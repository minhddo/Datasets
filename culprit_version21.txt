==========
Aggregation_Algebras
*** Failed to refine any pending goal
*** At command "qed" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Aggregation_Algebras/Minimum_Spanning_Trees.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 567 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Aggregation_Algebras/Minimum_Spanning_Trees.thy")

==========
Amortized_Complexity
*** Failed to load theory "Amortized_Complexity.Pairing_Heap_List2_Analysis" (unresolved "Pairing_Heap.Pairing_Heap_List2")
*** Failed to load theory "Amortized_Complexity.Pairing_Heap_List1_Analysis" (unresolved "Pairing_Heap.Pairing_Heap_List1")
*** Failed to load theory "Amortized_Complexity.Pairing_Heap_List1_Analysis2" (unresolved "Amortized_Complexity.Pairing_Heap_List1_Analysis")
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀x hs Union_mset.
***    mset_heap (Hp x hs) = {#x#} + Union_mset (mset (map mset_heap hs))
*** At command "fun" (line 72 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List1.thy")
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀x hs Union_mset.
***    mset_hp (Hp x hs) = {#x#} + Union_mset (mset (map mset_hp hs))
*** At command "fun" (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List2.thy")

==========
ArrowImpossibilityGS
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦a <⇘F (λi. if h i < ?n then Lab else Lba)⇙ b;
***    (a, b) ∉ F (λi. if h i < 0 then Lab else Lba)⟧
***   ⟹ ∃k<?n.
***         (∀i≤k. (a, b) ∉ F (λia. if h ia < i then Lab else Lba)) ∧
***         a <⇘F (λi. if h i < Suc k then Lab else Lba)⇙ b
***   (a, b) ∉ F (λi. if h i < 0 then Lab else Lba)
***   a <⇘F (λi. if h i < N then Lab else Lba)⇙ b
*** At command "with" (line 277 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/ArrowImpossibilityGS/Thys/Arrow_Order.thy")

==========
Auto2_HOL
*** Failed to load theory "Auto2_HOL.Lists_Thms" (unresolved "Auto2_HOL.Set_Thms")
*** Failed to load theory "Auto2_HOL.Auto2_Main" (unresolved "Auto2_HOL.Lists_Thms")
*** Failed to load theory "Auto2_HOL.Auto2_Test" (unresolved "Auto2_HOL.Auto2_Main")
*** Undefined fact: "card_empty" (line 139 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Auto2_HOL/HOL/Set_Thms.thy")
*** At command "setup" (line 139 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Auto2_HOL/HOL/Set_Thms.thy")

==========
AWN
*** Failed to refine any pending goal
*** At command "by" (line 1203 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/AWN/OClosed_Transfer.thy")
*** Failed to refine any pending goal
*** At command "by" (line 995 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/AWN/OClosed_Transfer.thy")

==========
Banach_Steinhaus
*** Undefined fact: "real_mult_le_cancel_iff2" (line 459 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus.thy")
*** At command "by" (line 458 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus.thy")
*** Failed to finish proof (line 249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus.thy"):
*** goal (1 subgoal):
***  1. (⋀n. (1 / 3) ^ n = inverse (3 ^ n)) ⟹ summable (λn. inverse (3 ^ n))
*** At command "by" (line 249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus.thy")
*** Undefined fact: "real_mult_le_cancel_iff2" (line 218 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus_Missing.thy")
*** At command "using" (line 218 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Banach_Steinhaus/Banach_Steinhaus_Missing.thy")

==========
Binomial-Heaps
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀e a q Union_mset.
***    elem_to_mset (Element e a q) =
***    {#(e, a)#} +
***    Union_mset
***     (image_mset elem_to_mset
***       (image_mset fst
***         (SkewBinomialHeapStruc.queue_to_multiset (map bsmapt q))))
*** At command "function" (line 2067 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Binomial-Heaps/SkewBinomialHeap.thy")

==========
Bondy
*** Undefined fact: "card_infinite" (line 14 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Bondy/Bondy.thy")
*** At command "by" (line 14 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Bondy/Bondy.thy")

==========
Buildings
*** Failed to finish proof (line 1843 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Buildings/Algebra.thy"):
*** goal (2 subgoals):
***  1. ⋀P a b xs.
***        ⟦b = [] ⟹ P; a = [] ⟹ P;
***         ⋀xs aa ba ab bb ys. a = xs @ [(aa, ba)] ∧ b = (ab, bb) # ys ⟹ P;
***         a = xs ∧ b = []⟧
***        ⟹ P
***  2. ⋀P a b ys.
***        ⟦b = [] ⟹ P; a = [] ⟹ P;
***         ⋀xs aa ba ab bb ys. a = xs @ [(aa, ba)] ∧ b = (ab, bb) # ys ⟹ P;
***         a = [] ∧ b = ys⟧
***        ⟹ P
*** At command "by" (line 1843 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Buildings/Algebra.thy")
*** Failed to finish proof (line 71 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Buildings/Simplicial.thy"):
*** goal (1 subgoal):
***  1. ⋀xa. ⟦z ⊲ insert v z; v ∉ z; f ` x = insert v z; u ≡ the_inv_into x f v;
***           y ≡ {v ∈ x. f v ∈ z}; ⋀xa. xa ∈ x ⟹ the_inv_into x f (f xa) = xa;
***           ⋀xa B.
***              ⟦xa = v ∨ xa ∈ z; order.greater_eq B x⟧
***              ⟹ the_inv_into x f xa ∈ B;
***           xa ∈ x; xa ≠ the_inv_into x f v⟧
***          ⟹ f xa ∈ z
*** At command "by" (line 71 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Buildings/Simplicial.thy")

==========
BytecodeLogicJmlTypes
*** Failed to apply proof method (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Language.thy"):
*** goal (1 subgoal):
***  1. ⋀n k w ad ae bb la af ag bc ll ah ai bd m ha va nb ma.
***        ⟦∀v. ((ad, ae, bb), lla, (a, aa, b), m, ha, v) ∈ Exec ⟶
***             (∀n2 k w.
***                 ((ad, ae, bb), lla, (a, aa, b), n2, k, w) ∈ Exec ⟶
***                 m = n2 ∧ ha = k ∧ v = w);
***         ((ad, ae, bb), ll, (ah, ai, bd), m, ha, va) ∈ Exec; nb ≤ n; m ≤ n;
***         ((ad, ae, bb), la, (af, ag, bc), nb, ll, ah, ai, bd) ∈ Step;
***         ((ad, ae, bb), ll, (ah, ai, bd), ma, k, w) ∈ Exec⟧
***        ⟹ max nb m = max nb ma
*** At command "apply" (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Language.thy")
*** Failed to apply proof method (line 1075 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Cachera.thy"):
*** goal (3 subgoals):
***  1. ⋀Σ k e m x G C ma T MI Anno la codea pa code1a l1a a b.
***        ⟦∀l1. (l1a + 1, code1a[l1a↦store xa], e, a, l1) ∈ compileExpr ⟶
***              (∀G C ma.
***                  (∃T MI Anno. MST↓(C, ma) = Some (T, MI, Anno)) ⟶
***                  Segment C ma (l1a + 1) l1 a ⟶
***                  deriv G C ma (l1a + 1) (Cachera m));
***         (Σ, pa, k) ∈ TP_prim; (Σ, e, m) ∈ TP_expr; Sig_good Σ;
***         MST↓(C, ma) = Some (T, MI, Anno); Segment C ma la b a;
***         (la, codea, pa, code1a, l1a) ∈ compilePrim;
***         (l1a + 1, code1a[l1a↦store x], e, a, b) ∈ compileExpr; la < l1a;
***         l1a + 1 < b; ∀ll≥la. ll < l1a ⟶ (∃ins. code1a↓ll = Some ins);
***         ∀ll≤l1a. a↓ll = code1a[l1a↦store x]↓ll;
***         ∀ll≥l1a + 1. ll < b ⟶ (∃ins. a↓ll = Some ins)⟧
***        ⟹ deriv G C ma la (Cachera (k + m))
***  2. ⋀Σ e1 n e2 x.
***        ⟦(Σ, e1, n) ∈ TP_expr;
***         Sig_good Σ ⟶
***         (∀l code code1 l1 G C m T MI Anno.
***             (l, code, e1, code1, l1) ∈ compileExpr ⟶
***             MST↓(C, m) = Some (T, MI, Anno) ⟶
***             Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n));
***         (Σ, e2, n) ∈ TP_expr;
***         Sig_good Σ ⟶
***         (∀l code code1 l1 G C m T MI Anno.
***             (l, code, e2, code1, l1) ∈ compileExpr ⟶
***             MST↓(C, m) = Some (T, MI, Anno) ⟶
***             Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n))⟧
***        ⟹ Sig_good Σ ⟶
***           (∀l code code1 l1 G C m T MI Anno.
***               (l, code, CondE x e1 e2, code1, l1) ∈ compileExpr ⟶
***               MST↓(C, m) = Some (T, MI, Anno) ⟶
***               Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n))
***  3. ⋀Σ e1 n e2 x h t.
***        ⟦(Σ, e1, n) ∈ TP_expr;
***         Sig_good Σ ⟶
***         (∀l code code1 l1 G C m T MI Anno.
***             (l, code, e1, code1, l1) ∈ compileExpr ⟶
***             MST↓(C, m) = Some (T, MI, Anno) ⟶
***             Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n));
***         (Σ, e2, n) ∈ TP_expr;
***         Sig_good Σ ⟶
***         (∀l code code1 l1 G C m T MI Anno.
***             (l, code, e2, code1, l1) ∈ compileExpr ⟶
***             MST↓(C, m) = Some (T, MI, Anno) ⟶
***             Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n))⟧
***        ⟹ Sig_good Σ ⟶
***           (∀l code code1 l1 G C m T MI Anno.
***               (l, code, MatchE x e1 h t e2, code1, l1) ∈ compileExpr ⟶
***               MST↓(C, m) = Some (T, MI, Anno) ⟶
***               Segment C m l l1 code1 ⟶ deriv G C m l (Cachera n))
*** At command "apply" (line 1075 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Cachera.thy")
*** Failed to apply proof method (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Cachera.thy"):
*** goal (1 subgoal):
***  1. ⋀args par body l0 G C m T MI k la codea x aa b.
***        ⟦∀l1. (la + 1, codea[la↦load x], CallPrim f args, ab, l1)
***              ∈ compilePrim ⟶
***              (∀G C m.
***                  (∃T MI. MST↓(C, m) = Some (T, MI, Anno)) ⟶
***                  Segment C m (la + 1) l1 ab ⟶
***                  (∀k. derivAssum G C m l1 (Cachera k) ⟶
***                       deriv G C m (la + 1) (Cachera (n + k))));
***         Σ↓f = Some n; MST↓f = Some (mkSPEC (Cachera n) Anno2);
***         mbody_is (fst f) (snd f) (par, body, l0);
***         MST↓(C, m) = Some (T, MI, Anno); Segment C m la b aa;
***         derivAssum G C m b (Cachera k);
***         (la + 1, codea[la↦load x], CallPrim f args, aa, b) ∈ compilePrim⟧
***        ⟹ deriv G C m la (Cachera (n + k))
*** At command "apply" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Cachera.thy")
*** Failed to apply proof method (line 558 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Sound.thy"):
*** goal (9 subgoals):
***  1. ⋀C m aa b l ins Mspec Minv Anno A I c x f g d F G B CD ab ad bb ae af bc
***        k h v n a ac ba ma.
***        ⟦∀ac ba.
***            (∃k. ((ab, aa, b), b, mkState (ad, bb), k, l + 1, a, ac, ba)
***                 ∈ MStep) ⟶
***            SP_pre (ab, aa, b) l A (ad, bb) (a, ac, ba) ⟶
***            (∀k≤K. (∀h v. ((ab, aa, b), l + 1, (a, ac, ba), k, h, v)
***                          ∈ Exec ⟶
***                          SP_post (ab, aa, b) l B (ad, bb) (a, ac, ba)
***                           (h, v)) ∧
***                   (∀ll ae af bc.
***                       (((ab, aa, b), l + 1, (a, ac, ba), k, ll, ae, af, bc)
***                        ∈ MStep ⟶
***                        (∀Q. Anno↓ll = Some Q ⟶ Q (ad, bb) (ae, af, bc))) ∧
***                       (((ab, aa, b), l + 1, (a, ac, ba), k, ae, af, bc)
***                        ∈ Reachable ⟶
***                        SP_inv (ab, aa, b) l I (ad, bb) (a, ac, ba)
***                         (heap (ae, af, bc)))));
***         G_validn K G; MST_validn K; get_ins (ab, aa, b) l = Some ins;
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶
***             (∀a b aa ab ba. A (a, b) (aa, ab, ba) ⟶ Q (a, b) (aa, ab, ba));
***         ∀a b aa ab ba.
***            A (a, b) (aa, ab, ba) ⟶
***            I (a, b) (aa, ab, ba) (heap (aa, ab, ba));
***         ins = const c ∨
***         ins = dup ∨
***         ins = pop ∨
***         ins = swap ∨
***         ins = load x ∨
***         ins = store x ∨
***         ins = binop f ∨
***         ins = unop g ∨
***         ins = new d ∨
***         ins = getfield d F ∨ ins = putfield d F ∨ ins = checkcast d;
***         CD↓m = Some (ab, aa, b); P↓C = Some CD;
***         ((ab, aa, b), b, mkState (ad, bb), k, l, ae, af, bc) ∈ MStep;
***         A (ad, bb) (ae, af, bc);
***         ((ab, aa, b), l, (ae, af, bc), n, l + 1, a, ac, ba) ∈ Step;
***         ((ab, aa, b), l + 1, (a, ac, ba), ma, h, v) ∈ Exec; n ≤ K; ma ≤ K⟧
***        ⟹ B (ad, bb) (ae, af, bc) (h, v)
***  2. ⋀C m aa b l ins Mspec Minv Anno A I c x f g d F G B CD ab ad bb ae af bc
***        k ka.
***        ⟦G_validn K G; MST_validn K;
***         ∀a ba ac ad bb.
***            (∃k. ((ab, aa, b), b, mkState (a, ba), k, l + 1, ac, ad, bb)
***                 ∈ MStep) ⟶
***            SP_pre (ab, aa, b) l A (a, ba) (ac, ad, bb) ⟶
***            (∀k≤K. (∀h v. ((ab, aa, b), l + 1, (ac, ad, bb), k, h, v)
***                          ∈ Exec ⟶
***                          SP_post (ab, aa, b) l B (a, ba) (ac, ad, bb)
***                           (h, v)) ∧
***                   (∀ll ae af bc.
***                       (((ab, aa, b), l + 1, (ac, ad, bb), k, ll, ae, af, bc)
***                        ∈ MStep ⟶
***                        (∀Q. Anno↓ll = Some Q ⟶ Q (a, ba) (ae, af, bc))) ∧
***                       (((ab, aa, b), l + 1, (ac, ad, bb), k, ae, af, bc)
***                        ∈ Reachable ⟶
***                        SP_inv (ab, aa, b) l I (a, ba) (ac, ad, bb)
***                         (heap (ae, af, bc)))));
***         get_ins (ab, aa, b) l = Some ins;
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶
***             (∀a b aa ab ba. A (a, b) (aa, ab, ba) ⟶ Q (a, b) (aa, ab, ba));
***         ∀a b aa ab ba.
***            A (a, b) (aa, ab, ba) ⟶
***            I (a, b) (aa, ab, ba) (heap (aa, ab, ba));
***         ins = const c ∨
***         ins = dup ∨
***         ins = pop ∨
***         ins = swap ∨
***         ins = load x ∨
***         ins = store x ∨
***         ins = binop f ∨
***         ins = unop g ∨
***         ins = new d ∨
***         ins = getfield d F ∨ ins = putfield d F ∨ ins = checkcast d;
***         CD↓m = Some (ab, aa, b); P↓C = Some CD;
***         ((ab, aa, b), b, mkState (ad, bb), k, l, ae, af, bc) ∈ MStep;
***         A (ad, bb) (ae, af, bc); ka ≤ Suc K⟧
***        ⟹ ∀ll a ac ba.
***              (((ab, aa, b), l, (ae, af, bc), ka, ll, a, ac, ba) ∈ MStep ⟶
***               (∀Q. Anno↓ll = Some Q ⟶ Q (ad, bb) (a, ac, ba))) ∧
***              (((ab, aa, b), l, (ae, af, bc), ka, a, ac, ba) ∈ Reachable ⟶
***               I (ad, bb) (ae, af, bc) (heap (a, ac, ba)))
***  3. ⋀C m M l pc Mspec Minv Anno A I G B.
***        ⟦mbody_is C m M; get_ins M l = Some (goto pc);
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶ (∀s0 s. A s0 s ⟶ Q s0 s);
***         ∀s0 s. A s0 s ⟶ I s0 s (heap s);
***         G ⊳ ⟨ SP_pre M l A ⟩ C,m,pc ⟨ SP_post M l B ⟩ SP_inv M l I;
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (True ⟶
***          ⊨⇩K ⦃ SP_pre M l A ⦄ C , m , pc ⦃ SP_post M l B ⦄ SP_inv M l I ) ∧
***         (¬ True ⟶
***          ⊨⇩Suc K ⦃ SP_pre M l
***                    A ⦄ C , m , pc ⦃ SP_post M l B ⦄ SP_inv M l I )⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (False ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ False ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  4. ⋀C m M l pc Mspec Minv Anno A I G B.
***        ⟦mbody_is C m M; get_ins M l = Some (iftrue pc);
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶ (∀s0 s. A s0 s ⟶ Q s0 s);
***         ∀s0 s. A s0 s ⟶ I s0 s (heap s);
***         G ⊳ ⟨ SP_pre M l
***                (λs0 s.
***                    ∀ops S k.
***                       s = (TRUE # ops, S, k) ⟶
***                       A s0
***                        s) ⟩ C,m,pc ⟨ SP_post M l
*** (λs0 s t.
***     ∀ops S k.
***        s = (TRUE # ops, S, k) ⟶
***        B s0 s
***         t) ⟩ SP_inv M l
***               (λs0 s t. ∀ops S k. s = (TRUE # ops, S, k) ⟶ I s0 s t);
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (True ⟶
***          ⊨⇩K ⦃ SP_pre M l
***                (λs0 s.
***                    ∀ops S k.
***                       s = (TRUE # ops, S, k) ⟶
***                       A s0
***                        s) ⦄ C , m , pc ⦃ SP_post M l
***     (λs0 s t.
***         ∀ops S k.
***            s = (TRUE # ops, S, k) ⟶
***            B s0 s
***             t) ⦄ SP_inv M l
***                   (λs0 s t.
***                       ∀ops S k. s = (TRUE # ops, S, k) ⟶ I s0 s t) ) ∧
***         (¬ True ⟶
***          ⊨⇩Suc K ⦃ SP_pre M l
***                    (λs0 s.
***                        ∀ops S k.
***                           s = (TRUE # ops, S, k) ⟶
***                           A s0
***                            s) ⦄ C , m , pc ⦃ SP_post M l
***         (λs0 s t.
***             ∀ops S k.
***                s = (TRUE # ops, S, k) ⟶
***                B s0 s
***                 t) ⦄ SP_inv M l
***                       (λs0 s t.
***                           ∀ops S k. s = (TRUE # ops, S, k) ⟶ I s0 s t) );
***         G ⊳ ⟨ SP_pre M l
***                (λs0 s.
***                    ∀ops S k v.
***                       s = (v # ops, S, k) ⟶
***                       v ≠ TRUE ⟶
***                       A s0
***                        s) ⟩ C,m,(l +
***                                  1) ⟨ SP_post M l
***  (λs0 s t.
***      ∀ops S k v.
***         s = (v # ops, S, k) ⟶
***         v ≠ TRUE ⟶
***         B s0 s
***          t) ⟩ SP_inv M l
***                (λs0 s t.
***                    ∀ops S k v. s = (v # ops, S, k) ⟶ v ≠ TRUE ⟶ I s0 s t);
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (True ⟶
***          ⊨⇩K ⦃ SP_pre M l
***                (λs0 s.
***                    ∀ops S k v.
***                       s = (v # ops, S, k) ⟶
***                       v ≠ TRUE ⟶
***                       A s0
***                        s) ⦄ C , m , (l +
***                                      1) ⦃ SP_post M l
***      (λs0 s t.
***          ∀ops S k v.
***             s = (v # ops, S, k) ⟶
***             v ≠ TRUE ⟶
***             B s0 s
***              t) ⦄ SP_inv M l
***                    (λs0 s t.
***                        ∀ops S k v.
***                           s = (v # ops, S, k) ⟶ v ≠ TRUE ⟶ I s0 s t) ) ∧
***         (¬ True ⟶
***          ⊨⇩Suc K ⦃ SP_pre M l
***                    (λs0 s.
***                        ∀ops S k v.
***                           s = (v # ops, S, k) ⟶
***                           v ≠ TRUE ⟶
***                           A s0
***                            s) ⦄ C , m , (l +
***    1) ⦃ SP_post M l
***          (λs0 s t.
***              ∀ops S k v.
***                 s = (v # ops, S, k) ⟶
***                 v ≠ TRUE ⟶
***                 B s0 s
***                  t) ⦄ SP_inv M l
***                        (λs0 s t.
***                            ∀ops S k v.
***                               s = (v # ops, S, k) ⟶
***                               v ≠ TRUE ⟶ I s0 s t) )⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (False ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ False ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  5. ⋀C m M l Mspec Minv Anno A I B G.
***        ⟦mbody_is C m M; get_ins M l = Some vreturn;
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶ (∀s0 s. A s0 s ⟶ Q s0 s);
***         ∀s0 s. A s0 s ⟶ I s0 s (heap s);
***         ∀s0 s. A s0 s ⟶ (∀v ops S h. s = (v # ops, S, h) ⟶ B s0 s (h, v))⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (False ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ False ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  6. ⋀C m M l D m' Mspec Minv Anno T MI Anno2 par code l0 A I G B.
***        ⟦mbody_is C m M; get_ins M l = Some (invokeS D m');
***         MST↓(C, m) = Some (Mspec, Minv, Anno);
***         MST↓(D, m') = Some (T, MI, Anno2); mbody_is D m' (par, code, l0);
***         ∀Q. Anno↓l = Some Q ⟶ (∀s0 s. A s0 s ⟶ Q s0 s);
***         ∀s0 s. A s0 s ⟶ I s0 s (heap s);
***         ∀s0 ops1 ops2 S R k t.
***            (ops1, par, R, ops2) ∈ Frame ⟶
***            A s0 (ops1, S, k) ⟶ MI (R, k) t ⟶ I s0 (ops1, S, k) t;
***         G ⊳ ⟨ SINV_pre par T
***                A ⟩ C,m,(l + 1) ⟨ SINV_post par T B ⟩ SINV_inv par T I;
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (True ⟶
***          ⊨⇩K ⦃ SINV_pre par T
***                A ⦄ C , m , (l +
***                             1) ⦃ SINV_post par T B ⦄ SINV_inv par T I ) ∧
***         (¬ True ⟶
***          ⊨⇩Suc K ⦃ SINV_pre par T
***                    A ⦄ C , m , (l +
***                                 1) ⦃ SINV_post par T B ⦄ SINV_inv par T I )⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (False ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ False ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  7. ⋀b G C m l AA BB II A B I.
***        ⟦(b, G, C, m, l, AA, BB, II) ∈ SP_Judgement;
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (b ⟶ ⊨⇩K ⦃ AA ⦄ C , m , l ⦃ BB ⦄ II ) ∧
***         (¬ b ⟶ ⊨⇩Suc K ⦃ AA ⦄ C , m , l ⦃ BB ⦄ II );
***         ∀s0 s. A s0 s ⟶ AA s0 s; ∀s0 s t. BB s0 s t ⟶ B s0 s t;
***         ∀s0 s k. II s0 s k ⟶ I s0 s k⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (b ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ b ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  8. ⋀G A C m l B I.
***        ⟦G ⊳ ⦃ A ⦄ C,m,l ⦃ B ⦄ I;
***         G_validn K G ⟶
***         MST_validn K ⟶
***         (False ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***         (¬ False ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (True ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ True ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
***  9. ⋀G C m l A B I Mspec Minv Anno.
***        ⟦G↓(C, m, l) = Some (A, B, I); MST↓(C, m) = Some (Mspec, Minv, Anno);
***         ∀Q. Anno↓l = Some Q ⟶ (∀s0 s. A s0 s ⟶ Q s0 s);
***         ∀s0 s. A s0 s ⟶ I s0 s (heap s)⟧
***        ⟹ G_validn K G ⟶
***           MST_validn K ⟶
***           (True ⟶ ⊨⇩K ⦃ A ⦄ C , m , l ⦃ B ⦄ I ) ∧
***           (¬ True ⟶ ⊨⇩Suc K ⦃ A ⦄ C , m , l ⦃ B ⦄ I )
*** At command "apply" (line 558 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Sound.thy")
*** Failed to apply proof method (line 345 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Sound.thy"):
*** goal (3 subgoals):
***  1. ⋀Mspec Minv Annoa par code l0 ab ba ac ad bb h v ll a aa b.
***        ⟦INVS_SC C m l D m' T MI Anno Anno2 M' A I; G_validn 0 G;
***         MST_validn 0; mbody_is C m (par, code, l0);
***         MST↓(C, m) = Some (Mspec, Minv, Annoa);
***         ∀a b aa ab ba.
***            MS (par, code, l0) l0 (mkState (a, b)) (l + 1) (aa, ab, ba) ⟶
***            SINV_pre (fst M') T A (a, b) (aa, ab, ba) ⟶
***            (∀h v. ((par, code, l0), l + 1, (aa, ab, ba), 0, h, v) ∈ Exec ⟶
***                   SINV_post (fst M') T B (a, b) (aa, ab, ba) (h, v)) ∧
***            (∀ll ac ad bb.
***                (((par, code, l0), l + 1, (aa, ab, ba), 0, ll, ac, ad, bb)
***                 ∈ MStep ⟶
***                 (∀Q. Annoa↓ll = Some Q ⟶ Q (a, b) (ac, ad, bb))) ∧
***                (((par, code, l0), l + 1, (aa, ab, ba), 0, ac, ad, bb)
***                 ∈ Reachable ⟶
***                 SINV_inv (fst M') T I (a, b) (aa, ab, ba)
***                  (heap (ac, ad, bb))));
***         MS (par, code, l0) l0 (mkState (ab, ba)) l (ac, ad, bb);
***         A (ab, ba) (ac, ad, bb);
***         ((par, code, l0), l, (ac, ad, bb), 0, ll, a, aa, b) ∈ Step;
***         ((par, code, l0), ll, (a, aa, b), 0, h, v) ∈ Exec⟧
***        ⟹ B (ab, ba) (ac, ad, bb) (h, v)
***  2. ⋀M Mspec Minv Annoa par code l0 s0 s k.
***        ⟦INVS_SC C m l D m' T MI Anno Anno2 M' A I; G_validn 0 G;
***         MST_validn 0; mbody_is C m M;
***         MST↓(C, m) = Some (Mspec, Minv, Annoa); M = (par, code, l0);
***         ∀s0 s.
***            MS M l0 (mkState s0) (l + 1) s ⟶
***            SINV_pre (fst M') T A s0 s ⟶
***            (∀k≤0. (∀h v. (M, l + 1, s, k, h, v) ∈ Exec ⟶
***                          SINV_post (fst M') T B s0 s (h, v)) ∧
***                   (∀ll r.
***                       ((M, l + 1, s, k, ll, r) ∈ MStep ⟶
***                        (∀Q. Annoa↓ll = Some Q ⟶ Q s0 r)) ∧
***                       ((M, l + 1, s, k, r) ∈ Reachable ⟶
***                        SINV_inv (fst M') T I s0 s (heap r))));
***         MS M l0 (mkState s0) l s; A s0 s; k ≤ Suc 0⟧
***        ⟹ ∀ll r.
***              ((M, l, s, k, ll, r) ∈ MStep ⟶
***               (∀Q. Annoa↓ll = Some Q ⟶ Q s0 r)) ∧
***              ((M, l, s, k, r) ∈ Reachable ⟶ I s0 s (heap r))
***  3. ⋀K. INVS_soundK K G C m l D m' T MI Anno Anno2 M' A B I ⟹
***         INVS_soundK (Suc K) G C m l D m' T MI Anno Anno2 M' A B I
*** At command "apply" (line 345 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/BytecodeLogicJmlTypes/Sound.thy")

==========
Card_Multisets
*** Undefined fact: "card_empty" (line 193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Multisets/Card_Multisets.thy")
*** At command "by" (line 193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Multisets/Card_Multisets.thy")

==========
Card_Number_Partitions
*** Undefined fact: "card_empty" (line 146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** At command "by" (line 146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** Undefined fact: "card_empty" (line 306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** At command "by" (line 306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")

==========
Card_Partitions
*** Undefined fact: "card_empty" (line 350 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Partitions/Card_Partitions.thy")
*** At command "by" (line 350 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Partitions/Card_Partitions.thy")

==========
Case_Labeling
*** Failed to load theory "Case_Labeling.Labeled_Hoare_Examples" (unresolved "Case_Labeling.Labeled_Hoare")
*** Failed to load theory "Case_Labeling.Case_Labeling_Examples" (unresolved "Case_Labeling.Labeled_Hoare_Examples")
*** Undefined constant: "_Seq"
*** At command "lemma" (line 12 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Case_Labeling/Examples/Hoare/Labeled_Hoare.thy")

==========
Circus
*** Failed to load theory "Circus.Refinement" (unresolved "Circus.Circus_Syntax")
*** Failed to load theory "Circus.Refinement_Example" (unresolved "Circus.Refinement")
*** ML error (line 154 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Circus/Circus_Syntax.thy"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML" (line 94 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Circus/Circus_Syntax.thy")
*** Failed to apply proof method (line 374 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Circus/Circus_Actions.thy"):
*** goal (8 subgoals):
***  1. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ¬ ok ba; wait ba; wait b; ¬ ok b;
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  2. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ¬ ok ba; wait ba; wait b;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈);
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  3. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ¬ ok ba; ¬ wait ba; ¬ wait b; ¬ ok b;
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  4. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ¬ ok ba; ¬ wait ba; ¬ wait b;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈);
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  5. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ok b; wait ba; wait b;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈);
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  6. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ok b; ¬ wait ba; ¬ wait b;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈);
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := False⦈)⟧
***        ⟹ False
***  7. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ok b; ok ba;
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := True⦈);
***         wait ba; wait b⟧
***        ⟹ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈)
***  8. ⋀b aa ba xa xb.
***        ⟦tr ba = tr b; ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;
***         xa ∈ A; ¬ wait aa; tr aa ≤ tr b; ok aa;
***         ¬ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b
***             ⦇tr := tr b - tr aa, ok := False⦈);
***         xb ∈ A; ok b; ok ba;
***         action.relation_of xa
***          (aa⦇tr := [], wait := False⦈, ba⦇tr := tr b - tr aa, ok := True⦈);
***         ¬ wait ba; ¬ wait b⟧
***        ⟹ action.relation_of xa
***            (aa⦇tr := [], wait := False⦈, b⦇tr := tr b - tr aa, ok := True⦈)
*** At command "apply" (line 374 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Circus/Circus_Actions.thy")

==========
Complex_Geometry
*** Failed to finish proof (line 866 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/Unit_Circle_Preserving_Moebius.thy"):
*** goal (1 subgoal):
***  1. ⋀φ a'.
***        ⟦⋀φ'. a = cnj a * cis φ' ∧ (a' = 0 ∨ cis φ = cis φ') ⟹ thesis;
***         a ≠ 0; k ≠ 0; a * cnj a ≠ b * cnj b;
***         M =
***         (k * cnj a * cis φ, - (k * cnj a * cis φ * a'),
***          - (k * cnj a * cnj a'), k * cnj a);
***         a' * cnj a' ≠ 1; a = cnj a * cis φ;
***         k * b = - (k * cnj a * cis φ * a');
***         k * cnj b = - (k * cnj a * cnj a')⟧
***        ⟹ thesis
*** At command "by" (line 866 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/Unit_Circle_Preserving_Moebius.thy")
*** Failed to finish proof (line 270 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/Unit_Circle_Preserving_Moebius.thy"):
*** goal (1 subgoal):
***  1. ⟦0 < k;
***      mat_adj M *⇩m⇩m (1 / cor k, 0, 0, - (1 / cor k)) *⇩m⇩m M = (1, 0, 0, - 1);
***      mat_det M ≠ 0;
***      mat_adj (mat_inv M) *⇩m⇩m (1, 0, 0, - 1) *⇩m⇩m mat_inv M =
***      (1 / cor k, 0, 0, - (1 / cor k));
***      (1, 0, 0, - 1) = (1 / cor k) *⇩s⇩m (mat_adj M *⇩m⇩m (1, 0, 0, - 1) *⇩m⇩m M)⟧
***     ⟹ mat_adj M *⇩m⇩m (1, 0, 0, - 1) *⇩m⇩m M = (cor k, 0, 0, - cor k)
*** At command "by" (line 270 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/Unit_Circle_Preserving_Moebius.thy")
*** Undefined fact: "card_infinite" (line 60 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/More_Set.thy")
*** At command "using" (line 60 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/More_Set.thy")
*** Undefined fact: "card_infinite" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/More_Set.thy")
*** At command "using" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Complex_Geometry/More_Set.thy")

==========
ConcurrentGC
*** More names than parameters in subgoal!
*** At command "apply" (line 2731 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/ConcurrentGC/StrongTricolour.thy")

==========
Consensus_Refined
*** Undefined fact: "card_empty" (line 353 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Consensus_Refined/MRU/Paxos_Proofs.thy")
*** At command "by" (line 353 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Consensus_Refined/MRU/Paxos_Proofs.thy")
*** Undefined fact: "card_empty" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Consensus_Refined/MRU/CT_Proofs.thy")
*** At command "by" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Consensus_Refined/MRU/CT_Proofs.thy")

==========
Constructor_Funs
*** Failed to load theory "Constructor_Funs.Test_Constructor_Funs" (unresolved "Constructor_Funs.Constructor_Funs")
*** ML error (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Constructor_Funs/constructor_funs.ML"):
*** Value or constructor (open_target) has not been declared in structure Local_Theory
*** ML error (line 85 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Constructor_Funs/constructor_funs.ML"):
*** Value or constructor (close_target) has not been declared in structure Local_Theory
*** At command "ML_file" (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Constructor_Funs/Constructor_Funs.thy")

==========
CoreC++
*** Undefined fact: "card_infinite" (line 457 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CoreC++/Execute.thy")
*** At command "apply" (line 457 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CoreC++/Execute.thy")
*** Failed to apply proof method (line 99 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CoreC++/Execute.thy"):
*** goal (1 subgoal):
***  1. ⋀a ys aa lista.
***        ⟦⋀ys. map Val lista = map Val ys ⟹ map_val (map Val ys) ys;
***         a = Val aa; ys = aa # lista⟧
***        ⟹ map_val (Val aa # map Val lista) (aa # lista)
*** At command "apply" (line 99 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CoreC++/Execute.thy")

==========
Core_DOM
*** Failed to apply initial proof method (line 153 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Core_DOM/monads/BaseMonad.thy"):
*** using this:
***     Complete_Partial_Order.chain (flat_ord (Inl e)) {y. ∃f∈A. y = f ?a}
***     flat_lub (Inl e) {y. ∃f∈A. y = f ?a1} = ?a ⟹
***     ?a = Inl e ∨ ?a ∈ {y. ∃f∈A. y = f ?a1}
***     ∀xa∈A. ∀h h2 r. the_prog (Prog xa) h = Inr (r, h2) ⟶ P h h2 r
***     the_prog (Prog (λx. flat_lub (Inl e) {y. ∃f∈A. y = f x})) h =
***     Inr (r, h2)
*** goal (1 subgoal):
***  1. P h h2 r
*** At command "by" (line 153 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Core_DOM/monads/BaseMonad.thy")
*** Failed to finish proof (line 174 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Core_DOM/monads/BaseMonad.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀a. flat_lub (Inl e) {y. ∃f∈A. y = f a} = Inl e ∨
***          (∃f∈A. flat_lub (Inl e) {y. ∃f∈A. y = f a} = f a);
***      flat_lub (Inl e) {y. ∃f∈A. y = f h} = Inr (r, h2)⟧
***     ⟹ ∃f∈A. Inr (r, h2) = f h
*** At command "by" (line 174 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Core_DOM/monads/BaseMonad.thy")

==========
Count_Complex_Roots
*** Failed to apply initial proof method (line 2237 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Winding_Number_Eval/Winding_Number_Eval.thy"):
*** goal (1 subgoal):
***  1. z0 +
***     complex_of_real r *
***     (cos (complex_of_real ((1 - 0) *⇩R (2 * pi) + 0 *⇩R tt)) +
***      𝗂 * sin (complex_of_real ((1 - 0) *⇩R (2 * pi) + 0 *⇩R tt))) =
***     z0 + complex_of_real r
*** At command "by" (line 2237 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Winding_Number_Eval/Winding_Number_Eval.thy")
*** Undefined fact: "card_empty" (line 190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Count_Complex_Roots/More_Polynomials.thy")
*** At command "by" (line 190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Count_Complex_Roots/More_Polynomials.thy")

==========
CRDT
*** Type unification failed
*** 
*** Failed to meet type constraint:
*** 
*** Term:  m :: 'op
*** Type:  bool
*** 
*** At command "apply" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CRDT/Network.thy")

==========
CSP_RefTK
*** Failed to apply initial proof method (line 783 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CSP_RefTK/DiningPhilosophers.thy"):
*** using this:
***     fs ! 0 = 0
***     e = picks 0 0
***     (∀i. Suc i < N ⟶ (fs ! Suc i = 1) = (ps ! Suc i ≠ 0)) ∧
***     (fs ! (N - 1) = 2) = (ps ! 0 ≠ 0) ∧
***     (∀i<N - 1. (fs ! i = 2) = (ps ! Suc i = 2)) ∧
***     (fs ! 0 = 1) = (ps ! 0 = 2) ∧
***     (∀i<N. fs ! i = 0 ∨ fs ! i = 1 ∨ fs ! i = 2) ∧
***     (∀i<N. ps ! i = 0 ∨ ps ! i = 1 ∨ ps ! i = 2 ∨ ps ! i = 3) ∧
***     length fs = N ∧ length ps = N
***     s = (ps, fs)
***     ps ! 0 = Suc 0
***     of_bool (N ≠ Suc 0) = 0
***     1 < N
*** goal (1 subgoal):
***  1. (∀i. Suc i < N ⟶ (fs[0 := 2] ! Suc i = 1) = (ps[0 := 2] ! Suc i ≠ 0)) ∧
***     (fs[0 := 2] ! (N - 1) = 2) = (ps[0 := 2] ! 0 ≠ 0) ∧
***     (∀i<N - 1. (fs[0 := 2] ! i = 2) = (ps[0 := 2] ! Suc i = 2)) ∧
***     (fs[0 := 2] ! 0 = 1) = (ps[0 := 2] ! 0 = 2) ∧
***     (∀i<N. fs[0 := 2] ! i = 0 ∨ fs[0 := 2] ! i = 1 ∨ fs[0 := 2] ! i = 2) ∧
***     (∀i<N. ps[0 := 2] ! i = 0 ∨
***            ps[0 := 2] ! i = 1 ∨ ps[0 := 2] ! i = 2 ∨ ps[0 := 2] ! i = 3) ∧
***     length (fs[0 := 2]) = N ∧ length (ps[0 := 2]) = N
*** At command "by" (line 783 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/CSP_RefTK/DiningPhilosophers.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦s setinterleaves ((?t1.0, ?u), C); set ?t2.0 ∩ C = {}⟧
***   ⟹ s @ ?t2.0 setinterleaves ((?t1.0 @ ?t2.0, ?u), C)
***   aa ∈ C
***   s setinterleaves ((aa # lista, list), C)
*** At command "with" (line 1599 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")
*** Too many parameters for case "1" (line 1315 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")
*** At command "case" (line 1315 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")

==========
CYK
*** Interrupt

==========
Decreasing-Diagrams-II
*** Failed to finish proof (line 887 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Decreasing-Diagrams-II/Decreasing_Diagrams_II.thy"):
*** goal (2 subgoals):
***  1. ⋀za zb zc.
***        ⟦(t, u)
***         ∉ (⋃ (E ` (under r a ∩ under r b)) ∪
***            (⋃ (L ` (under r a ∩ under r b)) ∪
***             (⋃x∈under r a ∩ under r b. (L x)¯)))⇧* O
***           (Id ∪ L b) O
***           (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧* O
***           E a O
***           (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (za, u)
***         ∈ (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (zb, za) ∈ E a;
***         (zc, zb)
***         ∈ (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (t, zc)
***         ∈ (⋃ (E ` (under r a ∩ under r b)) ∪
***            (⋃ (L ` (under r a ∩ under r b)) ∪
***             (⋃x∈under r a ∩ under r b. (L x)¯)))⇧*⟧
***        ⟹ (t, u)
***           ∈ (⋃ (E ` under r a) ∪
***              (⋃ (L ` under r a) ∪ (⋃x∈under r a. (L x)¯)))⇧* O
***             (Id ∪ L b) O
***             (⋃ (E ` (under r a ∪ under r b)) ∪
***              (⋃ (L ` (under r a ∪ under r b)) ∪
***               (⋃x∈under r a ∪ under r b. (L x)¯)))⇧*
***  2. ⋀za zb yc zc.
***        ⟦(t, u)
***         ∉ (⋃ (E ` (under r a ∩ under r b)) ∪
***            (⋃ (L ` (under r a ∩ under r b)) ∪
***             (⋃x∈under r a ∩ under r b. (L x)¯)))⇧* O
***           (Id ∪ L b) O
***           (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧* O
***           E a O
***           (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (za, u)
***         ∈ (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (zb, za) ∈ E a;
***         (zc, zb)
***         ∈ (⋃ (E ` under r b) ∪
***            (⋃ (L ` under r b) ∪ (⋃x∈under r b. (L x)¯)))⇧*;
***         (t, yc)
***         ∈ (⋃ (E ` (under r a ∩ under r b)) ∪
***            (⋃ (L ` (under r a ∩ under r b)) ∪
***             (⋃x∈under r a ∩ under r b. (L x)¯)))⇧*;
***         (yc, zc) ∈ L b⟧
***        ⟹ (t, u)
***           ∈ (⋃ (E ` under r a) ∪
***              (⋃ (L ` under r a) ∪ (⋃x∈under r a. (L x)¯)))⇧* O
***             (Id ∪ L b) O
***             (⋃ (E ` (under r a ∪ under r b)) ∪
***              (⋃ (L ` (under r a ∪ under r b)) ∪
***               (⋃x∈under r a ∪ under r b. (L x)¯)))⇧*
*** At command "by" (line 887 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Decreasing-Diagrams-II/Decreasing_Diagrams_II.thy")

==========
Delta_System_Lemma
*** Undefined fact: "lepoll_imp_Card_le" (line 44 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Konig.thy")
*** At command "using" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Konig.thy")
*** Undefined fact: "lepoll_imp_Card_le" (line 653 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** At command "using" (line 653 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** Undefined fact: "lepoll_imp_Card_le" (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** At command "using" (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** Undefined fact: "lepoll_imp_Card_le" (line 116 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** At command "using" (line 116 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** Undefined fact: "lepoll_imp_Card_le" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")
*** At command "using" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Delta_System_Lemma/Cardinal_Library.thy")

==========
Dependent_SIFUM_Refinement
*** Cannot determine type of "xb" (line 42 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Dependent_SIFUM_Refinement/Examples/Eg1Eg2.thy")
*** At command "apply" (line 42 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Dependent_SIFUM_Refinement/Examples/Eg1Eg2.thy")

==========
Derangements
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦⋀n. ?f n ≤ ?g n; ?f sums ?s; ?g sums ?t⟧ ⟹ ?s ≤ ?t
***   (⋀x. ?P x) ⟹ ∀x. ?P x
*** At command "proof" (line 456 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Derangements/Derangements.thy")

==========
Diophantine_Eqns_Lin_Hom
*** Failed to finish proof (line 591 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy"):
*** goal (1 subgoal):
***  1. ⋀x. ⟦∃x∈set Seq. b ∙ x mod a ! k = 0 ⟹ thesis;
***          ∃i<a ! k.
***             ∃j<a ! k.
***                i ≠ j ∧
***                map ((∙) b) Seq ! i mod a ! k =
***                map ((∙) b) Seq ! j mod a ! k ⟹
***          thesis;
***          length Seq = a ! k; Seq_p = map ((∙) b) Seq; 0 < a ! k;
***          x ∈ set Seq; a ! k dvd b ∙ x⟧
***         ⟹ thesis
*** At command "by" (line 591 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy")

==========
DynamicArchitectures
*** Failed to finish proof (line 1504 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/DynamicArchitectures/Configuration_Traces.thy"):
*** goal (1 subgoal):
***  1. ⟦∥c∥⇘t i⇙; ∀n'>n. ¬ ∥c∥⇘t n'⇙; ∥c∥⇘t i'⇙; ∀y. ∥c∥⇘t y⇙ ⟶ y ≤ i';
***      ⋀c t. ⟨c ∧ t⟩ ≡ GREATEST i. ∥c∥⇘t i⇙;
***      ⋀b. (⋀y. ∥c∥⇘t y⇙ ⟹ y ≤ b) ⟹ i ≤ (GREATEST i'. ∥c∥⇘t i'⇙)⟧
***     ⟹ i ≤ (GREATEST i. ∥c∥⇘t i⇙)
*** At command "by" (line 1504 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/DynamicArchitectures/Configuration_Traces.thy")
*** Failed to finish proof (line 1483 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/DynamicArchitectures/Configuration_Traces.thy"):
*** goal (1 subgoal):
***  1. ⟦∥c∥⇘t i'⇙; ∀y. ∥c∥⇘t y⇙ ⟶ y ≤ i'; ⋀c t. ⟨c ∧ t⟩ ≡ GREATEST i. ∥c∥⇘t i⇙;
***      ⋀k b. ⟦∥c∥⇘t k⇙; ⋀y. ∥c∥⇘t y⇙ ⟹ y ≤ b⟧ ⟹ ∥c∥⇘t (GREATEST i'. ∥c∥⇘t i'⇙)⇙⟧
***     ⟹ ∥c∥⇘t (GREATEST i. ∥c∥⇘t i⇙)⇙
*** At command "by" (line 1483 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/DynamicArchitectures/Configuration_Traces.thy")

==========
Echelon_Form
*** Failed to finish proof (line 1277 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Echelon_Form/Echelon_Form.thy"):
*** goal (1 subgoal):
***  1. ⟦mod_type_class.to_nat a = 0; i < a;
***      ⋀y k. y < mod_type_class.from_nat k ⟹ mod_type_class.to_nat y < k⟧
***     ⟹ A $ a $ mod_type_class.from_nat k = (0::'a)
*** At command "by" (line 1277 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Echelon_Form/Echelon_Form.thy")
*** Undefined fact: "card_insert" (line 393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/System_Of_Equations.thy")
*** At command "using" (line 393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/System_Of_Equations.thy")
*** Undefined fact: "nat_add_left_cancel" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/Rank.thy")
*** At command "by" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/Rank.thy")
*** Failed to finish proof (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy"):
*** goal (1 subgoal):
***  1. ⟦mod_type_class.to_nat (0::'a) = 0; mod_type_class.to_nat x = 0⟧
***     ⟹ x = (0::'a)
*** At command "by" (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy")

==========
Ergodic_Theory
*** Undefined fact: "real_mult_le_cancel_iff2" (line 609 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 609 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "real_mult_le_cancel_iff1" (line 1233 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Normalizing_Sequences.thy")
*** At command "by" (line 1233 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Normalizing_Sequences.thy")
*** Undefined fact: "real_mult_le_cancel_iff1" (line 1339 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Normalizing_Sequences.thy")
*** At command "by" (line 1339 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Normalizing_Sequences.thy")
*** Undefined fact: "real_mult_le_cancel_iff2" (line 1410 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Invariants.thy")
*** At command "by" (line 1410 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/Invariants.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   convex_on ?C ?f =
***   (∀x∈?C.
***       ∀y∈?C.
***          ∀μ. 0 ≤ μ ∧ μ ≤ 1 ⟶
***              ?f (μ *⇩R x + (1 - μ) *⇩R y) ≤ μ * ?f x + (1 - μ) * ?f y)
***   convex C
*** At command "unfolding" (line 340 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Extended_Finite_State_Machines
*** Type unification failed: Clash of types "_ list" and "String.literal"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  possible_steps e2 s2 r2 ::
***   String.literal ⇒ value list ⇒ (nat × transition) fset
*** Operand:   l :: value list
*** 
*** At command "apply" (line 1139 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/EFSM.thy")
*** Type unification failed: Clash of types "nat" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  evaluate_outputs t1 ::
***   value list ⇒ nat ⇒f value option ⇒ value option list
*** Operand:   i :: nat
*** 
*** At command "apply" (line 953 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/EFSM.thy")
*** Failed to apply initial proof method (line 590 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/EFSM.thy"):
*** goal:
*** No subgoals!
*** At command "by" (line 590 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/EFSM.thy")
*** Undefined fact: "card_empty" (line 299 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/FSet_Utils.thy")
*** At command "by" (line 299 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Extended_Finite_State_Machines/FSet_Utils.thy")

==========
Factored_Transition_System_Bounding
*** Failed to apply initial proof method (line 822 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/AcycSspace.thy"):
*** using this:
***     S vs lss PROB (fmrestrict_set vs s)
***     ≤ Max {S vs lss PROB s' |s'. s' ∈ valid_states (prob_proj PROB vs)}
***     Sup ?X = (if ?X = {} then 0 else Max ?X)
*** goal (1 subgoal):
***  1. S vs lss PROB (fmrestrict_set vs s)
***     ≤ Sup {S vs lss PROB s' |s'. s' ∈ valid_states (prob_proj PROB vs)}
*** At command "by" (line 822 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/AcycSspace.thy")
*** Failed to apply initial proof method (line 2027 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/TopologicalProps.thy"):
*** using this:
***     ∀y. y ∈ {length p - 1 |p. valid_path Pi p ∧ distinct p} ⟶ y ≤ x
***     x ∈ {length p - 1 |p. valid_path Pi p ∧ distinct p}
***     x = length p - 1
*** goal (1 subgoal):
***  1. length p - 1 ≤ Max {length p - 1 |p. valid_path Pi p ∧ distinct p}
*** At command "by" (line 2027 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/TopologicalProps.thy")
*** Failed to apply initial proof method (line 2127 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/TopologicalProps.thy"):
*** using this:
***   Max (MPLS Pi) ≤ Max {length p - 1 |p. valid_path Pi p ∧ distinct p}
*** goal (1 subgoal):
***  1. (if MPLS Pi = {} then 0 else Max (MPLS Pi))
***     ≤ (if {length p - 1 |p. valid_path Pi p ∧ distinct p} = {} then 0
***        else Max {length p - 1 |p. valid_path Pi p ∧ distinct p})
*** At command "by" (line 2127 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/TopologicalProps.thy")
*** Undefined fact: "card_infinite" (line 483 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/FactoredSystem.thy")
*** At command "using" (line 483 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Factored_Transition_System_Bounding/FactoredSystem.thy")

==========
Finger-Trees
*** Failed to apply proof method (line 612 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Finger-Trees/FingerTree.thy"):
*** goal (3 subgoals):
***  1. ⋀pr m a b.
***        digitToList pr @
***        rec_FingerTreeStruc [] nodeToList
***         (λ_ pr m sf ma. digitToList pr @ ma @ digitToList sf) m @
***        nodeToList a @ nodeToList b =
***        rec_FingerTreeStruc [] nodeToList
***         (λ_ pr m sf ma. digitToList pr @ ma @ digitToList sf)
***         (deep pr m (Two a b))
***  2. ⋀uw_ pr m a b c d nd s.
***        viewRn (Deep uw_ pr m (Four a b c d)) = Some (nd, s) ⟹
***        toList (Deep uw_ pr m (Four a b c d)) = toList s @ nodeToList nd
***  3. ⋀ux_ pr m a nd s.
***        ⟦⋀nd s.
***            viewRn m = Some (nd, s) ⟹ toList m = toList s @ nodeToList nd;
***         viewRn (Deep ux_ pr m (One a)) = Some (nd, s)⟧
***        ⟹ toList (Deep ux_ pr m (One a)) = toList s @ nodeToList nd
*** At command "apply" (line 612 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Finger-Trees/FingerTree.thy")
*** Failed to apply proof method (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Finger-Trees/FingerTree.thy"):
*** goal (3 subgoals):
***  1. ⋀b c m sf.
***        nodeToList b @
***        nodeToList c @
***        rec_FingerTreeStruc [] nodeToList
***         (λ_ pr m sf ma. digitToList pr @ ma @ digitToList sf) m @
***        digitToList sf =
***        rec_FingerTreeStruc [] nodeToList
***         (λ_ pr m sf ma. digitToList pr @ ma @ digitToList sf)
***         (deep (Two b c) m sf)
***  2. ⋀uw_ a b c d m sf nd s.
***        viewLn (Deep uw_ (Four a b c d) m sf) = Some (nd, s) ⟹
***        toList (Deep uw_ (Four a b c d) m sf) = nodeToList nd @ toList s
***  3. ⋀ux_ a m sf nd s.
***        ⟦⋀nd s.
***            viewLn m = Some (nd, s) ⟹ toList m = nodeToList nd @ toList s;
***         viewLn (Deep ux_ (One a) m sf) = Some (nd, s)⟧
***        ⟹ toList (Deep ux_ (One a) m sf) = nodeToList nd @ toList s
*** At command "apply" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Finger-Trees/FingerTree.thy")

==========
First_Welfare_Theorem
*** Undefined fact: "real_mult_less_iff1" (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/First_Welfare_Theorem/Utility_Functions.thy")
*** At command "by" (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/First_Welfare_Theorem/Utility_Functions.thy")

==========
Flyspeck-Tame
*** Failed to apply proof method (line 4814 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (6 subgoals):
***  1. ⟦distinct xs; before (filter P xs) u v; P u; P v; pre_between xs u v;
***      before xs v u; before ys v u⟧
***     ⟹ distinct ys
***  2. ⟦distinct xs; before (filter P xs) u v; P u; P v; pre_between xs u v;
***      before xs v u; before ys v u⟧
***     ⟹ before ys u v
***  3. ⟦distinct xs; before (filter P xs) u v; P u; P v; pre_between xs u v;
***      before xs v u⟧
***     ⟹ before ys v u
***  4. ⋀ys. ⟦filter P xs = ys; distinct xs; before ys u v; P u; P v⟧
***          ⟹ pre_between xs u v
***  5. ⋀ys. ⟦filter P xs = ys; distinct xs; before ys u v; P u⟧ ⟹ P v
***  6. ⋀ys. ⟦filter P xs = ys; distinct xs; before ys u v⟧ ⟹ P u
*** At command "apply" (line 4814 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 3206 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (4 subgoals):
***  1. ⋀ys. ⟦pre_split_face f ram1 ram2 vs; vs1 = ys @ [c];
***           vs2 = between (vertices f) ram2 ram1;
***           between (vertices f) ram2 ram1 ≠ []; ram1 ∈ 𝒱 f;
***           c = last (between (vertices f) ram2 ram1) ⟶ ram2 ≠ ram1;
***           c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]); d = ram2;
***           between (vertices f) ram1 ram2 = ys @ [c];
***           ram1 # ys @ y # ram2 # between (vertices f) ram2 ram1 =
***           (ram1 # ys) @ y # ram2 # between (vertices f) ram2 ram1⟧
***          ⟹ ram1 # ys @ c # ram2 # between (vertices f) ram2 ram1 =
***             ?as29 ys @ c # ram2 # ?bs30 ys
***  2. ⋀ys. ⟦pre_split_face f ram1 ram2 vs; vs1 = ys @ [c];
***           vs2 = between (vertices f) ram2 ram1;
***           between (vertices f) ram2 ram1 ≠ []; ram1 ∈ 𝒱 f;
***           c = last (between (vertices f) ram2 ram1) ⟶ ram2 ≠ ram1;
***           c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]); d = ram2;
***           between (vertices f) ram1 ram2 = ys @ [c]⟧
***          ⟹ ram1 # ys @ y # ram2 # between (vertices f) ram2 ram1 =
***             (ram1 # ys) @ y # ram2 # between (vertices f) ram2 ram1
***  3. ⟦c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      c = ram2 ∧ d = hd (between (vertices f) ram2 ram1) ∨
***      (c, d) ∈ Edges (between (vertices f) ram1 ram2) ∨
***      (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 vs; vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ [];
***      vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ []; ram1 ∈ 𝒱 f;
***      c = last (between (vertices f) ram2 ram1) ⟶ d ≠ ram1;
***      c = ram1 ⟶ d ≠ hd (between (vertices f) ram1 ram2);
***      ¬ (c = last (between (vertices f) ram1 ram2) ∧ d = ram2)⟧
***     ⟹ is_sublist [c, d]
***         (ram1 #
***          between (vertices f) ram1 ram2 @
***          ram2 # between (vertices f) ram2 ram1)
***  4. ⟦c = last (between (vertices f) ram2 ram1) ∧ d = ram1 ∨
***      c = ram1 ∧ d = hd (between (vertices f) ram1 ram2) ∨
***      c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      c = ram2 ∧ d = hd (between (vertices f) ram2 ram1) ∨
***      (c, d) ∈ Edges (between (vertices f) ram1 ram2) ∨
***      (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 vs; vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ [];
***      vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ []⟧
***     ⟹ ram1 ∈ 𝒱 f
*** At command "apply" (line 3206 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 2737 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (3 subgoals):
***  1. ⋀list.
***        ⟦pre_split_face f ram1 ram2 (d # list);
***         f12 =
***         Face (rev list @ d # ram1 # between (vertices f) ram1 ram2 @ [ram2])
***          Nonfinal ∧
***         f21 =
***         Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # d # list)
***          Nonfinal;
***         vs2 = between (vertices f) ram2 ram1;
***         between (vertices f) ram2 ram1 ≠ [];
***         ram1 = ram2 ⟶ d ≠ hd (between (vertices f) ram2 ram2); c = ram1;
***         vs = d # list;
***         ram2 # between (vertices f) ram2 ram1 @ ram1 # a # list =
***         (ram2 # between (vertices f) ram2 ram1) @ ram1 # a # list⟧
***        ⟹ ram2 # between (vertices f) ram2 ram1 @ ram1 # d # list =
***           ?as16 list @ ram1 # d # ?bs17 list
***  2. ⋀list.
***        ⟦pre_split_face f ram1 ram2 (d # list);
***         f12 =
***         Face (rev list @ d # ram1 # between (vertices f) ram1 ram2 @ [ram2])
***          Nonfinal ∧
***         f21 =
***         Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # d # list)
***          Nonfinal;
***         vs2 = between (vertices f) ram2 ram1;
***         between (vertices f) ram2 ram1 ≠ [];
***         ram1 = ram2 ⟶ d ≠ hd (between (vertices f) ram2 ram2); c = ram1;
***         vs = d # list⟧
***        ⟹ ram2 # between (vertices f) ram2 ram1 @ ram1 # a # list =
***           (ram2 # between (vertices f) ram2 ram1) @ ram1 # a # list
***  3. ⟦c = last (between (vertices f) ram2 ram1) ∧ d = ram1 ∨
***      c = ram1 ∧ d = hd vs ∨
***      c = last vs ∧ d = ram2 ∨
***      c = ram2 ∧ d = hd (between (vertices f) ram2 ram1) ∨
***      (c, d) ∈ Edges vs ∨ (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 vs;
***      f12 =
***      Face (rev vs @ ram1 # between (vertices f) ram1 ram2 @ [ram2])
***       Nonfinal ∧
***      f21 =
***      Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # vs) Nonfinal;
***      vs ≠ []; vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ [];
***      ¬ (c = ram2 ∧ d = hd (between (vertices f) ram2 ram1));
***      ¬ (c = ram1 ∧ d = hd vs)⟧
***     ⟹ (∃as bs.
***            ram2 # between (vertices f) ram2 ram1 @ ram1 # vs =
***            as @ c # d # bs) ∨
***        c = last vs ∧ d = ram2
*** At command "apply" (line 2737 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 2890 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (3 subgoals):
***  1. ⋀list.
***        ⟦pre_split_face f ram1 ram2 (d # list);
***         f12 =
***         Face (rev list @ d # ram1 # between (vertices f) ram1 ram2 @ [ram2])
***          Nonfinal ∧
***         f21 = Face (ram2 # ram1 # d # list) Nonfinal;
***         between (vertices f) ram2 ram1 = []; ram1 = ram2 ⟶ d ≠ ram2;
***         c = ram1; vs = d # list;
***         ram2 # ram1 # a # list = [ram2] @ ram1 # a # list⟧
***        ⟹ ram2 # ram1 # d # list = ?as20 list @ ram1 # d # ?bs21 list
***  2. ⋀list.
***        ⟦pre_split_face f ram1 ram2 (d # list);
***         f12 =
***         Face (rev list @ d # ram1 # between (vertices f) ram1 ram2 @ [ram2])
***          Nonfinal ∧
***         f21 = Face (ram2 # ram1 # d # list) Nonfinal;
***         between (vertices f) ram2 ram1 = []; ram1 = ram2 ⟶ d ≠ ram2;
***         c = ram1; vs = d # list⟧
***        ⟹ ram2 # ram1 # a # list = [ram2] @ ram1 # a # list
***  3. ⟦c = ram1 ∧ d = hd vs ∨
***      c = last vs ∧ d = ram2 ∨ c = ram2 ∧ d = ram1 ∨ (c, d) ∈ Edges vs;
***      pre_split_face f ram1 ram2 vs;
***      f12 =
***      Face (rev vs @ ram1 # between (vertices f) ram1 ram2 @ [ram2])
***       Nonfinal ∧
***      f21 = Face (ram2 # ram1 # vs) Nonfinal;
***      vs ≠ []; between (vertices f) ram2 ram1 = []; ¬ (c = ram2 ∧ d = ram1);
***      ¬ (c = ram1 ∧ d = hd vs)⟧
***     ⟹ (∃as bs. ram2 # ram1 # vs = as @ c # d # bs) ∨ c = last vs ∧ d = ram2
*** At command "apply" (line 2890 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 2459 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (3 subgoals):
***  1. ⋀ys. ⟦pre_split_face f ram1 ram2 vs;
***           f12 = Face (rev vs @ ram1 # ys @ [c, ram2]) Nonfinal ∧
***           f21 =
***           Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # vs) Nonfinal;
***           vs ≠ []; vs1 = ys @ [c]; c = ram2 ⟶ ram2 ≠ last vs;
***           c = hd vs ⟶ ram2 ≠ ram1; c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]);
***           d = ram2; between (vertices f) ram1 ram2 = ys @ [c];
***           rev vs @ ram1 # ys @ [y, ram2] = (rev vs @ ram1 # ys) @ [y, ram2]⟧
***          ⟹ rev vs @ ram1 # ys @ [c, ram2] = ?as53 ys @ c # ram2 # ?bs54 ys
***  2. ⋀ys. ⟦pre_split_face f ram1 ram2 vs;
***           f12 = Face (rev vs @ ram1 # ys @ [c, ram2]) Nonfinal ∧
***           f21 =
***           Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # vs) Nonfinal;
***           vs ≠ []; vs1 = ys @ [c]; c = ram2 ⟶ ram2 ≠ last vs;
***           c = hd vs ⟶ ram2 ≠ ram1; c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]);
***           d = ram2; between (vertices f) ram1 ram2 = ys @ [c]⟧
***          ⟹ rev vs @ ram1 # ys @ [y, ram2] =
***             (rev vs @ ram1 # ys) @ [y, ram2]
***  3. ⟦c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      (d, c) ∈ Edges vs ∨ (c, d) ∈ Edges (between (vertices f) ram1 ram2);
***      pre_split_face f ram1 ram2 vs;
***      f12 =
***      Face (rev vs @ ram1 # between (vertices f) ram1 ram2 @ [ram2])
***       Nonfinal ∧
***      f21 =
***      Face (ram2 # between (vertices f) ram2 ram1 @ ram1 # vs) Nonfinal;
***      vs ≠ []; vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ []; c = ram2 ⟶ d ≠ last vs;
***      c = hd vs ⟶ d ≠ ram1;
***      c = ram1 ⟶ d ≠ hd (between (vertices f) ram1 ram2);
***      ¬ (c = last (between (vertices f) ram1 ram2) ∧ d = ram2)⟧
***     ⟹ ∃as bs.
***           rev vs @ ram1 # between (vertices f) ram1 ram2 @ [ram2] =
***           as @ c # d # bs
*** At command "apply" (line 2459 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 3131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (4 subgoals):
***  1. ⋀ys. ⟦pre_split_face f ram1 ram2 vs; vs1 = ys @ [c];
***           between (vertices f) ram2 ram1 = []; ram1 ∈ 𝒱 f;
***           c = ram2 ⟶ ram2 ≠ ram1; c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]);
***           d = ram2; between (vertices f) ram1 ram2 = ys @ [c];
***           ram1 # ys @ [y, ram2] = (ram1 # ys) @ [y, ram2]⟧
***          ⟹ ram1 # ys @ [c, ram2] = ?as28 ys @ c # ram2 # ?bs29 ys
***  2. ⋀ys. ⟦pre_split_face f ram1 ram2 vs; vs1 = ys @ [c];
***           between (vertices f) ram2 ram1 = []; ram1 ∈ 𝒱 f;
***           c = ram2 ⟶ ram2 ≠ ram1; c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]);
***           d = ram2; between (vertices f) ram1 ram2 = ys @ [c]⟧
***          ⟹ ram1 # ys @ [y, ram2] = (ram1 # ys) @ [y, ram2]
***  3. ⟦c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      (c, d) ∈ Edges (between (vertices f) ram1 ram2);
***      pre_split_face f ram1 ram2 vs; vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ [];
***      between (vertices f) ram2 ram1 = []; ram1 ∈ 𝒱 f; c = ram2 ⟶ d ≠ ram1;
***      c = ram1 ⟶ d ≠ hd (between (vertices f) ram1 ram2);
***      ¬ (c = last (between (vertices f) ram1 ram2) ∧ d = ram2)⟧
***     ⟹ is_sublist [c, d] (ram1 # between (vertices f) ram1 ram2 @ [ram2])
***  4. ⟦c = ram2 ∧ d = ram1 ∨
***      c = ram1 ∧ d = hd (between (vertices f) ram1 ram2) ∨
***      c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      (c, d) ∈ Edges (between (vertices f) ram1 ram2);
***      pre_split_face f ram1 ram2 vs; vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ [];
***      between (vertices f) ram2 ram1 = []⟧
***     ⟹ ram1 ∈ 𝒱 f
*** At command "apply" (line 3131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 3059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (4 subgoals):
***  1. ⋀list.
***        ⟦pre_split_face f ram1 ram2 vs; between (vertices f) ram1 ram2 = [];
***         vs2 = d # list; ram1 ∈ 𝒱 f;
***         ram2 = (if list = [] then d else last list) ⟶
***         hd (between (vertices f) (if list = [] then d else last list)
***              ram1) ≠
***         ram1;
***         ram2 = ram1 ⟶ hd (between (vertices f) ram1 ram1) ≠ ram1; c = ram2;
***         between (vertices f) ram2 ram1 = d # list;
***         ram1 # ram2 # a # list = [ram1] @ ram2 # a # list⟧
***        ⟹ ram1 # ram2 # d # list = ?as24 list @ ram2 # d # ?bs25 list
***  2. ⋀list.
***        ⟦pre_split_face f ram1 ram2 vs; between (vertices f) ram1 ram2 = [];
***         vs2 = d # list; ram1 ∈ 𝒱 f;
***         ram2 = (if list = [] then d else last list) ⟶
***         hd (between (vertices f) (if list = [] then d else last list)
***              ram1) ≠
***         ram1;
***         ram2 = ram1 ⟶ hd (between (vertices f) ram1 ram1) ≠ ram1; c = ram2;
***         between (vertices f) ram2 ram1 = d # list⟧
***        ⟹ ram1 # ram2 # a # list = [ram1] @ ram2 # a # list
***  3. ⟦c = ram2 ∧ d = hd (between (vertices f) ram2 ram1) ∨
***      (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 vs; between (vertices f) ram1 ram2 = [];
***      vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ []; ram1 ∈ 𝒱 f;
***      c = last (between (vertices f) ram2 ram1) ⟶ d ≠ ram1;
***      c = ram1 ⟶ d ≠ ram2;
***      ¬ (c = ram2 ∧ d = hd (between (vertices f) ram2 ram1))⟧
***     ⟹ is_sublist [c, d] (ram1 # ram2 # between (vertices f) ram2 ram1)
***  4. ⟦c = last (between (vertices f) ram2 ram1) ∧ d = ram1 ∨
***      c = ram1 ∧ d = ram2 ∨
***      c = ram2 ∧ d = hd (between (vertices f) ram2 ram1) ∨
***      (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 vs; between (vertices f) ram1 ram2 = [];
***      vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ []⟧
***     ⟹ ram1 ∈ 𝒱 f
*** At command "apply" (line 3059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 2826 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (3 subgoals):
***  1. ⋀ys. ⟦pre_split_face f ram1 ram2 [];
***           f12 =
***           Face (ram1 # between (vertices f) ram1 ram2 @ [ram2]) Nonfinal ∧
***           f21 = Face (ram2 # ys @ [c, ram1]) Nonfinal;
***           vs2 = ys @ [c]; c = ram2 ⟶ ram1 ≠ hd (ys @ [ram2]);
***           c = ram1 ⟶ ram1 ≠ ram2; d = ram1;
***           between (vertices f) ram2 ram1 = ys @ [c];
***           ram2 # ys @ [y, ram1] = (ram2 # ys) @ [y, ram1]⟧
***          ⟹ ram2 # ys @ [c, ram1] = ?as18 ys c @ c # ram1 # ?bs19 ys c
***  2. ⋀ys. ⟦pre_split_face f ram1 ram2 [];
***           f12 =
***           Face (ram1 # between (vertices f) ram1 ram2 @ [ram2]) Nonfinal ∧
***           f21 = Face (ram2 # ys @ [c, ram1]) Nonfinal;
***           vs2 = ys @ [c]; c = ram2 ⟶ ram1 ≠ hd (ys @ [ram2]);
***           c = ram1 ⟶ ram1 ≠ ram2; d = ram1;
***           between (vertices f) ram2 ram1 = ys @ [c]⟧
***          ⟹ ram2 # ys @ [y, ram1] = (ram2 # ys) @ [y, ram1]
***  3. ⟦c = last (between (vertices f) ram2 ram1) ∧ d = ram1 ∨
***      (c, d) ∈ Edges (between (vertices f) ram2 ram1);
***      pre_split_face f ram1 ram2 [];
***      f12 = Face (ram1 # between (vertices f) ram1 ram2 @ [ram2]) Nonfinal ∧
***      f21 = Face (ram2 # between (vertices f) ram2 ram1 @ [ram1]) Nonfinal;
***      vs2 = between (vertices f) ram2 ram1;
***      between (vertices f) ram2 ram1 ≠ [];
***      c = ram2 ⟶ d ≠ hd (between (vertices f) ram2 ram1);
***      c = ram1 ⟶ d ≠ ram2;
***      ¬ (c = last (between (vertices f) ram2 ram1) ∧ d = ram1)⟧
***     ⟹ (∃as bs.
***            ram2 # between (vertices f) ram2 ram1 @ [ram1] =
***            as @ c # d # bs) ∨
***        c = ram1 ∧ d = ram2
*** At command "apply" (line 2826 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")
*** Failed to apply proof method (line 2536 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy"):
*** goal (3 subgoals):
***  1. ⋀ys. ⟦pre_split_face f ram1 ram2 [];
***           f12 = Face (ram1 # ys @ [c, ram2]) Nonfinal ∧
***           f21 =
***           Face (ram2 # between (vertices f) ram2 ram1 @ [ram1]) Nonfinal;
***           vs1 = ys @ [c]; c = ram2 ⟶ ram2 ≠ ram1;
***           c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]); d = ram2;
***           between (vertices f) ram1 ram2 = ys @ [c];
***           ram1 # ys @ [y, ram2] = (ram1 # ys) @ [y, ram2]⟧
***          ⟹ ram1 # ys @ [c, ram2] = ?as28 ys @ c # ram2 # ?bs29 ys
***  2. ⋀ys. ⟦pre_split_face f ram1 ram2 [];
***           f12 = Face (ram1 # ys @ [c, ram2]) Nonfinal ∧
***           f21 =
***           Face (ram2 # between (vertices f) ram2 ram1 @ [ram1]) Nonfinal;
***           vs1 = ys @ [c]; c = ram2 ⟶ ram2 ≠ ram1;
***           c = ram1 ⟶ ram2 ≠ hd (ys @ [ram1]); d = ram2;
***           between (vertices f) ram1 ram2 = ys @ [c]⟧
***          ⟹ ram1 # ys @ [y, ram2] = (ram1 # ys) @ [y, ram2]
***  3. ⟦c = last (between (vertices f) ram1 ram2) ∧ d = ram2 ∨
***      (c, d) ∈ Edges (between (vertices f) ram1 ram2);
***      pre_split_face f ram1 ram2 [];
***      f12 = Face (ram1 # between (vertices f) ram1 ram2 @ [ram2]) Nonfinal ∧
***      f21 = Face (ram2 # between (vertices f) ram2 ram1 @ [ram1]) Nonfinal;
***      vs1 = between (vertices f) ram1 ram2;
***      between (vertices f) ram1 ram2 ≠ []; c = ram2 ⟶ d ≠ ram1;
***      c = ram1 ⟶ d ≠ hd (between (vertices f) ram1 ram2);
***      ¬ (c = last (between (vertices f) ram1 ram2) ∧ d = ram2)⟧
***     ⟹ ∃as bs.
***           ram1 # between (vertices f) ram1 ram2 @ [ram2] = as @ c # d # bs
*** At command "apply" (line 2536 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Flyspeck-Tame/FaceDivisionProps.thy")

==========
Fourier
*** Undefined fact: "real_mult_less_iff1" (line 1102 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Fourier/Fourier.thy")
*** At command "by" (line 1102 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Fourier/Fourier.thy")
*** Failed to apply proof method (line 1617 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lp/Lp.thy"):
*** goal (3 subgoals):
***  1. ⋀n. ¦u (n + N) x¦ ≤ (1 / 2) ^ (n + N)
***  2. summable (λn. ¦u (n + N) x¦)
***  3. summable (λn. (1 / 2) ^ (n + N))
*** At command "apply" (line 1617 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lp/Lp.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   convex_on ?C ?f =
***   (∀x∈?C.
***       ∀y∈?C.
***          ∀μ. 0 ≤ μ ∧ μ ≤ 1 ⟶
***              ?f (μ *⇩R x + (1 - μ) *⇩R y) ≤ μ * ?f x + (1 - μ) * ?f y)
***   convex C
*** At command "unfolding" (line 340 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Furstenberg_Topology
*** Failed to refine any pending goal
*** At command "by" (line 631 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Furstenberg_Topology/Furstenberg_Topology.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦⋀n. ?f n ≤ ?g n; ?f sums ?s; ?g sums ?t⟧ ⟹ ?s ≤ ?t
***   (⋀x. ?P x) ⟹ ∀x. ?P x
***   (λk. if k = 0 ∨ int k dvd ?n then 0 else 1 / q ^ k) sums N ?n
*** At command "proof" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Furstenberg_Topology/Furstenberg_Topology.thy")
*** Failed to refine any pending goal
*** At command "by" (line 507 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Furstenberg_Topology/Furstenberg_Topology.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦⋀n. ?f n ≤ ?g n; ?f sums ?s; ?g sums ?t⟧ ⟹ ?s ≤ ?t
***   (⋀x. ?P x) ⟹ ∀x. ?P x
***   (λk. if k = 0 ∨ int k dvd ?n then 0 else 1 / q ^ k) sums N ?n
***   (λk. if k = 0 ∨ int k dvd ?n then 0 else 1 / q ^ k) sums N ?n
*** At command "proof" (line 535 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Furstenberg_Topology/Furstenberg_Topology.thy")

==========
Gauss_Jordan
*** Undefined fact: "card_insert" (line 393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/System_Of_Equations.thy")
*** At command "using" (line 393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/System_Of_Equations.thy")
*** Undefined fact: "nat_add_left_cancel" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/Rank.thy")
*** At command "by" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gauss_Jordan/Rank.thy")
*** Failed to finish proof (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy"):
*** goal (1 subgoal):
***  1. ⟦mod_type_class.to_nat (0::'a) = 0; mod_type_class.to_nat x = 0⟧
***     ⟹ x = (0::'a)
*** At command "by" (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy")

==========
GenClock
*** Undefined fact: "real_mult_le_cancel_iff1" (line 1057 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/GenClock/GenClock.thy")
*** At command "by" (line 1057 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/GenClock/GenClock.thy")
*** Undefined fact: "real_mult_le_cancel_iff2" (line 690 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/GenClock/GenClock.thy")
*** At command "by" (line 690 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/GenClock/GenClock.thy")

==========
Generalized_Counting_Sort
*** Failed to refine any pending goal
*** At command "qed" (line 1217 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Sorting.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 715 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Stability.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 1990 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Conservation.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 968 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Conservation.thy")
*** Failed to refine any pending goal
*** At command "by" (line 2071 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Algorithm.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 1935 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Algorithm.thy")
*** Failed to refine any pending goal
*** At command "by" (line 2118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Algorithm.thy")
*** Failed to apply initial proof method (line 1732 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Algorithm.thy"):
*** goal (1 subgoal):
***  1. bn_valid m (p - bn_count (Suc (Suc m) # ns))
***      (Suc (Suc (foldl (+) 0 ns + m)) - bn_count (Suc (Suc m) # ns))
*** At command "proof" (line 1732 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generalized_Counting_Sort/Algorithm.thy")

==========
Generic_Deriving
*** Failed to load theory "Generic_Deriving.Derive_Algebra" (unresolved "Generic_Deriving.Derive")
*** Failed to load theory "Generic_Deriving.Derive_Algebra_Laws" (unresolved "Generic_Deriving.Derive")
*** Failed to load theory "Generic_Deriving.Derive_Encode" (unresolved "Generic_Deriving.Derive")
*** Failed to load theory "Generic_Deriving.Derive_Eq" (unresolved "Generic_Deriving.Derive")
*** Failed to load theory "Generic_Deriving.Derive_Eq_Laws" (unresolved "Generic_Deriving.Derive")
*** Failed to load theory "Generic_Deriving.Derive_Show" (unresolved "Generic_Deriving.Derive")
*** ML error (line 97 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generic_Deriving/derive_setup.ML"):
*** Value or constructor (exit) has not been declared in structure Named_Target
*** At command "ML_file" (line 24 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Generic_Deriving/Derive.thy")

==========
Girth_Chromatic
*** Undefined fact: "real_mult_le_cancel_iff1" (line 593 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Girth_Chromatic/Girth_Chromatic.thy")
*** At command "by" (line 593 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Girth_Chromatic/Girth_Chromatic.thy")

==========
Goedel_HFSet_Semanticless
*** Failed to load theory "Goedel_HFSet_Semanticless.SyntaxN" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Goedel_HFSet_Semanticless.Coding" (unresolved "Goedel_HFSet_Semanticless.SyntaxN")
*** Failed to load theory "Goedel_HFSet_Semanticless.Predicates" (unresolved "Goedel_HFSet_Semanticless.SyntaxN")
*** Failed to load theory "Goedel_HFSet_Semanticless.Sigma" (unresolved "Goedel_HFSet_Semanticless.Predicates")
*** Failed to load theory "Goedel_HFSet_Semanticless.Coding_Predicates" (unresolved "Goedel_HFSet_Semanticless.Coding", "Goedel_HFSet_Semanticless.Sigma")
*** Failed to load theory "Goedel_HFSet_Semanticless.Functions" (unresolved "Goedel_HFSet_Semanticless.Coding_Predicates")
*** Failed to load theory "Goedel_HFSet_Semanticless.Pf_Predicates" (unresolved "Goedel_HFSet_Semanticless.Coding_Predicates")
*** Failed to load theory "Goedel_HFSet_Semanticless.II_Prelims" (unresolved "Goedel_HFSet_Semanticless.Pf_Predicates")
*** Failed to load theory "Goedel_HFSet_Semanticless.Goedel_I" (unresolved "Goedel_HFSet_Semanticless.Functions", "Goedel_HFSet_Semanticless.II_Prelims", "Goedel_HFSet_Semanticless.Pf_Predicates")
*** Failed to load theory "Goedel_HFSet_Semanticless.Pseudo_Coding" (unresolved "Goedel_HFSet_Semanticless.II_Prelims")
*** Failed to load theory "Goedel_HFSet_Semanticless.Quote" (unresolved "Goedel_HFSet_Semanticless.Pseudo_Coding")
*** Failed to load theory "Goedel_HFSet_Semanticless.Instance" (unresolved "Goedel_HFSet_Semanticless.Goedel_I", "Goedel_HFSet_Semanticless.Quote")
*** ML error (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 328 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML_file" (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/Nominal2.thy")

==========
Graph_Saturation
*** Undefined fact: "card_infinite" (line 215 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Graph_Saturation/MissingRelation.thy")
*** At command "by" (line 215 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Graph_Saturation/MissingRelation.thy")

==========
Green
*** Undefined fact: "real_mult_le_cancel_iff1" (line 382 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Green/CircExample.thy")
*** At command "by" (line 382 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Green/CircExample.thy")

==========
Gromov_Hyperbolicity
*** Undefined fact: "real_mult_le_cancel_iff2" (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
*** At command "by" (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
*** Undefined fact: "card_infinite" (line 2142 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gromov_Hyperbolicity/Isometries.thy")
*** At command "using" (line 2142 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Gromov_Hyperbolicity/Isometries.thy")

==========
Group-Ring-Module
*** Failed to apply proof method (line 832 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra5.thy"):
*** goal (3 subgoals):
***  1. ⋀g h x.
***        ⟦∀k≤Suc n. Ring (B k); x ≤ n; g ∈ extensional {i. i ≤ n};
***         h ∈ extensional {0}; g ∈ {i. i ≤ n} → Un_carrier {i. i ≤ n} B;
***         ∀i≤n. g i ∈ carrier (B i);
***         h 0 ∈ Un_carrier {0} (compose {0} B (slide (Suc n)));
***         h 0 ∈ carrier (compose {0} B (slide (Suc n)) 0); x ∈ {i. i ≤ n};
***         g x ∈ Un_carrier {j. j ≤ n} B⟧
***        ⟹ g x ∈ Un_carrier {i. i ≤ Suc n} B
***  2. ⋀g h x.
***        ⟦∀k≤Suc n. Ring (B k); g ∈ carr_prodag {i. i ≤ n} B;
***         h ∈ carr_prodag {0} (compose {0} B (slide (Suc n))); x ≤ Suc n;
***         ¬ x ≤ n⟧
***        ⟹ (x ≤ n ⟶ g x ∈ Un_carrier {i. i ≤ Suc n} B) ∧
***           (¬ x ≤ n ⟶ h (sliden (Suc n) x) ∈ Un_carrier {i. i ≤ Suc n} B)
***  3. ⋀g h. ⟦∀k≤Suc n. Ring (B k); g ∈ carr_prodag {i. i ≤ n} B;
***            h ∈ carr_prodag {0} (compose {0} B (slide (Suc n)))⟧
***           ⟹ ∀i≤Suc n.
***                 augm_func n g (Un_carrier {j. j ≤ n} B) (Suc 0) h
***                  (Un_carrier {0} (compose {0} B (slide (Suc n)))) i
***                 ∈ carrier (B i)
*** At command "apply" (line 832 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra5.thy")
*** Failed to apply proof method (line 4186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy"):
*** goal (1 subgoal):
***  1. i < j ⟹ {y. ∃x≤j - i. y = slide i x} = nset i j
*** At command "apply" (line 4186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy")
*** Failed to apply proof method (line 1256 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy"):
*** goal (1 subgoal):
***  1. f ∈ {j. j ≤ Suc n} → B ⟹
***     f ` {j. j ≤ Suc n} ⊆ insert (f (Suc n)) (f ` {j. j ≤ n})
*** At command "apply" (line 1256 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy")
*** Failed to apply proof method (line 1232 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy"):
*** goal (2 subgoals):
***  1. ⋀x xa.
***        ⟦f ∈ {j. j ≤ Suc n} → B; ∃xa≤Suc n. x = f xa; xa ≤ n;
***         f (Suc n) = f xa⟧
***        ⟹ ∃xa≤n. x = f xa
***  2. ⟦f ∈ {j. j ≤ Suc n} → B; f (Suc n) ∈ f ` {j. j ≤ n}⟧
***     ⟹ f ` {j. j ≤ n} ⊆ f ` {j. j ≤ Suc n}
*** At command "apply" (line 1232 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Group-Ring-Module/Algebra1.thy")

==========
Hello_World
*** ML error (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Hello_World/RunningCodeFromIsabelle.thy"):
*** Value or constructor (mkdirs) has not been declared in structure Isabelle_System
*** At command "ML" (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Hello_World/RunningCodeFromIsabelle.thy")

==========
HOL-CSP
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦s setinterleaves ((?t1.0, ?u), C); set ?t2.0 ∩ C = {}⟧
***   ⟹ s @ ?t2.0 setinterleaves ((?t1.0 @ ?t2.0, ?u), C)
***   aa ∈ C
***   s setinterleaves ((aa # lista, list), C)
*** At command "with" (line 1599 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")
*** Too many parameters for case "1" (line 1315 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")
*** At command "case" (line 1315 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/HOL-CSP/CSP.thy")

==========
Hybrid_Multi_Lane_Spatial_Logic
*** Interrupt

==========
Incompleteness
*** Failed to load theory "Incompleteness.SyntaxN" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Incompleteness.Coding" (unresolved "Incompleteness.SyntaxN")
*** Failed to load theory "Incompleteness.Predicates" (unresolved "Incompleteness.SyntaxN")
*** Failed to load theory "Incompleteness.Sigma" (unresolved "Incompleteness.Predicates")
*** Failed to load theory "Incompleteness.Coding_Predicates" (unresolved "Incompleteness.Coding", "Incompleteness.Sigma")
*** Failed to load theory "Incompleteness.Functions" (unresolved "Incompleteness.Coding_Predicates")
*** Failed to load theory "Incompleteness.Pf_Predicates" (unresolved "Incompleteness.Coding_Predicates")
*** Failed to load theory "Incompleteness.Goedel_I" (unresolved "Incompleteness.Functions", "Incompleteness.Pf_Predicates")
*** Failed to load theory "Incompleteness.II_Prelims" (unresolved "Incompleteness.Pf_Predicates")
*** Failed to load theory "Incompleteness.Pseudo_Coding" (unresolved "Incompleteness.II_Prelims")
*** Failed to load theory "Incompleteness.Quote" (unresolved "Incompleteness.Pseudo_Coding")
*** Failed to load theory "Incompleteness.Goedel_II" (unresolved "Incompleteness.Goedel_I", "Incompleteness.Quote")
*** ML error (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 328 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML_file" (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/Nominal2.thy")

==========
Inductive_Inference
*** Failed to finish proof (line 932 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Lemma_R.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀f xs.
***         ⟦wellf f; length xs = arity f⟧
***         ⟹ eval (r_universal (arity f)) (encode f # xs) = eval f xs;
***      recfn 3 r; Partial_Recursive.total r;
***      (λi j x. eval r [i, j, x]) = local.adverse z⟧
***     ⟹ eval (r_universal 3) [encode r, i, j, x] = eval r [i, j, x]
*** At command "by" (line 932 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Lemma_R.thy")
*** Failed to finish proof (line 776 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Standard_Results.thy"):
*** goal (1 subgoal):
***  1. (⋀f xs.
***         ⟦wellf f; length xs = arity f⟧
***         ⟹ eval (r_universal (arity f)) (encode f # xs) = eval f xs) ⟹
***     eval (r_universal 3) [encode r_univuniv2, u, x, y] =
***     eval r_univuniv2 [u, x, y]
*** At command "by" (line 776 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Standard_Results.thy")
*** exception Bug "Metis_KeyMap.delete: element not found" raised (line 3895 of "~~/src/Tools/Metis/metis.ML")
*** At command "by" (line 82 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Standard_Results.thy")
*** Failed to finish proof (line 1890 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀f xs.
***         ⟦wellf f; length xs = arity f⟧
***         ⟹ eval (r_universal (arity f)) (encode f # xs) = eval f xs;
***      i = encode f; recfn (Suc 0) f⟧
***     ⟹ eval (r_universal (Suc 0)) [encode f, x] = eval f [x]
*** At command "by" (line 1890 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 1650 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀h f g xs x.
***         ⟦h = Pr (arity f) f g;
***          arity g = Suc (Suc (arity f)) ∧
***          wellf f ∧ wellf g ∧ Mn_free f ∧ Mn_free g;
***          length xs = arity f⟧
***         ⟹ eval (Pr (arity f) f g) (Suc x # xs) =
***            eval g (x # the (eval (Pr (arity f) f g) (x # xs)) # xs);
***      wellf r_step ∧ arity r_step = Suc 0 ∧ Mn_free r_step; i = encode f;
***      recfn (e_length x) f⟧
***     ⟹ eval
***         (Pr 2
***           (Cn 2 r_prod_encode
***             [Cn 2 r_singleton_encode
***               [Cn 2 r_prod_encode
***                 [recf.Id 2 0,
***                  Cn 2 r_prod_encode
***                   [recf.Id 2 (Suc 0), r_constn (Suc 0) 0]]],
***              r_constn (Suc 0) 0])
***           (Cn 4 r_step [recf.Id 4 (Suc 0)]))
***         [Suc t, encode f, x] =
***        eval r_step
***         [the (eval
***                (Pr 2
***                  (Cn 2 r_prod_encode
***                    [Cn 2 r_singleton_encode
***                      [Cn 2 r_prod_encode
***                        [recf.Id 2 0,
***                         Cn 2 r_prod_encode
***                          [recf.Id 2 (Suc 0), r_constn (Suc 0) 0]]],
***                     r_constn (Suc 0) 0])
***                  (Cn 4 r_step [recf.Id 4 (Suc 0)]))
***                [t, encode f, x])]
*** At command "by" (line 1650 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 1190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦c = ((Pr n f g, xs, ls) # fs, rv);
***      arity g = Suc (Suc n) ∧
***      arity f = n ∧ wellf f ∧ wellf g ∧ Suc n = length xs;
***      ⋀c f g xs ls fs rv.
***         ⟦c = ((Pr (arity f) f g, xs, ls) # fs, rv); ls ≠ [];
***          length ls ≠ Suc (hd xs); ∃y. rv ↓= y;
***          arity g = Suc (Suc (arity f)) ∧
***          wellf f ∧ wellf g ∧ Suc (arity f) = length xs⟧
***         ⟹ estep_Pr (encode_config ((Pr (arity f) f g, xs, ls) # fs, rv)) =
***            encode_config
***             (if rv ↑
***              then ((g, (length ls - 1) # hd ls # tl xs, []) #
***                    (Pr (arity f) f g, xs, ls) # fs,
***                    None)
***              else ((Pr (arity f) f g, xs, the rv # ls) # fs, None));
***      ⋀c f g xs ls fs rv.
***         ⟦c = ((Pr (arity f) f g, xs, ls) # fs, None); ls ≠ [];
***          length ls ≠ Suc (hd xs); rv ↑;
***          arity g = Suc (Suc (arity f)) ∧
***          wellf f ∧ wellf g ∧ Suc (arity f) = length xs⟧
***         ⟹ estep_Pr
***             (encode_config ((Pr (arity f) f g, xs, ls) # fs, None)) =
***            encode_config
***             ((g, (length ls - Suc 0) # hd ls # tl xs, []) #
***              (Pr (arity f) f g, xs, ls) # fs,
***              None);
***      ⋀c f g xs ls fs rv.
***         ⟦c = ((Pr (arity f) f g, xs, ls) # fs, rv); ls ≠ [];
***          length ls = Suc (hd xs);
***          arity g = Suc (Suc (arity f)) ∧
***          wellf f ∧ wellf g ∧ Suc (arity f) = length xs⟧
***         ⟹ estep_Pr (encode_config ((Pr (arity f) f g, xs, ls) # fs, rv)) =
***            encode_config (fs, Some (hd ls));
***      ⋀c n f g xs ls fs rv.
***         ⟦c = ((Pr n f g, xs, []) # fs, rv); ls = []⟧
***         ⟹ estep_Pr (encode_config ((Pr n f g, xs, []) # fs, rv)) =
***            encode_config
***             (if rv ↑ then ((f, tl xs, []) # (Pr n f g, xs, []) # fs, None)
***              else ((Pr n f g, xs, [the rv]) # fs, None))⟧
***     ⟹ (rv ↑ ⟶
***         (length ls = Suc (hd xs) ⟶
***          ls ≠ [] ⟶
***          estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, None)) =
***          encode_config (fs, Some (hd ls))) ∧
***         (length ls ≠ Suc (hd xs) ⟶
***          ls ≠ [] ⟶
***          estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, None)) =
***          encode_config
***           ((g, (length ls - Suc 0) # hd ls # tl xs, []) #
***            (Pr n f g, xs, ls) # fs,
***            None))) ∧
***        ((∃y. rv ↓= y) ⟶
***         (rv ↑ ⟶
***          (length ls = Suc (hd xs) ⟶
***           ls ≠ [] ⟶
***           estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, None)) =
***           encode_config (fs, Some (hd ls))) ∧
***          (length ls ≠ Suc (hd xs) ⟶
***           ls ≠ [] ⟶
***           estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, None)) =
***           encode_config
***            ((g, (length ls - Suc 0) # hd ls # tl xs, []) #
***             (Pr n f g, xs, ls) # fs,
***             None))) ∧
***         (length ls = Suc (hd xs) ⟶
***          ls ≠ [] ⟶
***          estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, rv)) =
***          encode_config (fs, Some (hd ls))) ∧
***         (length ls ≠ Suc (hd xs) ⟶
***          ls ≠ [] ⟶
***          estep_Pr (encode_config ((Pr n f g, xs, ls) # fs, rv)) =
***          encode_config ((Pr n f g, xs, the rv # ls) # fs, None)))
*** At command "by" (line 1190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 772 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦eval f (z # xs) ↓= 0;
***      ⋀y. y < z ⟹ (∃ya. eval f (y # xs) ↓= ya) ∧ eval f (y # xs) ≠ Some 0;
***      ⋀x. reachable x (step x)⟧
***     ⟹ reachable ((Mn n f, xs, [z]) # rest, Some 0) (rest, Some z)
*** At command "by" (line 772 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 336 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀x. reachable x (step x); k < length gs⟧
***     ⟹ reachable
***         ((Cn n f gs, xs, take k (map (λg. the (eval g xs)) gs)) # rest,
***          None)
***         ((gs ! k, xs, []) #
***          (Cn n f gs, xs, take k (map (λg. the (eval g xs)) gs)) # rest,
***          None)
*** At command "by" (line 336 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 784 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦valid ((Z, xs, []) # rest);
***      ⋀xs locs rest.
***         valid ((Z, xs, locs) # rest) ⟹ valid rest ∧ Suc 0 = length xs;
***      ⋀x. reachable x (step x)⟧
***     ⟹ reachable ((Z, xs, []) # rest, None) (rest, Some 0)
*** At command "by" (line 784 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 557 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦tl xs = ys; ⋀x. reachable x (step x)⟧
***     ⟹ reachable ((Pr n f g, xs, []) # rest, None)
***         ((f, ys, []) # (Pr n f g, xs, []) # rest, None)
*** At command "by" (line 557 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 625 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀x. reachable x (step x); valid ((Mn n f, xs, []) # rest)⟧
***     ⟹ reachable ((Mn n f, xs, []) # rest, None)
***         ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)
*** At command "by" (line 625 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 405 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. ⟦min (length gs) k < length gs; ⋀x. reachable x (step x)⟧
***     ⟹ reachable
***         ((Cn n f gs, xs, take k (map (λg. the (eval g xs)) gs)) # rest,
***          None)
***         ((gs ! min (length gs) k, xs, []) #
***          (Cn n f gs, xs, take k (map (λg. the (eval g xs)) gs)) # rest,
***          None)
*** At command "by" (line 405 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")
*** Failed to finish proof (line 482 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy"):
*** goal (1 subgoal):
***  1. (⋀x. reachable x (step x)) ⟹
***     reachable ((Pr n f g, x # xs, []) # rest, None)
***      ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)
*** At command "by" (line 482 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Inductive_Inference/Universal.thy")

==========
Integration
*** Undefined fact: "LIMSEQ_Suc_iff" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Integration/MonConv.thy")
*** At command "by" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Integration/MonConv.thy")

==========
Irrationality_J_Hancl
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   summable ?f ⟹ summable (λn. ?f (n + ?k))
***   True
*** At command "using" (line 917 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** Failed to refine any pending goal
*** At command "by" (line 237 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")

==========
Isabelle_C
*** Failed to load theory "Isabelle_C.C_Parser_Annotation" (unresolved "Isabelle_C.C_Lexer_Annotation")
*** Failed to load theory "Isabelle_C.C_Eval" (unresolved "Isabelle_C.C_Parser_Annotation", "Isabelle_C.C_Parser_Language")
*** Failed to load theory "Isabelle_C.C_Command" (unresolved "Isabelle_C.C_Eval")
*** Failed to load theory "Isabelle_C.C_Document" (unresolved "Isabelle_C.C_Command")
*** Failed to load theory "Isabelle_C.C_Main" (unresolved "Isabelle_C.C_Document")
*** Failed to load theory "Isabelle_C.C0" (unresolved "Isabelle_C.C_Main")
*** Failed to load theory "Isabelle_C.C1" (unresolved "Isabelle_C.C_Main")
*** Failed to load theory "Isabelle_C.C2" (unresolved "Isabelle_C.C_Main")
*** Failed to load theory "Isabelle_C.C_paper" (unresolved "Isabelle_C.C_Main")
*** ML error (line 815 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Parser_Language.thy"):
*** Type error in function application.
***    Function:
***       Command.read_file
***       (Resources.master_directory (Proof_Context.theory_of ctxt))
***       Position.none
***       : bool -> Path.T -> Token.file
***    Argument: (Path.explode (#1 (Input.source_content text))) : Path.T
***    Reason:
***       Can't unify bool (*In Basis*) with Path.T
***          (Different type constructors)
*** ML error (line 814 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Parser_Language.thy"):
*** Type error in function application.
***    Function: Token.file_source : Token.file -> Input.source
***    Argument:
***       (Command.read_file
***        (Resources.master_directory (Proof_Context.theory_of ctxt))
***        Position.none
***        (Path.explode (#1 (Input.source_content text)))
***       )
***       : Path.T -> Token.file
***    Reason:
***       Can't unify
***          {digest: SHA1.digest,
***           lines: string list, pos: Position.T, src_path: Path.T}
***          to Path.T -> Token.file (Incompatible types)
*** At command "ML" (line 795 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Parser_Language.thy")
*** ML error (line 810 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Lexer_Annotation.thy"):
*** Type error in function application.
***    Function: Keyword.add_keywords :
***       ((string * Position.T) * Keyword.spec) list ->
***         Keyword.keywords -> Keyword.keywords
***    Argument: [((x, Position.none), ((Keyword.thy_decl, ...), [...]))] :
***       ((string * Position.T) * ((string * 'a list) * 'b list)) list
***    Reason: Can't unify string to string * 'a list (Incompatible types)
*** At command "ML" (line 212 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Lexer_Annotation.thy")

==========
Isabelle_Meta_Model
*** Failed to load theory "Isabelle_Meta_Model.Design_deep" (unresolved "Isabelle_Meta_Model.Generator_dynamic_sequential")
*** Failed to load theory "Isabelle_Meta_Model.Rail" (unresolved "Isabelle_Meta_Model.Generator_dynamic_sequential")
*** Failed to load theory "Isabelle_Meta_Model.Design_shallow" (unresolved "Isabelle_Meta_Model.Generator_dynamic_sequential")
*** ML error (line 524 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_Meta_Model/toy_example/embedding/Generator_dynamic_sequential.thy"):
*** Type error in function application.
***    Function:
***       Expression.add_locale_cmd (To_sbinding (META.holThyLocale_name data))
***       Binding.empty
***       : (xstring * Position.T) list ->
***           Expression.expression ->
***             Element.context list -> theory -> string * local_theory
***    Argument: ([], []) : 'a list * 'b list
***    Reason:
***       Can't unify (xstring * Position.T) list to 'a list * 'b list
***          (Incompatible types)
*** ML error (line 524 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_Meta_Model/toy_example/embedding/Generator_dynamic_sequential.thy"):
*** Type error in function application.
***    Function:
***       Expression.add_locale_cmd (To_sbinding (META.holThyLocale_name data))
***       Binding.empty
***       ([], [])
***       : Expression.expression ->
***           Element.context list -> theory -> string * local_theory
***    Argument:
***       (List.concat
***        (map (fn (...) => ... ...) (META.holThyLocale_header data))
***       )
***       : (string, string, 'a) Element.ctxt list
***    Reason:
***       Can't unify (string, string, 'a) Element.ctxt list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 524 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_Meta_Model/toy_example/embedding/Generator_dynamic_sequential.thy"):
*** Type error in function application.
***    Function: #> :
***       (Element.context list -> theory -> string * local_theory) *
***       ((theory -> string * local_theory) -> 'a)
***         -> Element.context list -> 'a
***    Argument:
***       (
***          Expression.add_locale_cmd (... ...) Binding.empty ([], [...])
***          (List.concat (map (fn ...) (META.holThyLocale_header data)))
***          ,
***          snd
***          )
***       : (Element.context list -> theory -> string * local_theory) *
***         ('a * 'b -> 'b)
***    Reason:
***       Can't unify theory -> string * local_theory to 'a * 'b
***          (Incompatible types)
*** ML error (line 521 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_Meta_Model/toy_example/embedding/Generator_dynamic_sequential.thy"):
*** Clauses in case have different types.
***    Clause 1: Theories_one thy => semi__theory I Named_Target.theory_map thy
***       : semi_theories -> theory -> theory
***    Clause 2:
***       Theories_locale (data, l) =>
***       fn thy => ... |> ... |> ... ... |> Local_Theory.exit_global
***       : semi_theories -> Element.context list -> theory
***    Reason:
***       Can't unify theory with Element.context list (*In Basis*)
***          (Different type constructors)
*** At command "ML" (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Isabelle_Meta_Model/toy_example/embedding/Generator_dynamic_sequential.thy")

==========
Jinja
*** Failed to finish proof (line 496 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Jinja/Compiler/Correctness1.thy"):
*** goal (13 subgoals):
***  1. ⋀x2 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x2) n
***  2. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x3) n
***  3. ⋀x2 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x2) n
***  4. ⋀x1 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n
***  5. ⋀x1 x4 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x4) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x4) n
***  6. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬs (map (compE⇩1 Vs) x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬs (map (compE⇩1 Vs) x3) n
***  7. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 (Vs @ [x1]) x3) (Suc n)
***  8. ⋀x1 x2 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x2) n
***  9. ⋀x1 x2 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x2) n ∧ ℬ (compE⇩1 Vs x3) n
***  10. ⋀x1 x2 Vs n.
***         ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***          ⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***         ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x2) n
*** A total of 13 subgoals...
*** At command "by" (line 496 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Jinja/Compiler/Correctness1.thy")
*** Failed to apply proof method (line 37 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Jinja/J/execute_Bigstep.thy"):
*** goal (1 subgoal):
***  1. ⋀a ys aa lista.
***        ⟦⋀ys. map Val lista = map Val ys ⟹ map_val (map Val ys) ys;
***         a = Val aa; ys = aa # lista⟧
***        ⟹ map_val (Val aa # map Val lista) (aa # lista)
*** At command "apply" (line 37 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Jinja/J/execute_Bigstep.thy")

==========
JinjaDCI
*** Failed to finish proof (line 792 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/JinjaDCI/Compiler/Correctness1.thy"):
*** goal (17 subgoals):
***  1. ⋀x2 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x2) n
***  2. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x3) n
***  3. ⋀x2 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x2) n
***  4. ⋀x1 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n
***  5. ⋀x1 x4 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬ (compE⇩1 Vs x4) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x4) n
***  6. ⋀x4 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x4) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x4) n
***  7. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***         ⋀Vs. ℬs (map (compE⇩1 Vs) x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬs (map (compE⇩1 Vs) x3) n
***  8. ⋀x3 Vs n.
***        ⟦⋀Vs. ℬs (map (compE⇩1 Vs) x3) (length Vs); length Vs = n⟧
***        ⟹ ℬs (map (compE⇩1 Vs) x3) n
***  9. ⋀x1 x3 Vs n.
***        ⟦⋀Vs. ℬ (compE⇩1 Vs x3) (length Vs); length Vs = n⟧
***        ⟹ ℬ (compE⇩1 (Vs @ [x1]) x3) (Suc n)
***  10. ⋀x1 x2 Vs n.
***         ⟦⋀Vs. ℬ (compE⇩1 Vs x1) (length Vs);
***          ⋀Vs. ℬ (compE⇩1 Vs x2) (length Vs); length Vs = n⟧
***         ⟹ ℬ (compE⇩1 Vs x1) n ∧ ℬ (compE⇩1 Vs x2) n
*** A total of 17 subgoals...
*** At command "by" (line 792 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/JinjaDCI/Compiler/Correctness1.thy")

==========
Key_Agreement_Strong_Adversaries
*** Failed to apply proof method (line 858 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/pfslvl2.thy"):
*** goal (2 subgoals):
***  1. ⋀y. ⟦y ∈ l2_inv1; y ∈ l2_inv3; y ∈ l2_inv7; Ra = test;
***          K ∈ synth (analz (ik y));
***          guessed_runs test = ⦇role = Init, owner = A, partner = B⦈;
***          progress y test = Some {xpkE, xskE};
***          guessed_frame test xsk = Some K; A ∈ bad y⟧
***         ⟹ False
***  2. ⋀y. ⟦y ∈ l2_inv1; y ∈ l2_inv3; y ∈ l2_inv7; Ra = test;
***          K ∈ synth (analz (ik y));
***          guessed_runs test = ⦇role = Init, owner = A, partner = B⦈;
***          progress y test = Some {xpkE, xskE};
***          guessed_frame test xsk = Some K; B ∈ bad y⟧
***         ⟹ False
*** At command "apply" (line 858 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/pfslvl2.thy")
*** Failed to apply proof method (line 789 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/pfslvl2.thy"):
*** goal (2 subgoals):
***  1. ⋀xb xc xh xi.
***        ⟦xb ∈ l2_inv3; xb ∈ l2_inv8; xb ∈ l2_inv1;
***         guessed_runs test = ⦇role = Init, owner = xh, partner = xi⦈;
***         progress xb test = Some {xpkE, xskE};
***         guessed_frame test xsk = Some xc;
***         ∀R. xc = NonceF (R $ sk) ⟶
***             R ≠ test ∧
***             (owner (guessed_runs R) = xi ⟶
***              xh = partner (guessed_runs R) ⟶
***              Init = role_comp (role (guessed_runs R)) ⟶
***              (∃x. (x = xpkE ∨ x = xskE ∨ x = xsk) ∧
***                   x ∈ domain (role (guessed_runs R)) ∧
***                   guessed_frame test x ≠ guessed_frame R x));
***         xh ∈ bad xb⟧
***        ⟹ False
***  2. ⋀xb xc xh xi.
***        ⟦xb ∈ l2_inv3; xb ∈ l2_inv8; xb ∈ l2_inv1;
***         guessed_runs test = ⦇role = Init, owner = xh, partner = xi⦈;
***         progress xb test = Some {xpkE, xskE};
***         guessed_frame test xsk = Some xc;
***         ∀R. xc = NonceF (R $ sk) ⟶
***             R ≠ test ∧
***             (owner (guessed_runs R) = xi ⟶
***              xh = partner (guessed_runs R) ⟶
***              Init = role_comp (role (guessed_runs R)) ⟶
***              (∃x. (x = xpkE ∨ x = xskE ∨ x = xsk) ∧
***                   x ∈ domain (role (guessed_runs R)) ∧
***                   guessed_frame test x ≠ guessed_frame R x));
***         xi ∈ bad xb⟧
***        ⟹ False
*** At command "apply" (line 789 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/pfslvl2.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 571 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/Implem_symmetric.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 477 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Key_Agreement_Strong_Adversaries/Implem_asymmetric.thy")

==========
Kuratowski_Closure_Complement
*** Undefined fact: "card_insert" (line 451 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy")
*** At command "by" (line 451 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy")
*** Undefined fact: "card_insert" (line 292 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy")
*** At command "by" (line 292 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy")

==========
Lambda_Free_RPOs
*** Failed to load theory "Lambda_Free_RPOs.Lambda_Encoding" (unresolved "Lambda_Free_RPOs.Lambda_Free_Term")
*** Failed to load theory "Lambda_Free_RPOs.Lambda_Free_RPO_App" (unresolved "Lambda_Free_RPOs.Lambda_Free_Term")
*** Failed to load theory "Lambda_Free_RPOs.Lambda_Free_RPO_Std" (unresolved "Lambda_Free_RPOs.Lambda_Free_Term", "Nested_Multisets_Ordinals.Multiset_More")
*** Failed to load theory "Lambda_Free_RPOs.Lambda_Free_RPO_Optim" (unresolved "Lambda_Free_RPOs.Lambda_Free_RPO_Std")
*** Failed to load theory "Lambda_Free_RPOs.Lambda_Free_RPOs" (unresolved "Lambda_Free_RPOs.Lambda_Encoding", "Lambda_Free_RPOs.Lambda_Free_RPO_App", "Lambda_Free_RPOs.Lambda_Free_RPO_Optim")
*** Type unification failed: Clash of types "_ multiset" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (#) ⋃ ::
***   (??'a set set ⇒ ??'a set) list ⇒ (??'a set set ⇒ ??'a set) list
*** Operand:   {#vars_mset (ρ x). x ∈# vars_mset s#} :: ??'b multiset multiset
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** No coercion known for type constructors: "multiset" and "list"
*** At command "lemma" (line 260 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lambda_Free_RPOs/Lambda_Free_Term.thy")
*** Type unification failed: Clash of types "_ multiset" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (#) ⋃ ::
***   (??'a set set ⇒ ??'a set) list ⇒ (??'a set set ⇒ ??'a set) list
*** Operand:   {#image_mset (Pair a) (B a). a ∈# A#} ::
***   ('a × 'b) multiset multiset
*** 
*** At command "definition" (line 527 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy")

==========
Latin_Square
*** Undefined fact: "card_infinite" (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Latin_Square/Latin_Square.thy")
*** At command "using" (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Latin_Square/Latin_Square.thy")

==========
Launchbury
*** Failed to load theory "Launchbury.Nominal-Utils" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Launchbury.AList-Utils-Nominal" (unresolved "Launchbury.Nominal-Utils")
*** Failed to load theory "Launchbury.Vars" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Launchbury.EvalHeap" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Launchbury.Terms" (unresolved "Launchbury.AList-Utils-Nominal", "Launchbury.Nominal-Utils", "Launchbury.Vars")
*** Failed to load theory "Launchbury.Nominal-HOLCF" (unresolved "Launchbury.Nominal-Utils")
*** Failed to load theory "Launchbury.Substitution" (unresolved "Launchbury.Terms")
*** Failed to load theory "Launchbury.Launchbury" (unresolved "Launchbury.Substitution", "Launchbury.Terms")
*** Failed to load theory "Launchbury.CValue-Nominal" (unresolved "Launchbury.Nominal-HOLCF", "Launchbury.Nominal-Utils")
*** Failed to load theory "Launchbury.Env-Nominal" (unresolved "Launchbury.Nominal-HOLCF", "Launchbury.Nominal-Utils")
*** Failed to load theory "Launchbury.HasESem" (unresolved "Launchbury.Nominal-HOLCF")
*** Failed to load theory "Launchbury.Value-Nominal" (unresolved "Launchbury.Nominal-HOLCF", "Launchbury.Nominal-Utils")
*** Failed to load theory "Launchbury.HeapSemantics" (unresolved "Launchbury.AList-Utils-Nominal", "Launchbury.Env-Nominal", "Launchbury.EvalHeap", "Launchbury.HasESem")
*** Failed to load theory "Launchbury.AbstractDenotational" (unresolved "Launchbury.HeapSemantics", "Launchbury.Terms")
*** Failed to load theory "Launchbury.Abstract-Denotational-Props" (unresolved "Launchbury.AbstractDenotational", "Launchbury.Substitution")
*** Failed to load theory "Launchbury.ResourcedDenotational" (unresolved "Launchbury.Abstract-Denotational-Props", "Launchbury.CValue-Nominal")
*** Failed to load theory "Launchbury.CorrectnessResourced" (unresolved "Launchbury.Launchbury", "Launchbury.ResourcedDenotational")
*** Failed to load theory "Launchbury.ResourcedAdequacy" (unresolved "Launchbury.CorrectnessResourced", "Launchbury.Launchbury", "Launchbury.ResourcedDenotational")
*** Failed to load theory "Launchbury.Denotational" (unresolved "Launchbury.Abstract-Denotational-Props", "Launchbury.Value-Nominal")
*** Failed to load theory "Launchbury.CorrectnessOriginal" (unresolved "Launchbury.Denotational", "Launchbury.Launchbury")
*** Failed to load theory "Launchbury.Denotational-Related" (unresolved "Launchbury.Denotational", "Launchbury.ResourcedDenotational")
*** Failed to load theory "Launchbury.Adequacy" (unresolved "Launchbury.Denotational-Related", "Launchbury.ResourcedAdequacy")
*** Failed to load theory "Launchbury.EverythingAdequacy" (unresolved "Launchbury.Adequacy", "Launchbury.CorrectnessOriginal")
*** ML error (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 328 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML_file" (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/Nominal2.thy")

==========
Lazy_Case
*** Failed to load theory "Lazy_Case.Test_Lazy_Case" (unresolved "Lazy_Case.Lazy_Case")
*** ML error (line 59 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lazy_Case/lazy_case.ML"):
*** Value or constructor (open_target) has not been declared in structure Local_Theory
*** ML error (line 64 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lazy_Case/lazy_case.ML"):
*** Value or constructor (close_target) has not been declared in structure Local_Theory
*** At command "ML_file" (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lazy_Case/Lazy_Case.thy")

==========
LightweightJava
*** Failed to apply proof method (line 1579 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (10 subgoals):
***  1. ⋀L oid H v s_list ty_oid fs_oid Γ x ty_x P f ty ty' Pa.
***        ⟦wf_program Pa; wf_heap Pa H; wf_varstate Pa ty_x H L;
***         config' = config_normal Pa (L(x_var ty_oid ↦ s_list)) H fs_oid;
***         L P = Some (v_oid oid); ∀x∈set fs_oid. wf_stmt Pa ty_x x;
***         H oid = Some (Γ, x); x [] = Some s_list; ty_x P = Some f;
***         ftype_f Pa f [] = Some ty; ty_x (x_var ty_oid) = Some ty';
***         is_sty_one Pa ty ty' = Some True⟧
***        ⟹ wf_object Pa H (Some s_list) (Some ty')
***  2. ⋀L oid H v s_list ty_oid fs_oid Γ x ty_x P f ty ty' Pa a list.
***        ⟦wf_program Pa; wf_heap Pa H; wf_varstate Pa ty_x H L;
***         config' = config_normal Pa (L(x_var ty_oid ↦ s_list)) H fs_oid;
***         L P = Some (v_oid oid); ∀x∈set fs_oid. wf_stmt Pa ty_x x;
***         H oid = Some (Γ, x); x v = Some s_list; ty_x P = Some f;
***         ftype_f Pa f v = Some ty; ty_x (x_var ty_oid) = Some ty';
***         is_sty_one Pa ty ty' = Some True; v = a # list⟧
***        ⟹ wf_object Pa H (Some s_list) (Some ty')
***  3. ⋀L x oid H f v P var s_list Γ' a b Γ xa ty Pa ty'.
***        ⟦wf_program Pa; wf_heap Pa H; wf_varstate Pa Γ H L;
***         config' = config_normal Pa (L(x_var var ↦ v)) H s_list;
***         L xa = Some (v_oid oid); ∀x∈set s_list. wf_stmt Pa Γ x;
***         H oid = Some (a, b); b f = Some v; P = Pa; Γ' = Γ; x = xa;
***         Γ xa = Some ty; ftype_f Pa ty f = Some ty';
***         sty_option Pa (Some ty') (Γ (x_var var))⟧
***        ⟹ ∀x∈set s_list. wf_stmt Pa Γ x
***  4. ⋀Γ config L x P H f y s_list Pa Γ'.
***        ⟦Pa = P; config' = config_ex P L H ex_npe; L x = Some v_null; Γ = Γ';
***         config = config_normal P L H (s_write x f y # s_list); wf_program P;
***         wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_write x f y) ∧ (∀x∈set s_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ' (config_ex P L H ex_npe)
***  5. ⋀Γ config L x oid y v P H f s_list arbitrary Pa Γ'.
***        ⟦Pa = P;
***         config' =
***         config_normal P L
***          (case H oid of None ⇒ arbitrary
***           | Some tyfs ⇒ H(oid ↦ (fst tyfs, snd tyfs(f ↦ v))))
***          s_list;
***         L x = Some (v_oid oid); L y = Some v; Γ = Γ';
***         config = config_normal P L H (s_write x f y # s_list); wf_program P;
***         wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_write x f y) ∧ (∀x∈set s_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ'
***            (config_normal P L
***              (case H oid of None ⇒ arbitrary
***               | Some tyfs ⇒ H(oid ↦ (fst tyfs, snd tyfs(f ↦ v))))
***              s_list)
***  6. ⋀Γ config L x v y w P H s1 s2 s'_list Pa Γ'.
***        ⟦Pa = P; config' = config_normal P L H (s1 # s'_list); L x = Some w;
***         L y = Some w; v = w; Γ = Γ';
***         config = config_normal P L H (s_if x y s1 s2 # s'_list);
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_if x y s1 s2) ∧ (∀x∈set s'_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ' (config_normal P L H (s1 # s'_list))
***  7. ⋀Γ config L x v y w P H s1 s2 s'_list Pa Γ'.
***        ⟦Pa = P; config' = config_normal P L H (s2 # s'_list); L x = Some v;
***         L y = Some w; v ≠ w; Γ = Γ';
***         config = config_normal P L H (s_if x y s1 s2 # s'_list);
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_if x y s1 s2) ∧ (∀x∈set s'_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ' (config_normal P L H (s2 # s'_list))
***  8. ⋀Γ config P ctx cl ty f_list oid H H' L var s_list Pa Γ'.
***        ⟦Pa = P;
***         config' =
***         config_normal P (L(x_var var ↦ v_oid oid))
***          (H(oid ↦ (ty, map_of (map (λf_XXX. (f_XXX, v_null)) f_list))))
***          s_list;
***         find_type_f P ctx cl = Some ty; fields_f P ty = Some f_list;
***         oid ∉ dom H;
***         H' = H(oid ↦ (ty, map_of (map (λf_XXX. (f_XXX, v_null)) f_list)));
***         Γ = Γ'; config = config_normal P L H (s_new var ctx cl # s_list);
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_new var ctx cl) ∧ (∀x∈set s_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ'
***            (config_normal P (L(x_var var ↦ v_oid oid))
***              (H(oid ↦ (ty, map_of (map (λf_XXX. (f_XXX, v_null)) f_list))))
***              s_list)
***  9. ⋀Γ config L x P H var meth y_list s_list Pa Γ'.
***        ⟦Pa = P; config' = config_ex P L H ex_npe; L x = Some v_null; Γ = Γ';
***         config = config_normal P L H (s_call var x meth y_list # s_list);
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         wf_stmt P Γ' (s_call var x meth y_list) ∧
***         (∀x∈set s_list. wf_stmt P Γ' x)⟧
***        ⟹ wf_config Γ' (config_ex P L H ex_npe)
***  10. ⋀Γ config L x oid H ty P meth ctx cl y_cl_var_var'_v_list s''_s'_list y
***         x' L' T y' var s_list Pa Γ'.
***         ⟦Pa = P;
***          config' =
***          config_normal P
***           ((L ++
***             map_of
***              (map (λ(y_XXX, cl_XXX, var_XXX, var_', y). (x_var var_', y))
***                y_cl_var_var'_v_list))
***            (x' ↦ v_oid oid))
***           H (map fst s''_s'_list @ s_ass var y' # s_list);
***          L x = Some (v_oid oid);
***          (case H oid of None ⇒ None | Some tyfs ⇒ Some (fst tyfs)) =
***          Some ty;
***          find_meth_def_f P ty meth =
***          Some
***           (ctx,
***            meth_def_def
***             (meth_sig_def cl meth
***               (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX).
***                        vd_def cl_XXX var_XXX)
***                 y_cl_var_var'_v_list))
***             (meth_body_def (map snd s''_s'_list) y));
***          (λx. case x of
***               (y_XXX, cl_XXX, var_XXX, var_', v_XXX) ⇒ x_var var_') `
***          set y_cl_var_var'_v_list ∩
***          dom L =
***          {};
***          distinct
***           (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX). var_')
***             y_cl_var_var'_v_list);
***          x' ∉ dom L;
***          x' ∉ (λx. case x of
***                    (y_XXX, cl_XXX, var_XXX, var_', v_XXX) ⇒ x_var var_') `
***               set y_cl_var_var'_v_list;
***          ∀x∈set y_cl_var_var'_v_list.
***             case x of
***             (y_XXX, cl_XXX, var_XXX, var_', v_XXX) ⇒ L y_XXX = Some v_XXX;
***          L' =
***          (L ++
***           map_of
***            (map (λ(y_XXX, cl_XXX, var_XXX, var_', y). (x_var var_', y))
***              y_cl_var_var'_v_list))
***          (x' ↦ v_oid oid);
***          T =
***          map_of
***           (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX).
***                    (x_var var_XXX, x_var var_'))
***             y_cl_var_var'_v_list)
***          (x_this ↦ x');
***          ∀x∈set s''_s'_list.
***             case x of
***             (s_'', s_') ⇒
***               tr_s
***                (map_of
***                  (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX).
***                           (x_var var_XXX, x_var var_'))
***                    y_cl_var_var'_v_list)
***                 (x_this ↦ x'))
***                s_' s_'';
***          (case if y = x_this then Some x'
***                else map_of
***                      (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX).
***                               (x_var var_XXX, x_var var_'))
***                        y_cl_var_var'_v_list)
***                      y of
***           None ⇒ y | Some x' ⇒ x') =
***          y';
***          Γ = Γ';
***          config =
***          config_normal P L H
***           (s_call var x meth
***             (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX). y_XXX)
***               y_cl_var_var'_v_list) #
***            s_list);
***          wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***          wf_stmt P Γ'
***           (s_call var x meth
***             (map (λ(y_XXX, cl_XXX, var_XXX, var_', v_XXX). y_XXX)
***               y_cl_var_var'_v_list)) ∧
***          (∀x∈set s_list. wf_stmt P Γ' x)⟧
***         ⟹ ∃Γ''. Γ' ⊆⇩m Γ'' ∧
***                  wf_config Γ''
***                   (config_normal P
***                     ((L ++
***                       map_of
***                        (map (λ(y_XXX, cl_XXX, var_XXX, var_', y).
***                                 (x_var var_', y))
***                          y_cl_var_var'_v_list))
***                      (x' ↦ v_oid oid))
***                     H (map fst s''_s'_list @ s_ass var y' # s_list))
*** At command "apply" (line 1579 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 1479 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (5 subgoals):
***  1. ⋀ss x31 x33 xa x oid ty_x_s ty_x_d fields_oid fs.
***        ⟦is_sty_one P ty_x_d ty_x_s = Some True; wf_program P;
***         S = s_read x31 xa x33 # ss; ∀x∈set ss. wf_stmt P Γ x;
***         ftype_f P ty_x_s x33 = Some x;
***         sty_option P (Some x) (Γ (x_var x31)); finite (dom L);
***         L xa = Some (v_oid oid); Γ xa = Some ty_x_s;
***         H oid = Some (ty_x_d, fields_oid); finite (dom H);
***         fields_f P ty_x_d = Some fs;
***         ∀f∈set fs.
***            ∃ty'. ftype_f P ty_x_d f = Some ty' ∧
***                  wf_object P H (fields_oid f) (Some ty');
***         x33 ∈ set fs⟧
***        ⟹ Ex (r_stmt (config_normal P L H (s_read x31 xa x33 # ss)))
***  2. ⋀s ss x41 x42 x43 Γ'.
***        ⟦s = s_write x41 x42 x43; Γ = Γ'; s_write x41 x42 x43 # ss = S;
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         ∀x∈set S. wf_stmt P Γ' x⟧
***        ⟹ Ex (r_stmt (config_normal P L H S))
***  3. ⋀s ss x51 x52 x53 x54 Γ'.
***        ⟦s = s_if x51 x52 x53 x54; Γ = Γ'; s_if x51 x52 x53 x54 # ss = S;
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         ∀x∈set S. wf_stmt P Γ' x⟧
***        ⟹ Ex (r_stmt (config_normal P L H S))
***  4. ⋀s ss x61 x62 x63 Γ'.
***        ⟦s = s_new x61 x62 x63; Γ = Γ'; s_new x61 x62 x63 # ss = S;
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         ∀x∈set S. wf_stmt P Γ' x⟧
***        ⟹ Ex (r_stmt (config_normal P L H S))
***  5. ⋀s ss x71 x72 x73 x74 Γ'.
***        ⟦s = s_call x71 x72 x73 x74; Γ = Γ'; s_call x71 x72 x73 x74 # ss = S;
***         wf_program P; wf_heap P H; wf_varstate P Γ' H L;
***         ∀x∈set S. wf_stmt P Γ' x⟧
***        ⟹ Ex (r_stmt (config_normal P L H S))
*** At command "apply" (line 1479 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 1327 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (1 subgoal):
***  1. ⋀P ctx fqn path a b suffix aa ba.
***        ⟦⋀aa x.
***            ⟦a = aa; x = aa⟧
***            ⟹ ∀suffix.
***                  find_path_rec_f P aa (superclass_name_f b)
***                   (path @ [(aa, b)]) =
***                  Some (path @ (aa, b) # suffix) ⟶
***                  (∀x∈set suffix.
***                      case x of
***                      (ctx', cld') ⇒
***                        ∀prefix'.
***                           ∃suffix'.
***                              (case find_cld_f P ctx'
***                                     (fqn_def (class_name_f cld')) of
***                               None ⇒ None
***                               | Some (ctx', cld) ⇒
***                                   find_path_rec_f P ctx'
***                                    (superclass_name_f cld)
***                                    (prefix' @ [(ctx', cld)])) =
***                              Some suffix');
***         find_cld_f P ctx fqn = Some (a, b); acyclic_clds P;
***         find_path_rec_f P a (superclass_name_f b) (path @ [(a, b)]) =
***         Some (path @ suffix);
***         (aa, ba) ∈ set suffix;
***         ∀aa ba aaa bb.
***            a = aaa ∧ b = bb ∧ aa = aaa ∧ ba = bb ⟶
***            (∀suffix.
***                find_path_rec_f P aaa (superclass_name_f bb)
***                 (path @ [(aaa, bb)]) =
***                Some (path @ (aaa, bb) # suffix) ⟶
***                (∀x∈set suffix.
***                    case x of
***                    (ctx', cld') ⇒
***                      ∀prefix'.
***                         ∃suffix'.
***                            (case find_cld_f P ctx'
***                                   (fqn_def (class_name_f cld')) of
***                             None ⇒ None
***                             | Some (ctx', cld) ⇒
***                                 find_path_rec_f P ctx'
***                                  (superclass_name_f cld)
***                                  (prefix' @ [(ctx', cld)])) =
***                            Some suffix'))⟧
***        ⟹ (∃a b. find_cld_f P aa (fqn_def (class_name_f ba)) =
***                  Some (a, b)) ∧
***           (∀prefix' a b.
***               find_cld_f P aa (fqn_def (class_name_f ba)) = Some (a, b) ⟶
***               (∃suffix'.
***                   find_path_rec_f P a (superclass_name_f b)
***                    (prefix' @ [(a, b)]) =
***                   Some suffix'))
*** At command "apply" (line 1327 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 1272 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (1 subgoal):
***  1. ⟦finite (dom H);
***      ∀oid∈dom H.
***         ∃ty. (case H oid of None ⇒ None | Some tyfs ⇒ Some (fst tyfs)) =
***              Some ty ∧
***              (∃fs. fields_f P ty = Some fs ∧
***                    (∀f∈set fs.
***                        ∃ty'. ftype_f P ty f = Some ty' ∧
***                              wf_object P H
***                               (case H oid of None ⇒ None
***                                | Some tyfs ⇒ snd tyfs f)
***                               (Some ty')))⟧
***     ⟹ ∃oid. oid ∉ dom H
*** At command "apply" (line 1272 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (2 subgoals):
***  1. ⋀P path a prefix' path'' list1 cl list2 list3 path''a.
***        ⟦∀x∈set path''.
***            case x of
***            (ctx, cld) ⇒
***              ∀x1. (∀x2 x3 x4. cld ≠ cld_def x1 x2 x3 x4) ∨
***                   (∀prefix' suffix'.
***                       (case find_cld_f P ctx (fqn_def x1) of None ⇒ None
***                        | Some (ctx', cld) ⇒
***                            find_path_rec_f P ctx' (superclass_name_f cld)
***                             (prefix' @ [(ctx', cld)])) =
***                       Some (prefix' @ suffix') ⟶
***                       ftype_in_path_f P suffix' f ≠ Some ty) ∨
***                   ftype_in_path_f P path'' f = Some ty;
***         find_cld_f P a (fqn_def list1) =
***         Some (a, cld_def list1 cl list2 list3);
***         acyclic_clds P;
***         find_path_rec_f P a
***          (superclass_name_f (cld_def list1 cl list2 list3))
***          (path @ [(a, cld_def list1 cl list2 list3)]) =
***         Some (path @ (a, cld_def list1 cl list2 list3) # path'');
***         wf_program P;
***         find_path_rec_f P a
***          (superclass_name_f (cld_def list1 cl list2 list3))
***          (prefix' @ [(a, cld_def list1 cl list2 list3)]) =
***         Some (prefix' @ (a, cld_def list1 cl list2 list3) # path''a);
***         (case ftype_in_fds_f P a
***                (class_fields_f (cld_def list1 cl list2 list3)) f of
***          ty_opt_bot_opt None ⇒ ftype_in_path_f P path''a f
***          | ty_opt_bot_opt (Some xa) ⇒ Some xa | ty_opt_bot_bot ⇒ None) =
***         Some ty⟧
***        ⟹ (case ftype_in_fds_f P a
***                  (class_fields_f (cld_def list1 cl list2 list3)) f of
***            ty_opt_bot_opt None ⇒ ftype_in_path_f P path'' f
***            | ty_opt_bot_opt (Some xa) ⇒ Some xa | ty_opt_bot_bot ⇒ None) =
***           Some ty
***  2. ⋀P ctx fqn path a b aa ba ab prefix' bb suffix' path''.
***        ⟦find_cld_f P ctx fqn = Some (a, b); acyclic_clds P;
***         find_path_rec_f P a (superclass_name_f b) (path @ [(a, b)]) =
***         Some (path @ (a, b) # path'');
***         wf_program P;
***         find_cld_f P aa (fqn_def (class_name_f ba)) = Some (ab, bb);
***         find_path_rec_f P ab (superclass_name_f bb) (prefix' @ [(ab, bb)]) =
***         Some (prefix' @ suffix');
***         ftype_in_path_f P suffix' f = Some ty;
***         ∀x∈set path''.
***            case x of
***            (ctx, cld) ⇒
***              (∃prefix' suffix'.
***                  (case find_cld_f P ctx (fqn_def (class_name_f cld)) of
***                   None ⇒ None
***                   | Some (ctx', cld) ⇒
***                       find_path_rec_f P ctx' (superclass_name_f cld)
***                        (prefix' @ [(ctx', cld)])) =
***                  Some (prefix' @ suffix') ∧
***                  ftype_in_path_f P suffix' f = Some ty) ⟶
***              ftype_in_path_f P path'' f = Some ty;
***         (aa, ba) ∈ set path''⟧
***        ⟹ (case ftype_in_fds_f P a (class_fields_f b) f of
***            ty_opt_bot_opt None ⇒ ftype_in_path_f P path'' f
***            | ty_opt_bot_opt (Some xa) ⇒ Some xa | ty_opt_bot_bot ⇒ None) =
***           Some ty
*** At command "apply" (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 433 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (1 subgoal):
***  1. ⋀P ctx path a dcl aa ba ab bb prefix' suffix' path'' dcl' fds' mds'
***        dcl'' ac b.
***        ⟦⋀aa x.
***            ⟦a = aa; x = aa⟧
***            ⟹ ∀suffix.
***                  (case find_cld_f P aa (fqn_def dcl'') of None ⇒ None
***                   | Some (ctx', cld) ⇒
***                       find_path_rec_f P ctx' (superclass_name_f cld)
***                        ((path @
***                          [(aa,
***                            cld_def dcl' (cl_fqn (fqn_def dcl'')) fds'
***                             mds')]) @
***                         [(ctx', cld)])) =
***                  Some
***                   (path @
***                    (aa, cld_def dcl' (cl_fqn (fqn_def dcl'')) fds' mds') #
***                    suffix) ⟶
***                  (∀x∈set suffix.
***                      case x of
***                      (ctx', cld') ⇒
***                        (∃prefix' suffix'.
***                            (case find_cld_f P ctx'
***                                   (fqn_def (class_name_f cld')) of
***                             None ⇒ None
***                             | Some (ctx', cld) ⇒
***                                 find_path_rec_f P ctx'
***                                  (superclass_name_f cld)
***                                  (prefix' @ [(ctx', cld)])) =
***                            Some (prefix' @ suffix')) ∧
***                        mtype_f P (ty_def ctx' (class_name_f cld')) m =
***                        Some mty ⟶
***                        mtype_f P (ty_def aa dcl'') m = Some mty);
***         find_cld_f P ctx (fqn_def dcl) =
***         Some (a, cld_def dcl' (cl_fqn (fqn_def dcl'')) fds' mds');
***         acyclic_clds P; wf_program P;
***         find_cld_f P aa (fqn_def (class_name_f ba)) = Some (ab, bb);
***         mtype_f P (ty_def aa (class_name_f ba)) m = Some mty;
***         find_path_rec_f P ab (case bb of cld_def dcl cl fds mds ⇒ cl)
***          (prefix' @ [(ab, bb)]) =
***         Some (prefix' @ suffix');
***         (aa, ba) ∈ set path'';
***         find_cld_f P a (fqn_def dcl'') = Some (ac, b);
***         find_path_rec_f P ac (superclass_name_f b)
***          (path @
***           [(a, cld_def dcl' (cl_fqn (fqn_def dcl'')) fds' mds'), (ac, b)]) =
***         Some
***          (path @
***           (a, cld_def dcl' (cl_fqn (fqn_def dcl'')) fds' mds') # path'');
***         ∀aa b ab bb.
***            a = ab ∧
***            cld_def dcl' (cl_fqn (fqn_def dcl'')) fds' mds' = bb ∧
***            aa = ab ∧ b = bb ⟶
***            (∀suffix.
***                find_path_rec_f P ab (case bb of cld_def dcl cl fds mds ⇒ cl)
***                 (path @ [(ab, bb)]) =
***                Some (path @ (ab, bb) # suffix) ⟶
***                (∀dcl. (case bb of cld_def dcl cl fds mds ⇒ cl) =
***                       cl_fqn (fqn_def dcl) ⟶
***                       (∀x∈set suffix.
***                           case x of
***                           (ctx', cld') ⇒
***                             (∃prefix' suffix'.
***                                 (case find_cld_f P ctx'
***  (fqn_def (class_name_f cld')) of
***                                  None ⇒ None
***                                  | Some (ctx', cld) ⇒
***                                      find_path_rec_f P ctx'
*** (superclass_name_f cld) (prefix' @ [(ctx', cld)])) =
***                                 Some (prefix' @ suffix')) ∧
***                             mtype_f P (ty_def ctx' (class_name_f cld')) m =
***                             Some mty ⟶
***                             mtype_f P (ty_def ab dcl) m = Some mty)))⟧
***        ⟹ mtype_f P (ty_def ctx dcl) m = Some mty
*** At command "apply" (line 433 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 584 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (1 subgoal):
***  1. ⋀P ctx fqn path a b suffix aa ba ab prefix' bb suffix'.
***        ⟦⋀aa x.
***            ⟦a = aa; x = aa⟧
***            ⟹ ∀suffix.
***                  find_path_rec_f P aa (superclass_name_f b)
***                   (path @ [(aa, b)]) =
***                  Some (path @ (aa, b) # suffix) ⟶
***                  (∀x∈set suffix.
***                      case x of
***                      (ctx, cld) ⇒
***                        (∃prefix' suffix'.
***                            (case find_cld_f P ctx
***                                   (fqn_def (class_name_f cld)) of
***                             None ⇒ None
***                             | Some (ctx', cld) ⇒
***                                 find_path_rec_f P ctx'
***                                  (superclass_name_f cld)
***                                  (prefix' @ [(ctx', cld)])) =
***                            Some (prefix' @ suffix') ∧
***                            f ∈ set (fields_in_path_f suffix')) ⟶
***                        f ∈ set (fields_in_path_f suffix));
***         find_cld_f P ctx fqn = Some (a, b); acyclic_clds P;
***         find_path_rec_f P a (superclass_name_f b) (path @ [(a, b)]) =
***         Some (path @ suffix);
***         wf_program P; (aa, ba) ∈ set suffix;
***         find_cld_f P aa (fqn_def (class_name_f ba)) = Some (ab, bb);
***         find_path_rec_f P ab (superclass_name_f bb) (prefix' @ [(ab, bb)]) =
***         Some (prefix' @ suffix');
***         f ∈ set (fields_in_path_f suffix');
***         ∀aa ba aaa bb.
***            a = aaa ∧ b = bb ∧ aa = aaa ∧ ba = bb ⟶
***            (∀suffix.
***                find_path_rec_f P aaa (superclass_name_f bb)
***                 (path @ [(aaa, bb)]) =
***                Some (path @ (aaa, bb) # suffix) ⟶
***                (∀x∈set suffix.
***                    case x of
***                    (ctx, cld) ⇒
***                      (∃prefix' suffix'.
***                          (case find_cld_f P ctx
***                                 (fqn_def (class_name_f cld)) of
***                           None ⇒ None
***                           | Some (ctx', cld) ⇒
***                               find_path_rec_f P ctx' (superclass_name_f cld)
***                                (prefix' @ [(ctx', cld)])) =
***                          Some (prefix' @ suffix') ∧
***                          f ∈ set (fields_in_path_f suffix')) ⟶
***                      f ∈ set (fields_in_path_f suffix)))⟧
***        ⟹ f ∈ set (fields_in_path_f suffix)
*** At command "apply" (line 584 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 312 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy"):
*** goal (1 subgoal):
***  1. ⋀cld. ⟦(ctx, cld) ∈ set ctxclds; meth_def ∈ set (class_methods_f cld);
***            ∀x∈set ctxclds. case x of (ctx, cld) ⇒ cld ∈ set P;
***            distinct_names_f P; ∀x∈set P. wf_class P x; acyclic_clds P⟧
***           ⟹ wf_meth P (ty_def ctx_def (class_name_f cld)) meth_def
*** At command "apply" (line 312 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Proof.thy")
*** Failed to apply proof method (line 698 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Equivalence.thy"):
*** goal (2 subgoals):
***  1. ⋀P ctx fqn path' ctx' cld' cld'' ctx'' path''' cl fds mds.
***        ⟦⋀a x. ⟦ctx' = a; x = a⟧
***               ⟹ find_path_rec_f P a (superclass_name_f cld')
***                   (path' @ [(a, cld')]) =
***                  Some path ⟶
***                  (∀ctxcld∈set path.
***                      ctxcld = (a, cld') ∨
***                      ctxcld ∈ set path' ∨
***                      (∀path_fqn.
***                          (case find_cld_f P (fst ctxcld)
***                                 (fqn_def (class_name_f (snd ctxcld))) of
***                           None ⇒ None
***                           | Some (ctx', cld) ⇒
***                               find_path_rec_f P ctx' (superclass_name_f cld)
***                                (path'' @ [(ctx', cld)])) =
***                          Some path_fqn ⟶
***                          (∀path'''.
***                              path_fqn = path'' @ path''' ⟶
***                              (∃path_rest. path = path_rest @ path'''))));
***         find_cld_f P ctx fqn = Some (ctx', cld'); acyclic_clds P;
***         find_path_rec_f P ctx' (superclass_name_f cld')
***          (path' @ [(ctx', cld')]) =
***         Some path;
***         (cld'', ctx'') ∈ set path;
***         find_cld_f P cld'' (fqn_def (class_name_f ctx'')) =
***         Some (cld'', cld_def (class_name_f ctx'') cl fds mds);
***         (cld'', ctx'') ∉ set path';
***         find_path_rec_f P cld''
***          (superclass_name_f (cld_def (class_name_f ctx'') cl fds mds))
***          (path'' @ [(cld'', cld_def (class_name_f ctx'') cl fds mds)]) =
***         Some (path'' @ path''');
***         ∀ctxcld∈set path.
***            ctxcld = (ctx', cld') ∨
***            ctxcld ∈ set path' ∨
***            (∀path_fqn.
***                (case find_cld_f P (fst ctxcld)
***                       (fqn_def (class_name_f (snd ctxcld))) of
***                 None ⇒ None
***                 | Some (ctx', cld) ⇒
***                     find_path_rec_f P ctx' (superclass_name_f cld)
***                      (path'' @ [(ctx', cld)])) =
***                Some path_fqn ⟶
***                (∀path'''.
***                    path_fqn = path'' @ path''' ⟶
***                    (∃path_rest. path = path_rest @ path''')))⟧
***        ⟹ ∃path_rest. path = path_rest @ path'''
***  2. ⋀P ctx fqn path' ctx' cld' cld'' ctx'' path''' cl fds mds.
***        ⟦⋀a x. ⟦ctx' = a; x = a⟧
***               ⟹ find_path_rec_f P a (superclass_name_f cld')
***                   (path' @ [(a, cld')]) =
***                  Some path ⟶
***                  (∀ctxcld∈set path.
***                      ctxcld = (a, cld') ∨
***                      ctxcld ∈ set path' ∨
***                      (∀path_fqn.
***                          (case find_cld_f P (fst ctxcld)
***                                 (fqn_def (class_name_f (snd ctxcld))) of
***                           None ⇒ None
***                           | Some (ctx', cld) ⇒
***                               find_path_rec_f P ctx' (superclass_name_f cld)
***                                (path'' @ [(ctx', cld)])) =
***                          Some path_fqn ⟶
***                          (∀path'''.
***                              path_fqn = path'' @ path''' ⟶
***                              (∃path_rest. path = path_rest @ path'''))));
***         find_cld_f P ctx fqn = Some (ctx', cld'); acyclic_clds P;
***         find_path_rec_f P ctx' (superclass_name_f cld')
***          (path' @ [(ctx', cld')]) =
***         Some path;
***         (cld'', ctx'') ∈ set path;
***         find_cld_f P cld'' (fqn_def (class_name_f ctx'')) =
***         Some (cld'', cld_def (class_name_f ctx'') cl fds mds);
***         (cld'', ctx'') ∉ set path';
***         find_path_rec_f P cld''
***          (superclass_name_f (cld_def (class_name_f ctx'') cl fds mds))
***          (path'' @ [(cld'', cld_def (class_name_f ctx'') cl fds mds)]) =
***         Some (path'' @ path''')⟧
***        ⟹ find_path_rec_f P ctx' (superclass_name_f cld')
***            (path' @ [(ctx', cld')]) =
***           Some path ⟶
***           (∀ctxcld∈set path.
***               ctxcld = (ctx', cld') ∨
***               ctxcld ∈ set path' ∨
***               (∀path_fqn.
***                   (case find_cld_f P (fst ctxcld)
***                          (fqn_def (class_name_f (snd ctxcld))) of
***                    None ⇒ None
***                    | Some (ctx', cld) ⇒
***                        find_path_rec_f P ctx' (superclass_name_f cld)
***                         (path'' @ [(ctx', cld)])) =
***                   Some path_fqn ⟶
***                   (∀path'''.
***                       path_fqn = path'' @ path''' ⟶
***                       (∃path_rest. path = path_rest @ path'''))))
*** At command "apply" (line 698 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Equivalence.thy")
*** Failed to apply proof method (line 314 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Equivalence.thy"):
*** goal (1 subgoal):
***  1. ⋀a. find_path_ty_f P ty = Some a ⟹
***         fields P ty (Some (fields_in_path_f a))
*** At command "apply" (line 314 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/LightweightJava/Lightweight_Java_Equivalence.thy")

==========
LinearQuantifierElim


==========
List-Infinite
*** Undefined fact: "nat_add_left_cancel" (line 265 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/ListInf/List2.thy")
*** At command "apply" (line 265 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/ListInf/List2.thy")
*** Undefined fact: "card_infinite" (line 1030 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonSet/SetInterval2.thy")
*** At command "by" (line 1030 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonSet/SetInterval2.thy")
*** Undefined fact: "Divides.nat_mod_distrib" (line 1147 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Div.thy")
*** At command "thm" (line 1146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Div.thy")
*** Undefined fact: "Nat.nat_add_right_cancel" (line 283 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")
*** At command "thm" (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")
*** Undefined fact: "Nat.nat_add_right_cancel" (line 307 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")
*** At command "thm" (line 306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")
*** Undefined fact: "Nat.le_add_diff" (line 236 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")
*** At command "thm" (line 235 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List-Infinite/CommonArith/Util_Nat.thy")

==========
List_Interleaving
*** Failed to apply initial proof method (line 1078 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   x # xs @ ws ≅ {ys @ ws, zs, P}
*** goal (1 subgoal):
***  1. x # xs ≅ {ys, zs, λv vs. P v (vs @ ws)}
*** At command "proof" (line 1078 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 968 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to apply initial proof method (line 886 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   w # xs @ [x] ≅ {ys @ [x], zs, P}
*** goal (1 subgoal):
***  1. w # xs ≅ {ys, zs, λw ws. P w (ws @ [x])}
*** At command "proof" (line 886 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to apply initial proof method (line 861 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   w # xs @ [x] ≅ {[], zs, P}
*** goal (1 subgoal):
***  1. False
*** At command "proof" (line 861 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")

==========
List_Update
*** Failed to finish proof (line 1873 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Update/BIT.thy"):
*** goal (1 subgoal):
***  1. (⋀xs. pmf (bv (length xs)) xs = (1 / 2) ^ length xs) ⟹
***     (∑x∈{l. length l = length init}.
***        (if x ! index init q then real (k - k')
***         else ∑j<k'. if x ! index init (xs' ! j) then 2 else 1) *
***        pmf (bv (length init)) x) =
***     (∑x∈{l. length l = length init}.
***        (if x ! index init q then real (k - k')
***         else ∑j<k'. if x ! index init (xs' ! j) then 2 else 1) *
***        (1 / 2) ^ length init)
*** At command "by" (line 1873 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Update/BIT.thy")

==========
Locally-Nameless-Sigma
*** Undefined fact: "card_insert" (line 2424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Locally-Nameless-Sigma/Sigma/Sigma.thy")
*** At command "from" (line 2424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Locally-Nameless-Sigma/Sigma/Sigma.thy")

==========
Lower_Semicontinuous
*** Failed to finish proof (line 461 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy"):
*** goal (1 subgoal):
***  1. ⟦⋀f. limsup f = liminf f ⟹ f ⇢ liminf f; limsup (f ∘ x) = f x0;
***      liminf (f ∘ x) = f x0⟧
***     ⟹ (f ∘ x) ⇢ f x0
*** At command "by" (line 461 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")

==========
Lp
*** Failed to apply proof method (line 1617 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lp/Lp.thy"):
*** goal (3 subgoals):
***  1. ⋀n. ¦u (n + N) x¦ ≤ (1 / 2) ^ (n + N)
***  2. summable (λn. ¦u (n + N) x¦)
***  3. summable (λn. (1 / 2) ^ (n + N))
*** At command "apply" (line 1617 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Lp/Lp.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   convex_on ?C ?f =
***   (∀x∈?C.
***       ∀y∈?C.
***          ∀μ. 0 ≤ μ ∧ μ ≤ 1 ⟶
***              ?f (μ *⇩R x + (1 - μ) *⇩R y) ≤ μ * ?f x + (1 - μ) * ?f y)
***   convex C
*** At command "unfolding" (line 340 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Markov_Models
*** Failed to refine any pending goal
*** At command "by" (line 1021 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Markov_Models/Classifying_Markov_Chain_States.thy")
*** Failed to refine any pending goal
*** At command "by" (line 971 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Markov_Models/Classifying_Markov_Chain_States.thy")

==========
Matroids
*** Undefined fact: "card_insert" (line 1173 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** At command "by" (line 1173 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** Undefined fact: "card_insert" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** At command "using" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** Undefined fact: "card_insert" (line 132 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** At command "using" (line 132 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** Undefined fact: "card_empty" (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")
*** At command "using" (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Matroids/Matroid.thy")

==========
Menger
*** Undefined fact: "card_empty" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Menger/Menger.thy")
*** At command "using" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Menger/Menger.thy")
*** Undefined fact: "card_infinite" (line 132 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Menger/MengerInduction.thy")
*** At command "by" (line 132 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Menger/MengerInduction.thy")

==========
MiniML
*** Failed to apply proof method (line 387 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/MiniML/W.thy"):
*** goal (3 subgoals):
***  1. ⋀x1a x2a A t m n S1 t1 m1 S2.
***        ⟦∀A S t m n.
***            new_tv n A ⟶ Some (S, t, m) = W x1a A n ⟶ $ S A |- x1a :: t;
***         ∀A S t m n.
***            new_tv n A ⟶ Some (S, t, m) = W x2a A n ⟶ $ S A |- x2a :: t;
***         W x2a (gen ($ S1 A) t1 # $ S1 A) m1 = Some (S2, t, m);
***         W x1a A n = Some (S1, t1, m1); new_tv n A⟧
***        ⟹ free_tv S2 ∩ (free_tv t1 - free_tv ($ S1 A)) = {}
***  2. ⋀x1a x2a A t m n S1 t1 m1 S2.
***        ⟦W x2a (gen ($ S1 A) t1 # $ S1 A) m1 = Some (S2, t, m);
***         W x1a A n = Some (S1, t1, m1); new_tv n A; new_tv m1 S1;
***         new_tv m1 ($ S1 A)⟧
***        ⟹ new_tv m1 ($ S1 A)
***  3. ⋀x1a x2a A t m n S1 t1 m1 S2.
***        ⟦W x2a (gen ($ S1 A) t1 # $ S1 A) m1 = Some (S2, t, m);
***         W x1a A n = Some (S1, t1, m1); new_tv n A; new_tv m1 S1;
***         new_tv m1 ($ S1 A);
***         Some (S2, t, m) = W x2a (gen ($ S1 A) t1 # $ S1 A) m1 ⟶
***         $ S2 (gen ($ S1 A) t1 # $ S1 A) |- x2a :: t⟧
***        ⟹ $ S2 (gen ($ S1 A) t1 # $ S1 A) |- x2a :: t
*** At command "apply" (line 387 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/MiniML/W.thy")

==========
Nested_Multisets_Ordinals
*** Failed to load theory "Nested_Multisets_Ordinals.Signed_Multiset" (unresolved "Nested_Multisets_Ordinals.Multiset_More")
*** Failed to load theory "Nested_Multisets_Ordinals.Hereditary_Multiset" (unresolved "Nested_Multisets_Ordinals.Multiset_More")
*** Failed to load theory "Nested_Multisets_Ordinals.Signed_Hereditary_Multiset" (unresolved "Nested_Multisets_Ordinals.Hereditary_Multiset", "Nested_Multisets_Ordinals.Signed_Multiset")
*** Failed to load theory "Nested_Multisets_Ordinals.Unary_PCF" (unresolved "Nested_Multisets_Ordinals.Hereditary_Multiset")
*** Failed to load theory "Nested_Multisets_Ordinals.Syntactic_Ordinal" (unresolved "Nested_Multisets_Ordinals.Hereditary_Multiset")
*** Failed to load theory "Nested_Multisets_Ordinals.Goodstein_Sequence" (unresolved "Nested_Multisets_Ordinals.Multiset_More", "Nested_Multisets_Ordinals.Syntactic_Ordinal")
*** Failed to load theory "Nested_Multisets_Ordinals.Hydra_Battle" (unresolved "Nested_Multisets_Ordinals.Syntactic_Ordinal")
*** Failed to load theory "Nested_Multisets_Ordinals.Signed_Syntactic_Ordinal" (unresolved "Nested_Multisets_Ordinals.Signed_Hereditary_Multiset", "Nested_Multisets_Ordinals.Syntactic_Ordinal")
*** Failed to load theory "Nested_Multisets_Ordinals.Syntactic_Ordinal_Bridge" (unresolved "Nested_Multisets_Ordinals.Syntactic_Ordinal")
*** Type unification failed: Clash of types "_ multiset" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (#) ⋃ ::
***   (??'a set set ⇒ ??'a set) list ⇒ (??'a set set ⇒ ??'a set) list
*** Operand:   {#image_mset (Pair a) (B a). a ∈# A#} ::
***   ('a × 'b) multiset multiset
*** 
*** At command "definition" (line 527 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy")

==========
Neumann_Morgenstern_Utility
*** Undefined fact: "real_mult_less_iff1" (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/First_Welfare_Theorem/Utility_Functions.thy")
*** At command "by" (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/First_Welfare_Theorem/Utility_Functions.thy")
*** Undefined fact: "card_empty" (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** At command "by" (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** Undefined fact: "card_infinite" (line 44 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** At command "using" (line 44 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** Undefined fact: "card_infinite" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** At command "by" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** Undefined fact: "card_infinite" (line 35 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")
*** At command "by" (line 35 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/Lotteries.thy")

==========
Nominal2
*** ML error (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 328 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML_file" (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/Nominal2.thy")

==========
Noninterference_Sequential_Composition
*** Failed to apply initial proof method (line 1078 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   x # xs @ ws ≅ {ys @ ws, zs, P}
*** goal (1 subgoal):
***  1. x # xs ≅ {ys, zs, λv vs. P v (vs @ ws)}
*** At command "proof" (line 1078 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to refine any pending goal
*** At command "qed" (line 968 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to apply initial proof method (line 886 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   w # xs @ [x] ≅ {ys @ [x], zs, P}
*** goal (1 subgoal):
***  1. w # xs ≅ {ys, zs, λw ws. P w (ws @ [x])}
*** At command "proof" (line 886 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")
*** Failed to apply initial proof method (line 861 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy"):
*** using this:
***   w # xs @ [x] ≅ {[], zs, P}
*** goal (1 subgoal):
***  1. False
*** At command "proof" (line 861 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/List_Interleaving/ListInterleaving.thy")

==========
NormByEval
*** Failed to apply proof method (line 1996 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/NormByEval/NBE.thy"):
*** goal (3 subgoals):
***  1. ⋀v v' tsa nm.
***        ⟦v ⇒ v'; C_normal⇩M⇩L v⟧
***        ⟹ C_normal⇩M⇩L v' ∧
***           (dterm⇩M⇩L v = C nm ∙∙ tsa ⟶
***            dterm⇩M⇩L v' = C nm ∙∙ map dterm (C⇩U_args (term v')) ∧
***            length (C⇩U_args (term v)) = length (C⇩U_args (term v')) ∧
***            (∀i<length (C⇩U_args (term v)).
***                C⇩U_args (term v) ! i ⇒* C⇩U_args (term v') ! i))
***  2. ⋀i t' ts.
***        ⟦i < length ts; ts ! i ⇒ t';
***         ⋀tsa nm.
***            C_normal t' ∧
***            (dterm (ts ! i) = C nm ∙∙ tsa ⟶
***             dterm t' = C nm ∙∙ map dterm (C⇩U_args t') ∧
***             length (C⇩U_args (ts ! i)) = length (C⇩U_args t') ∧
***             (∀ia<length (C⇩U_args (ts ! i)).
***                 C⇩U_args (ts ! i) ! ia ⇒* C⇩U_args t' ! ia));
***         Ball (set ts) C_normal⟧
***        ⟹ Ball (set (ts[i := t'])) C_normal
***  3. ⋀nm i t' ts tsa nma.
***        ⟦i < length ts; ts ! i ⇒ t';
***         ⋀tsa nm.
***            C_normal t' ∧
***            (dterm (ts ! i) = C nm ∙∙ tsa ⟶
***             dterm t' = C nm ∙∙ map dterm (C⇩U_args t') ∧
***             length (C⇩U_args (ts ! i)) = length (C⇩U_args t') ∧
***             (∀ia<length (C⇩U_args (ts ! i)).
***                 C⇩U_args (ts ! i) ! ia ⇒* C⇩U_args t' ! ia));
***         (∀t∈set ts. C_normal t) ∧ no_match_R nm (map dterm ts)⟧
***        ⟹ Ball (set (ts[i := t'])) C_normal ∧
***           no_match_R nm (map dterm (ts[i := t'])) ∧
***           (nm = nma ∧ map dterm ts = tsa ⟶
***            (∀ia<length ts. ts ! ia ⇒* ts[i := t'] ! ia))
*** At command "apply" (line 1996 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/NormByEval/NBE.thy")

==========
Orbit_Stabiliser
*** Undefined fact: "card_empty" (line 865 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Orbit_Stabiliser/Tetrahedron.thy")
*** At command "from" (line 865 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Orbit_Stabiliser/Tetrahedron.thy")
*** Undefined fact: "card_empty" (line 739 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Orbit_Stabiliser/Tetrahedron.thy")
*** At command "from" (line 739 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Orbit_Stabiliser/Tetrahedron.thy")

==========
Ordered_Resolution_Prover
*** Failed to load theory "Ordered_Resolution_Prover.Clausal_Logic" (unresolved "Nested_Multisets_Ordinals.Multiset_More")
*** Failed to load theory "Ordered_Resolution_Prover.Herbrand_Interpretation" (unresolved "Ordered_Resolution_Prover.Clausal_Logic")
*** Failed to load theory "Ordered_Resolution_Prover.Abstract_Substitution" (unresolved "Ordered_Resolution_Prover.Clausal_Logic")
*** Failed to load theory "Ordered_Resolution_Prover.Ground_Resolution_Model" (unresolved "Ordered_Resolution_Prover.Herbrand_Interpretation")
*** Failed to load theory "Ordered_Resolution_Prover.Inference_System" (unresolved "Ordered_Resolution_Prover.Herbrand_Interpretation")
*** Failed to load theory "Ordered_Resolution_Prover.Ordered_Ground_Resolution" (unresolved "Ordered_Resolution_Prover.Ground_Resolution_Model", "Ordered_Resolution_Prover.Inference_System")
*** Failed to load theory "Ordered_Resolution_Prover.Unordered_Ground_Resolution" (unresolved "Ordered_Resolution_Prover.Ground_Resolution_Model", "Ordered_Resolution_Prover.Inference_System")
*** Failed to load theory "Ordered_Resolution_Prover.Proving_Process" (unresolved "Ordered_Resolution_Prover.Unordered_Ground_Resolution")
*** Failed to load theory "Ordered_Resolution_Prover.Standard_Redundancy" (unresolved "Ordered_Resolution_Prover.Proving_Process")
*** Failed to load theory "Ordered_Resolution_Prover.FO_Ordered_Resolution" (unresolved "Ordered_Resolution_Prover.Abstract_Substitution", "Ordered_Resolution_Prover.Ordered_Ground_Resolution", "Ordered_Resolution_Prover.Standard_Redundancy")
*** Failed to load theory "Ordered_Resolution_Prover.FO_Ordered_Resolution_Prover" (unresolved "Ordered_Resolution_Prover.FO_Ordered_Resolution")
*** Type unification failed: Clash of types "_ multiset" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (#) ⋃ ::
***   (??'a set set ⇒ ??'a set) list ⇒ (??'a set set ⇒ ??'a set) list
*** Operand:   {#image_mset (Pair a) (B a). a ∈# A#} ::
***   ('a × 'b) multiset multiset
*** 
*** At command "definition" (line 527 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy")
*** At command "by" (line 509 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy")
*** Type unification failed: Clash of types "_ multiset" and "_ list"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (#) ⋃ ::
***   (??'a set set ⇒ ??'a set) list ⇒ (??'a set set ⇒ ??'a set) list
*** Operand:   {#image_mset (Pair a) (B a). a ∈# A#} ::
***   ('a × 'b) multiset multiset
*** 
*** At command "definition" (line 527 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy")

==========
Ordinal_Partitions
*** Undefined fact: "card_empty" (line 3226 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Omega_Omega.thy")
*** At command "apply" (line 3226 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Omega_Omega.thy")
*** Undefined fact: "card_infinite" (line 4573 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Omega_Omega.thy")
*** At command "by" (line 4573 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Omega_Omega.thy")
*** Undefined fact: "card_empty" (line 64 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Library_Additions.thy")
*** At command "by" (line 64 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Ordinal_Partitions/Library_Additions.thy")

==========
Pairing_Heap
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀x hs Union_mset.
***    mset_heap (Hp x hs) = {#x#} + Union_mset (mset (map mset_heap hs))
*** At command "fun" (line 72 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List1.thy")
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀x hs Union_mset.
***    mset_hp (Hp x hs) = {#x#} + Union_mset (mset (map mset_hp hs))
*** At command "fun" (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List2.thy")
*** At command "by" (line 91 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List2.thy")
*** Variable "Union_mset" occurs on right hand side only:
*** ⋀x hs Union_mset.
***    mset_hp (Hp x hs) = {#x#} + Union_mset (mset (map mset_hp hs))
*** At command "fun" (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List2.thy")

==========
Password_Authentication_Protocol
*** Failed to refine any pending goal
*** At command "by" (line 3987 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Password_Authentication_Protocol/Protocol.thy")
*** Failed to refine any pending goal
*** At command "by" (line 4748 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Password_Authentication_Protocol/Protocol.thy")
*** Failed to refine any pending goal
*** At command "by" (line 2325 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Password_Authentication_Protocol/Protocol.thy")
*** Failed to apply proof method (line 1027 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Password_Authentication_Protocol/Propaedeutics.thy"):
*** goal (4 subgoals):
***  1. ⋀Ka. ⟦Crypt K X ∈ parts (insert (Crypt K X) H); Ka = K⟧
***          ⟹ X ∈ parts (insert X H)
***  2. ⋀Ka Xa.
***        ⟦Crypt Ka Xa ∈ parts (insert (Crypt K X) H);
***         Crypt Ka Xa ∈ parts (insert X H)⟧
***        ⟹ Xa = Crypt K X ∨ Xa ∈ parts (insert X H)
***  3. ⋀xa y.
***        ⟦Auth_Data xa y ∈ parts (insert (Crypt K X) H);
***         Auth_Data xa y ∈ parts (insert X H)⟧
***        ⟹ Pri_AgrK xa ∈ parts (insert X H)
***  4. ⋀xa y.
***        ⟦Auth_Data xa y ∈ parts (insert (Crypt K X) H);
***         Auth_Data xa y ∈ parts (insert X H)⟧
***        ⟹ Pri_AgrK y ∈ parts (insert X H)
*** At command "apply" (line 1027 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Password_Authentication_Protocol/Propaedeutics.thy")

==========
Pi_Calculus
*** Failed to apply proof method (line 169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pi_Calculus/Early_Semantics.thy"):
*** goal:
*** No subgoals!
*** At command "apply" (line 169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Pi_Calculus/Early_Semantics.thy")

==========
POPLmark-deBruijn
*** Failed to apply proof method (line 1869 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (11 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***           Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : ?T⇩2402 T⇩1 t⇩2 T⇩2 Δ
***  2. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ T⇩1[∥Δ∥ ↦⇩τ P]⇩τ → ↓⇩τ 1 0 (?T⇩2402 T⇩1 t⇩2 T⇩2 Δ) =
***           T⇩1[∥Δ∥ ↦⇩τ P]⇩τ → T⇩2[0 ↦⇩τ Top]⇩τ[∥Δ∥ ↦⇩τ P]⇩τ
***  3. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] : T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ → T⇩1⇩2[∥Δ∥ ↦⇩τ P]⇩τ;
***         Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩1⇩1;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[∥Δ∥ ↦⇩τ P] : T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] ∙ t⇩2[∥Δ∥ ↦⇩τ P] : T⇩1⇩2[∥Δ∥ ↦⇩τ P]⇩τ
***  4. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @
***           Γ ⊢ (λ<:T⇩1[∥Δ∥ ↦⇩τ P]⇩τ.
***                   t⇩2[Suc ∥Δ∥ ↦⇩τ P]) : (∀<:T⇩1[∥Δ∥ ↦⇩τ P]⇩τ. T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ)
***  5. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ[0 ↦⇩τ P]⇩e @
***         Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] : (∀<:T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ. T⇩1⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ);
***         Δ @ TVarB Q ∷ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @
***           Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] ∙⇩τ T⇩2[∥Δ∥ ↦⇩τ P]⇩τ : T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ[∥Δ∥ ↦⇩τ P]⇩τ
***  6. ⋀t S T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : S;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P] : S[∥Δ∥ ↦⇩τ P]⇩τ;
***         Δ @ TVarB Q ∷ Γ ⊢ S <: T; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P] : T[∥Δ∥ ↦⇩τ P]⇩τ
***  7. ⋀t⇩1 T⇩1 p Δ t⇩2 T⇩2 Δ'.
***        ⟦Δ' @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1;
***         Δ'[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩1[∥Δ'∥ ↦⇩τ P] : T⇩1[∥Δ'∥ ↦⇩τ P]⇩τ; ⊢ p : T⇩1 ⇒ Δ;
***         Δ @ Δ' @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         Δ[∥Δ'∥ ↦⇩τ P]⇩e @
***         Δ'[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[∥Δ∥ + ∥Δ'∥ ↦⇩τ P] : T⇩2[∥Δ∥ + ∥Δ'∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ'[0 ↦⇩τ P]⇩e @
***           Γ ⊢ (LET p[∥Δ'∥ ↦⇩τ P]⇩p = t⇩1[∥Δ'∥ ↦⇩τ P]
***                IN t⇩2[∥Δ'∥ + ∥Δ∥ ↦⇩τ P]) : ↓⇩τ ∥Δ∥ 0 (T⇩2[∥Δ∥ + ∥Δ'∥ ↦⇩τ P]⇩τ)
***  8. ⋀fs fTs Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ fs [:] fTs;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ fs[∥Δ∥ ↦⇩τ P]⇩r [:] fTs[∥Δ∥ ↦⇩τ P]⇩r⇩τ; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ Rcd (fs[∥Δ∥ ↦⇩τ P]⇩r) : RcdT (fTs[∥Δ∥ ↦⇩τ P]⇩r⇩τ)
***  9. ⋀t fTs l T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : RcdT fTs;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P] : RcdT (fTs[∥Δ∥ ↦⇩τ P]⇩r⇩τ);
***         fTs⟨l⟩⇩? = ⌊T⌋; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P]..l : T[∥Δ∥ ↦⇩τ P]⇩τ
***  10. ⋀Δ. ⟦Δ @ TVarB Q ∷ Γ ⊢⇩w⇩f; Γ ⊢ P <: Q⟧ ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ [] [:] []
*** A total of 11 subgoals...
*** At command "apply" (line 1869 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1789 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (10 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦ u] : T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ;
***         Γ ⊢ u : U⟧
***        ⟹ Δ[0 ↦⇩τ Top]⇩e @
***           Γ ⊢ (λ:T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ.
***                   t⇩2[Suc ∥Δ∥ ↦ u]) : T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ →
***                                      T⇩2[0 ↦⇩τ Top]⇩τ[∥Δ∥ ↦⇩τ Top]⇩τ
***  2. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩1[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (T⇩1⇩1 → T⇩1⇩2);
***         Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩1⇩1;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩2[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T⇩1⇩1; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (t⇩1 ∙ t⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T⇩1⇩2
***  3. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩2;
***         ⋀Δ'. ⟦TVarB T⇩1 ∷ Δ @ VarB U ∷ Γ = Δ' @ VarB U ∷ Γ; Γ ⊢ u : U⟧
***              ⟹ ↓⇩e 1 0 Δ' @ Γ ⊢ t⇩2[∥Δ'∥ ↦ u] : ↓⇩τ 1 ∥Δ'∥ T⇩2;
***         Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (λ<:T⇩1. t⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (∀<:T⇩1. T⇩2)
***  4. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩1[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ @ VarB U ∷ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (t⇩1 ∙⇩τ T⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ)
***  5. ⋀t S T Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t : S;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ S;
***         Δ @ VarB U ∷ Γ ⊢ S <: T; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T
***  6. ⋀t⇩1 T⇩1 p Δ t⇩2 T⇩2 Δ'.
***        ⟦Δ' @ VarB U ∷ Γ ⊢ t⇩1 : T⇩1;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ' @ Γ ⊢ t⇩1[∥Δ'∥ ↦ u] : ↓⇩τ 1 ∥Δ'∥ T⇩1;
***         ⊢ p : T⇩1 ⇒ Δ; Δ @ Δ' @ VarB U ∷ Γ ⊢ t⇩2 : T⇩2;
***         ⋀Δ''. ⟦Δ @ Δ' @ VarB U ∷ Γ = Δ'' @ VarB U ∷ Γ; Γ ⊢ u : U⟧
***               ⟹ ↓⇩e 1 0 Δ'' @ Γ ⊢ t⇩2[∥Δ''∥ ↦ u] : ↓⇩τ 1 ∥Δ''∥ T⇩2;
***         Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ' @
***           Γ ⊢ (LET p = t⇩1 IN t⇩2)[∥Δ'∥ ↦ u] : ↓⇩τ 1 ∥Δ'∥ (↓⇩τ ∥Δ∥ 0 T⇩2)
***  7. ⋀fs fTs Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ fs [:] fTs;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ fs[∥Δ∥ ↦ u]⇩r [:] ↓⇩r⇩τ 1 ∥Δ∥ fTs;
***         Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ Rcd fs[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (RcdT fTs)
***  8. ⋀t fTs l T Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t : RcdT fTs;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (RcdT fTs);
***         fTs⟨l⟩⇩? = ⌊T⌋; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (t..l)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T
***  9. ⋀Δ. ⟦Δ @ VarB U ∷ Γ ⊢⇩w⇩f; Γ ⊢ u : U⟧
***         ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ [][∥Δ∥ ↦ u]⇩r [:] ↓⇩r⇩τ 1 ∥Δ∥ []
***  10. ⋀t T fs fTs l Δ.
***         ⟦Δ @ VarB U ∷ Γ ⊢ t : T;
***          Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T;
***          Δ @ VarB U ∷ Γ ⊢ fs [:] fTs;
***          Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ fs[∥Δ∥ ↦ u]⇩r [:] ↓⇩r⇩τ 1 ∥Δ∥ fTs;
***          fs⟨l⟩⇩? = ⊥; Γ ⊢ u : U⟧
***         ⟹ ↓⇩e 1 0 Δ @
***            Γ ⊢ ((l, t) ∷ fs)[∥Δ∥ ↦ u]⇩r [:] ↓⇩r⇩τ 1 ∥Δ∥ ((l, T) ∷ fTs)
*** At command "apply" (line 1789 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1686 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (10 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ Γ ⊢ t⇩2 : T⇩2;
***         VarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ VarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***           ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2
***  2. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1 → ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩2;
***         Δ @ Γ ⊢ t⇩2 : T⇩1⇩1;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 ∙ ↑ (Suc 0) ∥Δ∥ t⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩2
***  3. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ Γ ⊢ t⇩2 : T⇩2;
***         TVarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ (λ<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1.
***                   ↑ (Suc 0) (Suc ∥Δ∥)
***                    t⇩2) : (∀<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1. ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2)
***  4. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) ∥Δ∥
***              t⇩1 : (∀<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1. ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩1⇩2);
***         Δ @ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 ∙⇩τ
***               ↑⇩τ (Suc 0) ∥Δ∥ T⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ (T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ)
***  5. ⋀t S T Δ.
***        ⟦Δ @ Γ ⊢ t : S;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : ↑⇩τ (Suc 0) ∥Δ∥ S;
***         Δ @ Γ ⊢ S <: T; Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : ↑⇩τ (Suc 0) ∥Δ∥ T
***  6. ⋀t⇩1 T⇩1 p Δ t⇩2 T⇩2 Δ'.
***        ⟦Δ' @ Γ ⊢ t⇩1 : T⇩1;
***         ↑⇩e (Suc 0) 0 Δ' @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ'∥ t⇩1 : ↑⇩τ (Suc 0) ∥Δ'∥ T⇩1;
***         ⊢ p : T⇩1 ⇒ Δ; Δ @ Δ' @ Γ ⊢ t⇩2 : T⇩2;
***         ↑⇩e (Suc 0) ∥Δ'∥ Δ @
***         ↑⇩e (Suc 0) 0 Δ' @ B ∷
***         Γ ⊢ ↑ (Suc 0) (∥Δ∥ + ∥Δ'∥) t⇩2 : ↑⇩τ (Suc 0) (∥Δ∥ + ∥Δ'∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ' @ B ∷
***           Γ ⊢ (LET ↑⇩p (Suc 0) ∥Δ'∥ p = ↑ (Suc 0) ∥Δ'∥ t⇩1
***                IN ↑ (Suc 0) (∥Δ'∥ + ∥Δ∥)
***                    t⇩2) : ↓⇩τ ∥Δ∥ 0 (↑⇩τ (Suc 0) (∥Δ∥ + ∥Δ'∥) T⇩2)
***  7. ⋀fs fTs Δ.
***        ⟦Δ @ Γ ⊢ fs [:] fTs;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑⇩r (Suc 0) ∥Δ∥ fs [:] ↑⇩r⇩τ (Suc 0) ∥Δ∥ fTs;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ Rcd (↑⇩r (Suc 0) ∥Δ∥ fs) : RcdT (↑⇩r⇩τ (Suc 0) ∥Δ∥ fTs)
***  8. ⋀t fTs l T Δ.
***        ⟦Δ @ Γ ⊢ t : RcdT fTs;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : RcdT (↑⇩r⇩τ (Suc 0) ∥Δ∥ fTs);
***         fTs⟨l⟩⇩? = ⌊T⌋; Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t..l : ↑⇩τ (Suc 0) ∥Δ∥ T
***  9. ⋀Δ. ⟦Δ @ Γ ⊢⇩w⇩f; Γ ⊢⇩w⇩f⇩B B⟧ ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ [] [:] []
***  10. ⋀t T fs fTs l Δ.
***         ⟦Δ @ Γ ⊢ t : T;
***          ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : ↑⇩τ (Suc 0) ∥Δ∥ T;
***          Δ @ Γ ⊢ fs [:] fTs;
***          ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑⇩r (Suc 0) ∥Δ∥ fs [:] ↑⇩r⇩τ (Suc 0) ∥Δ∥ fTs;
***          fs⟨l⟩⇩? = ⊥; Γ ⊢⇩w⇩f⇩B B⟧
***         ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ (l, ↑ (Suc 0) ∥Δ∥ t) ∷
***            ↑⇩r (Suc 0) ∥Δ∥ fs [:] (l, ↑⇩τ (Suc 0) ∥Δ∥ T) ∷ ↑⇩r⇩τ (Suc 0) ∥Δ∥ fTs
*** At command "apply" (line 1686 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1285 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (2 subgoals):
***  1. ⋀T⇩1 S⇩1 S⇩2 T⇩2 Δ.
***        ⟦Δ @ VarB V ∷ Γ ⊢ T⇩1 <: S⇩1;
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ <: S⇩1[∥Δ∥ ↦⇩τ Top]⇩τ;
***         TVarB T⇩1 ∷ Δ @ VarB V ∷ Γ ⊢ S⇩2 <: T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ⟧
***        ⟹ TVarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***           Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ
***  2. ⋀fs fs' Δ.
***        ⟦Δ @ VarB V ∷ Γ ⊢⇩w⇩f; Δ @ VarB V ∷ Γ ⊢⇩w⇩f RcdT fs; unique fs';
***         ∀x∈set fs'.
***            case x of
***            (l, T) ⇒
***              ∃S. (l, S) ∈ set fs ∧
***                  Δ @ VarB V ∷ Γ ⊢ S <: T ∧
***                  Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ S[∥Δ∥ ↦⇩τ Top]⇩τ <: T[∥Δ∥ ↦⇩τ Top]⇩τ⟧
***        ⟹ Δ[0 ↦⇩τ Top]⇩e @
***           Γ ⊢ RcdT (fs[∥Δ∥ ↦⇩τ Top]⇩r⇩τ) <: RcdT (fs'[∥Δ∥ ↦⇩τ Top]⇩r⇩τ)
*** At command "apply" (line 1285 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1205 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (2 subgoals):
***  1. ⋀T⇩1 S⇩1 S⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ T⇩1 <: S⇩1;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ T⇩1[∥Δ∥ ↦⇩τ P]⇩τ <: S⇩1[∥Δ∥ ↦⇩τ P]⇩τ;
***         TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ S⇩2 <: T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***           Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ
***  2. ⋀fs fs' Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢⇩w⇩f; Δ @ TVarB Q ∷ Γ ⊢⇩w⇩f RcdT fs; unique fs';
***         ∀x∈set fs'.
***            case x of
***            (l, T) ⇒
***              ∃S. (l, S) ∈ set fs ∧
***                  Δ @ TVarB Q ∷ Γ ⊢ S <: T ∧
***                  Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ S[∥Δ∥ ↦⇩τ P]⇩τ <: T[∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ RcdT (fs[∥Δ∥ ↦⇩τ P]⇩r⇩τ) <: RcdT (fs'[∥Δ∥ ↦⇩τ P]⇩r⇩τ)
*** At command "apply" (line 1205 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1440 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (10 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2; Γ ⊢ P <: Q⟧
***        ⟹ VarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2
***  2. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2; Δ @ TVarB P ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩1⇩1; Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩1⇩1; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t⇩1 ∙ t⇩2 : T⇩1⇩2
***  3. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         TVarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ (λ<:T⇩1. t⇩2) : (∀<:T⇩1. T⇩2)
***  4. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ @ TVarB P ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2); Δ @ TVarB Q ∷ Γ ⊢ T⇩2 <: T⇩1⇩1;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t⇩1 ∙⇩τ T⇩2 : T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ
***  5. ⋀t S T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : S; Δ @ TVarB P ∷ Γ ⊢ t : S;
***         Δ @ TVarB Q ∷ Γ ⊢ S <: T; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t : T
***  6. ⋀t⇩1 T⇩1 p Δ t⇩2 T⇩2 Δ'.
***        ⟦Δ' @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1; Δ' @ TVarB P ∷ Γ ⊢ t⇩1 : T⇩1;
***         ⊢ p : T⇩1 ⇒ Δ; Δ @ Δ' @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         Δ @ Δ' @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2; Γ ⊢ P <: Q⟧
***        ⟹ Δ' @ TVarB P ∷ Γ ⊢ (LET p = t⇩1 IN t⇩2) : ↓⇩τ ∥Δ∥ 0 T⇩2
***  7. ⋀fs fTs Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ fs [:] fTs; Δ @ TVarB P ∷ Γ ⊢ fs [:] fTs;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ Rcd fs : RcdT fTs
***  8. ⋀t fTs l T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : RcdT fTs; Δ @ TVarB P ∷ Γ ⊢ t : RcdT fTs;
***         fTs⟨l⟩⇩? = ⌊T⌋; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t..l : T
***  9. ⋀Δ. ⟦Δ @ TVarB Q ∷ Γ ⊢⇩w⇩f; Γ ⊢ P <: Q⟧ ⟹ Δ @ TVarB P ∷ Γ ⊢ [] [:] []
***  10. ⋀t T fs fTs l Δ.
***         ⟦Δ @ TVarB Q ∷ Γ ⊢ t : T; Δ @ TVarB P ∷ Γ ⊢ t : T;
***          Δ @ TVarB Q ∷ Γ ⊢ fs [:] fTs; Δ @ TVarB P ∷ Γ ⊢ fs [:] fTs;
***          fs⟨l⟩⇩? = ⊥; Γ ⊢ P <: Q⟧
***         ⟹ Δ @ TVarB P ∷ Γ ⊢ (l, t) ∷ fs [:] (l, T) ∷ fTs
*** At command "apply" (line 1440 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 689 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy"):
*** goal (2 subgoals):
***  1. ⋀T U Δ.
***        ⟦Δ @ Γ ⊢⇩w⇩f T; ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) ∥Δ∥ T;
***         TVarB T ∷ Δ @ Γ ⊢⇩w⇩f U;
***         TVarB (↑⇩τ (Suc 0) ∥Δ∥ T) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) (Suc ∥Δ∥) U⟧
***        ⟹ TVarB (↑⇩τ (Suc 0) ∥Δ∥ T) ∷
***           ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) (Suc ∥Δ∥) U
***  2. ⋀fs Δ.
***        ⟦unique fs;
***         ∀x∈set fs.
***            case x of
***            (l, T) ⇒
***              Δ @ Γ ⊢⇩w⇩f T ∧ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) ∥Δ∥ T⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f RcdT (↑⇩r⇩τ (Suc 0) ∥Δ∥ fs)
*** At command "apply" (line 689 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmarkRecord.thy")
*** Failed to apply proof method (line 1228 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (5 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦ u] : T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ;
***         Γ ⊢ u : U⟧
***        ⟹ Δ[0 ↦⇩τ Top]⇩e @
***           Γ ⊢ (λ:T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ.
***                   t⇩2[Suc ∥Δ∥ ↦ u]) : T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ →
***                                      T⇩2[0 ↦⇩τ Top]⇩τ[∥Δ∥ ↦⇩τ Top]⇩τ
***  2. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩1[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (T⇩1⇩1 → T⇩1⇩2);
***         Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩1⇩1;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩2[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T⇩1⇩1; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (t⇩1 ∙ t⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T⇩1⇩2
***  3. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ VarB U ∷ Γ ⊢ t⇩2 : T⇩2;
***         ⋀Δ'. ⟦TVarB T⇩1 ∷ Δ @ VarB U ∷ Γ = Δ' @ VarB U ∷ Γ; Γ ⊢ u : U⟧
***              ⟹ ↓⇩e 1 0 Δ' @ Γ ⊢ t⇩2[∥Δ'∥ ↦ u] : ↓⇩τ 1 ∥Δ'∥ T⇩2;
***         Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (λ<:T⇩1. t⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (∀<:T⇩1. T⇩2)
***  4. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t⇩1[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ @ VarB U ∷ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ (t⇩1 ∙⇩τ T⇩2)[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ (T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ)
***  5. ⋀t S T Δ.
***        ⟦Δ @ VarB U ∷ Γ ⊢ t : S;
***         Γ ⊢ u : U ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ S;
***         Δ @ VarB U ∷ Γ ⊢ S <: T; Γ ⊢ u : U⟧
***        ⟹ ↓⇩e 1 0 Δ @ Γ ⊢ t[∥Δ∥ ↦ u] : ↓⇩τ 1 ∥Δ∥ T
*** At command "apply" (line 1228 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 1285 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (6 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***           Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : ?T⇩2402 T⇩1 t⇩2 T⇩2 Δ
***  2. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ T⇩1[∥Δ∥ ↦⇩τ P]⇩τ → ↓⇩τ 1 0 (?T⇩2402 T⇩1 t⇩2 T⇩2 Δ) =
***           T⇩1[∥Δ∥ ↦⇩τ P]⇩τ → T⇩2[0 ↦⇩τ Top]⇩τ[∥Δ∥ ↦⇩τ P]⇩τ
***  3. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] : T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ → T⇩1⇩2[∥Δ∥ ↦⇩τ P]⇩τ;
***         Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩1⇩1;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[∥Δ∥ ↦⇩τ P] : T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] ∙ t⇩2[∥Δ∥ ↦⇩τ P] : T⇩1⇩2[∥Δ∥ ↦⇩τ P]⇩τ
***  4. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t⇩2[Suc ∥Δ∥ ↦⇩τ P] : T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @
***           Γ ⊢ (λ<:T⇩1[∥Δ∥ ↦⇩τ P]⇩τ.
***                   t⇩2[Suc ∥Δ∥ ↦⇩τ P]) : (∀<:T⇩1[∥Δ∥ ↦⇩τ P]⇩τ. T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ)
***  5. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ[0 ↦⇩τ P]⇩e @
***         Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] : (∀<:T⇩1⇩1[∥Δ∥ ↦⇩τ P]⇩τ. T⇩1⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ);
***         Δ @ TVarB Q ∷ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @
***           Γ ⊢ t⇩1[∥Δ∥ ↦⇩τ P] ∙⇩τ T⇩2[∥Δ∥ ↦⇩τ P]⇩τ : T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ[∥Δ∥ ↦⇩τ P]⇩τ
***  6. ⋀t S T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : S;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P] : S[∥Δ∥ ↦⇩τ P]⇩τ;
***         Δ @ TVarB Q ∷ Γ ⊢ S <: T; Γ ⊢ P <: Q⟧
***        ⟹ Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ t[∥Δ∥ ↦⇩τ P] : T[∥Δ∥ ↦⇩τ P]⇩τ
*** At command "apply" (line 1285 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 1146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (6 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ Γ ⊢ t⇩2 : T⇩2;
***         VarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ VarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***           ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ?T⇩2103 T⇩1 t⇩2 T⇩2 Δ
***  2. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ Γ ⊢ t⇩2 : T⇩2;
***         VarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩τ (Suc 0) ∥Δ∥ T⇩1 → ↓⇩τ 1 0 (?T⇩2103 T⇩1 t⇩2 T⇩2 Δ) =
***           ↑⇩τ (Suc 0) ∥Δ∥ T⇩1 → ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2[0 ↦⇩τ Top]⇩τ
***  3. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1 → ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩2;
***         Δ @ Γ ⊢ t⇩2 : T⇩1⇩1;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 ∙ ↑ (Suc 0) ∥Δ∥ t⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩2
***  4. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ Γ ⊢ t⇩2 : T⇩2;
***         TVarB (↑⇩τ (Suc 0) ∥Δ∥ T⇩1) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) (Suc ∥Δ∥) t⇩2 : ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2;
***         Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ (λ<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1.
***                   ↑ (Suc 0) (Suc ∥Δ∥)
***                    t⇩2) : (∀<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1. ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩2)
***  5. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         ↑⇩e (Suc 0) 0 Δ @ B ∷
***         Γ ⊢ ↑ (Suc 0) ∥Δ∥
***              t⇩1 : (∀<:↑⇩τ (Suc 0) ∥Δ∥ T⇩1⇩1. ↑⇩τ (Suc 0) (Suc ∥Δ∥) T⇩1⇩2);
***         Δ @ Γ ⊢ T⇩2 <: T⇩1⇩1; Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷
***           Γ ⊢ ↑ (Suc 0) ∥Δ∥ t⇩1 ∙⇩τ
***               ↑⇩τ (Suc 0) ∥Δ∥ T⇩2 : ↑⇩τ (Suc 0) ∥Δ∥ (T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ)
***  6. ⋀t S T Δ.
***        ⟦Δ @ Γ ⊢ t : S;
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : ↑⇩τ (Suc 0) ∥Δ∥ S;
***         Δ @ Γ ⊢ S <: T; Γ ⊢⇩w⇩f⇩B B⟧
***        ⟹ ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢ ↑ (Suc 0) ∥Δ∥ t : ↑⇩τ (Suc 0) ∥Δ∥ T
*** At command "apply" (line 1146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 879 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (1 subgoal):
***  1. ⋀T⇩1 S⇩1 S⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ T⇩1 <: S⇩1;
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ T⇩1[∥Δ∥ ↦⇩τ P]⇩τ <: S⇩1[∥Δ∥ ↦⇩τ P]⇩τ;
***         TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ S⇩2 <: T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***         Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ;
***         Γ ⊢ P <: Q⟧
***        ⟹ TVarB (T⇩1[∥Δ∥ ↦⇩τ P]⇩τ) ∷
***           Δ[0 ↦⇩τ P]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ P]⇩τ
*** At command "apply" (line 879 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 939 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (1 subgoal):
***  1. ⋀T⇩1 S⇩1 S⇩2 T⇩2 Δ.
***        ⟦Δ @ VarB V ∷ Γ ⊢ T⇩1 <: S⇩1;
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ <: S⇩1[∥Δ∥ ↦⇩τ Top]⇩τ;
***         TVarB T⇩1 ∷ Δ @ VarB V ∷ Γ ⊢ S⇩2 <: T⇩2;
***         TVarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***         Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ⟧
***        ⟹ TVarB (T⇩1[∥Δ∥ ↦⇩τ Top]⇩τ) ∷
***           Δ[0 ↦⇩τ Top]⇩e @ Γ ⊢ S⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ <: T⇩2[Suc ∥Δ∥ ↦⇩τ Top]⇩τ
*** At command "apply" (line 939 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 1036 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (5 subgoals):
***  1. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦VarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         VarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2; Γ ⊢ P <: Q⟧
***        ⟹ VarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2
***  2. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 t⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2; Δ @ TVarB P ∷ Γ ⊢ t⇩1 : T⇩1⇩1 → T⇩1⇩2;
***         Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩1⇩1; Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩1⇩1; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t⇩1 ∙ t⇩2 : T⇩1⇩2
***  3. ⋀T⇩1 t⇩2 T⇩2 Δ.
***        ⟦TVarB T⇩1 ∷ Δ @ TVarB Q ∷ Γ ⊢ t⇩2 : T⇩2;
***         TVarB T⇩1 ∷ Δ @ TVarB P ∷ Γ ⊢ t⇩2 : T⇩2; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ (λ<:T⇩1. t⇩2) : (∀<:T⇩1. T⇩2)
***  4. ⋀t⇩1 T⇩1⇩1 T⇩1⇩2 T⇩2 Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2);
***         Δ @ TVarB P ∷ Γ ⊢ t⇩1 : (∀<:T⇩1⇩1. T⇩1⇩2); Δ @ TVarB Q ∷ Γ ⊢ T⇩2 <: T⇩1⇩1;
***         Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t⇩1 ∙⇩τ T⇩2 : T⇩1⇩2[0 ↦⇩τ T⇩2]⇩τ
***  5. ⋀t S T Δ.
***        ⟦Δ @ TVarB Q ∷ Γ ⊢ t : S; Δ @ TVarB P ∷ Γ ⊢ t : S;
***         Δ @ TVarB Q ∷ Γ ⊢ S <: T; Γ ⊢ P <: Q⟧
***        ⟹ Δ @ TVarB P ∷ Γ ⊢ t : T
*** At command "apply" (line 1036 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")
*** Failed to apply proof method (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy"):
*** goal (1 subgoal):
***  1. ⋀T U Δ.
***        ⟦Δ @ Γ ⊢⇩w⇩f T; ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) ∥Δ∥ T;
***         TVarB T ∷ Δ @ Γ ⊢⇩w⇩f U;
***         TVarB (↑⇩τ (Suc 0) ∥Δ∥ T) ∷
***         ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) (Suc ∥Δ∥) U⟧
***        ⟹ TVarB (↑⇩τ (Suc 0) ∥Δ∥ T) ∷
***           ↑⇩e (Suc 0) 0 Δ @ B ∷ Γ ⊢⇩w⇩f ↑⇩τ (Suc 0) (Suc ∥Δ∥) U
*** At command "apply" (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/POPLmark-deBruijn/POPLmark.thy")

==========
Priority_Queue_Braun
*** Undefined fact: "height_balanced" (line 551 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** At command "apply" (line 551 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** Undefined fact: "height_balanced" (line 405 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** At command "by" (line 405 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** Undefined fact: "balanced_if_braun" (line 234 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** At command "using" (line 234 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** Undefined fact: "balanced_optimal" (line 229 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** At command "by" (line 229 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** Undefined fact: "balanced_if_braun" (line 101 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")
*** At command "using" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Priority_Queue_Braun/Sorting_Braun.thy")

==========
Probabilistic_Noninterference
*** Failed to apply terminal proof method (line 74 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_Noninterference/Language_Semantics.thy"):
*** goal:
*** No subgoals!
*** At command "by" (line 74 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_Noninterference/Language_Semantics.thy")

==========
Probabilistic_System_Zoo
*** Undefined fact: "card_insert" (line 153 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 152 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 111 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 111 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 115 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 114 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 119 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 108 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 108 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 105 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** At command "by" (line 105 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy")
*** Undefined fact: "card_insert" (line 27 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Bool_Bounded_Set.thy")
*** At command "by" (line 27 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Probabilistic_System_Zoo/Bool_Bounded_Set.thy")

==========
Projective_Geometry
*** Undefined fact: "card_empty" (line 141 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Projective_Geometry/Desargues_2D.thy")
*** At command "by" (line 141 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Projective_Geometry/Desargues_2D.thy")
*** Undefined fact: "card_empty" (line 98 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Projective_Geometry/Desargues_2D.thy")
*** At command "by" (line 98 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Projective_Geometry/Desargues_2D.thy")

==========
Propositional_Proof_Systems
*** Undefined fact: "card_empty" (line 97 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Propositional_Proof_Systems/Sema_Craig.thy")
*** At command "by" (line 97 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Propositional_Proof_Systems/Sema_Craig.thy")

==========
Rank_Nullity_Theorem
*** Failed to finish proof (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy"):
*** goal (1 subgoal):
***  1. ⟦mod_type_class.to_nat (0::'a) = 0; mod_type_class.to_nat x = 0⟧
***     ⟹ x = (0::'a)
*** At command "by" (line 448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Rank_Nullity_Theorem/Mod_Type.thy")

==========
Relational_Disjoint_Set_Forests
*** Failed to refine any pending goal
*** At command "qed" (line 1728 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy")
*** Failed to apply proof method (line 1482 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy"):
*** goal (2 subgoals):
***  1. ⋀p w y.
***        path_compression_invariant p x y p0 w ∧ y ≠ p[[w]] ⟹
***        path_compression_invariant (p[w⟼y]) x y p0 (p[[w]]) ∧
***        card {z. regular z ∧ z ≤ (p[w⟼y])⇧T⇧⋆ * (p[[w]])}
***        < card {z. regular z ∧ z ≤ p⇧T⇧⋆ * w}
***  2. ⋀p w. path_compression_invariant p x (p[[w]]) p0 w ⟹
***           path_compression_postcondition p x (p[[w]]) p0
*** At command "apply" (line 1482 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy")
*** Failed to apply proof method (line 1441 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy"):
*** goal (2 subgoals):
***  1. ⋀p w y.
***        path_compression_invariant p x y p0 w ∧ y ≠ p[[w]] ⟹
***        path_compression_invariant (p[w⟼y]) x y p0 (p[[w]]) ∧
***        card {z. regular z ∧ z ≤ (p[w⟼y])⇧T⇧⋆ * (p[[w]])}
***        < card {z. regular z ∧ z ≤ p⇧T⇧⋆ * w}
***  2. ⋀p w. path_compression_invariant p x (p[[w]]) p0 w ⟹
***           path_compression_postcondition p x (p[[w]]) p0
*** At command "apply" (line 1441 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy")
*** Failed to apply proof method (line 1393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy"):
*** goal (3 subgoals):
***  1. path_compression_precondition p0 x y ⟹
***     path_compression_invariant p0 x y p0 x
***  2. ⋀p w. path_compression_invariant p x y p0 w ∧ y ≠ p[[w]] ⟹
***           path_compression_invariant (p[w⟼y]) x y p0 (p[[w]]) ∧
***           card {z. regular z ∧ z ≤ (p[w⟼y])⇧T⇧⋆ * (p[[w]])}
***           < card {z. regular z ∧ z ≤ p⇧T⇧⋆ * w}
***  3. ⋀p w. path_compression_invariant p x y p0 w ∧ y = p[[w]] ⟹
***           path_compression_postcondition p x (p[[w]]) p0
*** At command "apply" (line 1393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy")
*** Failed to apply proof method (line 953 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy"):
*** goal (2 subgoals):
***  1. ⋀y. find_set_invariant p x y ∧ y ≠ p[[y]] ⟹
***         find_set_invariant p x (p[[y]]) ∧
***         card {z. regular z ∧ z ≤ p⇧T⇧⋆ * (p[[y]])}
***         < card {z. regular z ∧ z ≤ p⇧T⇧⋆ * y}
***  2. ⋀y. find_set_invariant p x y ∧ y = p[[y]] ⟹
***         find_set_postcondition p x y
*** At command "apply" (line 953 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Disjoint_Set_Forests/Disjoint_Set_Forests.thy")

==========
Relational_Method
*** Failed to finish proof (line 307 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Method/Anonymity.thy"):
*** goal (2 subgoals):
***  1. ⋀y K X.
***        ⟦n ∉ bad_agent;
***         (insert (Spy, VerKey)
***           (range (λx. (Asset x, Key (PriK (Auth_PriK x)))) ∪
***            {Spy} ×
***            (range Num ∪ range (λx. Key (PubK (Auth_PriK x))) ∪
***             range
***              (λx. Crypt SigK
***                    ⦃Hash (Agent x), Hash (Key (PubK (Auth_PriK x)))⦄) ∪
***             Agent ` bad_agent ∪
***             Pwd ` bad_pwd ∪
***             (λx. Key (PriK x)) ` bad_prik ∪
***             (λx. Key (ShaK x)) ` bad_shak ∪
***             (λn. ⟨n, Pwd n⟩) ` bad_id_password ∪
***             (λx. ⟨x, Key (PriK (Auth_PriK x))⟩) ` bad_id_prikey ∪
***             (λx. ⟨x, Key (PubK (Auth_PriK x))⟩) ` bad_id_pubkey ∪
***             (λx. ⟨x, Key (ShaK (Auth_ShaK x))⟩) ` bad_id_shakey)),
***          y)
***         ∈ ({(s, s').
***             ∃n S. s' =
***                   insert
***                    (Spy, Log (Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))))
***                    (insert
***                      (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))
***                      (insert
***                        (Spy, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))
***                        (insert (Asset n, Key (PriK S)) s))) ∧
***                   Key (PriK S) ∉ used s} ∪
***            {(s, s').
***             ∃n S A K.
***                s' =
***                insert (Spy, Log (Crypt K (Key (PriK S))))
***                 (insert (Spy, Log ⦃Num (Suc 0), Key (PubK A)⦄)
***                   (insert (Owner n, ⦃Num (Suc 0), Key (PubK A)⦄)
***                     (insert (Spy, ⦃Num (Suc 0), Key (PubK A)⦄)
***                       (insert (Owner n, Key (PriK A)) s)))) ∧
***                Crypt K (Key (PriK S)) ∈ used s ∧ Key (PriK A) ∉ used s} ∪
***            {(s, s').
***             ∃n A B.
***                s' =
***                insert (Spy, Log ⦃Num (Suc 0), Key (PubK A)⦄)
***                 (insert (Spy, Log ⦃Num 2, Key (PubK B)⦄)
***                   (insert (Asset n, ⦃Num 2, Key (PubK B)⦄)
***                     (insert (Spy, ⦃Num 2, Key (PubK B)⦄)
***                       (insert (Asset n, Key (PriK B)) s)))) ∧
***                ⦃Num (Suc 0), Key (PubK A)⦄ ∈ used s ∧
***                Key (PriK B) ∉ used s} ∪
***            {(s, s').
***             ∃n B C.
***                s' =
***                insert (Spy, Log ⦃Num 2, Key (PubK B)⦄)
***                 (insert (Spy, Log ⦃Num 3, Key (PubK C)⦄)
***                   (insert (Owner n, ⦃Num 3, Key (PubK C)⦄)
***                     (insert (Spy, ⦃Num 3, Key (PubK C)⦄)
***                       (insert (Owner n, Key (PriK C)) s)))) ∧
***                ⦃Num 2, Key (PubK B)⦄ ∈ used s ∧ Key (PriK C) ∉ used s} ∪
***            {(s, s').
***             ∃n C D.
***                s' =
***                insert (Spy, Log ⦃Num 3, Key (PubK C)⦄)
***                 (insert (Spy, Log ⦃Num 4, Key (PubK D)⦄)
***                   (insert (Asset n, ⦃Num 4, Key (PubK D)⦄)
***                     (insert (Spy, ⦃Num 4, Key (PubK D)⦄)
***                       (insert (Asset n, Key (PriK D)) s)))) ∧
***                ⦃Num 3, Key (PubK C)⦄ ∈ used s ∧ Key (PriK D) ∉ used s} ∪
***            {(s, s').
***             ∃n S A B C D K.
***                s' =
***                insert (Spy, Log ⦃Num 4, Key (PubK D)⦄)
***                 (insert
***                   (Spy,
***                    Log (Crypt
***                          (SesK
***                            (if K = ShaK (Auth_ShaK n) then Some S else None,
***                             {A, B}, {C, D}))
***                          (Key (PubK D))))
***                   (insert
***                     (Owner n,
***                      Crypt
***                       (SesK
***                         (if K = ShaK (Auth_ShaK n) then Some S else None,
***                          {A, B}, {C, D}))
***                       (Key (PubK D)))
***                     (insert
***                       (Spy,
***                        Crypt
***                         (SesK
***                           (if K = ShaK (Auth_ShaK n) then Some S else None,
***                            {A, B}, {C, D}))
***                         (Key (PubK D)))
***                       (insert
***                         (Owner n,
***                          Key (SesK
***                                (if K = ShaK (Auth_ShaK n) then Some S
***                                 else None,
***                                 {A, B}, {C, D})))
***                         s)))) ∧
***                Crypt K (Key (PriK S)) ∈ used s ∧
***                ⦃Num 2, Key (PubK B)⦄ ∈ used s ∧
***                ⦃Num 4, Key (PubK D)⦄ ∈ used s ∧
***                (Owner n, ⦃Num (Suc 0), Key (PubK A)⦄) ∈ s ∧
***                (Owner n, ⦃Num 3, Key (PubK C)⦄) ∈ s} ∪
***            {(s, s').
***             ∃n S A B C D.
***                s' =
***                insert
***                 (Spy,
***                  Log (Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))))
***                 (insert
***                   (Spy,
***                    Log ⦃Crypt (SesK (Some S, {A, B}, {C, D}))
***                          (Key (PubK C)),
***                          Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Auth_PriK n ⊗ B),
***                          Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Crypt SigK
***                             ⦃Hash (Agent n),
***                               Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                   (insert
***                     (Asset n,
***                      ⦃Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK C)),
***                        Crypt (SesK (Some S, {A, B}, {C, D}))
***                         (Auth_PriK n ⊗ B),
***                        Crypt (SesK (Some S, {A, B}, {C, D}))
***                         (Crypt SigK
***                           ⦃Hash (Agent n),
***                             Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                     (insert
***                       (Spy,
***                        ⦃Crypt (SesK (Some S, {A, B}, {C, D}))
***                          (Key (PubK C)),
***                          Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Auth_PriK n ⊗ B),
***                          Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Crypt SigK
***                             ⦃Hash (Agent n),
***                               Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                       (insert (Asset n, Key (SesK (Some S, {A, B}, {C, D})))
***                         (insert (Asset n, Key (PubK B)) s))))) ∧
***                (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))) ∈ s ∧
***                (Asset n, ⦃Num 2, Key (PubK B)⦄) ∈ s ∧
***                (Asset n, ⦃Num 4, Key (PubK D)⦄) ∈ s ∧
***                ⦃Num (Suc 0), Key (PubK A)⦄ ∈ used s ∧
***                ⦃Num 3, Key (PubK C)⦄ ∈ used s ∧
***                Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))
***                ∈ used s ∧
***                (Asset n, Key (PubK B)) ∉ s} ∪
***            {(s, s').
***             ∃n A B C a aa b.
***                s' =
***                insert
***                 (Spy,
***                  Log ⦃Crypt (SesK (a, aa, b)) (Key (PubK C)),
***                        Crypt (SesK (a, aa, b)) (A ⊗ B),
***                        Crypt (SesK (a, aa, b))
***                         (Crypt SigK ⦃Hash (Agent n), Hash (Key (PubK A))⦄)⦄)
***                 (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))
***                   (insert (Owner n, Crypt (SesK (a, aa, b)) (Pwd n))
***                     (insert (Spy, Crypt (SesK (a, aa, b)) (Pwd n)) s))) ∧
***                ⦃Crypt (SesK (a, aa, b)) (Key (PubK C)),
***                  Crypt (SesK (a, aa, b)) (A ⊗ B),
***                  Crypt (SesK (a, aa, b))
***                   (Crypt SigK ⦃Hash (Agent n), Hash (Key (PubK A))⦄)⦄
***                ∈ used s ∧
***                (Owner n, Key (SesK (a, aa, b))) ∈ s ∧ B ∈ aa} ∪
***            {(s, s').
***             ∃n a aa b.
***                s' =
***                insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))
***                 (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Num 0)))
***                   (insert (Asset n, Crypt (SesK (a, aa, b)) (Num 0))
***                     (insert (Spy, Crypt (SesK (a, aa, b)) (Num 0)) s))) ∧
***                (Asset n, Key (SesK (a, aa, b))) ∈ s ∧
***                Crypt (SesK (a, aa, b)) (Pwd n) ∈ used s} ∪
***            {(s, s').
***             ∃A. s' = insert (Spy, Key (PriK A)) s ∧ Key (PriK A) ∉ used s} ∪
***            {(s, s').
***             ∃A. s' = insert (Spy, Key (PubK A)) s ∧
***                 (Spy, Key (PriK A)) ∈ s} ∪
***            {(s, s').
***             ∃A B C D S.
***                s' = insert (Spy, Key (SesK (Some S, {A, B}, {C, D}))) s ∧
***                (Spy, Key (PriK S)) ∈ s ∧
***                (Spy, Key (PriK A)) ∈ s ∧
***                (Spy, Key (PubK B)) ∈ s ∧
***                (Spy, Key (PriK C)) ∈ s ∧ (Spy, Key (PubK D)) ∈ s} ∪
***            {(s, s').
***             ∃A B. s' =
***                   insert (Spy, Key (PriK A))
***                    (insert (Spy, Key (PriK B)) s) ∧
***                   (Spy, A ⊗ B) ∈ s ∧
***                   ((Spy, Key (PriK A)) ∈ s ∨ (Spy, Key (PriK B)) ∈ s)} ∪
***            {(s, s').
***             ∃A B. s' = insert (Spy, A ⊗ B) s ∧
***                   (Spy, Key (PriK A)) ∈ s ∧ (Spy, Key (PriK B)) ∈ s} ∪
***            {(s, s'). ∃X. s' = insert (Spy, Hash X) s ∧ (Spy, X) ∈ s} ∪
***            {(s, s').
***             ∃K X. s' = insert (Spy, X) s ∧
***                   (Spy, Crypt K X) ∈ s ∧ (Spy, Key (InvK K)) ∈ s} ∪
***            {(s, s').
***             ∃K X. s' = insert (Spy, Crypt K X) s ∧
***                   (Spy, X) ∈ s ∧ (Spy, Key K) ∈ s} ∪
***            {(s, s').
***             ∃X Y. s' = insert (Spy, X) (insert (Spy, Y) s) ∧
***                   (Spy, ⦃X, Y⦄) ∈ s} ∪
***            {(s, s').
***             ∃X Y. s' = insert (Spy, ⦃X, Y⦄) s ∧
***                   (Spy, X) ∈ s ∧ (Spy, Y) ∈ s} ∪
***            {(s, s').
***             ∃n. s' = insert (Spy, ⟨n, Agent n⟩) s ∧ (Spy, Agent n) ∈ s} ∪
***            {(s, s').
***             ∃n K. s' = insert (Spy, ⟨n, Key (InvK K)⟩) s ∧
***                   (Spy, Key (InvK K)) ∈ s ∧ (Spy, ⟨n, Key K⟩) ∈ s} ∪
***            {(s, s').
***             ∃n A a aa b.
***                s' =
***                insert (Spy, ⟨n, Key (PubK A)⟩)
***                 (insert (Spy, ⟨n, Key (SesK (a, aa, b))⟩) s) ∧
***                (Spy, Key (PubK A)) ∈ s ∧
***                (Spy, Key (SesK (a, aa, b))) ∈ s ∧
***                ((Spy, ⟨n, Key (PubK A)⟩) ∈ s ∨
***                 (Spy, ⟨n, Key (SesK (a, aa, b))⟩) ∈ s) ∧
***                A ∈ seskey_set (a, aa, b) ∧
***                (∃X U. Key (SesK (a, aa, b)) ∈ U ∧
***                       U ∈ key_sets X (crypts (Log -` spied s)))} ∪
***            {(s, s').
***             ∃n A B.
***                s' =
***                insert (Spy, ⟨n, Key (PriK A)⟩)
***                 (insert (Spy, ⟨n, Key (PriK B)⟩) s) ∧
***                (Spy, Key (PriK A)) ∈ s ∧
***                (Spy, Key (PriK B)) ∈ s ∧ (Spy, ⟨n, A ⊗ B⟩) ∈ s} ∪
***            {(s, s').
***             ∃n A B.
***                s' = insert (Spy, ⟨n, A ⊗ B⟩) s ∧
***                (Spy, Key (PriK A)) ∈ s ∧
***                (Spy, Key (PriK B)) ∈ s ∧
***                (Spy, A ⊗ B) ∈ s ∧
***                (∃U⊆spied s.
***                    ((Spy, ⟨n, Key (PriK A)⟩) ∈ s ∨
***                     (Spy, ⟨n, Key (PriK B)⟩) ∈ s) ∧
***                    U ∈ key_sets (A ⊗ B) (crypts (Log -` spied s)))} ∪
***            {(s, s').
***             ∃n X. s' = insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Hash X⟩) s) ∧
***                   (Spy, X) ∈ s ∧
***                   (Spy, Hash X) ∈ s ∧
***                   (∃U⊆spied s.
***                       ((Spy, ⟨n, X⟩) ∈ s ∨ (Spy, ⟨n, Hash X⟩) ∈ s) ∧
***                       U ∈ key_sets (Hash X) (crypts (Log -` spied s)))} ∪
***            {(s, s').
***             ∃n X U.
***                s' = insert (Spy, ⟨n, X⟩) (s ∪ {Spy} × IDInfo n ` U) ∧
***                (Spy, X) ∈ s ∧
***                U ⊆ spied s ∧
***                ((Spy, ⟨n, X⟩) ∈ s ∨ (∃K∈U. (Spy, ⟨n, K⟩) ∈ s)) ∧
***                U ∈ key_sets X (crypts (Log -` spied s))} ∪
***            {(s, s').
***             ∃n X Y.
***                s' = insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Y⟩) s) ∧
***                (Spy, X) ∈ s ∧ (Spy, Y) ∈ s ∧ (Spy, ⟨n, ⦃X, Y⦄⟩) ∈ s} ∪
***            {(s, s').
***             ∃n X Y.
***                s' = insert (Spy, ⟨n, ⦃X, Y⦄⟩) s ∧
***                (Spy, X) ∈ s ∧
***                (Spy, Y) ∈ s ∧
***                (Spy, ⦃X, Y⦄) ∈ s ∧
***                (∃U⊆spied s.
***                    ((Spy, ⟨n, X⟩) ∈ s ∨ (Spy, ⟨n, Y⟩) ∈ s) ∧
***                    U ∈ key_sets ⦃X, Y⦄ (crypts (Log -` spied s)))})⇧*;
***         Agent n ∉ parts (used y);
***         (Spy, Crypt K X) ∈ y ∧ (Spy, Key (InvK K)) ∈ y⟧
***        ⟹ Agent n ∉ parts_msg X
***  2. ⋀y z. ⟦n ∉ bad_agent;
***            (insert (Spy, VerKey)
***              (range (λx. (Asset x, Key (PriK (Auth_PriK x)))) ∪
***               {Spy} ×
***               (range Num ∪ range (λx. Key (PubK (Auth_PriK x))) ∪
***                range
***                 (λx. Crypt SigK
***                       ⦃Hash (Agent x), Hash (Key (PubK (Auth_PriK x)))⦄) ∪
***                Agent ` bad_agent ∪
***                Pwd ` bad_pwd ∪
***                (λx. Key (PriK x)) ` bad_prik ∪
***                (λx. Key (ShaK x)) ` bad_shak ∪
***                (λn. ⟨n, Pwd n⟩) ` bad_id_password ∪
***                (λx. ⟨x, Key (PriK (Auth_PriK x))⟩) ` bad_id_prikey ∪
***                (λx. ⟨x, Key (PubK (Auth_PriK x))⟩) ` bad_id_pubkey ∪
***                (λx. ⟨x, Key (ShaK (Auth_ShaK x))⟩) ` bad_id_shakey)),
***             y)
***            ∈ ({(s, s').
***                ∃n S. s' =
***                      insert
***                       (Spy, Log (Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))))
***                       (insert
***                         (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))
***                         (insert
***                           (Spy, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))
***                           (insert (Asset n, Key (PriK S)) s))) ∧
***                      Key (PriK S) ∉ used s} ∪
***               {(s, s').
***                ∃n S A K.
***                   s' =
***                   insert (Spy, Log (Crypt K (Key (PriK S))))
***                    (insert (Spy, Log ⦃Num (Suc 0), Key (PubK A)⦄)
***                      (insert (Owner n, ⦃Num (Suc 0), Key (PubK A)⦄)
***                        (insert (Spy, ⦃Num (Suc 0), Key (PubK A)⦄)
***                          (insert (Owner n, Key (PriK A)) s)))) ∧
***                   Crypt K (Key (PriK S)) ∈ used s ∧ Key (PriK A) ∉ used s} ∪
***               {(s, s').
***                ∃n A B.
***                   s' =
***                   insert (Spy, Log ⦃Num (Suc 0), Key (PubK A)⦄)
***                    (insert (Spy, Log ⦃Num 2, Key (PubK B)⦄)
***                      (insert (Asset n, ⦃Num 2, Key (PubK B)⦄)
***                        (insert (Spy, ⦃Num 2, Key (PubK B)⦄)
***                          (insert (Asset n, Key (PriK B)) s)))) ∧
***                   ⦃Num (Suc 0), Key (PubK A)⦄ ∈ used s ∧
***                   Key (PriK B) ∉ used s} ∪
***               {(s, s').
***                ∃n B C.
***                   s' =
***                   insert (Spy, Log ⦃Num 2, Key (PubK B)⦄)
***                    (insert (Spy, Log ⦃Num 3, Key (PubK C)⦄)
***                      (insert (Owner n, ⦃Num 3, Key (PubK C)⦄)
***                        (insert (Spy, ⦃Num 3, Key (PubK C)⦄)
***                          (insert (Owner n, Key (PriK C)) s)))) ∧
***                   ⦃Num 2, Key (PubK B)⦄ ∈ used s ∧ Key (PriK C) ∉ used s} ∪
***               {(s, s').
***                ∃n C D.
***                   s' =
***                   insert (Spy, Log ⦃Num 3, Key (PubK C)⦄)
***                    (insert (Spy, Log ⦃Num 4, Key (PubK D)⦄)
***                      (insert (Asset n, ⦃Num 4, Key (PubK D)⦄)
***                        (insert (Spy, ⦃Num 4, Key (PubK D)⦄)
***                          (insert (Asset n, Key (PriK D)) s)))) ∧
***                   ⦃Num 3, Key (PubK C)⦄ ∈ used s ∧ Key (PriK D) ∉ used s} ∪
***               {(s, s').
***                ∃n S A B C D K.
***                   s' =
***                   insert (Spy, Log ⦃Num 4, Key (PubK D)⦄)
***                    (insert
***                      (Spy,
***                       Log (Crypt
***                             (SesK
***                               (if K = ShaK (Auth_ShaK n) then Some S
***                                else None,
***                                {A, B}, {C, D}))
***                             (Key (PubK D))))
***                      (insert
***                        (Owner n,
***                         Crypt
***                          (SesK
***                            (if K = ShaK (Auth_ShaK n) then Some S else None,
***                             {A, B}, {C, D}))
***                          (Key (PubK D)))
***                        (insert
***                          (Spy,
***                           Crypt
***                            (SesK
***                              (if K = ShaK (Auth_ShaK n) then Some S
***                               else None,
***                               {A, B}, {C, D}))
***                            (Key (PubK D)))
***                          (insert
***                            (Owner n,
***                             Key (SesK
***                                   (if K = ShaK (Auth_ShaK n) then Some S
***                                    else None,
***                                    {A, B}, {C, D})))
***                            s)))) ∧
***                   Crypt K (Key (PriK S)) ∈ used s ∧
***                   ⦃Num 2, Key (PubK B)⦄ ∈ used s ∧
***                   ⦃Num 4, Key (PubK D)⦄ ∈ used s ∧
***                   (Owner n, ⦃Num (Suc 0), Key (PubK A)⦄) ∈ s ∧
***                   (Owner n, ⦃Num 3, Key (PubK C)⦄) ∈ s} ∪
***               {(s, s').
***                ∃n S A B C D.
***                   s' =
***                   insert
***                    (Spy,
***                     Log (Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Key (PubK D))))
***                    (insert
***                      (Spy,
***                       Log ⦃Crypt (SesK (Some S, {A, B}, {C, D}))
***                             (Key (PubK C)),
***                             Crypt (SesK (Some S, {A, B}, {C, D}))
***                              (Auth_PriK n ⊗ B),
***                             Crypt (SesK (Some S, {A, B}, {C, D}))
***                              (Crypt SigK
***                                ⦃Hash (Agent n),
***                                  Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                      (insert
***                        (Asset n,
***                         ⦃Crypt (SesK (Some S, {A, B}, {C, D}))
***                           (Key (PubK C)),
***                           Crypt (SesK (Some S, {A, B}, {C, D}))
***                            (Auth_PriK n ⊗ B),
***                           Crypt (SesK (Some S, {A, B}, {C, D}))
***                            (Crypt SigK
***                              ⦃Hash (Agent n),
***                                Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                        (insert
***                          (Spy,
***                           ⦃Crypt (SesK (Some S, {A, B}, {C, D}))
***                             (Key (PubK C)),
***                             Crypt (SesK (Some S, {A, B}, {C, D}))
***                              (Auth_PriK n ⊗ B),
***                             Crypt (SesK (Some S, {A, B}, {C, D}))
***                              (Crypt SigK
***                                ⦃Hash (Agent n),
***                                  Hash (Key (PubK (Auth_PriK n)))⦄)⦄)
***                          (insert
***                            (Asset n, Key (SesK (Some S, {A, B}, {C, D})))
***                            (insert (Asset n, Key (PubK B)) s))))) ∧
***                   (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))) ∈ s ∧
***                   (Asset n, ⦃Num 2, Key (PubK B)⦄) ∈ s ∧
***                   (Asset n, ⦃Num 4, Key (PubK D)⦄) ∈ s ∧
***                   ⦃Num (Suc 0), Key (PubK A)⦄ ∈ used s ∧
***                   ⦃Num 3, Key (PubK C)⦄ ∈ used s ∧
***                   Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))
***                   ∈ used s ∧
***                   (Asset n, Key (PubK B)) ∉ s} ∪
***               {(s, s').
***                ∃n A B C a aa b.
***                   s' =
***                   insert
***                    (Spy,
***                     Log ⦃Crypt (SesK (a, aa, b)) (Key (PubK C)),
***                           Crypt (SesK (a, aa, b)) (A ⊗ B),
***                           Crypt (SesK (a, aa, b))
***                            (Crypt SigK
***                              ⦃Hash (Agent n), Hash (Key (PubK A))⦄)⦄)
***                    (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))
***                      (insert (Owner n, Crypt (SesK (a, aa, b)) (Pwd n))
***                        (insert (Spy, Crypt (SesK (a, aa, b)) (Pwd n)) s))) ∧
***                   ⦃Crypt (SesK (a, aa, b)) (Key (PubK C)),
***                     Crypt (SesK (a, aa, b)) (A ⊗ B),
***                     Crypt (SesK (a, aa, b))
***                      (Crypt SigK ⦃Hash (Agent n), Hash (Key (PubK A))⦄)⦄
***                   ∈ used s ∧
***                   (Owner n, Key (SesK (a, aa, b))) ∈ s ∧ B ∈ aa} ∪
***               {(s, s').
***                ∃n a aa b.
***                   s' =
***                   insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))
***                    (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Num 0)))
***                      (insert (Asset n, Crypt (SesK (a, aa, b)) (Num 0))
***                        (insert (Spy, Crypt (SesK (a, aa, b)) (Num 0)) s))) ∧
***                   (Asset n, Key (SesK (a, aa, b))) ∈ s ∧
***                   Crypt (SesK (a, aa, b)) (Pwd n) ∈ used s} ∪
***               {(s, s').
***                ∃A. s' = insert (Spy, Key (PriK A)) s ∧
***                    Key (PriK A) ∉ used s} ∪
***               {(s, s').
***                ∃A. s' = insert (Spy, Key (PubK A)) s ∧
***                    (Spy, Key (PriK A)) ∈ s} ∪
***               {(s, s').
***                ∃A B C D S.
***                   s' = insert (Spy, Key (SesK (Some S, {A, B}, {C, D}))) s ∧
***                   (Spy, Key (PriK S)) ∈ s ∧
***                   (Spy, Key (PriK A)) ∈ s ∧
***                   (Spy, Key (PubK B)) ∈ s ∧
***                   (Spy, Key (PriK C)) ∈ s ∧ (Spy, Key (PubK D)) ∈ s} ∪
***               {(s, s').
***                ∃A B. s' =
***                      insert (Spy, Key (PriK A))
***                       (insert (Spy, Key (PriK B)) s) ∧
***                      (Spy, A ⊗ B) ∈ s ∧
***                      ((Spy, Key (PriK A)) ∈ s ∨ (Spy, Key (PriK B)) ∈ s)} ∪
***               {(s, s').
***                ∃A B. s' = insert (Spy, A ⊗ B) s ∧
***                      (Spy, Key (PriK A)) ∈ s ∧ (Spy, Key (PriK B)) ∈ s} ∪
***               {(s, s'). ∃X. s' = insert (Spy, Hash X) s ∧ (Spy, X) ∈ s} ∪
***               {(s, s').
***                ∃K X. s' = insert (Spy, X) s ∧
***                      (Spy, Crypt K X) ∈ s ∧ (Spy, Key (InvK K)) ∈ s} ∪
***               {(s, s').
***                ∃K X. s' = insert (Spy, Crypt K X) s ∧
***                      (Spy, X) ∈ s ∧ (Spy, Key K) ∈ s} ∪
***               {(s, s').
***                ∃X Y. s' = insert (Spy, X) (insert (Spy, Y) s) ∧
***                      (Spy, ⦃X, Y⦄) ∈ s} ∪
***               {(s, s').
***                ∃X Y. s' = insert (Spy, ⦃X, Y⦄) s ∧
***                      (Spy, X) ∈ s ∧ (Spy, Y) ∈ s} ∪
***               {(s, s').
***                ∃n. s' = insert (Spy, ⟨n, Agent n⟩) s ∧ (Spy, Agent n) ∈ s} ∪
***               {(s, s').
***                ∃n K. s' = insert (Spy, ⟨n, Key (InvK K)⟩) s ∧
***                      (Spy, Key (InvK K)) ∈ s ∧ (Spy, ⟨n, Key K⟩) ∈ s} ∪
***               {(s, s').
***                ∃n A a aa b.
***                   s' =
***                   insert (Spy, ⟨n, Key (PubK A)⟩)
***                    (insert (Spy, ⟨n, Key (SesK (a, aa, b))⟩) s) ∧
***                   (Spy, Key (PubK A)) ∈ s ∧
***                   (Spy, Key (SesK (a, aa, b))) ∈ s ∧
***                   ((Spy, ⟨n, Key (PubK A)⟩) ∈ s ∨
***                    (Spy, ⟨n, Key (SesK (a, aa, b))⟩) ∈ s) ∧
***                   A ∈ seskey_set (a, aa, b) ∧
***                   (∃X U. Key (SesK (a, aa, b)) ∈ U ∧
***                          U ∈ key_sets X (crypts (Log -` spied s)))} ∪
***               {(s, s').
***                ∃n A B.
***                   s' =
***                   insert (Spy, ⟨n, Key (PriK A)⟩)
***                    (insert (Spy, ⟨n, Key (PriK B)⟩) s) ∧
***                   (Spy, Key (PriK A)) ∈ s ∧
***                   (Spy, Key (PriK B)) ∈ s ∧ (Spy, ⟨n, A ⊗ B⟩) ∈ s} ∪
***               {(s, s').
***                ∃n A B.
***                   s' = insert (Spy, ⟨n, A ⊗ B⟩) s ∧
***                   (Spy, Key (PriK A)) ∈ s ∧
***                   (Spy, Key (PriK B)) ∈ s ∧
***                   (Spy, A ⊗ B) ∈ s ∧
***                   (∃U⊆spied s.
***                       ((Spy, ⟨n, Key (PriK A)⟩) ∈ s ∨
***                        (Spy, ⟨n, Key (PriK B)⟩) ∈ s) ∧
***                       U ∈ key_sets (A ⊗ B) (crypts (Log -` spied s)))} ∪
***               {(s, s').
***                ∃n X. s' =
***                      insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Hash X⟩) s) ∧
***                      (Spy, X) ∈ s ∧
***                      (Spy, Hash X) ∈ s ∧
***                      (∃U⊆spied s.
***                          ((Spy, ⟨n, X⟩) ∈ s ∨ (Spy, ⟨n, Hash X⟩) ∈ s) ∧
***                          U ∈ key_sets (Hash X) (crypts (Log -` spied s)))} ∪
***               {(s, s').
***                ∃n X U.
***                   s' = insert (Spy, ⟨n, X⟩) (s ∪ {Spy} × IDInfo n ` U) ∧
***                   (Spy, X) ∈ s ∧
***                   U ⊆ spied s ∧
***                   ((Spy, ⟨n, X⟩) ∈ s ∨ (∃K∈U. (Spy, ⟨n, K⟩) ∈ s)) ∧
***                   U ∈ key_sets X (crypts (Log -` spied s))} ∪
***               {(s, s').
***                ∃n X Y.
***                   s' = insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Y⟩) s) ∧
***                   (Spy, X) ∈ s ∧ (Spy, Y) ∈ s ∧ (Spy, ⟨n, ⦃X, Y⦄⟩) ∈ s} ∪
***               {(s, s').
***                ∃n X Y.
***                   s' = insert (Spy, ⟨n, ⦃X, Y⦄⟩) s ∧
***                   (Spy, X) ∈ s ∧
***                   (Spy, Y) ∈ s ∧
***                   (Spy, ⦃X, Y⦄) ∈ s ∧
***                   (∃U⊆spied s.
***                       ((Spy, ⟨n, X⟩) ∈ s ∨ (Spy, ⟨n, Y⟩) ∈ s) ∧
***                       U ∈ key_sets ⦃X, Y⦄ (crypts (Log -` spied s)))})⇧*;
***            Agent n ∉ parts (used y);
***            (∃K X. z = insert (Spy, Crypt K X) y ∧
***                   (Spy, X) ∈ y ∧ (Spy, Key K) ∈ y) ∨
***            (∃X Y. z = insert (Spy, X) (insert (Spy, Y) y) ∧
***                   (Spy, ⦃X, Y⦄) ∈ y) ∨
***            (∃X Y. z = insert (Spy, ⦃X, Y⦄) y ∧
***                   (Spy, X) ∈ y ∧ (Spy, Y) ∈ y) ∨
***            (∃n. z = insert (Spy, ⟨n, Agent n⟩) y ∧ (Spy, Agent n) ∈ y) ∨
***            (∃n K. z = insert (Spy, ⟨n, Key (InvK K)⟩) y ∧
***                   (Spy, Key (InvK K)) ∈ y ∧ (Spy, ⟨n, Key K⟩) ∈ y) ∨
***            (∃n A a aa b.
***                z =
***                insert (Spy, ⟨n, Key (PubK A)⟩)
***                 (insert (Spy, ⟨n, Key (SesK (a, aa, b))⟩) y) ∧
***                (Spy, Key (PubK A)) ∈ y ∧
***                (Spy, Key (SesK (a, aa, b))) ∈ y ∧
***                ((Spy, ⟨n, Key (PubK A)⟩) ∈ y ∨
***                 (Spy, ⟨n, Key (SesK (a, aa, b))⟩) ∈ y) ∧
***                A ∈ seskey_set (a, aa, b) ∧
***                (∃X U. Key (SesK (a, aa, b)) ∈ U ∧
***                       U ∈ key_sets X (crypts (Log -` spied y)))) ∨
***            (∃n A B.
***                z =
***                insert (Spy, ⟨n, Key (PriK A)⟩)
***                 (insert (Spy, ⟨n, Key (PriK B)⟩) y) ∧
***                (Spy, Key (PriK A)) ∈ y ∧
***                (Spy, Key (PriK B)) ∈ y ∧ (Spy, ⟨n, A ⊗ B⟩) ∈ y) ∨
***            (∃n A B.
***                z = insert (Spy, ⟨n, A ⊗ B⟩) y ∧
***                (Spy, Key (PriK A)) ∈ y ∧
***                (Spy, Key (PriK B)) ∈ y ∧
***                (Spy, A ⊗ B) ∈ y ∧
***                (∃U⊆spied y.
***                    ((Spy, ⟨n, Key (PriK A)⟩) ∈ y ∨
***                     (Spy, ⟨n, Key (PriK B)⟩) ∈ y) ∧
***                    U ∈ key_sets (A ⊗ B) (crypts (Log -` spied y)))) ∨
***            (∃n X. z = insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Hash X⟩) y) ∧
***                   (Spy, X) ∈ y ∧
***                   (Spy, Hash X) ∈ y ∧
***                   (∃U⊆spied y.
***                       ((Spy, ⟨n, X⟩) ∈ y ∨ (Spy, ⟨n, Hash X⟩) ∈ y) ∧
***                       U ∈ key_sets (Hash X) (crypts (Log -` spied y)))) ∨
***            (∃n X U.
***                z = insert (Spy, ⟨n, X⟩) (y ∪ {Spy} × IDInfo n ` U) ∧
***                (Spy, X) ∈ y ∧
***                U ⊆ spied y ∧
***                ((Spy, ⟨n, X⟩) ∈ y ∨ (∃K∈U. (Spy, ⟨n, K⟩) ∈ y)) ∧
***                U ∈ key_sets X (crypts (Log -` spied y))) ∨
***            (∃n X Y.
***                z = insert (Spy, ⟨n, X⟩) (insert (Spy, ⟨n, Y⟩) y) ∧
***                (Spy, X) ∈ y ∧ (Spy, Y) ∈ y ∧ (Spy, ⟨n, ⦃X, Y⦄⟩) ∈ y) ∨
***            (∃n X Y.
***                z = insert (Spy, ⟨n, ⦃X, Y⦄⟩) y ∧
***                (Spy, X) ∈ y ∧
***                (Spy, Y) ∈ y ∧
***                (Spy, ⦃X, Y⦄) ∈ y ∧
***                (∃U⊆spied y.
***                    ((Spy, ⟨n, X⟩) ∈ y ∨ (Spy, ⟨n, Y⟩) ∈ y) ∧
***                    U ∈ key_sets ⦃X, Y⦄ (crypts (Log -` spied y))))⟧
***           ⟹ Agent n ∉ parts (used z)
*** At command "by" (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Method/Anonymity.thy")
*** Failed to apply initial proof method (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Method/Anonymity.thy"):
*** goal (1 subgoal):
***  1. crypts {Crypt K X} ⊆ Crypt K ` crypts {X}
*** At command "by" (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Relational_Method/Anonymity.thy")

==========
Robinson_Arithmetic
*** Failed to load theory "Robinson_Arithmetic.Robinson_Arithmetic" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Robinson_Arithmetic.Instance" (unresolved "Robinson_Arithmetic.Robinson_Arithmetic")
*** ML error (line 118 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** ML error (line 328 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/nominal_dt_rawfuns.ML"):
*** Value or constructor (subtarget) has not been declared in structure Local_Theory
*** At command "ML_file" (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Nominal2/Nominal2.thy")

==========
Root_Balanced_Tree
*** Undefined fact: "real_mult_le_cancel_iff1" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Root_Balanced_Tree/Root_Balanced_Tree_Tab.thy")
*** At command "by" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Root_Balanced_Tree/Root_Balanced_Tree_Tab.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   0 < n
***   ?t = ?t
*** At command "using" (line 189 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy")

==========
Safe_Distance
*** Undefined fact: "real_mult_le_cancel_iff1" (line 1089 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Safe_Distance/Safe_Distance_Reaction.thy")
*** At command "using" (line 1089 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Safe_Distance/Safe_Distance_Reaction.thy")
*** Undefined fact: "real_mult_le_cancel_iff2" (line 137 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Safe_Distance/Safe_Distance.thy")
*** At command "by" (line 137 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Safe_Distance/Safe_Distance.thy")

==========
Secondary_Sylow
*** Undefined fact: "card_infinite" (line 218 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/SndSylow.thy")
*** At command "by" (line 218 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/SndSylow.thy")
*** Undefined fact: "card_infinite" (line 48 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/SndSylow.thy")
*** At command "by" (line 48 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/SndSylow.thy")
*** Undefined fact: "card_infinite" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/GroupAction.thy")
*** At command "by" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Secondary_Sylow/GroupAction.thy")

==========
SenSocialChoice
*** Failed to load theory "SenSocialChoice.RPRs" (unresolved "SenSocialChoice.FSext")
*** Failed to load theory "SenSocialChoice.SCFs" (unresolved "SenSocialChoice.RPRs")
*** Failed to load theory "SenSocialChoice.May" (unresolved "SenSocialChoice.SCFs")
*** Failed to load theory "SenSocialChoice.Arrow" (unresolved "SenSocialChoice.SCFs")
*** Failed to load theory "SenSocialChoice.Sen" (unresolved "SenSocialChoice.SCFs")
*** Undefined fact: "Finite_Set.card_infinite" (line 202 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/SenSocialChoice/FSext.thy")
*** At command "text" (line 196 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/SenSocialChoice/FSext.thy")

==========
Shivers-CFA
*** Failed to apply proof method (line 197 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Shivers-CFA/CPSUtils.thy"):
*** goal (1 subgoal):
***  1. ⋀x2 x3 b aa bb ab ba bc.
***        ⟦∀x∈set x2.
***            call.Let l binds c' ∈ calls (snd x) ⟶
***            fst ` set binds ⊆ vars (snd x);
***         call.Let l binds c' ∈ callsC x3 ⟹ fst ` set binds ⊆ varsC x3;
***         ((aa, b), bb) ∈ set binds; (aa, b) ∉ varsC x3;
***         ((ab, ba), bc) ∈ set x2; call.Let l binds c' ∈ calls bc⟧
***        ⟹ ∃x∈set x2. (aa, b) ∈ (case x of (v, l) ⇒ insert v (vars l))
*** At command "apply" (line 197 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Shivers-CFA/CPSUtils.thy")

==========
SIFPL
*** Failed to apply proof method (line 1601 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/SIFPL/VS_OBJ.thy"):
*** goal (1 subgoal):
***  1. ⋀l ac bc aaa baa.
***        ⟦noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);
***         ab  ≈⇩mkId bb aa; a  ≈⇩mkId b ab; mkId bb ∈ Pbij; mkId b ∈ Pbij;
***         Dom bb ⊆ Dom ba;
***         ∀l ll.
***            (l, ll) ∈ mkId bb ⟶
***            (∀a b. lookup bb l = Some (a, b) ⟶
***                   (∀aa bc.
***                       lookup ba ll = Some (aa, bc) ⟶
***                       twiddleObj (mkId bb) (a, b) (aa, bc)));
***         Dom b ⊆ Dom bb;
***         ∀l ll.
***            (l, ll) ∈ mkId b ⟶
***            (∀a ba.
***                lookup b l = Some (a, ba) ⟶
***                (∀aa bc.
***                    lookup bb ll = Some (aa, bc) ⟶
***                    twiddleObj (mkId b) (a, ba) (aa, bc)));
***         lookup b l = Some (ac, bc); lookup ba l = Some (aaa, baa);
***         l ∈ Dom b⟧
***        ⟹ twiddleObj (mkId b) (ac, bc) (aaa, baa)
*** At command "apply" (line 1601 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/SIFPL/VS_OBJ.thy")

==========
Simpl
*** Failed to load theory "Simpl.ProcParEx" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.ProcParExSP" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.XVcg" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.XVcgEx" (unresolved "Simpl.XVcg")
*** Failed to load theory "Simpl.ClosureEx" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.ComposeEx" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.Quicksort" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.SyntaxTest" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.UserGuide" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.VcgEx" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.VcgExSP" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.VcgExTotal" (unresolved "Simpl.Vcg")
*** Failed to load theory "Simpl.Simpl" (unresolved "Simpl.ClosureEx", "Simpl.ComposeEx", "Simpl.ProcParEx", "Simpl.ProcParExSP", "Simpl.Quicksort", "Simpl.SyntaxTest", "Simpl.UserGuide", "Simpl.VcgEx", "Simpl.VcgExSP", "Simpl.VcgExTotal", "Simpl.XVcgEx")
*** ML error (line 541 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> :
***       (theory -> local_theory) * ((theory -> local_theory) -> 'a) -> 'a
***    Argument:
***       (
***          thy |> Named_Target.init name,
***          Local_Theory.declaration {syntax = ..., ...} decl
***          )
***       : (theory -> local_theory) * (local_theory -> local_theory)
***    Reason:
***       Can't unify local_theory to theory -> local_theory
***          (Incompatible types)
*** ML error (line 816 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> :
***       (theory -> string * local_theory) *
***       ((theory -> string * local_theory) -> 'a)
***         -> 'a
***    Argument: (thy |> ... ... (... ...) expr elems, snd) :
***       (theory -> string * local_theory) * ('a * 'b -> 'b)
***    Reason:
***       Can't unify theory -> string * local_theory to 'a * 'b
***          (Incompatible types)
*** ML error (line 822 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: ||> : ('a * 'b) * ('b -> 'c) -> 'a * 'c
***    Argument: (thy |> ... ... (... ...) expr elems, Local_Theory.exit) :
***       (theory -> string * local_theory) * (local_theory -> Proof.context)
***    Reason:
***       Can't unify 'a * 'b to theory -> string * local_theory
***          (Incompatible types)
*** ML error (line 828 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function:
***       Expression.add_locale_cmd (Binding.name name) (Binding.name name) :
***       (xstring * Position.T) list ->
***         Expression.expression ->
***           Element.context list -> theory -> string * local_theory
***    Argument: (expression_no_pos expr) : Expression.expression
***    Reason:
***       Can't unify (xstring * Position.T) list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 827 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> :
***       (theory -> string * local_theory) *
***       ((theory -> string * local_theory) -> 'a)
***         -> 'a
***    Argument: (thy |> ... ... (... ...) (expression_no_pos expr) elems, snd)
***       : (theory -> string * local_theory) * ('a * 'b -> 'b)
***    Reason:
***       Can't unify theory -> string * local_theory to 'a * 'b
***          (Incompatible types)
*** ML error (line 866 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd parSP ([], []) :
***       Expression.expression -> Element.context list -> Proof.context
***    Argument: [] : 'a list
***    Reason:
***       Can't unify 'a list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 865 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale_cmd parSP ([...], ...) []) :
***       theory * (Element.context list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context list (*In Basis*)
***          (Different type constructors)
*** ML error (line 867 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd varSP ([], []) :
***       Expression.expression -> Element.context list -> Proof.context
***    Argument: [] : 'a list
***    Reason:
***       Can't unify 'a list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 865 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument:
***       (
***          thy |> ... ... (...) [] |> Proof_Context.theory_of,
***          add_locale_cmd varSP ([...], ...) []
***          )
***       : theory * (Element.context list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context list (*In Basis*)
***          (Different type constructors)
*** ML error (line 885 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd (name_variant "foo") lexp :
***       Expression.expression -> Element.context list -> Proof.context
***    Argument: [] : 'a list
***    Reason:
***       Can't unify 'a list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 883 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale_cmd (... ...) lexp []) :
***       theory * (Element.context list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context list (*In Basis*)
***          (Different type constructors)
*** ML error (line 890 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> :
***       (theory -> local_theory) * ((theory -> local_theory) -> 'a) -> 'a
***    Argument:
***       (
***          thy |> Named_Target.init loc,
***          (fn lthy => let val ... in ... ... end)
***          )
***       : (theory -> local_theory) *
***         (local_theory -> (term * term) * local_theory)
***    Reason:
***       Can't unify local_theory to theory -> local_theory
***          (Incompatible types)
*** ML error (line 1024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale sN :
***       string list ->
***         Expression.expression_i -> Element.context_i list -> Proof.context
***    Argument: pE :
***       (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***       'c list
***    Reason:
***       Can't unify string list to
***          (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***          'c list
***          (Incompatible types)
*** ML error (line 1024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale sN pE :
***       Expression.expression_i -> Element.context_i list -> Proof.context
***    Argument: fixes : (typ, 'a, 'b) Element.ctxt list
***    Reason:
***       Can't unify (typ, 'a, 'b) Element.ctxt list to
***          (string, term) Expression.expr *
***          (binding * typ option * mixfix) list
***          (Incompatible types)
*** ML error (line 1023 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale sN pE fixes) :
***       theory * (Element.context_i list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context_i list (*In Basis*)
***          (Different type constructors)
*** ML error (line 1026 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration :
***       string list -> declaration -> string -> theory
***    Argument: (intern_locale thy sN) : string
***    Reason:
***       Can't unify string list (*In Basis*) with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1026 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration (intern_locale thy sN) parameter_info_decl :
***       string -> theory
***    Argument: thy : theory
***    Reason:
***       Can't unify string (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1061 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (ctxt |> Proof_Context.theory_of, Named_Target.init lname) :
***       theory * (string -> theory -> local_theory)
***    Reason:
***       Can't unify theory with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1072 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale' (suffix bodyN name') :
***       string list ->
***         Expression.expression_i -> Element.context_i list -> 'a * 'b
***    Argument: pE :
***       (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***       'c list
***    Reason:
***       Can't unify string list to
***          (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***          'c list
***          (Incompatible types)
*** ML error (line 1072 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale' (suffix bodyN name') pE :
***       Expression.expression_i -> Element.context_i list -> 'a * 'b
***    Argument: fixes : (typ, 'a, 'b) Element.ctxt list
***    Reason:
***       Can't unify (typ, 'a, 'b) Element.ctxt list to
***          (string, term) Expression.expr *
***          (binding * typ option * mixfix) list
***          (Incompatible types)
*** ML error (line 1071 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale' (... ...) pE fixes) :
***       theory * (Element.context_i list -> 'a * 'b)
***    Reason:
***       Can't unify theory with Element.context_i list (*In Basis*)
***          (Different type constructors)
*** ML error (line 1127 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd implN parent :
***       Expression.expression -> Element.context list -> Proof.context
***    Argument: [] : 'a list
***    Reason:
***       Can't unify 'a list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 1126 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale_cmd implN parent []) :
***       theory * (Element.context list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context list (*In Basis*)
***          (Different type constructors)
*** ML error (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd cliqN (pE thy) :
***       Expression.expression -> Element.context list -> Proof.context
***    Argument: (elems thy) : ('a, string, 'b) Element.ctxt list
***    Reason:
***       Can't unify ('a, string, 'b) Element.ctxt list to
***          (xstring * Position.T, string) Expression.expr *
***          (binding * string option * mixfix) list
***          (Incompatible types)
*** ML error (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale_cmd cliqN (pE thy) (elems thy) :
***       Element.context list -> Proof.context
***    Argument: thy : theory
***    Reason:
***       Can't unify Element.context list (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1143 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration :
***       string list -> declaration -> string -> theory
***    Argument: (intern_locale thy cliqN) : string
***    Reason:
***       Can't unify string list (*In Basis*) with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1143 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration (intern_locale thy cliqN) proc_declaration :
***       string -> theory
***    Argument: thy : theory
***    Reason:
***       Can't unify string (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1144 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration :
***       string list -> declaration -> string -> theory
***    Argument: (intern_locale thy cliqN) : string
***    Reason:
***       Can't unify string list (*In Basis*) with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1144 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration (intern_locale thy cliqN) recursive_declaration
***       : string -> theory
***    Argument: thy : theory
***    Reason:
***       Can't unify string (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1170 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale thm_name :
***       string list ->
***         Expression.expression_i -> Element.context_i list -> Proof.context
***    Argument: pE' :
***       (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***       'c list
***    Reason:
***       Can't unify string list to
***          (string * ((string * bool) * ('a Expression.map * 'b list))) list *
***          'c list
***          (Incompatible types)
*** ML error (line 1170 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_locale thm_name pE' :
***       Expression.expression_i -> Element.context_i list -> Proof.context
***    Argument: [elem] : ('a, term, 'b) Element.ctxt list
***    Reason:
***       Can't unify ('a, term, 'b) Element.ctxt list to
***          (string, term) Expression.expr *
***          (binding * typ option * mixfix) list
***          (Incompatible types)
*** ML error (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument: (thy, add_locale thm_name pE' [elem]) :
***       theory * (Element.context_i list -> Proof.context)
***    Reason:
***       Can't unify theory with Element.context_i list (*In Basis*)
***          (Different type constructors)
*** ML error (line 1173 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration :
***       string list -> declaration -> string -> theory
***    Argument: (intern_locale thy thm_name) : string
***    Reason:
***       Can't unify string list (*In Basis*) with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1173 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_declaration (intern_locale thy thm_name) proc_declaration :
***       string -> theory
***    Argument: thy : theory
***    Reason:
***       Can't unify string (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1175 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: add_abbrev :
***       string list -> Syntax.mode -> bstring -> string -> string -> theory
***    Argument: (intern_locale thy (suffix cliqueN (cname name))) : string
***    Reason:
***       Can't unify string list (*In Basis*) with string (*In Basis*)
***          (Different type constructors)
*** ML error (line 1174 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: error_to_warning ("abbreviation: '" ^ thm_name ^ "' not added")
***       : (string -> string) -> string -> string
***    Argument:
***       (add_abbrev (... ... (... ...)) Syntax.mode_input thm_name spec) :
***       string -> theory
***    Reason:
***       Can't unify string (*In Basis*) with theory
***          (Different type constructors)
*** ML error (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/hoare.ML"):
*** Type error in function application.
***    Function: |> : theory * (theory -> 'a) -> 'a
***    Argument:
***       (
***          thy |> ... ... [...] |> Proof_Context.theory_of |>
***          (fn thy => ... ... thy)
***          ,
***          error_to_warning (... ^ ... ^ "' not added")
***          (... ... thm_name spec)
***          )
***       : theory * (string -> string)
***    Reason:
***       Can't unify theory with string (*In Basis*)
***          (Different type constructors)
*** At command "ML_file" (line 36 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simpl/Vcg.thy")

==========
Simplex
*** Failed to apply terminal proof method (line 3247 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simplex/Simplex.thy"):
*** goal:
*** No subgoals!
*** At command "by" (line 3247 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Simplex/Simplex.thy")

==========
Smooth_Manifolds
*** Undefined fact: "has_derivative_within_subset" (line 260 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Smooth_Manifolds/Bump_Function.thy")
*** At command "by" (line 260 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Smooth_Manifolds/Bump_Function.thy")
*** Undefined fact: "has_derivative_within_subset" (line 44 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Smooth_Manifolds/Smooth.thy")
*** At command "note" (line 44 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Smooth_Manifolds/Smooth.thy")

==========
Stable_Matching
*** Interrupt

==========
Statecharts
*** Failed to apply proof method (line 687 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Statecharts/HAOps.thy"):
*** goal (1 subgoal):
***  1. ⟦States SA2 ∩ (HAStates A ∪ States SA1) = {};
***      States SA1 ∩ HAStates A = {}; S ∈ HAStates A;
***      {SA2} ∉ ran (CompFun (A [++] (S, SA1)));
***      {SA2} ∈ ran (CompFun A [f+] (S, SA1))⟧
***     ⟹ False
*** At command "apply" (line 687 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Statecharts/HAOps.thy")

==========
Stateful_Protocol_Composition_and_Typing
*** Failed to apply initial proof method (line 347 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Stateful_Protocol_Composition_and_Typing/Typing_Result.thy"):
*** using this:
***     ℐ ?v2 = ?t2 ⟹ Γ (Var ?v2) = Γ ?t2 ∧ public_ground_wf_term ?t2
***     public_ground_wf_term ?t ⟹ fv ?t = {}
*** goal (1 subgoal):
***  1. ℐ v ≠ Var v
*** At command "by" (line 347 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Stateful_Protocol_Composition_and_Typing/Typing_Result.thy")

==========
Stirling_Formula
*** Undefined fact: "LIMSEQ_Suc_iff" (line 396 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 396 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
***   OF: no unifiers
***   ⟦⋀n. ?f n ≤ ?g n; ?f sums ?s; ?g sums ?t⟧ ⟹ ?s ≤ ?t
***   (⋀x. ?P x) ⟹ ∀x. ?P x
*** At command "proof" (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Stirling_Formula/Stirling_Formula.thy")

==========
Tail_Recursive_Functions
*** Failed to refine any pending goal
*** At command "qed" (line 528 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tail_Recursive_Functions/CaseStudy2.thy")
*** Failed to apply terminal proof method (line 430 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tail_Recursive_Functions/CaseStudy2.thy"):
*** goal (1 subgoal):
***  1. ⋀ux_ uy_.
***        ⟦∀n∈{..<Suc (Suc (length uy_))}.
***            (t_sorted xt ⟶ t_sorted ((ux_ # Leaf # uy_) ! n)) ∧
***            (0 < n ⟶
***             (∃y yl yr. (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) ∧
***            (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]
***             in t_multiset ((ux_ # Leaf # uy_) ! n) =
***                (if n = 0 then {#x#} else {#}) +
***                (if x ≤ t_val ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)
***                 then t_multiset (t_left (ts' ! Suc n))
***                 else t_multiset (t_right (ts' ! Suc n))));
***         X = ⦇t_type.folding = True, item = x, subtrees = ux_ # Leaf # uy_⦈⟧
***        ⟹ (y = x ⟶
***            count (t_multiset ux_) x = Suc (count (t_multiset xt) x)) ∧
***           (y ≠ x ⟶ count (t_multiset ux_) y = count (t_multiset xt) y)
*** At command "qed" (line 430 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tail_Recursive_Functions/CaseStudy2.thy")
*** Failed to apply terminal proof method (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tail_Recursive_Functions/CaseStudy2.thy"):
*** goal (1 subgoal):
***  1. ⋀ux_ uy_.
***        ⟦∀n∈{..<Suc (Suc (length uy_))}.
***            (t_sorted xt ⟶ t_sorted ((ux_ # Leaf # uy_) ! n)) ∧
***            (0 < n ⟶
***             (∃y yl yr. (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) ∧
***            (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]
***             in t_multiset ((ux_ # Leaf # uy_) ! n) =
***                (if n = 0 then {#x#} else {#}) +
***                (if x ≤ t_val ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)
***                 then t_multiset (t_left (ts' ! Suc n))
***                 else t_multiset (t_right (ts' ! Suc n))));
***         X = ⦇t_type.folding = True, item = x, subtrees = ux_ # Leaf # uy_⦈⟧
***        ⟹ t_sorted xt ⟶ t_sorted ux_
*** At command "qed" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tail_Recursive_Functions/CaseStudy2.thy")

==========
Tarskis_Geometry
*** Undefined fact: "card_infinite" (line 299 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tarskis_Geometry/Miscellany.thy")
*** At command "by" (line 299 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tarskis_Geometry/Miscellany.thy")

==========
TortoiseHare
*** Undefined fact: "nat_add_left_cancel" (line 125 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/TortoiseHare/Brent.thy")
*** At command "by" (line 124 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/TortoiseHare/Brent.thy")

==========
Tree_Decomposition
*** Undefined fact: "card_empty" (line 81 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tree_Decomposition/TreewidthCompleteGraph.thy")
*** At command "using" (line 81 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tree_Decomposition/TreewidthCompleteGraph.thy")
*** Undefined fact: "card_empty" (line 70 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tree_Decomposition/TreewidthTree.thy")
*** At command "by" (line 70 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Tree_Decomposition/TreewidthTree.thy")

==========
Twelvefold_Way
*** Undefined fact: "card_empty" (line 157 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** At command "by" (line 157 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** Undefined fact: "card_empty" (line 113 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** At command "by" (line 113 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** Undefined fact: "card_empty" (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** At command "by" (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** Undefined fact: "card_empty" (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** At command "by" (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Card_Bijections.thy")
*** Undefined fact: "card_infinite" (line 31 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Preliminaries.thy")
*** At command "from" (line 31 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Preliminaries.thy")
*** Undefined fact: "card_infinite" (line 194 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Preliminaries.thy")
*** At command "using" (line 194 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Twelvefold_Way/Preliminaries.thy")
*** Undefined fact: "card_empty" (line 350 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Partitions/Card_Partitions.thy")
*** At command "by" (line 350 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Partitions/Card_Partitions.thy")
*** Undefined fact: "card_empty" (line 306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** At command "by" (line 306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** Undefined fact: "card_empty" (line 146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** At command "by" (line 146 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Number_Partitions/Card_Number_Partitions.thy")
*** Undefined fact: "card_empty" (line 193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Multisets/Card_Multisets.thy")
*** At command "by" (line 193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Card_Multisets/Card_Multisets.thy")

==========
Universal_Turing_Machine
*** Failed to refine any pending goal
*** At command "qed" (line 2311 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/UTM.thy")
*** Failed to finish proof (line 1631 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/UTM.thy"):
*** goal (1 subgoal):
***  1. ⋀ln. b = Oc # Oc ↑ rs @ Bk # Bk # Bk ↑ ln @ Oc # ires ⟹
***          ∃ml. (∃lna. Oc # Oc ↑ rs @ Bk # Bk # Bk ↑ ln =
***                      Oc ↑ ml @ Bk # Bk # Bk ↑ lna) ∧
***               (∃mr. (∃rn. [Oc] = Oc ↑ mr @ Bk ↑ rn) ∧
***                     ml + mr = Suc (Suc rs) ∧ 0 < mr)
*** At command "by" (line 1631 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/UTM.thy")
*** Failed to refine any pending goal
*** At command "done" (line 2327 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Recursive.thy")
*** Cannot determine type of "Mr" (line 2492 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")
*** At command "apply" (line 2492 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")
*** Cannot determine type of "tn" (line 1214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")
*** At command "apply" (line 1214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")
*** Failed to apply proof method (line 1268 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy"):
*** goal (1 subgoal):
***  1. ⋀lm1 lm2 m ml mr rn.
***        ⟦∀n. xs ≠ Bk ↑ n;
***         am @ 0 ↑ (Suc q - length am) = lm1 @ m # lm2 ∧
***         length lm1 = q ∧
***         Suc m = ml + mr ∧
***         0 < ml ∧
***         (if lm1 = [] then aaa = Oc ↑ ml @ Bk # Bk # ires
***          else aaa = Oc ↑ ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) ∧
***         (mr = 0 ∧ xs = <lm2> @ Bk ↑ rn ∨ lm2 = [] ∧ Bk # xs = Oc ↑ mr)⟧
***        ⟹ am = lm1 @ m # lm2 ∧
***           aaa = <m # rev lm1> @ Bk # Bk # ires ∧ (∃rn. xs = <lm2> @ Bk ↑ rn)
*** At command "apply" (line 1268 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")
*** Failed to apply proof method (line 1198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy"):
*** goal (1 subgoal):
***  1. ⋀lm1 lm2 tn m ml mr rn.
***        am @ 0 ↑ tn = lm1 @ [m] @ lm2 ∧
***        length lm1 = q ∧
***        m + 1 = ml + mr ∧
***        ml ≠ 0 ∧
***        tn = q + 1 - length am ∧
***        (if lm1 = [] then aaa = Oc ↑ ml @ Bk # Bk # ires
***         else aaa = Oc ↑ ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) ∧
***        (Oc # xs = Oc ↑ mr @ [Bk] @ <lm2> @ Bk ↑ rn ∨
***         lm2 = [] ∧ Oc # xs = Oc ↑ mr) ⟹
***        am @ 0 ↑ tn = lm1 @ [m] @ lm2 ∧
***        length lm1 = q ∧
***        m + 1 = Suc ml + (mr - 1) ∧
***        Suc ml ≠ 0 ∧
***        tn = q + 1 - length am ∧
***        (if lm1 = [] then Oc # aaa = Oc ↑ Suc ml @ Bk # Bk # ires
***         else Oc # aaa = Oc ↑ Suc ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) ∧
***        (xs = Oc ↑ (mr - 1) @ [Bk] @ <lm2> @ Bk ↑ rn ∨
***         lm2 = [] ∧ xs = Oc ↑ (mr - 1))
*** At command "apply" (line 1198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Universal_Turing_Machine/Abacus.thy")

==========
UTP-Toolkit
*** Interrupt

==========
Verified-Prover
*** Type unification failed: Clash of types "form" and "nat"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  PAtom :: nat ⇒ nat list ⇒ form
*** Operand:   nat :: form
*** 
*** At command "apply" (line 1009 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Verified-Prover/Prover.thy")

==========
Vickrey_Clarke_Groves
*** Undefined fact: "card_infinite" (line 1235 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** At command "using" (line 1235 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** Undefined fact: "card_infinite" (line 1163 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** At command "by" (line 1163 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** Undefined fact: "card_infinite" (line 891 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** At command "by" (line 891 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** Undefined fact: "card_infinite" (line 879 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** At command "by" (line 879 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** Undefined fact: "card_infinite" (line 874 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** At command "by" (line 874 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/MiscTools.thy")
*** Undefined fact: "card_empty" (line 36 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/RelationProperties.thy")
*** At command "by" (line 36 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/RelationProperties.thy")
*** Undefined fact: "card_empty" (line 129 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")
*** At command "using" (line 129 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")
*** Undefined fact: "card_empty" (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")
*** At command "using" (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")
*** Undefined fact: "card_empty" (line 101 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")
*** At command "using" (line 101 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Vickrey_Clarke_Groves/SetUtils.thy")

==========
Winding_Number_Eval
*** Failed to apply initial proof method (line 2237 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Winding_Number_Eval/Winding_Number_Eval.thy"):
*** goal (1 subgoal):
***  1. z0 +
***     complex_of_real r *
***     (cos (complex_of_real ((1 - 0) *⇩R (2 * pi) + 0 *⇩R tt)) +
***      𝗂 * sin (complex_of_real ((1 - 0) *⇩R (2 * pi) + 0 *⇩R tt))) =
***     z0 + complex_of_real r
*** At command "by" (line 2237 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Winding_Number_Eval/Winding_Number_Eval.thy")

