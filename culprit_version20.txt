==========
Akra_Bazzi
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "HOL-Library.Code_Target_Int" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
Loading theory "HOL-Library.Function_Algebras" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics" via "Akra_Bazzi.Akra_Bazzi_Library" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
Loading theory "Akra_Bazzi.Eval_Numeral" (required by "Akra_Bazzi.Akra_Bazzi_Method")
Loading theory "HOL-Library.Landau_Symbols" (required by "Akra_Bazzi.Akra_Bazzi")
Loading theory "HOL-Library.Lattice_Algebras" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
Loading theory "HOL-Library.Log_Nat" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
### Code generator: dropping subsumed code equation
### 1 \<equiv> Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l \<equiv> ?l
### Code generator: dropping subsumed code equation
### ?k + 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m \<equiv> Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m \<equiv> Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l \<equiv> - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) \<equiv> Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) \<equiv> Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 \<equiv> 0
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### theory "HOL-Library.Code_Abstract_Nat"
### 0.075s elapsed time, 0.575s cpu time, 0.068s GC time
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
Loading theory "HOL-Library.Code_Target_Nat" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k * 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One \<equiv> - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One \<equiv> ?k
### Code generator: dropping subsumed code equation
### 0 div ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k div 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n \<equiv> - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n \<equiv>
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n \<equiv>
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n \<equiv> snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### 0 mod ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k \<equiv> True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Neg ?l \<equiv> ?l \<le> ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Pos ?l \<equiv> ?k \<le> ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l \<equiv> ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l \<equiv> ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 < 0 \<equiv> False
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
signature EVAL_NUMERAL =
  sig val eval_numeral_tac: Proof.context -> int -> tactic end
structure Eval_Numeral: EVAL_NUMERAL
### theory "Akra_Bazzi.Eval_Numeral"
### 0.157s elapsed time, 1.193s cpu time, 0.131s GC time
Loading theory "Landau_Symbols.Group_Sort" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics" via "Akra_Bazzi.Akra_Bazzi_Library" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### if ?n = 0 \<or> ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### theory "HOL-Library.Function_Algebras"
### 0.167s elapsed time, 1.278s cpu time, 0.131s GC time
### theory "HOL-Library.Log_Nat"
### 0.166s elapsed time, 1.270s cpu time, 0.131s GC time
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
### Code generator: dropping subsumed code equation
### Suc ?m \<le> ?n \<equiv> ?m < ?n
### Code generator: dropping subsumed code equation
### 0 \<le> ?n \<equiv> True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n \<equiv> ?m \<le> ?n
### Code generator: dropping subsumed code equation
### ?n < 0 \<equiv> False
locale groupsort
  fixes f :: "'a \<Rightarrow> 'b"
    and merge :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and g :: "'a list \<Rightarrow> 'c"
  assumes "groupsort f merge g"
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) \<equiv> numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 \<equiv> 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) \<equiv> - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) \<equiv> nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) \<equiv> 0
### theory "HOL-Library.Code_Target_Int"
### 0.208s elapsed time, 1.590s cpu time, 0.131s GC time
### Code generator: dropping subsumed code equation
### of_nat ?n \<equiv>
### semiring_1_class.of_nat_aux (\<lambda>i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.184s elapsed time, 1.373s cpu time, 0.125s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation")
### theory "HOL-Library.Code_Target_Numeral"
### 0.075s elapsed time, 0.568s cpu time, 0.000s GC time
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
Found termination order: "length <*mlex*> {}"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### ML warning (line 19 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 18 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
locale linorder_stupid_syntax
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_stupid_syntax less_eq less"
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### mset (filter ?P1 ?xs1) \<equiv> filter_mset ?P1 (mset ?xs1)
### theory "Landau_Symbols.Group_Sort"
### 1.341s elapsed time, 9.343s cpu time, 1.190s GC time
locale linorder_no_ub
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale linorder_no_lb
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
locale constr_dense_linorder
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and between :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 81 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (xT) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
bundle asymp_equiv_notation
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.min (\<le>)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.max (\<le>)) ?xs ?x
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 2.586s elapsed time, 17.610s cpu time, 1.696s GC time
### theory "HOL-Library.Landau_Symbols"
### 2.662s elapsed time, 17.920s cpu time, 1.628s GC time
Loading theory "Landau_Symbols.Landau_Real_Products" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics" via "Akra_Bazzi.Akra_Bazzi_Library" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs")
### Ignoring duplicate rewrite rule:
### sup ?x1 (sup ?x1 ?y1) \<equiv> sup ?x1 ?y1
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "\<And>a. \<bar>a\<bar> = sup a (- a)"
consts
  bigtheta_pow ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> 'b) set
                   \<Rightarrow> nat
                                 \<Rightarrow> ('a \<Rightarrow> 'b) set"
locale landau_function_family
  fixes F :: "'a filter"
    and H :: "('a \<Rightarrow> real) set"
  assumes "landau_function_family F H"
locale landau_function_family_pair
  fixes F :: "'a filter"
    and G :: "('a \<Rightarrow> real) set"
    and H :: "('a \<Rightarrow> real) set"
    and g :: "'a \<Rightarrow> real"
  assumes "landau_function_family_pair F G H g"
### theory "HOL-Library.Lattice_Algebras"
### 5.559s elapsed time, 28.909s cpu time, 2.260s GC time
Loading theory "HOL-Library.Interval" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
Loading theory "HOL-Library.Float" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
consts
  landau_dominating_chain' ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> real) list \<Rightarrow> bool"
consts
  nonneg_list :: "'a list \<Rightarrow> bool"
consts
  pos_list :: "'a list \<Rightarrow> bool"
locale landau_function_family_chain
  fixes F :: "'b filter"
    and gs :: "'a list"
    and get_param :: "'a \<Rightarrow> real"
    and get_fun :: "'a \<Rightarrow> 'b \<Rightarrow> real"
  assumes "landau_function_family_chain F gs get_fun"
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float \<Rightarrow> float
  abs_float == abs :: float \<Rightarrow> float
  uminus_float == uminus :: float \<Rightarrow> float
  one_float == one_class.one :: float
  times_float == times :: float \<Rightarrow> float \<Rightarrow> float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float \<Rightarrow> float \<Rightarrow> float
  less_eq_float == less_eq :: float \<Rightarrow> float \<Rightarrow> bool
  less_float == less :: float \<Rightarrow> float \<Rightarrow> bool
  plus_float == plus :: float \<Rightarrow> float \<Rightarrow> float
  equal_float == equal_class.equal ::
    float \<Rightarrow> float \<Rightarrow> bool
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float \<Rightarrow> float \<Rightarrow> float
  sup_float == sup :: float \<Rightarrow> float \<Rightarrow> float
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  primfun :: linorder
  less_eq_primfun == less_eq ::
    primfun \<Rightarrow> primfun \<Rightarrow> bool
  less_primfun == less :: primfun \<Rightarrow> primfun \<Rightarrow> bool
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> (float \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
Found termination order: "{}"
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
  less_interval == less ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
Found termination order: "{}"
Found termination order: "{}"
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
Found termination order: "{}"
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval \<Rightarrow> 'a interval
Found termination order: "{}"
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
Found termination order: "{}"
instantiation
  interval :: (linordered_semiring) times
  times_interval == times ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### ?i1 \<in> {?l1..?u1} \<equiv> ?l1 \<le> ?i1 \<and> ?i1 \<le> ?u1
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 \<equiv> ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<equiv> ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 - ?c1 \<equiv> ?a1 - (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + (?b1 - ?c1) \<equiv> ?a1 + ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 = ?c1 \<equiv> ?a1 = ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 = ?c1 - ?b1 \<equiv> ?a1 + ?b1 = ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - (?b1 - ?c1) \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 + ?c1 \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 < ?c1 \<equiv> ?a1 < ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 < ?c1 - ?b1 \<equiv> ?a1 + ?b1 < ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 \<le> ?c1 \<equiv> ?a1 \<le> ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 \<le> ?c1 - ?b1 \<equiv> ?a1 + ?b1 \<le> ?c1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### pos_primfun_list [] \<equiv> False
### Ignoring duplicate rewrite rule:
### pos_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> pos_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> nonneg_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### iszero_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### iszero_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### ?x1 = (0::?'b1) \<and> iszero_primfun_list ?xs1
### theory "Landau_Symbols.Landau_Real_Products"
### 5.410s elapsed time, 24.703s cpu time, 2.947s GC time
Loading theory "Landau_Symbols.Landau_Simprocs" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics" via "Akra_Bazzi.Akra_Bazzi_Library" via "Landau_Symbols.Landau_More")
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### Metis: Unused theorems: "Lattices.linorder_class.min.left_commute"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Library.Float"
### 3.254s elapsed time, 19.070s cpu time, 4.143s GC time
### ML warning (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (dest_bigtheta) has not been referenced.
### ML warning (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (x_name2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest1) has not been referenced.
### ML warning (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 373 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
signature LANDAU =
  sig
    val cancel_factor_conv: Proof.context -> cterm -> thm
    val cancel_factor_simproc: Proof.context -> cterm -> thm option
    val dest_landau: term -> term * term * term
    val landau_const_names: string list
    val landau_sum_limit: int Config.T
    val lift_landau_conv: conv -> conv
    val lift_landau_simproc:
       (Proof.context -> cterm -> thm option) ->
         Proof.context -> cterm -> thm option
    val simplify_landau_product_conv: Proof.context -> conv
    val simplify_landau_product_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_real_prod_prop_conv: Proof.context -> conv
    val simplify_landau_real_prod_prop_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_sum_conv: Proof.context -> conv
    val simplify_landau_sum_simproc: Proof.context -> cterm -> thm option
  end
structure Landau: LANDAU
### theory "Landau_Symbols.Landau_Simprocs"
### 0.876s elapsed time, 6.291s cpu time, 1.888s GC time
Loading theory "Landau_Symbols.Landau_More" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics" via "Akra_Bazzi.Akra_Bazzi_Library")
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set \<Rightarrow> bool
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a interval \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### theory "Landau_Symbols.Landau_More"
### 0.212s elapsed time, 1.588s cpu time, 0.129s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi_Library" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real" via "Akra_Bazzi.Akra_Bazzi_Asymptotics")
### theory "HOL-Library.Interval"
### 3.700s elapsed time, 22.255s cpu time, 4.400s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
### theory "Akra_Bazzi.Akra_Bazzi_Library"
### 0.170s elapsed time, 1.226s cpu time, 0.051s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi_Asymptotics" (required by "Akra_Bazzi.Akra_Bazzi" via "Akra_Bazzi.Akra_Bazzi_Real")
locale akra_bazzi_asymptotics_bep
  fixes b :: "real"
    and e :: "real"
    and p :: "real"
    and hb :: "real"
  assumes "akra_bazzi_asymptotics_bep b e hb"
### theory "Akra_Bazzi.Akra_Bazzi_Asymptotics"
### 0.363s elapsed time, 2.819s cpu time, 0.093s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi_Real" (required by "Akra_Bazzi.Akra_Bazzi")
locale akra_bazzi_integral
  fixes
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
  assumes "akra_bazzi_integral integrable integral"
locale akra_bazzi_params
  fixes k :: "nat"
    and as :: "real list"
    and bs :: "real list"
  assumes "akra_bazzi_params k as bs"
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
locale akra_bazzi_params_nonzero
  fixes k :: "nat"
    and as :: "real list"
    and bs :: "real list"
  assumes "akra_bazzi_params_nonzero k as bs"
### Rewrite rule not in simpset:
### power_down ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1
### then truncate_down (Suc ?p1) ((power_down ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_down (Suc ?p1) (?x1 * power_down ?p1 ?x1 ?n1)
locale akra_bazzi_real_recursion
  fixes as :: "real list"
    and bs :: "real list"
    and hs :: "(real \<Rightarrow> real) list"
    and k :: "nat"
    and x\<^sub>0 :: "real"
    and x\<^sub>1 :: "real"
    and hb :: "real"
    and e :: "real"
    and p :: "real"
  assumes "akra_bazzi_real_recursion as bs hs k x\<^sub>0 x\<^sub>1 hb e p"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### power_up ?p1 ?x1 0 \<equiv> 1
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
Found termination order: "length <*mlex*> {}"
locale akra_bazzi_real
  fixes as :: "real list"
    and bs :: "real list"
    and hs :: "(real \<Rightarrow> real) list"
    and k :: "nat"
    and x\<^sub>0 :: "real"
    and x\<^sub>1 :: "real"
    and hb :: "real"
    and e :: "real"
    and p :: "real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and f :: "real \<Rightarrow> real"
    and g :: "real \<Rightarrow> real"
    and C :: "real"
  assumes
    "akra_bazzi_real as bs hs k x\<^sub>0 x\<^sub>1 hb e p integrable
      integral f g C"
### Rewrite rule not in simpset:
### power_up ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1 then truncate_up ?p1 ((power_up ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_up ?p1 (?x1 * power_up ?p1 ?x1 ?n1)
locale akra_bazzi_nat_to_real
  fixes as :: "real list"
    and bs :: "real list"
    and hs :: "(real \<Rightarrow> real) list"
    and k :: "nat"
    and x\<^sub>0 :: "real"
    and x\<^sub>1 :: "real"
    and hb :: "real"
    and e :: "real"
    and p :: "real"
    and f :: "nat \<Rightarrow> real"
    and g :: "real \<Rightarrow> real"
  assumes "akra_bazzi_nat_to_real as bs hs k x\<^sub>0 x\<^sub>1 hb e p f g"
### theory "HOL-Library.Interval_Float"
### 1.144s elapsed time, 8.786s cpu time, 0.379s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Akra_Bazzi.Akra_Bazzi_Approximation" via "HOL-Decision_Procs.Approximation")
locale akra_bazzi_real_lower
  fixes as :: "real list"
    and bs :: "real list"
    and hs :: "(real \<Rightarrow> real) list"
    and k :: "nat"
    and x\<^sub>0 :: "real"
    and x\<^sub>1 :: "real"
    and hb :: "real"
    and e :: "real"
    and p :: "real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and f :: "real \<Rightarrow> real"
    and g :: "real \<Rightarrow> real"
    and C :: "real"
    and fb2 :: "real"
    and gb2 :: "real"
    and c2 :: "real"
  assumes
    "akra_bazzi_real_lower as bs hs k x\<^sub>0 x\<^sub>1 hb e p integrable
      integral f g C fb2 gb2 c2"
locale akra_bazzi_real_upper
  fixes as :: "real list"
    and bs :: "real list"
    and hs :: "(real \<Rightarrow> real) list"
    and k :: "nat"
    and x\<^sub>0 :: "real"
    and x\<^sub>1 :: "real"
    and hb :: "real"
    and e :: "real"
    and p :: "real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and f :: "real \<Rightarrow> real"
    and g :: "real \<Rightarrow> real"
    and C :: "real"
    and fb1 :: "real"
    and c1 :: "real"
  assumes
    "akra_bazzi_real_upper as bs hs k x\<^sub>0 x\<^sub>1 hb e p integrable
      integral f g C fb1 c1"
### theory "Akra_Bazzi.Akra_Bazzi_Real"
### 0.836s elapsed time, 6.479s cpu time, 0.323s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi"
consts
  horner ::
    "(nat \<Rightarrow> nat)
     \<Rightarrow> (nat \<Rightarrow> nat \<Rightarrow> nat)
                   \<Rightarrow> nat
                                 \<Rightarrow> nat
         \<Rightarrow> nat \<Rightarrow> real \<Rightarrow> real"
val it =
   "(\<lambda>x.
        5 * (ln (ln x))\<^sup>2 / (2 * x) powr (15 / 10) * inverse 2)
    \<in> \<omega>(\<lambda>x.
                      3 * ln x * ln x / x * ln (ln (ln (ln x)))) \<equiv>
    3 = 0 \<or>
    5 * inverse (2 powr (15 / 10)) * inverse 2 \<noteq> 0 \<and>
    pos_primfun_list
     (group_primfuns
       [(LnChain 1, - 1), (LnChain 1, - 1), (LnChain 0, 1),
        (LnChain 4, - 1), (LnChain 2, real 2), (LnChain 0, - (15 / 10))])":
   thm
locale akra_bazzi_recursion
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
  assumes "akra_bazzi_recursion x\<^sub>0 x\<^sub>1 k as bs ts"
locale akra_bazzi_function
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
  assumes
    "akra_bazzi_function x\<^sub>0 x\<^sub>1 k as bs ts f integrable
      integral g"
locale akra_bazzi_lower
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
    and g' :: "real \<Rightarrow> real"
  assumes
    "akra_bazzi_lower x\<^sub>0 x\<^sub>1 k as bs ts f integrable integral g
      g'"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
locale akra_bazzi_upper
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
    and g' :: "real \<Rightarrow> real"
  assumes
    "akra_bazzi_upper x\<^sub>0 x\<^sub>1 k as bs ts f integrable integral g
      g'"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
locale akra_bazzi
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and
    integrable ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> bool"
    and
    integral ::
      "(real \<Rightarrow> real)
       \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
    and g' :: "real \<Rightarrow> real"
  assumes
    "akra_bazzi x\<^sub>0 x\<^sub>1 k as bs ts f integrable integral g g'"
### theory "Akra_Bazzi.Akra_Bazzi"
### 0.852s elapsed time, 6.654s cpu time, 0.311s GC time
Loading theory "Akra_Bazzi.Master_Theorem"
### Ignoring duplicate rewrite rule:
### of_nat (Suc ?m1) \<equiv> (1::?'a1) + of_nat ?m1
### Rewrite rule not in simpset:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln (?x1 * ?y1) \<equiv> ln ?x1 + ln ?y1
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Rewrite rule not in simpset:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln (?x1 * ?y1) \<equiv> ln ?x1 + ln ?y1
locale master_theorem_function
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
  assumes "master_theorem_function x\<^sub>0 x\<^sub>1 k as bs ts f g"
### theory "Akra_Bazzi.Master_Theorem"
### 0.571s elapsed time, 4.406s cpu time, 0.254s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi_Method"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
locale master_theorem_function
  fixes x\<^sub>0 :: "nat"
    and x\<^sub>1 :: "nat"
    and k :: "nat"
    and as :: "real list"
    and bs :: "real list"
    and ts :: "(nat \<Rightarrow> nat) list"
    and f :: "nat \<Rightarrow> real"
    and g :: "nat \<Rightarrow> real"
  assumes "master_theorem_function x\<^sub>0 x\<^sub>1 k as bs ts f g"
### ML warning (line 369 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Akra_Bazzi/Akra_Bazzi_Method.thy"):
### Pattern is not exhaustive.
val generalize_master_thm = fn: Proof.context -> thm -> thm
val generalize_master_thm' = fn:
   binding * thm -> Proof.context -> local_theory
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
signature AKRA_BAZZI =
  sig
    val akra_bazzi_measure_tac: Proof.context -> int -> tactic
    val akra_bazzi_relation_tac: Proof.context -> int -> tactic
    val akra_bazzi_sum_tac: Proof.context -> int -> tactic
    val akra_bazzi_term_tac: Proof.context -> int -> tactic
    val akra_bazzi_termination_tac: Proof.context -> int -> tactic
    val master_theorem_function_tac: bool -> Proof.context -> int -> tactic
    val master_theorem_tac:
       string option ->
         bool ->
           thm option ->
             term option ->
               term option -> term option -> Proof.context -> int -> tactic
    val setup_master_theorem:
       Context.generic * Token.T list ->
         (Proof.context -> Method.method) * (Context.generic * Token.T list)
  end
structure Akra_Bazzi: AKRA_BAZZI
### theory "Akra_Bazzi.Akra_Bazzi_Method"
### 1.607s elapsed time, 9.086s cpu time, 0.365s GC time
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 6.104s elapsed time, 37.185s cpu time, 1.572s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Akra_Bazzi.Akra_Bazzi_Approximation")
*** Failed to apply proof method (line 45 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Akra_Bazzi/Master_Theorem.thy"):
*** goal (1 subgoal):
***  1. \<And>a c b f.
***        \<lbrakk>a \<le> c; c \<le> b; f integrable_on {a..b}\<rbrakk>
***        \<Longrightarrow> integral {a..c} f + integral {c..b} f =
***                          integral {a..b} f
*** At command "apply" (line 45 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Akra_Bazzi/Master_Theorem.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "{}"
Found termination order: "{}"
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "{}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln ?x1 \<le> ln ?y1 \<equiv> ?x1 \<le> ?y1
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. 0) (\<lambda>x. Suc 0) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. Suc 0) (\<lambda>x. 0) <*mlex*>
   case_sum (\<lambda>p. size (fst (snd (snd p))))
    (\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 204 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 23.826s elapsed time, 86.400s cpu time, 14.404s GC time
Loading theory "Akra_Bazzi.Akra_Bazzi_Approximation"
locale akra_bazzi_params_nonzero
  fixes k :: "nat"
    and as :: "real list"
    and bs :: "real list"
  assumes "akra_bazzi_params_nonzero k as bs"
signature AKRA_BAZZI_APPROXIMATION =
  sig
    val akra_bazzi_approximate_tac: int -> Proof.context -> int -> tactic
  end
structure Akra_Bazzi_Approximation: AKRA_BAZZI_APPROXIMATION
### theory "Akra_Bazzi.Akra_Bazzi_Approximation"
### 0.409s elapsed time, 0.562s cpu time, 0.000s GC time
Loading theory "Akra_Bazzi.Master_Theorem_Examples"
locale det_select
  fixes b :: "real"
  assumes "det_select b"
### theory "Akra_Bazzi.Master_Theorem_Examples"
### 0.884s elapsed time, 6.101s cpu time, 0.357s GC time
*** Failed to apply proof method (line 45 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Akra_Bazzi/Master_Theorem.thy"):
*** goal (1 subgoal):
***  1. \<And>a c b f.
***        \<lbrakk>a \<le> c; c \<le> b; f integrable_on {a..b}\<rbrakk>
***        \<Longrightarrow> integral {a..c} f + integral {c..b} f =
***                          integral {a..b} f
*** At command "apply" (line 45 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Akra_Bazzi/Master_Theorem.thy")

==========
Applicative_Lifting
Loading theory "Applicative_Lifting.Applicative"
Loading theory "Applicative_Lifting.Joinable" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators" via "Applicative_Lifting.Beta_Eta")
Loading theory "HOL-Library.State_Monad" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_State")
Loading theory "HOL-Library.Confluence" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_DNEList" via "HOL-Library.Dlist" via "HOL-Library.Confluent_Quotient")
Loading theory "HOL-Library.Function_Algebras" (required by "Applicative_Lifting.Applicative_Examples" via "Applicative_Lifting.Applicative_Environment_Algebra" via "HOL-Library.Function_Division")
Loading theory "HOL-Nonstandard_Analysis.Free_Ultrafilter" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_Star" via "HOL-Nonstandard_Analysis.StarDef")
Loading theory "HOL-Proofs-Lambda.Commutation" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators" via "Applicative_Lifting.Beta_Eta" via "HOL-Proofs-Lambda.Eta" via "HOL-Proofs-Lambda.ParRed")
Loading theory "HOL-Proofs-Lambda.Lambda" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators" via "Applicative_Lifting.Beta_Eta" via "HOL-Proofs-Lambda.Eta" via "HOL-Proofs-Lambda.ParRed")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
locale ultrafilter
  fixes F :: "'a filter"
  assumes "ultrafilter F"
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
locale freeultrafilter
  fixes F :: "'a filter"
  assumes "freeultrafilter F"
### theory "HOL-Nonstandard_Analysis.Free_Ultrafilter"
### 0.077s elapsed time, 0.596s cpu time, 0.064s GC time
Loading theory "HOL-Nonstandard_Analysis.StarDef" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_Star")
### theory "HOL-Library.Function_Algebras"
### 0.089s elapsed time, 0.703s cpu time, 0.064s GC time
Loading theory "HOL-Library.Function_Division" (required by "Applicative_Lifting.Applicative_Examples" via "Applicative_Lifting.Applicative_Environment_Algebra")
### theory "HOL-Library.Confluence"
### 0.096s elapsed time, 0.744s cpu time, 0.064s GC time
Loading theory "HOL-Library.Confluent_Quotient" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_DNEList" via "HOL-Library.Dlist")
instantiation
  fun :: (type, inverse) inverse
  inverse_fun == inverse ::
    ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
  divide_fun == divide ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
### theory "HOL-Library.Function_Division"
### 0.031s elapsed time, 0.241s cpu time, 0.000s GC time
### theory "Applicative_Lifting.Joinable"
### 0.132s elapsed time, 1.046s cpu time, 0.064s GC time
### theory "HOL-Proofs-Lambda.Commutation"
### 0.141s elapsed time, 1.113s cpu time, 0.064s GC time
locale confluent_quotient
  fixes R :: "'Fb \<Rightarrow> 'Fb \<Rightarrow> bool"
    and Ea :: "'Fa \<Rightarrow> 'Fa \<Rightarrow> bool"
    and Eb :: "'Fb \<Rightarrow> 'Fb \<Rightarrow> bool"
    and Ec :: "'Fc \<Rightarrow> 'Fc \<Rightarrow> bool"
    and Eab :: "'Fab \<Rightarrow> 'Fab \<Rightarrow> bool"
    and Ebc :: "'Fbc \<Rightarrow> 'Fbc \<Rightarrow> bool"
    and \<pi>_Faba :: "'Fab \<Rightarrow> 'Fa"
    and \<pi>_Fabb :: "'Fab \<Rightarrow> 'Fb"
    and \<pi>_Fbcb :: "'Fbc \<Rightarrow> 'Fb"
    and \<pi>_Fbcc :: "'Fbc \<Rightarrow> 'Fc"
    and
    rel_Fab ::
      "('a \<Rightarrow> 'b \<Rightarrow> bool)
       \<Rightarrow> 'Fa \<Rightarrow> 'Fb \<Rightarrow> bool"
    and
    rel_Fbc ::
      "('b \<Rightarrow> 'c \<Rightarrow> bool)
       \<Rightarrow> 'Fb \<Rightarrow> 'Fc \<Rightarrow> bool"
    and
    rel_Fac ::
      "('a \<Rightarrow> 'c \<Rightarrow> bool)
       \<Rightarrow> 'Fa \<Rightarrow> 'Fc \<Rightarrow> bool"
    and set_Fab :: "'Fab \<Rightarrow> ('a \<times> 'b) set"
    and set_Fbc :: "'Fbc \<Rightarrow> ('b \<times> 'c) set"
  assumes
    "confluent_quotient R Ea Eb Ec Eab Ebc \<pi>_Faba \<pi>_Fabb \<pi>_Fbcb
      \<pi>_Fbcc rel_Fab rel_Fbc rel_Fac set_Fab set_Fbc"
### theory "HOL-Library.Confluent_Quotient"
### 0.112s elapsed time, 0.882s cpu time, 0.108s GC time
Loading theory "HOL-Library.Dlist" (required by "Applicative_Lifting.Applicative_Functor" via "Applicative_Lifting.Applicative_DNEList")
### ML warning (line 78 of "~~/src/HOL/Nonstandard_Analysis/transfer_principle.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Nonstandard_Analysis/transfer_principle.ML"):
### Pattern is not exhaustive.
signature TRANSFER_PRINCIPLE =
  sig
    val add_const: string -> theory -> theory
    val transfer_tac: Proof.context -> thm list -> int -> tactic
  end
structure Transfer_Principle: TRANSFER_PRINCIPLE
### Ignoring duplicate elimination (elim)
### \<lbrakk>?P \<le> ?Q; ?P ?x ?y; ?Q ?x ?y \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Ignoring duplicate elimination (elim)
### \<lbrakk>?P \<le> ?Q; ?P ?x ?y; ?Q ?x ?y \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
locale Quotient_dlist
instantiation
  star :: (zero) zero
  zero_star == zero_class.zero :: 'a star
instantiation
  star :: (one) one
  one_star == one_class.one :: 'a star
instantiation
  star :: (plus) plus
  plus_star == plus :: 'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (times) times
  times_star == times :: 'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (uminus) uminus
  uminus_star == uminus :: 'a star \<Rightarrow> 'a star
instantiation
  star :: (minus) minus
  minus_star == minus :: 'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (abs) abs
  abs_star == abs :: 'a star \<Rightarrow> 'a star
instantiation
  star :: (sgn) sgn
  sgn_star == sgn :: 'a star \<Rightarrow> 'a star
instantiation
  star :: (divide) divide
  divide_star == divide ::
    'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (inverse) inverse
  inverse_star == inverse :: 'a star \<Rightarrow> 'a star
instantiation
  star :: (modulo) modulo
  modulo_star == modulo ::
    'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (ord) ord
  less_eq_star == less_eq ::
    'a star \<Rightarrow> 'a star \<Rightarrow> bool
  less_star == less :: 'a star \<Rightarrow> 'a star \<Rightarrow> bool
instantiation
  star :: (semilattice_inf) semilattice_inf
  inf_star == inf :: 'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  star :: (semilattice_sup) semilattice_sup
  sup_star == sup :: 'a star \<Rightarrow> 'a star \<Rightarrow> 'a star
instantiation
  dlist :: (equal) equal
  equal_dlist == equal_class.equal ::
    'a dlist \<Rightarrow> 'a dlist \<Rightarrow> bool
signature APPLICATIVE =
  sig
    val add_unfold_attrib: xstring option -> attribute
    type afun
    val afun_fold_tac: Proof.context -> afun -> int -> tactic
    type afun_inst
    val afun_of: Proof.context -> string -> afun
    val afun_of_generic: Context.generic -> string -> afun
    val afun_unfold_tac: Proof.context -> afun -> int -> tactic
    val afuns_of_term: Proof.context -> term -> afun list
    val afuns_of_term_generic: Context.generic -> term -> afun list
    val afuns_of_typ: Proof.context -> typ -> afun list
    val afuns_of_typ_generic: Context.generic -> typ -> afun list
    val applicative_cmd:
       ((((binding * string list) * string) * string) * string option) *
       string option
         -> local_theory -> Proof.state
    val combinator_rule_attrib: string list option -> attribute
    val dest_comb: Proof.context -> afun_inst -> term -> term * term
    val dest_pure: Proof.context -> afun_inst -> term -> term
    val dest_type: Proof.context -> afun_inst -> typ -> typ option
    val dest_type': Proof.context -> afun_inst -> typ -> typ
    val extern: Context.generic -> string -> xstring
    val fold_wrapper_tac: Proof.context -> afun option -> int -> tactic
    val forward_lift_attrib: xstring -> attribute
    val forward_lift_rule: Proof.context -> afun -> thm -> thm
    val general_normalform_conv:
       Proof.context -> afun -> cterm * cterm -> thm * thm
    val general_normalize_rel_tac: Proof.context -> afun -> int -> tactic
    val generalize_lift_terms:
       afun_inst -> term list -> Proof.context -> term list * Proof.context
    val import_afun_inst: afun -> Proof.context -> afun_inst * Proof.context
    val infer_comb: Proof.context -> afun_inst -> term * term -> term
    val inner_sort_of: afun_inst -> sort
    val intern: Context.generic -> xstring -> string
    val lift_term: afun_inst -> term -> term
    val lifting_wrapper_tac: Proof.context -> afun option -> int -> tactic
    val match_afun_inst: Proof.context -> afun -> term * int -> afun_inst
    val mk_ap: afun_inst -> typ * typ -> term
    val mk_comb: afun_inst -> typ -> term * term -> term
    val mk_pure: afun_inst -> typ -> term
    val mk_set: afun_inst -> typ -> term
    val mk_type: afun_inst -> typ -> typ
    val name_of_afun: afun -> binding
    val normalform_conv: Proof.context -> afun -> conv
    val normalize_rel_tac: Proof.context -> afun -> int -> tactic
    val normalize_wrapper_tac: Proof.context -> afun option -> int -> tactic
    val parse_opt_afun: afun option context_parser
    val print_afuns: Proof.context -> unit
    val setup_combinators:
       (string * thm) list -> local_theory -> local_theory
    val subst_lift_term: afun_inst -> (term * term) list -> term -> term
    val unfold_all_tac: Proof.context -> int -> tactic
    val unfold_wrapper_tac: Proof.context -> afun option -> int -> tactic
    val unfolds_of_afun: afun -> thm list
  end
### theory "Applicative_Lifting.Applicative"
### 0.503s elapsed time, 3.905s cpu time, 0.420s GC time
instantiation
  star :: (normalization_semidom) normalization_semidom
  normalize_star == normalize :: 'a star \<Rightarrow> 'a star
  unit_factor_star == unit_factor :: 'a star \<Rightarrow> 'a star
consts
  lift :: "dB \<Rightarrow> nat \<Rightarrow> dB"
consts
  subst :: "dB \<Rightarrow> dB \<Rightarrow> nat \<Rightarrow> dB"
### theory "HOL-Nonstandard_Analysis.StarDef"
### 0.588s elapsed time, 4.470s cpu time, 1.004s GC time
consts
  liftn :: "nat \<Rightarrow> dB \<Rightarrow> nat \<Rightarrow> dB"
consts
  substn :: "dB \<Rightarrow> dB \<Rightarrow> nat \<Rightarrow> dB"
Proofs for inductive predicate(s) "double"
Proofs for inductive predicate(s) "beta"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Proofs-Lambda.Lambda"
### 0.834s elapsed time, 6.354s cpu time, 1.118s GC time
Loading theory "HOL-Proofs-Lambda.ParRed" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators" via "Applicative_Lifting.Beta_Eta" via "HOL-Proofs-Lambda.Eta")
### theory "HOL-Library.Dlist"
### 0.682s elapsed time, 5.130s cpu time, 0.997s GC time
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "par_beta"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Rule already declared as introduction (intro)
### (\<And>a s s'.
###     run_state ?m s = (a, s') \<Longrightarrow> ?P s s') \<Longrightarrow>
### state_io_rel ?P ?m
### Rule already declared as introduction (intro)
### (\<And>a s s'.
###     run_state ?m s = (a, s') \<Longrightarrow> ?P s s') \<Longrightarrow>
### state_io_rel ?P ?m
### Rule already declared as elimination (elim)
### \<lbrakk>state_io_rel ?P ?m; run_state ?m ?s = (?a, ?s');
###  ?P ?s ?s' \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Rule already declared as elimination (elim)
### \<lbrakk>state_io_rel ?P ?m; run_state ?m ?s = (?a, ?s');
###  ?P ?s ?s' \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Rule already declared as elimination (elim)
### \<lbrakk>state_io_rel ?P ?m; run_state ?m ?s = (?a, ?s');
###  ?P ?s ?s' \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### theory "HOL-Library.State_Monad"
### 1.056s elapsed time, 8.047s cpu time, 1.245s GC time
### Rule already declared as introduction (intro)
### (\<And>a s s'.
###     run_state ?m s = (a, s') \<Longrightarrow> ?P s s') \<Longrightarrow>
### state_io_rel ?P ?m
### Rule already declared as introduction (intro)
### (\<And>a s s'.
###     run_state ?m s = (a, s') \<Longrightarrow> ?P s s') \<Longrightarrow>
### state_io_rel ?P ?m
Found termination order: "size <*mlex*> {}"
### theory "HOL-Proofs-Lambda.ParRed"
### 0.303s elapsed time, 2.373s cpu time, 0.127s GC time
Loading theory "HOL-Proofs-Lambda.Eta" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators" via "Applicative_Lifting.Beta_Eta")
consts
  free :: "dB \<Rightarrow> nat \<Rightarrow> bool"
Proofs for inductive predicate(s) "eta"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Proofs-Lambda.Eta"
### 0.104s elapsed time, 0.434s cpu time, 0.056s GC time
Loading theory "Applicative_Lifting.Beta_Eta" (required by "Applicative_Lifting.Idiomatic_Terms" via "Applicative_Lifting.Combinators")
### theory "Applicative_Lifting.Beta_Eta"
### 0.203s elapsed time, 1.249s cpu time, 0.043s GC time
Loading theory "Applicative_Lifting.Combinators" (required by "Applicative_Lifting.Idiomatic_Terms")
### theory "Applicative_Lifting.Combinators"
### 0.063s elapsed time, 0.469s cpu time, 0.055s GC time
Loading theory "Applicative_Lifting.Idiomatic_Terms"
consts
  opaque :: "'a itrm \<Rightarrow> 'a list"
Proofs for inductive predicate(s) "itrm_cong"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "idiom_rule"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale special_idiom
  fixes extra_rule :: "'a itrm \<Rightarrow> 'a itrm \<Rightarrow> bool"
consts
  unlift' :: "nat \<Rightarrow> 'a itrm \<Rightarrow> nat \<Rightarrow> dB"
consts
  unlift_vars :: "nat \<Rightarrow> nat itrm \<Rightarrow> dB"
Proofs for inductive predicate(s) "CFp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
consts
  CF_pure :: "'a itrm \<Rightarrow> dB"
consts
  norm_pn :: "dB \<Rightarrow> 'a itrm \<Rightarrow> 'a itrm"
consts
  norm_nn :: "'a itrm \<Rightarrow> 'a itrm \<Rightarrow> 'a itrm"
consts
  norm :: "'a itrm \<Rightarrow> 'a itrm"
consts
  strip_context :: "nat \<Rightarrow> dB \<Rightarrow> nat \<Rightarrow> dB"
locale bracket_abstraction
  fixes term_bracket :: "nat \<Rightarrow> dB \<Rightarrow> dB option"
  assumes "bracket_abstraction term_bracket"
locale itrm_abstraction
  fixes extra_rule :: "nat itrm \<Rightarrow> nat itrm \<Rightarrow> bool"
    and
    itrm_bracket ::
      "nat \<Rightarrow> nat itrm \<Rightarrow> nat itrm option"
  assumes "itrm_abstraction extra_rule itrm_bracket"
locale lifted_bracket
  fixes term_bracket :: "nat \<Rightarrow> dB \<Rightarrow> dB option"
    and extra_rule :: "nat itrm \<Rightarrow> nat itrm \<Rightarrow> bool"
    and
    itrm_bracket ::
      "nat \<Rightarrow> nat itrm \<Rightarrow> nat itrm option"
  assumes "lifted_bracket term_bracket extra_rule itrm_bracket"
### theory "Applicative_Lifting.Idiomatic_Terms"
### 0.902s elapsed time, 4.679s cpu time, 0.198s GC time
*** Failed to load theory "Applicative_Lifting.Applicative_Environment" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_List" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Monoid" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Open_State" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Option" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Set" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Sum" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Environment_Algebra" (unresolved "Applicative_Lifting.Applicative_Environment")
*** Failed to load theory "Applicative_Lifting.Applicative_Stream" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Stream_Algebra" (unresolved "Applicative_Lifting.Applicative_Stream")
*** Failed to load theory "Applicative_Lifting.Applicative_Filter" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Probability_List" (unresolved "Applicative_Lifting.Applicative_List")
*** Failed to load theory "Applicative_Lifting.Applicative_Vector" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_PMF" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Star" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_DNEList" (unresolved "Applicative_Lifting.Applicative_List")
*** Failed to load theory "Applicative_Lifting.Applicative_State" (unresolved "Applicative_Lifting.Applicative")
*** Failed to load theory "Applicative_Lifting.Applicative_Functor" (unresolved "Applicative_Lifting.Applicative_DNEList", "Applicative_Lifting.Applicative_Environment", "Applicative_Lifting.Applicative_Filter", "Applicative_Lifting.Applicative_List", "Applicative_Lifting.Applicative_Monoid", "Applicative_Lifting.Applicative_Open_State", "Applicative_Lifting.Applicative_Option", "Applicative_Lifting.Applicative_PMF", "Applicative_Lifting.Applicative_Probability_List", "Applicative_Lifting.Applicative_Set", "Applicative_Lifting.Applicative_Star", "Applicative_Lifting.Applicative_State", "Applicative_Lifting.Applicative_Stream", "Applicative_Lifting.Applicative_Sum", "Applicative_Lifting.Applicative_Vector")
*** Failed to load theory "Applicative_Lifting.Tree_Relabelling" (unresolved "Applicative_Lifting.Applicative_Option", "Applicative_Lifting.Applicative_PMF", "Applicative_Lifting.Applicative_State")
*** Failed to load theory "Applicative_Lifting.Applicative_Examples" (unresolved "Applicative_Lifting.Applicative_Environment_Algebra", "Applicative_Lifting.Stream_Algebra", "Applicative_Lifting.Tree_Relabelling")
*** ML error (line 968 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Applicative_Lifting/applicative.ML"):
*** Value or constructor (auto_fixes) has not been declared in structure Variable
*** At command "ML_file" (line 48 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Applicative_Lifting/Applicative.thy")

==========
Arith_Prog_Rel_Primes
Loading theory "Arith_Prog_Rel_Primes.Arith_Prog_Rel_Primes"
### theory "Arith_Prog_Rel_Primes.Arith_Prog_Rel_Primes"
### 0.069s elapsed time, 0.212s cpu time, 0.000s GC time
*** Undefined fact: "linordered_field_class.sign_simps" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy")
*** At command "using" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy")
*** At command "using" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy")

==========
Bernoulli
Loading theory "HOL-Library.Stirling" (required by "Bernoulli.Bernoulli_FPS")
Loading theory "Bernoulli.Bernoulli"
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
### theory "Bernoulli.Bernoulli"
### 0.224s elapsed time, 1.151s cpu time, 0.033s GC time
Loading theory "Bernoulli.Periodic_Bernpoly"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
consts
  stirling_row_aux ::
    "'a \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list"
### theory "HOL-Library.Stirling"
### 0.301s elapsed time, 1.747s cpu time, 0.071s GC time
Loading theory "Bernoulli.Bernoulli_FPS"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### theory "Bernoulli.Periodic_Bernpoly"
### 0.206s elapsed time, 1.530s cpu time, 0.072s GC time
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "Bernoulli.Bernoulli_FPS"
### 0.869s elapsed time, 4.199s cpu time, 0.220s GC time
Loading theory "Bernoulli.Bernoulli_Zeta"
### theory "Bernoulli.Bernoulli_Zeta"
### 0.378s elapsed time, 2.340s cpu time, 0.128s GC time
*** Undefined fact: "residue_simple_pole_deriv" (line 28 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** At command "by" (line 28 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
### Rule already declared as introduction (intro)
### (\<lambda>_. ?c) has_fps_expansion fps_const ?c
### Rule already declared as introduction (intro)
### (\<lambda>_. 0::?'a) has_fps_expansion 0
### Rule already declared as introduction (intro)
### (\<lambda>_. 1::?'a) has_fps_expansion 1
### Rule already declared as introduction (intro)
### (\<lambda>_. numeral ?n) has_fps_expansion numeral ?n
*** Undefined fact: "Residue_theorem" (line 187 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** At command "proof" (line 187 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** Undefined fact: "Residue_theorem" (line 187 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** At command "proof" (line 187 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** Undefined fact: "residue_simple_pole_deriv" (line 28 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** At command "by" (line 28 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy")
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")

==========
Budan_Fourier
Loading theory "Sturm_Tarski.PolyMisc" (required by "Budan_Fourier.Budan_Fourier" via "Budan_Fourier.BF_Misc" via "Sturm_Tarski.Sturm_Tarski")
### theory "Sturm_Tarski.PolyMisc"
### 0.060s elapsed time, 0.155s cpu time, 0.000s GC time
*** Failed to load theory "Sturm_Tarski.Sturm_Tarski" (unresolved "Sturm_Tarski.PolyMisc")
*** Failed to load theory "Budan_Fourier.BF_Misc" (unresolved "Sturm_Tarski.Sturm_Tarski")
*** Failed to load theory "Budan_Fourier.Sturm_Multiple_Roots" (unresolved "Budan_Fourier.BF_Misc")
*** Failed to load theory "Budan_Fourier.Budan_Fourier" (unresolved "Budan_Fourier.BF_Misc")
*** Failed to load theory "Budan_Fourier.Descartes_Roots_Test" (unresolved "Budan_Fourier.Budan_Fourier")
*** Type unification failed: Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  gcd :: ??'a \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Sturm_Tarski/PolyMisc.thy")

==========
Buffons_Needle
Loading theory "Buffons_Needle.Buffons_Needle"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Buffons_Needle.Buffons_Needle"
### 0.254s elapsed time, 1.305s cpu time, 0.077s GC time
*** Failed to apply initial proof method (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Buffons_Needle/Buffons_Needle.thy"):
*** goal (1 subgoal):
***  1. integral {0..pi} (\<lambda>x. min (d / 2) (sin x * l / 2)) =
***     integral {0..pi / 2} (\<lambda>x. min (d / 2) (sin x * l / 2)) +
***     integral {pi / 2..pi} (\<lambda>x. min (d / 2) (sin x * l / 2))
*** At command "by" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Buffons_Needle/Buffons_Needle.thy")
### Rule already declared as introduction (intro)
### (\<And>x. x \<in> space ?M \<Longrightarrow> ?P x) \<Longrightarrow>
### almost_everywhere ?M ?P
### Rule already declared as introduction (intro)
### (\<And>x. x \<in> space ?M \<Longrightarrow> ?P x) \<Longrightarrow>
### almost_everywhere ?M ?P
*** Failed to apply initial proof method (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Buffons_Needle/Buffons_Needle.thy"):
*** goal (1 subgoal):
***  1. integral {0..pi} (\<lambda>x. min (d / 2) (sin x * l / 2)) =
***     integral {0..pi / 2} (\<lambda>x. min (d / 2) (sin x * l / 2)) +
***     integral {pi / 2..pi} (\<lambda>x. min (d / 2) (sin x * l / 2))
*** At command "by" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Buffons_Needle/Buffons_Needle.thy")

==========
Cartan_FP
Loading theory "Cartan_FP.Cartan"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) holomorphic_on ?s1 \<equiv> True
*** Failed to finish proof (line 147 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>deriv f z = 1; i \<le> n\<rbrakk>
***     \<Longrightarrow> (deriv ^^ i) (\<lambda>a. a) z = (deriv ^^ i) f z
*** At command "by" (line 147 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "higher_deriv_id" (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "using" (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 52 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. 0 < n \<Longrightarrow> (deriv ^^ n) (\<lambda>w. y) z = 0
*** At command "by" (line 52 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
### theory "Cartan_FP.Cartan"
### 0.149s elapsed time, 0.577s cpu time, 0.020s GC time
### Ignoring duplicate rewrite rule:
### (*) ?c1 holomorphic_on ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) holomorphic_on ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) holomorphic_on ?s1 \<equiv> True
*** Failed to finish proof (line 186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>open s; z \<in> s; \<And>m. f ^^ m holomorphic_on s;
***      f holomorphic_on s; \<And>m. (f ^^ m) ` s \<subseteq> s\<rbrakk>
***     \<Longrightarrow> deriv f holomorphic_on s
*** At command "by" (line 186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "holomorphic_deriv" (line 95 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "by" (line 95 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) holomorphic_on ?s1 \<equiv> True
*** Undefined fact: "holomorphic_higher_deriv" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "by" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>Suc 0 < n; (deriv ^^ n) f z = 0\<rbrakk>
***     \<Longrightarrow> (deriv ^^ n) id z = 0
*** At command "by" (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "complex_derivative_chain" (line 463 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "apply" (line 463 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "complex_derivative_chain" (line 463 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "apply" (line 463 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>Suc 0 < n; (deriv ^^ n) f z = 0\<rbrakk>
***     \<Longrightarrow> (deriv ^^ n) id z = 0
*** At command "by" (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "holomorphic_higher_deriv" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "by" (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "holomorphic_deriv" (line 95 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "by" (line 95 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>open s; z \<in> s; \<And>m. f ^^ m holomorphic_on s;
***      f holomorphic_on s; \<And>m. (f ^^ m) ` s \<subseteq> s\<rbrakk>
***     \<Longrightarrow> deriv f holomorphic_on s
*** At command "by" (line 186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 52 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. 0 < n \<Longrightarrow> (deriv ^^ n) (\<lambda>w. y) z = 0
*** At command "by" (line 52 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Undefined fact: "higher_deriv_id" (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** At command "using" (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")
*** Failed to finish proof (line 147 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>deriv f z = 1; i \<le> n\<rbrakk>
***     \<Longrightarrow> (deriv ^^ i) (\<lambda>a. a) z = (deriv ^^ i) f z
*** At command "by" (line 147 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Cartan_FP/Cartan.thy")

==========
Catalan_Numbers
Loading theory "HOL-Library.Function_Algebras" (required by "Catalan_Numbers.Catalan_Numbers" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
Loading theory "HOL-Library.Landau_Symbols" (required by "Catalan_Numbers.Catalan_Numbers")
Loading theory "Catalan_Numbers.Catalan_Auxiliary_Integral" (required by "Catalan_Numbers.Catalan_Numbers")
Loading theory "Landau_Symbols.Group_Sort" (required by "Catalan_Numbers.Catalan_Numbers" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
locale groupsort
  fixes f :: "'a \<Rightarrow> 'b"
    and merge :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and g :: "'a list \<Rightarrow> 'c"
  assumes "groupsort f merge g"
### theory "Catalan_Numbers.Catalan_Auxiliary_Integral"
### 0.057s elapsed time, 0.327s cpu time, 0.000s GC time
### theory "HOL-Library.Function_Algebras"
### 0.113s elapsed time, 0.718s cpu time, 0.072s GC time
*** Failed to apply initial proof method (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy"):
*** using this:
***   (F \<longlongrightarrow> - pi) (at_right 0)
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          if x = 4 then pi
***          else if x = 0 then - pi else F x) \<longlongrightarrow>
***      - pi)
***      (at_right 0)
*** At command "by" (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy")
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Ignoring duplicate rewrite rule:
### mset (filter ?P1 ?xs1) \<equiv> filter_mset ?P1 (mset ?xs1)
Found termination order: "length <*mlex*> {}"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
### theory "Landau_Symbols.Group_Sort"
### 1.123s elapsed time, 6.503s cpu time, 0.457s GC time
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
bundle asymp_equiv_notation
### theory "HOL-Library.Landau_Symbols"
### 1.600s elapsed time, 9.171s cpu time, 0.588s GC time
Loading theory "Landau_Symbols.Landau_Real_Products" (required by "Catalan_Numbers.Catalan_Numbers" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs")
consts
  bigtheta_pow ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> 'b) set
                   \<Rightarrow> nat
                                 \<Rightarrow> ('a \<Rightarrow> 'b) set"
locale landau_function_family
  fixes F :: "'a filter"
    and H :: "('a \<Rightarrow> real) set"
  assumes "landau_function_family F H"
locale landau_function_family_pair
  fixes F :: "'a filter"
    and G :: "('a \<Rightarrow> real) set"
    and H :: "('a \<Rightarrow> real) set"
    and g :: "'a \<Rightarrow> real"
  assumes "landau_function_family_pair F G H g"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
consts
  landau_dominating_chain' ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> real) list \<Rightarrow> bool"
consts
  nonneg_list :: "'a list \<Rightarrow> bool"
consts
  pos_list :: "'a list \<Rightarrow> bool"
locale landau_function_family_chain
  fixes F :: "'b filter"
    and gs :: "'a list"
    and get_param :: "'a \<Rightarrow> real"
    and get_fun :: "'a \<Rightarrow> 'b \<Rightarrow> real"
  assumes "landau_function_family_chain F gs get_fun"
instantiation
  primfun :: linorder
  less_eq_primfun == less_eq ::
    primfun \<Rightarrow> primfun \<Rightarrow> bool
  less_primfun == less :: primfun \<Rightarrow> primfun \<Rightarrow> bool
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### pos_primfun_list [] \<equiv> False
### Ignoring duplicate rewrite rule:
### pos_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> pos_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> nonneg_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### iszero_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### iszero_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### ?x1 = (0::?'b1) \<and> iszero_primfun_list ?xs1
### theory "Landau_Symbols.Landau_Real_Products"
### 1.850s elapsed time, 5.718s cpu time, 0.994s GC time
Loading theory "Landau_Symbols.Landau_Simprocs" (required by "Catalan_Numbers.Catalan_Numbers" via "Landau_Symbols.Landau_More")
### ML warning (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (dest_bigtheta) has not been referenced.
### ML warning (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (x_name2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest1) has not been referenced.
### ML warning (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 373 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
signature LANDAU =
  sig
    val cancel_factor_conv: Proof.context -> cterm -> thm
    val cancel_factor_simproc: Proof.context -> cterm -> thm option
    val dest_landau: term -> term * term * term
    val landau_const_names: string list
    val landau_sum_limit: int Config.T
    val lift_landau_conv: conv -> conv
    val lift_landau_simproc:
       (Proof.context -> cterm -> thm option) ->
         Proof.context -> cterm -> thm option
    val simplify_landau_product_conv: Proof.context -> conv
    val simplify_landau_product_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_real_prod_prop_conv: Proof.context -> conv
    val simplify_landau_real_prod_prop_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_sum_conv: Proof.context -> conv
    val simplify_landau_sum_simproc: Proof.context -> cterm -> thm option
  end
structure Landau: LANDAU
### theory "Landau_Symbols.Landau_Simprocs"
### 0.472s elapsed time, 1.636s cpu time, 0.914s GC time
Loading theory "Landau_Symbols.Landau_More" (required by "Catalan_Numbers.Catalan_Numbers")
val it =
   "(\<lambda>x.
        5 * (ln (ln x))\<^sup>2 / (2 * x) powr (15 / 10) * inverse 2)
    \<in> \<omega>(\<lambda>x.
                      3 * ln x * ln x / x * ln (ln (ln (ln x)))) \<equiv>
    3 = 0 \<or>
    5 * inverse (2 powr (15 / 10)) * inverse 2 \<noteq> 0 \<and>
    pos_primfun_list
     (group_primfuns
       [(LnChain 1, - 1), (LnChain 1, - 1), (LnChain 0, 1),
        (LnChain 4, - 1), (LnChain 2, real 2), (LnChain 0, - (15 / 10))])":
   thm
### theory "Landau_Symbols.Landau_More"
### 0.142s elapsed time, 0.790s cpu time, 0.027s GC time
Loading theory "Catalan_Numbers.Catalan_Numbers"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate rewrite rule:
### ?f1 \<sim>[?F1] ?f1 \<equiv> True
Found termination order: "size <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### ?f1 \<sim>[?F1] ?f1 \<equiv> True
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
consts
  count_nodes :: "tree \<Rightarrow> nat"
### Rule already declared as introduction (intro)
### finite ?F \<Longrightarrow> finite (?h ` ?F)
### Ignoring duplicate rewrite rule:
### catalan (Suc ?n1) \<equiv> \<Sum>i\<le>?n1. catalan i * catalan (?n1 - i)
### Rewrite rule not in simpset:
### Wellfounded.accp catalan_aux_rel (?n1, ?k1, ?acc1) \<Longrightarrow>
### catalan_aux ?n1 ?k1 ?acc1 \<equiv>
### if ?n1 \<le> ?k1 then ?acc1
### else catalan_aux ?n1 (Suc ?k1) (?acc1 * (2 * (2 * ?k1 + 1)) div (?k1 + 2))
### theory "Catalan_Numbers.Catalan_Numbers"
### 0.850s elapsed time, 4.264s cpu time, 0.250s GC time
*** Failed to apply initial proof method (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy"):
*** using this:
***   (F \<longlongrightarrow> - pi) (at_right 0)
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          if x = 4 then pi
***          else if x = 0 then - pi else F x) \<longlongrightarrow>
***      - pi)
***      (at_right 0)
*** At command "by" (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy")

==========
Category2
Loading theory "HOL-ZF.LProd" (required by "Category2.MonadicEquationalTheory" via "Category2.Universe" via "HOL-ZF.MainZF")
Loading theory "Category2.Category" (required by "Category2.MonadicEquationalTheory")
Loading theory "HOL-ZF.HOLZF" (required by "Category2.MonadicEquationalTheory" via "Category2.Universe" via "HOL-ZF.MainZF" via "HOL-ZF.Zet")
Proofs for inductive predicate(s) "lprodp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Elem ?y (Power ?x) = (\<forall>x. Elem x ?y \<longrightarrow> Elem x ?x)
### Ignoring duplicate rewrite rule:
### trans (?r1\<^sup>+) \<equiv> True
### theory "HOL-ZF.LProd"
### 0.240s elapsed time, 1.339s cpu time, 0.049s GC time
consts
  nat2Nat :: "nat \<Rightarrow> ZF"
consts
  NatInterval :: "nat \<Rightarrow> nat \<Rightarrow> ZF"
locale ExtCategory
  fixes C :: "('o, 'm, 'a) Category_scheme"  (structure)
  assumes "ExtCategory C"
locale Category
  fixes C :: "('a, 'b, 'c) Category_scheme"  (structure)
  assumes "Category C"
consts
  Ext_ZF_n ::
    "(ZF \<times> ZF) set
     \<Rightarrow> ZF \<Rightarrow> nat \<Rightarrow> ZF"
"P"
  :: "ZF \<Rightarrow> bool"
"Sep"
  :: "ZF \<Rightarrow> (ZF \<Rightarrow> bool) \<Rightarrow> ZF"
### theory "HOL-ZF.HOLZF"
### 0.461s elapsed time, 2.534s cpu time, 0.182s GC time
Loading theory "HOL-ZF.Zet" (required by "Category2.MonadicEquationalTheory" via "Category2.Universe" via "HOL-ZF.MainZF")
### theory "Category2.Category"
### 0.546s elapsed time, 3.177s cpu time, 0.226s GC time
Loading theory "Category2.Functors" (required by "Category2.Yoneda" via "Category2.NatTrans")
### theory "HOL-ZF.Zet"
### 0.123s elapsed time, 0.889s cpu time, 0.044s GC time
Loading theory "HOL-ZF.MainZF" (required by "Category2.MonadicEquationalTheory" via "Category2.Universe")
### theory "HOL-ZF.MainZF"
### 0.133s elapsed time, 0.885s cpu time, 0.048s GC time
Loading theory "Category2.Universe" (required by "Category2.MonadicEquationalTheory")
locale Universe
  fixes U :: "ZF"  (structure)
  assumes "Universe U"
### theory "Category2.Universe"
### 0.123s elapsed time, 0.859s cpu time, 0.079s GC time
Loading theory "Category2.MonadicEquationalTheory"
locale PreFunctor
  fixes
    F :: "('o1, 'o2, 'm1, 'm2, 'a1, 'a2, 'a) Functor_scheme"  (structure)
  assumes "PreFunctor F"
locale FunctorM
  fixes F :: "('a, 'b, 'c, 'd, 'e, 'f, 'g) Functor_scheme"  (structure)
  assumes "FunctorM F"
locale FunctorExt
  fixes
    F :: "('o1, 'o2, 'm1, 'm2, 'a1, 'a2, 'a) Functor_scheme"  (structure)
  assumes "FunctorExt F"
locale Functor
  fixes F :: "('a, 'b, 'c, 'd, 'e, 'f, 'g) Functor_scheme"  (structure)
  assumes "Functor F"
*** Failed to apply initial proof method (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy"):
*** goal (1 subgoal):
***  1. FId' C ## id\<^bsub>CatDom (FId' C)\<^esub> X =
***     id\<^bsub>CatCod (FId' C)\<^esub> X
*** At command "by" (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy")
### theory "Category2.Functors"
### 0.489s elapsed time, 2.795s cpu time, 0.182s GC time
locale Signature
  fixes S :: "('t, 'f) Signature"  (structure)
  assumes "Signature S"
Proofs for inductive predicate(s) "WellDefined"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale Interpretation
  fixes I :: "('t, 'f, 'o, 'm) Interpretation"  (structure)
  assumes "Interpretation I"
Proofs for inductive predicate(s) "Interp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale Axioms
  fixes Ax :: "('t, 'f) Axioms"  (structure)
  assumes "Axioms Ax"
consts
  Subst ::
    "('t, 'f) Expression
     \<Rightarrow> ('t, 'f) Expression \<Rightarrow> ('t, 'f) Expression"
Proofs for inductive predicate(s) "Theoryp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale Model
  fixes I :: "('t, 'f, 'o, 'm) Interpretation"  (structure)
    and Ax :: "('t, 'f) Axioms"
  assumes "Model I Ax"
### Ambiguous input (line 307 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp" ("_position" f)
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("\<^const>Pure.eq"
###             ("\<^const>MonadicEquationalTheory.Subst" ("_position" e1)
###               ("_position" d))
###             ("_position" f))
###           ("\<^const>MonadicEquationalTheory.Subst" ("_position" e2)
###             ("_position" d))))
###       ("_position" C))
###     ("_position" Theory)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###         ("\<^const>Pure.eq"
###           ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###             ("_position" f)
###             ("\<^const>MonadicEquationalTheory.Subst" ("_position" e1)
###               ("_position" d)))
###           ("_position" f))
###         ("\<^const>MonadicEquationalTheory.Subst" ("_position" e2)
###           ("_position" d)))
###       ("_position" C))
###     ("_position" Theory)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("\<^const>MonadicEquationalTheory.Language.Equation" ("_position" A)
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp" ("_position" f)
###         ("\<^const>MonadicEquationalTheory.Subst" ("_position" e1)
###           ("_position" d)))
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp" ("_position" f)
###         ("\<^const>MonadicEquationalTheory.Subst" ("_position" e2)
###           ("_position" d)))
###       ("_position" C))
###     ("_position" Theory)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 334 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>MonadicEquationalTheory.Interp_indexed"
###       ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###         ("_position" e) ("_position" B))
###       ("_indexdefault") ("_position" IMor))
###     ("_position" g)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Interp_indexed"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###       ("_position" e) ("_position" B))
###     ("_indexdefault") ("_applC" ("_position" IMor) ("_position" g))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 335 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>MonadicEquationalTheory.Interp_indexed"
###       ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###         ("_position" e) ("_position" C))
###       ("_indexdefault") ("_position" IMor))
###     ("\<^const>Category.Category.Comp_indexed" ("_position" g)
###       ("_index"
###         ("\<^const>MonadicEquationalTheory.Interpretation.ICategory_indexed"
###           ("_indexdefault")))
###       ("_position" h))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Interp_indexed"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###       ("_position" e) ("_position" C))
###     ("_indexdefault")
###     ("_applC" ("_position" IMor)
###       ("\<^const>Category.Category.Comp_indexed" ("_position" g)
###         ("_index"
###           ("\<^const>MonadicEquationalTheory.Interpretation.ICategory_indexed"
###             ("_indexdefault")))
###         ("_position" h)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 348 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" C'))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("\<^const>MonadicEquationalTheory.Interp_indexed"
###           ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" B)
###             ("_position" d) ("_position" C'))
###           ("_indexdefault") ("_position" IMor))
###         ("_position" h)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>MonadicEquationalTheory.Interp_indexed"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("\<^const>MonadicEquationalTheory.Subst" ("_position" e)
###             ("_position" d))
###           ("_position" C'))
###         ("_indexdefault")
###         ("_applC" ("_position" IMor)
###           ("\<^const>Category.Category.Comp_indexed" ("_position" g)
###             ("_index"
###               ("\<^const>MonadicEquationalTheory.Interpretation.ICategory_indexed"
###                 ("_indexdefault")))
###             ("_position" h)))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" C'))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>MonadicEquationalTheory.Interp_indexed"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" B)
###           ("_position" d) ("_position" C'))
###         ("_indexdefault") ("_applC" ("_position" IMor) ("_position" h))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>MonadicEquationalTheory.Interp_indexed"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("\<^const>MonadicEquationalTheory.Subst" ("_position" e)
###             ("_position" d))
###           ("_position" C'))
###         ("_indexdefault")
###         ("_applC" ("_position" IMor)
###           ("\<^const>Category.Category.Comp_indexed" ("_position" g)
###             ("_index"
###               ("\<^const>MonadicEquationalTheory.Interpretation.ICategory_indexed"
###                 ("_indexdefault")))
###             ("_position" h)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>MonadicEquationalTheory.Interp_indexed"
###       ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###         ("_position" e) ("_position" B))
###       ("_indexdefault") ("_position" IMor))
###     ("_position" g)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Interp_indexed"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###       ("_position" e) ("_position" B))
###     ("_indexdefault") ("_applC" ("_position" IMor) ("_position" g))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 349 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>MonadicEquationalTheory.Interp_indexed"
###       ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" B)
###         ("_position" d) ("_position" C'))
###       ("_indexdefault") ("_position" IMor))
###     ("_position" h)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Interp_indexed"
###     ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" B)
###       ("_position" d) ("_position" C'))
###     ("_indexdefault") ("_applC" ("_position" IMor) ("_position" h))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale ZFAxioms
  fixes Ax :: "(ZF, ZF) Axioms"  (structure)
  assumes "ZFAxioms Ax"
consts
  Expr2ZF :: "(ZF, ZF) Expression \<Rightarrow> ZF"
consts
  WellFormedToSet ::
    "(ZF, ZF) Signature
     \<Rightarrow> nat \<Rightarrow> (ZF, ZF) Expression set"
### Ambiguous input (line 561 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("\<^const>MonadicEquationalTheory.Language.Equation" ("_position" A)
###       ("_position" x) ("_position" e)
###       ("\<^const>Set.member" ("_position" B) ("_position" Axioms.Theory)))
###     ("_position" T)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Language.Equation" ("_position" A)
###     ("_position" x) ("_position" e)
###     ("\<^const>Set.member" ("_position" B)
###       ("_applC" ("_position" Axioms.Theory) ("_position" T)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("\<^const>MonadicEquationalTheory.Language.Equation" ("_position" A)
###       ("_position" x) ("_position" e) ("_position" B))
###     ("_applC" ("_position" Axioms.Theory) ("_position" T))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 547 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 11 parse trees (10 displayed):
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###       ("_applC"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n)
###                 ("\<^const>Set.member" ("_position" e)
###                   ("_position" WellFormedToSet))))))
###         ("_cargs" ("_position" S) ("_position" n))))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n)
###                 ("\<^const>Set.member" ("_position" e)
###                   ("_position" WellFormedToSet)))))))
###       ("_cargs" ("_position" S) ("_position" n)))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>Set.member"
###           ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###             ("_position" e)
###             ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.Ex_binder" ("_position" n)
###                   ("_position" e)))))
###           ("_position" WellFormedToSet)))
###       ("_cargs" ("_position" S) ("_position" n)))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###       ("\<^const>Set.member"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n) ("_position" e)))))
###         ("_applC" ("_position" WellFormedToSet)
###           ("_cargs" ("_position" S) ("_position" n)))))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n) ("_position" e))))))
###       ("_applC" ("_position" WellFormedToSet)
###         ("_cargs" ("_position" S) ("_position" n))))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###       ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###         ("_position" e)
###         ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.Ex_binder" ("_position" n)
###               ("\<^const>Set.member" ("_position" e)
###                 ("_applC" ("_position" WellFormedToSet)
###                   ("_cargs" ("_position" S) ("_position" n)))))))))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e) ("_position" B'))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" n)
###         ("\<^const>Set.member" ("_position" e)
###           ("_applC" ("_position" WellFormedToSet)
###             ("_cargs" ("_position" S) ("_position" n))))))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###       ("_applC"
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n)
###                 ("\<^const>Set.member" ("_position" e)
###                   ("_applC" ("_position" WellFormedToSet)
###                     ("_position" S)))))))
###         ("_position" n)))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###           ("_position" e)
###           ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.Ex_binder" ("_position" n)
###                 ("\<^const>Set.member" ("_position" e)
###                   ("_applC" ("_position" WellFormedToSet)
###                     ("_position" S))))))))
###       ("_position" n))))
### ("\<^const>Pure.all_binder" ("_position" B')
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("\<^const>MonadicEquationalTheory.WellDefined" ("_position" S)
###         ("\<^const>Set.member"
###           ("\<^const>MonadicEquationalTheory.Language.Term" ("_position" A)
###             ("_position" e)
###             ("\<^const>Pure.imp" ("\<^const>HOL.Trueprop" ("_position" B'))
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.Ex_binder" ("_position" n)
###                   ("_position" e)))))
###           ("_applC" ("_position" WellFormedToSet) ("_position" S))))
###       ("_position" n))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 526 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 19 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###             ("\<^const>HOL.eq" ("_position" x) ("_position" f))
###             ("\<^const>HOL.conj" ("_position" e)
###               ("\<^const>Set.member" ("_position" f)
###                 ("_applC" ("_position" BaseFunctions)
###                   ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                     ("_index" ("_position" T)))))))
###           ("\<^const>Set.member" ("_position" e)
###             ("_applC" ("_position" WellFormedToSet)
###               ("_cargs"
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))
###                 ("_position" n))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" x)
###             ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###               ("_position" f)
###               ("\<^const>HOL.conj" ("_position" e)
###                 ("\<^const>Set.member" ("_position" f)
###                   ("_applC" ("_position" BaseFunctions)
###                     ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                       ("_index" ("_position" T))))))))
###           ("\<^const>Set.member" ("_position" e)
###             ("_applC" ("_position" WellFormedToSet)
###               ("_cargs"
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))
###                 ("_position" n))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.conj"
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" f) ("_position" e))
###             ("\<^const>HOL.eq" ("_position" x) ("_position" f)))
###           ("\<^const>HOL.conj" ("_position" e)
###             ("\<^const>Set.member" ("_position" f)
###               ("_applC" ("_position" BaseFunctions)
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))))))
###         ("\<^const>Set.member" ("_position" e)
###           ("_applC" ("_position" WellFormedToSet)
###             ("_cargs"
###               ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                 ("_index" ("_position" T)))
###               ("_position" n)))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###             ("\<^const>HOL.eq" ("_position" x) ("_position" f))
###             ("_position" e))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" f)
###               ("_applC" ("_position" BaseFunctions)
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))))
###             ("\<^const>Set.member" ("_position" e)
###               ("_applC" ("_position" WellFormedToSet)
###                 ("_cargs"
###                   ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                     ("_index" ("_position" T)))
###                   ("_position" n)))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" x)
###             ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###               ("_position" f) ("_position" e)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" f)
###               ("_applC" ("_position" BaseFunctions)
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))))
###             ("\<^const>Set.member" ("_position" e)
###               ("_applC" ("_position" WellFormedToSet)
###                 ("_cargs"
###                   ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                     ("_index" ("_position" T)))
###                   ("_position" n)))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("\<^const>HOL.eq" ("_position" x) ("_position" f))
###           ("\<^const>HOL.conj" ("_position" e)
###             ("\<^const>HOL.conj"
###               ("\<^const>Set.member" ("_position" f)
###                 ("_applC" ("_position" BaseFunctions)
###                   ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                     ("_index" ("_position" T)))))
###               ("\<^const>Set.member" ("_position" e)
###                 ("_applC" ("_position" WellFormedToSet)
###                   ("_cargs"
###                     ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                       ("_index" ("_position" T)))
###                     ("_position" n))))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.eq" ("_position" x)
###           ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###             ("_position" f)
###             ("\<^const>HOL.conj" ("_position" e)
###               ("\<^const>HOL.conj"
###                 ("\<^const>Set.member" ("_position" f)
###                   ("_applC" ("_position" BaseFunctions)
###                     ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                       ("_index" ("_position" T)))))
###                 ("\<^const>Set.member" ("_position" e)
###                   ("_applC" ("_position" WellFormedToSet)
###                     ("_cargs"
###                       ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                         ("_index" ("_position" T)))
###                       ("_position" n)))))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###         ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###           ("\<^const>HOL.eq" ("_position" x) ("_position" f)))
###         ("\<^const>HOL.conj" ("_position" e)
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" f)
###               ("_applC" ("_position" BaseFunctions)
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))))
###             ("\<^const>Set.member" ("_position" e)
###               ("_applC" ("_position" WellFormedToSet)
###                 ("_cargs"
###                   ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                     ("_index" ("_position" T)))
###                   ("_position" n)))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.conj"
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" f) ("_position" e))
###             ("\<^const>HOL.eq" ("_position" x) ("_position" f)))
###           ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" f)
###             ("_applC" ("_position" BaseFunctions)
###               ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                 ("_index" ("_position" T)))))
###           ("\<^const>Set.member" ("_position" e)
###             ("_applC" ("_position" WellFormedToSet)
###               ("_cargs"
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))
###                 ("_position" n))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" x)
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" f) ("_position" e))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member"
###             ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###               ("\<^const>HOL.eq" ("_position" x) ("_position" f))
###               ("\<^const>HOL.conj" ("_position" e) ("_position" f)))
###             ("_applC" ("_position" BaseFunctions)
###               ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                 ("_index" ("_position" T)))))
###           ("\<^const>Set.member" ("_position" e)
###             ("_applC" ("_position" WellFormedToSet)
###               ("_cargs"
###                 ("\<^const>MonadicEquationalTheory.Axioms.aSignature_indexed"
###                   ("_index" ("_position" T)))
###                 ("_position" n))))))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" ZFTriple)
###           ("_cargs"
###             ("_applC" ("_position" SucNat)
###               ("_applC" ("_position" ZFTFst)
###                 ("_applC" ("_position" Expr2ZF) ("_position" e))))
###             ("_cargs" ("_applC" ("_position" SucNat) ("_position" Empty))
###               ("_applC" ("_position" Opair)
###                 ("_cargs" ("_position" f)
###                   ("_applC" ("_position" Expr2ZF) ("_position" e)))))))
###         ("_applC" ("_position" Expr2ZF) ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Category2.MonadicEquationalTheory"
### 3.326s elapsed time, 8.079s cpu time, 1.916s GC time
### Ambiguous input (line 864 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/MonadicEquationalTheory.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###     ("\<^const>HOL.eq"
###       ("\<^const>MonadicEquationalTheory.Subst" ("_position" e)
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("_position" f)
###           ("\<^const>MonadicEquationalTheory.Expression.ExprVar")))
###       ("_position" f))
###     ("_position" e)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MonadicEquationalTheory.Subst" ("_position" e)
###       ("\<^const>MonadicEquationalTheory.Expression.ExprApp" ("_position" f)
###         ("\<^const>MonadicEquationalTheory.Expression.ExprVar")))
###     ("\<^const>MonadicEquationalTheory.Expression.ExprApp" ("_position" f)
###       ("_position" e))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MonadicEquationalTheory.Subst" ("_position" e)
###     ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###       ("\<^const>HOL.eq"
###         ("\<^const>MonadicEquationalTheory.Expression.ExprApp"
###           ("_position" f)
###           ("\<^const>MonadicEquationalTheory.Expression.ExprVar"))
###         ("_position" f))
###       ("_position" e))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
*** Failed to load theory "Category2.NatTrans" (unresolved "Category2.Functors")
*** Failed to load theory "Category2.SetCat" (unresolved "Category2.Functors")
*** Failed to load theory "Category2.Yoneda" (unresolved "Category2.NatTrans", "Category2.SetCat")
*** Ambiguous input (line 275 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy") produces 2 parse trees:
*** ("\<^const>Pure.imp"
***   ("\<^const>HOL.Trueprop"
***     ("_applC" ("_position" Category) ("_position" C)))
***   ("\<^const>HOL.Trueprop"
***     ("_applC" ("_position" Functor)
***       ("\<^const>Functors.IdentityFunctor'" ("_position" C)))))
*** ("\<^const>Pure.imp"
***   ("\<^const>HOL.Trueprop"
***     ("_applC" ("_position" Category) ("_position" C)))
***   ("\<^const>HOL.Trueprop"
***     ("_applC" ("_position" Functor)
***       ("\<^const>Functors.IdentityFunctor" ("_position" C)))))
*** Ambiguous input
*** 2 terms are type correct:
*** (((Category::<position>) (C::<position>)) \<Longrightarrow>
***  ((Functor::<position>) FId(C::<position>)))
*** (((Category::<position>) (C::<position>)) \<Longrightarrow>
***  ((Functor::<position>) FId (C::<position>)))
*** Failed to parse prop
*** At command "lemma" (line 275 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy")
*** Failed to apply initial proof method (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy"):
*** goal (1 subgoal):
***  1. FId' C ## id\<^bsub>CatDom (FId' C)\<^esub> X =
***     id\<^bsub>CatCod (FId' C)\<^esub> X
*** At command "by" (line 255 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category2/Functors.thy")

==========
Category3
Loading theory "Category3.Category" (required by "Category3.Limit" via "Category3.FreeCategory")
locale partial_magma
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "partial_magma (\<cdot>)"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale classical_category
  fixes Obj :: "'obj \<Rightarrow> bool"
    and Arr :: "'arr \<Rightarrow> bool"
    and Dom :: "'arr \<Rightarrow> 'obj"
    and Cod :: "'arr \<Rightarrow> 'obj"
    and Id :: "'obj \<Rightarrow> 'arr"
    and Comp :: "'arr \<Rightarrow> 'arr \<Rightarrow> 'arr"
  assumes "classical_category Obj Arr Dom Cod Id Comp"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Category3.Category"
### 0.446s elapsed time, 2.132s cpu time, 0.126s GC time
Loading theory "Category3.AbstractedCategory" (required by "Category3.Limit" via "Category3.FreeCategory")
locale abstracted_category
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and A :: "'c \<Rightarrow> 'a"
    and R :: "'a \<Rightarrow> 'c"
    and S :: "'c set"
  assumes "abstracted_category (\<cdot>\<^sub>C) A R S"
Loading theory "Category3.DiscreteCategory" (required by "Category3.Limit")
Loading theory "Category3.DualCategory" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda")
Loading theory "Category3.EpiMonoIso" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "Category3.Functor" via "Category3.InitialTerminal")
locale discrete_category
  fixes Obj :: "'a set"
    and Null :: "'a"
  assumes "discrete_category Obj Null"
locale dual_category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "dual_category (\<cdot>)"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale abstracted_category
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and A :: "'c \<Rightarrow> 'a"
    and R :: "'a \<Rightarrow> 'c"
    and S :: "'c set"
  assumes "abstracted_category (\<cdot>\<^sub>C) A R S"
locale discrete_category
  fixes Obj :: "'a set"
    and Null :: "'a"
  assumes "discrete_category Obj Null"
### theory "Category3.DiscreteCategory"
### 0.088s elapsed time, 0.544s cpu time, 0.041s GC time
### theory "Category3.AbstractedCategory"
### 0.146s elapsed time, 0.743s cpu time, 0.041s GC time
Loading theory "Category3.FreeCategory" (required by "Category3.Limit")
locale dual_category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "dual_category (\<cdot>)"
### theory "Category3.DualCategory"
### 0.130s elapsed time, 0.718s cpu time, 0.041s GC time
locale graph
  fixes Obj :: "'obj set"
    and Arr :: "'arr set"
    and Dom :: "'arr \<Rightarrow> 'obj"
    and Cod :: "'arr \<Rightarrow> 'obj"
  assumes "graph Obj Arr Dom Cod"
locale free_category
  fixes Obj :: "'obj set"
    and Arr :: "'arr set"
    and D :: "'arr \<Rightarrow> 'obj"
    and C :: "'arr \<Rightarrow> 'obj"
  assumes "free_category Obj Arr D C"
### theory "Category3.EpiMonoIso"
### 0.185s elapsed time, 0.940s cpu time, 0.096s GC time
Loading theory "Category3.InitialTerminal" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory" via "Category3.Functor")
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
### theory "Category3.InitialTerminal"
### 0.048s elapsed time, 0.147s cpu time, 0.000s GC time
Loading theory "Category3.Functor" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat" via "Category3.SetCategory")
Loading theory "Category3.ProductCategory" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory" via "Category3.BinaryFunctor")
locale free_category
  fixes Obj :: "'obj set"
    and Arr :: "'arr set"
    and D :: "'arr \<Rightarrow> 'obj"
    and C :: "'arr \<Rightarrow> 'obj"
  assumes "free_category Obj Arr D C"
locale functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
  assumes "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale product_category
  fixes
    C1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>1\<close> 55)
    and
    C2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>2\<close> 55)
  assumes "product_category (\<cdot>\<^sub>1) (\<cdot>\<^sub>2)"
locale endofunctor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
    and F :: "'a \<Rightarrow> 'a"
  assumes "endofunctor (\<cdot>) F"
locale discrete_category
  fixes Obj :: "'obj set"
  assumes "discrete_category Obj"
locale faithful_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "faithful_functor A B F"
locale product_category
  fixes
    C1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>1\<close> 55)
    and
    C2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>2\<close> 55)
  assumes "product_category (\<cdot>\<^sub>1) (\<cdot>\<^sub>2)"
### theory "Category3.ProductCategory"
### 0.348s elapsed time, 2.702s cpu time, 0.164s GC time
locale full_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "full_functor A B F"
locale fully_faithful_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "fully_faithful_functor A B F"
locale empty_category
  assumes "empty_category"
locale quiver
  fixes Arr :: "'arr set"
  assumes "quiver Arr"
locale embedding_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "embedding_functor A B F"
locale embedding_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "embedding_functor A B F"
locale full_embedding_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and F :: "'a \<Rightarrow> 'b"
  assumes "full_embedding_functor A B F"
locale essentially_surjective_functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
  assumes
    "essentially_surjective_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale parallel_pair
  assumes "parallel_pair"
locale constant_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and b :: "'b"
  assumes "constant_functor A B b"
locale identity_functor
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "identity_functor C"
### theory "Category3.FreeCategory"
### 1.655s elapsed time, 10.922s cpu time, 0.991s GC time
locale composite_functor
  fixes A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'b \<Rightarrow> 'c"
  assumes "composite_functor A B C F G"
locale inverse_functors
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'b \<Rightarrow> 'a"
  assumes "inverse_functors (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G"
locale isomorphic_categories
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "isomorphic_categories (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale invertible_functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
  assumes "invertible_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale dual_functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
  assumes "dual_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
### theory "Category3.Functor"
### 2.729s elapsed time, 17.547s cpu time, 1.396s GC time
Loading theory "Category3.NaturalTransformation" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory" via "Category3.BinaryFunctor")
Loading theory "Category3.Subcategory"
Loading theory "Category3.SetCategory" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.SetCat")
locale subcategory
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and Arr :: "'a \<Rightarrow> bool"
  assumes "subcategory (\<cdot>\<^sub>C) Arr"
locale natural_transformation
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'a \<Rightarrow> 'b"
  assumes
    "natural_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale set_category_data
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
    and img :: "'s \<Rightarrow> 's"
  assumes "set_category_data (\<cdot>)"
locale transformation_by_components
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and t :: "'a \<Rightarrow> 'b"
  assumes
    "transformation_by_components (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G t"
locale set_category_given_img
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
    and img :: "'s \<Rightarrow> 's"
  assumes "set_category_given_img (\<cdot>) img"
locale constant_transformation
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and g :: "'b"
  assumes "constant_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) g"
locale constant_transformation
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and g :: "'b"
  assumes "constant_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) g"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale vertical_composite
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and H :: "'a \<Rightarrow> 'b"
    and \<sigma> :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'a \<Rightarrow> 'b"
  assumes
    "vertical_composite (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G H \<sigma>
      \<tau>"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale natural_isomorphism
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'a \<Rightarrow> 'b"
  assumes
    "natural_isomorphism (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale two_set_categories_bij_betw_Univ
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S' :: "'t \<Rightarrow> 't \<Rightarrow> 't"
      (infixr \<open>\<cdot>\<acute>\<close> 55)
    and \<phi> :: "'s \<Rightarrow> 't"
  assumes
    "two_set_categories_bij_betw_Univ (\<cdot>) (\<cdot>\<acute>) \<phi>"
locale full_subcategory
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and Ide :: "'a \<Rightarrow> bool"
  assumes "full_subcategory C Ide"
locale inverse_transformation
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'a \<Rightarrow> 'b"
  assumes
    "inverse_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale inverse_transformations
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'a \<Rightarrow> 'b"
    and \<tau>' :: "'a \<Rightarrow> 'b"
  assumes
    "inverse_transformations (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<tau>
      \<tau>'"
locale concrete_set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and U :: "'a set"
    and \<iota> :: "'a \<Rightarrow> 's"
  assumes "concrete_set_category (\<cdot>\<^sub>S) U \<iota>"
### theory "Category3.SetCategory"
### 1.949s elapsed time, 15.125s cpu time, 1.891s GC time
Loading theory "Category3.SetCat" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda")
locale setcat
locale full_subcategory
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and Ide :: "'a \<Rightarrow> bool"
  assumes "full_subcategory C Ide"
locale horizontal_composite
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and H :: "'b \<Rightarrow> 'c"
    and K :: "'b \<Rightarrow> 'c"
    and \<sigma> :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'b \<Rightarrow> 'c"
  assumes
    "horizontal_composite (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>C) F G H K \<sigma> \<tau>"
locale inclusion_functor
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and Arr :: "'a \<Rightarrow> bool"
  assumes "inclusion_functor C Arr"
locale horizontal_composite
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
    and G :: "'a \<Rightarrow> 'b"
    and H :: "'b \<Rightarrow> 'c"
    and K :: "'b \<Rightarrow> 'c"
    and \<sigma> :: "'a \<Rightarrow> 'b"
    and \<tau> :: "'b \<Rightarrow> 'c"
  assumes
    "horizontal_composite (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>C) F G H K \<sigma> \<tau>"
locale full_inclusion_functor
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and Ide :: "'a \<Rightarrow> bool"
  assumes "full_inclusion_functor C Ide"
locale full_inclusion_functor
  fixes C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and Ide :: "'a \<Rightarrow> bool"
  assumes "full_inclusion_functor C Ide"
### theory "Category3.Subcategory"
### 4.786s elapsed time, 35.633s cpu time, 3.238s GC time
### theory "Category3.SetCat"
### 3.084s elapsed time, 22.451s cpu time, 1.419s GC time
### theory "Category3.NaturalTransformation"
### 5.387s elapsed time, 39.983s cpu time, 4.363s GC time
Loading theory "Category3.BinaryFunctor" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda" via "Category3.FunctorCategory")
locale binary_functor
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
  assumes
    "binary_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale product_functor
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B1 :: "'b1 \<Rightarrow> 'b1 \<Rightarrow> 'b1"
      (infixr \<open>\<cdot>\<^sub>B\<^sub>1\<close> 55)
    and
    B2 :: "'b2 \<Rightarrow> 'b2 \<Rightarrow> 'b2"
      (infixr \<open>\<cdot>\<^sub>B\<^sub>2\<close> 55)
    and F1 :: "'a1 \<Rightarrow> 'b1"
    and F2 :: "'a2 \<Rightarrow> 'b2"
  assumes
    "product_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B\<^sub>1) (\<cdot>\<^sub>B\<^sub>2) F1 F2"
locale symmetry_functor
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
  assumes
    "symmetry_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)"
locale binary_functor
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
  assumes
    "binary_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale binary_functor_transformation
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
    and G :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
    and \<tau> :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
  assumes
    "binary_functor_transformation (\<cdot>\<^sub>A\<^sub>1)
      (\<cdot>\<^sub>A\<^sub>2) (\<cdot>\<^sub>B) F G \<tau>"
### theory "Category3.BinaryFunctor"
### 3.236s elapsed time, 14.125s cpu time, 0.520s GC time
Loading theory "Category3.FunctorCategory" (required by "Category3.Limit" via "Category3.Adjunction" via "Category3.Yoneda")
locale functor_category
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale functor_category
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale evaluation_functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "evaluation_functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale currying
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes
    "currying (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B)"
locale curried_functor
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
  assumes
    "curried_functor (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
locale curried_functor'
  fixes
    A1 :: "'a1 \<Rightarrow> 'a1 \<Rightarrow> 'a1"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>1\<close> 55)
    and
    A2 :: "'a2 \<Rightarrow> 'a2 \<Rightarrow> 'a2"
      (infixr \<open>\<cdot>\<^sub>A\<^sub>2\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a1 \<times> 'a2 \<Rightarrow> 'b"
  assumes
    "curried_functor' (\<cdot>\<^sub>A\<^sub>1) (\<cdot>\<^sub>A\<^sub>2)
      (\<cdot>\<^sub>B) F"
### theory "Category3.FunctorCategory"
### 3.070s elapsed time, 11.638s cpu time, 0.653s GC time
Loading theory "Category3.Yoneda" (required by "Category3.Limit" via "Category3.Adjunction")
locale hom_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
  assumes "hom_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale hom_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
  assumes "hom_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale set_valued_functor
  fixes C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
    and S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
  assumes "set_valued_functor C S F"
locale set_valued_transformation
  fixes C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
    and S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and G :: "'c \<Rightarrow> 's"
    and \<tau> :: "'c \<Rightarrow> 's"
  assumes "set_valued_transformation C S F G \<tau>"
locale yoneda_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
  assumes "yoneda_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
locale yoneda_functor_fixed_object
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and a :: "'c"
  assumes "yoneda_functor_fixed_object (\<cdot>) (\<cdot>\<^sub>S) \<phi> a"
locale yoneda_lemma
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
  assumes "yoneda_lemma (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a"
locale yoneda_lemma_fixed_e
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
    and e :: "'s"
  assumes "yoneda_lemma_fixed_e (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a e"
locale yoneda_lemma_fixed_\<tau>
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
    and \<tau> :: "'c \<Rightarrow> 's"
  assumes
    "yoneda_lemma_fixed_\<tau> (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a
      \<tau>"
locale yoneda_lemma
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
  assumes "yoneda_lemma (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a"
locale yoneda_lemma_for_hom
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
    and a' :: "'c"
  assumes "yoneda_lemma_for_hom (\<cdot>) (\<cdot>\<^sub>S) \<phi> a a'"
locale yoneda_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
  assumes "yoneda_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
### theory "Category3.Yoneda"
### 6.024s elapsed time, 21.501s cpu time, 1.327s GC time
Loading theory "Category3.Adjunction" (required by "Category3.Limit")
locale arrow_from_functor
  fixes
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and x :: "'d"
    and y :: "'c"
    and e :: "'c"
  assumes "arrow_from_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F x y e"
locale terminal_arrow_from_functor
  fixes
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and x :: "'d"
    and y :: "'c"
    and e :: "'c"
  assumes
    "terminal_arrow_from_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F x y
      e"
locale left_adjoint_functor
  fixes
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale arrow_to_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
    and x :: "'d"
    and y :: "'c"
    and e :: "'d"
  assumes "arrow_to_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G x y e"
locale initial_arrow_to_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
    and x :: "'d"
    and y :: "'c"
    and e :: "'d"
  assumes
    "initial_arrow_to_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G x y e"
locale right_adjoint_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale hom_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<phi>D :: "'d \<times> 'd \<Rightarrow> 'd \<Rightarrow> 's"
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<Phi> :: "'d \<times> 'c \<Rightarrow> 's"
    and \<Psi> :: "'d \<times> 'c \<Rightarrow> 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
*** Inner lexical error (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** at "' S'.cod (\<Phi> f)\<guillemotright>"
*** Failed to parse prop
*** At command "have" (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** Inner lexical error (line 859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** at "' \<Phi>o a\<guillemotright>"
*** Failed to parse prop
*** At command "have" (line 859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
locale unit_counit_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<phi>D :: "'d \<times> 'd \<Rightarrow> 'd \<Rightarrow> 's"
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
    and \<Phi> :: "'d \<times> 'c \<Rightarrow> 's"
    and \<Psi> :: "'d \<times> 'c \<Rightarrow> 's"
  assumes
    "adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<phi> \<psi> \<eta> \<epsilon> \<Phi> \<Psi>"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale unit_counit_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale left_adjoint_functor
  fixes
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale right_adjoint_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale hom_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<phi>D :: "'d \<times> 'd \<Rightarrow> 'd \<Rightarrow> 's"
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<Phi> :: "'d \<times> 'c \<Rightarrow> 's"
    and \<Psi> :: "'d \<times> 'c \<Rightarrow> 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
locale meta_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<phi> :: "'d \<Rightarrow> 'c \<Rightarrow> 'd"
    and \<psi> :: "'c \<Rightarrow> 'd \<Rightarrow> 'c"
  assumes
    "meta_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<phi> \<psi>"
locale unit_counit_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "unit_counit_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale hom_adjunction
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi>C :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<phi>D :: "'d \<times> 'd \<Rightarrow> 'd \<Rightarrow> 's"
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<Phi> :: "'d \<times> 'c \<Rightarrow> 's"
    and \<Psi> :: "'d \<times> 'c \<Rightarrow> 's"
  assumes
    "hom_adjunction (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) (\<cdot>\<^sub>S)
      \<phi>C \<phi>D F G \<Phi> \<Psi>"
locale left_adjoint_functor
  fixes
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
  assumes "left_adjoint_functor (\<cdot>\<^sub>D) (\<cdot>\<^sub>C) F"
locale right_adjoint_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale composite_adjunction
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'b \<Rightarrow> 'a"
    and G :: "'a \<Rightarrow> 'b"
    and F' :: "'c \<Rightarrow> 'b"
    and G' :: "'b \<Rightarrow> 'c"
    and \<phi> :: "'b \<Rightarrow> 'a \<Rightarrow> 'b"
    and \<psi> :: "'a \<Rightarrow> 'b \<Rightarrow> 'a"
    and \<phi>' :: "'c \<Rightarrow> 'b \<Rightarrow> 'c"
    and \<psi>' :: "'b \<Rightarrow> 'c \<Rightarrow> 'b"
  assumes
    "composite_adjunction (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>C) F G F' G' \<phi> \<psi> \<phi>' \<psi>'"
locale composite_adjunction
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and F :: "'b \<Rightarrow> 'a"
    and G :: "'a \<Rightarrow> 'b"
    and F' :: "'c \<Rightarrow> 'b"
    and G' :: "'b \<Rightarrow> 'c"
    and \<phi> :: "'b \<Rightarrow> 'a \<Rightarrow> 'b"
    and \<psi> :: "'a \<Rightarrow> 'b \<Rightarrow> 'a"
    and \<phi>' :: "'c \<Rightarrow> 'b \<Rightarrow> 'c"
    and \<psi>' :: "'b \<Rightarrow> 'c \<Rightarrow> 'b"
  assumes
    "composite_adjunction (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>C) F G F' G' \<phi> \<psi> \<phi>' \<psi>'"
### theory "Category3.Adjunction"
### 94.721s elapsed time, 293.151s cpu time, 28.529s GC time
Loading theory "Category3.EquivalenceOfCategories"
Loading theory "Category3.Limit"
locale equivalence_of_categories
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "equivalence_of_categories (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G
      \<eta> \<epsilon>"
locale equivalence_of_categories
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "equivalence_of_categories (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G
      \<eta> \<epsilon>"
locale equivalence_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
  assumes "equivalence_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale endofunctor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
    and F :: "'a \<Rightarrow> 'a"
  assumes "endofunctor (\<cdot>) F"
locale representation_of_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and F :: "'c \<Rightarrow> 's"
    and a :: "'c"
    and \<Phi> :: "'c \<Rightarrow> 's"
  assumes
    "representation_of_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi> F a
      \<Phi>"
locale two_representations_one_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and F :: "'c \<Rightarrow> 's"
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and a :: "'c"
    and \<Phi> :: "'c \<Rightarrow> 's"
    and a' :: "'c"
    and \<Phi>' :: "'c \<Rightarrow> 's"
  assumes
    "two_representations_one_functor (\<cdot>) (\<cdot>\<^sub>S) F \<phi> a
      \<Phi> a' \<Phi>'"
locale diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale cone
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and a :: "'c"
    and \<chi> :: "'j \<Rightarrow> 'c"
  assumes "cone (\<cdot>\<^sub>J) (\<cdot>) D a \<chi>"
locale functor
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and F :: "'a \<Rightarrow> 'b"
  assumes "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
locale diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale cones_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<iota> :: "('j \<Rightarrow> 'c) \<Rightarrow> 's"
  assumes
    "cones_functor (\<cdot>\<^sub>J) (\<cdot>) D (\<cdot>\<^sub>S) \<iota>"
locale limit_cone
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and a :: "'c"
    and \<chi> :: "'j \<Rightarrow> 'c"
  assumes "limit_cone (\<cdot>\<^sub>J) (\<cdot>) D a \<chi>"
locale diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale adjoint_equivalence
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "adjoint_equivalence (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale representation_of_cones_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<iota> :: "('j \<Rightarrow> 'c) \<Rightarrow> 's"
    and a :: "'c"
    and \<Phi> :: "'c \<Rightarrow> 's"
  assumes
    "representation_of_cones_functor (\<cdot>\<^sub>J) (\<cdot>) D
      (\<cdot>\<^sub>S) \<phi> \<iota> a \<Phi>"
locale limit_situation
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<iota> :: "('j \<Rightarrow> 'c) \<Rightarrow> 's"
    and a :: "'c"
    and \<Phi> :: "'c \<Rightarrow> 's"
    and \<chi> :: "'j \<Rightarrow> 'c"
  assumes
    "limit_situation (\<cdot>\<^sub>J) (\<cdot>) D (\<cdot>\<^sub>S) \<phi>
      \<iota> a \<Phi> \<chi>"
locale limit_cone
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and a :: "'c"
    and \<chi> :: "'j \<Rightarrow> 'c"
  assumes "D.limit_cone a \<chi>"
locale adjoint_equivalence
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
    and G :: "'c \<Rightarrow> 'd"
    and \<eta> :: "'d \<Rightarrow> 'd"
    and \<epsilon> :: "'c \<Rightarrow> 'c"
  assumes
    "adjoint_equivalence (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) F G \<eta>
      \<epsilon>"
locale fully_faithful_and_essentially_surjective_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and F :: "'d \<Rightarrow> 'c"
  assumes
    "fully_faithful_and_essentially_surjective_functor (\<cdot>\<^sub>C)
      (\<cdot>\<^sub>D) F"
### theory "Category3.EquivalenceOfCategories"
### 6.184s elapsed time, 38.236s cpu time, 2.083s GC time
locale representation_of_cones_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
    and \<iota> :: "('j \<Rightarrow> 'c) \<Rightarrow> 's"
    and a :: "'c"
    and \<Phi> :: "'c \<Rightarrow> 's"
  assumes
    "representation_of_cones_functor (\<cdot>\<^sub>J) (\<cdot>) D
      (\<cdot>\<^sub>S) \<phi> \<iota> a \<Phi>"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale diagonal_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "diagonal_functor (\<cdot>\<^sub>J) (\<cdot>)"
locale diagonal_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "diagonal_functor (\<cdot>\<^sub>J) (\<cdot>)"
locale right_adjoint_to_diagonal_functor
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and G :: "('j, 'c) J_C.arr \<Rightarrow> 'c"
    and \<phi> :: "'c \<Rightarrow> ('j, 'c) J_C.arr \<Rightarrow> 'c"
    and
    \<psi> ::
      "('j, 'c) J_C.arr \<Rightarrow> 'c \<Rightarrow> ('j, 'c) J_C.arr"
  assumes
    "right_adjoint_to_diagonal_functor (\<cdot>\<^sub>J) (\<cdot>) G \<phi>
      \<psi>"
locale right_adjoint_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<^sub>C\<close> 55)
    and
    D :: "'d \<Rightarrow> 'd \<Rightarrow> 'd"
      (infixr \<open>\<cdot>\<^sub>D\<close> 55)
    and G :: "'c \<Rightarrow> 'd"
  assumes "right_adjoint_functor (\<cdot>\<^sub>C) (\<cdot>\<^sub>D) G"
locale empty_diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "empty_diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale discrete_diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "discrete_diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale discrete_diagram_from_map
  fixes I :: "'i set"
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'i \<Rightarrow> 'c"
    and null :: "'i"
  assumes "discrete_diagram_from_map I (\<cdot>) D null"
locale product_cone
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
    and a :: "'c"
    and \<pi> :: "'j \<Rightarrow> 'c"
  assumes "product_cone (\<cdot>\<^sub>J) (\<cdot>) D a \<pi>"
locale discrete_diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 'c"
  assumes "discrete_diagram (\<cdot>\<^sub>J) (\<cdot>) D"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale parallel_pair_diagram
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and f0 :: "'c"
    and f1 :: "'c"
  assumes "parallel_pair_diagram (\<cdot>) f0 f1"
locale parallel_pair_diagram
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and f0 :: "'c"
    and f1 :: "'c"
  assumes "parallel_pair_diagram (\<cdot>) f0 f1"
locale equalizer_cone
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and f0 :: "'c"
    and f1 :: "'c"
    and e :: "'c"
  assumes "equalizer_cone (\<cdot>) f0 f1 e"
locale category
  fixes
    C :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category (\<cdot>)"
locale category_with_equalizers
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "category_with_equalizers (\<cdot>)"
locale diagram_in_set_category
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 's"
  assumes "diagram_in_set_category (\<cdot>\<^sub>J) (\<cdot>) D"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale discrete_diagram_in_set_category
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
    and D :: "'j \<Rightarrow> 's"
  assumes "discrete_diagram_in_set_category (\<cdot>\<^sub>J) (\<cdot>) D"
locale set_category
  fixes
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<close> 55)
  assumes "set_category (\<cdot>)"
locale parametrized_diagram
  fixes
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and D :: "'j \<times> 'a \<Rightarrow> 'b"
  assumes
    "parametrized_diagram (\<cdot>\<^sub>J) (\<cdot>\<^sub>A)
      (\<cdot>\<^sub>B) D"
locale diagram_in_functor_category
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
    and
    J :: "'j \<Rightarrow> 'j \<Rightarrow> 'j"
      (infixr \<open>\<cdot>\<^sub>J\<close> 55)
    and D :: "'j \<Rightarrow> ('a, 'b) A_B.arr"
  assumes
    "diagram_in_functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)
      (\<cdot>\<^sub>J) D"
locale functor_category
  fixes
    A :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixr \<open>\<cdot>\<^sub>A\<close> 55)
    and
    B :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<cdot>\<^sub>B\<close> 55)
  assumes "functor_category (\<cdot>\<^sub>A) (\<cdot>\<^sub>B)"
locale yoneda_functor
  fixes
    C :: "'c \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>\<cdot>\<close> 55)
    and
    S :: "'s \<Rightarrow> 's \<Rightarrow> 's"
      (infixr \<open>\<cdot>\<^sub>S\<close> 55)
    and \<phi> :: "'c \<times> 'c \<Rightarrow> 'c \<Rightarrow> 's"
  assumes "yoneda_functor (\<cdot>) (\<cdot>\<^sub>S) \<phi>"
### theory "Category3.Limit"
### 28.545s elapsed time, 144.270s cpu time, 9.102s GC time
*** Inner lexical error (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** at "' S'.cod (\<Phi> f)\<guillemotright>"
*** Failed to parse prop
*** At command "have" (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** Inner lexical error (line 859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")
*** at "' \<Phi>o a\<guillemotright>"
*** Failed to parse prop
*** At command "have" (line 859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Category3/SetCategory.thy")

==========
Collections
Loading theory "Collections.ICF_Tools" (required by "Collections.Robdd" via "Collections.MapSpec" via "Collections.ICF_Spec_Base" via "Collections.Record_Intf")
Loading theory "Collections.Partial_Equivalence_Relation"
Loading theory "Finger-Trees.FingerTree"
Loading theory "Binomial-Heaps.BinomialHeap"
Loading theory "HOL-Library.AList" (required by "Collections.Assoc_List")
Loading theory "HOL-Library.Code_Target_Int" (required by "HOL-Library.Code_Target_Numeral")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "Binomial-Heaps.SkewBinomialHeap"
consts
  update ::
    "'key
     \<Rightarrow> 'val
                   \<Rightarrow> ('key \<times> 'val) list
                                 \<Rightarrow> ('key \<times> 'val) list"
### theory "HOL-Library.Code_Abstract_Nat"
### 0.073s elapsed time, 0.522s cpu time, 0.119s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "HOL-Library.Code_Target_Numeral")
locale BinomialHeapStruc_loc
### Code generator: dropping subsumed code equation
### 1 \<equiv> Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l \<equiv> ?l
### Code generator: dropping subsumed code equation
### ?k + 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m \<equiv> Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m \<equiv> Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l \<equiv> - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) \<equiv> Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) \<equiv> Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k * 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One \<equiv> - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One \<equiv> ?k
### Code generator: dropping subsumed code equation
### 0 div ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k div 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n \<equiv> - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n \<equiv>
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n \<equiv>
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n \<equiv> snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### 0 mod ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k \<equiv> True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Neg ?l \<equiv> ?l \<le> ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Pos ?l \<equiv> True
infix 0 ##
signature ICF_TOOLS =
  sig
    val changed_conv: conv -> conv
    val chead_of: cterm -> cterm
    val chead_of_thm: thm -> cterm
    val define_simple:
       string -> term -> local_theory -> (term * thm) * local_theory
    val define_simple_global:
       string -> term -> theory -> (term * thm) * theory
    val define_simple_local:
       string -> term -> local_theory -> (term * thm) * local_theory
    val dest_def_eq: term -> term * term
    val dt_head: term -> term
    val dt_lhs: term -> term
    val dt_params: term -> term list
    val dt_rhs: term -> term
    val dthm_head: thm -> term
    val dthm_lhs: thm -> term
    val dthm_params: thm -> term list
    val dthm_rhs: thm -> term
    val gen_variant: (string -> bool) -> string -> string
    val import_cterm: cterm -> Proof.context -> cterm * Proof.context
    val inst_meta_cong: Proof.context -> cterm -> thm
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val norm_def_thm: thm -> thm
    val parse_cpat: cterm context_parser
    val rem_dup_prems: Proof.context -> thm -> thm
    val rename_cterm:
       cterm * cterm ->
         ((indexname * sort) * ctyp) list * ((indexname * typ) * cterm) list
    val renames_cterm: cterm * cterm -> bool
    val repeat_top_sweep_conv:
       (Proof.context -> conv) -> Proof.context -> conv
    val revert_abbrevs: string -> theory -> theory
    val sss_add: thm list -> Proof.context -> Proof.context
    val wrap_lthy_global: (local_theory -> local_theory) -> theory -> theory
    val wrap_lthy_local:
       (local_theory -> local_theory) -> local_theory -> local_theory
    val wrap_lthy_result_global:
       (local_theory -> 'a * local_theory) ->
         (morphism -> 'a -> 'b) -> theory -> 'b * theory
    val wrap_lthy_result_local:
       (local_theory -> 'a * local_theory) ->
         (morphism -> 'a -> 'b) -> local_theory -> 'b * local_theory
  end
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
structure ICF_Tools: ICF_TOOLS
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Pos ?l \<equiv> ?k \<le> ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Neg ?l \<equiv> False
locale SkewBinomialHeapStruc_loc
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l \<equiv> ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l \<equiv> ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### if ?n = 0 \<or> ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
locale FingerTreeStruc_loc
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### theory "Collections.ICF_Tools"
### 0.117s elapsed time, 0.879s cpu time, 0.119s GC time
Loading theory "Collections.Ord_Code_Preproc" (required by "Collections.Robdd" via "Collections.MapSpec" via "Collections.ICF_Spec_Base" via "Collections.Record_Intf")
### theory "Collections.Partial_Equivalence_Relation"
### 0.120s elapsed time, 0.894s cpu time, 0.119s GC time
Loading theory "HOL-Library.Confluence" (required by "Collections.Dlist_add" via "HOL-Library.Dlist" via "HOL-Library.Confluent_Quotient")
### Code generator: dropping subsumed code equation
### Suc ?m \<le> ?n \<equiv> ?m < ?n
### Code generator: dropping subsumed code equation
### 0 \<le> ?n \<equiv> True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n \<equiv> ?m \<le> ?n
### Code generator: dropping subsumed code equation
### ?n < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### of_nat ?n \<equiv>
### semiring_1_class.of_nat_aux (\<lambda>i. i + (1::?'a)) ?n (0::?'a)
### ML warning (line 27 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### (=) has infix status but was not preceded by op.
### ML warning (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### Value identifier (trace_ft) has not been referenced.
### ML warning (line 51 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### Value identifier (process) has not been referenced.
signature ORD_CODE_PREPROC =
  sig
    val add: int * string * (theory -> thm -> thm) -> theory -> theory
    val get: theory -> (int * string * (theory -> thm -> thm)) list
    val rem: string -> theory -> theory
    val setup: theory -> theory
    val trace_enabled: bool ref
  end
signature OC_SIMPSET =
  sig
    val get: theory -> simpset
    val map: (simpset -> simpset) -> theory -> theory
    val setup: theory -> theory
  end
structure Ord_Code_Preproc: ORD_CODE_PREPROC
functor Oc_Simpset (sig val name: string val prio: int end): OC_SIMPSET
### theory "Collections.Ord_Code_Preproc"
### 0.061s elapsed time, 0.476s cpu time, 0.083s GC time
Loading theory "Collections.Locale_Code" (required by "Collections.Robdd" via "Collections.MapSpec" via "Collections.ICF_Spec_Base")
### theory "HOL-Library.Code_Target_Nat"
### 0.122s elapsed time, 0.984s cpu time, 0.083s GC time
Loading theory "Collections.Record_Intf" (required by "Collections.Robdd" via "Collections.MapSpec" via "Collections.ICF_Spec_Base")
### theory "HOL-Library.Confluence"
### 0.093s elapsed time, 0.729s cpu time, 0.083s GC time
Loading theory "HOL-Library.Confluent_Quotient" (required by "Collections.Dlist_add" via "HOL-Library.Dlist")
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) \<equiv> numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 \<equiv> 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) \<equiv> - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) \<equiv> nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) \<equiv> 0
### theory "HOL-Library.Code_Target_Int"
### 0.252s elapsed time, 1.917s cpu time, 0.312s GC time
Loading theory "HOL-Library.Code_Target_Numeral"
signature RECORD_INTF =
  sig
    val add_unf_thms: thm list -> Context.generic -> Context.generic
    val add_unf_thms_global: thm list -> theory -> theory
    val get_unf_ss: Context.generic -> simpset
    val get_unf_thms: Context.generic -> thm list
    val icf_locales_tac: Proof.context -> tactic
    val icf_rec_def: thm -> Context.generic -> Context.generic
    val icf_rec_def_attr: attribute context_parser
    val setup: theory -> theory
  end
structure Record_Intf: RECORD_INTF
### theory "Collections.Record_Intf"
### 0.065s elapsed time, 0.495s cpu time, 0.110s GC time
Loading theory "Collections.SetIterator" (required by "Collections.RBT_add" via "Collections.Iterator" via "Collections.It_to_It" via "Collections.Proper_Iterator" via "Collections.SetIteratorOperations")
consts
  update_with_aux ::
    "'val
     \<Rightarrow> 'key
                   \<Rightarrow> ('val \<Rightarrow> 'val)
                                 \<Rightarrow> ('key \<times> 'val) list
         \<Rightarrow> ('key \<times> 'val) list"
locale confluent_quotient
  fixes R :: "'Fb \<Rightarrow> 'Fb \<Rightarrow> bool"
    and Ea :: "'Fa \<Rightarrow> 'Fa \<Rightarrow> bool"
    and Eb :: "'Fb \<Rightarrow> 'Fb \<Rightarrow> bool"
    and Ec :: "'Fc \<Rightarrow> 'Fc \<Rightarrow> bool"
    and Eab :: "'Fab \<Rightarrow> 'Fab \<Rightarrow> bool"
    and Ebc :: "'Fbc \<Rightarrow> 'Fbc \<Rightarrow> bool"
    and \<pi>_Faba :: "'Fab \<Rightarrow> 'Fa"
    and \<pi>_Fabb :: "'Fab \<Rightarrow> 'Fb"
    and \<pi>_Fbcb :: "'Fbc \<Rightarrow> 'Fb"
    and \<pi>_Fbcc :: "'Fbc \<Rightarrow> 'Fc"
    and
    rel_Fab ::
      "('a \<Rightarrow> 'b \<Rightarrow> bool)
       \<Rightarrow> 'Fa \<Rightarrow> 'Fb \<Rightarrow> bool"
    and
    rel_Fbc ::
      "('b \<Rightarrow> 'c \<Rightarrow> bool)
       \<Rightarrow> 'Fb \<Rightarrow> 'Fc \<Rightarrow> bool"
    and
    rel_Fac ::
      "('a \<Rightarrow> 'c \<Rightarrow> bool)
       \<Rightarrow> 'Fa \<Rightarrow> 'Fc \<Rightarrow> bool"
    and set_Fab :: "'Fab \<Rightarrow> ('a \<times> 'b) set"
    and set_Fbc :: "'Fbc \<Rightarrow> ('b \<times> 'c) set"
  assumes
    "confluent_quotient R Ea Eb Ec Eab Ebc \<pi>_Faba \<pi>_Fabb \<pi>_Fbcb
      \<pi>_Fbcc rel_Fab rel_Fbc rel_Fac set_Fab set_Fbc"
### ML warning (line 344 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2020/thys/Collections/ICF/tools/Locale_Code.thy"):
### Pattern is not exhaustive.
signature LOCALE_CODE =
  sig
    val add_pat_eq: cterm -> thm list -> theory -> theory
    val close_block: theory -> theory
    val del_pat: cterm -> theory -> theory
    val get_unf_ss: theory -> simpset
    val lc_decl_del: term -> local_theory -> local_theory
    val lc_decl_eq: thm list -> local_theory -> local_theory
    val open_block: theory -> theory
    type pat_eq = cterm * thm list
    val setup: theory -> theory
    val tracing_enabled: bool ref
  end
structure Locale_Code: LOCALE_CODE
### theory "HOL-Library.Confluent_Quotient"
### 0.112s elapsed time, 0.859s cpu time, 0.189s GC time
Loading theory "HOL-Library.Dlist" (required by "Collections.Dlist_add")
### theory "Collections.Locale_Code"
### 0.154s elapsed time, 1.190s cpu time, 0.189s GC time
Loading theory "Collections.Sorted_List_Operations"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
locale set_iterator_genord
  fixes
    iti ::
      "('\<sigma> \<Rightarrow> bool)
       \<Rightarrow> ('x \<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>)
                     \<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>"
    and S0 :: "'x set"
    and R :: "'x \<Rightarrow> 'x \<Rightarrow> bool"
  assumes "set_iterator_genord iti S0 R"
### theory "HOL-Library.Code_Target_Numeral"
### 0.122s elapsed time, 0.954s cpu time, 0.079s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Collections.RBT_add")
locale Quotient_dlist
Found termination order:
  "(\<lambda>p. length (snd p)) <*mlex*>
   (\<lambda>p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. length (snd p)) <*mlex*>
   (\<lambda>p. length (fst p)) <*mlex*> {}"
instantiation
  dlist :: (equal) equal
  equal_dlist == equal_class.equal ::
    'a dlist \<Rightarrow> 'a dlist \<Rightarrow> bool
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "double"
### Ignoring sort constraints in type variables(s): "'a"
### in type abbreviation "BinomialQueue_inv"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order: "(\<lambda>p. length (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order:
  "(\<lambda>p. size_list size (snd (snd p))) <*mlex*> {}"
### Ignoring sort constraints in type variables(s): "'a"
### in type abbreviation "SkewBinomialQueue"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "HOL-Library.Dlist"
### 0.851s elapsed time, 6.422s cpu time, 2.133s GC time
Loading theory "Collections.DatRef"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
### theory "Collections.Sorted_List_Operations"
### 0.947s elapsed time, 7.119s cpu time, 2.202s GC time
Loading theory "Native_Word.More_Bits_Int" (required by "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
Found termination order:
  "(\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.AList"
### 1.335s elapsed time, 10.130s cpu time, 2.672s GC time
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Found termination order: "{}"
### theory "Collections.SetIterator"
### 1.256s elapsed time, 9.577s cpu time, 2.560s GC time
Loading theory "Collections.Idx_Iterator" (required by "Collections.RBT_add" via "Collections.Iterator")
Loading theory "Collections.SetAbstractionIterator"
Found termination order: "size_list size <*mlex*> {}"
locale set_iterator_abs_genord
  fixes \<alpha> :: "'xc \<Rightarrow> 'xa"
    and invar :: "'xc \<Rightarrow> bool"
    and
    iti ::
      "('\<sigma> \<Rightarrow> bool)
       \<Rightarrow> ('xc \<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>)
                     \<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>"
    and S0 :: "'xa set"
    and R :: "'xa \<Rightarrow> 'xa \<Rightarrow> bool"
  assumes "set_iterator_abs_genord \<alpha> invar iti S0 R"
locale while_algo
  fixes WA :: "'S while_algo"
  assumes "while_algo WA"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
locale wa_refine
  fixes WAC :: "'C while_algo"
    and WAA :: "'A while_algo"
    and \<alpha> :: "'C \<Rightarrow> 'A"
  assumes "wa_refine WAC WAA \<alpha>"
locale wa_precise_refine
  fixes WAC :: "'C while_algo"
    and WAA :: "'A while_algo"
    and \<alpha> :: "'C \<Rightarrow> 'A"
  assumes "wa_precise_refine WAC WAA \<alpha>"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
consts
  entries :: "('a, 'b) rbt \<Rightarrow> ('a \<times> 'b) list"
### theory "Collections.Idx_Iterator"
### 0.458s elapsed time, 3.700s cpu time, 0.608s GC time
Loading theory "Collections.SetIteratorOperations" (required by "Collections.RBT_add" via "Collections.Iterator" via "Collections.It_to_It" via "Collections.Proper_Iterator")
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### theory "Collections.SetAbstractionIterator"
### 0.479s elapsed time, 3.849s cpu time, 0.582s GC time
locale det_while_algo
  fixes WA :: "'S det_while_algo"
  assumes "det_while_algo WA"
### theory "Collections.DatRef"
### 0.852s elapsed time, 6.773s cpu time, 1.045s GC time
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
consts
  rbt_sorted :: "('a, 'b) rbt \<Rightarrow> bool"
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
consts
  bin_mask :: "nat \<Rightarrow> int"
Proofs for inductive predicate(s) "wf_set_bits_int"
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
consts
  rbt_lookup :: "('a, 'b) rbt \<Rightarrow> 'a \<Rightarrow> 'b option"
### theory "Native_Word.More_Bits_Int"
### 1.013s elapsed time, 8.103s cpu time, 1.218s GC time
Loading theory "Native_Word.Code_Symbolic_Bits_Int" (required by "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
Found termination order:
  "(\<lambda>p. size_list size (snd p)) <*mlex*>
   (\<lambda>p. size_list size (fst p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size_list size (snd p)) <*mlex*>
   (\<lambda>p. size_list size (fst p)) <*mlex*> {}"
### Missing patterns in function definition:
### getMinTree [] = undefined
### Missing patterns in function definition:
### getMinTree [] = undefined
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
Found termination order: "size_list size <*mlex*> {}"
### theory "Native_Word.Code_Symbolic_Bits_Int"
### 0.137s elapsed time, 1.086s cpu time, 0.110s GC time
Loading theory "Native_Word.Bits_Integer" (required by "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
val it = fn:
   (theory -> theory) ->
     (Proof.context -> Proof.context) -> Context.generic -> Context.generic
Found termination order: "size_list size <*mlex*> {}"
instantiation
  integer :: bit_operations
  bitNOT_integer == bitNOT :: integer \<Rightarrow> integer
  bitAND_integer == bitAND ::
    integer \<Rightarrow> integer \<Rightarrow> integer
  bitOR_integer == bitOR ::
    integer \<Rightarrow> integer \<Rightarrow> integer
  bitXOR_integer == bitXOR ::
    integer \<Rightarrow> integer \<Rightarrow> integer
  shiftl_integer == shiftl ::
    integer \<Rightarrow> nat \<Rightarrow> integer
  shiftr_integer == shiftr ::
    integer \<Rightarrow> nat \<Rightarrow> integer
  test_bit_integer == test_bit ::
    integer \<Rightarrow> nat \<Rightarrow> bool
  lsb_integer == lsb :: integer \<Rightarrow> bool
  msb_integer == msb :: integer \<Rightarrow> bool
  set_bit_integer == set_bit ::
    integer \<Rightarrow> nat \<Rightarrow> bool \<Rightarrow> integer
Found termination order: "(\<lambda>p. size_list size (fst p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
consts
  color_of :: "('a, 'b) rbt \<Rightarrow> color"
consts
  bheight :: "('a, 'b) rbt \<Rightarrow> nat"
consts
  inv1 :: "('a, 'b) rbt \<Rightarrow> bool"
consts
  inv1l :: "('a, 'b) rbt \<Rightarrow> bool"
consts
  inv2 :: "('a, 'b) rbt \<Rightarrow> bool"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
locale Bootstrapped
locale BinomialHeap_loc
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### theory "Binomial-Heaps.BinomialHeap"
### 3.227s elapsed time, 25.053s cpu time, 4.857s GC time
locale FingerTreeStruc_loc
consts
  gmn :: "('e, 'a) Node \<Rightarrow> 'a"
consts
  gmd :: "('e, 'a) Digit \<Rightarrow> 'a"
consts
  gmft :: "('e, 'a) FingerTreeStruc \<Rightarrow> 'a"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
consts
  is_leveln_digit :: "nat \<Rightarrow> ('e, 'a) Digit \<Rightarrow> bool"
consts
  is_leveln_ftree ::
    "nat \<Rightarrow> ('e, 'a) FingerTreeStruc \<Rightarrow> bool"
consts
  is_measured_node :: "('e, 'a) Node \<Rightarrow> bool"
consts
  is_measured_digit :: "('e, 'a) Digit \<Rightarrow> bool"
consts
  is_measured_ftree :: "('e, 'a) FingerTreeStruc \<Rightarrow> bool"
consts
  nodeToList :: "('e, 'a) Node \<Rightarrow> ('e \<times> 'a) list"
consts
  digitToList :: "('e, 'a) Digit \<Rightarrow> ('e \<times> 'a) list"
consts
  toList :: "('e, 'a) FingerTreeStruc \<Rightarrow> ('e \<times> 'a) list"
### theory "Collections.SetIteratorOperations"
### 2.250s elapsed time, 16.581s cpu time, 2.004s GC time
Loading theory "Collections.Assoc_List"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Loading theory "Collections.Dlist_add"
Loading theory "Collections.Proper_Iterator" (required by "Collections.RBT_add" via "Collections.Iterator" via "Collections.It_to_It")
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
consts
  dlist_remove1' ::
    "'a \<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> 'a list"
Found termination order: "size <*mlex*> {}"
### theory "Collections.Dlist_add"
### 0.273s elapsed time, 1.830s cpu time, 0.153s GC time
Loading theory "Collections.SetIteratorGA" (required by "Collections.RBT_add" via "Collections.Iterator")
consts
  toTree :: "('e \<times> 'a) list \<Rightarrow> ('e, 'a) FingerTreeStruc"
consts
  digitToTree :: "('e, 'a) Digit \<Rightarrow> ('e, 'a) FingerTreeStruc"
consts
  prio :: "('e, 'a) BsSkewBinomialTree \<Rightarrow> 'a"
structure Icf_Proper_Iterator:
  sig
    val add: attribute
    val add_thm: thm -> Context.generic -> Context.generic
    val del: attribute
    val del_thm: thm -> Context.generic -> Context.generic
    val get: Proof.context -> thm list
    structure icf_proper_iteratorI: NAMED_THMS
    val setup: theory -> theory
  end
consts
  nodeToDigit :: "('e, 'a) Node \<Rightarrow> ('e, 'a) Digit"
instantiation
  assoc_list :: (equal, equal) equal
  equal_assoc_list == equal_class.equal ::
    ('a, 'b) assoc_list \<Rightarrow> ('a, 'b) assoc_list \<Rightarrow> bool
### Missing patterns in function definition:
### nlistToDigit [] = undefined
### \<And>v vb va vc vd vf.
###    nlistToDigit (v # vb # va # vc # vd # vf) = undefined
instantiation
  assoc_list :: (type, type) size
  size_assoc_list == size :: ('a, 'b) assoc_list \<Rightarrow> nat
consts
  map_ran ::
    "('key \<Rightarrow> 'val \<Rightarrow> 'val')
     \<Rightarrow> ('key \<times> 'val) list
                   \<Rightarrow> ('key \<times> 'val') list"
Found termination order: "{}"
### theory "Collections.Assoc_List"
### 0.490s elapsed time, 3.276s cpu time, 0.319s GC time
Loading theory "Collections.Diff_Array"
Found termination order: "{}"
consts
  digitToNlist :: "('e, 'a) Digit \<Rightarrow> ('e, 'a) Node list"
### theory "Collections.Proper_Iterator"
### 0.409s elapsed time, 2.756s cpu time, 0.254s GC time
Loading theory "Collections.It_to_It" (required by "Collections.RBT_add" via "Collections.Iterator")
consts
  n_unwrap :: "('e, 'a) Node \<Rightarrow> 'e \<times> 'a"
locale proper_it_loc
  fixes
    it ::
      "'s \<Rightarrow> ('x list \<Rightarrow> bool)
                        \<Rightarrow> ('x
 \<Rightarrow> 'x list \<Rightarrow> 'x list)
\<Rightarrow> 'x list \<Rightarrow> 'x list"
    and
    it' ::
      "'s \<Rightarrow> ('\<sigma> \<Rightarrow> bool)
                        \<Rightarrow> ('x
 \<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>)
\<Rightarrow> '\<sigma> \<Rightarrow> '\<sigma>"
  assumes "proper_it_loc it it'"
datatype 'a ref = ref of 'a
structure Bits_Integer:
  sig
    val set_bit: int -> int -> bool -> int
    val shiftl: int -> int -> int
    val shiftr: int -> int -> int
    val test_bit: int -> int -> bool
  end
ROOT.ML:38: warning: Pattern 3 is redundant.
Found near
  fun
     equal_boola p true = p |
        equal_boola p ... = not p |
        equal_boola ... = p |
        equal_boola ... = ...
ROOT.ML:39: warning: Pattern 4 is redundant.
Found near
  fun
     equal_boola p true = p |
        equal_boola p ... = not p |
        equal_boola ... = p |
        equal_boola ... = ...
ROOT.ML:85: warning: Value identifier (times) has not been referenced.
ROOT.ML:88: warning: Value identifier (one_power) has not been referenced.
ROOT.ML:89: warning: Value identifier (times_power) has not been referenced.
ROOT.ML:98: warning: Value identifier (semigroup_add_ab_semigroup_add) has not been referenced.
ROOT.ML:102: warning: Value identifier (times_semigroup_mult) has not been referenced.
ROOT.ML:108: warning: Value identifier (ab_semigroup_add_semiring) has not been referenced.
ROOT.ML:110: warning: Value identifier (semigroup_mult_semiring) has not been referenced.
ROOT.ML:126: warning: Value identifier (times_mult_zero) has not been referenced.
ROOT.ML:135: warning: Value identifier (semigroup_add_monoid_add) has not been referenced.
ROOT.ML:137: warning: Value identifier (zero_monoid_add) has not been referenced.
ROOT.ML:142: warning: Value identifier (ab_semigroup_add_comm_monoid_add) has not been referenced.
ROOT.ML:144: warning: Value identifier (monoid_add_comm_monoid_add) has not been referenced.
ROOT.ML:150: warning: Value identifier (comm_monoid_add_semiring_0) has not been referenced.
ROOT.ML:154: warning: Value identifier (semiring_semiring_0) has not been referenced.
ROOT.ML:175: warning: Value identifier (semigroup_mult_monoid_mult) has not been referenced.
ROOT.ML:177: warning: Value identifier (power_monoid_mult) has not been referenced.
ROOT.ML:183: warning: Value identifier (monoid_mult_semiring_numeral) has not been referenced.
ROOT.ML:187: warning: Value identifier (semiring_semiring_numeral) has not been referenced.
ROOT.ML:191: warning: Value identifier (one_zero_neq_one) has not been referenced.
ROOT.ML:192: warning: Value identifier (zero_zero_neq_one) has not been referenced.
ROOT.ML:202: warning: Value identifier (zero_neq_one_semiring_1) has not been referenced.
ROOT.ML:247: warning: Value identifier (inc) has not been referenced.
ROOT.ML:247: warning: Value identifier (A_) has not been referenced.
ROOT.ML:280: warning: Value identifier (A_) has not been referenced.
ROOT.ML:277: warning: Value identifier (x22) has not been referenced.
ROOT.ML:277: warning: Value identifier (x21) has not been referenced.
ROOT.ML:277: warning: Value identifier (A_) has not been referenced.
ROOT.ML:276: warning: Value identifier (x22) has not been referenced.
ROOT.ML:276: warning: Value identifier (x21) has not been referenced.
ROOT.ML:276: warning: Value identifier (A_) has not been referenced.
structure Generated_Code:
  sig val bit_integer_test: bool type nat type num end
Loading theory "Collections.Gen_Iterator" (required by "Collections.RBT_add" via "Collections.Iterator")
### ISABELLE_GHC not set; skipped checking code for Haskell
### ISABELLE_GHC not set; skipped checking code for Haskell_Quickcheck
### ISABELLE_OCAMLFIND not set; skipped checking code for OCaml
Found termination order: "{}"
### theory "Collections.It_to_It"
### 0.093s elapsed time, 0.657s cpu time, 0.089s GC time
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
consts
  array_length :: "'a array \<Rightarrow> nat"
consts
  array_get :: "'a array \<Rightarrow> nat \<Rightarrow> 'a"
consts
  array_set ::
    "'a array \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a array"
consts
  array_grow ::
    "'a array \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a array"
consts
  array_shrink :: "'a array \<Rightarrow> nat \<Rightarrow> 'a array"
consts
  list_of_array :: "'a array \<Rightarrow> 'a list"
consts
  assoc_list_of_array :: "'a array \<Rightarrow> (nat \<times> 'a) list"
### Rewrite rule not in simpset:
### Wellfounded.accp assoc_list_of_array_code_rel (?a1, ?n1) \<Longrightarrow>
### assoc_list_of_array_code ?a1 ?n1 \<equiv>
### if array_length ?a1 \<le> ?n1 then []
### else (?n1, array_get ?a1 ?n1) # assoc_list_of_array_code ?a1 (?n1 + 1)
### theory "Collections.Gen_Iterator"
### 0.635s elapsed time, 4.465s cpu time, 0.553s GC time
### theory "Collections.SetIteratorGA"
### 0.959s elapsed time, 6.658s cpu time, 0.900s GC time
Loading theory "Collections.Iterator" (required by "Collections.RBT_add")
consts
  lconsNlist ::
    "('e, 'a) Node list
     \<Rightarrow> ('e, 'a) FingerTreeStruc
                   \<Rightarrow> ('e, 'a) FingerTreeStruc"
Found termination order:
  "(\<lambda>p. size_list size (snd p)) <*mlex*>
   (\<lambda>p. size_list size (fst p)) <*mlex*> {}"
consts
  rconsNlist ::
    "('e, 'a) FingerTreeStruc
     \<Rightarrow> ('e, 'a) Node list
                   \<Rightarrow> ('e, 'a) FingerTreeStruc"
### Missing patterns in function definition:
### nodes [] = undefined
### \<And>v. nodes [v] = undefined
Found termination order: "(\<lambda>p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### Missing patterns in function definition:
### getMinTree [] = undefined
Found termination order: "size_list size <*mlex*> {}"
consts
  findMin' :: "('a, 'b) BsSkewElem \<Rightarrow> 'a \<times> 'b"
### theory "Collections.Iterator"
### 0.714s elapsed time, 4.571s cpu time, 0.409s GC time
Loading theory "Collections.ICF_Spec_Base" (required by "Collections.Robdd" via "Collections.MapSpec")
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
consts
  nlistToList :: "('e, 'a) Node list \<Rightarrow> ('e \<times> 'a) list"
Found termination order: "{}"
Found termination order: "{}"
### theory "Collections.ICF_Spec_Base"
### 0.398s elapsed time, 2.352s cpu time, 0.206s GC time
Loading theory "Collections.MapSpec" (required by "Collections.Robdd")
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
locale map
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
locale map_no_invar
  fixes \<alpha> :: "'a \<Rightarrow> 'b \<Rightarrow> 'c option"
    and invar :: "'a \<Rightarrow> bool"
  assumes "map_no_invar invar"
locale map_empty
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and empty :: "unit \<Rightarrow> 's"
  assumes "map_empty \<alpha> invar empty"
Found termination order: "{}"
locale map_lookup
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and lookup :: "'u \<Rightarrow> 's \<Rightarrow> 'v option"
  assumes "map_lookup \<alpha> invar lookup"
### Missing patterns in function definition:
### \<And>a b. splitNlist a b [] = undefined
locale map_update
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and update :: "'u \<Rightarrow> 'v \<Rightarrow> 's \<Rightarrow> 's"
  assumes "map_update \<alpha> invar update"
Found termination order: "{}"
locale map_update_dj
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and update_dj :: "'u \<Rightarrow> 'v \<Rightarrow> 's \<Rightarrow> 's"
  assumes "map_update_dj \<alpha> invar update_dj"
locale map_delete
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and delete :: "'u \<Rightarrow> 's \<Rightarrow> 's"
  assumes "map_delete \<alpha> invar delete"
locale map_add
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and add :: "'s \<Rightarrow> 's \<Rightarrow> 's"
  assumes "MapSpec.map_add \<alpha> invar add"
locale map_add_dj
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and add_dj :: "'s \<Rightarrow> 's \<Rightarrow> 's"
  assumes "map_add_dj \<alpha> invar add_dj"
locale map_isEmpty
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and isEmpty :: "'s \<Rightarrow> bool"
  assumes "map_isEmpty \<alpha> invar isEmpty"
locale map_sng
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and sng :: "'u \<Rightarrow> 'v \<Rightarrow> 's"
  assumes "map_sng \<alpha> invar sng"
locale map_isSng
  fixes \<alpha> :: "'s \<Rightarrow> 'k \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and isSng :: "'s \<Rightarrow> bool"
  assumes "map_isSng \<alpha> invar isSng"
locale finite_map
  fixes \<alpha> :: "'a \<Rightarrow> 'b \<Rightarrow> 'c option"
    and invar :: "'a \<Rightarrow> bool"
  assumes "finite_map \<alpha> invar"
locale map_size
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and size :: "'s \<Rightarrow> nat"
  assumes "map_size \<alpha> invar size"
locale map_size_abort
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and size_abort :: "nat \<Rightarrow> 's \<Rightarrow> nat"
  assumes "map_size_abort \<alpha> invar size_abort"
locale poly_map_iteratei_defs
  fixes
    list_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
Found termination order:
  "(\<lambda>p. size_list size (snd (snd p))) <*mlex*> {}"
locale poly_map_iteratei
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    list_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
  assumes "poly_map_iteratei \<alpha> invar list_it"
### No equation for constructor "Inl"
consts
  bs_findMin :: "'c + ('a, 'b) BsSkewElem \<Rightarrow> 'a \<times> 'b"
Found termination order: "{}"
locale map_ball
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    ball ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> bool)
                        \<Rightarrow> bool"
  assumes "map_ball \<alpha> invar ball"
consts
  bs_insert ::
    "'e \<Rightarrow> 'a \<Rightarrow> unit + ('e, 'a) BsSkewElem
 \<Rightarrow> unit + ('e, 'a) BsSkewElem"
locale map_bex
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    bex ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> bool)
                        \<Rightarrow> bool"
  assumes "map_bex \<alpha> invar bex"
### Missing patterns in function definition:
### \<And>v. bs_deleteMin (Inl v) = undefined
locale map_sel
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    sel ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> 'r option)
                        \<Rightarrow> 'r option"
  assumes "map_sel \<alpha> invar sel"
Found termination order: "{}"
consts
  bs_invar :: "unit + ('e, 'a) BsSkewElem \<Rightarrow> bool"
locale map_sel'
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    sel' ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v) option"
  assumes "map_sel' \<alpha> invar sel'"
consts
  bs_to_mset ::
    "unit + ('e, 'a) BsSkewElem \<Rightarrow> ('e \<times> 'a) multiset"
locale map_to_list
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and to_list :: "'s \<Rightarrow> ('u \<times> 'v) list"
  assumes "map_to_list \<alpha> invar to_list"
locale list_to_map
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and to_map :: "('u \<times> 'v) list \<Rightarrow> 's"
  assumes "list_to_map \<alpha> invar to_map"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
locale map_image_filter
  fixes \<alpha>1 :: "'m1 \<Rightarrow> 'u1 \<Rightarrow> 'v1 option"
    and invar1 :: "'m1 \<Rightarrow> bool"
    and \<alpha>2 :: "'m2 \<Rightarrow> 'u2 \<Rightarrow> 'v2 option"
    and invar2 :: "'m2 \<Rightarrow> bool"
    and
    map_image_filter ::
      "('u1 \<times> 'v1 \<Rightarrow> ('u2 \<times> 'v2) option)
       \<Rightarrow> 'm1 \<Rightarrow> 'm2"
  assumes
    "map_image_filter \<alpha>1 invar1 \<alpha>2 invar2 map_image_filter"
locale map_value_image_filter
  fixes \<alpha>1 :: "'m1 \<Rightarrow> 'u \<Rightarrow> 'v1 option"
    and invar1 :: "'m1 \<Rightarrow> bool"
    and \<alpha>2 :: "'m2 \<Rightarrow> 'u \<Rightarrow> 'v2 option"
    and invar2 :: "'m2 \<Rightarrow> bool"
    and
    map_value_image_filter ::
      "('u \<Rightarrow> 'v1 \<Rightarrow> 'v2 option)
       \<Rightarrow> 'm1 \<Rightarrow> 'm2"
  assumes
    "map_value_image_filter \<alpha>1 invar1 \<alpha>2 invar2
      map_value_image_filter"
locale map_restrict
  fixes \<alpha>1 :: "'m1 \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar1 :: "'m1 \<Rightarrow> bool"
    and \<alpha>2 :: "'m2 \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar2 :: "'m2 \<Rightarrow> bool"
    and
    restrict ::
      "('u \<times> 'v \<Rightarrow> bool)
       \<Rightarrow> 'm1 \<Rightarrow> 'm2"
  assumes "map_restrict \<alpha>1 invar1 \<alpha>2 invar2 restrict"
consts
  gmnl :: "('e, 'a) Node list \<Rightarrow> 'a"
locale ordered_map
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
locale ordered_finite_map
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
  assumes "ordered_finite_map \<alpha> invar"
locale poly_map_iterateoi_defs
  fixes
    olist_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
locale poly_map_iterateoi
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    list_ordered_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
  assumes "poly_map_iterateoi \<alpha> invar list_ordered_it"
locale poly_map_rev_iterateoi_defs
  fixes
    list_rev_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
locale poly_map_rev_iterateoi
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    list_rev_it ::
      "'s \<Rightarrow> (('u \<times> 'v) list \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v
 \<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list)
\<Rightarrow> ('u \<times> 'v) list \<Rightarrow> ('u \<times> 'v) list"
  assumes "poly_map_rev_iterateoi \<alpha> invar list_rev_it"
locale map_min
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    min ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v) option"
  assumes "map_min \<alpha> invar min"
locale map_max
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and
    max ::
      "'s \<Rightarrow> ('u \<times> 'v \<Rightarrow> bool)
                        \<Rightarrow> ('u \<times> 'v) option"
  assumes "map_max \<alpha> invar max"
locale map_to_sorted_list
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and to_sorted_list :: "'s \<Rightarrow> ('u \<times> 'v) list"
  assumes "MapSpec.map_to_sorted_list \<alpha> invar to_sorted_list"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
locale map_to_rev_list
  fixes \<alpha> :: "'s \<Rightarrow> 'u \<Rightarrow> 'v option"
    and invar :: "'s \<Rightarrow> bool"
    and to_rev_list :: "'s \<Rightarrow> ('u \<times> 'v) list"
  assumes "map_to_rev_list \<alpha> invar to_rev_list"
consts
  foldl_digit ::
    "('s \<Rightarrow> 'e \<times> 'a \<Rightarrow> 's)
     \<Rightarrow> 's \<Rightarrow> ('e, 'a) Digit \<Rightarrow> 's"
consts
  foldr_node ::
    "('e \<times> 'a \<Rightarrow> 's \<Rightarrow> 's)
     \<Rightarrow> ('e, 'a) Node \<Rightarrow> 's \<Rightarrow> 's"
consts
  foldr_digit ::
    "('e \<times> 'a \<Rightarrow> 's \<Rightarrow> 's)
     \<Rightarrow> ('e, 'a) Digit \<Rightarrow> 's \<Rightarrow> 's"
consts
  foldl ::
    "('s \<Rightarrow> 'e \<times> 'a \<Rightarrow> 's)
     \<Rightarrow> 's \<Rightarrow> ('e, 'a) FingerTreeStruc
                                    \<Rightarrow> 's"
consts
  foldr ::
    "('e \<times> 'a \<Rightarrow> 's \<Rightarrow> 's)
     \<Rightarrow> ('e, 'a) FingerTreeStruc
                   \<Rightarrow> 's \<Rightarrow> 's"
locale SkewBinomialHeap_loc
consts
  count_node :: "('e, 'a) Node \<Rightarrow> nat"
consts
  count_digit :: "('e, 'a) Digit \<Rightarrow> nat"
consts
  count :: "('e, 'a) FingerTreeStruc \<Rightarrow> nat"
### theory "Binomial-Heaps.SkewBinomialHeap"
### 8.528s elapsed time, 57.103s cpu time, 8.354s GC time
locale StdMapDefs
  fixes ops :: "('k, 'v, 's, 'more) map_ops_scheme"
locale FingerTree_loc
locale StdMap
  fixes ops :: "('k, 'v, 's, 'more) map_ops_scheme"
  assumes "StdMap ops"
### theory "Finger-Trees.FingerTree"
### 12.459s elapsed time, 75.724s cpu time, 19.146s GC time
locale StdMap_no_invar
  fixes ops :: "('a, 'b, 'c, 'd) map_ops_scheme"
  assumes "StdMap_no_invar ops"
*** Interrupt

==========
Complex_Geometry
Loading theory "Complex_Geometry.Linear_Systems"
Loading theory "Complex_Geometry.More_Set"
Loading theory "HOL-Library.Product_Plus" (required by "Complex_Geometry.Riemann_Sphere" via "HOL-Analysis.Product_Vector")
Loading theory "Complex_Geometry.More_Transcendental"
Loading theory "HOL-Analysis.L2_Norm" (required by "Complex_Geometry.Chordal_Metric" via "HOL-Analysis.Euclidean_Space")
Loading theory "HOL-Analysis.Inner_Product" (required by "Complex_Geometry.Chordal_Metric")
Loading theory "HOL-Library.Quadratic_Discriminant" (required by "Complex_Geometry.Quadratic")
instantiation
  prod :: (zero, zero) zero
  zero_prod == zero_class.zero :: 'a \<times> 'b
instantiation
  prod :: (plus, plus) plus
  plus_prod == plus ::
    'a \<times> 'b \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
instantiation
  prod :: (minus, minus) minus
  minus_prod == minus ::
    'a \<times> 'b \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
### theory "Complex_Geometry.More_Set"
### 0.059s elapsed time, 0.460s cpu time, 0.035s GC time
instantiation
  prod :: (uminus, uminus) uminus
  uminus_prod == uminus :: 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
### theory "Complex_Geometry.Linear_Systems"
### 0.072s elapsed time, 0.548s cpu time, 0.035s GC time
### theory "HOL-Library.Quadratic_Discriminant"
### 0.099s elapsed time, 0.776s cpu time, 0.035s GC time
### theory "HOL-Analysis.L2_Norm"
### 0.100s elapsed time, 0.782s cpu time, 0.035s GC time
### theory "HOL-Library.Product_Plus"
### 0.119s elapsed time, 0.931s cpu time, 0.035s GC time
Loading theory "HOL-Analysis.Product_Vector" (required by "Complex_Geometry.Riemann_Sphere")
### theory "Complex_Geometry.More_Transcendental"
### 0.137s elapsed time, 1.072s cpu time, 0.035s GC time
Loading theory "Complex_Geometry.Canonical_Angle"
### theory "Complex_Geometry.Canonical_Angle"
### 0.113s elapsed time, 0.774s cpu time, 0.077s GC time
Loading theory "Complex_Geometry.More_Complex"
locale module_prod
  fixes s1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "module_prod s1 s2"
locale vector_space_prod
  fixes
    s1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*a\<close> 75)
    and
    s2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>*b\<close> 75)
  assumes "vector_space_prod (*a) (*b)"
instantiation
  prod :: (real_vector, real_vector) real_vector
  scaleR_prod == scaleR ::
    real \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
instantiation
  prod :: (metric_space, metric_space) dist
  dist_prod == dist ::
    'a \<times> 'b \<Rightarrow> 'a \<times> 'b \<Rightarrow> real
instantiation
  prod :: (metric_space, metric_space) uniformity_dist
  uniformity_prod == uniformity ::
    (('a \<times> 'b) \<times> 'a \<times> 'b) filter
instantiation
  prod :: (metric_space, metric_space) metric_space
instantiation
  prod :: (real_normed_vector, real_normed_vector) real_normed_vector
  sgn_prod == sgn :: 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
  norm_prod == norm :: 'a \<times> 'b \<Rightarrow> real
### theory "Complex_Geometry.More_Complex"
### 0.351s elapsed time, 2.400s cpu time, 0.171s GC time
Loading theory "Complex_Geometry.Angles"
Loading theory "Complex_Geometry.Quadratic"
class real_inner = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  fixes inner :: "'a \<Rightarrow> 'a \<Rightarrow> real"
  assumes "inner_commute": "\<And>x y. inner x y = inner y x"
    and
    "inner_add_left": "\<And>x y z. inner (x + y) z = inner x z + inner y z"
    and
    "inner_scaleR_left":
      "\<And>r x y. inner (r *\<^sub>R x) y = r * inner x y"
    and "inner_ge_zero": "\<And>x. 0 \<le> inner x x"
    and "inner_eq_zero_iff": "\<And>x. (inner x x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "\<And>x. norm x = sqrt (inner x x)"
locale finite_dimensional_vector_space_prod
  fixes
    s1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*a\<close> 75)
    and
    s2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>*b\<close> 75)
    and B1 :: "'b set"
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_prod (*a) (*b) B1 B2"
### theory "HOL-Analysis.Product_Vector"
### 0.590s elapsed time, 4.059s cpu time, 0.293s GC time
### theory "Complex_Geometry.Angles"
### 0.218s elapsed time, 1.463s cpu time, 0.610s GC time
Loading theory "Complex_Geometry.Elementary_Complex_Geometry"
### theory "Complex_Geometry.Quadratic"
### 0.418s elapsed time, 2.877s cpu time, 0.623s GC time
Loading theory "Complex_Geometry.Matrices"
instantiation
  real :: real_inner
  inner_real == inner :: real \<Rightarrow> real \<Rightarrow> real
instantiation
  complex :: real_inner
  inner_complex == inner :: complex \<Rightarrow> complex \<Rightarrow> real
bundle inner_syntax
bundle no_inner_syntax
### theory "HOL-Analysis.Inner_Product"
### 1.306s elapsed time, 9.061s cpu time, 1.041s GC time
Loading theory "HOL-Analysis.Euclidean_Space" (required by "Complex_Geometry.Chordal_Metric")
### theory "Complex_Geometry.Elementary_Complex_Geometry"
### 0.517s elapsed time, 3.466s cpu time, 0.148s GC time
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
class euclidean_space = real_inner +
  fixes Basis :: "'a set"
  assumes "nonempty_Basis": "Basis \<noteq> {}"
  assumes "finite_Basis": "finite Basis"
  assumes
    "inner_Basis":
      "\<And>u v.
          \<lbrakk>u \<in> Basis; v \<in> Basis\<rbrakk>
          \<Longrightarrow> inner u v = (if u = v then 1 else 0)"
  assumes
    "euclidean_all_zero_iff":
      "\<And>x. (\<forall>u\<in>Basis. inner x u = 0) = (x = (0::'a))"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Complex_Geometry.Matrices"
### 1.602s elapsed time, 10.572s cpu time, 0.611s GC time
Loading theory "Complex_Geometry.Homogeneous_Coordinates"
Loading theory "Complex_Geometry.Unitary11_Matrices"
Loading theory "Complex_Geometry.Unitary_Matrices"
### theory "Complex_Geometry.Unitary_Matrices"
### 0.096s elapsed time, 0.668s cpu time, 0.056s GC time
Loading theory "Complex_Geometry.Hermitean_Matrices"
### theory "Complex_Geometry.Unitary11_Matrices"
### 0.205s elapsed time, 1.465s cpu time, 0.116s GC time
instantiation
  real :: euclidean_space
  Basis_real == Basis :: real set
instantiation
  complex :: euclidean_space
  Basis_complex == Basis :: complex set
instantiation
  prod :: (real_inner, real_inner) real_inner
  inner_prod == inner ::
    'a \<times> 'b \<Rightarrow> 'a \<times> 'b \<Rightarrow> real
### theory "Complex_Geometry.Hermitean_Matrices"
### 0.094s elapsed time, 0.665s cpu time, 0.051s GC time
instantiation
  prod :: (euclidean_space, euclidean_space) euclidean_space
  Basis_prod == Basis :: ('a \<times> 'b) set
### theory "HOL-Analysis.Euclidean_Space"
### 1.842s elapsed time, 12.319s cpu time, 0.744s GC time
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
### theory "Complex_Geometry.Homogeneous_Coordinates"
### 0.607s elapsed time, 4.253s cpu time, 0.316s GC time
Loading theory "Complex_Geometry.Moebius"
instantiation
  moebius :: group_add
  minus_moebius == minus ::
    moebius \<Rightarrow> moebius \<Rightarrow> moebius
  uminus_moebius == uminus_class.uminus :: moebius \<Rightarrow> moebius
  zero_moebius == zero_class.zero :: moebius
  plus_moebius == plus ::
    moebius \<Rightarrow> moebius \<Rightarrow> moebius
### theory "Complex_Geometry.Moebius"
### 0.963s elapsed time, 6.823s cpu time, 0.323s GC time
Loading theory "Complex_Geometry.Circlines"
### theory "Complex_Geometry.Circlines"
### 1.777s elapsed time, 11.335s cpu time, 0.478s GC time
Loading theory "Complex_Geometry.Oriented_Circlines"
Loading theory "Complex_Geometry.Riemann_Sphere"
Found termination order: "{}"
### theory "Complex_Geometry.Riemann_Sphere"
### 0.515s elapsed time, 2.400s cpu time, 0.110s GC time
### theory "Complex_Geometry.Oriented_Circlines"
### 0.620s elapsed time, 3.097s cpu time, 0.174s GC time
Loading theory "Complex_Geometry.Circlines_Angle"
Loading theory "Complex_Geometry.Unit_Circle_Preserving_Moebius"
Loading theory "Complex_Geometry.Chordal_Metric"
Found termination order: "{}"
### theory "Complex_Geometry.Circlines_Angle"
### 0.168s elapsed time, 1.298s cpu time, 0.072s GC time
instantiation
  complex_homo :: metric_space
  dist_complex_homo == dist ::
    complex_homo \<Rightarrow> complex_homo \<Rightarrow> real
  uniformity_complex_homo == uniformity ::
    (complex_homo \<times> complex_homo) filter
  open_complex_homo == open :: complex_homo set \<Rightarrow> bool
### theory "Complex_Geometry.Chordal_Metric"
### 0.391s elapsed time, 1.963s cpu time, 0.109s GC time
### theory "Complex_Geometry.Unit_Circle_Preserving_Moebius"
### 0.859s elapsed time, 5.090s cpu time, 1.841s GC time
*** Inner syntax error (line 427 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Complex_Geometry/Chordal_Metric.thy")
*** at ": { 0 <..} . principal { ( x , y ) . dist_class.dist x y < e } )"
*** Failed to parse prop
*** At command "definition" (line 427 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Complex_Geometry/Chordal_Metric.thy")

==========
CoreC++
Loading theory "CoreC++.Auxiliary" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj" via "CoreC++.ClassRel" via "CoreC++.Decl" via "CoreC++.Expr" via "CoreC++.Value" via "CoreC++.Type")
### Ignoring duplicate safe elimination (elim!)
### \<lbrakk>?x # ?xs = map ?f ?ys;
###  \<exists>z zs.
###     ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
###  PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Ignoring duplicate safe elimination (elim!)
### \<lbrakk>?x # ?xs = map ?f ?ys;
###  \<exists>z zs.
###     ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
###  PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Ignoring duplicate rewrite rule:
### (?f1(?x1 := ?y1)) ?z1 \<equiv> if ?z1 = ?x1 then ?y1 else ?f1 ?z1
### theory "CoreC++.Auxiliary"
### 0.277s elapsed time, 0.658s cpu time, 0.022s GC time
Loading theory "CoreC++.Type" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj" via "CoreC++.ClassRel" via "CoreC++.Decl" via "CoreC++.Expr" via "CoreC++.Value")
consts
  getbase :: "base \<Rightarrow> char list"
consts
  isRepBase :: "base \<Rightarrow> bool"
consts
  isShBase :: "base \<Rightarrow> bool"
### theory "CoreC++.Type"
### 0.505s elapsed time, 0.973s cpu time, 0.081s GC time
Loading theory "CoreC++.Value" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj" via "CoreC++.ClassRel" via "CoreC++.Decl" via "CoreC++.Expr")
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Ref"
consts
  the_Intg :: "val \<Rightarrow> int"
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Intg"
consts
  the_addr :: "val \<Rightarrow> nat"
### No equation for constructor "Unit"
### No equation for constructor "Null"
### No equation for constructor "Bool"
### No equation for constructor "Intg"
consts
  the_path :: "val \<Rightarrow> char list list"
consts
  default_val :: "ty \<Rightarrow> val"
consts
  typeof :: "val \<Rightarrow> ty option"
### theory "CoreC++.Value"
### 0.309s elapsed time, 0.527s cpu time, 0.052s GC time
Loading theory "CoreC++.Expr" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj" via "CoreC++.ClassRel" via "CoreC++.Decl")
Found termination order: "{}"
### Ambiguous input (line 80 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Expr.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" fv)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("\<^const>Set.union" ("_Finset" ("_position" V))
###       ("_applC" ("_position" fv) ("_position" e)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" e)))
###     ("\<^const>Set.union" ("_Finset" ("_position" V))
###       ("_applC" ("_position" fv) ("_position" e)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 82 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Expr.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" fv)
###       ("_updbind"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2)))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" fv) ("_position" e\<^sub>1))
###       ("_applC" ("_position" fv) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  fv :: "expr \<Rightarrow> char list set"
  fvs :: "expr list \<Rightarrow> char list set"
### theory "CoreC++.Expr"
### 2.228s elapsed time, 7.805s cpu time, 1.665s GC time
Loading theory "CoreC++.Decl" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj" via "CoreC++.ClassRel")
### Ignoring duplicate safe elimination (elim!)
### \<lbrakk>\<exists>x\<in>?A. ?P x;
###  \<And>x. \<lbrakk>x \<in> ?A; ?P x\<rbrakk> \<Longrightarrow> ?Q\<rbrakk>
### \<Longrightarrow> ?Q
### theory "CoreC++.Decl"
### 0.059s elapsed time, 0.170s cpu time, 0.000s GC time
Loading theory "CoreC++.ClassRel" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects" via "CoreC++.SubObj")
Proofs for inductive predicate(s) "subclsRp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "subclsSp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "subcls1p"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "CoreC++.ClassRel"
### 0.131s elapsed time, 0.212s cpu time, 0.029s GC time
Loading theory "CoreC++.SubObj" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions" via "CoreC++.Objects")
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
Proofs for inductive predicate(s) "Subobjs\<^sub>R"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "Subobjs"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "casts_to"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "Casts_to"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "leq_path1p"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ambiguous input (line 720 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SubObj.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" MinimalMethodDefs)
###     ("_cargs" ("_position" P) ("_cargs" ("_position" C) ("_position" M))))
###   ("_Coll" ("_pattern" ("_position" Cs) ("_position" mthd))
###     ("\<^const>HOL.conj"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Cs) ("_tuple_arg" ("_position" mthd)))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M)))))
###       ("_Ball" ("_pattern" ("_position" Cs') ("_position" mthd'))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M))))
###         ("\<^const>HOL.eq"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Cs')
###             ("\<^const>HOL.implies" ("_position" Cs) ("_position" Cs')))
###           ("_position" Cs))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" MinimalMethodDefs)
###     ("_cargs" ("_position" P) ("_cargs" ("_position" C) ("_position" M))))
###   ("_Coll" ("_pattern" ("_position" Cs) ("_position" mthd))
###     ("\<^const>HOL.conj"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Cs) ("_tuple_arg" ("_position" mthd)))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M)))))
###       ("_Ball" ("_pattern" ("_position" Cs') ("_position" mthd'))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M))))
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###           ("_position" Cs')
###           ("\<^const>HOL.implies" ("_position" Cs)
###             ("\<^const>HOL.eq" ("_position" Cs') ("_position" Cs))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" MinimalMethodDefs)
###     ("_cargs" ("_position" P) ("_cargs" ("_position" C) ("_position" M))))
###   ("_Coll" ("_pattern" ("_position" Cs) ("_position" mthd))
###     ("\<^const>HOL.conj"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Cs) ("_tuple_arg" ("_position" mthd)))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M)))))
###       ("_Ball" ("_pattern" ("_position" Cs') ("_position" mthd'))
###         ("_applC" ("_position" MethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C) ("_position" M))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Cs') ("_position" Cs))
###           ("\<^const>HOL.eq" ("_position" Cs') ("_position" Cs)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 725 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SubObj.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" OverriderMethodDefs)
###     ("_cargs" ("_position" P) ("_cargs" ("_position" R) ("_position" M))))
###   ("_Coll" ("_pattern" ("_position" Cs) ("_position" mthd))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" Cs') ("_position" mthd'))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###           ("_applC" ("_position" ldc) ("_position" R)) ("_position" M)
###           ("_position" mthd') ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" Cs) ("_tuple_arg" ("_position" mthd)))
###             ("_applC" ("_position" MinimalMethodDefs)
###               ("_cargs" ("_position" P)
###                 ("_cargs" ("_applC" ("_position" mdc) ("_position" R))
###                   ("_position" M)))))
###           ("\<^const>SubObj.appendPath"
###             ("\<^const>SubObj.leq_path" ("_position" P)
###               ("_applC" ("_position" mdc) ("_position" R)) ("_position" Cs)
###               ("_applC" ("_position" snd) ("_position" R)))
###             ("_position" Cs')))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" OverriderMethodDefs)
###     ("_cargs" ("_position" P) ("_cargs" ("_position" R) ("_position" M))))
###   ("_Coll" ("_pattern" ("_position" Cs) ("_position" mthd))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" Cs') ("_position" mthd'))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###           ("_applC" ("_position" ldc) ("_position" R)) ("_position" M)
###           ("_position" mthd') ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" Cs) ("_tuple_arg" ("_position" mthd)))
###             ("_applC" ("_position" MinimalMethodDefs)
###               ("_cargs" ("_position" P)
###                 ("_cargs" ("_applC" ("_position" mdc) ("_position" R))
###                   ("_position" M)))))
###           ("\<^const>SubObj.leq_path" ("_position" P)
###             ("_applC" ("_position" mdc) ("_position" R)) ("_position" Cs)
###             ("\<^const>SubObj.appendPath"
###               ("_applC" ("_position" snd) ("_position" R))
###               ("_position" Cs'))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "SelectMethodDef"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "CoreC++.SubObj"
### 0.719s elapsed time, 1.782s cpu time, 0.141s GC time
Loading theory "CoreC++.Objects" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax" via "CoreC++.Exceptions")
Loading theory "CoreC++.TypeRel" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.WWellForm" via "CoreC++.WellForm")
Proofs for inductive predicate(s) "init_obj"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "widen"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "CoreC++.TypeRel"
### 0.045s elapsed time, 0.179s cpu time, 0.000s GC time
### theory "CoreC++.Objects"
### 0.058s elapsed time, 0.194s cpu time, 0.000s GC time
Loading theory "CoreC++.Exceptions" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep" via "CoreC++.Syntax")
### Ignoring duplicate rewrite rule:
### (?f1(?x1 := ?y1)) ?z1 \<equiv> if ?z1 = ?x1 then ?y1 else ?f1 ?z1
### Ignoring duplicate rewrite rule:
### (?f1(?x1 := ?y1)) ?z1 \<equiv> if ?z1 = ?x1 then ?y1 else ?f1 ?z1
### theory "CoreC++.Exceptions"
### 0.072s elapsed time, 0.179s cpu time, 0.048s GC time
Loading theory "CoreC++.State" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep")
Loading theory "CoreC++.Syntax" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.BigStep")
Loading theory "CoreC++.SystemClasses" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.WWellForm" via "CoreC++.WellForm")
### theory "CoreC++.Syntax"
### 0.018s elapsed time, 0.102s cpu time, 0.000s GC time
Loading theory "CoreC++.WellType" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.WWellForm" via "CoreC++.WellForm")
### theory "CoreC++.State"
### 0.019s elapsed time, 0.104s cpu time, 0.000s GC time
Loading theory "CoreC++.BigStep" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence")
Loading theory "CoreC++.SmallStep" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence")
### theory "CoreC++.SystemClasses"
### 0.047s elapsed time, 0.221s cpu time, 0.000s GC time
### Ambiguous input (line 172 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 123 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asms"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg" ("_position" fs)))
###                     ("_position" S)))
###                 ("_asms"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" fs')
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v')))))
###                   ("_asms"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" S')
###                         ("\<^const>Set.union"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" S)
###                             ("_Finset"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))))
###                           ("_Finset"
###                             ("_tuple" ("_position" Ds)
###                               ("_tuple_arg" ("_position" fs')))))))
###                     ("_asm"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                           ("_MapUpd" ("_position" h\<^sub>2)
###                             ("_maplet" ("_position" a)
###                               ("_tuple" ("_position" D)
###                                 ("_tuple_arg"
###                                   ("_position" S')))))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asms"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg" ("_position" fs)))
###                     ("_position" S)))
###                 ("_asms"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" fs')
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v')))))
###                   ("_asms"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" S')
###                         ("\<^const>Set.union"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" S)
###                             ("_Finset"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))))
###                           ("_Finset"
###                             ("_tuple" ("_position" Ds)
###                               ("_tuple_arg" ("_position" fs')))))))
###                     ("_asm"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                           ("_MapUpd" ("_position" h\<^sub>2)
###                             ("_maplet" ("_position" a)
###                               ("_tuple" ("_position" D)
###                                 ("_tuple_arg"
###                                   ("_position" S')))))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 130 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 134 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 62 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" Cs)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" T))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WT" ("_position" P) ("_position" E) ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###           ("_position" F) ("_position" T) ("_position" Cs)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^fixed>WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T')))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" T))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 138 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>eval" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>eval" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>eval" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 17 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" blocks)
###       ("_tuple" ("\<^const>List.list.Cons" ("_position" V) ("_position" Vs))
###         ("_tuple_args"
###           ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts))
###           ("_tuple_args"
###             ("\<^const>List.list.Cons" ("_position" v) ("_position" vs))
###             ("_tuple_arg" ("_position" e))))))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" blocks)
###         ("_tuple" ("_position" Vs)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" vs)
###               ("_tuple_arg" ("_position" e)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" blocks)
###       ("_tuple" ("\<^const>List.list.Cons" ("_position" V) ("_position" Vs))
###         ("_tuple_args"
###           ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts))
###           ("_tuple_args"
###             ("\<^const>List.list.Cons" ("_position" v) ("_position" vs))
###             ("_tuple_arg" ("_position" e))))))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" blocks)
###         ("_tuple" ("_position" Vs)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" vs)
###               ("_tuple_arg" ("_position" e)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Missing patterns in function definition:
### \<And>vc vd vb. blocks ([], vc # vd, vb) = undefined
### \<And>v ve vf vd. blocks ([], v, ve # vf, vd) = undefined
### \<And>va vb vc. blocks (va # vb, [], vc) = undefined
### (3 more)
Proofs for inductive predicate(s) "WT", "WTs"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order:
  "(\<lambda>p. size_list size (fst (snd (snd p)))) <*mlex*> {}"
### Ignoring duplicate safe introduction (intro!)
### ?P,?E \<turnstile> [] [::] []
### Ignoring duplicate safe introduction (intro!)
### ?P,?E \<turnstile> [] [::] []
Found termination order:
  "(\<lambda>p. size_list size (fst (snd (snd p)))) <*mlex*> {}"
### Ambiguous input (line 144 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e') ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e') ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss" ("_position" e') ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss" ("_position" e') ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Throw) ("_position" r)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###     ("_position" s)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss"
###       ("_applC" ("_position" Throw) ("_position" r)) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###     ("_position" s)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E) ("_position" e)
###       ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e'))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###     ("_position" s)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs)
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###     ("_position" s)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 186 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_position" None)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_position" None)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_position" None)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_position" None)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 152 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###         ("_applC" ("_position" Some)
###           ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###           ("_applC" ("_position" last) ("_position" Cs')) ("_position" F)
###           ("_position" T) ("_position" Cs)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v')))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" Ds)
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))
###                 ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" ref)
###             ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###           ("_position" F) ("_position" Cs))
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple"
###         ("_MapUpd" ("_position" h)
###           ("_maplet" ("_position" a)
###             ("_tuple" ("_position" D)
###               ("_tuple_arg"
###                 ("_applC" ("_position" insert)
###                   ("_cargs"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg"
###                         ("_MapUpd" ("_position" fs)
###                           ("_maplet" ("_position" F) ("_position" v')))))
###                     ("\<^const>Groups.minus_class.minus" ("_position" S)
###                       ("_Finset"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))))))))))
###         ("_tuple_arg" ("_position" l))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###         ("_applC" ("_position" Some)
###           ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###           ("_applC" ("_position" last) ("_position" Cs')) ("_position" F)
###           ("_position" T) ("_position" Cs)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v')))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" Ds)
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))
###                 ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" F) ("_position" Cs)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple"
###         ("_MapUpd" ("_position" h)
###           ("_maplet" ("_position" a)
###             ("_tuple" ("_position" D)
###               ("_tuple_arg"
###                 ("_applC" ("_position" insert)
###                   ("_cargs"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg"
###                         ("_MapUpd" ("_position" fs)
###                           ("_maplet" ("_position" F) ("_position" v')))))
###                     ("\<^const>Groups.minus_class.minus" ("_position" S)
###                       ("_Finset"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))))))))))
###         ("_tuple_arg" ("_position" l))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 157 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" null) ("_position" F)
###         ("_position" Cs))
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" null) ("_position" F)
###       ("_position" Cs) ("_applC" ("_position" Val) ("_position" v)))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 254 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v) ("_position" v')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_applC" ("_position" Throw) ("_position" r)))
###       ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v) ("_position" v')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_applC" ("_position" Throw) ("_position" r)))
###       ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" assigned)
###               ("_cargs" ("_position" V) ("_position" e))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>red'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V))
###           ("_applC" ("_position" Some) ("_position" v''))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e))
###       ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 203 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v) ("_position" v')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_applC" ("_position" Val) ("_position" u)))
###       ("_position" s) ("_applC" ("_position" Val) ("_position" u))
###       ("_position" s))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v) ("_position" v')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>red'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_applC" ("_position" Val) ("_position" u)))
###       ("_position" s) ("_applC" ("_position" Val) ("_position" u))
###       ("_position" s))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 122 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E) ("_position" e)
###       ("\<^const>HOL.conj" ("_position" T)
###         ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###           ("_position" es) ("_position" Ts))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>HOL.conj"
###       ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###         ("_position" e) ("_position" T))
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("_position" es) ("_position" Ts)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "eval", "evals"
### Ambiguous input (line 129 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("_position" Ts))
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" U) ("_position" Us))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts)
###           ("\<^const>List.list.Cons" ("_position" U) ("_position" Us)))
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e) ("_position" U))
###           ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###             ("_position" es) ("_position" Us)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("_position" Ts))
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" U) ("_position" Us))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts)
###           ("\<^const>List.list.Cons" ("_position" U) ("_position" Us)))
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e)
###           ("\<^const>HOL.conj" ("_position" U)
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es) ("_position" Us))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 137 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" Ts)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>HOL.conj"
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es\<^sub>1) ("_position" Ts\<^sub>1))
###             ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###               ("_position" es\<^sub>2) ("_position" Ts\<^sub>2))))))))
### ("\<^const>Pure.all_binder" ("_position" Ts)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###             ("_position" es\<^sub>1)
###             ("\<^const>HOL.conj" ("_position" Ts\<^sub>1)
###               ("\<^const>WellType.WTs" ("_position" P) ("_position" E)
###                 ("_position" es\<^sub>2) ("_position" Ts\<^sub>2)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 154 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" T))
###     ("\<^const>HOL.eq" ("_applC" ("_position" typeof) ("_position" v))
###       ("_applC" ("_position" Some) ("_position" T)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("_applC" ("_position" Val) ("_position" v))
###     ("\<^const>HOL.eq" ("_position" T)
###       ("\<^const>HOL.eq" ("_applC" ("_position" typeof) ("_position" v))
###         ("_applC" ("_position" Some) ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate safe introduction (intro!)
### typeof ?v = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E \<turnstile> Val ?v :: ?T
### Ignoring duplicate safe introduction (intro!)
### typeof ?v = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E \<turnstile> Val ?v :: ?T
### Ambiguous input (line 161 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V)) ("_position" T))
###     ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###       ("_applC" ("_position" Some) ("_position" T)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("_applC" ("_position" Var) ("_position" V))
###     ("\<^const>HOL.eq" ("_position" T)
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_applC" ("_position" Some) ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E \<turnstile> Var ?V :: ?T
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E \<turnstile> Var ?V :: ?T
### Ambiguous input (line 168 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Seq" ("_position" e\<^sub>1)
###         ("_position" e\<^sub>2))
###       ("_position" T\<^sub>2))
###     ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###       ("\<^const>HOL.conj"
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>1) ("_position" T\<^sub>1))
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" T\<^sub>2))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Seq" ("_position" e\<^sub>1)
###       ("_position" e\<^sub>2))
###     ("\<^const>HOL.eq" ("_position" T\<^sub>2)
###       ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>1) ("_position" T\<^sub>1))
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T\<^sub>2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Seq" ("_position" e\<^sub>1)
###         ("_position" e\<^sub>2))
###       ("_position" T\<^sub>2))
###     ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###       ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1)
###         ("\<^const>HOL.conj" ("_position" T\<^sub>1)
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e\<^sub>2) ("_position" T\<^sub>2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Seq" ("_position" e\<^sub>1)
###       ("_position" e\<^sub>2))
###     ("\<^const>HOL.eq" ("_position" T\<^sub>2)
###       ("\<^const>HOL.Ex_binder" ("_position" T\<^sub>1)
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>1)
###           ("\<^const>HOL.conj" ("_position" T\<^sub>1)
###             ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###               ("_position" e\<^sub>2) ("_position" T\<^sub>2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
  Proving the introduction rules ...
### Ambiguous input (line 190 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellType.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###         ("_position" Cs))
###       ("_position" v))
###     ("_position" T)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###       ("_position" Cs) ("_position" v))
###     ("_position" T)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "CoreC++.WellType"
### 0.610s elapsed time, 2.787s cpu time, 0.275s GC time
Loading theory "CoreC++.Annotate" (required by "CoreC++.CoreC++")
### Ambiguous input (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Annotate.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("_position" T))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V))
###       ("_applC" ("_position" Var) ("_position" V)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###       ("\<^const>Option.option.Some" ("_position" T))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V))
###       ("_applC" ("_position" Var) ("_position" V)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 33 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Annotate.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_position" None)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" this))
###           ("\<^const>Option.option.Some"
###             ("_applC" ("_position" Class) ("_position" C)))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" V) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V))
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Var) ("_position" this)) ("_position" V)
###         ("_position" Cs)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_position" None)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" this))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_applC" ("_position" Class) ("_position" C)))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" V) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("_applC" ("_position" Var) ("_position" V))
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Var) ("_position" this)) ("_position" V)
###         ("_position" Cs)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_position" None)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" this))
###           ("\<^const>Option.option.Some"
###             ("_applC" ("_position" Class) ("_position" C)))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" V) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.FAcc"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E)
###         ("_applC" ("_position" Var) ("_position" V))
###         ("_applC" ("_position" Var) ("_position" this)))
###       ("_position" V) ("_position" Cs))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_position" None)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" this))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_applC" ("_position" Class) ("_position" C)))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" V) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.FAcc"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E)
###         ("_applC" ("_position" Var) ("_position" V))
###         ("_applC" ("_position" Var) ("_position" this)))
###       ("_position" V) ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 41 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Annotate.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e)
###         ("_position" e')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e') ("_applC" ("_position" Class) ("_position" C))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" F) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###         ("\<^const>List.list.Nil"))
###       ("\<^const>Expr.expr.FAcc" ("_position" e') ("_position" F)
###         ("_position" Cs)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e)
###         ("_position" e')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###           ("_position" e') ("_applC" ("_position" Class) ("_position" C))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" F) ("_position" T) ("_position" Cs))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.FAcc"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("\<^const>List.list.Nil"))
###         ("_position" e'))
###       ("_position" F) ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Annotate.thy") produces 8 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.FAss"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.FAss" ("_position" e1) ("_position" F)
###           ("\<^const>List.list.Nil") ("_position" e2))
###         ("_position" e1'))
###       ("_position" F) ("_position" Cs) ("_position" e2'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.FAss" ("_position" e1) ("_position" F)
###             ("\<^const>List.list.Nil") ("_position" e2))
###           ("_position" e1'))
###         ("_position" F) ("_position" Cs))
###       ("_position" e2'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e1) ("_position" F)
###           ("\<^const>List.list.Nil"))
###         ("_position" e2))
###       ("\<^const>Expr.expr.FAss" ("_position" e1') ("_position" F)
###         ("_position" Cs) ("_position" e2')))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e1) ("_position" F)
###         ("\<^const>List.list.Nil") ("_position" e2))
###       ("\<^const>Expr.expr.FAss" ("_position" e1') ("_position" F)
###         ("_position" Cs) ("_position" e2')))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e1) ("_position" F)
###           ("\<^const>List.list.Nil"))
###         ("_position" e2))
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e1') ("_position" F)
###           ("_position" Cs))
###         ("_position" e2')))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>Anno" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e1) ("_position" F)
###         ("\<^const>List.list.Nil") ("_position" e2))
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e1') ("_position" F)
###           ("_position" Cs))
###         ("_position" e2')))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.FAss"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc" ("_position" e1) ("_position" F)
###             ("\<^const>List.list.Nil"))
###           ("_position" e2))
###         ("_position" e1'))
###       ("_position" F) ("_position" Cs) ("_position" e2'))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e1)
###         ("_position" e1')))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E) ("_position" e2)
###           ("_position" e2')))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###             ("_position" e1')
###             ("_applC" ("_position" Class) ("_position" C))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_position" C) ("_position" F) ("_position" T)
###               ("_position" Cs)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("\<^fixed>Anno" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e1) ("_position" F)
###               ("\<^const>List.list.Nil"))
###             ("_position" e2))
###           ("_position" e1'))
###         ("_position" F) ("_position" Cs))
###       ("_position" e2'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "Anno", "Annos"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "redp", "redsp"
Loading theory "CoreC++.WellForm" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence" via "CoreC++.WWellForm")
Loading theory "CoreC++.WellTypeRT" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Conform")
consts
  typeof_h ::
    "(char list \<times>
      base list \<times>
      (char list \<times> ty) list \<times>
      (char list \<times>
       ty list \<times> ty \<times> char list list \<times> expr) list) list
     \<Rightarrow> (nat
                    \<Rightarrow> (char list \<times>
                                   (char list list \<times>
                                    (char list
                                     \<Rightarrow> val option)) set) option)
                   \<Rightarrow> val \<Rightarrow> ty option"
### Ambiguous input (line 99 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellTypeRT.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###         ("_position" e\<^sub>1) ("_position" NT)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###           ("_position" e\<^sub>2) ("_position" T')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" T))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###         ("_position" e\<^sub>1) ("_position" NT)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###           ("_position" e\<^sub>2) ("_position" T')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" T))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 94 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellTypeRT.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###         ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" Cs)
###           ("\<^const>List.list.Nil")))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" F) ("_position" T) ("_position" Cs)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###               ("_position" e\<^sub>2) ("_position" T')))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                 ("_position" T))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" T))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###         ("_position" e\<^sub>1)
###         ("_applC" ("_position" Class) ("_position" C))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" Cs)
###           ("\<^const>List.list.Nil")))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>SubObj.LeastFieldDecl" ("_position" P) ("_position" C)
###             ("_position" F) ("_position" T) ("_position" Cs)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###               ("_position" e\<^sub>2) ("_position" T')))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                 ("_position" T))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>WTrt" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" T))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.Annotate"
### 0.272s elapsed time, 1.454s cpu time, 0.140s GC time
Proofs for inductive predicate(s) "WTrt", "WTrts"
  Proving monotonicity ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the introduction rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
  Proving the elimination rules ...
### Ignoring duplicate safe introduction (intro!)
### ?P,?E,?h \<turnstile> [] [:] []
### Ignoring duplicate safe introduction (intro!)
### ?P,?E,?h \<turnstile> [] [:] []
  Proving the induction rule ...
### Ignoring duplicate rewrite rule:
### ?P1,?E1 \<turnstile> [] [::] [] \<equiv> True
  Proving the simplification rules ...
### Ignoring duplicate safe introduction (intro!)
### ?P \<turnstile> typeof\<^bsub>?h\<^esub> ?v =
### \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E,?h \<turnstile> Val ?v : ?T
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E,?h \<turnstile> Var ?V : ?T
### Ignoring duplicate safe introduction (intro!)
### ?P \<turnstile> typeof\<^bsub>?h\<^esub> ?v =
### \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E,?h \<turnstile> Val ?v : ?T
### Ignoring duplicate safe introduction (intro!)
### ?E ?V = \<lfloor>?T\<rfloor> \<Longrightarrow>
### ?P,?E,?h \<turnstile> Var ?V : ?T
### Ambiguous input (line 169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellTypeRT.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" Ts)
###     ("\<^const>HOL.eq"
###       ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###         ("_position" h)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>HOL.conj"
###             ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###               ("_position" h) ("_position" es\<^sub>1)
###               ("_position" Ts\<^sub>1))
###             ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###               ("_position" h) ("_position" es\<^sub>2)
###               ("_position" Ts\<^sub>2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" Ts)
###     ("\<^const>HOL.eq"
###       ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###         ("_position" h)
###         ("\<^const>List.append" ("_position" es\<^sub>1)
###           ("_position" es\<^sub>2))
###         ("_position" Ts))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" Ts\<^sub>1) ("_position" Ts\<^sub>2))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts)
###             ("\<^const>List.append" ("_position" Ts\<^sub>1)
###               ("_position" Ts\<^sub>2)))
###           ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###             ("_position" h) ("_position" es\<^sub>1)
###             ("\<^const>HOL.conj" ("_position" Ts\<^sub>1)
###               ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###                 ("_position" h) ("_position" es\<^sub>2)
###                 ("_position" Ts\<^sub>2)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate introduction (intro)
### (?a, ?b) \<in> ?r \<Longrightarrow> (?a, ?b) \<in> ?r\<^sup>+
### Ambiguous input (line 553 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C))
###       ("\<^const>List.append" ("_position" Cs) ("_list" ("_position" D))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>List.append"
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###         ("_list" ("_position" C)) ("_position" Cs))
###       ("_list" ("_position" D)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 194 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellTypeRT.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###     ("_position" h)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###         ("_position" Cs))
###       ("_position" v))
###     ("_position" T)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###     ("_position" h)
###     ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###       ("_position" Cs) ("_position" v))
###     ("_position" T)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 557 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C))
###       ("\<^const>List.append" ("_position" Cs) ("_list" ("_position" C))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>List.append"
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###         ("_list" ("_position" C)) ("_position" Cs))
###       ("_list" ("_position" C)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 559 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C))
###       ("\<^const>List.append" ("_position" Cs)
###         ("_list" ("_position" C'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>List.append"
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###         ("_list" ("_position" C)) ("_position" Cs))
###       ("_list" ("_position" C')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 563 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C)) ("_position" Cs))
###     ("_list" ("_position" C'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_list" ("_position" C))
###     ("\<^const>List.append" ("_position" Cs) ("_list" ("_position" C')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 574 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C))
###       ("\<^const>List.append" ("_position" Cs) ("_list" ("_position" D))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_position" Cs)
###     ("\<^const>List.append"
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###         ("_list" ("_position" C)) ("_position" Cs))
###       ("_list" ("_position" D)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 923 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs) ("_position" Cs'))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs)
###     ("\<^const>SubObj.appendPath" ("_position" Cs') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 609 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_list" ("_position" C)) ("_position" Ds))
###     ("_list" ("_position" D))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_list" ("_position" C))
###     ("\<^const>List.append" ("_position" Ds) ("_list" ("_position" D)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.WellTypeRT"
### 0.885s elapsed time, 6.737s cpu time, 1.493s GC time
Loading theory "CoreC++.Conform" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress")
### Ambiguous input (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>conf" ("_position" P) ("_position" h) ("_position" v)
###       ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.eq"
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("\<^const>WellTypeRT.typeof_h" ("_position" P) ("_position" h))
###           ("_position" v))
###         ("_applC"
###           ("\<^const>WellTypeRT.typeof_h"
###             ("\<^const>HOL.disj"
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" Class) ("_position" C)))
###               ("_position" P))
###             ("_position" h))
###           ("_position" v)))
###       ("_applC" ("_position" Some) ("_position" NT)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>conf" ("_position" P) ("_position" h) ("_position" v)
###       ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.disj"
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("\<^const>WellTypeRT.typeof_h" ("_position" P) ("_position" h))
###           ("_position" v))
###         ("_applC" ("_position" Some)
###           ("_applC" ("_position" Class) ("_position" C))))
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("\<^const>WellTypeRT.typeof_h" ("_position" P) ("_position" h))
###           ("_position" v))
###         ("_applC" ("_position" Some) ("_position" NT))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>conf" ("_position" P) ("_position" h) ("_position" v)
###       ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.eq"
###       ("_applC"
###         ("\<^const>WellTypeRT.typeof_h"
###           ("\<^const>HOL.disj"
###             ("\<^const>HOL.eq"
###               ("_applC"
###                 ("\<^const>WellTypeRT.typeof_h" ("_position" P)
###                   ("_position" h))
###                 ("_position" v))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" Class) ("_position" C))))
###             ("_position" P))
###           ("_position" h))
###         ("_position" v))
###       ("_applC" ("_position" Some) ("_position" NT)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>conf" ("_position" P) ("_position" h) ("_position" v)
###       ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.eq"
###       ("_applC"
###         ("\<^const>WellTypeRT.typeof_h" ("_position" P) ("_position" h))
###         ("_cargs"
###           ("\<^const>WellTypeRT.typeof_h"
###             ("\<^const>HOL.disj"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" Class) ("_position" C))))
###               ("_position" P))
###             ("_position" h))
###           ("_position" v)))
###       ("_applC" ("_position" Some) ("_position" NT)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>conf" ("_position" P) ("_position" h) ("_position" v)
###       ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.eq"
###       ("\<^const>HOL.eq"
###         ("_applC"
###           ("\<^const>WellTypeRT.typeof_h" ("_position" P) ("_position" h))
###           ("_position" v))
###         ("_applC" ("_position" Some)
###           ("_cargs"
###             ("\<^const>WellTypeRT.typeof_h"
###               ("\<^const>HOL.disj"
###                 ("_applC" ("_position" Class) ("_position" C))
###                 ("_position" P))
###               ("_position" h))
###             ("_position" v))))
###       ("_applC" ("_position" Some) ("_position" NT)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
consts
  conf ::
    "(char list \<times>
      base list \<times>
      (char list \<times> ty) list \<times>
      (char list \<times>
       ty list \<times> ty \<times> char list list \<times> expr) list) list
     \<Rightarrow> (nat
                    \<Rightarrow> (char list \<times>
                                   (char list list \<times>
                                    (char list
                                     \<Rightarrow> val option)) set) option)
                   \<Rightarrow> val \<Rightarrow> ty \<Rightarrow> bool"
### Ambiguous input (line 33 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("\<^fixed>hconf" ("_position" P) ("_position" h))
###   ("\<^const>HOL.conj"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_idts" ("_position" a) ("_position" obj))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###             ("_applC" ("_position" Some) ("_position" obj)))
###           ("_position" P)))
###       ("_tuple_arg" ("\<^fixed>hconf" ("_position" h) ("_position" obj))))
###     ("_applC" ("_position" preallocated) ("_position" h))))
### ("\<^const>Pure.eq" ("\<^fixed>hconf" ("_position" P) ("_position" h))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" a) ("_position" obj))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###           ("_applC" ("_position" Some) ("_position" obj)))
###         ("\<^const>Conform.oconf" ("_position" P) ("_position" h)
###           ("_position" obj))))
###     ("_applC" ("_position" preallocated) ("_position" h))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 929 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs) ("_position" Cs'))
###     ("_applC" ("_position" tl) ("_position" Cs))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs)
###     ("\<^const>List.append" ("_position" Cs')
###       ("_applC" ("_position" tl) ("_position" Cs)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 203 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("\<^fixed>envconf" ("_position" P) ("_position" E))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" V) ("_position" T))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_applC" ("_position" Some) ("_position" T)))
###       ("_applC" ("_position" is_type)
###         ("_cargs" ("_position" P) ("_position" T))))))
### ("\<^const>Pure.eq"
###   ("\<^const>Conform.hconf" ("_position" P) ("_position" E))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" V) ("_position" T))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###         ("_applC" ("_position" Some) ("_position" T)))
###       ("_applC" ("_position" is_type)
###         ("_cargs" ("_position" P) ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_position" Void))
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e) ("_position" Void))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_position" Void)
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" Void)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 212 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_position" Boolean))
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e) ("_position" Boolean))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_position" Boolean)
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" Boolean)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 213 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_position" Integer))
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e) ("_position" Integer))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_position" Integer)
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" Integer)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_position" NT))
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e) ("_position" NT))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_position" NT)
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" NT)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1647 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.not_equal" ("_position" Cs)
###                     ("\<^const>List.list.Nil"))
###                   ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                     ("_position" C) ("_position" M)
###                     ("_tuple" ("_position" Ts)
###                       ("_tuple_args" ("_position" T)
###                         ("_tuple_arg" ("_position" m))))
###                     ("_position" Cs))))
###               ("_position" Ts)))
###           ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.not_equal"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("_position" Cs)))
###             ("\<^const>List.list.Nil"))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###         ("_position" Ds)
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###           ("_position" Ds)
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs)))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.appendPath"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds) ("_position" Cs'))
###             ("_position" Cs))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.HasMethodDef"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("_position" P))))
###           ("_position" C) ("_position" M)
###           ("_tuple" ("_position" Ts)
###             ("_tuple_args" ("_position" T) ("_tuple_arg" ("_position" m))))
###           ("_position" Cs)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###           ("_position" Ds)
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                   ("_position" C) ("_position" M)
###                   ("_tuple" ("_position" Ts)
###                     ("_tuple_args" ("_position" T)
###                       ("_tuple_arg" ("_position" m))))
###                   ("_position" Cs))))
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 215 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e)
###       ("\<^const>HOL.disj" ("_applC" ("_position" Class) ("_position" C))
###         ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" e) ("_position" NT))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_applC" ("_position" Class) ("_position" C))
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e)
###         ("\<^const>HOL.disj" ("_applC" ("_position" Class) ("_position" C))
###           ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###             ("_position" h) ("_position" e) ("_position" NT)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" e) ("_applC" ("_position" Class) ("_position" C)))
###     ("\<^const>HOL.disj"
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e)
###         ("_applC" ("_position" Class) ("_position" C)))
###       ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" NT)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>type_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" e)
###     ("\<^const>HOL.iff" ("_applC" ("_position" Class) ("_position" C))
###       ("\<^const>HOL.disj"
###         ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" e)
###           ("_applC" ("_position" Class) ("_position" C)))
###         ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" e) ("_position" NT))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  type_conf ::
    "(char list \<times>
      base list \<times>
      (char list \<times> ty) list \<times>
      (char list \<times>
       ty list \<times> ty \<times> char list list \<times> expr) list) list
     \<Rightarrow> (char list \<Rightarrow> ty option)
                   \<Rightarrow> (nat
                                  \<Rightarrow> (char list \<times>
           (char list list \<times>
            (char list \<Rightarrow> val option)) set) option)
                                 \<Rightarrow> expr
         \<Rightarrow> ty \<Rightarrow> bool"
### Ambiguous input (line 222 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>List.list.Nil") ("\<^const>List.list.Nil"))
###     ("_position" True)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("\<^const>List.list.Nil")
###     ("\<^const>HOL.iff" ("\<^const>List.list.Nil") ("_position" True))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 223 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>Conform.type_conf" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e)
###       ("\<^const>HOL.conj" ("_position" T)
###         ("\<^fixed>types_conf" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" es) ("_position" Ts))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###     ("\<^const>HOL.iff"
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts))
###       ("\<^const>Conform.type_conf" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e)
###         ("\<^const>HOL.conj" ("_position" T)
###           ("\<^fixed>types_conf" ("_position" P) ("_position" E)
###             ("_position" h) ("_position" es) ("_position" Ts)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts)))
###     ("\<^const>HOL.conj"
###       ("\<^const>Conform.type_conf" ("_position" P) ("_position" E)
###         ("_position" h) ("_position" e) ("_position" T))
###       ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###         ("_position" es) ("_position" Ts)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("\<^const>List.list.Cons" ("_position" e) ("_position" es))
###     ("\<^const>HOL.iff"
###       ("\<^const>List.list.Cons" ("_position" T) ("_position" Ts))
###       ("\<^const>HOL.conj"
###         ("\<^const>Conform.type_conf" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" e) ("_position" T))
###         ("\<^fixed>types_conf" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" es) ("_position" Ts))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###       ("_position" es) ("_position" Ts))
###     ("_position" False)))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>types_conf" ("_position" P) ("_position" E) ("_position" h)
###     ("_position" es)
###     ("\<^const>HOL.iff" ("_position" Ts) ("_position" False))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.WellForm"
### 1.068s elapsed time, 8.160s cpu time, 1.611s GC time
Loading theory "CoreC++.WWellForm" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress" via "CoreC++.Equivalence")
### Ambiguous input (line 1206 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs) ("_position" Cs'))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs)
###     ("\<^const>SubObj.appendPath" ("_position" Cs') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.WWellForm"
### 0.042s elapsed time, 0.349s cpu time, 0.000s GC time
### Ambiguous input (line 1208 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs) ("_position" Cs''))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs)
###     ("\<^const>SubObj.appendPath" ("_position" Cs'') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order:
  "(\<lambda>p. size_list size (snd (snd (snd (snd p))))) <*mlex*> {}"
### Ambiguous input (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" es) ("_position" Ts))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" es))
###           ("_applC" ("_position" length) ("_position" Ts'))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" types_conf)
###             ("_cargs" ("_position" P)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" h)
###                   ("_cargs" ("_position" es) ("_position" Ts')))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts')
###               ("_position" Ts))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" Ts'')
###         ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" es)
###           ("\<^const>HOL.conj" ("_position" Ts'')
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###               ("_position" Ts))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" es) ("_position" Ts))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" es))
###           ("_applC" ("_position" length) ("_position" Ts'))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" types_conf)
###             ("_cargs" ("_position" P)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" h)
###                   ("_cargs" ("_position" es) ("_position" Ts')))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts')
###               ("_position" Ts))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" Ts'')
###         ("\<^const>HOL.conj"
###           ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###             ("_position" h) ("_position" es) ("_position" Ts''))
###           ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###             ("_position" Ts)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.Conform"
### 0.343s elapsed time, 2.702s cpu time, 0.177s GC time
### Ignoring duplicate rewrite rule:
### ?P1,?E1,?h1 \<turnstile> [] [:] [] \<equiv> True
### Ambiguous input (line 1656 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Ds) ("_position" Cs'))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Ds)
###     ("\<^const>SubObj.appendPath" ("_position" Cs') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Rule already declared as safe introduction (intro!)
### \<lbrakk>?P; ?Q\<rbrakk> \<Longrightarrow> ?P \<and> ?Q
### Ambiguous input (line 1779 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs') ("_position" Cs))
###     ("_position" Ds)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs')
###     ("\<^const>SubObj.appendPath" ("_position" Cs) ("_position" Ds))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1682 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Ds)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.not_equal" ("_position" Cs)
###                     ("\<^const>List.list.Nil"))
###                   ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                     ("_position" C) ("_position" M)
###                     ("_tuple" ("_position" Ts)
###                       ("_tuple_args" ("_position" T)
###                         ("_tuple_arg" ("_position" m))))
###                     ("_position" Cs))))
###               ("_position" Ts)))
###           ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.not_equal"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###               ("_position" Ds)
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("_position" Cs)))
###             ("\<^const>List.list.Nil"))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###         ("_position" Ds)
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###           ("_position" Ds)
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Ds)
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs)))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.appendPath"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###               ("_position" Ds) ("_position" Cs'))
###             ("_position" Cs))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.HasMethodDef"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("_position" P))))
###           ("_position" C) ("_position" M)
###           ("_tuple" ("_position" Ts)
###             ("_tuple_args" ("_position" T) ("_tuple_arg" ("_position" m))))
###           ("_position" Cs)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" C)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###           ("_position" Ds)
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                   ("_position" C) ("_position" M)
###                   ("_tuple" ("_position" Ts)
###                     ("_tuple_args" ("_position" T)
###                       ("_tuple_arg" ("_position" m))))
###                   ("_position" Cs))))
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1876 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" T'')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellType.WT" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" T'')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1689 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 9 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C') ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>HOL.implies"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.not_equal" ("_position" Cs)
###                       ("\<^const>List.list.Nil"))
###                     ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                       ("_position" C') ("_position" M)
###                       ("_tuple" ("_position" Ts)
###                         ("_tuple_args" ("_position" T)
###                           ("_tuple_arg" ("_position" m))))
###                       ("_position" Cs))))
###                 ("_position" Ts)))
###             ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal"
###               ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###                 ("_position" Ds)
###                 ("\<^const>HOL.conj"
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))
###                   ("_position" Cs)))
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C')
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs))))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C') ("_position" Cs'))
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###           ("_position" Ds)
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                   ("_position" C') ("_position" M)
###                   ("_tuple" ("_position" Ts)
###                     ("_tuple_args" ("_position" T)
###                       ("_tuple_arg" ("_position" m))))
###                   ("_position" Cs))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###               ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###                 ("_position" T)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                   ("_position" C') ("_position" M)
###                   ("_tuple" ("_position" Ts)
###                     ("_tuple_args" ("_position" T)
###                       ("_tuple_arg" ("_position" m))))
###                   ("_position" Cs))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs)))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C') ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs)))))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath"
###               ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###                 ("_position" Ds) ("_position" Cs'))
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C') ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs)))))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C')
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs))))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###             ("_position" C') ("_position" Cs'))
###           ("\<^const>SubObj.HasMethodDef"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.not_equal" ("_position" Cs)
###                     ("\<^const>List.list.Nil"))
###                   ("_position" P))))
###             ("_position" C') ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs)))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" Ds)
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" T')
###               ("_tuple_arg" ("_position" m')))))
###         ("_applC" ("_position" MinimalMethodDefs)
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" D) ("_position" M))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" wf_prog)
###           ("_cargs" ("_position" wf_md) ("_position" P))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" Ts)
###         ("_idts" ("_position" T)
###           ("_idts" ("_position" m)
###             ("_idts" ("_position" Cs) ("_position" Cs')))))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C') ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.not_equal" ("_position" Cs)
###                     ("\<^const>List.list.Nil"))
###                   ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                     ("_position" C') ("_position" M)
###                     ("_tuple" ("_position" Ts)
###                       ("_tuple_args" ("_position" T)
###                         ("_tuple_arg" ("_position" m))))
###                     ("_position" Cs))))
###               ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))))
###           ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###             ("_position" T)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1695 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###       ("_position" Ds) ("_position" Cs'))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###     ("_position" Ds)
###     ("\<^const>SubObj.appendPath" ("_position" Cs') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 258 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" es) ("_position" Ts))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" es))
###           ("_applC" ("_position" length) ("_position" Ss))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" types_conf)
###             ("_cargs" ("_position" P)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" h)
###                   ("_cargs" ("_position" es) ("_position" Ss)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ss)
###               ("_position" Ts))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" Ts'')
###         ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###           ("_position" h) ("_position" es)
###           ("\<^const>HOL.conj" ("_position" Ts'')
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###               ("_position" Ts))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" es) ("_position" Ts))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" es))
###           ("_applC" ("_position" length) ("_position" Ss))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" types_conf)
###             ("_cargs" ("_position" P)
###               ("_cargs" ("_position" E)
###                 ("_cargs" ("_position" h)
###                   ("_cargs" ("_position" es) ("_position" Ss)))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ss)
###               ("_position" Ts))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" Ts'')
###         ("\<^const>HOL.conj"
###           ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###             ("_position" h) ("_position" es) ("_position" Ts''))
###           ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###             ("_position" Ts)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 266 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" e') ("_position" T''))
###     ("\<^const>TypeRel.widen" ("_position" P) ("_position" T'')
###       ("_position" U))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellTypeRT.WTrt" ("_position" P) ("_position" E)
###     ("_position" h) ("_position" e')
###     ("\<^const>HOL.conj" ("_position" T'')
###       ("\<^const>TypeRel.widen" ("_position" P) ("_position" T'')
###         ("_position" U)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 270 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###       ("_position" h) ("_position" es') ("_position" Ts''))
###     ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###       ("_position" Us))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###     ("_position" h) ("_position" es')
###     ("\<^const>HOL.conj" ("_position" Ts'')
###       ("\<^const>TypeRel.widens" ("_position" P) ("_position" Ts'')
###         ("_position" Us)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1613 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.appendPath"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###       ("_position" Ds) ("_position" Cs'))
###     ("_position" Cs)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###     ("_position" Ds)
###     ("\<^const>SubObj.appendPath" ("_position" Cs') ("_position" Cs))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 272 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Conform.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###       ("_position" h)
###       ("\<^const>List.list.Cons" ("_position" e') ("_position" es'))
###       ("\<^const>List.list.Cons" ("_position" T'') ("_position" Ts'')))
###     ("\<^const>TypeRel.widens" ("_position" P)
###       ("\<^const>List.list.Cons" ("_position" T'') ("_position" Ts''))
###       ("\<^const>List.list.Cons" ("_position" U) ("_position" Us)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>WellTypeRT.WTrts" ("_position" P) ("_position" E)
###     ("_position" h)
###     ("\<^const>List.list.Cons" ("_position" e') ("_position" es'))
###     ("\<^const>HOL.conj"
###       ("\<^const>List.list.Cons" ("_position" T'') ("_position" Ts''))
###       ("\<^const>TypeRel.widens" ("_position" P)
###         ("\<^const>List.list.Cons" ("_position" T'') ("_position" Ts''))
###         ("\<^const>List.list.Cons" ("_position" U) ("_position" Us))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1724 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/WellForm.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.implies"
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.not_equal" ("_position" Cs)
###                     ("\<^const>List.list.Nil"))
###                   ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                     ("_position" C) ("_position" M)
###                     ("_tuple" ("_position" Ts)
###                       ("_tuple_args" ("_position" T)
###                         ("_tuple_arg" ("_position" m))))
###                     ("_position" Cs))))
###               ("_position" Ts)))
###           ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.not_equal"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds)
###               ("\<^const>HOL.conj"
###                 ("\<^const>SubObj.appendPath" ("_position" Cs')
###                   ("_position" Cs))
###                 ("_position" Cs)))
###             ("\<^const>List.list.Nil"))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###         ("_position" Ds)
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###             ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###               ("_position" T))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###           ("_position" Ds)
###           ("\<^const>HOL.conj"
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))
###               ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                 ("_position" C) ("_position" M)
###                 ("_tuple" ("_position" Ts)
###                   ("_tuple_args" ("_position" T)
###                     ("_tuple_arg" ("_position" m))))
###                 ("_position" Cs))))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>SubObj.appendPath" ("_position" Cs')
###               ("_position" Cs)))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.appendPath"
###             ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###               ("_position" Ds) ("_position" Cs'))
###             ("_position" Cs))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.not_equal" ("_position" Cs)
###               ("\<^const>List.list.Nil"))
###             ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###               ("_position" M)
###               ("_tuple" ("_position" Ts)
###                 ("_tuple_args" ("_position" T)
###                   ("_tuple_arg" ("_position" m))))
###               ("_position" Cs)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>HOL.conj"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.not_equal" ("_position" Cs)
###                 ("\<^const>List.list.Nil"))))
###           ("\<^const>SubObj.HasMethodDef" ("_position" P) ("_position" C)
###             ("_position" M)
###             ("_tuple" ("_position" Ts)
###               ("_tuple_args" ("_position" T)
###                 ("_tuple_arg" ("_position" m))))
###             ("_position" Cs))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###           ("_position" C) ("_position" Cs'))
###         ("\<^const>SubObj.HasMethodDef"
###           ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###             ("_position" Ds)
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("_position" P))))
###           ("_position" C) ("_position" M)
###           ("_tuple" ("_position" Ts)
###             ("_tuple_args" ("_position" T) ("_tuple_arg" ("_position" m))))
###           ("_position" Cs)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" Ts)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" m)
###           ("_idts" ("_position" Cs) ("_position" Cs')))))
###     ("\<^const>HOL.conj"
###       ("\<^const>SubObj.path_via" ("_position" P) ("_position" D)
###         ("_position" C) ("_position" Cs'))
###       ("\<^const>HOL.conj"
###         ("\<^const>SubObj.leq_path" ("_position" P) ("_position" D)
###           ("_position" Ds)
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>SubObj.appendPath" ("_position" Cs')
###                 ("_position" Cs))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.not_equal" ("_position" Cs)
###                   ("\<^const>List.list.Nil"))
###                 ("\<^const>SubObj.HasMethodDef" ("_position" P)
###                   ("_position" C) ("_position" M)
###                   ("_tuple" ("_position" Ts)
###                     ("_tuple_args" ("_position" T)
###                       ("_tuple_arg" ("_position" m))))
###                   ("_position" Cs))))
###             ("\<^const>HOL.eq" ("_position" Ts) ("_position" Ts'))))
###         ("\<^const>TypeRel.widen" ("_position" P) ("_position" T')
###           ("_position" T))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 247 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/BigStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.BigStep"
### 3.176s elapsed time, 21.952s cpu time, 2.454s GC time
Loading theory "CoreC++.DefAss" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress")
### Ambiguous input (line 18 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 8 parse trees:
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperUn" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2" ("_case1" ("_position" None) ("_position" None))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.union" ("_position" A)
###                   ("_position" B))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 22 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 16 parse trees (10 displayed):
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A)))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A)))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" B))
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperInt" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" B))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("_case_syntax" ("_position" B)
###           ("_case2"
###             ("_case1" ("_position" None)
###               ("\<^const>Option.option.Some" ("_position" A)))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.inter" ("_position" A)
###                   ("_position" B))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 26 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 4 parse trees:
### ("\<^const>Pure.eq" ("\<^fixed>hyperDiff1" ("_position" A) ("_position" a))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Groups.minus_class.minus" ("_position" A)
###             ("_Finset" ("_position" a))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperDiff1" ("_position" A) ("_position" a))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Groups.minus_class.minus" ("_position" A)
###             ("_Finset" ("_position" a))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperDiff1" ("_position" A) ("_position" a))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Option.option.Some"
###           ("\<^const>Groups.minus_class.minus" ("_position" A)
###             ("_Finset" ("_position" a))))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyperDiff1" ("_position" A) ("_position" a))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" None))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Option.option.Some"
###           ("\<^const>Groups.minus_class.minus" ("_position" A)
###             ("_Finset" ("_position" a))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("\<^fixed>hyper_isin" ("_position" a) ("_position" A))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Set.member" ("_position" a) ("_position" A))))))
### ("\<^const>Pure.eq" ("\<^fixed>hyper_isin" ("_position" a) ("_position" A))
###   ("_case_syntax" ("_position" A)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Set.member" ("_position" a) ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 32 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 4 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^fixed>hyper_subset" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" B)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B))
###         ("_case_syntax" ("_position" A)
###           ("_case2" ("_case1" ("_position" None) ("_position" False))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###               ("\<^const>Set.subset_eq" ("_position" A)
###                 ("_position" B)))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>hyper_subset" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" B)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###         ("_case_syntax" ("_position" A)
###           ("_case2" ("_case1" ("_position" None) ("_position" False))
###             ("_case1" ("\<^const>Option.option.Some" ("_position" A))
###               ("\<^const>Set.subset_eq" ("_position" A)
###                 ("_position" B)))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>hyper_subset" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" B)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B))
###         ("_case_syntax" ("_position" A)
###           ("_case2" ("_case1" ("_position" None) ("_position" False))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A))
###               ("\<^const>Set.subset_eq" ("_position" A)
###                 ("_position" B)))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>hyper_subset" ("_position" A) ("_position" B))
###   ("_case_syntax" ("_position" B)
###     ("_case2" ("_case1" ("_position" None) ("_position" True))
###       ("_case1" ("\<^const>Option.option.Some" ("_position" B))
###         ("_case_syntax" ("_position" A)
###           ("_case2" ("_case1" ("_position" None) ("_position" False))
###             ("_case1"
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("_position" A))
###               ("\<^const>Set.subset_eq" ("_position" A)
###                 ("_position" B)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Loading theory "CoreC++.Execute" (required by "CoreC++.CoreC++")
### Ambiguous input (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Set.empty"))
###         ("_position" A))
###       ("_position" A))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Set.empty")))
###       ("_position" A))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("\<^const>Set.empty"))
###         ("_position" A))
###       ("_position" A))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Set.empty")))
###       ("_position" A))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("\<^const>Set.empty"))
###         ("_position" A))
###       ("_position" A))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("\<^const>Set.empty")))
###       ("_position" A))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("\<^const>Set.empty"))
###         ("_position" A))
###       ("_position" A))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("\<^const>Set.empty")))
###       ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 41 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 32 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Option.option.Some" ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Option.option.Some" ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Option.option.Some"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Option.option.Some"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Option.option.Some" ("_position" B)))
###       ("\<^const>Option.option.Some"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Option.option.Some" ("_position" B)))
###       ("\<^const>Option.option.Some"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Option.option.Some" ("_position" A)) ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_position" A))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" B)))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Set.union" ("_position" A) ("_position" B))))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperDiff1"
###         ("\<^const>Option.option.Some" ("_position" A)) ("_position" a))
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("\<^const>Groups.minus_class.minus" ("_position" A)
###           ("_Finset" ("_position" a)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 53 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a))))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_Finset" ("_position" a)))
###         ("_position" A)))
###     ("\<^const>HOL.eq"
###       ("\<^const>DefAss.hyperUn" ("_position" A)
###         ("\<^const>DefAss.hyperUn"
###           ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###           ("_position" B)))
###       ("\<^const>DefAss.hyperUn"
###         ("\<^const>Option.option.Some" ("_Finset" ("_position" a)))
###         ("\<^const>DefAss.hyperUn" ("_position" A) ("_position" B))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 60 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" new) ("_position" C)))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("\<^const>Set.empty"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" new) ("_position" C)))
###     ("\<^const>Option.option.Some" ("\<^const>Set.empty"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("\<^const>Set.empty"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("\<^const>Option.option.Some" ("\<^const>Set.empty"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 65 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" Var) ("_position" V)))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("\<^const>Set.empty"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" Var) ("_position" V)))
###     ("\<^const>Option.option.Some" ("\<^const>Set.empty"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 66 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" LAss)
###         ("_cargs" ("_position" V) ("_position" e))))
###     ("\<^const>DefAss.hyperUn"
###       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###         ("_Finset" ("_position" V)))
###       ("_applC" ("_position" \<A>) ("_position" e)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("_applC" ("_position" LAss)
###         ("_cargs" ("_position" V) ("_position" e))))
###     ("\<^const>DefAss.hyperUn"
###       ("\<^const>Option.option.Some" ("_Finset" ("_position" V)))
###       ("_applC" ("_position" \<A>) ("_position" e)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 68 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update" ("_position" \<A>)
###       ("_updbind"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2)))
###     ("\<^const>DefAss.hyperUn"
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))
###       ("_applC" ("_position" \<A>) ("_position" e\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 76 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>s) ("\<^const>List.list.Nil"))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("\<^const>Set.empty"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>s) ("\<^const>List.list.Nil"))
###     ("\<^const>Option.option.Some" ("\<^const>Set.empty"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<A> :: "expr \<Rightarrow> char list set option"
  \<A>s :: "expr list \<Rightarrow> char list set option"
### Ambiguous input (line 88 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<D>)
###       ("_cargs"
###         ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs) ("_position" e\<^sub>2))
###         ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" A)))
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("\<^const>DefAss.hyperUn" ("_position" A)
###             ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<D>)
###       ("_cargs"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs))
###           ("_position" e\<^sub>2))
###         ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>1) ("_position" A)))
###       ("_applC" ("_position" \<D>)
###         ("_cargs" ("_position" e\<^sub>2)
###           ("\<^const>DefAss.hyperUn" ("_position" A)
###             ("_applC" ("_position" \<A>) ("_position" e\<^sub>1))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  \<D> :: "expr \<Rightarrow> char list set option \<Rightarrow> bool"
  \<D>s :: "expr list \<Rightarrow> char list set option \<Rightarrow> bool"
### Ambiguous input (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>s)
###       ("_applC" ("_position" map)
###         ("_cargs" ("_position" Val) ("_position" vs))))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("\<^const>Set.empty"))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" \<A>s)
###       ("_applC" ("_position" map)
###         ("_cargs" ("_position" Val) ("_position" vs))))
###     ("\<^const>Option.option.Some" ("\<^const>Set.empty"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 107 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" A)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" \<A>) ("_position" e))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq" ("_position" A)
###         ("_applC" ("_position" fv) ("_position" e))))))
### ("\<^const>Pure.all_binder" ("_position" A)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" \<A>) ("_position" e))
###         ("\<^const>Option.option.Some" ("_position" A))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq" ("_position" A)
###         ("_applC" ("_position" fv) ("_position" e))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 108 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/DefAss.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" A)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" \<A>s) ("_position" es))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_position" A))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq" ("_position" A)
###         ("_applC" ("_position" fvs) ("_position" es))))))
### ("\<^const>Pure.all_binder" ("_position" A)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" \<A>s) ("_position" es))
###         ("\<^const>Option.option.Some" ("_position" A))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq" ("_position" A)
###         ("_applC" ("_position" fvs) ("_position" es))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.DefAss"
### 0.326s elapsed time, 2.446s cpu time, 0.102s GC time
Loading theory "CoreC++.CWellForm" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe")
Proofs for inductive predicate(s) "app"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "map_val"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "map_val2"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ambiguous input (line 13 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/CWellForm.thy") produces 4 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>WellType.WT" ("_position" P)
###             ("_Map"
###               ("_Maplets"
###                 ("_maplet" ("_position" this)
###                   ("_applC" ("_position" Class) ("_position" C)))
###                 ("_maplets" ("_position" pns) ("_position" Ts))))
###             ("_position" body)
###             ("\<^const>HOL.conj" ("_position" T)
###               ("_applC" ("_position" \<D>)
###                 ("_cargs" ("_position" body)
###                   ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                     ("\<^const>Set.union" ("_Finset" ("_position" this))
###                       ("_applC" ("_position" set)
###                         ("_position" pns)))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>HOL.conj"
###             ("\<^const>WellType.WT" ("_position" P)
###               ("_Map"
###                 ("_Maplets"
###                   ("_maplet" ("_position" this)
###                     ("_applC" ("_position" Class) ("_position" C)))
###                   ("_maplets" ("_position" pns) ("_position" Ts))))
###               ("_position" body) ("_position" T))
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>WellType.WT" ("_position" P)
###             ("_Map"
###               ("_Maplets"
###                 ("_maplet" ("_position" this)
###                   ("_applC" ("_position" Class) ("_position" C)))
###                 ("_maplets" ("_position" pns) ("_position" Ts))))
###             ("_position" body)
###             ("\<^const>HOL.conj" ("_position" T)
###               ("_applC" ("_position" \<D>)
###                 ("_cargs" ("_position" body)
###                   ("\<^const>Option.option.Some"
###                     ("\<^const>Set.union" ("_Finset" ("_position" this))
###                       ("_applC" ("_position" set)
###                         ("_position" pns)))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P) ("_position" C)))
###   ("_lambda"
###     ("_pattern" ("_position" M)
###       ("_patterns" ("_position" Ts)
###         ("_patterns" ("_position" T)
###           ("_pattern" ("_position" pns) ("_position" body)))))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###         ("_applC" ("_position" length) ("_position" pns)))
###       ("\<^const>HOL.conj"
###         ("_applC" ("_position" distinct) ("_position" pns))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.not_member" ("_position" this)
###             ("_applC" ("_position" set) ("_position" pns)))
###           ("\<^const>HOL.conj"
###             ("\<^const>WellType.WT" ("_position" P)
###               ("_Map"
###                 ("_Maplets"
###                   ("_maplet" ("_position" this)
###                     ("_applC" ("_position" Class) ("_position" C)))
###                   ("_maplets" ("_position" pns) ("_position" Ts))))
###               ("_position" body) ("_position" T))
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Option.option.Some"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 21 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/CWellForm.thy") produces 4 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P)
###             ("_Map"
###               ("_Maplets"
###                 ("_maplet" ("_position" this)
###                   ("_applC" ("_position" Class) ("_position" C)))
###                 ("_maplets" ("_position" pns) ("_position" Ts))))
###             ("_position" body) ("_position" T))
###           ("_applC" ("_position" \<D>)
###             ("_cargs" ("_position" body)
###               ("\<^const>Option.option.Some"
###                 ("\<^const>Set.union" ("_Finset" ("_position" this))
###                   ("_applC" ("_position" set) ("_position" pns)))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>WellType.WT" ("_position" P)
###           ("_Map"
###             ("_Maplets"
###               ("_maplet" ("_position" this)
###                 ("_applC" ("_position" Class) ("_position" C)))
###               ("_maplets" ("_position" pns) ("_position" Ts))))
###           ("_position" body)
###           ("\<^const>HOL.conj" ("_position" T)
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Option.option.Some"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>HOL.conj"
###           ("\<^const>WellType.WT" ("_position" P)
###             ("_Map"
###               ("_Maplets"
###                 ("_maplet" ("_position" this)
###                   ("_applC" ("_position" Class) ("_position" C)))
###                 ("_maplets" ("_position" pns) ("_position" Ts))))
###             ("_position" body) ("_position" T))
###           ("_applC" ("_position" \<D>)
###             ("_cargs" ("_position" body)
###               ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                 ("\<^const>Set.union" ("_Finset" ("_position" this))
###                   ("_applC" ("_position" set) ("_position" pns)))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" wf_C_mdecl)
###     ("_cargs" ("_position" P)
###       ("_cargs" ("_position" C)
###         ("_tuple" ("_position" M)
###           ("_tuple_args" ("_position" Ts)
###             ("_tuple_args" ("_position" T)
###               ("_tuple_args" ("_position" pns)
###                 ("_tuple_arg" ("_position" body)))))))))
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" Ts))
###       ("_applC" ("_position" length) ("_position" pns)))
###     ("\<^const>HOL.conj" ("_applC" ("_position" distinct) ("_position" pns))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.not_member" ("_position" this)
###           ("_applC" ("_position" set) ("_position" pns)))
###         ("\<^const>WellType.WT" ("_position" P)
###           ("_Map"
###             ("_Maplets"
###               ("_maplet" ("_position" this)
###                 ("_applC" ("_position" Class) ("_position" C)))
###               ("_maplets" ("_position" pns) ("_position" Ts))))
###           ("_position" body)
###           ("\<^const>HOL.conj" ("_position" T)
###             ("_applC" ("_position" \<D>)
###               ("_cargs" ("_position" body)
###                 ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                   ("\<^const>Set.union" ("_Finset" ("_position" this))
###                     ("_applC" ("_position" set) ("_position" pns))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P) ("_position" C)))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs) ("_tuple_arg" ("_position" rest))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" Predicate_Compile.contains)
###           ("_cargs" ("_applC" ("_position" set) ("_position" Bs))
###             ("_applC" ("_position" Repeats) ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" subclsRp)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" D))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P) ("_position" C)))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs) ("_tuple_arg" ("_position" rest))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" Predicate_Compile.contains)
###           ("_cargs" ("_applC" ("_position" set) ("_position" Bs))
###             ("_applC" ("_position" Repeats) ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" subclsRp)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" D))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.CWellForm"
### 0.441s elapsed time, 2.488s cpu time, 0.104s GC time
### Ambiguous input (line 149 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P) ("_position" C)))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs) ("_tuple_arg" ("_position" rest))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" Predicate_Compile.contains)
###           ("_cargs" ("_applC" ("_position" set) ("_position" Bs))
###             ("_applC" ("_position" Shares) ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" subclsSp)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" D))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P) ("_position" C)))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs) ("_tuple_arg" ("_position" rest))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" Predicate_Compile.contains)
###           ("_cargs" ("_applC" ("_position" set) ("_position" Bs))
###             ("_applC" ("_position" Shares) ("_position" D)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" subclsSp)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" D))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Introduced fixed type variable(s): 'a in "xu" or "z"
### Introduced fixed type variable(s): 'a in "res" or "xu" or "z"
### Ambiguous input (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###       ("_position" Cs) ("_position" Ds))
###     ("_applC"
###       ("\<^const>Transitive_Closure.rtranclp"
###         ("_applC" ("_position" leq_path1p)
###           ("_cargs" ("_position" P) ("_position" C))))
###       ("_cargs" ("_position" Cs) ("_position" Ds)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SubObj.leq_path" ("_position" P) ("_position" C)
###     ("_position" Cs)
###     ("\<^const>HOL.iff" ("_position" Ds)
###       ("_applC"
###         ("\<^const>Transitive_Closure.rtranclp"
###           ("_applC" ("_position" leq_path1p)
###             ("_cargs" ("_position" P) ("_position" C))))
###         ("_cargs" ("_position" Cs) ("_position" Ds))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 238 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" ms) ("_position" M)))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_position" mthd))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" MethodDefs')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" M)
###                 ("_cargs" ("_position" Cs) ("_position" mthd))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" ms) ("_position" M)))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_position" mthd))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" MethodDefs')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" M)
###                 ("_cargs" ("_position" Cs) ("_position" mthd))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" ms) ("_position" M)))
###           ("\<^const>Option.option.Some" ("_position" mthd))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" MethodDefs')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" M)
###                 ("_cargs" ("_position" Cs) ("_position" mthd))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" ms) ("_position" M)))
###           ("\<^const>Option.option.Some" ("_position" mthd))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" MethodDefs')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" M)
###                 ("_cargs" ("_position" Cs) ("_position" mthd))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 252 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" fs) ("_position" F)))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_position" T))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" FieldDecls')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" F)
###                 ("_cargs" ("_position" Cs) ("_position" T))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" fs) ("_position" F)))
###           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###             ("_position" T))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" FieldDecls')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" F)
###                 ("_cargs" ("_position" Cs) ("_position" T))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" fs) ("_position" F)))
###           ("\<^const>Option.option.Some" ("_position" T))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" FieldDecls')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" F)
###                 ("_cargs" ("_position" Cs) ("_position" T))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" Subobjs)
###       ("_cargs" ("_position" P)
###         ("_cargs" ("_position" C) ("_position" Cs)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" class)
###           ("_cargs" ("_position" P)
###             ("_applC" ("_position" last) ("_position" Cs))))
###         ("\<^const>Option.option.Some"
###           ("_tuple" ("_position" Bs)
###             ("_tuple_args" ("_position" fs)
###               ("_tuple_arg" ("_position" ms)))))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" map_of)
###             ("_cargs" ("_position" fs) ("_position" F)))
###           ("\<^const>Option.option.Some" ("_position" T))))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" FieldDecls')
###           ("_cargs" ("_position" P)
###             ("_cargs" ("_position" C)
###               ("_cargs" ("_position" F)
###                 ("_cargs" ("_position" Cs) ("_position" T))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Replacing higher order arguments is not applied in an undestructable product type
### Ignoring duplicate safe introduction (intro!)
### \<exists>z zs.
###    ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
### ?x # ?xs = map ?f ?ys
### Ignoring duplicate safe elimination (elim!)
### \<lbrakk>?x # ?xs = map ?f ?ys;
###  \<exists>z zs.
###     ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
###  PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Ignoring duplicate safe introduction (intro!)
### \<exists>z zs.
###    ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
### ?x # ?xs = map ?f ?ys
### Ignoring duplicate safe elimination (elim!)
### \<lbrakk>?x # ?xs = map ?f ?ys;
###  \<exists>z zs.
###     ?ys = z # zs \<and> ?x = ?f z \<and> ?xs = map ?f zs \<Longrightarrow>
###  PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
### Ignoring duplicate rewrite rule:
### ?x1 # ?xs1 = map ?f1 ?ys1 \<equiv>
### \<exists>z zs. ?ys1 = z # zs \<and> ?x1 = ?f1 z \<and> ?xs1 = map ?f1 zs
### Replacing higher order arguments is not applied in an undestructable product type
### theory "CoreC++.SmallStep"
### 4.765s elapsed time, 29.936s cpu time, 2.885s GC time
Loading theory "CoreC++.Equivalence" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension" via "CoreC++.Progress")
### Ambiguous input (line 91 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 92 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))
###             ("_position" V'))
###           ("_position" None)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V'))
###               ("_applC" ("_position" Some) ("_position" v')))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))
###             ("_position" V'))
###           ("_position" None)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V'))
###               ("_applC" ("_position" Some) ("_position" v')))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 101 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_position" None)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 191 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))
###             ("_position" V'))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v'') ("_position" v)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" l') ("_position" V'))
###                 ("_applC" ("_position" Some) ("_position" v'))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))
###             ("_position" V'))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v'') ("_position" v)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" l') ("_position" V'))
###                 ("_applC" ("_position" Some) ("_position" v'))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 109 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 204 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))
###             ("_position" V'))
###           ("_position" None)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V'))
###               ("_applC" ("_position" Some) ("_position" v')))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))
###             ("_position" V'))
###           ("_position" None)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_applC" ("_position" l') ("_position" V'))
###               ("_applC" ("_position" Some) ("_position" v')))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 212 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 214 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))
###             ("_position" V'))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v'') ("_position" v)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" l') ("_position" V'))
###                 ("_applC" ("_position" Some) ("_position" v'))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### ("\<^const>Pure.all_binder" ("_position" V')
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))
###             ("_position" V'))
###           ("_applC" ("_position" Some) ("_position" v))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC"
###               ("_MapUpd" ("_position" E)
###                 ("_maplet" ("_position" V) ("_position" T')))
###               ("_position" V'))
###             ("_applC" ("_position" Some) ("_position" T))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v'') ("_position" v)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" l') ("_position" V'))
###                 ("_applC" ("_position" Some) ("_position" v'))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v') ("_position" v')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 119 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_position" None)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 526 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e') ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e') ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss" ("_position" e') ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss" ("_position" e') ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 536 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###           ("_position" Cs))
###         ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e'))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e))
###       ("_position" s)
###       ("\<^const>Expr.expr.FAss"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs) ("_position" e'))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 127 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 233 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V))))
###       ("_position" V'))
###     ("_applC" ("_position" Some) ("_position" v'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 546 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg" ("_position" fs)))
###                     ("_position" S))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple"
###         ("_MapUpd" ("_position" h\<^sub>2)
###           ("_maplet" ("_position" a)
###             ("_tuple" ("_position" D)
###               ("_tuple_arg"
###                 ("_applC" ("_position" insert)
###                   ("_cargs"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg"
###                         ("_MapUpd" ("_position" fs)
###                           ("_maplet" ("_position" F) ("_position" v')))))
###                     ("\<^const>Groups.minus_class.minus" ("_position" S)
###                       ("_Finset"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))))))))))
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asm"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg" ("_position" fs)))
###                     ("_position" S))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple"
###         ("_MapUpd" ("_position" h\<^sub>2)
###           ("_maplet" ("_position" a)
###             ("_tuple" ("_position" D)
###               ("_tuple_arg"
###                 ("_applC" ("_position" insert)
###                   ("_cargs"
###                     ("_tuple" ("_position" Ds)
###                       ("_tuple_arg"
###                         ("_MapUpd" ("_position" fs)
###                           ("_maplet" ("_position" F) ("_position" v')))))
###                     ("\<^const>Groups.minus_class.minus" ("_position" S)
###                       ("_Finset"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))))))))))
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 561 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 573 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s)
###       ("_applC" ("_position" Throw) ("_position" r)) ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s'))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("_position" e) ("_position" s)
###       ("_applC" ("_position" Throw) ("_position" r)) ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 582 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Throw) ("_position" r))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Throw) ("_position" r))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Throw) ("_position" r))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 381 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 387 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" l\<^sub>0)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.red'" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e)
###       ("_tuple" ("_position" h)
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None))))))
###       ("_position" e')
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_position" l')))))))
### ("\<^const>Pure.all_binder" ("_position" l\<^sub>0)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.red'" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e)
###       ("_tuple" ("_position" h)
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None))))))
###       ("_position" e')
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_position" l')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 389 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 391 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 764 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l')
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l')
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v''))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l')
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v''))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l')
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l')
###                         ("_updbind" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l')
###                         ("_updbind" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Expr.expr.Block" ("_position" V)
###                     ("\<^const>Expr.expr.LAss" ("_position" T)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v''))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l')
###                         ("_updbind" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.Step" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e) ("_position" s) ("_position" e') ("_position" s')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" h)
###         ("_idts" ("_position" l)
###           ("_idts" ("_position" h')
###             ("_idts" ("_position" l')
###               ("_idts" ("_position" v) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" s)
###           ("_tuple" ("_position" h)
###             ("_tuple_arg"
###               ("_MapUpd" ("_position" l)
###                 ("_maplet" ("_position" V) ("_position" v'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###             ("_position" v) ("_position" v'))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq" ("_position" s')
###               ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###             ("\<^const>HOL.Ex_binder"
###               ("_idts" ("_position" v'') ("_position" w))
###               ("\<^const>HOL.conj"
###                 ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v))
###                     ("_position" e))
###                   ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                   ("\<^const>Syntax.InitBlock" ("_position" V)
###                     ("_position" T)
###                     ("_applC" ("_position" Val) ("_position" v''))
###                     ("_position" e'))
###                   ("_tuple" ("_position" h')
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l')
###                         ("_updbind" ("_position" V)
###                           ("_applC" ("_position" l) ("_position" V)))))))
###                 ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                   ("_position" v'') ("_position" w))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 392 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("_Update" ("_position" l\<^sub>0)
###   ("_updbind" ("_position" V) ("_position" None)))
### ("_applC" ("_position" l\<^sub>0)
###   ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 393 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 774 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e')))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e')))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e')))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e')))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 845 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_Update" ("_position" l')
###                 ("_updbind" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_Update" ("_position" l')
###                 ("_updbind" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_Update" ("_position" l')
###                 ("_updbind" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_Update" ("_position" l')
###                 ("_updbind" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_applC" ("_position" l')
###                 ("\<^const>Expr.expr.LAss" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_applC" ("_position" l')
###                 ("\<^const>Expr.expr.LAss" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###             ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_applC" ("_position" l')
###                 ("\<^const>Expr.expr.LAss" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v')))))
###         ("_position" e')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v')))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" wf_prog)
###             ("_cargs" ("_position" wf_md) ("_position" P)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###       ("\<^const>HOL.conj"
###         ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e))
###           ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###           ("\<^const>Expr.expr.Block" ("_position" V)
###             ("\<^const>Expr.expr.LAss" ("_position" T)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e'))
###           ("_tuple" ("_position" h')
###             ("_tuple_arg"
###               ("_applC" ("_position" l')
###                 ("\<^const>Expr.expr.LAss" ("_position" V)
###                   ("_applC" ("_position" l) ("_position" V)))))))
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v'') ("_position" w))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 399 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" l\<^sub>0)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.red'" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e)
###       ("_tuple" ("_position" h)
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None))))))
###       ("_position" e')
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_position" l')))))))
### ("\<^const>Pure.all_binder" ("_position" l\<^sub>0)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>SmallStep.red'" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("_position" e)
###       ("_tuple" ("_position" h)
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None))))))
###       ("_position" e')
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###             ("_position" l')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_Update"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("_updbind" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_Update" ("_position" l)
###         ("_updbind" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_Update" ("_position" l\<^sub>0)
###         ("_updbind" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Map.map_add"
###       ("_applC" ("_position" l\<^sub>0)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###       ("_applC" ("_position" l)
###         ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None))))
###     ("_applC"
###       ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 856 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 403 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_Update" ("_position" l\<^sub>0)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("\<^const>Map.map_add"
###           ("_applC" ("_position" l\<^sub>0)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_position" l'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 777 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###               ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                 ("\<^const>Expr.expr.Seq"
###                   ("\<^const>Expr.expr.LAss" ("_position" V)
###                     ("_applC" ("_position" Val) ("_position" v)))
###                   ("_position" e')))
###               ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###               ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                 ("\<^const>Expr.expr.Seq"
###                   ("\<^const>Expr.expr.LAss" ("_position" V)
###                     ("_applC" ("_position" Val) ("_position" v)))
###                   ("_position" e')))
###               ("_tuple" ("_position" h')
###                 ("_tuple_arg"
###                   ("_applC" ("_position" l')
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" l) ("_position" V)))))))
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v) ("_position" v'))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###               ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                 ("\<^const>Expr.expr.Seq"
###                   ("\<^const>Expr.expr.LAss" ("_position" V)
###                     ("_applC" ("_position" Val) ("_position" v)))
###                   ("_position" e')))
###               ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###               ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                 ("\<^const>Expr.expr.Seq"
###                   ("\<^const>Expr.expr.LAss" ("_position" V)
###                     ("_applC" ("_position" Val) ("_position" v)))
###                   ("_position" e')))
###               ("_tuple" ("_position" h')
###                 ("_tuple_arg"
###                   ("_Update" ("_position" l')
###                     ("_updbind" ("_position" V)
###                       ("_applC" ("_position" l) ("_position" V)))))))
###             ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###               ("_position" v) ("_position" v'))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 404 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 2 parse trees:
### ("_Update" ("_position" l\<^sub>0)
###   ("_updbind" ("_position" V) ("_position" None)))
### ("_applC" ("_position" l\<^sub>0)
###   ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 878 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h\<^sub>0) ("_position" l\<^sub>0))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>0))
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg" ("_position" l\<^sub>0)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>2)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h\<^sub>0) ("_position" l\<^sub>0))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>0))
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg" ("_position" l\<^sub>0)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>2)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h\<^sub>0) ("_position" l\<^sub>0))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>0))
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg" ("_position" l\<^sub>0)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>2)
###               ("_updbind" ("_position" V)
###                 ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h\<^sub>0) ("_position" l\<^sub>0))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>0))
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg" ("_position" l\<^sub>0)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>2)
###               ("_updbind" ("_position" V)
###                 ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 405 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/SmallStep.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_applC" ("_position" l')
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("\<^const>Map.map_add"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l'))
###       ("_updbind" ("_position" V)
###         ("_applC"
###           ("\<^const>Map.map_add" ("_position" l\<^sub>0) ("_position" l))
###           ("_position" V))))
###     ("\<^const>Map.map_add" ("_position" l\<^sub>0)
###       ("_Update" ("_position" l')
###         ("_updbind" ("_position" V)
###           ("_applC" ("_position" l) ("_position" V)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 785 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_Update" ("_position" l')
###                       ("_updbind" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_applC" ("_position" l')
###                       ("\<^const>Expr.expr.LAss" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 889 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" l))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>1)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>1))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>2)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" l))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>1)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>1))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>2)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" l))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>1)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>1))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>2)
###               ("_updbind" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" h) ("_position" l))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" s\<^sub>1)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("_position" e\<^sub>1))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("_position" e\<^sub>2)
###         ("_tuple" ("_position" h\<^sub>2)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>2)
###               ("_updbind" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 891 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>0)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s\<^sub>0)
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>0)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1031 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("_applC" ("_position" override_on)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_MapUpd" ("_position" g)
###               ("_maplet" ("_position" a) ("_position" b)))
###             ("_position" A))))
###       ("\<^const>Expr.expr.LAss" ("_position" a)
###         ("_applC" ("_position" g) ("_position" a))))
###     ("_applC" ("_position" override_on)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_applC" ("_position" insert)
###             ("_cargs" ("_position" a) ("_position" A))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_Update"
###       ("_applC" ("_position" override_on)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_MapUpd" ("_position" g)
###               ("_maplet" ("_position" a) ("_position" b)))
###             ("_position" A))))
###       ("_updbind" ("_position" a)
###         ("_applC" ("_position" g) ("_position" a))))
###     ("_applC" ("_position" override_on)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_applC" ("_position" insert)
###             ("_cargs" ("_position" a) ("_position" A))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 864 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e'))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e')
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 797 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s'')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e'')))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_Update" ("_position" l')
###                       ("_updbind" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s'')
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e'')))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_applC" ("_position" l')
###                       ("\<^const>Expr.expr.LAss" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 811 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1083 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_applC" ("_position" blocks)
###           ("_tuple" ("_position" Vs)
###             ("_tuple_args" ("_position" Ts)
###               ("_tuple_args" ("_position" vs)
###                 ("_tuple_arg" ("_position" e))))))))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_applC" ("_position" blocks)
###           ("_tuple" ("_position" Vs)
###             ("_tuple_args" ("_position" Ts)
###               ("_tuple_args" ("_position" vs'')
###                 ("_tuple_arg" ("_position" e'))))))))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC"
###           ("_applC" ("_position" override_on)
###             ("_cargs" ("_position" l\<^sub>1)
###               ("_cargs"
###                 ("_MapUpd" ("_position" l\<^sub>0)
###                   ("_maplet" ("_position" V) ("_position" x)))
###                 ("_applC" ("_position" set) ("_position" Vs)))))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_applC" ("_position" blocks)
###           ("_tuple" ("_position" Vs)
###             ("_tuple_args" ("_position" Ts)
###               ("_tuple_args" ("_position" vs)
###                 ("_tuple_arg" ("_position" e))))))))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_applC" ("_position" blocks)
###           ("_tuple" ("_position" Vs)
###             ("_tuple_args" ("_position" Ts)
###               ("_tuple_args" ("_position" vs'')
###                 ("_tuple_arg" ("_position" e'))))))))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update"
###           ("_applC" ("_position" override_on)
###             ("_cargs" ("_position" l\<^sub>1)
###               ("_cargs"
###                 ("_MapUpd" ("_position" l\<^sub>0)
###                   ("_maplet" ("_position" V) ("_position" x)))
###                 ("_applC" ("_position" set) ("_position" Vs)))))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 914 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 917 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 918 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_applC" ("_position" l\<^sub>1)
###   ("\<^const>Expr.expr.LAss" ("_position" V)
###     ("_applC" ("_position" l\<^sub>0) ("_position" V))))
### ("_Update" ("_position" l\<^sub>1)
###   ("_updbind" ("_position" V)
###     ("_applC" ("_position" l\<^sub>0) ("_position" V))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 817 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v''')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v''')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v''')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v''')))
###         ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V)
###         ("\<^const>Expr.expr.LAss" ("_position" T)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V))))))
###       ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v''')) ("_position" e'))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))
###     ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###       ("_position" v''') ("_position" w))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 920 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_tuple"
###   ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###     ("_position" e\<^sub>1))
###   ("_tuple_arg"
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("_tuple"
###   ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###     ("_position" e\<^sub>1))
###   ("_tuple_arg"
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 821 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_applC" ("_position" l'')
###   ("\<^const>Expr.expr.LAss" ("_position" V)
###     ("_applC" ("_position" l) ("_position" V))))
### ("_Update" ("_position" l'')
###   ("_updbind" ("_position" V) ("_applC" ("_position" l) ("_position" V))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ambiguous input (line 927 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_position" e\<^sub>0))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 930 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>2)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1))
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))
###     ("_position" e\<^sub>2)
###     ("_tuple" ("_position" h\<^sub>2)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>2)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 932 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_applC" ("_position" l\<^sub>1)
###   ("\<^const>Expr.expr.LAss" ("_position" V)
###     ("_applC" ("_position" l\<^sub>0) ("_position" V))))
### ("_Update" ("_position" l\<^sub>1)
###   ("_updbind" ("_position" V)
###     ("_applC" ("_position" l\<^sub>0) ("_position" V))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 825 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###     ("\<^const>HOL.conj"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("\<^const>Expr.expr.Seq"
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e)))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("\<^const>Expr.expr.Seq"
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e')))
###         ("_tuple" ("_position" h')
###           ("_tuple_arg"
###             ("_applC" ("_position" l')
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V)))))))
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v'') ("_position" w)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" v'') ("_position" w))
###     ("\<^const>HOL.conj"
###       ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("\<^const>Expr.expr.Seq"
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" Val) ("_position" v)))
###             ("_position" e)))
###         ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###         ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###           ("\<^const>Expr.expr.Seq"
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" Val) ("_position" v'')))
###             ("_position" e')))
###         ("_tuple" ("_position" h')
###           ("_tuple_arg"
###             ("_Update" ("_position" l')
###               ("_updbind" ("_position" V)
###                 ("_applC" ("_position" l) ("_position" V)))))))
###       ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###         ("_position" v'') ("_position" w)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 936 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_tuple"
###   ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1)))
###   ("_tuple_arg"
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_applC" ("_position" l\<^sub>1)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### ("_tuple"
###   ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_position" V)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e\<^sub>1)))
###   ("_tuple_arg"
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("_Update" ("_position" l\<^sub>1)
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l\<^sub>0) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### No such looper in simpset: "split_all_tac"
### Ambiguous input (line 832 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e)))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_Update" ("_position" l')
###                       ("_updbind" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" h)
###       ("_idts" ("_position" l)
###         ("_idts" ("_position" h')
###           ("_idts" ("_position" l')
###             ("_idts" ("_position" v) ("_position" v'))))))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.eq" ("_position" s)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_MapUpd" ("_position" l)
###               ("_maplet" ("_position" V) ("_position" v'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###           ("_position" v) ("_position" v'))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_position" s')
###             ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l'))))
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" v'') ("_position" w))
###             ("\<^const>HOL.conj"
###               ("\<^const>SmallStep.Step" ("_position" P) ("_position" E)
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v)))
###                     ("_position" e)))
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###                 ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###                   ("\<^const>Expr.expr.Seq"
###                     ("\<^const>Expr.expr.LAss" ("_position" V)
###                       ("_applC" ("_position" Val) ("_position" v'')))
###                     ("_position" e')))
###                 ("_tuple" ("_position" h')
###                   ("_tuple_arg"
###                     ("_applC" ("_position" l')
###                       ("\<^const>Expr.expr.LAss" ("_position" V)
###                         ("_applC" ("_position" l) ("_position" V)))))))
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v'') ("_position" w)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.Equivalence"
### 0.920s elapsed time, 5.967s cpu time, 0.296s GC time
Loading theory "CoreC++.Progress" (required by "CoreC++.CoreC++" via "CoreC++.Determinism" via "CoreC++.TypeSafe" via "CoreC++.HeapExtension")
### Ambiguous input (line 1723 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" p) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" blocks)
###         ("_tuple" ("_position" ps')
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" vs')
###               ("_tuple_arg" ("_position" e)))))))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" p)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" blocks)
###         ("_tuple" ("_position" ps')
###           ("_tuple_args" ("_position" Ts')
###             ("_tuple_args" ("_position" vs')
###               ("_tuple_arg" ("_position" e)))))))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_position" e')
###     ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1727 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" l')
###     ("_applC" ("_position" l''')
###       ("\<^const>Expr.expr.LAss" ("_position" p)
###         ("_applC" ("_position" l) ("_position" p))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" l')
###     ("_Update" ("_position" l''')
###       ("_updbind" ("_position" p)
###         ("_applC" ("_position" l) ("_position" p))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.Progress"
### 0.471s elapsed time, 3.745s cpu time, 0.282s GC time
### Ambiguous input (line 1846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" W)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq"
###         ("_applC" ("_position" fv) ("_position" e\<^sub>0))
###         ("_position" W)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("\<^const>Map.restrict_map"
###               ("_Update" ("_position" l\<^sub>0)
###                 ("_updbind" ("_position" V) ("_position" None)))
###               ("_position" W))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg"
###             ("\<^const>Map.restrict_map" ("_position" l\<^sub>1)
###               ("_position" W))))))))
### ("\<^const>Pure.all_binder" ("_position" W)
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.subset_eq"
###         ("_applC" ("_position" fv) ("_position" e\<^sub>0))
###         ("_position" W)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("\<^const>Map.restrict_map"
###               ("_applC" ("_position" l\<^sub>0)
###                 ("\<^const>Expr.expr.LAss" ("_position" V)
###                   ("_position" None)))
###               ("_position" W))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg"
###             ("\<^const>Map.restrict_map" ("_position" l\<^sub>1)
###               ("_position" W))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1853 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e\<^sub>0)
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg"
###         ("_Update"
###           ("\<^const>Map.restrict_map" ("_position" l\<^sub>0)
###             ("_position" W))
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e\<^sub>1)
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("\<^const>Map.restrict_map" ("_position" l\<^sub>1)
###           ("_applC" ("_position" insert)
###             ("_cargs" ("_position" V) ("_position" W))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e\<^sub>0)
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg"
###         ("_applC"
###           ("\<^const>Map.restrict_map" ("_position" l\<^sub>0)
###             ("_position" W))
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e\<^sub>1)
###     ("_tuple" ("_position" h\<^sub>1)
###       ("_tuple_arg"
###         ("\<^const>Map.restrict_map" ("_position" l\<^sub>1)
###           ("_applC" ("_position" insert)
###             ("_cargs" ("_position" V) ("_position" W))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
\<lbrakk>?P,?E \<turnstile> \<langle>?e,?s\<^sub>0\<rangle> \<rightarrow>*
                            \<langle>null,?s\<^sub>1\<rangle>;
 ?P,?E \<turnstile> \<langle>?es,?s\<^sub>1\<rangle> [\<rightarrow>]*
                    \<langle>map Val ?vs,?s\<^sub>2\<rangle>\<rbrakk>
\<Longrightarrow> ?P,?E \<turnstile> \<langle>Call ?e ?Copt ?M ?es,
?s\<^sub>0\<rangle> \<rightarrow>*
                                     \<langle>Throw
         (addr_of_sys_xcpt NullPointer, [NullPointer]),
?s\<^sub>2\<rangle>
### Ambiguous input (line 1907 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("_position" T))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" E) ("_position" V))
###     ("\<^const>Option.option.Some" ("_position" T))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1909 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.subset_eq"
###     ("_Update" ("_position" fv)
###       ("_updbind" ("_position" V) ("_position" e)))
###     ("_position" W)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.subset_eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" e)))
###     ("_position" W)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1925 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.subset_eq"
###     ("_Update" ("_position" fv)
###       ("_updbind"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("_position" W)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.subset_eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2)))
###     ("_position" W)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.subset_eq"
###     ("_applC" ("_position" fv)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2)))
###     ("_position" W)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ambiguous input (line 2197 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1') ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s'') ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1') ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s'') ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2201 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h\<^sub>2) ("_position" a))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h\<^sub>2) ("_position" a))
###     ("\<^const>Option.option.Some"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2205 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple"
###       ("_MapUpd" ("_position" h\<^sub>2)
###         ("_maplet" ("_position" a)
###           ("_tuple" ("_position" D)
###             ("_tuple_arg"
###               ("_applC" ("_position" insert)
###                 ("_cargs"
###                   ("_tuple"
###                     ("\<^const>SubObj.appendPath" ("_position" Cs')
###                       ("_position" Cs))
###                     ("_tuple_arg"
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v')))))
###                   ("\<^const>Groups.minus_class.minus" ("_position" S)
###                     ("_Finset"
###                       ("_tuple"
###                         ("\<^const>SubObj.appendPath" ("_position" Cs')
###                           ("_position" Cs))
###                         ("_tuple_arg" ("_position" fs)))))))))))
###       ("_tuple_arg" ("_position" l\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple"
###       ("_MapUpd" ("_position" h\<^sub>2)
###         ("_maplet" ("_position" a)
###           ("_tuple" ("_position" D)
###             ("_tuple_arg"
###               ("_applC" ("_position" insert)
###                 ("_cargs"
###                   ("_tuple"
###                     ("\<^const>SubObj.appendPath" ("_position" Cs')
###                       ("_position" Cs))
###                     ("_tuple_arg"
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v')))))
###                   ("\<^const>Groups.minus_class.minus" ("_position" S)
###                     ("_Finset"
###                       ("_tuple"
###                         ("\<^const>SubObj.appendPath" ("_position" Cs')
###                           ("_position" Cs))
###                         ("_tuple_arg" ("_position" fs)))))))))))
###       ("_tuple_arg" ("_position" l\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2213 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2218 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" e'))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" e'))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" e'))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###       ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" e'))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2231 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2'))
###     ("_position" s'') ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs) ("_position" e\<^sub>2'))
###     ("_position" s'') ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2236 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h\<^sub>2) ("_position" a))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h\<^sub>2) ("_position" a))
###     ("\<^const>Option.option.Some"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2242 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Val) ("_position" v''))
###     ("_tuple"
###       ("_MapUpd" ("_position" h\<^sub>2)
###         ("_maplet" ("_position" a)
###           ("_tuple" ("_position" D)
###             ("_tuple_arg"
###               ("_applC" ("_position" insert)
###                 ("_cargs"
###                   ("_tuple"
###                     ("\<^const>SubObj.appendPath" ("_position" Cs')
###                       ("_position" Cs))
###                     ("_tuple_arg"
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v'')))))
###                   ("\<^const>Groups.minus_class.minus" ("_position" S)
###                     ("_Finset"
###                       ("_tuple"
###                         ("\<^const>SubObj.appendPath" ("_position" Cs')
###                           ("_position" Cs))
###                         ("_tuple_arg" ("_position" fs)))))))))))
###       ("_tuple_arg" ("_position" l\<^sub>2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" Val) ("_position" v''))
###     ("_tuple"
###       ("_MapUpd" ("_position" h\<^sub>2)
###         ("_maplet" ("_position" a)
###           ("_tuple" ("_position" D)
###             ("_tuple_arg"
###               ("_applC" ("_position" insert)
###                 ("_cargs"
###                   ("_tuple"
###                     ("\<^const>SubObj.appendPath" ("_position" Cs')
###                       ("_position" Cs))
###                     ("_tuple_arg"
###                       ("_MapUpd" ("_position" fs)
###                         ("_maplet" ("_position" F) ("_position" v'')))))
###                   ("\<^const>Groups.minus_class.minus" ("_position" S)
###                     ("_Finset"
###                       ("_tuple"
###                         ("\<^const>SubObj.appendPath" ("_position" Cs')
###                           ("_position" Cs))
###                         ("_tuple_arg" ("_position" fs)))))))))))
###       ("_tuple_arg" ("_position" l\<^sub>2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2253 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" THROW) ("_position" NullPointer))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2258 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" r))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" r))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2268 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.LAss"
###       ("\<^const>Expr.expr.FAcc"
###         ("_applC" ("_position" Val) ("_position" v)) ("_position" F)
###         ("_position" Cs))
###       ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" r))
###     ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.FAss" ("_applC" ("_position" Val) ("_position" v))
###       ("_position" F) ("_position" Cs) ("_position" e\<^sub>2))
###     ("_position" s) ("_applC" ("_position" throw) ("_position" r))
###     ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" h) ("_position" a))
###     ("\<^const>Option.option.Some"
###       ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Replacing higher order arguments is not applied in an undestructable product type
### Replacing higher order arguments is not applied in an undestructable product type
### Replacing higher order arguments is not applied in an undestructable product type
### Ambiguous input (line 2567 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)) ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2568 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e'')
###     ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SmallStep.red'" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e'')
###     ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2570 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" ex) ("_position" sx))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e'')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))
###         ("_position" ex) ("_position" sx)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_Update" ("_position" l)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" ex) ("_position" sx)))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" ex) ("_position" sx))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e'')
###         ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l')))
###         ("_position" ex) ("_position" sx)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>BigStep.eval" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e)
###         ("_tuple" ("_position" h)
###           ("_tuple_arg"
###             ("_applC" ("_position" l)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" ex) ("_position" sx)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2578 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v)))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2584 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h\<^sub>0)
###       ("_tuple_arg" ("_position" l\<^sub>0)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2587 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj" ("\<^const>HOL.eq" ("_position" v) ("_position" v'))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_position" h') ("_position" h\<^sub>0))
###       ("\<^const>HOL.eq"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V) ("_position" None)))
###         ("_position" l\<^sub>0)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj" ("\<^const>HOL.eq" ("_position" v) ("_position" v'))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq" ("_position" h') ("_position" h\<^sub>0))
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###         ("_position" l\<^sub>0)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2595 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s')
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s')
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Replacing higher order arguments is not applied in an undestructable product type
### Ambiguous input (line 2604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l'')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_position" e)
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_position" e')
###     ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l'')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2608 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_applC" ("_position" l')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v'')) ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v'')))
###       ("_position" e''))
###     ("_tuple" ("_position" h')
###       ("_tuple_arg"
###         ("_Update" ("_position" l')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2620 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_Update" ("_position" l'')
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_Update" ("_position" l')
###             ("_updbind" ("_position" V) ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>BigStep.eval" ("_position" P)
###       ("_MapUpd" ("_position" E)
###         ("_maplet" ("_position" V) ("_position" T)))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_position" V)
###           ("_applC" ("_position" Val) ("_position" v'')))
###         ("_position" e''))
###       ("_tuple" ("_position" h')
###         ("_tuple_arg"
###           ("_applC" ("_position" l')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_position" None)))))
###       ("_position" e')
###       ("_tuple" ("_position" h'') ("_tuple_arg" ("_position" l''))))
###     ("\<^const>HOL.eq" ("_position" s')
###       ("_tuple" ("_position" h'')
###         ("_tuple_arg"
###           ("_applC" ("_position" l'')
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2631 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s')
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_Update" ("_position" l'')
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" s')
###     ("_tuple" ("_position" h'')
###       ("_tuple_arg"
###         ("_applC" ("_position" l'')
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2638 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2639 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_Update" ("_position" l) ("_updbind" ("_position" V) ("_position" None)))
### ("_applC" ("_position" l)
###   ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2648 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2650 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_Update" ("_position" l)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_applC" ("_position" l)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_Update" ("_position" l)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_applC" ("_position" l)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2660 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2663 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2664 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_Update" ("_position" l) ("_updbind" ("_position" V) ("_position" None)))
### ("_applC" ("_position" l)
###   ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2665 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" Val) ("_position" u)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" u))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" Val) ("_position" u)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" u))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" Val) ("_position" u)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" u))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" Val) ("_position" u)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Val) ("_position" u))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 677 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asms"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" Predicate_Compile.contains)
###                     ("_cargs"
###                       ("_applC" ("_position" Set_project)
###                         ("_cargs" ("_position" S) ("_position" Ds)))
###                       ("_position" fs))))
###                 ("_asms"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" fs')
###                       ("_applC" ("_position" Mapping.update)
###                         ("_cargs" ("_position" F)
###                           ("_cargs" ("_position" v') ("_position" fs))))))
###                   ("_asms"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" S')
###                         ("\<^const>Set.union"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" S)
###                             ("_Finset"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))))
###                           ("_Finset"
###                             ("_tuple" ("_position" Ds)
###                               ("_tuple_arg" ("_position" fs')))))))
###                     ("_asm"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                           ("_MapUpd" ("_position" h\<^sub>2)
###                             ("_maplet" ("_position" a)
###                               ("_tuple" ("_position" D)
###                                 ("_tuple_arg"
###                                   ("_position" S')))))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" ref)
###           ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs'))))
###         ("_position" s\<^sub>1)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_tuple" ("_position" h\<^sub>2)
###             ("_tuple_arg" ("_position" l\<^sub>2)))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" h\<^sub>2) ("_position" a))
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S))))))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###               ("_applC" ("_position" last) ("_position" Cs'))
###               ("_position" F) ("_position" T) ("_position" Cs)))
###           ("_asms"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>SubObj.casts_to" ("_position" P) ("_position" T)
###                 ("_position" v) ("_position" v')))
###             ("_asms"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq" ("_position" Ds)
###                   ("\<^const>SubObj.appendPath" ("_position" Cs')
###                     ("_position" Cs))))
###               ("_asms"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" Predicate_Compile.contains)
###                     ("_cargs"
###                       ("_applC" ("_position" Set_project)
###                         ("_cargs" ("_position" S) ("_position" Ds)))
###                       ("_position" fs))))
###                 ("_asms"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" fs')
###                       ("_applC" ("_position" Mapping.update)
###                         ("_cargs" ("_position" F)
###                           ("_cargs" ("_position" v') ("_position" fs))))))
###                   ("_asms"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" S')
###                         ("\<^const>Set.union"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" S)
###                             ("_Finset"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))))
###                           ("_Finset"
###                             ("_tuple" ("_position" Ds)
###                               ("_tuple_arg" ("_position" fs')))))))
###                     ("_asm"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq" ("_position" h\<^sub>2')
###                           ("_MapUpd" ("_position" h\<^sub>2)
###                             ("_maplet" ("_position" a)
###                               ("_tuple" ("_position" D)
###                                 ("_tuple_arg"
###                                   ("_position" S')))))))))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0) ("_applC" ("_position" Val) ("_position" v'))
###       ("_tuple" ("_position" h\<^sub>2')
###         ("_tuple_arg" ("_position" l\<^sub>2))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 686 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0) ("_position" null)
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" Val) ("_position" v))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" THROW) ("_position" NullPointer))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 691 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>1))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 696 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.LAss"
###         ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1) ("_position" F)
###           ("_position" Cs))
###         ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###         ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###         ("_applC" ("_position" Val) ("_position" v))
###         ("_position" s\<^sub>1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###           ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###           ("_applC" ("_position" throw) ("_position" e'))
###           ("_position" s\<^sub>2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###         ("_position" Cs) ("_position" e\<^sub>2))
###       ("_position" s\<^sub>0)
###       ("_applC" ("_position" throw) ("_position" e'))
###       ("_position" s\<^sub>2))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 755 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_applC" ("_position" l\<^sub>1)
###             ("\<^const>Expr.expr.LAss" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_applC" ("_position" l\<^sub>0)
###               ("\<^const>Expr.expr.LAss" ("_position" V)
###                 ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### ("_bigimpl"
###   ("_asm"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Execute.eval'" ("_position" P)
###         ("_MapUpd" ("_position" E)
###           ("_maplet" ("_position" V) ("_position" T)))
###         ("_position" e\<^sub>0)
###         ("_tuple" ("_position" h\<^sub>0)
###           ("_tuple_arg"
###             ("_Update" ("_position" l\<^sub>0)
###               ("_updbind" ("_position" V) ("_position" None)))))
###         ("_position" e\<^sub>1)
###         ("_tuple" ("_position" h\<^sub>1)
###           ("_tuple_arg" ("_position" l\<^sub>1))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###       ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###         ("_position" e\<^sub>0))
###       ("_tuple" ("_position" h\<^sub>0)
###         ("_tuple_arg" ("_position" l\<^sub>0)))
###       ("_position" e\<^sub>1)
###       ("_tuple" ("_position" h\<^sub>1)
###         ("_tuple_arg"
###           ("_Update" ("_position" l\<^sub>1)
###             ("_updbind" ("_position" V)
###               ("_applC" ("_position" l\<^sub>0) ("_position" V)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 854 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h)
###     ("_idts" ("_position" a)
###       ("_idts" ("_position" h')
###         ("_idts" ("_position" C)
###           ("_idts" ("_position" E) ("_position" l))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" new) ("_position" C))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" ref)
###                 ("_tuple" ("_position" a)
###                   ("_tuple_arg" ("_list" ("_position" C)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" new_Addr') ("_position" h))
###                   ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                     ("_position" a))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" h')
###                     ("_MapUpd" ("_position" h)
###                       ("_maplet" ("_position" a)
###                         ("_applC" ("_position" blank')
###                           ("_cargs" ("_position" P) ("_position" C)))))))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" h)
###     ("_idts" ("_position" a)
###       ("_idts" ("_position" h')
###         ("_idts" ("_position" C)
###           ("_idts" ("_position" E) ("_position" l))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" new) ("_position" C))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" ref)
###                 ("_tuple" ("_position" a)
###                   ("_tuple_arg" ("_list" ("_position" C)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h') ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" new_Addr') ("_position" h))
###                   ("\<^const>Option.option.Some" ("_position" a))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq" ("_position" h')
###                     ("_MapUpd" ("_position" h)
###                       ("_maplet" ("_position" a)
###                         ("_applC" ("_position" blank')
###                           ("_cargs" ("_position" P) ("_position" C)))))))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 876 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" C) ("_position" Cs')))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Cast)
###             ("_cargs" ("_position" C) ("_position" e)))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" ref)
###                 ("_tuple" ("_position" a)
###                   ("_tuple_arg" ("_position" Cs'))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.path_via" ("_position" P)
###                       ("_position" D) ("_position" C) ("_position" Cs')))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.path_unique" ("_position" P)
###                         ("_position" D) ("_position" C)))
###                     ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" C) ("_position" Cs')))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Cast)
###             ("_cargs" ("_position" C) ("_position" e)))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" ref)
###                 ("_tuple" ("_position" a)
###                   ("_tuple_arg" ("_position" Cs'))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.path_via" ("_position" P)
###                       ("_position" D) ("_position" C) ("_position" Cs')))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.path_unique" ("_position" P)
###                         ("_position" D) ("_position" C)))
###                     ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 881 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S) ("_position" C))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Cast)
###             ("_cargs" ("_position" C) ("_position" e)))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" null)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.Not"
###                       ("\<^const>SubObj.path_unique" ("_position" P)
###                         ("_position" D) ("_position" C))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.Not"
###                         ("\<^const>SubObj.path_unique" ("_position" P)
###                           ("_applC" ("_position" last) ("_position" Cs))
###                           ("_position" C))))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>Set.not_member" ("_position" C)
###                           ("_applC" ("_position" set) ("_position" Cs))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S) ("_position" C))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Cast)
###             ("_cargs" ("_position" C) ("_position" e)))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" null)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.Not"
###                       ("\<^const>SubObj.path_unique" ("_position" P)
###                         ("_position" D) ("_position" C))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.Not"
###                         ("\<^const>SubObj.path_unique" ("_position" P)
###                           ("_applC" ("_position" last) ("_position" Cs))
###                           ("_position" C))))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>Set.not_member" ("_position" C)
###                           ("_applC" ("_position" set) ("_position" Cs))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 887 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" v\<^sub>1)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" v\<^sub>2)
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" bop) ("_position" va))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.BinOp" ("_position" e\<^sub>1)
###             ("_position" bop) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" v\<^sub>1))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" v\<^sub>2))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" binop)
###                         ("_tuple" ("_position" bop)
###                           ("_tuple_args" ("_position" v\<^sub>1)
###                             ("_tuple_arg" ("_position" v\<^sub>2)))))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_position" va))))
###                   ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" v\<^sub>1)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" v\<^sub>2)
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" bop) ("_position" va))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.BinOp" ("_position" e\<^sub>1)
###             ("_position" bop) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" v\<^sub>1))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" v\<^sub>2))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" binop)
###                         ("_tuple" ("_position" bop)
###                           ("_tuple_args" ("_position" v\<^sub>1)
###                             ("_tuple_arg" ("_position" v\<^sub>2)))))
###                       ("\<^const>Option.option.Some" ("_position" va))))
###                   ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 894 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" l)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" va) ("_idts" ("_position" E) ("_position" h)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Var) ("_position" V))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" l) ("_position" V))
###                   ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                     ("_position" va))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" l)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" va) ("_idts" ("_position" E) ("_position" h)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Var) ("_position" V))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_position" l) ("_position" V))
###                   ("\<^const>Option.option.Some" ("_position" va))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 896 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" h)
###             ("_idts" ("_position" l)
###               ("_idts" ("_position" V)
###                 ("_idts" ("_position" T)
###                   ("_idts" ("_position" v') ("_position" l'))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" e))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l')))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" E) ("_position" V))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_position" T))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.casts_to" ("_position" P)
###                       ("_position" T) ("_position" va) ("_position" v')))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" l')
###                         ("_MapUpd" ("_position" l)
###                           ("_maplet" ("_position" V) ("_position" v')))))
###                     ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" h)
###             ("_idts" ("_position" l)
###               ("_idts" ("_position" V)
###                 ("_idts" ("_position" T)
###                   ("_idts" ("_position" v') ("_position" l'))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" e))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l')))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" E) ("_position" V))
###                     ("\<^const>Option.option.Some" ("_position" T))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.casts_to" ("_position" P)
###                       ("_position" T) ("_position" va) ("_position" v')))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>HOL.eq" ("_position" l')
###                         ("_MapUpd" ("_position" l)
###                           ("_maplet" ("_position" V) ("_position" v')))))
###                     ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 901 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 8 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                             ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                             ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                             ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                             ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Option.option.Some" ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Option.option.Some" ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Option.option.Some" ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" h)
###               ("_idts" ("_position" l)
###                 ("_idts" ("_position" D)
###                   ("_idts" ("_position" S)
###                     ("_idts" ("_position" Ds)
###                       ("_idts" ("_position" Cs)
###                         ("_idts" ("_position" fs)
###                           ("_idts" ("_position" F)
###                             ("_position" va))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" va))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_tuple" ("_position" h)
###                     ("_tuple_arg" ("_position" l)))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_position" h) ("_position" a))
###                     ("\<^const>Option.option.Some"
###                       ("_tuple" ("_position" D)
###                         ("_tuple_arg" ("_position" S))))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq" ("_position" Ds)
###                       ("\<^const>SubObj.appendPath" ("_position" Cs')
###                         ("_position" Cs))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Set.member"
###                         ("_tuple" ("_position" Ds)
###                           ("_tuple_arg" ("_position" fs)))
###                         ("_position" S)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_position" Mapping.lookup)
###                             ("_cargs" ("_position" fs) ("_position" F)))
###                           ("\<^const>Option.option.Some" ("_position" va))))
###                       ("\<^const>HOL.Trueprop"
###                         ("_position" thesis)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 904 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" F) ("_position" Cs))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0) ("_position" null)
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" F) ("_position" Cs))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0) ("_position" null)
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 907 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F) ("_position" Cs)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAcc" ("_position" e) ("_position" F)
###             ("_position" Cs))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F) ("_position" Cs)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAcc"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e))
###           ("_position" F) ("_position" Cs)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 909 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 8 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" Cs))
###             ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAss"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###           ("_position" F) ("_position" Cs) ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###             ("_position" F) ("_position" Cs))
###           ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Option.option.Some"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" Cs))
###             ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Option.option.Some"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAss"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###           ("_position" F) ("_position" Cs) ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Option.option.Some"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs')
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" e\<^sub>2)
###                 ("_idts" ("_position" va)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" D)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" F)
###                             ("_idts" ("_position" T)
###                               ("_idts" ("_position" Cs)
###                                 ("_idts" ("_position" v')
###                                   ("_idts" ("_position" Ds)
###                                     ("_idts" ("_position" fs)
### ("_idts" ("_position" fs')
###   ("_idts" ("_position" S') ("_position" h\<^sub>2')))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###             ("_position" F) ("_position" Cs))
###           ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Val) ("_position" v'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>2')
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs'))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Option.option.Some"
###                         ("_tuple" ("_position" D)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastFieldDecl" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs'))
###                         ("_position" F) ("_position" T) ("_position" Cs)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.casts_to" ("_position" P)
###                           ("_position" T) ("_position" va)
###                           ("_position" v')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath" ("_position" Cs')
###                               ("_position" Cs))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>Set.member"
###                               ("_tuple" ("_position" Ds)
###                                 ("_tuple_arg" ("_position" fs)))
###                               ("_position" S)))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" fs')
###                                 ("_applC" ("_position" Mapping.update)
###                                   ("_cargs" ("_position" F)
###                                     ("_cargs" ("_position" v')
### ("_position" fs))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" S')
###                                   ("\<^const>Set.union"
###                                     ("\<^const>Groups.minus_class.minus"
### ("_position" S)
### ("_Finset" ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs)))))
###                                     ("_Finset"
### ("_tuple" ("_position" Ds) ("_tuple_arg" ("_position" fs')))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>HOL.eq"
###                                     ("_position" h\<^sub>2')
###                                     ("_MapUpd" ("_position" h\<^sub>2)
### ("_maplet" ("_position" a)
###   ("_tuple" ("_position" D) ("_tuple_arg" ("_position" S')))))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 915 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" e\<^sub>2)
###             ("_idts" ("_position" va)
###               ("_idts" ("_position" s\<^sub>2)
###                 ("_idts" ("_position" F) ("_position" Cs)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_position" null) ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" e\<^sub>2)
###             ("_idts" ("_position" va)
###               ("_idts" ("_position" s\<^sub>2)
###                 ("_idts" ("_position" F) ("_position" Cs)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" Cs))
###             ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_position" null) ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" e\<^sub>2)
###             ("_idts" ("_position" va)
###               ("_idts" ("_position" s\<^sub>2)
###                 ("_idts" ("_position" F) ("_position" Cs)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAss"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###           ("_position" F) ("_position" Cs) ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_position" null) ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" s\<^sub>1)
###           ("_idts" ("_position" e\<^sub>2)
###             ("_idts" ("_position" va)
###               ("_idts" ("_position" s\<^sub>2)
###                 ("_idts" ("_position" F) ("_position" Cs)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###             ("_position" F) ("_position" Cs))
###           ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" Throw)
###                 ("_tuple"
###                   ("_applC" ("_position" addr_of_sys_xcpt)
###                     ("_position" NullPointer))
###                   ("_tuple_arg" ("_list" ("_position" NullPointer)))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_position" null) ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" Val) ("_position" va))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 918 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F)
###               ("_idts" ("_position" Cs) ("_position" e\<^sub>2))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F)
###               ("_idts" ("_position" Cs) ("_position" e\<^sub>2))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" Cs))
###             ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F)
###               ("_idts" ("_position" Cs) ("_position" e\<^sub>2))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAss"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###           ("_position" F) ("_position" Cs) ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" e')
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" F)
###               ("_idts" ("_position" Cs) ("_position" e\<^sub>2))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###             ("_position" F) ("_position" Cs))
###           ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>1)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" throw) ("_position" e'))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 920 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" e')
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" F) ("_position" Cs))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.FAss" ("_position" e\<^sub>1) ("_position" F)
###             ("_position" Cs) ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" throw) ("_position" e'))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" e')
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" F) ("_position" Cs))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc" ("_position" e\<^sub>1)
###               ("_position" F) ("_position" Cs))
###             ("_position" e\<^sub>2))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" throw) ("_position" e'))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" e')
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" F) ("_position" Cs))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.FAss"
###           ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###           ("_position" F) ("_position" Cs) ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" throw) ("_position" e'))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e\<^sub>1)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" va)
###           ("_idts" ("_position" s\<^sub>1)
###             ("_idts" ("_position" e\<^sub>2)
###               ("_idts" ("_position" e')
###                 ("_idts" ("_position" s\<^sub>2)
###                   ("_idts" ("_position" F) ("_position" Cs))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("\<^const>HOL.eq" ("_position" y) ("_position" e\<^sub>1))
###             ("_position" F) ("_position" Cs))
###           ("_position" e\<^sub>2)))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u)
###               ("_applC" ("_position" throw) ("_position" e'))))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v) ("_position" s\<^sub>2)))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e\<^sub>1) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" Val) ("_position" va))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                     ("_position" e\<^sub>2) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" throw) ("_position" e'))
###                     ("_position" s\<^sub>2)))
###                 ("\<^const>HOL.Trueprop" ("_position" thesis))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 928 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" ps)
###                 ("_idts" ("_position" vs)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" C)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" M)
###                             ("_idts" ("_position" Ts')
###                               ("_idts" ("_position" T')
###                                 ("_idts" ("_position" pns')
###                                   ("_idts" ("_position" body')
###                                     ("_idts" ("_position" Ds)
### ("_idts" ("_position" Ts)
###   ("_idts" ("_position" T)
###     ("_idts" ("_position" pns)
###       ("_idts" ("_position" body)
###         ("_idts" ("_position" Cs')
###           ("_idts" ("_position" vs')
###             ("_idts" ("_position" l\<^sub>2')
###               ("_idts" ("_position" new_body)
###                 ("_idts" ("_position" e')
###                   ("_idts" ("_position" h\<^sub>3)
###                     ("_position" l\<^sub>3)))))))))))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Call)
###             ("_cargs" ("_position" e)
###               ("_cargs" ("_position" None)
###                 ("_cargs" ("_position" M) ("_position" ps)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e')))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>3)
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.evals'" ("_position" P) ("_position" E)
###                     ("_position" ps) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" map)
###                       ("_cargs" ("_position" Val) ("_position" vs)))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                         ("_tuple" ("_position" C)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs))
###                         ("_position" M)
###                         ("_tuple" ("_position" Ts')
###                           ("_tuple_args" ("_position" T')
###                             ("_tuple_args" ("_position" pns')
###                               ("_tuple_arg" ("_position" body')))))
###                         ("_position" Ds)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.SelectMethodDef" ("_position" P)
###                           ("_position" C)
###                           ("\<^const>SubObj.appendPath" ("_position" Cs)
###                             ("_position" Ds))
###                           ("_position" M)
###                           ("_tuple" ("_position" Ts)
###                             ("_tuple_args" ("_position" T)
###                               ("_tuple_args" ("_position" pns)
###                                 ("_tuple_arg" ("_position" body)))))
###                           ("_position" Cs')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_position" length) ("_position" vs))
###                             ("_applC" ("_position" length)
###                               ("_position" pns))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>SubObj.Casts_to" ("_position" P)
###                               ("_position" Ts) ("_position" vs)
###                               ("_position" vs')))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" l\<^sub>2')
###                                 ("_Map"
###                                   ("_Maplets"
###                                     ("_maplet" ("_position" this)
### ("_applC" ("_position" Ref)
###   ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs')))))
###                                     ("_maplets" ("_position" pns)
### ("_position" vs'))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" new_body)
###                                   ("_case_syntax" ("_position" T')
###                                     ("_case2"
### ("_case1" ("_applC" ("_position" Class) ("_position" D))
###   ("\<^const>Expr.expr.StatCast" ("_position" D) ("_position" body)))
### ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" body))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>Execute.eval'" ("_position" P)
###                                     ("_MapUpd" ("_position" E)
### ("_Maplets"
###   ("_maplet" ("_position" this)
###     ("_applC" ("_position" Class)
###       ("_applC" ("_position" last) ("_position" Cs'))))
###   ("_maplets" ("_position" pns) ("_position" Ts))))
###                                     ("_position" new_body)
###                                     ("_tuple" ("_position" h\<^sub>2)
### ("_tuple_arg" ("_position" l\<^sub>2')))
###                                     ("_position" e')
###                                     ("_tuple" ("_position" h\<^sub>3)
### ("_tuple_arg" ("_position" l\<^sub>3)))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" ps)
###                 ("_idts" ("_position" vs)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" C)
###                         ("_idts" ("_position" S)
###                           ("_idts" ("_position" M)
###                             ("_idts" ("_position" Ts')
###                               ("_idts" ("_position" T')
###                                 ("_idts" ("_position" pns')
###                                   ("_idts" ("_position" body')
###                                     ("_idts" ("_position" Ds)
### ("_idts" ("_position" Ts)
###   ("_idts" ("_position" T)
###     ("_idts" ("_position" pns)
###       ("_idts" ("_position" body)
###         ("_idts" ("_position" Cs')
###           ("_idts" ("_position" vs')
###             ("_idts" ("_position" l\<^sub>2')
###               ("_idts" ("_position" new_body)
###                 ("_idts" ("_position" e')
###                   ("_idts" ("_position" h\<^sub>3)
###                     ("_position" l\<^sub>3)))))))))))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Call)
###             ("_cargs" ("_position" e)
###               ("_cargs" ("_position" None)
###                 ("_cargs" ("_position" M) ("_position" ps)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e')))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>3)
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.evals'" ("_position" P) ("_position" E)
###                     ("_position" ps) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" map)
###                       ("_cargs" ("_position" Val) ("_position" vs)))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_position" h\<^sub>2) ("_position" a))
###                       ("\<^const>Option.option.Some"
###                         ("_tuple" ("_position" C)
###                           ("_tuple_arg" ("_position" S))))))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs))
###                         ("_position" M)
###                         ("_tuple" ("_position" Ts')
###                           ("_tuple_args" ("_position" T')
###                             ("_tuple_args" ("_position" pns')
###                               ("_tuple_arg" ("_position" body')))))
###                         ("_position" Ds)))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.SelectMethodDef" ("_position" P)
###                           ("_position" C)
###                           ("\<^const>SubObj.appendPath" ("_position" Cs)
###                             ("_position" Ds))
###                           ("_position" M)
###                           ("_tuple" ("_position" Ts)
###                             ("_tuple_args" ("_position" T)
###                               ("_tuple_args" ("_position" pns)
###                                 ("_tuple_arg" ("_position" body)))))
###                           ("_position" Cs')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_position" length) ("_position" vs))
###                             ("_applC" ("_position" length)
###                               ("_position" pns))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>SubObj.Casts_to" ("_position" P)
###                               ("_position" Ts) ("_position" vs)
###                               ("_position" vs')))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>HOL.eq" ("_position" l\<^sub>2')
###                                 ("_Map"
###                                   ("_Maplets"
###                                     ("_maplet" ("_position" this)
### ("_applC" ("_position" Ref)
###   ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Cs')))))
###                                     ("_maplets" ("_position" pns)
### ("_position" vs'))))))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" new_body)
###                                   ("_case_syntax" ("_position" T')
###                                     ("_case2"
### ("_case1" ("_applC" ("_position" Class) ("_position" D))
###   ("\<^const>Expr.expr.StatCast" ("_position" D) ("_position" body)))
### ("_case1" ("\<^const>Pure.dummy_pattern") ("_position" body))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>Execute.eval'" ("_position" P)
###                                     ("_MapUpd" ("_position" E)
### ("_Maplets"
###   ("_maplet" ("_position" this)
###     ("_applC" ("_position" Class)
###       ("_applC" ("_position" last) ("_position" Cs'))))
###   ("_maplets" ("_position" pns) ("_position" Ts))))
###                                     ("_position" new_body)
###                                     ("_tuple" ("_position" h\<^sub>2)
### ("_tuple_arg" ("_position" l\<^sub>2')))
###                                     ("_position" e')
###                                     ("_tuple" ("_position" h\<^sub>3)
### ("_tuple_arg" ("_position" l\<^sub>3)))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 937 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" ps)
###                 ("_idts" ("_position" vs)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" C)
###                         ("_idts" ("_position" Cs'')
###                           ("_idts" ("_position" M)
###                             ("_idts" ("_position" Ts)
###                               ("_idts" ("_position" T)
###                                 ("_idts" ("_position" pns)
###                                   ("_idts" ("_position" body)
###                                     ("_idts" ("_position" Cs')
### ("_idts" ("_position" Ds)
###   ("_idts" ("_position" vs')
###     ("_idts" ("_position" l\<^sub>2')
###       ("_idts" ("_position" e')
###         ("_idts" ("_position" h\<^sub>3)
###           ("_position" l\<^sub>3))))))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Call)
###             ("_cargs" ("_position" e)
###               ("_cargs" ("\<^const>Option.option.Some" ("_position" C))
###                 ("_cargs" ("_position" M) ("_position" ps)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e')))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>3)
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.evals'" ("_position" P) ("_position" E)
###                     ("_position" ps) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" map)
###                       ("_cargs" ("_position" Val) ("_position" vs)))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.path_unique" ("_position" P)
###                       ("_applC" ("_position" last) ("_position" Cs))
###                       ("_position" C)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.path_via" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs))
###                         ("_position" C) ("_position" Cs'')))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###                           ("_position" C) ("_position" M)
###                           ("_tuple" ("_position" Ts)
###                             ("_tuple_args" ("_position" T)
###                               ("_tuple_args" ("_position" pns)
###                                 ("_tuple_arg" ("_position" body)))))
###                           ("_position" Cs')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath"
###                               ("\<^const>SubObj.appendPath" ("_position" Cs)
###                                 ("_position" Cs''))
###                               ("_position" Cs'))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_position" length)
###                                 ("_position" vs))
###                               ("_applC" ("_position" length)
###                                 ("_position" pns))))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>SubObj.Casts_to" ("_position" P)
###                                 ("_position" Ts) ("_position" vs)
###                                 ("_position" vs')))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" l\<^sub>2')
###                                   ("_Map"
###                                     ("_Maplets"
### ("_maplet" ("_position" this)
###   ("_applC" ("_position" Ref)
###     ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Ds)))))
### ("_maplets" ("_position" pns) ("_position" vs'))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>Execute.eval'" ("_position" P)
###                                     ("_MapUpd" ("_position" E)
### ("_Maplets"
###   ("_maplet" ("_position" this)
###     ("_applC" ("_position" Class)
###       ("_applC" ("_position" last) ("_position" Ds))))
###   ("_maplets" ("_position" pns) ("_position" Ts))))
###                                     ("_position" body)
###                                     ("_tuple" ("_position" h\<^sub>2)
### ("_tuple_arg" ("_position" l\<^sub>2')))
###                                     ("_position" e')
###                                     ("_tuple" ("_position" h\<^sub>3)
### ("_tuple_arg" ("_position" l\<^sub>3)))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" e)
###       ("_idts" ("_position" s\<^sub>0)
###         ("_idts" ("_position" a)
###           ("_idts" ("_position" Cs)
###             ("_idts" ("_position" s\<^sub>1)
###               ("_idts" ("_position" ps)
###                 ("_idts" ("_position" vs)
###                   ("_idts" ("_position" h\<^sub>2)
###                     ("_idts" ("_position" l\<^sub>2)
###                       ("_idts" ("_position" C)
###                         ("_idts" ("_position" Cs'')
###                           ("_idts" ("_position" M)
###                             ("_idts" ("_position" Ts)
###                               ("_idts" ("_position" T)
###                                 ("_idts" ("_position" pns)
###                                   ("_idts" ("_position" body)
###                                     ("_idts" ("_position" Cs')
### ("_idts" ("_position" Ds)
###   ("_idts" ("_position" vs')
###     ("_idts" ("_position" l\<^sub>2')
###       ("_idts" ("_position" e')
###         ("_idts" ("_position" h\<^sub>3)
###           ("_position" l\<^sub>3))))))))))))))))))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("_applC" ("_position" Call)
###             ("_cargs" ("_position" e)
###               ("_cargs"
###                 ("\<^const>Archimedean_Field.floor_ceiling_class.floor"
###                   ("_position" C))
###                 ("_cargs" ("_position" M) ("_position" ps)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z) ("_position" s\<^sub>0)))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e')))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>3)
###                   ("_tuple_arg" ("_position" l\<^sub>2)))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P) ("_position" E)
###                   ("_position" e) ("_position" s\<^sub>0)
###                   ("_applC" ("_position" ref)
###                     ("_tuple" ("_position" a)
###                       ("_tuple_arg" ("_position" Cs))))
###                   ("_position" s\<^sub>1)))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("\<^const>Execute.evals'" ("_position" P) ("_position" E)
###                     ("_position" ps) ("_position" s\<^sub>1)
###                     ("_applC" ("_position" map)
###                       ("_cargs" ("_position" Val) ("_position" vs)))
###                     ("_tuple" ("_position" h\<^sub>2)
###                       ("_tuple_arg" ("_position" l\<^sub>2)))))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("\<^const>SubObj.path_unique" ("_position" P)
###                       ("_applC" ("_position" last) ("_position" Cs))
###                       ("_position" C)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>SubObj.path_via" ("_position" P)
###                         ("_applC" ("_position" last) ("_position" Cs))
###                         ("_position" C) ("_position" Cs'')))
###                     ("\<^const>Pure.imp"
###                       ("\<^const>HOL.Trueprop"
###                         ("\<^const>SubObj.LeastMethodDef" ("_position" P)
###                           ("_position" C) ("_position" M)
###                           ("_tuple" ("_position" Ts)
###                             ("_tuple_args" ("_position" T)
###                               ("_tuple_args" ("_position" pns)
###                                 ("_tuple_arg" ("_position" body)))))
###                           ("_position" Cs')))
###                       ("\<^const>Pure.imp"
###                         ("\<^const>HOL.Trueprop"
###                           ("\<^const>HOL.eq" ("_position" Ds)
###                             ("\<^const>SubObj.appendPath"
###                               ("\<^const>SubObj.appendPath" ("_position" Cs)
###                                 ("_position" Cs''))
###                               ("_position" Cs'))))
###                         ("\<^const>Pure.imp"
###                           ("\<^const>HOL.Trueprop"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_position" length)
###                                 ("_position" vs))
###                               ("_applC" ("_position" length)
###                                 ("_position" pns))))
###                           ("\<^const>Pure.imp"
###                             ("\<^const>HOL.Trueprop"
###                               ("\<^const>SubObj.Casts_to" ("_position" P)
###                                 ("_position" Ts) ("_position" vs)
###                                 ("_position" vs')))
###                             ("\<^const>Pure.imp"
###                               ("\<^const>HOL.Trueprop"
###                                 ("\<^const>HOL.eq" ("_position" l\<^sub>2')
###                                   ("_Map"
###                                     ("_Maplets"
### ("_maplet" ("_position" this)
###   ("_applC" ("_position" Ref)
###     ("_tuple" ("_position" a) ("_tuple_arg" ("_position" Ds)))))
### ("_maplets" ("_position" pns) ("_position" vs'))))))
###                               ("\<^const>Pure.imp"
###                                 ("\<^const>HOL.Trueprop"
###                                   ("\<^const>Execute.eval'" ("_position" P)
###                                     ("_MapUpd" ("_position" E)
### ("_Maplets"
###   ("_maplet" ("_position" this)
###     ("_applC" ("_position" Class)
###       ("_applC" ("_position" last) ("_position" Ds))))
###   ("_maplets" ("_position" pns) ("_position" Ts))))
###                                     ("_position" body)
###                                     ("_tuple" ("_position" h\<^sub>2)
### ("_tuple_arg" ("_position" l\<^sub>2')))
###                                     ("_position" e')
###                                     ("_tuple" ("_position" h\<^sub>3)
### ("_tuple_arg" ("_position" l\<^sub>3)))))
###                                 ("\<^const>HOL.Trueprop"
###                                   ("_position" thesis))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 949 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 4 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" e\<^sub>0)
###           ("_idts" ("_position" h\<^sub>0)
###             ("_idts" ("_position" l\<^sub>0)
###               ("_idts" ("_position" e\<^sub>1)
###                 ("_idts" ("_position" h\<^sub>1)
###                   ("_position" l\<^sub>1)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###             ("_position" e\<^sub>0))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h\<^sub>0)
###               ("_tuple_arg" ("_position" l\<^sub>0)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e\<^sub>1)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_Update" ("_position" l\<^sub>1)
###                       ("_updbind" ("_position" V)
###                         ("_applC" ("_position" l\<^sub>0)
###                           ("_position" V))))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P)
###                   ("_MapUpd" ("_position" E)
###                     ("_maplet" ("_position" V) ("_position" T)))
###                   ("_position" e\<^sub>0)
###                   ("_tuple" ("_position" h\<^sub>0)
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l\<^sub>0)
###                         ("_updbind" ("_position" V) ("_position" None)))))
###                   ("_position" e\<^sub>1)
###                   ("_tuple" ("_position" h\<^sub>1)
###                     ("_tuple_arg" ("_position" l\<^sub>1)))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" e\<^sub>0)
###           ("_idts" ("_position" h\<^sub>0)
###             ("_idts" ("_position" l\<^sub>0)
###               ("_idts" ("_position" e\<^sub>1)
###                 ("_idts" ("_position" h\<^sub>1)
###                   ("_position" l\<^sub>1)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###             ("_position" e\<^sub>0))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h\<^sub>0)
###               ("_tuple_arg" ("_position" l\<^sub>0)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e\<^sub>1)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_applC" ("_position" l\<^sub>1)
###                       ("\<^const>Expr.expr.LAss" ("_position" V)
###                         ("_applC" ("_position" l\<^sub>0)
###                           ("_position" V))))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P)
###                   ("_MapUpd" ("_position" E)
###                     ("_maplet" ("_position" V) ("_position" T)))
###                   ("_position" e\<^sub>0)
###                   ("_tuple" ("_position" h\<^sub>0)
###                     ("_tuple_arg"
###                       ("_Update" ("_position" l\<^sub>0)
###                         ("_updbind" ("_position" V) ("_position" None)))))
###                   ("_position" e\<^sub>1)
###                   ("_tuple" ("_position" h\<^sub>1)
###                     ("_tuple_arg" ("_position" l\<^sub>1)))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" e\<^sub>0)
###           ("_idts" ("_position" h\<^sub>0)
###             ("_idts" ("_position" l\<^sub>0)
###               ("_idts" ("_position" e\<^sub>1)
###                 ("_idts" ("_position" h\<^sub>1)
###                   ("_position" l\<^sub>1)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###             ("_position" e\<^sub>0))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h\<^sub>0)
###               ("_tuple_arg" ("_position" l\<^sub>0)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e\<^sub>1)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_Update" ("_position" l\<^sub>1)
###                       ("_updbind" ("_position" V)
###                         ("_applC" ("_position" l\<^sub>0)
###                           ("_position" V))))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P)
###                   ("_MapUpd" ("_position" E)
###                     ("_maplet" ("_position" V) ("_position" T)))
###                   ("_position" e\<^sub>0)
###                   ("_tuple" ("_position" h\<^sub>0)
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l\<^sub>0)
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_position" None)))))
###                   ("_position" e\<^sub>1)
###                   ("_tuple" ("_position" h\<^sub>1)
###                     ("_tuple_arg" ("_position" l\<^sub>1)))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" E)
###     ("_idts" ("_position" V)
###       ("_idts" ("_position" T)
###         ("_idts" ("_position" e\<^sub>0)
###           ("_idts" ("_position" h\<^sub>0)
###             ("_idts" ("_position" l\<^sub>0)
###               ("_idts" ("_position" e\<^sub>1)
###                 ("_idts" ("_position" h\<^sub>1)
###                   ("_position" l\<^sub>1)))))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" x) ("_position" E)))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" y)
###           ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###             ("_position" e\<^sub>0))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_position" z)
###             ("_tuple" ("_position" h\<^sub>0)
###               ("_tuple_arg" ("_position" l\<^sub>0)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq" ("_position" u) ("_position" e\<^sub>1)))
###           ("\<^const>Pure.imp"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq" ("_position" v)
###                 ("_tuple" ("_position" h\<^sub>1)
###                   ("_tuple_arg"
###                     ("_applC" ("_position" l\<^sub>1)
###                       ("\<^const>Expr.expr.LAss" ("_position" V)
###                         ("_applC" ("_position" l\<^sub>0)
###                           ("_position" V))))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>HOL.Trueprop"
###                 ("\<^const>Execute.eval'" ("_position" P)
###                   ("_MapUpd" ("_position" E)
###                     ("_maplet" ("_position" V) ("_position" T)))
###                   ("_position" e\<^sub>0)
###                   ("_tuple" ("_position" h\<^sub>0)
###                     ("_tuple_arg"
###                       ("_applC" ("_position" l\<^sub>0)
###                         ("\<^const>Expr.expr.LAss" ("_position" V)
###                           ("_position" None)))))
###                   ("_position" e\<^sub>1)
###                   ("_tuple" ("_position" h\<^sub>1)
###                     ("_tuple_arg" ("_position" l\<^sub>1)))))
###               ("\<^const>HOL.Trueprop" ("_position" thesis)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2731 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2733 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_Update" ("_position" l)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_applC" ("_position" l)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_Update" ("_position" l)
###             ("_updbind" ("_position" V) ("_position" None)))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_applC" ("_position" l)
###             ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2742 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_position" None)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2745 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update" ("_position" l)
###           ("_updbind" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P)
###     ("_MapUpd" ("_position" E) ("_maplet" ("_position" V) ("_position" T)))
###     ("\<^const>Expr.expr.LAss" ("_position" V)
###       ("_applC" ("_position" Val) ("_position" v)))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC" ("_position" l)
###           ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))))
###     ("_applC" ("_position" Val) ("_position" v'))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_MapUpd" ("_position" l)
###           ("_maplet" ("_position" V) ("_position" v')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2746 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("_Update" ("_position" l) ("_updbind" ("_position" V) ("_position" None)))
### ("_applC" ("_position" l)
###   ("\<^const>Expr.expr.LAss" ("_position" V) ("_position" None)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2747 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_applC"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("\<^const>Expr.expr.LAss" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_tuple" ("_position" h) ("_tuple_arg" ("_position" l)))
###     ("_applC" ("_position" Throw) ("_position" r))
###     ("_tuple" ("_position" h)
###       ("_tuple_arg"
###         ("_Update"
###           ("_MapUpd" ("_position" l)
###             ("_maplet" ("_position" V) ("_position" v')))
###           ("_updbind" ("_position" V)
###             ("_applC" ("_position" l) ("_position" V))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2749 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Equivalence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Syntax.InitBlock" ("_position" V) ("_position" T)
###       ("_applC" ("_position" Val) ("_position" v))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_position" s) ("_position" e') ("_position" s')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>BigStep.eval" ("_position" P) ("_position" E)
###     ("\<^const>Expr.expr.Block" ("_position" V)
###       ("\<^const>Expr.expr.LAss" ("_position" T)
###         ("_applC" ("_position" Val) ("_position" v)))
###       ("_applC" ("_position" Throw) ("_position" r)))
###     ("_position" s) ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "CoreC++.Execute"
### 23.776s elapsed time, 61.684s cpu time, 6.238s GC time
"{ref (0, [''Bottom'', ''Left''])}"
  :: "expr set"
"{Val (Intg 42)}"
  :: "expr set"
### Ambiguous input (line 1179 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_Maplets"
###         ("_maplet" ("_String" ("_position" ''V''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Right''))))
###         ("_maplet" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Bottom''))))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###         ("\<^const>Expr.expr.Seq"
###           ("\<^const>Expr.expr.LAss"
###             ("\<^const>Expr.expr.FAcc"
###               ("_applC" ("_position" Cast)
###                 ("_cargs" ("_String" ("_position" ''Left''))
###                   ("_applC" ("_position" Var)
###                     ("_String" ("_position" ''W'')))))
###               ("_String" ("_position" ''x''))
###               ("_list"
###                 ("_args" ("_String" ("_position" ''Left''))
###                   ("_String" ("_position" ''Top'')))))
###             ("_applC" ("_position" Val)
###               ("_applC" ("_position" Intg)
###                 ("_Numeral" ("_constify" ("_position" 3))))))
###           ("\<^const>Expr.StaticCall"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''W'')))
###             ("_String" ("_position" ''Left''))
###             ("_String" ("_position" ''f''))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###                 ("_applC" ("_position" Val)
###                   ("_applC" ("_position" Intg)
###                     ("_Numeral" ("_constify" ("_position" 2)))))))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_Maplets"
###         ("_maplet" ("_String" ("_position" ''V''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Right''))))
###         ("_maplet" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Bottom''))))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###         ("\<^const>Expr.expr.Seq"
###           ("\<^const>Expr.expr.FAss"
###             ("_applC" ("_position" Cast)
###               ("_cargs" ("_String" ("_position" ''Left''))
###                 ("_applC" ("_position" Var)
###                   ("_String" ("_position" ''W'')))))
###             ("_String" ("_position" ''x''))
###             ("_list"
###               ("_args" ("_String" ("_position" ''Left''))
###                 ("_String" ("_position" ''Top''))))
###             ("_applC" ("_position" Val)
###               ("_applC" ("_position" Intg)
###                 ("_Numeral" ("_constify" ("_position" 3))))))
###           ("\<^const>Expr.StaticCall"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''W'')))
###             ("_String" ("_position" ''Left''))
###             ("_String" ("_position" ''f''))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###                 ("_applC" ("_position" Val)
###                   ("_applC" ("_position" Intg)
###                     ("_Numeral" ("_constify" ("_position" 2)))))))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
"{Val (Intg 8), Val (Intg 8)}"
  :: "expr set"
"{Val (Intg 12)}"
  :: "expr set"
### Ambiguous input (line 1193 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_Maplets"
###         ("_maplet" ("_String" ("_position" ''V''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Right2''))))
###         ("_maplet" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Left''))))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###             ("_String" ("_position" ''x''))
###             ("_list"
###               ("_args" ("_String" ("_position" ''Right2''))
###                 ("_String" ("_position" ''Top'')))))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 6))))))
###         ("\<^const>Expr.expr.Seq"
###           ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''W''))
###             ("_applC" ("_position" new) ("_String" ("_position" ''Left''))))
###           ("\<^const>Expr.DynCall"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###             ("_String" ("_position" ''f''))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Var) ("_String" ("_position" ''W'')))
###                 ("_applC" ("_position" Val)
###                   ("_applC" ("_position" Intg)
###                     ("_Numeral" ("_constify" ("_position" 42)))))))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_Maplets"
###         ("_maplet" ("_String" ("_position" ''V''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Right2''))))
###         ("_maplet" ("_String" ("_position" ''W''))
###           ("_applC" ("_position" Class)
###             ("_String" ("_position" ''Left''))))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.FAss"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list"
###             ("_args" ("_String" ("_position" ''Right2''))
###               ("_String" ("_position" ''Top''))))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 6))))))
###         ("\<^const>Expr.expr.Seq"
###           ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''W''))
###             ("_applC" ("_position" new) ("_String" ("_position" ''Left''))))
###           ("\<^const>Expr.DynCall"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###             ("_String" ("_position" ''f''))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Var) ("_String" ("_position" ''W'')))
###                 ("_applC" ("_position" Val)
###                   ("_applC" ("_position" Intg)
###                     ("_Numeral" ("_constify" ("_position" 42)))))))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
"{\<lfloor>Intg 12\<rfloor>}"
  :: "val option set"
"{Val (Intg 13)}"
  :: "expr set"
### Ambiguous input (line 1205 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_maplet" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" Class)
###           ("_String" ("_position" ''Right2'')))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Right''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###             ("_String" ("_position" ''x''))
###             ("_list"
###               ("_args" ("_String" ("_position" ''Right2''))
###                 ("_String" ("_position" ''Top'')))))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 42))))))
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list"
###             ("_args" ("_String" ("_position" ''Right2''))
###               ("_String" ("_position" ''Top'')))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progOverrider)
###     ("_Map"
###       ("_maplet" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" Class)
###           ("_String" ("_position" ''Right2'')))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Right''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.FAss"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list"
###             ("_args" ("_String" ("_position" ''Right2''))
###               ("_String" ("_position" ''Top''))))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 42))))))
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list"
###             ("_args" ("_String" ("_position" ''Right2''))
###               ("_String" ("_position" ''Top'')))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
"{Val (Intg 5)}"
  :: "expr set"
"{ref (1, [''Left'', ''Top''])}"
  :: "expr set"
"{Val (Intg 42)}"
  :: "expr set"
"{Val (Intg 11)}"
  :: "expr set"
"{ref (0, [''Right''])}"
  :: "expr set"
"{Val (Intg 30)}"
  :: "expr set"
"{\<lfloor>Intg 6\<rfloor>}"
  :: "val option set"
"{Val (Intg 83)}"
  :: "expr set"
"{Class ''Left''}"
  :: "ty set"
"{Integer}"
  :: "ty set"
"{Integer}"
  :: "ty set"
"{Class ''Bottom''}"
  :: "ty set"
"{Integer}"
  :: "ty set"
"{Class ''Left''}"
  :: "ty set"
"{Integer, Integer}"
  :: "ty set"
"{Integer}"
  :: "ty set"
"{Class ''Top''}"
  :: "ty set"
"{Class ''Top''}"
  :: "ty set"
"{Void}"
  :: "ty set"
"{Integer}"
  :: "ty set"
"{Integer, Integer}"
  :: "ty set"
"{Void}"
  :: "ty set"
### Ambiguous input (line 1320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Execute.thy") produces 2 parse trees:
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progDiamond)
###     ("_Map"
###       ("_maplet" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" Class)
###           ("_String" ("_position" ''Bottom'')))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.LAss"
###           ("\<^const>Expr.expr.FAcc"
###             ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###             ("_String" ("_position" ''x''))
###             ("_list" ("_String" ("_position" ''Bottom''))))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 17))))))
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list" ("_String" ("_position" ''Bottom''))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### ("_Setcompr"
###   ("_applC" ("_position" fst)
###     ("_tuple" ("_position" e') ("_tuple_arg" ("_position" s'))))
###   ("_idts" ("_position" e') ("_position" s'))
###   ("\<^const>Execute.eval'" ("_position" progDiamond)
###     ("_Map"
###       ("_maplet" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" Class)
###           ("_String" ("_position" ''Bottom'')))))
###     ("\<^const>Expr.expr.Seq"
###       ("\<^const>Expr.expr.LAss" ("_String" ("_position" ''V''))
###         ("_applC" ("_position" new) ("_String" ("_position" ''Bottom''))))
###       ("\<^const>Expr.expr.Seq"
###         ("\<^const>Expr.expr.FAss"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list" ("_String" ("_position" ''Bottom'')))
###           ("_applC" ("_position" Val)
###             ("_applC" ("_position" Intg)
###               ("_Numeral" ("_constify" ("_position" 17))))))
###         ("\<^const>Expr.expr.FAcc"
###           ("_applC" ("_position" Var) ("_String" ("_position" ''V'')))
###           ("_String" ("_position" ''x''))
###           ("_list" ("_String" ("_position" ''Bottom''))))))
###     ("_tuple" ("_position" Map.empty)
###       ("_tuple_arg" ("_position" Map.empty)))
###     ("_position" e') ("_position" s')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
"{Class ''Top''}"
  :: "ty set"
"{Boolean}"
  :: "ty set"
"{}"
  :: "ty set"
"{ref (0, [''TopSh'']), ref (0, [''TopSh''])}"
  :: "expr set"
"{ref (0, [''Bottom'', ''Left'', ''TopRep'']),
  ref (0, [''Bottom'', ''Right'', ''TopRep''])}"
  :: "expr set"
"{Val (Intg 17)}"
  :: "expr set"
"{ref (0, [''Bottom'', ''Left''])}"
  :: "expr set"
"{ref (0, [''Bottom'', ''Left''])}"
  :: "expr set"
"{null}"
  :: "expr set"
"{null}"
  :: "expr set"
"{ref (0, [''Right''])}"
  :: "expr set"
"{Val (Intg 42)}"
  :: "expr set"
*** Inner lexical error (line 96 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** at "' Class C"
*** Failed to parse prop
*** At command "inductive" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** Inner lexical error (line 115 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** at "' T'; P \<turnstile> T' \<le> T \<rbrakk> 
***    \<Longrightarrow> P,E,h \<turnstile> e\<^sub>1\<bullet>F{Cs}:=e\<^sub>2 :' T"
*** Failed to parse prop
*** At command "inductive" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** Inner lexical error (line 137 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** at "' T;  P,E,h \<turnstile> es [:'] Ts \<rbrakk> \<Longrightarrow>  P,E,h \<turnstile> e#es [:'] T#Ts"
*** Failed to parse prop
*** At command "inductive" (line 89 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/CoreC++/Progress.thy")
*** Failed to load theory "CoreC++.HeapExtension" (unresolved "CoreC++.Progress")
*** Failed to load theory "CoreC++.TypeSafe" (unresolved "CoreC++.HeapExtension")
*** Failed to load theory "CoreC++.Determinism" (unresolved "CoreC++.TypeSafe")
*** Failed to load theory "CoreC++.CoreC++" (unresolved "CoreC++.Determinism")

==========
Count_Complex_Roots
Loading theory "HOL-Eisbach.Eisbach" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "HOL-Eisbach.Eisbach_Tools")
Loading theory "HOL-Computational_Algebra.Fraction_Field" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
Loading theory "HOL-Library.More_List" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Polynomial")
Loading theory "HOL-Computational_Algebra.Field_as_Ring" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski")
Loading theory "Winding_Number_Eval.Missing_Analysis" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem")
Loading theory "Winding_Number_Eval.Missing_Topology" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Winding_Number_Eval.Missing_Transcendental")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### theory "Winding_Number_Eval.Missing_Analysis"
### 0.107s elapsed time, 0.756s cpu time, 0.064s GC time
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
structure Eisbach_Rule_Insts: sig end
### theory "HOL-Library.More_List"
### 0.233s elapsed time, 1.712s cpu time, 0.166s GC time
Loading theory "HOL-Computational_Algebra.Polynomial" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial")
### theory "Winding_Number_Eval.Missing_Topology"
### 0.243s elapsed time, 1.787s cpu time, 0.166s GC time
*** Type unification failed: Variable 'a::type not of sort real_normed_vector
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  linepath ::
***   ??'a \<Rightarrow> ??'a \<Rightarrow> real \<Rightarrow> ??'a
*** Operand:   st :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::type not of sort real_normed_vector
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "obtain" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
*** Type unification failed
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (*) c :: complex \<Rightarrow> complex
*** Operand:   x :: 'b
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Cannot generate coercion from "'b" to "complex"
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 61 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Eisbach.Eisbach"
### 0.349s elapsed time, 2.555s cpu time, 0.280s GC time
Loading theory "HOL-Eisbach.Eisbach_Tools" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval")
val try_map = fn: 'a Seq.seq -> 'a Seq.seq -> 'a Seq.seq
val uncurry_rule = fn: thm -> thm
val curry_rule = fn: thm -> thm
### theory "HOL-Eisbach.Eisbach_Tools"
### 0.049s elapsed time, 0.363s cpu time, 0.038s GC time
*** Type unification failed: Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (-) (- w) :: ??'a \<Rightarrow> ??'a
*** Operand:   z :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Undefined fact: "contour_integral_integral" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** At command "unfolding" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "using" (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** Type unification failed: Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  deriv ::
***   (??'a \<Rightarrow> ??'a) \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   \<lambda>x. c * x + b :: 'a \<Rightarrow> 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 133 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
instantiation
  fract :: (idom) comm_ring_1
  uminus_fract == uminus :: 'a fract \<Rightarrow> 'a fract
  one_fract == one_class.one :: 'a fract
  times_fract == times ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  zero_fract == zero_class.zero :: 'a fract
  minus_fract == minus ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  plus_fract == plus ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
*** Undefined fact: "linordered_field_class.sign_simps" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
instantiation
  fract :: (idom) field
  inverse_fract == inverse :: 'a fract \<Rightarrow> 'a fract
  divide_fract == divide ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
class field = division_ring + idom_divide +
  assumes
    "field_inverse":
      "\<And>a.
          a \<noteq> (0::'a) \<Longrightarrow> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "\<And>a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
instantiation
  fract :: (linordered_idom) linorder
  less_eq_fract == less_eq ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> bool
  less_fract == less :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> bool
instantiation
  fract :: (linordered_idom) linordered_field
  sgn_fract == sgn :: 'a fract \<Rightarrow> 'a fract
  abs_fract == abs :: 'a fract \<Rightarrow> 'a fract
instantiation
  fract :: (linordered_idom) distrib_lattice
  inf_fract == inf :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  sup_fract == sup :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
### theory "HOL-Computational_Algebra.Fraction_Field"
### 0.771s elapsed time, 5.858s cpu time, 0.472s GC time
Loading theory "HOL-Computational_Algebra.Normalized_Fraction" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial")
instantiation
  real ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_real == division_segment :: real \<Rightarrow> real
  normalize_real == normalize :: real \<Rightarrow> real
  unit_factor_real == unit_factor :: real \<Rightarrow> real
  euclidean_size_real == euclidean_size :: real \<Rightarrow> nat
  modulo_real == modulo :: real \<Rightarrow> real \<Rightarrow> real
instantiation
  real :: euclidean_ring_gcd
  Gcd_real == Gcd :: real set \<Rightarrow> real
  Lcm_real == Lcm :: real set \<Rightarrow> real
  gcd_real == gcd :: real \<Rightarrow> real \<Rightarrow> real
  lcm_real == lcm :: real \<Rightarrow> real \<Rightarrow> real
instantiation
  rat ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_rat == division_segment :: rat \<Rightarrow> rat
  normalize_rat == normalize :: rat \<Rightarrow> rat
  unit_factor_rat == unit_factor :: rat \<Rightarrow> rat
  euclidean_size_rat == euclidean_size :: rat \<Rightarrow> nat
  modulo_rat == modulo :: rat \<Rightarrow> rat \<Rightarrow> rat
instantiation
  rat :: euclidean_ring_gcd
  Gcd_rat == Gcd :: rat set \<Rightarrow> rat
  Lcm_rat == Lcm :: rat set \<Rightarrow> rat
  gcd_rat == gcd :: rat \<Rightarrow> rat \<Rightarrow> rat
  lcm_rat == lcm :: rat \<Rightarrow> rat \<Rightarrow> rat
instantiation
  complex ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_complex == division_segment ::
    complex \<Rightarrow> complex
  normalize_complex == normalize :: complex \<Rightarrow> complex
  unit_factor_complex == unit_factor :: complex \<Rightarrow> complex
  euclidean_size_complex == euclidean_size :: complex \<Rightarrow> nat
  modulo_complex == modulo ::
    complex \<Rightarrow> complex \<Rightarrow> complex
locale fract_as_normalized_quot
instantiation
  complex :: euclidean_ring_gcd
  Gcd_complex == Gcd :: complex set \<Rightarrow> complex
  Lcm_complex == Lcm :: complex set \<Rightarrow> complex
  gcd_complex == gcd :: complex \<Rightarrow> complex \<Rightarrow> complex
  lcm_complex == lcm :: complex \<Rightarrow> complex \<Rightarrow> complex
### theory "HOL-Computational_Algebra.Field_as_Ring"
### 1.126s elapsed time, 8.485s cpu time, 0.620s GC time
instantiation
  poly :: (zero) zero
  zero_poly == zero_class.zero :: 'a poly
### theory "HOL-Computational_Algebra.Normalized_Fraction"
### 0.457s elapsed time, 3.352s cpu time, 0.176s GC time
consts
  Poly :: "'a list \<Rightarrow> 'a poly"
instantiation
  poly :: ({zero,equal}) equal
  equal_poly == equal_class.equal ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
instantiation
  poly :: (comm_monoid_add) comm_monoid_add
  plus_poly == plus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly == minus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (ab_group_add) ab_group_add
  uminus_poly == uminus :: 'a poly \<Rightarrow> 'a poly
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
instantiation
  poly :: (comm_semiring_0) comm_semiring_0
  times_poly == times :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (comm_semiring_1) comm_semiring_1
  one_poly == one_class.one :: 'a poly
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
instantiation
  poly :: (linordered_idom) linordered_idom
  sgn_poly == sgn :: 'a poly \<Rightarrow> 'a poly
  abs_poly == abs :: 'a poly \<Rightarrow> 'a poly
  less_eq_poly == less_eq ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
  less_poly == less :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
instantiation
  poly :: (idom_divide) idom_divide
  divide_poly == divide ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
instantiation
  poly :: ({idom_divide,semidom_divide_unit_factor}) normalization_semidom
  normalize_poly == normalize :: 'a poly \<Rightarrow> 'a poly
  unit_factor_poly == unit_factor :: 'a poly \<Rightarrow> 'a poly
class field_unit_factor = field + unit_factor +
  assumes "unit_factor_field": "unit_factor = id"
Proofs for inductive predicate(s) "eucl_rel_poly"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
instantiation
  poly :: (field) semidom_modulo
  modulo_poly == modulo ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "HOL-Computational_Algebra.Polynomial"
### 4.710s elapsed time, 24.283s cpu time, 2.837s GC time
Loading theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem")
Loading theory "HOL-Computational_Algebra.Polynomial_Factorial" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc")
### theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra"
### 0.225s elapsed time, 1.483s cpu time, 0.117s GC time
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
instantiation
  poly :: ({factorial_ring_gcd,semiring_gcd_mult_normalize})
    factorial_ring_gcd
  Gcd_poly == Gcd :: 'a poly set \<Rightarrow> 'a poly
  Lcm_poly == Lcm :: 'a poly set \<Rightarrow> 'a poly
  gcd_poly == gcd :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
  lcm_poly == lcm :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: ({factorial_ring_gcd,field,semiring_gcd_mult_normalize})
    {normalization_euclidean_semiring,unique_euclidean_ring}
  division_segment_poly == division_segment :: 'a poly \<Rightarrow> 'a poly
  euclidean_size_poly == euclidean_size :: 'a poly \<Rightarrow> nat
find_theorems
  name: "prod_mset_prime_factorization"

found 6 theorem(s):
Factorial_Ring.factorial_semiring_multiplicative_class.prod_mset_prime_factorization:
  ?x \<noteq> (0::?'a) \<Longrightarrow>
  prod_mset (prime_factorization ?x) = normalize ?x
Factorial_Ring.factorial_semiring_class.prod_mset_prime_factorization_weak:
  ?x \<noteq> (0::?'a) \<Longrightarrow>
  normalize (prod_mset (prime_factorization ?x)) = normalize ?x
local.field_poly.prod_mset_prime_factorization:
  ?x \<noteq> 0 \<Longrightarrow>
  prod_mset (field_poly.prime_factorization ?x) =
  smult (inverse (lead_coeff ?x)) ?x
Factorial_Ring.factorial_semiring_multiplicative.prod_mset_prime_factorization:
  \<lbrakk>class.factorial_semiring_multiplicative ?divide ?plus ?minus
            ?zero ?times ?one ?unit_factor ?normalize;
   ?x \<noteq> ?zero\<rbrakk>
  \<Longrightarrow> comm_monoid_mult.prod_mset ?times ?one
                     (factorial_semiring.prime_factorization ?zero ?times
                       ?one ?normalize ?x) =
                    ?normalize ?x
Factorial_Ring.factorial_semiring.prod_mset_prime_factorization_weak:
  \<lbrakk>class.factorial_semiring ?divide ?plus ?minus ?zero ?times ?one
            ?unit_factor ?normalize;
   ?x \<noteq> ?zero\<rbrakk>
  \<Longrightarrow> ?normalize
                     (comm_monoid_mult.prod_mset ?times ?one
                       (factorial_semiring.prime_factorization ?zero ?times
                         ?one ?normalize ?x)) =
                    ?normalize ?x
local.field_poly.prod_mset_prime_factorization_weak:
  ?x \<noteq> 0 \<Longrightarrow>
  smult
   (inverse (lead_coeff (prod_mset (field_poly.prime_factorization ?x))))
   (prod_mset (field_poly.prime_factorization ?x)) =
  smult (inverse (lead_coeff ?x)) ?x
### theory "HOL-Computational_Algebra.Polynomial_Factorial"
### 9.217s elapsed time, 16.993s cpu time, 3.539s GC time
Loading theory "Sturm_Tarski.PolyMisc" (required by "Count_Complex_Roots.Count_Complex_Roots" via "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski")
### theory "Sturm_Tarski.PolyMisc"
### 0.025s elapsed time, 0.053s cpu time, 0.000s GC time
*** Failed to load theory "Sturm_Tarski.Sturm_Tarski" (unresolved "Sturm_Tarski.PolyMisc")
*** Failed to load theory "Budan_Fourier.BF_Misc" (unresolved "Sturm_Tarski.Sturm_Tarski")
*** Failed to load theory "Budan_Fourier.Sturm_Multiple_Roots" (unresolved "Budan_Fourier.BF_Misc")
*** Failed to load theory "Winding_Number_Eval.Missing_Algebraic" (unresolved "Budan_Fourier.BF_Misc")
*** Failed to load theory "Winding_Number_Eval.Missing_Transcendental" (unresolved "Winding_Number_Eval.Missing_Algebraic")
*** Failed to load theory "Count_Complex_Roots.More_Polynomials" (unresolved "Budan_Fourier.BF_Misc", "Sturm_Tarski.PolyMisc", "Winding_Number_Eval.Missing_Algebraic", "Winding_Number_Eval.Missing_Transcendental")
*** Failed to load theory "Winding_Number_Eval.Cauchy_Index_Theorem" (unresolved "Sturm_Tarski.Sturm_Tarski", "Winding_Number_Eval.Missing_Algebraic", "Winding_Number_Eval.Missing_Transcendental")
*** Failed to load theory "Count_Complex_Roots.Extended_Sturm" (unresolved "Sturm_Tarski.Sturm_Tarski", "Winding_Number_Eval.Cauchy_Index_Theorem")
*** Failed to load theory "Winding_Number_Eval.Winding_Number_Eval" (unresolved "Winding_Number_Eval.Cauchy_Index_Theorem")
*** Failed to load theory "Count_Complex_Roots.Count_Complex_Roots" (unresolved "Budan_Fourier.Sturm_Multiple_Roots", "Count_Complex_Roots.Extended_Sturm", "Count_Complex_Roots.More_Polynomials", "Winding_Number_Eval.Winding_Number_Eval")
*** Failed to load theory "Count_Complex_Roots.Count_Complex_Roots_Examples" (unresolved "Count_Complex_Roots.Count_Complex_Roots")
*** Type unification failed: Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  gcd :: ??'a \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Sturm_Tarski/PolyMisc.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** Type unification failed: Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  deriv ::
***   (??'a \<Rightarrow> ??'a) \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   \<lambda>x. c * x + b :: 'a \<Rightarrow> 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 133 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "using" (line 195 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** Undefined fact: "contour_integral_integral" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** At command "unfolding" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed: Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (-) (- w) :: ??'a \<Rightarrow> ??'a
*** Operand:   z :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (*) c :: complex \<Rightarrow> complex
*** Operand:   x :: 'b
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Cannot generate coercion from "'b" to "complex"
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 61 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed: Variable 'a::type not of sort real_normed_vector
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  linepath ::
***   ??'a \<Rightarrow> ??'a \<Rightarrow> real \<Rightarrow> ??'a
*** Operand:   st :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::type not of sort real_normed_vector
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "obtain" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")

==========
Diophantine_Eqns_Lin_Hom
Loading theory "Diophantine_Eqns_Lin_Hom.List_Vector"
Loading theory "Diophantine_Eqns_Lin_Hom.Sorted_Wrt"
### theory "Diophantine_Eqns_Lin_Hom.Sorted_Wrt"
### 0.074s elapsed time, 0.424s cpu time, 0.028s GC time
Loading theory "Diophantine_Eqns_Lin_Hom.Minimize_Wrt"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "Diophantine_Eqns_Lin_Hom.Minimize_Wrt"
### 0.185s elapsed time, 1.435s cpu time, 0.081s GC time
Found termination order:
  "(\<lambda>p. length (snd (snd (snd p)))) <*mlex*> {}"
### theory "Diophantine_Eqns_Lin_Hom.List_Vector"
### 0.580s elapsed time, 4.412s cpu time, 0.246s GC time
Loading theory "Diophantine_Eqns_Lin_Hom.Linear_Diophantine_Equations"
locale hlde_ops
  fixes a :: "nat list"
    and b :: "nat list"
locale hlde
  fixes a :: "nat list"
    and b :: "nat list"
  assumes "hlde a b"
locale hlde
  fixes a :: "nat list"
    and b :: "nat list"
  assumes "hlde a b"
### theory "Diophantine_Eqns_Lin_Hom.Linear_Diophantine_Equations"
### 0.489s elapsed time, 3.660s cpu time, 0.547s GC time
Loading theory "Diophantine_Eqns_Lin_Hom.Simple_Algorithm" (required by "Diophantine_Eqns_Lin_Hom.Algorithm")
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### theory "Diophantine_Eqns_Lin_Hom.Simple_Algorithm"
### 0.245s elapsed time, 1.935s cpu time, 0.064s GC time
Loading theory "Diophantine_Eqns_Lin_Hom.Algorithm"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
locale bounded_gen_check
  fixes C :: "nat list \<Rightarrow> nat \<Rightarrow> bool"
    and B :: "nat"
  assumes "bounded_gen_check C B"
Found termination order: "size_list size <*mlex*> {}"
*** Undefined fact: "linorder_antisym_conv2" (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy")
*** At command "by" (line 499 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy")
locale bounded_generate_check
  fixes C\<^sub>2 :: "nat list \<Rightarrow> nat \<Rightarrow> bool"
    and B\<^sub>2 :: "nat"
    and
    C\<^sub>1 ::
      "nat list
       \<Rightarrow> nat list
                     \<Rightarrow> nat list
                                   \<Rightarrow> nat \<Rightarrow> bool"
    and B\<^sub>1 :: "nat list \<Rightarrow> nat"
  assumes "bounded_generate_check C\<^sub>2 B\<^sub>2 C\<^sub>1 B\<^sub>1"
Found termination order: "{}"
Found termination order: "{}"
locale bounded_incs
  fixes cond :: "nat list \<Rightarrow> nat \<Rightarrow> bool"
    and B :: "nat"
  assumes "bounded_incs cond B"
### Metis: Unused theorems: "Set.mem_Collect_eq", "Product_Type.prod.simps_2"
### Metis: Unused theorems: "Set.mem_Collect_eq", "Product_Type.prod.simps_2"
Found termination order:
  "(\<lambda>p. size_list size (snd (snd p))) <*mlex*> {}"
### theory "Diophantine_Eqns_Lin_Hom.Algorithm"
### 1.245s elapsed time, 9.797s cpu time, 0.410s GC time
*** Undefined fact: "linorder_antisym_conv2" (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy")
*** At command "by" (line 499 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy")

==========
DiscretePricing
Loading theory "DiscretePricing.Filtration"
Loading theory "DiscretePricing.Generated_Subalgebra"
### theory "DiscretePricing.Generated_Subalgebra"
### 0.139s elapsed time, 0.779s cpu time, 0.031s GC time
Loading theory "DiscretePricing.Disc_Cond_Expect" (required by "DiscretePricing.Geometric_Random_Walk" via "DiscretePricing.Infinite_Coin_Toss_Space")
### theory "DiscretePricing.Disc_Cond_Expect"
### 0.249s elapsed time, 1.890s cpu time, 0.103s GC time
instantiation
  nat :: linorder_bot
locale filtrated_prob_space
  fixes M :: "'a measure"
    and F :: "'b \<Rightarrow> 'a measure"
  assumes "filtrated_prob_space M F"
locale disc_filtr_prob_space
  fixes M :: "'a measure"
    and F :: "nat \<Rightarrow> 'a measure"
  assumes "disc_filtr_prob_space M F"
locale trivial_init_filtrated_prob_space
  fixes M :: "'a measure"
    and F :: "'b \<Rightarrow> 'a measure"
  assumes "trivial_init_filtrated_prob_space M F"
locale triv_init_disc_filtr_prob_space
  fixes M :: "'a measure"
    and F :: "nat \<Rightarrow> 'a measure"
  assumes "triv_init_disc_filtr_prob_space M F"
### theory "DiscretePricing.Filtration"
### 1.698s elapsed time, 12.604s cpu time, 0.649s GC time
Loading theory "DiscretePricing.Martingale"
Loading theory "DiscretePricing.Infinite_Coin_Toss_Space" (required by "DiscretePricing.Geometric_Random_Walk")
### theory "DiscretePricing.Martingale"
### 0.107s elapsed time, 0.767s cpu time, 0.081s GC time
locale infinite_coin_toss_space
  fixes p :: "real"
    and M :: "bool stream measure"
  assumes "infinite_coin_toss_space p M"
locale infinite_cts_filtration
  fixes p :: "real"
    and M :: "bool stream measure"
    and F :: "nat \<Rightarrow> bool stream measure"
  assumes "infinite_cts_filtration p M F"
*** Failed to finish proof (line 316 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy"):
*** goal (1 subgoal):
***  1. restrict X {n} = (\<lambda>x\<in>{n}. True) \<Longrightarrow> X n
*** At command "by" (line 316 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy")
consts
  smap_stoch_proc ::
    "nat
     \<Rightarrow> (nat \<Rightarrow> 'a \<Rightarrow> 'b)
                   \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'b list"
### theory "DiscretePricing.Infinite_Coin_Toss_Space"
### 3.790s elapsed time, 25.926s cpu time, 3.435s GC time
Loading theory "DiscretePricing.Geometric_Random_Walk"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
locale prob_grw
  fixes p :: "real"
    and M :: "bool stream measure"
    and geom_proc :: "nat \<Rightarrow> bool stream \<Rightarrow> real"
    and u :: "real"
    and d :: "real"
    and init :: "real"
  assumes "prob_grw p M geom_proc u d init"
### theory "DiscretePricing.Geometric_Random_Walk"
### 0.510s elapsed time, 2.416s cpu time, 1.367s GC time
Loading theory "DiscretePricing.Fair_Price"
locale disc_equity_market
  fixes M :: "'a measure"
    and F :: "nat \<Rightarrow> 'a measure"
    and Mkt :: "('a, 'b) discrete_market"
  assumes "disc_equity_market M F"
Found termination order: "{}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
locale disc_market_pos_stock
  fixes M :: "'a measure"
    and F :: "nat \<Rightarrow> 'a measure"
    and Mkt :: "('a, 'b) discrete_market"
    and pos_stock :: "'b"
  assumes "disc_market_pos_stock M F Mkt pos_stock"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
locale rsk_free_asset
  fixes Mkt :: "('a, 'b) discrete_market"
    and r :: "real"
    and risk_free_asset :: "'b"
  assumes "rsk_free_asset Mkt r risk_free_asset"
locale rfr_disc_equity_market
  fixes M :: "'a measure"
    and F :: "nat \<Rightarrow> 'a measure"
    and Mkt :: "('a, 'b) discrete_market"
    and r :: "real"
    and risk_free_asset :: "'b"
  assumes "rfr_disc_equity_market M F Mkt r risk_free_asset"
### theory "DiscretePricing.Fair_Price"
### 3.510s elapsed time, 24.993s cpu time, 1.216s GC time
Loading theory "DiscretePricing.CRR_Model"
locale CRR_hyps
  fixes p :: "real"
    and M :: "bool stream measure"
    and geom_proc :: "nat \<Rightarrow> bool stream \<Rightarrow> real"
    and u :: "real"
    and d :: "real"
    and init :: "real"
    and Mkt :: "(bool stream, 'a) discrete_market"
    and r :: "real"
    and risk_free_asset :: "'a"
    and stk :: "'a"
  assumes "CRR_hyps p M geom_proc u d init Mkt r risk_free_asset stk"
locale CRR_market
  fixes p :: "real"
    and M :: "bool stream measure"
    and geom_proc :: "nat \<Rightarrow> bool stream \<Rightarrow> real"
    and u :: "real"
    and d :: "real"
    and init :: "real"
    and Mkt :: "(bool stream, 'a) discrete_market"
    and r :: "real"
    and risk_free_asset :: "'a"
    and stk :: "'a"
    and G :: "nat \<Rightarrow> bool stream measure"
  assumes "CRR_market p M geom_proc u d init Mkt r risk_free_asset stk G"
locale CRR_market_viable
  fixes p :: "real"
    and M :: "bool stream measure"
    and geom_proc :: "nat \<Rightarrow> bool stream \<Rightarrow> real"
    and u :: "real"
    and d :: "real"
    and init :: "real"
    and Mkt :: "(bool stream, 'a) discrete_market"
    and r :: "real"
    and risk_free_asset :: "'a"
    and stk :: "'a"
    and G :: "nat \<Rightarrow> bool stream measure"
  assumes
    "CRR_market_viable p M geom_proc u d init Mkt r risk_free_asset stk G"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order: "{}"
### theory "DiscretePricing.CRR_Model"
### 4.436s elapsed time, 33.138s cpu time, 4.266s GC time
Loading theory "DiscretePricing.Option_Price_Examples"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. length (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "DiscretePricing.Option_Price_Examples"
### 2.342s elapsed time, 12.869s cpu time, 3.586s GC time
*** Undefined fact: "linordered_field_class.sign_simps" (line 2005 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** At command "by" (line 2005 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 3024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** At command "by" (line 3024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
"13345 / 10609"
  :: "real"
*** Undefined fact: "linordered_field_class.sign_simps" (line 3024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** At command "by" (line 3024 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 2005 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** At command "by" (line 2005 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy")
*** Failed to finish proof (line 316 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy"):
*** goal (1 subgoal):
***  1. restrict X {n} = (\<lambda>x\<in>{n}. True) \<Longrightarrow> X n
*** At command "by" (line 316 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy")

==========
Ergodic_Theory
Loading theory "Ergodic_Theory.Fekete"
Loading theory "Ergodic_Theory.SG_Library_Complement"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Ergodic_Theory.Fekete"
### 0.236s elapsed time, 1.617s cpu time, 0.070s GC time
Loading theory "Ergodic_Theory.Kohlberg_Neyman_Karlsson"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale Kohlberg_Neyman_Karlsson
  fixes T :: "'a \<Rightarrow> 'a"
  assumes "Kohlberg_Neyman_Karlsson T"
### theory "Ergodic_Theory.Kohlberg_Neyman_Karlsson"
### 0.115s elapsed time, 0.860s cpu time, 0.071s GC time
locale finite_borel_measure'
  fixes M :: "'a measure"
  assumes "finite_borel_measure' M"
### theory "Ergodic_Theory.SG_Library_Complement"
### 0.408s elapsed time, 2.896s cpu time, 0.189s GC time
Loading theory "Ergodic_Theory.Asymptotic_Density"
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
Loading theory "Ergodic_Theory.Measure_Preserving_Transformations"
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** Undefined fact: "linordered_field_class.sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
locale mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "mpt M T"
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_derivative (\<lambda>x. x)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (id has_derivative id) (at ?a1) \<equiv> True
locale fmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "fmpt M T"
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_derivative (\<lambda>x. 0::?'b1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. of_real (?g1 x)) has_derivative
###  (\<lambda>x. of_real (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x + ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x + ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) ?F1) \<Longrightarrow>
### ((\<lambda>x. \<Sum>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>x. \<Sum>i\<in>?I1. ?f'1 i x))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. - ?f1 x) has_derivative (\<lambda>x. - ?f'1 x)) ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x - ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x - ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x * ?g1 x) has_derivative
###                    (\<lambda>h. ?f1 ?x1 * ?g'1 h + ?f'1 h * ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x *\<^sub>R ?g1 x) has_derivative
###                    (\<lambda>h.
###                        ?f1 ?x1 *\<^sub>R ?g'1 h + ?f'1 h *\<^sub>R ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) (at ?x1 within ?S1)) \<Longrightarrow>
### ((\<lambda>x. \<Prod>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>y.
###      \<Sum>i\<in>?I1. ?f'1 i y * (\<Prod>j\<in>?I1 - {i}. ?f1 j ?x1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) (at ?x1 within ?S1) \<Longrightarrow>
### ((\<lambda>x. ?f1 x ^ ?n1) has_derivative
###  (\<lambda>y. of_nat ?n1 * ?f'1 y * ?f1 ?x1 ^ (?n1 - 1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 ?x1 \<noteq> (0::?'a1);
###  (?f1 has_derivative ?f'1) (at ?x1 within ?S1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. inverse (?f1 x)) has_derivative
###                    (\<lambda>h.
###                        - (inverse (?f1 ?x1) * ?f'1 h * inverse (?f1 ?x1))))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?S1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?S1);
###  ?g1 ?x1 \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x / ?g1 x) has_derivative
###                    (\<lambda>h.
###                        - ?f1 ?x1 *
###                        (inverse (?g1 ?x1) * ?g'1 h * inverse (?g1 ?x1)) +
###                        ?f'1 h / ?g1 ?x1))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>finite ?s1; \<forall>a\<in>?s1. ?f1 a differentiable ?net1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. \<Sum>a\<in>?s1. ?f1 a x) differentiable
###                   ?net1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable ?F1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?f1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1; ?g1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x / ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable at ?x1 within ?s1 \<Longrightarrow>
### (\<lambda>x. ?f1 x ^ ?n1) differentiable at ?x1 within ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_vector_derivative (0::?'a1)) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_vector_derivative 1) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?k1) has_field_derivative (0::?'a1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_field_derivative (1::?'a1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. cnj (?g1 x)) has_derivative (\<lambda>x. cnj (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. (?f1 x, ?g1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### id differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z * ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>z. - ?f1 z) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z + ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z - ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1;
###  \<And>x. x \<in> ?S1 \<Longrightarrow> ?f1 x \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. (norm x)\<^sup>2) has_derivative
###  (\<lambda>x. 2 *\<^sub>R (?a1 \<bullet> x)))
###  (at ?a1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<noteq> (0::?'a1) \<Longrightarrow>
### norm differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<notin> ?S1 \<Longrightarrow>
### norm differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (*) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. z) field_differentiable ?F1 \<equiv> True
### theory "Ergodic_Theory.Asymptotic_Density"
### 0.279s elapsed time, 2.108s cpu time, 0.131s GC time
### Ignoring duplicate rewrite rule:
### id field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (+) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 C1_differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
locale pmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "pmpt M T"
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "mpt M T"
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
*** Undefined fact: "linordered_field_class.sign_simps" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
locale polish_pmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "polish_pmpt M T"
### theory "Ergodic_Theory.Measure_Preserving_Transformations"
### 0.991s elapsed time, 7.668s cpu time, 0.414s GC time
Loading theory "Ergodic_Theory.Recurrence"
locale conservative
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "conservative M T"
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
locale conservative_mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "conservative_mpt M T"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    ereal (u n / real n - A + eps i) * ereal (real n) =
***    ereal (u n - (A - eps i) * real n)
*** At command "using" (line 158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kohlberg_Neyman_Karlsson.thy")
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
### Rewrite rule not in simpset:
### ereal (upper_asymptotic_density ?A1) \<equiv>
### limsup (\<lambda>x. ereal (real (card (?A1 \<inter> {..<x})) / real x))
### Rewrite rule not in simpset:
### upper_asymptotic_density ?A1 \<le> 1 \<equiv> True
### Rewrite rule not in simpset:
### 0 \<le> upper_asymptotic_density ?A1 \<equiv> True
locale conservative_mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "conservative_mpt M T"
### theory "Ergodic_Theory.Recurrence"
### 0.861s elapsed time, 6.404s cpu time, 1.015s GC time
Loading theory "Ergodic_Theory.Invariants"
Loading theory "Ergodic_Theory.Transfer_Operator"
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
locale qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "qmpt M T"
locale fmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "fmpt M T"
### theory "Ergodic_Theory.Transfer_Operator"
### 0.540s elapsed time, 3.899s cpu time, 0.904s GC time
Loading theory "Ergodic_Theory.Normalizing_Sequences"
locale fmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "fmpt M T"
### Metis: Unused theorems: "Asymptotic_Density.lower_asymptotic_density_infinite_interval_2", "Asymptotic_Density.lower_asymptotic_density_infinite_interval_3"
### Metis: Unused theorems: "Asymptotic_Density.lower_asymptotic_density_infinite_interval_1", "Asymptotic_Density.lower_asymptotic_density_infinite_interval_3"
### Metis: Unused theorems: "Asymptotic_Density.lower_asymptotic_density_infinite_interval_1", "Asymptotic_Density.lower_asymptotic_density_infinite_interval_2"
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
linarith_split_limit exceeded (current value is 9)
### theory "Ergodic_Theory.Invariants"
### 0.725s elapsed time, 5.389s cpu time, 0.910s GC time
Loading theory "Ergodic_Theory.Ergodicity"
locale ergodic_qmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_qmpt M T"
linarith_split_limit exceeded (current value is 9)
locale ergodic_mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_mpt M T"
locale ergodic_fmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_fmpt M T"
locale ergodic_pmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_pmpt M T"
locale ergodic_conservative
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_conservative M T"
locale ergodic_conservative_mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_conservative_mpt M T"
locale conservative_limit
  fixes T :: "'a \<Rightarrow> 'a"
    and M :: "'a measure"
    and P :: "'a measure"
    and Z :: "real measure"
    and f :: "'a \<Rightarrow> real"
    and g :: "'a \<Rightarrow> real"
    and B :: "nat \<Rightarrow> real"
  assumes "conservative_limit T M P Z f g B"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale pmpt_limit
  fixes T :: "'a \<Rightarrow> 'a"
    and M :: "'a measure"
    and Z :: "real measure"
    and f :: "'a \<Rightarrow> real"
    and B :: "nat \<Rightarrow> real"
  assumes "pmpt_limit T M Z f B"
### theory "Ergodic_Theory.Normalizing_Sequences"
### 0.708s elapsed time, 5.512s cpu time, 0.316s GC time
### Metis: Unused theorems: "local.Tn_meas", "Sigma_Algebra.measurable_comp", "Lattices.semilattice_inf_class.inf_commute"
### Metis: Unused theorems: "local.T_meas", "Sigma_Algebra.measurable_comp", "Lattices.semilattice_inf_class.inf_commute"
### Metis: Unused theorems: "local.Tn_meas", "Sigma_Algebra.measurable_comp"
### Metis: Unused theorems: "local.T_meas", "Sigma_Algebra.measurable_comp"
### Metis: Unused theorems: "Lattices.semilattice_inf_class.inf_commute"
### theory "Ergodic_Theory.Ergodicity"
### 0.925s elapsed time, 7.322s cpu time, 0.383s GC time
Loading theory "Ergodic_Theory.Kingman"
*** Undefined fact: "borel_measurable_continuous_on1" (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** At command "by" (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** At command "by" (line 1158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
locale mpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "mpt M T"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
locale fmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "fmpt M T"
locale ergodic_pmpt
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
  assumes "ergodic_pmpt M T"
### theory "Ergodic_Theory.Kingman"
### 1.286s elapsed time, 8.889s cpu time, 1.316s GC time
Loading theory "Ergodic_Theory.Gouezel_Karlsson"
locale Gouezel_Karlsson_Kingman
  fixes M :: "'a measure"
    and T :: "'a \<Rightarrow> 'a"
    and u :: "nat \<Rightarrow> 'a \<Rightarrow> real"
  assumes "Gouezel_Karlsson_Kingman M T u"
### theory "Ergodic_Theory.Gouezel_Karlsson"
### 0.615s elapsed time, 4.802s cpu time, 0.172s GC time
### Ignoring duplicate rewrite rule:
### ?y \<in> sets ?M1 \<Longrightarrow>
### space (restrict_space ?M1 ?y) \<equiv> ?y
*** Failed to apply initial proof method (line 959 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      ereal (birkhoff_sum f n x / real n) * ereal (real n) =
***      ereal (birkhoff_sum f n x)
***   (\<lambda>n. ereal (birkhoff_sum f n x / real n) * ereal (real n))
***   \<longlonglongrightarrow> ereal (real_cond_exp M Invariants f x) *
***                             \<infinity>
*** goal (1 subgoal):
***  1. (\<lambda>n. ereal (birkhoff_sum f n x))
***     \<longlonglongrightarrow> ereal (real_cond_exp M Invariants f x) *
***                               \<infinity>
*** At command "by" (line 959 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 785 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** At command "by" (line 785 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
### Ignoring duplicate rewrite rule:
### ?y \<in> sets ?M1 \<Longrightarrow>
### space (restrict_space ?M1 ?y) \<equiv> ?y
*** Undefined fact: "Lim_eventually" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** At command "proof" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "tendsto_explicit" (line 485 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "by" (line 485 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** Undefined fact: "tendsto_explicit" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "by" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
### Ignoring duplicate rewrite rule:
### e2ennreal (ereal ?x1) \<equiv> ennreal ?x1
### Ignoring duplicate rewrite rule:
### e2ennreal (ereal ?x1) \<equiv> ennreal ?x1
### Ignoring duplicate rewrite rule:
### e2ennreal (ereal ?x1) \<equiv> ennreal ?x1
### Ignoring duplicate rewrite rule:
### e2ennreal (ereal ?x1) \<equiv> ennreal ?x1
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** (\<lambda>x. ereal (LINT xa|M. w x xa / real x))
*** \<longlonglongrightarrow> subcocycle_avg_ereal w
*** At command "apply" (line 1687 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** Undefined fact: "tendsto_explicit" (line 1813 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "using" (line 1813 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "Lim_eventually" (line 294 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 294 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 376 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 376 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "linordered_field_class.sign_simps" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 376 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 376 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "Lim_eventually" (line 294 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** At command "by" (line 294 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy")
*** Undefined fact: "tendsto_explicit" (line 1813 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "using" (line 1813 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** (\<lambda>x. ereal (LINT xa|M. w x xa / real x))
*** \<longlonglongrightarrow> subcocycle_avg_ereal w
*** At command "apply" (line 1687 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** Undefined fact: "tendsto_explicit" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "by" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** Undefined fact: "tendsto_explicit" (line 485 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** At command "by" (line 485 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy")
*** Undefined fact: "Lim_eventually" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** At command "proof" (line 674 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 785 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** At command "by" (line 785 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** Failed to apply initial proof method (line 959 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      ereal (birkhoff_sum f n x / real n) * ereal (real n) =
***      ereal (birkhoff_sum f n x)
***   (\<lambda>n. ereal (birkhoff_sum f n x / real n) * ereal (real n))
***   \<longlonglongrightarrow> ereal (real_cond_exp M Invariants f x) *
***                             \<infinity>
*** goal (1 subgoal):
***  1. (\<lambda>n. ereal (birkhoff_sum f n x))
***     \<longlonglongrightarrow> ereal (real_cond_exp M Invariants f x) *
***                               \<infinity>
*** At command "by" (line 959 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** At command "by" (line 1158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** At command "by" (line 1140 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    ereal (u n / real n - A + eps i) * ereal (real n) =
***    ereal (u n - (A - eps i) * real n)
*** At command "using" (line 158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Kohlberg_Neyman_Karlsson.thy")
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Error_Function
Loading theory "HOL-Library.Function_Algebras" (required by "Error_Function.Error_Function_Asymptotics" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
Loading theory "HOL-Library.Landau_Symbols" (required by "Error_Function.Error_Function")
Loading theory "Landau_Symbols.Group_Sort" (required by "Error_Function.Error_Function_Asymptotics" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
locale groupsort
  fixes f :: "'a \<Rightarrow> 'b"
    and merge :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and g :: "'a list \<Rightarrow> 'c"
  assumes "groupsort f merge g"
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
### theory "HOL-Library.Function_Algebras"
### 0.149s elapsed time, 0.713s cpu time, 0.075s GC time
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### mset (filter ?P1 ?xs1) \<equiv> filter_mset ?P1 (mset ?xs1)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
Found termination order: "length <*mlex*> {}"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
### theory "Landau_Symbols.Group_Sort"
### 0.950s elapsed time, 5.201s cpu time, 0.379s GC time
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
bundle asymp_equiv_notation
### theory "HOL-Library.Landau_Symbols"
### 1.603s elapsed time, 8.566s cpu time, 0.556s GC time
Loading theory "Error_Function.Error_Function"
Loading theory "Landau_Symbols.Landau_Real_Products" (required by "Error_Function.Error_Function_Asymptotics" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs")
### theory "Error_Function.Error_Function"
### 0.273s elapsed time, 0.939s cpu time, 0.104s GC time
consts
  bigtheta_pow ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> 'b) set
                   \<Rightarrow> nat
                                 \<Rightarrow> ('a \<Rightarrow> 'b) set"
locale landau_function_family
  fixes F :: "'a filter"
    and H :: "('a \<Rightarrow> real) set"
  assumes "landau_function_family F H"
locale landau_function_family_pair
  fixes F :: "'a filter"
    and G :: "('a \<Rightarrow> real) set"
    and H :: "('a \<Rightarrow> real) set"
    and g :: "'a \<Rightarrow> real"
  assumes "landau_function_family_pair F G H g"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
consts
  landau_dominating_chain' ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> real) list \<Rightarrow> bool"
consts
  nonneg_list :: "'a list \<Rightarrow> bool"
consts
  pos_list :: "'a list \<Rightarrow> bool"
locale landau_function_family_chain
  fixes F :: "'b filter"
    and gs :: "'a list"
    and get_param :: "'a \<Rightarrow> real"
    and get_fun :: "'a \<Rightarrow> 'b \<Rightarrow> real"
  assumes "landau_function_family_chain F gs get_fun"
instantiation
  primfun :: linorder
  less_eq_primfun == less_eq ::
    primfun \<Rightarrow> primfun \<Rightarrow> bool
  less_primfun == less :: primfun \<Rightarrow> primfun \<Rightarrow> bool
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### pos_primfun_list [] \<equiv> False
### Ignoring duplicate rewrite rule:
### pos_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> pos_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> nonneg_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### iszero_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### iszero_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### ?x1 = (0::?'b1) \<and> iszero_primfun_list ?xs1
### theory "Landau_Symbols.Landau_Real_Products"
### 2.024s elapsed time, 6.208s cpu time, 1.053s GC time
Loading theory "Landau_Symbols.Landau_Simprocs" (required by "Error_Function.Error_Function_Asymptotics" via "Landau_Symbols.Landau_More")
### ML warning (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (dest_bigtheta) has not been referenced.
### ML warning (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (x_name2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest1) has not been referenced.
### ML warning (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 373 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
signature LANDAU =
  sig
    val cancel_factor_conv: Proof.context -> cterm -> thm
    val cancel_factor_simproc: Proof.context -> cterm -> thm option
    val dest_landau: term -> term * term * term
    val landau_const_names: string list
    val landau_sum_limit: int Config.T
    val lift_landau_conv: conv -> conv
    val lift_landau_simproc:
       (Proof.context -> cterm -> thm option) ->
         Proof.context -> cterm -> thm option
    val simplify_landau_product_conv: Proof.context -> conv
    val simplify_landau_product_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_real_prod_prop_conv: Proof.context -> conv
    val simplify_landau_real_prod_prop_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_sum_conv: Proof.context -> conv
    val simplify_landau_sum_simproc: Proof.context -> cterm -> thm option
  end
structure Landau: LANDAU
### theory "Landau_Symbols.Landau_Simprocs"
### 0.437s elapsed time, 1.636s cpu time, 0.914s GC time
Loading theory "Landau_Symbols.Landau_More" (required by "Error_Function.Error_Function_Asymptotics")
val it =
   "(\<lambda>x.
        5 * (ln (ln x))\<^sup>2 / (2 * x) powr (15 / 10) * inverse 2)
    \<in> \<omega>(\<lambda>x.
                      3 * ln x * ln x / x * ln (ln (ln (ln x)))) \<equiv>
    3 = 0 \<or>
    5 * inverse (2 powr (15 / 10)) * inverse 2 \<noteq> 0 \<and>
    pos_primfun_list
     (group_primfuns
       [(LnChain 1, - 1), (LnChain 1, - 1), (LnChain 0, 1),
        (LnChain 4, - 1), (LnChain 2, real 2), (LnChain 0, - (15 / 10))])":
   thm
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### theory "Landau_Symbols.Landau_More"
### 0.171s elapsed time, 0.961s cpu time, 0.030s GC time
*** Failed to load theory "Error_Function.Error_Function_Asymptotics" (unresolved "Error_Function.Error_Function")
*** Type unification failed: No type arity fun :: banach
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:  exp (- contour_integrable_on\<^sup>2) :: ??'a
*** Operand:   linepath ::
***   ??'b \<Rightarrow> ??'b \<Rightarrow> real \<Rightarrow> ??'b
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operator failed:
*** No complex coercion from "??'a44" to fun
*** At command "lemma" (line 130 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Error_Function/Error_Function.thy")

==========
E_Transcendental
Loading theory "HOL-Number_Theory.Cong" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
Loading theory "HOL-Algebra.Congruence" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
Loading theory "HOL-Library.More_List" (required by "E_Transcendental.E_Transcendental" via "HOL-Computational_Algebra.Polynomial")
Loading theory "HOL-Library.Power_By_Squaring" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Mod_Exp")
Loading theory "HOL-Number_Theory.Eratosthenes" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
Loading theory "HOL-Number_Theory.Fib" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
Loading theory "HOL-Number_Theory.Prime_Powers" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
class monoid_mult = semigroup_mult + power +
  assumes "mult_1_left": "\<And>a. (1::'a) * a = a"
    and "mult_1_right": "\<And>a. a * (1::'a) = a"
### theory "HOL-Library.Power_By_Squaring"
### 0.181s elapsed time, 1.353s cpu time, 0.106s GC time
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "HOL-Number_Theory.Fib"
### 0.212s elapsed time, 1.657s cpu time, 0.145s GC time
### theory "HOL-Library.More_List"
### 0.216s elapsed time, 1.689s cpu time, 0.145s GC time
Loading theory "HOL-Computational_Algebra.Polynomial" (required by "E_Transcendental.E_Transcendental")
### theory "HOL-Number_Theory.Eratosthenes"
### 0.244s elapsed time, 1.906s cpu time, 0.145s GC time
class unique_euclidean_semiring = euclidean_semiring_cancel +
  fixes division_segment :: "'a \<Rightarrow> 'a"
  assumes
    "euclidean_size_mult":
      "\<And>a b.
          euclidean_size (a * b) = euclidean_size a * euclidean_size b"
  assumes
    "is_unit_division_segment": "\<And>a. is_unit (division_segment a)"
    and
    "division_segment_mult":
      "\<And>a b.
          \<lbrakk>a \<noteq> (0::'a); b \<noteq> (0::'a)\<rbrakk>
          \<Longrightarrow> division_segment (a * b) =
                            division_segment a * division_segment b"
    and
    "division_segment_mod":
      "\<And>b a.
          \<lbrakk>b \<noteq> (0::'a); \<not> b dvd a\<rbrakk>
          \<Longrightarrow> division_segment (a mod b) = division_segment b"
  assumes
    "div_bounded":
      "\<And>b r q.
          \<lbrakk>b \<noteq> (0::'a);
           division_segment r = division_segment b;
           euclidean_size r < euclidean_size b\<rbrakk>
          \<Longrightarrow> (q * b + r) div b = q"
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
### theory "HOL-Number_Theory.Prime_Powers"
### 0.710s elapsed time, 5.460s cpu time, 0.385s GC time
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "HOL-Algebra.Congruence"
### 0.853s elapsed time, 6.538s cpu time, 0.460s GC time
Loading theory "HOL-Algebra.Order" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
### theory "HOL-Number_Theory.Cong"
### 1.085s elapsed time, 8.315s cpu time, 0.574s GC time
Loading theory "HOL-Number_Theory.Mod_Exp" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
Loading theory "HOL-Number_Theory.Totient" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
instantiation
  poly :: (zero) zero
  zero_poly == zero_class.zero :: 'a poly
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
consts
  Poly :: "'a list \<Rightarrow> 'a poly"
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
### theory "HOL-Algebra.Order"
### 0.599s elapsed time, 4.617s cpu time, 0.336s GC time
Loading theory "HOL-Algebra.Lattice" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
class euclidean_semiring_cancel = euclidean_semiring +
  assumes
    "div_mult_self1":
      "\<And>b a c.
          b \<noteq> (0::'a) \<Longrightarrow>
          (a + c * b) div b = c + a div b"
    and
    "div_mult_mult1":
      "\<And>c a b.
          c \<noteq> (0::'a) \<Longrightarrow> c * a div (c * b) = a div b"
instantiation
  poly :: ({zero,equal}) equal
  equal_poly == equal_class.equal ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
consts
  totient_naive ::
    "nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat"
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
### theory "HOL-Number_Theory.Mod_Exp"
### 0.688s elapsed time, 5.088s cpu time, 1.024s GC time
instantiation
  poly :: (comm_monoid_add) comm_monoid_add
  plus_poly == plus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly == minus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
### theory "HOL-Number_Theory.Totient"
### 0.693s elapsed time, 5.130s cpu time, 1.024s GC time
instantiation
  poly :: (ab_group_add) ab_group_add
  uminus_poly == uminus :: 'a poly \<Rightarrow> 'a poly
### Ignoring duplicate rewrite rule:
### \<Prod>x\<in>?A1. ?y1 \<equiv> ?y1 ^ card ?A1
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
instantiation
  poly :: (comm_semiring_0) comm_semiring_0
  times_poly == times :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
instantiation
  poly :: (comm_semiring_1) comm_semiring_1
  one_poly == one_class.one :: 'a poly
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
### theory "HOL-Algebra.Lattice"
### 0.849s elapsed time, 6.339s cpu time, 1.063s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group")
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
instantiation
  poly :: (linordered_idom) linordered_idom
  sgn_poly == sgn :: 'a poly \<Rightarrow> 'a poly
  abs_poly == abs :: 'a poly \<Rightarrow> 'a poly
  less_eq_poly == less_eq ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
  less_poly == less :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
instantiation
  poly :: (idom_divide) idom_divide
  divide_poly == divide ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
### theory "HOL-Algebra.Complete_Lattice"
### 0.916s elapsed time, 7.005s cpu time, 1.289s GC time
Loading theory "HOL-Algebra.Group" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
instantiation
  poly :: ({idom_divide,semidom_divide_unit_factor}) normalization_semidom
  normalize_poly == normalize :: 'a poly \<Rightarrow> 'a poly
  unit_factor_poly == unit_factor :: 'a poly \<Rightarrow> 'a poly
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
overloading
  nat_pow \<equiv> pow ::
    ('a, 'b) monoid_scheme
    \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
overloading
  int_pow \<equiv> pow ::
    ('a, 'b) monoid_scheme
    \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'a
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Rewrite rule not in simpset:
### \<bar>1::?'a1\<bar> \<equiv> 1::?'a1
### Rewrite rule not in simpset:
### \<bar>1::?'a1\<bar> \<equiv> 1::?'a1
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "group_hom G H h"
class field_unit_factor = field + unit_factor +
  assumes "unit_factor_field": "unit_factor = id"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
Proofs for inductive predicate(s) "eucl_rel_poly"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
instantiation
  poly :: (field) semidom_modulo
  modulo_poly == modulo ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
### theory "HOL-Algebra.Group"
### 1.775s elapsed time, 13.667s cpu time, 0.677s GC time
Loading theory "HOL-Algebra.Coset" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
Loading theory "HOL-Algebra.FiniteProduct" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.Module" via "HOL-Algebra.Ring")
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale normal
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "normal H G"
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and
    f :: "'b \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
locale ACeD
  fixes D :: "'a set"
    and
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
### theory "HOL-Algebra.FiniteProduct"
### 0.363s elapsed time, 2.863s cpu time, 0.193s GC time
Loading theory "HOL-Algebra.Ring" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.Module")
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
### Ambiguous input (line 611 of "~~/src/HOL/Algebra/Coset.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###       ("_position" H))
###     ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" carrier) ("_position" G)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" y)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>Set.member"
###             ("\<^const>Group.monoid.mult_indexed"
###               ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                 ("_position" x))
###               ("_index" ("_position" G)) ("_position" y))
###             ("_position" H)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###     ("\<^const>HOL.eq" ("_position" H)
###       ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" x)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" y)
###               ("_applC" ("_position" carrier) ("_position" G)))
###             ("\<^const>Set.member"
###               ("\<^const>Group.monoid.mult_indexed"
###                 ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                   ("_position" x))
###                 ("_index" ("_position" G)) ("_position" y))
###               ("_position" H))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### theory "HOL-Computational_Algebra.Polynomial"
### 6.501s elapsed time, 49.967s cpu time, 6.455s GC time
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
### theory "HOL-Algebra.Coset"
### 1.758s elapsed time, 13.760s cpu time, 2.779s GC time
Loading theory "HOL-Algebra.Generated_Groups" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
Proofs for inductive predicate(s) "generatep"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### ML warning (line 45 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
### theory "HOL-Algebra.Generated_Groups"
### 1.162s elapsed time, 7.528s cpu time, 2.614s GC time
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "ring_hom_cring R S h"
### Ignoring duplicate rewrite rule:
### Group.monoid G \<equiv> True
### Rule already declared as safe introduction (intro!)
### Group.group G
### Rule already declared as safe introduction (intro!)
### Group.group H
### theory "HOL-Algebra.Ring"
### 3.559s elapsed time, 25.916s cpu time, 5.685s GC time
Loading theory "HOL-Algebra.AbelCoset" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom" via "HOL-Algebra.Ideal")
Loading theory "HOL-Algebra.Module" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
locale abelian_group_hom
  fixes G :: "('a, 'b) ring_scheme"  (structure)
    and H :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "abelian_group_hom G H h"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale additive_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "additive_subgroup H G"
locale abelian_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_subgroup H G"
### Metis: Unused theorems: "local.assms_3"
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 \<in> ?A1 \<rightarrow> carrier G;
###  ?g1 \<in> ?A1 \<rightarrow> carrier G\<rbrakk>
### \<Longrightarrow> \<Otimes>x\<in>?A1. ?f1 x \<otimes> ?g1 x \<equiv>
###                   finprod G ?f1 ?A1 \<otimes> finprod G ?g1 ?A1
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Algebra.Module"
### 1.621s elapsed time, 11.747s cpu time, 0.779s GC time
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
### Rule already declared as introduction (intro)
### \<lbrakk>?P ?x; ?x \<in> ?A\<rbrakk>
### \<Longrightarrow> \<exists>x\<in>?A. ?P x
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "HOL-Algebra.AbelCoset"
### 2.909s elapsed time, 22.018s cpu time, 1.301s GC time
Loading theory "HOL-Algebra.Ideal" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom")
locale ideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ideal I R"
carrier \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> = ?carrier
partial_object.more \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
?more
carrier_update ?carrier'
 \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier' ?carrier, \<dots> = ?more\<rparr>
partial_object.more_update ?more'
 \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, \<dots> = ?more' ?more\<rparr>
(\<otimes>\<^bsub>\<lparr>carrier = ?carrier, mult = ?mult, one = ?one, \<dots> = ?more\<rparr>\<^esub>) =
?mult
\<one>\<^bsub>\<lparr>carrier = ?carrier, mult = ?mult, one = ?one, \<dots> = ?more\<rparr>\<^esub> =
?one
monoid.more
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
?more
mult_update ?mult'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult' ?mult, one = ?one,
   \<dots> = ?more\<rparr>
one_update ?one'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult, one = ?one' ?one,
   \<dots> = ?more\<rparr>
monoid.more_update ?more'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
   \<dots> = ?more' ?more\<rparr>
locale principalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "principalideal I R"
locale maximalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "maximalideal I R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
locale primeideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "primeideal I R"
### Ignoring duplicate rewrite rule:
### h \<in> hom G H \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<oplus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<zero> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<ominus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<otimes> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<one> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<zero> \<oplus> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<one> \<otimes> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> ?y \<oplus> \<zero> \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<ominus> (\<ominus> ?y) \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<ominus> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> \<zero> \<otimes> ?x1 \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> ?x1 \<otimes> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<oplus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<zero> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<ominus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<otimes> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<one> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<zero> \<oplus> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<one> \<otimes> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> ?y \<oplus> \<zero> \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<ominus> (\<ominus> ?y) \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<ominus> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> \<zero> \<otimes> ?x1 \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> ?x1 \<otimes> \<zero> \<equiv> \<zero>
\<lbrakk>?M \<subseteq> carrier G; ?g \<in> carrier G;
 ?h \<in> carrier G\<rbrakk>
\<Longrightarrow> ?M #>\<^bsub>add_monoid G\<^esub>
                  ?g #>\<^bsub>add_monoid G\<^esub>
                  ?h =
                  ?M #>\<^bsub>add_monoid G\<^esub> ?g \<oplus> ?h
\<lbrakk>abelian_group ?G; ?M \<subseteq> carrier ?G; ?g \<in> carrier ?G;
 ?h \<in> carrier ?G\<rbrakk>
\<Longrightarrow> ?M +>\<^bsub>?G\<^esub> ?g +>\<^bsub>?G\<^esub> ?h =
                  ?M +>\<^bsub>?G\<^esub> ?g \<oplus>\<^bsub>?G\<^esub> ?h
### theory "HOL-Algebra.Ideal"
### 1.956s elapsed time, 13.882s cpu time, 0.814s GC time
Loading theory "HOL-Algebra.RingHom" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
locale ring_hom_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "ring_hom_ring R S h"
### theory "HOL-Algebra.RingHom"
### 0.439s elapsed time, 1.425s cpu time, 0.000s GC time
Loading theory "HOL-Algebra.UnivPoly" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale bound
  fixes z :: "'a"
    and n :: "nat"
    and f :: "nat \<Rightarrow> 'a"
  assumes "bound z n f"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 = \<zero> \<equiv> ?x1 = \<zero>
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
locale UP_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
    and s :: "'c"
    and Eval :: "(nat \<Rightarrow> 'a) \<Rightarrow> 'c"
  assumes "UP_univ_prop R S h s"
  defines "P \<equiv> UP R"
    and "Eval \<equiv> eval R S h s"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
### theory "HOL-Algebra.UnivPoly"
### 5.844s elapsed time, 19.838s cpu time, 5.528s GC time
Loading theory "HOL-Algebra.Multiplicative_Group" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier G \<Longrightarrow> ?x1 [^] ord ?x1 \<equiv> \<one>
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
### Ignoring duplicate rewrite rule:
### (\<otimes>\<^bsub>mult_of ?R1\<^esub>) \<equiv>
### (\<otimes>\<^bsub>?R1\<^esub>)
### Ignoring duplicate rewrite rule:
### \<one>\<^bsub>mult_of ?R1\<^esub> \<equiv> \<one>\<^bsub>?R1\<^esub>
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
### Ignoring duplicate rewrite rule:
### (\<otimes>\<^bsub>mult_of ?R1\<^esub>) \<equiv>
### (\<otimes>\<^bsub>?R1\<^esub>)
### Ignoring duplicate rewrite rule:
### \<one>\<^bsub>mult_of ?R1\<^esub> \<equiv> \<one>\<^bsub>?R1\<^esub>
### theory "HOL-Algebra.Multiplicative_Group"
### 2.647s elapsed time, 13.793s cpu time, 5.674s GC time
Loading theory "HOL-Number_Theory.Residues" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R \<equiv> residue_ring m"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R \<equiv> residue_ring m"
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R \<equiv> residue_ring (int p)"
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R \<equiv> residue_ring (int p)"
### theory "HOL-Number_Theory.Residues"
### 1.109s elapsed time, 5.975s cpu time, 0.256s GC time
Loading theory "HOL-Number_Theory.Euler_Criterion" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Quadratic_Reciprocity" via "HOL-Number_Theory.Gauss")
### theory "HOL-Number_Theory.Euler_Criterion"
### 0.114s elapsed time, 0.450s cpu time, 0.000s GC time
Loading theory "HOL-Number_Theory.Gauss" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Quadratic_Reciprocity")
Loading theory "HOL-Number_Theory.Pocklington" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
locale GAUSS
  fixes p :: "nat"
    and a :: "int"
  assumes "GAUSS p a"
### theory "HOL-Number_Theory.Gauss"
### 0.196s elapsed time, 1.560s cpu time, 0.261s GC time
Loading theory "HOL-Number_Theory.Quadratic_Reciprocity" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
locale QR
  fixes p :: "nat"
    and q :: "nat"
  assumes "QR p q"
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
### theory "HOL-Number_Theory.Pocklington"
### 0.306s elapsed time, 2.476s cpu time, 0.261s GC time
Loading theory "HOL-Number_Theory.Residue_Primitive_Roots" (required by "E_Transcendental.E_Transcendental" via "HOL-Number_Theory.Number_Theory")
Proofs for inductive predicate(s) "residue_primroot"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Number_Theory.Quadratic_Reciprocity"
### 0.269s elapsed time, 2.139s cpu time, 0.000s GC time
### theory "HOL-Number_Theory.Residue_Primitive_Roots"
### 0.189s elapsed time, 1.393s cpu time, 0.000s GC time
Loading theory "HOL-Number_Theory.Number_Theory" (required by "E_Transcendental.E_Transcendental")
### Ignoring duplicate rewrite rule:
### \<Prod>x\<in>?A1. ?y1 \<equiv> ?y1 ^ card ?A1
### theory "HOL-Number_Theory.Number_Theory"
### 1.491s elapsed time, 11.403s cpu time, 0.575s GC time
Loading theory "E_Transcendental.E_Transcendental"
### theory "E_Transcendental.E_Transcendental"
### 1.403s elapsed time, 11.169s cpu time, 0.510s GC time
*** Type unification failed: Clash of types "_ \<Rightarrow> _" and "complex"
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:  exp (u - has_contour_integral) * poly f has_contour_integral ::
***   complex
*** Operand:   I :: ??'a poly \<Rightarrow> ??'a \<Rightarrow> ??'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operator failed:
*** No complex coercion from "complex" to "fun"
*** At command "lemma" (line 288 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/E_Transcendental/E_Transcendental.thy")

==========
Euler_MacLaurin
Loading theory "HOL-Library.Stirling" (required by "Euler_MacLaurin.Euler_MacLaurin" via "Bernoulli.Bernoulli_FPS")
Loading theory "HOL-Library.Function_Algebras" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
Loading theory "Bernoulli.Bernoulli" (required by "Euler_MacLaurin.Euler_MacLaurin" via "Bernoulli.Periodic_Bernpoly")
Loading theory "HOL-Library.Landau_Symbols" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau" via "Landau_Symbols.Landau_More")
Loading theory "Landau_Symbols.Group_Sort" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
locale groupsort
  fixes f :: "'a \<Rightarrow> 'b"
    and merge :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and g :: "'a list \<Rightarrow> 'c"
  assumes "groupsort f merge g"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.117s elapsed time, 0.826s cpu time, 0.089s GC time
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
consts
  stirling_row_aux ::
    "'a \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### theory "Bernoulli.Bernoulli"
### 0.285s elapsed time, 2.112s cpu time, 0.213s GC time
Loading theory "Bernoulli.Periodic_Bernpoly" (required by "Euler_MacLaurin.Euler_MacLaurin")
### theory "HOL-Library.Stirling"
### 0.291s elapsed time, 2.176s cpu time, 0.213s GC time
Loading theory "Bernoulli.Bernoulli_FPS" (required by "Euler_MacLaurin.Euler_MacLaurin")
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
Found termination order: "length <*mlex*> {}"
### theory "Bernoulli.Periodic_Bernpoly"
### 0.256s elapsed time, 1.938s cpu time, 0.165s GC time
### Ignoring duplicate rewrite rule:
### mset (filter ?P1 ?xs1) \<equiv> filter_mset ?P1 (mset ?xs1)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### theory "Landau_Symbols.Group_Sort"
### 0.792s elapsed time, 5.871s cpu time, 0.886s GC time
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
### theory "Bernoulli.Bernoulli_FPS"
### 1.173s elapsed time, 8.940s cpu time, 0.958s GC time
Loading theory "Euler_MacLaurin.Euler_MacLaurin"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
bundle asymp_equiv_notation
### theory "HOL-Library.Landau_Symbols"
### 2.007s elapsed time, 15.399s cpu time, 1.352s GC time
Loading theory "Landau_Symbols.Landau_Real_Products" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs")
locale euler_maclaurin_int
  fixes F :: "real \<Rightarrow> 'a"
    and f :: "real \<Rightarrow> 'a"
    and fs :: "nat \<Rightarrow> real \<Rightarrow> 'a"
    and a :: "int"
    and N :: "nat"
    and C :: "'a"
    and Y :: "real set"
  assumes "euler_maclaurin_int F f fs a N C Y"
locale euler_maclaurin_int'
  fixes F :: "real \<Rightarrow> 'a"
    and f :: "real \<Rightarrow> 'a"
    and fs :: "nat \<Rightarrow> real \<Rightarrow> 'a"
    and a :: "int"
    and N :: "nat"
    and C :: "'a"
    and Y :: "real set"
  assumes "euler_maclaurin_int' F f fs a N C Y"
locale euler_maclaurin_nat
  fixes F :: "real \<Rightarrow> 'a"
    and f :: "real \<Rightarrow> 'a"
    and fs :: "nat \<Rightarrow> real \<Rightarrow> 'a"
    and a :: "nat"
    and N :: "nat"
    and C :: "'a"
    and Y :: "real set"
  assumes "euler_maclaurin_nat F f fs a N C Y"
locale euler_maclaurin_nat'
  fixes F :: "real \<Rightarrow> 'a"
    and f :: "real \<Rightarrow> 'a"
    and fs :: "nat \<Rightarrow> real \<Rightarrow> 'a"
    and a :: "nat"
    and N :: "nat"
    and C :: "'a"
    and Y :: "real set"
  assumes "euler_maclaurin_nat' F f fs a N C Y"
### theory "Euler_MacLaurin.Euler_MacLaurin"
### 0.924s elapsed time, 6.759s cpu time, 0.353s GC time
consts
  bigtheta_pow ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> 'b) set
                   \<Rightarrow> nat
                                 \<Rightarrow> ('a \<Rightarrow> 'b) set"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale landau_function_family
  fixes F :: "'a filter"
    and H :: "('a \<Rightarrow> real) set"
  assumes "landau_function_family F H"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
locale landau_function_family_pair
  fixes F :: "'a filter"
    and G :: "('a \<Rightarrow> real) set"
    and H :: "('a \<Rightarrow> real) set"
    and g :: "'a \<Rightarrow> real"
  assumes "landau_function_family_pair F G H g"
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
consts
  landau_dominating_chain' ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> real) list \<Rightarrow> bool"
consts
  nonneg_list :: "'a list \<Rightarrow> bool"
consts
  pos_list :: "'a list \<Rightarrow> bool"
locale landau_function_family_chain
  fixes F :: "'b filter"
    and gs :: "'a list"
    and get_param :: "'a \<Rightarrow> real"
    and get_fun :: "'a \<Rightarrow> 'b \<Rightarrow> real"
  assumes "landau_function_family_chain F gs get_fun"
*** Failed to apply initial proof method (line 368 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** goal (1 subgoal):
***  1. integral {a..b} (\<lambda>t. pbernpoly n t *\<^sub>R f t) +
***     integral {b..c} (\<lambda>t. pbernpoly n t *\<^sub>R f t) =
***     integral {a..c} (\<lambda>t. pbernpoly n t *\<^sub>R f t)
*** At command "by" (line 368 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
instantiation
  primfun :: linorder
  less_eq_primfun == less_eq ::
    primfun \<Rightarrow> primfun \<Rightarrow> bool
  less_primfun == less :: primfun \<Rightarrow> primfun \<Rightarrow> bool
Found termination order: "{}"
*** Failed to apply initial proof method (line 435 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** using this:
***   ((\<lambda>x.
***        EM_remainder' n (f s) (real_of_int a)
***         (real (nat x))) \<longlongrightarrow>
***    lim (\<lambda>x. EM_remainder' n (f s) (real_of_int a) (real x)))
***    at_top
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          EM_remainder' n (f s) (real_of_int a)
***           (real_of_int x)) \<longlongrightarrow>
***      lim (\<lambda>x. EM_remainder' n (f s) (real_of_int a) (real x)))
***      at_top
*** At command "by" (line 435 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
*** Undefined fact: "holomorphic_uniform_sequence" (line 647 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** At command "proof" (line 647 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
*** Failed to apply initial proof method (line 1443 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** using this:
***   x0 \<le> x
***   a \<le> x0
*** goal (1 subgoal):
***  1. integral {a..x} (\<lambda>t. pbernpoly n t *\<^sub>R f t) =
***     integral {a..x0} (\<lambda>t. pbernpoly n t *\<^sub>R f t) +
***     integral {x0..x} (\<lambda>t. pbernpoly n t *\<^sub>R f t)
*** At command "by" (line 1443 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
Found termination order: "size_list size <*mlex*> {}"
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
Found termination order: "size_list size <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
Found termination order: "size_list size <*mlex*> {}"
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### pos_primfun_list [] \<equiv> False
### Rule already declared as introduction (intro)
### open {}
### Ignoring duplicate rewrite rule:
### pos_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> pos_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> nonneg_primfun_list ?xs1
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate rewrite rule:
### iszero_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### iszero_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### ?x1 = (0::?'b1) \<and> iszero_primfun_list ?xs1
### theory "Landau_Symbols.Landau_Real_Products"
### 2.612s elapsed time, 16.920s cpu time, 2.060s GC time
Loading theory "Landau_Symbols.Landau_Simprocs" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau" via "Landau_Symbols.Landau_More")
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
*** Undefined fact: "leibniz_rule_holomorphic" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** At command "proof" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
### ML warning (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (dest_bigtheta) has not been referenced.
### ML warning (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (x_name2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest1) has not been referenced.
### ML warning (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 373 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
signature LANDAU =
  sig
    val cancel_factor_conv: Proof.context -> cterm -> thm
    val cancel_factor_simproc: Proof.context -> cterm -> thm option
    val dest_landau: term -> term * term * term
    val landau_const_names: string list
    val landau_sum_limit: int Config.T
    val lift_landau_conv: conv -> conv
    val lift_landau_simproc:
       (Proof.context -> cterm -> thm option) ->
         Proof.context -> cterm -> thm option
    val simplify_landau_product_conv: Proof.context -> conv
    val simplify_landau_product_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_real_prod_prop_conv: Proof.context -> conv
    val simplify_landau_real_prod_prop_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_sum_conv: Proof.context -> conv
    val simplify_landau_sum_simproc: Proof.context -> cterm -> thm option
  end
structure Landau: LANDAU
### theory "Landau_Symbols.Landau_Simprocs"
### 0.332s elapsed time, 2.567s cpu time, 0.112s GC time
Loading theory "Landau_Symbols.Landau_More" (required by "Euler_MacLaurin.Euler_MacLaurin_Landau")
### theory "Landau_Symbols.Landau_More"
### 0.106s elapsed time, 0.550s cpu time, 0.038s GC time
Loading theory "Euler_MacLaurin.Euler_MacLaurin_Landau"
val it =
   "(\<lambda>x.
        5 * (ln (ln x))\<^sup>2 / (2 * x) powr (15 / 10) * inverse 2)
    \<in> \<omega>(\<lambda>x.
                      3 * ln x * ln x / x * ln (ln (ln (ln x)))) \<equiv>
    3 = 0 \<or>
    5 * inverse (2 powr (15 / 10)) * inverse 2 \<noteq> 0 \<and>
    pos_primfun_list
     (group_primfuns
       [(LnChain 1, - 1), (LnChain 1, - 1), (LnChain 0, 1),
        (LnChain 4, - 1), (LnChain 2, real 2), (LnChain 0, - (15 / 10))])":
   thm
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### theory "Euler_MacLaurin.Euler_MacLaurin_Landau"
### 0.523s elapsed time, 3.334s cpu time, 0.144s GC time
*** Undefined fact: "leibniz_rule_holomorphic" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** At command "proof" (line 475 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** Failed to apply initial proof method (line 1443 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** using this:
***   x0 \<le> x
***   a \<le> x0
*** goal (1 subgoal):
***  1. integral {a..x} (\<lambda>t. pbernpoly n t *\<^sub>R f t) =
***     integral {a..x0} (\<lambda>t. pbernpoly n t *\<^sub>R f t) +
***     integral {x0..x} (\<lambda>t. pbernpoly n t *\<^sub>R f t)
*** At command "by" (line 1443 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** Undefined fact: "holomorphic_uniform_sequence" (line 647 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** At command "proof" (line 647 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** Failed to apply initial proof method (line 435 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** using this:
***   ((\<lambda>x.
***        EM_remainder' n (f s) (real_of_int a)
***         (real (nat x))) \<longlongrightarrow>
***    lim (\<lambda>x. EM_remainder' n (f s) (real_of_int a) (real x)))
***    at_top
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          EM_remainder' n (f s) (real_of_int a)
***           (real_of_int x)) \<longlongrightarrow>
***      lim (\<lambda>x. EM_remainder' n (f s) (real_of_int a) (real x)))
***      at_top
*** At command "by" (line 435 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** Failed to apply initial proof method (line 368 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy"):
*** goal (1 subgoal):
***  1. integral {a..b} (\<lambda>t. pbernpoly n t *\<^sub>R f t) +
***     integral {b..c} (\<lambda>t. pbernpoly n t *\<^sub>R f t) =
***     integral {a..c} (\<lambda>t. pbernpoly n t *\<^sub>R f t)
*** At command "by" (line 368 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy")
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")

==========
Euler_Partition
Loading theory "HOL-Library.Cancellation" (required by "Euler_Partition.Euler_Partition" via "Card_Number_Partitions.Number_Partition" via "Card_Number_Partitions.Additions_to_Main" via "HOL-Library.Multiset")
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.329s elapsed time, 0.442s cpu time, 0.022s GC time
Loading theory "HOL-Library.Multiset" (required by "Euler_Partition.Euler_Partition" via "Card_Number_Partitions.Number_Partition" via "Card_Number_Partitions.Additions_to_Main")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
  plus_multiset == plus ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
### Partially applied constant "Multiset.inf_subset_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) \<equiv>
### fold (\<inter>#) ?xs ?x
### Partially applied constant "Multiset.sup_subset_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) \<equiv>
### fold (\<union>#) ?xs ?x
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set \<Rightarrow> 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set \<Rightarrow> 'a multiset
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset \<Rightarrow> nat
locale comp_fun_commute
  fixes f :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
  assumes "comp_fun_commute f"
### Introduced fixed type variable(s): 'd, 'e, 'f in "f__" or "g__"
consts
  mset :: "'a list \<Rightarrow> 'a multiset"
### Introduced fixed type variable(s): 'h in "A__"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
locale comm_monoid_mset
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "\<And>a b. (a \<le> b) = (\<exists>c. b = a + c)"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "\<And>a. (1::'a) * a = a"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
  less_multiset == less ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order: "(\<lambda>p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a multiset \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Introduced fixed type variable(s): 'd, 'e, 'f in "f__" or "g__"
### Introduced fixed type variable(s): 'd, 'e in "X__" or "f__" or "g__"
### Introduced fixed type variable(s): 'd, 'e in "f__"
### Introduced fixed type variable(s): 'd in "X__"
### Introduced fixed type variable(s): 'd, 'e, 'f in "R__" or "S__"
### Introduced fixed type variable(s): 'd, 'e in "R__"
### Ignoring duplicate rewrite rule:
### mset (map ?f1 ?xs1) \<equiv> image_mset ?f1 (mset ?xs1)
Proofs for inductive predicate(s) "rel_mset'"
### Ignoring duplicate rewrite rule:
### mset (map ?f1 ?xs1) \<equiv> image_mset ?f1 (mset ?xs1)
### Introduced fixed type variable(s): 'd in "z__"
### Introduced fixed type variable(s): 'd in "P__"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Library.Multiset"
### 2.609s elapsed time, 10.476s cpu time, 1.192s GC time
Loading theory "Card_Number_Partitions.Additions_to_Main" (required by "Euler_Partition.Euler_Partition" via "Card_Number_Partitions.Number_Partition")
### theory "Card_Number_Partitions.Additions_to_Main"
### 0.032s elapsed time, 0.268s cpu time, 0.000s GC time
Loading theory "Card_Number_Partitions.Number_Partition" (required by "Euler_Partition.Euler_Partition")
### theory "Card_Number_Partitions.Number_Partition"
### 0.245s elapsed time, 1.726s cpu time, 0.753s GC time
Loading theory "Euler_Partition.Euler_Partition"
### theory "Euler_Partition.Euler_Partition"
### 0.220s elapsed time, 1.726s cpu time, 0.070s GC time
*** Failed to finish proof (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy"):
*** goal (1 subgoal):
***  1. \<And>x.
***        \<lbrakk>\<And>b a c.
***                    \<lbrakk>b \<le> a; c \<le> b\<rbrakk>
***                    \<Longrightarrow> c \<le> a;
***         2 ^ x \<le> n\<rbrakk>
***        \<Longrightarrow> x \<le> n
*** At command "by" (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")
### Ignoring duplicate rewrite rule:
### 0 \<in> Suc ` ?A1 \<equiv> False
*** Undefined fact: "parity_induct" (line 103 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")
*** At command "using" (line 103 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")
*** Undefined fact: "parity_induct" (line 103 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")
*** At command "using" (line 103 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")
*** Failed to finish proof (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy"):
*** goal (1 subgoal):
***  1. \<And>x.
***        \<lbrakk>\<And>b a c.
***                    \<lbrakk>b \<le> a; c \<le> b\<rbrakk>
***                    \<Longrightarrow> c \<le> a;
***         2 ^ x \<le> n\<rbrakk>
***        \<Longrightarrow> x \<le> n
*** At command "by" (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy")

==========
Fermat3_4
Loading theory "Fermat3_4.Fermat4"
Loading theory "Fermat3_4.Quad_Form" (required by "Fermat3_4.Fermat3")
### theory "Fermat3_4.Fermat4"
### 0.102s elapsed time, 0.605s cpu time, 0.047s GC time
*** Failed to finish proof (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. a\<^sup>2 + b\<^sup>2 = c\<^sup>2 \<Longrightarrow> b \<le> c
*** At command "by" (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")
*** Failed to finish proof (line 88 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>b \<le> a; a * (a - b) = a\<^sup>2 - a * b\<rbrakk>
***     \<Longrightarrow> a\<^sup>2 - a * b =
***                       a * b + a\<^sup>2 - b\<^sup>2 + b\<^sup>2 - 2 * a * b
*** At command "by" (line 88 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")
*** Failed to finish proof (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. \<not> n \<le> m \<Longrightarrow> m\<^sup>2 < n\<^sup>2
*** At command "by" (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")
### theory "Fermat3_4.Quad_Form"
### 0.329s elapsed time, 2.373s cpu time, 0.125s GC time
Loading theory "Fermat3_4.Fermat3"
### theory "Fermat3_4.Fermat3"
### 0.088s elapsed time, 0.631s cpu time, 0.032s GC time
### Rule already declared as safe elimination (elim!)
### \<lbrakk>gcd ?a ?b = (1::?'a);
###  coprime ?a ?b \<Longrightarrow> PROP ?W\<rbrakk>
### \<Longrightarrow> PROP ?W
*** Failed to finish proof (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. \<not> n \<le> m \<Longrightarrow> m\<^sup>2 < n\<^sup>2
*** At command "by" (line 319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")
*** Failed to finish proof (line 88 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>b \<le> a; a * (a - b) = a\<^sup>2 - a * b\<rbrakk>
***     \<Longrightarrow> a\<^sup>2 - a * b =
***                       a * b + a\<^sup>2 - b\<^sup>2 + b\<^sup>2 - 2 * a * b
*** At command "by" (line 88 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")
*** Failed to finish proof (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy"):
*** goal (1 subgoal):
***  1. a\<^sup>2 + b\<^sup>2 = c\<^sup>2 \<Longrightarrow> b \<le> c
*** At command "by" (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy")

==========
Fourier
Loading theory "HOL-Library.BNF_Corec" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Loading theory "HOL-Real_Asymp.Inst_Existentials" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Loading theory "Fourier.Confine" (required by "Fourier.Fourier")
Loading theory "HOL-Library.Landau_Symbols" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Loading theory "Fourier.Fourier_Aux1" (required by "Fourier.Fourier" via "Fourier.Periodic" via "Fourier.Fourier_Aux2")
Loading theory "Ergodic_Theory.SG_Library_Complement" (required by "Fourier.Fourier" via "Fourier.Periodic" via "Fourier.Fourier_Aux2")
Loading theory "HOL-Real_Asymp.Eventuallize" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Loading theory "HOL-Real_Asymp.Lazy_Eval" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
signature INST_EXISTENTIALS =
  sig val tac: Proof.context -> term list -> int -> tactic end
structure Inst_Existentials: INST_EXISTENTIALS
signature EVENTUALLIZE =
  sig val eventuallize: Proof.context -> thm -> int option -> thm end
structure Eventuallize: EVENTUALLIZE
### theory "HOL-Real_Asymp.Inst_Existentials"
### 0.039s elapsed time, 0.336s cpu time, 0.000s GC time
### theory "HOL-Real_Asymp.Eventuallize"
### 0.043s elapsed time, 0.372s cpu time, 0.000s GC time
### Ignoring duplicate rewrite rule:
### ?x1\<^sup>2 powr (1 / 2) \<equiv> \<bar>?x1\<bar>
locale comm_monoid_set
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### theory "Fourier.Confine"
### 0.086s elapsed time, 0.670s cpu time, 0.070s GC time
locale cong
  fixes
    rel ::
      "('a \<Rightarrow> 'a \<Rightarrow> bool)
       \<Rightarrow> 'b \<Rightarrow> 'b \<Rightarrow> bool"
    and eval :: "'b \<Rightarrow> 'a"
    and
    retr ::
      "('a \<Rightarrow> 'a \<Rightarrow> bool)
       \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "cong rel eval retr"
consts
  CMP_BRANCH ::
    "cmp_result
     \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a"
### ML warning (line 177 of "~~/src/HOL/Real_Asymp/lazy_eval.ML"):
### Value identifier (instantiate) has not been referenced.
### ML warning (line 180 of "~~/src/HOL/Real_Asymp/lazy_eval.ML"):
### Value identifier (rhs) has not been referenced.
signature LAZY_EVAL =
  sig
    val add_facts: thm list -> eval_ctxt -> eval_ctxt
    val add_hook: eval_hook -> eval_ctxt -> eval_ctxt
    type constructor = string * int
    val constructor_arity: constructor list -> string -> int option
    type equation = {function: term, pats: pat list, rhs: term, thm: thm}
    type eval_ctxt = {ctxt: eval_ctxt', hooks: eval_hook list}
    type eval_ctxt' =
       {constructors: constructor list,
        equations: equation list,
        facts: thm Net.net, pctxt: Proof.context, verbose: bool}
    type eval_hook = eval_ctxt' -> term -> (term * conv) option
    val get_constructors: eval_ctxt -> constructor list
    val get_ctxt: eval_ctxt -> Proof.context
    val get_facts: eval_ctxt -> thm list
    val get_verbose: eval_ctxt -> bool
    val is_constructor_name: constructor list -> string -> bool
    val match:
       eval_ctxt ->
         pat ->
           term ->
             (indexname * term) list option ->
               (indexname * term) list option * term * conv
    val match_all:
       eval_ctxt ->
         pat list ->
           term list ->
             (indexname * term) list option ->
               (indexname * term) list option * term list * conv
    val mk_eval_ctxt:
       Proof.context -> constructor list -> thm list -> eval_ctxt
    datatype pat = AnyPat of indexname | ConsPat of string * pat list
    val set_constructors: constructor list -> eval_ctxt -> eval_ctxt
    val set_verbose: bool -> eval_ctxt -> eval_ctxt
    val whnf: eval_ctxt -> term -> term * conv
  end
structure Lazy_Eval: LAZY_EVAL
### theory "HOL-Real_Asymp.Lazy_Eval"
### 0.325s elapsed time, 2.494s cpu time, 0.216s GC time
class linordered_nonzero_semiring = semiring_char_0 + linorder +
  comm_semiring_1 + ordered_comm_semiring + zero_less_one +
  assumes
    "add_mono1":
      "\<And>a b. a < b \<Longrightarrow> a + (1::'a) < b + (1::'a)"
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### numeral ?m1 \<le> numeral ?n1 \<equiv> ?m1 \<le> ?n1
### Ignoring duplicate rewrite rule:
### (1::'a) \<le> numeral ?n1 \<equiv> True
### Ignoring duplicate rewrite rule:
### numeral ?n1 \<le> (1::'a) \<equiv> ?n1 \<le> num.One
### Ignoring duplicate rewrite rule:
### (0::'a) \<le> numeral ?n1 \<equiv> True
### Ignoring duplicate rewrite rule:
### numeral ?n1 \<le> (0::'a) \<equiv> False
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### numeral ?m1 < numeral ?n1 \<equiv> ?m1 < ?n1
### Ignoring duplicate rewrite rule:
### (1::'a) < numeral ?n1 \<equiv> num.One < ?n1
### Ignoring duplicate rewrite rule:
### numeral ?n1 < (1::'a) \<equiv> False
### Ignoring duplicate rewrite rule:
### (0::'a) < numeral ?n1 \<equiv> True
### Ignoring duplicate rewrite rule:
### numeral ?n1 < (0::'a) \<equiv> False
### Ignoring duplicate rewrite rule:
### 0 \<le> ?x1 \<Longrightarrow>
### ?x1 powr numeral ?n1 \<equiv> ?x1 ^ numeral ?n1
locale finite_borel_measure'
  fixes M :: "'a measure"
  assumes "finite_borel_measure' M"
### theory "Ergodic_Theory.SG_Library_Complement"
### 0.715s elapsed time, 5.199s cpu time, 0.885s GC time
Loading theory "Lp.Functional_Spaces" (required by "Fourier.Fourier" via "Fourier.Square_Integrable" via "Fourier.Lspace" via "Lp.Lp")
signature BNF_GFP_GREC_TACTICS =
  sig
    val mk_Lam_Inl_Inr_tac: Proof.context -> thm -> thm -> tactic
    val mk_Retr_coinduct_tac: Proof.context -> thm -> thm -> tactic
    val mk_algLam_algLam_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_algLam_algrho_tac: Proof.context -> thm -> thm -> tactic
    val mk_algLam_base_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm ->
                         thm list ->
                           thm ->
                             thm list -> thm list -> thm -> thm -> tactic
    val mk_algLam_step_tac: Proof.context -> thm -> thm -> thm -> tactic
    val mk_cong_locale_tac:
       Proof.context ->
         thm -> thm list -> thm -> thm -> thm list -> thm -> thm -> tactic
    val mk_corecUU_Inl_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm list ->
                     thm -> thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_corecUU_pointfree_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_corecUU_unique_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_corecU_pointfree_tac:
       Proof.context ->
         thm ->
           thm ->
             thm list ->
               thm ->
                 thm list -> thm -> thm list -> thm -> thm -> thm -> tactic
    val mk_dtor_algLam_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm list ->
                       thm ->
                         thm ->
                           thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_dtor_algrho_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_dtor_transfer_tac: Proof.context -> thm -> tactic
    val mk_equivp_Retr_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_Oper_tac:
       Proof.context ->
         int ->
           thm ->
             thm -> thm -> thm -> thm -> thm list -> thm -> thm -> tactic
    val mk_eval_V_or_CLeaf_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm list -> thm -> tactic
    val mk_eval_core_embL_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm ->
                         thm ->
                           thm ->
                             thm list ->
                               thm list -> thm list -> thm -> tactic
    val mk_eval_core_flat_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm list ->
                         thm ->
                           thm list ->
                             thm -> thm -> thm -> thm list -> tactic
    val mk_eval_core_k_as_ssig_tac:
       Proof.context ->
         thm ->
           thm -> thm -> thm list -> thm -> thm -> thm -> thm list -> tactic
    val mk_eval_embL_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_flat_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_sctr_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_extdd_mor_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_extdd_o_VLeaf_tac:
       Proof.context ->
         thm ->
           thm -> thm -> thm list -> thm list -> thm -> thm -> thm -> tactic
    val mk_flat_VLeaf_or_flat_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_flat_embL_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_mor_cutSsig_flat_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm list ->
                         thm ->
                           thm ->
                             thm ->
                               thm ->
                                 thm -> thm -> thm -> thm -> thm -> tactic
    val mk_natural_by_unfolding_tac: Proof.context -> thm list -> tactic
    val mk_natural_from_transfer_tac:
       Proof.context ->
         int ->
           bool list -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_sig_transfer_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_transfer_by_transfer_prover_tac:
       Proof.context -> thm list -> thm list -> thm list -> tactic
    val transfer_prover_add_tac:
       Proof.context -> thm list -> thm list -> int -> tactic
    val transfer_prover_eq_tac: Proof.context -> int -> tactic
  end
structure BNF_GFP_Grec_Tactics: BNF_GFP_GREC_TACTICS
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
instantiation
  fun :: (type, real_vector) real_vector
  scaleR_fun == scaleR ::
    real
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes
    "le_add_diff_inverse2":
      "\<And>b a. b \<le> a \<Longrightarrow> a - b + b = a"
### Ignoring duplicate rewrite rule:
### \<lbrakk>(0::'a) \<le> ?a1; (0::'a) \<le> ?b1; 0 < ?n1\<rbrakk>
### \<Longrightarrow> ?a1 ^ ?n1 \<le> ?b1 ^ ?n1 \<equiv> ?a1 \<le> ?b1
instantiation
  quasinorm :: (real_vector) preorder
  less_eq_quasinorm == less_eq ::
    'a quasinorm \<Rightarrow> 'a quasinorm \<Rightarrow> bool
  less_quasinorm == less ::
    'a quasinorm \<Rightarrow> 'a quasinorm \<Rightarrow> bool
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_derivative (\<lambda>x. x)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (id has_derivative id) (at ?a1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_derivative (\<lambda>x. 0::?'b1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. of_real (?g1 x)) has_derivative
###  (\<lambda>x. of_real (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x + ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x + ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) ?F1) \<Longrightarrow>
### ((\<lambda>x. \<Sum>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>x. \<Sum>i\<in>?I1. ?f'1 i x))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. - ?f1 x) has_derivative (\<lambda>x. - ?f'1 x)) ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x - ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x - ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x * ?g1 x) has_derivative
###                    (\<lambda>h. ?f1 ?x1 * ?g'1 h + ?f'1 h * ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x *\<^sub>R ?g1 x) has_derivative
###                    (\<lambda>h.
###                        ?f1 ?x1 *\<^sub>R ?g'1 h + ?f'1 h *\<^sub>R ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) (at ?x1 within ?S1)) \<Longrightarrow>
### ((\<lambda>x. \<Prod>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>y.
###      \<Sum>i\<in>?I1. ?f'1 i y * (\<Prod>j\<in>?I1 - {i}. ?f1 j ?x1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) (at ?x1 within ?S1) \<Longrightarrow>
### ((\<lambda>x. ?f1 x ^ ?n1) has_derivative
###  (\<lambda>y. of_nat ?n1 * ?f'1 y * ?f1 ?x1 ^ (?n1 - 1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 ?x1 \<noteq> (0::?'a1);
###  (?f1 has_derivative ?f'1) (at ?x1 within ?S1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. inverse (?f1 x)) has_derivative
###                    (\<lambda>h.
###                        - (inverse (?f1 ?x1) * ?f'1 h * inverse (?f1 ?x1))))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?S1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?S1);
###  ?g1 ?x1 \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x / ?g1 x) has_derivative
###                    (\<lambda>h.
###                        - ?f1 ?x1 *
###                        (inverse (?g1 ?x1) * ?g'1 h * inverse (?g1 ?x1)) +
###                        ?f'1 h / ?g1 ?x1))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>finite ?s1; \<forall>a\<in>?s1. ?f1 a differentiable ?net1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. \<Sum>a\<in>?s1. ?f1 a x) differentiable
###                   ?net1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable ?F1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?f1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1; ?g1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x / ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable at ?x1 within ?s1 \<Longrightarrow>
### (\<lambda>x. ?f1 x ^ ?n1) differentiable at ?x1 within ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_vector_derivative (0::?'a1)) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_vector_derivative 1) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?k1) has_field_derivative (0::?'a1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_field_derivative (1::?'a1)) ?F1 \<equiv> True
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. cnj (?g1 x)) has_derivative (\<lambda>x. cnj (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. (?f1 x, ?g1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### id differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z * ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>z. - ?f1 z) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z + ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z - ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1;
###  \<And>x. x \<in> ?S1 \<Longrightarrow> ?f1 x \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. (norm x)\<^sup>2) has_derivative
###  (\<lambda>x. 2 *\<^sub>R (?a1 \<bullet> x)))
###  (at ?a1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<noteq> (0::?'a1) \<Longrightarrow>
### norm differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<notin> ?S1 \<Longrightarrow>
### norm differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (*) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. z) field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### id field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (+) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 C1_differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### space (lebesgue_on ?y) \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?S1 \<in> lmeasurable \<Longrightarrow>
### (\<lambda>x. ?c1) absolutely_integrable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### Numeral1 \<equiv> 1::'a
### Ignoring duplicate rewrite rule:
### Numeral1 \<equiv> 1::'a
### theory "Lp.Functional_Spaces"
### 0.778s elapsed time, 5.622s cpu time, 1.323s GC time
Loading theory "Lp.Lp" (required by "Fourier.Fourier" via "Fourier.Square_Integrable" via "Fourier.Lspace")
### theory "Fourier.Fourier_Aux1"
### 1.557s elapsed time, 11.350s cpu time, 2.208s GC time
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### theory "Lp.Lp"
### 0.390s elapsed time, 2.999s cpu time, 0.143s GC time
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
bundle asymp_equiv_notation
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
### theory "HOL-Library.Landau_Symbols"
### 2.249s elapsed time, 16.657s cpu time, 2.466s GC time
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ignoring duplicate rewrite rule:
### ?x1 + ?y1 = (0::?'a1) \<equiv> ?x1 = (0::?'a1) \<and> ?y1 = (0::?'a1)
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Metis: Unused theorems: "Groups.ab_semigroup_add_class.add.commute"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### e2ennreal \<infinity> \<equiv> \<top>
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### ML warning (line 261 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 290 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 457 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 513 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 564 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 604 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 901 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1234 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1269 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1295 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1622 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1671 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1809 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1810 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2060 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2065 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2134 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2150 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2151 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2152 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2153 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2155 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2156 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2158 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2159 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2184 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2371 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2372 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2401 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2402 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2403 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2405 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2409 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2413 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2437 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2478 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2268 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 2595 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2600 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2712 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2713 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2714 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2753 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2754 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2755 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2757 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2759 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2766 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2793 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2570 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 2915 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 3015 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 3065 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3073 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3079 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3086 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Value identifier (fp_alives) has not been referenced.
### ML warning (line 3094 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3150 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3213 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
signature BNF_GFP_GREC =
  sig
    val Tsubst: typ -> typ -> typ -> typ
    val bnf_kill_all_but:
       int -> BNF_Def.bnf -> local_theory -> BNF_Def.bnf * local_theory
    type buffer =
       {CLeaf: term,
        Oper: term,
        VLeaf: term, ctr_wrapper: term, friends: (typ * term) Symtab.table}
    type corec_info =
       {Lam: term,
        Lam_pointful_natural: thm,
        Lam_transfer: thm,
        Retr: term,
        Retr_coinduct: thm,
        Y: typ,
        Z: typ,
        algLam: term,
        algLam_thm: thm,
        all_algLam_algs: thm list,
        all_dead_k_bnfs: BNF_Def.bnf list,
        buffer: buffer,
        corecUU: term,
        corecUU_thm: thm,
        corecUU_transfer: thm,
        corecUU_unique: thm,
        dtor_algLam: thm, dtor_coinduct_info: dtor_coinduct_info, ...}
    val corec_info_of: typ -> local_theory -> corec_info * local_theory
    val corec_infos_of: Proof.context -> string -> corec_info list
    val corec_infos_of_generic:
       Context.generic -> Symtab.key -> corec_info list
    val define_const:
       bool ->
         binding ->
           int ->
             string -> term -> local_theory -> (term * thm) * local_theory
    type dtor_coinduct_info =
       {cong_alg_intros: thm list,
        cong_base: thm,
        cong_def: thm,
        cong_locale: thm,
        cong_refl: thm, cong_sym: thm, cong_trans: thm, dtor_coinduct: thm}
    val dummify_atomic_types: term -> term
    val freeze_types:
       Proof.context -> (indexname * sort) list -> typ list -> typ list
    type friend_info = {algLam_algrho: thm, algrho: term, dtor_algrho: thm}
    val has_no_corec_info: Proof.context -> string -> bool
    val map_buffer: (term -> term) -> buffer -> buffer
    val maybe_corec_info_of: Proof.context -> typ -> corec_info option
    val mk_fp_binding: binding -> string -> binding
    val not_codatatype: Proof.context -> typ -> 'a
    val prepare_friend_corec:
       string ->
         typ ->
           local_theory ->
             (corec_info * binding * int * typ * typ * typ * typ * typ *
              BNF_Def.bnf * BNF_Def.bnf * BNF_FP_Def_Sugar.fp_sugar *
              BNF_FP_Def_Sugar.fp_sugar * buffer)
             *
             local_theory
    val print_corec_infos: Proof.context -> unit
    val register_friend_corec:
       string ->
         binding ->
           int ->
             typ ->
               typ ->
                 typ ->
                   BNF_Def.bnf ->
                     BNF_FP_Def_Sugar.fp_sugar ->
                       BNF_FP_Def_Sugar.fp_sugar ->
                         term ->
                           term ->
                             thm ->
                               corec_info ->
                                 local_theory -> friend_info * local_theory
    val specialize_buffer_types: buffer -> buffer
    val substT: typ -> typ -> term -> term
  end
structure BNF_GFP_Grec: BNF_GFP_GREC
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 163 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 188 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 329 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Matches are not exhaustive.
signature BNF_GFP_GREC_SUGAR_UTIL =
  sig
    exception UNNATURAL of unit
    val corec_parse_info_of:
       Proof.context ->
         typ list -> typ -> BNF_GFP_Grec.buffer -> s_parse_info
    val friend_parse_info_of:
       Proof.context ->
         typ list ->
           typ -> BNF_GFP_Grec.buffer -> s_parse_info * rho_parse_info
    val generalize_types: int -> typ -> typ -> typ
    val mk_abs_transfer: Proof.context -> string -> thm
    val mk_const_transfer_goal: Proof.context -> string * typ -> term
    val mk_curry_uncurryN_balanced: Proof.context -> int -> thm
    val mk_pointful_natural_from_transfer: Proof.context -> thm -> thm
    val mk_rep_transfer: Proof.context -> string -> thm
    type rho_parse_info =
       {discs: term Symtab.table,
        it: term,
        mk_case: typ -> term,
        pattern_ctrs: (term * term list) Symtab.table,
        sels: term Symtab.table}
    type s_parse_info =
       {ctr_guards: term Symtab.table,
        inner_buffer: BNF_GFP_Grec.buffer,
        outer_buffer: BNF_GFP_Grec.buffer}
  end
structure BNF_GFP_Grec_Sugar_Util: BNF_GFP_GREC_SUGAR_UTIL
signature BNF_GFP_GREC_SUGAR_TACTICS =
  sig
    val mk_case_dtor_tac:
       Proof.context ->
         term -> thm -> thm -> thm list -> thm -> thm list -> tactic
    val mk_code_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val mk_cong_intro_ctr_or_friend_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_eq_algrho_tac:
       Proof.context ->
         term list ->
           term ->
             term ->
               term ->
                 term ->
                   term ->
                     thm ->
                       thm ->
                         thm list ->
                           thm list ->
                             thm list ->
                               thm list ->
                                 thm ->
                                   thm ->
                                     thm ->
                                       thm list ->
   thm list -> thm list -> thm -> ...
    val mk_eq_corecUU_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val mk_last_disc_tac: Proof.context -> term -> thm -> thm list -> tactic
    val mk_rho_transfer_tac:
       Proof.context -> bool -> thm -> thm list -> tactic
    val mk_unique_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val rho_transfer_simps: thm list
  end
structure BNF_GFP_Grec_Sugar_Tactics: BNF_GFP_GREC_SUGAR_TACTICS
*** Undefined fact: "borel_measurable_continuous_on1" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "using" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
### ML warning (line 62 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (ctrN) has not been referenced.
### ML warning (line 63 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (discN) has not been referenced.
### ML warning (line 64 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (disc_iffN) has not been referenced.
### ML warning (line 72 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (selN) has not been referenced.
### ML warning (line 78 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (simp_attrs) has not been referenced.
### ML warning (line 219 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 224 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 255 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 257 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 317 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 320 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 322 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 361 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 363 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 388 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 418 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 440 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 443 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 446 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 515 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 542 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 543 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 562 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 563 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 593 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 596 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 598 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 618 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 622 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 624 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 627 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 630 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 644 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 657 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 661 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 653 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 714 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 786 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 787 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 800 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1091 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1092 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1151 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1187 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1219 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1214 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1243 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1316 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1368 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1399 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1658 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1692 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1737 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1806 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1807 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1817 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1853 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1862 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1825 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1875 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1878 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1880 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1938 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1918 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1955 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1970 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (transfer) has not been referenced.
### ML warning (line 1971 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2029 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2031 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2032 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2033 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2037 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2050 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2120 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2204 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2214 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2229 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2248 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2288 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2320 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2330 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2338 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
signature BNF_GFP_GREC_SUGAR =
  sig
    val build_corecUU_arg_and_goals:
       bool ->
         term ->
           term list * term ->
             local_theory ->
               (((thm list * thm list * thm list) * term list) * term) *
               local_theory
    val coinduction_upto_cmd:
       string * string -> local_theory -> local_theory
    val corec_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list * string ->
             local_theory -> local_theory
    datatype corec_option
    =
         Friend_Option
       | Plugins_Option of Proof.context -> Plugin_Name.filter
       | Transfer_Option
    val corecursive_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list * string ->
             local_theory -> Proof.state
    val derive_eq_corecUU:
       Proof.context ->
         BNF_GFP_Grec.corec_info -> term -> term -> thm -> thm
    val derive_unique:
       Proof.context ->
         morphism -> term -> BNF_GFP_Grec.corec_info -> string -> thm -> thm
    val explore_corec_equation:
       Proof.context ->
         bool ->
           bool ->
             string ->
               term ->
                 BNF_GFP_Grec_Sugar_Util.s_parse_info ->
                   typ -> term list * term -> term list * term
    val friend_of_corec_cmd:
       (string * string option) * string -> local_theory -> Proof.state
    val parse_corec_equation:
       Proof.context -> term list -> term -> term list * term
  end
structure BNF_GFP_Grec_Sugar: BNF_GFP_GREC_SUGAR
### ML warning (line 58 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_unique_sugar.ML"):
### Pattern is not exhaustive.
signature BNF_GFP_GREC_UNIQUE_SUGAR =
  sig val corec_unique_tac: Proof.context -> int -> tactic end
structure BNF_GFP_Grec_Unique_Sugar: BNF_GFP_GREC_UNIQUE_SUGAR
### theory "HOL-Library.BNF_Corec"
### 6.764s elapsed time, 48.702s cpu time, 7.325s GC time
Loading theory "HOL-Real_Asymp.Multiseries_Expansion" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds")
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
consts
  mssnth :: "'a msstream \<Rightarrow> nat \<Rightarrow> 'a"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
consts
  msllist_of_msstream :: "'a msstream \<Rightarrow> 'a msllist"
consts
  mssalternate :: "'a \<Rightarrow> 'a \<Rightarrow> 'a msstream"
consts
  exp_series_stream_aux ::
    "real \<Rightarrow> real \<Rightarrow> real msstream"
consts
  ln_series_stream_aux ::
    "bool \<Rightarrow> real \<Rightarrow> real msstream"
consts
  gbinomial_series_aux ::
    "bool
     \<Rightarrow> real
                   \<Rightarrow> real
                                 \<Rightarrow> real
         \<Rightarrow> real msllist"
consts
  sin_series_stream_aux ::
    "bool \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real msstream"
consts
  arctan_series_stream_aux ::
    "bool \<Rightarrow> real \<Rightarrow> real msstream"
class multiseries = inverse + minus + plus + times + uminus +
  fixes
    is_expansion ::
      "'a \<Rightarrow> (real \<Rightarrow> real) list \<Rightarrow> bool"
    and expansion_level :: "'a itself \<Rightarrow> nat"
    and eval :: "'a \<Rightarrow> real \<Rightarrow> real"
    and zero_expansion :: "'a"
    and const_expansion :: "real \<Rightarrow> 'a"
    and
    powr_expansion ::
      "bool \<Rightarrow> 'a \<Rightarrow> real \<Rightarrow> 'a"
    and
    power_expansion ::
      "bool \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a"
    and trimmed :: "'a \<Rightarrow> bool"
    and dominant_term :: "'a \<Rightarrow> real \<times> real list"
  assumes
    "is_expansion_length":
      "\<And>F basis.
          is_expansion F basis \<Longrightarrow>
          length basis = expansion_level TYPE('a)"
  assumes
    "is_expansion_zero":
      "\<And>basis.
          \<lbrakk>basis_wf basis;
           length basis = expansion_level TYPE('a)\<rbrakk>
          \<Longrightarrow> is_expansion zero_expansion basis"
  assumes
    "is_expansion_const":
      "\<And>basis c.
          \<lbrakk>basis_wf basis;
           length basis = expansion_level TYPE('a)\<rbrakk>
          \<Longrightarrow> is_expansion (const_expansion c) basis"
  assumes
    "is_expansion_uminus":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; is_expansion F basis\<rbrakk>
          \<Longrightarrow> is_expansion (- F) basis"
  assumes
    "is_expansion_add":
      "\<And>basis F G.
          \<lbrakk>basis_wf basis; is_expansion F basis;
           is_expansion G basis\<rbrakk>
          \<Longrightarrow> is_expansion (F + G) basis"
  assumes
    "is_expansion_minus":
      "\<And>basis F G.
          \<lbrakk>basis_wf basis; is_expansion F basis;
           is_expansion G basis\<rbrakk>
          \<Longrightarrow> is_expansion (F - G) basis"
  assumes
    "is_expansion_mult":
      "\<And>basis F G.
          \<lbrakk>basis_wf basis; is_expansion F basis;
           is_expansion G basis\<rbrakk>
          \<Longrightarrow> is_expansion (F * G) basis"
  assumes
    "is_expansion_inverse":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; trimmed F; is_expansion F basis\<rbrakk>
          \<Longrightarrow> is_expansion (inverse F) basis"
  assumes
    "is_expansion_divide":
      "\<And>basis G F.
          \<lbrakk>basis_wf basis; trimmed G; is_expansion F basis;
           is_expansion G basis\<rbrakk>
          \<Longrightarrow> is_expansion (F / G) basis"
  assumes
    "is_expansion_powr":
      "\<And>basis F abort p.
          \<lbrakk>basis_wf basis; trimmed F; 0 < fst (dominant_term F);
           is_expansion F basis\<rbrakk>
          \<Longrightarrow> is_expansion (powr_expansion abort F p) basis"
  assumes
    "is_expansion_power":
      "\<And>basis F abort n.
          \<lbrakk>basis_wf basis; trimmed F; is_expansion F basis\<rbrakk>
          \<Longrightarrow> is_expansion (power_expansion abort F n) basis"
  assumes
    "is_expansion_imp_smallo":
      "\<And>basis F b e.
          \<lbrakk>basis_wf basis; is_expansion F basis;
           filterlim b at_top at_top;
           \<forall>g\<in>set basis.
              (\<lambda>x. ln (g x)) \<in> o(\<lambda>x. ln (b x));
           0 < e\<rbrakk>
          \<Longrightarrow> eval F \<in> o(\<lambda>x. b x powr e)"
  assumes
    "is_expansion_imp_smallomega":
      "\<And>basis F b e.
          \<lbrakk>basis_wf basis; is_expansion F basis;
           filterlim b at_top at_top; trimmed F;
           \<forall>g\<in>set basis.
              (\<lambda>x. ln (g x)) \<in> o(\<lambda>x. ln (b x));
           e < 0\<rbrakk>
          \<Longrightarrow> eval F \<in> \<omega>(\<lambda>x. b x powr e)"
  assumes
    "trimmed_imp_eventually_sgn":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; is_expansion F basis; trimmed F\<rbrakk>
          \<Longrightarrow> \<forall>\<^sub>F x in at_top.
                               sgn (eval F x) = sgn (fst (dominant_term F))"
  assumes
    "trimmed_imp_eventually_nz":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; is_expansion F basis; trimmed F\<rbrakk>
          \<Longrightarrow> \<forall>\<^sub>F x in at_top.
                               eval F x \<noteq> 0"
  assumes
    "trimmed_imp_dominant_term_nz":
      "\<And>F.
          trimmed F \<Longrightarrow> fst (dominant_term F) \<noteq> 0"
  assumes
    "dominant_term":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; is_expansion F basis; trimmed F\<rbrakk>
          \<Longrightarrow> eval
                             F \<sim>[at_top] eval_monom (dominant_term F)
         basis"
  assumes
    "dominant_term_bigo":
      "\<And>basis F.
          \<lbrakk>basis_wf basis; is_expansion F basis\<rbrakk>
          \<Longrightarrow> eval F
                            \<in> O(eval_monom (1, snd (dominant_term F))
                                     basis)"
  assumes
    "length_dominant_term":
      "\<And>F. length (snd (dominant_term F)) = expansion_level TYPE('a)"
  assumes
    "fst_dominant_term_uminus":
      "\<And>F. fst (dominant_term (- F)) = - fst (dominant_term F)"
  assumes "trimmed_uminus_iff": "\<And>F. trimmed (- F) = trimmed F"
  assumes "add_zero_expansion_left": "\<And>F. zero_expansion + F = F"
  assumes "add_zero_expansion_right": "\<And>F. F + zero_expansion = F"
  assumes "eval_zero": "\<And>x. eval zero_expansion x = 0"
  assumes "eval_const": "\<And>c x. eval (const_expansion c) x = c"
  assumes "eval_uminus": "\<And>F. eval (- F) = (\<lambda>x. - eval F x)"
  assumes
    "eval_plus":
      "\<And>F G. eval (F + G) = (\<lambda>x. eval F x + eval G x)"
  assumes
    "eval_minus":
      "\<And>F G. eval (F - G) = (\<lambda>x. eval F x - eval G x)"
  assumes
    "eval_times":
      "\<And>F G. eval (F * G) = (\<lambda>x. eval F x * eval G x)"
  assumes
    "eval_inverse":
      "\<And>F. eval (inverse F) = (\<lambda>x. inverse (eval F x))"
  assumes
    "eval_divide":
      "\<And>F G. eval (F / G) = (\<lambda>x. eval F x / eval G x)"
  assumes
    "eval_powr":
      "\<And>abort F p.
          eval (powr_expansion abort F p) = (\<lambda>x. eval F x powr p)"
  assumes
    "eval_power":
      "\<And>abort F n.
          eval (power_expansion abort F n) = (\<lambda>x. eval F x ^ n)"
  assumes "minus_eq_plus_uminus": "\<And>F G. F - G = F + - G"
  assumes "times_const_expansion_1": "\<And>F. const_expansion 1 * F = F"
  assumes
    "trimmed_const_expansion":
      "\<And>c. trimmed (const_expansion c) = (c \<noteq> 0)"
instantiation
  real :: multiseries
  is_expansion_real == is_expansion ::
    real \<Rightarrow> (real \<Rightarrow> real) list \<Rightarrow> bool
  expansion_level_real == expansion_level :: real itself \<Rightarrow> nat
  eval_real == eval :: real \<Rightarrow> real \<Rightarrow> real
  zero_expansion_real == zero_expansion :: real
  const_expansion_real == const_expansion :: real \<Rightarrow> real
  powr_expansion_real == powr_expansion ::
    bool \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real
  power_expansion_real == power_expansion ::
    bool \<Rightarrow> real \<Rightarrow> nat \<Rightarrow> real
  trimmed_real == trimmed :: real \<Rightarrow> bool
  dominant_term_real == dominant_term ::
    real \<Rightarrow> real \<times> real list
Proofs for inductive predicate(s) "is_expansion_real"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
*** Undefined fact: "Lim_eventually" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "by" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
consts
  ms_exp_gt :: "real \<Rightarrow> real option \<Rightarrow> bool"
Proofs for coinductive predicate(s) "is_expansion_aux"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the coinduction rule ...
  Proving the simplification rules ...
consts
  plus_ms_aux ::
    "('a \<times> real) msllist
     \<Rightarrow> ('a \<times> real) msllist
                   \<Rightarrow> ('a \<times> real) msllist"
consts
  times_ms_aux ::
    "('a \<times> real) msllist
     \<Rightarrow> ('a \<times> real) msllist
                   \<Rightarrow> ('a \<times> real) msllist"
consts
  powser_ms_aux ::
    "real msllist
     \<Rightarrow> ('a \<times> real) msllist
                   \<Rightarrow> ('a \<times> real) msllist"
### Missing patterns in function definition:
### inverse_ms_aux MSLNil = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### \<And>a c. powr_ms_aux a MSLNil c = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### \<And>a c. power_ms_aux a MSLNil c = undefined
Found termination order: "{}"
Proofs for inductive predicate(s) "ms_closure"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### ?f1 \<sim>[?F1] ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### inverse_ms_aux (MSLCons ?x1 ?xs1) \<equiv>
### let c' = inverse (fst ?x1)
### in scale_shift_ms_aux (c', - snd ?x1)
###     (powser_ms_aux (msllist_of_msstream (mssalternate 1 (- 1)))
###       (scale_shift_ms_aux (c', - snd ?x1) ?xs1))
instantiation
  ms :: (uminus) uminus
  uminus_ms == uminus :: 'a ms \<Rightarrow> 'a ms
consts
  uminus_ms :: "'a ms \<Rightarrow> 'a ms"
instantiation
  ms :: (plus) plus
  plus_ms == plus :: 'a ms \<Rightarrow> 'a ms \<Rightarrow> 'a ms
Found termination order: "{}"
instantiation
  ms :: ({plus,uminus}) minus
  minus_ms == minus :: 'a ms \<Rightarrow> 'a ms \<Rightarrow> 'a ms
instantiation
  ms :: ({plus,times}) times
  times_ms == times :: 'a ms \<Rightarrow> 'a ms \<Rightarrow> 'a ms
Found termination order: "{}"
instantiation
  ms :: (multiseries) inverse
  inverse_ms == inverse :: 'a ms \<Rightarrow> 'a ms
  divide_ms == divide :: 'a ms \<Rightarrow> 'a ms \<Rightarrow> 'a ms
Found termination order: "{}"
Found termination order: "{}"
instantiation
  ms :: (multiseries) multiseries
  is_expansion_ms == is_expansion ::
    'a ms \<Rightarrow> (real \<Rightarrow> real) list \<Rightarrow> bool
  expansion_level_ms == expansion_level :: 'a ms itself \<Rightarrow> nat
  eval_ms == eval :: 'a ms \<Rightarrow> real \<Rightarrow> real
  zero_expansion_ms == zero_expansion :: 'a ms
  const_expansion_ms == const_expansion :: real \<Rightarrow> 'a ms
  powr_expansion_ms == powr_expansion ::
    bool \<Rightarrow> 'a ms \<Rightarrow> real \<Rightarrow> 'a ms
  power_expansion_ms == power_expansion ::
    bool \<Rightarrow> 'a ms \<Rightarrow> nat \<Rightarrow> 'a ms
  trimmed_ms == trimmed :: 'a ms \<Rightarrow> bool
  dominant_term_ms == dominant_term ::
    'a ms \<Rightarrow> real \<times> real list
consts
  is_expansion_ms ::
    "'a ms \<Rightarrow> (real \<Rightarrow> real) list \<Rightarrow> bool"
consts
  eval_ms :: "'a ms \<Rightarrow> real \<Rightarrow> real"
consts
  powr_expansion_ms ::
    "bool \<Rightarrow> 'a ms \<Rightarrow> real \<Rightarrow> 'a ms"
consts
  power_expansion_ms ::
    "bool \<Rightarrow> 'a ms \<Rightarrow> nat \<Rightarrow> 'a ms"
consts
  trimmed_ms :: "'a ms \<Rightarrow> bool"
consts
  dominant_term_ms :: "'a ms \<Rightarrow> real \<times> real list"
Proofs for inductive predicate(s) "expands_to"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### inverse_ms_aux (MSLCons ?x1 ?xs1) \<equiv>
### let c' = inverse (fst ?x1)
### in scale_shift_ms_aux (c', - snd ?x1)
###     (powser_ms_aux (msllist_of_msstream (mssalternate 1 (- 1)))
###       (scale_shift_ms_aux (c', - snd ?x1) ?xs1))
Proofs for coinductive predicate(s) "asymp_powser"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the coinduction rule ...
  Proving the simplification rules ...
consts
  flip_cmp_result :: "cmp_result \<Rightarrow> cmp_result"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
consts
  compare_list_0 :: "real list \<Rightarrow> cmp_result"
find_theorems
  "of_int"
  "at_bot"

found 2 theorem(s):
Multiseries_Expansion.filterlim_real_of_int_at_bot:
  filterlim real_of_int at_bot at_bot
Multiseries_Expansion.filterlim_of_int_at_bot:
  filterlim ?f ?F at_bot \<Longrightarrow>
  LIM x at_bot. ?f (real_of_int x) :> ?F
signature ASYMPTOTIC_BASIS =
  sig
    exception BASIS of string * basis
    datatype basis = SEmpty | SNE of basis'
    datatype basis'
    = SCons of basis_info * basis_ln_info * basis' | SSng of basis_info
    val basis_eq: basis -> basis -> bool
    val basis_eq': basis' -> basis' -> bool
    type basis_info = {head: term, wf_thm: thm}
    type basis_ln_info = {ln_thm: thm, trimmed_thm: thm}
    val basis_size: basis -> int
    val basis_size': basis' -> int
    val check_basis: basis -> basis
    val check_basis': basis' -> basis'
    val combine_lifts: lifting -> lifting -> lifting
    val default_basis: basis
    val extract_basis_list: thm -> term list
    val get_basis_head: basis -> term
    val get_basis_head': basis' -> term
    val get_basis_list: basis -> term list
    val get_basis_list': basis' -> term list
    val get_basis_term: basis -> term
    val get_basis_wf_thm: basis -> thm
    val get_basis_wf_thm': basis' -> thm
    val get_ln_info: basis -> basis_ln_info option
    val insert_ln: basis -> basis
    val insert_ln': basis' -> basis'
    val lift: basis -> thm -> thm
    val lift_expands_to_thm: lifting -> thm -> thm
    val lift_modification: basis -> basis -> basis
    val lift_modification': basis' -> basis' -> basis'
    val lift_trimmed_pos_thm: lifting -> thm -> thm
    val lift_trimmed_thm: lifting -> thm -> thm
    type lifting
    val mk_expansion_level_eq_thm: basis -> thm
    val mk_expansion_level_eq_thm': basis' -> thm
    val mk_lifting: term list -> basis -> lifting
    val split_basis:
       basis -> (basis_info * basis_ln_info option * basis) option
    val split_basis': basis' -> basis_info * basis_ln_info option * basis
    val tl_basis: basis -> basis
    val tl_basis': basis' -> basis
  end
structure Asymptotic_Basis: ASYMPTOTIC_BASIS
### ML warning (line 520 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 553 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 585 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 617 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 648 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
signature EXP_LOG_EXPRESSION =
  sig
    exception DUP
    type custom_handler =
       Lazy_Eval.eval_ctxt ->
         term ->
           thm list * Asymptotic_Basis.basis -> thm * Asymptotic_Basis.basis
    val expand_custom: Proof.context -> string -> custom_handler option
    datatype expr
    =
         Absolute of expr
       | Add of expr * expr
       | ArcTan of expr
       | Ceiling of expr
       | ConstExpr of term
       | Cos of expr
       | Custom of string * term * expr list
       | Div of expr * expr
       | Exp of expr
       | ExpLn of expr
       | Floor of expr
       | Frac of expr
       | Inverse of expr
       | Ln of expr
       | LnPowr of expr * expr
       | Max of expr * expr
       | Min of expr * expr
       | Minus of expr * expr
       | Mult of ...
       | ...
    val expr_to_term: expr -> term
    val limit_maple: string -> string
    val limit_mathematica: string -> string
    val limit_maxima: string -> string
    val limit_sage: string -> string
    val limit_sympy: string -> string
    val preproc_term_conv: Proof.context -> conv
    val register_custom:
       binding -> term -> custom_handler -> local_theory -> local_theory
    val register_custom_from_thm:
       binding -> thm -> custom_handler -> local_theory -> local_theory
    val reify: Proof.context -> term -> expr * thm
    val reify_maple: Proof.context -> term -> string
    val reify_mathematica: Proof.context -> term -> string
    val reify_maxima: Proof.context -> term -> string
    val reify_sage: Proof.context -> term -> string
    val reify_simple: Proof.context -> term -> expr * thm
    val reify_sympy: Proof.context -> term -> string
    val to_maple: expr -> string
    val to_mathematica: expr -> string
    val to_maxima: expr -> string
    val to_sage: expr -> string
    val to_sympy: expr -> string
  end
structure Exp_Log_Expression: EXP_LOG_EXPRESSION
signature EXPANSION_INTERFACE =
  sig
    type T
    val expand_term:
       Lazy_Eval.eval_ctxt ->
         term -> Asymptotic_Basis.basis -> T * Asymptotic_Basis.basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list ->
           Asymptotic_Basis.basis -> T list * Asymptotic_Basis.basis
    val prove_asymp_equiv:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_bot:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_infinity:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_left_0:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_right_0:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_top:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_bigo:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_bigtheta:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_nonzero:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_smallo:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
  end
### ML warning (line 576 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Value identifier (ectxt) has not been referenced.
### ML warning (line 1175 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1176 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1256 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1247 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1380 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1405 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1400 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Matches are not exhaustive.
### ML warning (line 1502 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1491 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2011 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2034 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Matches are not exhaustive.
### ML warning (line 2078 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2130 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2145 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2177 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2192 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
signature MULTISERIES_EXPANSION =
  sig
    val arctan_expansion:
       Lazy_Eval.eval_ctxt -> basis -> expansion_thm -> expansion_thm
    type basis
    val check_expansion: expr -> expansion_thm -> expansion_thm
    val compare_expansions:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis ->
           order * thm * expansion_thm * expansion_thm
    val compare_expansions':
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> comparison_result
    datatype comparison_result
    =
         Cmp_Asymp_Equiv of thm * thm
       | Cmp_Dominated of
           order * thm list * zeroness * trimmed_thm * expansion_thm *
           expansion_thm
    val compute_limit: Lazy_Eval.eval_ctxt -> term -> limit * thm
    val const_expansion:
       Lazy_Eval.eval_ctxt -> basis -> term -> expansion_thm
    val ev_zeroness_oracle: Lazy_Eval.eval_ctxt -> term -> thm option
    val exp_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> basis -> expansion_thm * basis
    val expand:
       Lazy_Eval.eval_ctxt -> expr -> basis -> expansion_thm * basis
    val expand_term:
       Lazy_Eval.eval_ctxt -> term -> basis -> expansion_thm * basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list -> basis -> expansion_thm list * basis
    val expands_to_hd: thm -> thm
    type expansion_thm
    eqtype expr
    val extract_terms:
       int * bool ->
         Lazy_Eval.eval_ctxt -> basis -> term -> term * term option
    val get_coeff: term -> term
    val get_eval: term -> term
    val get_expanded_fun: thm -> term
    val get_expansion: thm -> term
    val get_exponent: term -> term
    val get_intyness: Proof.context -> cterm -> intyness
    val get_parity: cterm -> parity
    val get_sign_oracles:
       Context.generic -> (string * (Proof.context -> int -> tactic)) list
    datatype intyness = Nat of thm | Neg_Nat of thm | No_Nat
    datatype limit
    =
         Finite_Limit of term
       | Infinite_Limit of bool option
       | Zero_Limit of bool option
    val limit_of_expansion:
       bool * bool -> Lazy_Eval.eval_ctxt -> thm * basis -> limit * thm
    val ln_expansion:
       Lazy_Eval.eval_ctxt ->
         trimmed_thm -> expansion_thm -> basis -> expansion_thm * basis
    val max_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val min_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val mk_eval_ctxt: Proof.context -> Lazy_Eval.eval_ctxt
    datatype parity = Even of thm | Odd of thm | Unknown_Parity
    val power_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_const_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_nat_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val prove_asymp_equiv: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_asymptotic_relation:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> order * thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_bot: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_infinity: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_left_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_right_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_top: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_bigo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigtheta: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_compare_expansions: order -> thm list -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_nonzero: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_smallo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val register_sign_oracle:
       binding * (Proof.context -> int -> tactic) ->
         Context.generic -> Context.generic
    val retrim_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm * thm
    val retrim_pos_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * basis * trimmed_thm ->
           expansion_thm * thm * trimmed_thm
    val root_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val sgn_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm
    val simplify_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm
    val simplify_term: Lazy_Eval.eval_ctxt -> term -> term
    val simplify_trimmed_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * trimmed_thm -> expansion_thm * trimmed_thm
    val solve_eval_eq: thm -> thm
    val trim_expansion:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt ->
             expansion_thm * basis ->
               expansion_thm * zeroness * trimmed_thm option
    val trim_expansion_while_greater:
       bool ->
         term list option ->
           bool ->
             trim_mode option ->
               Lazy_Eval.eval_ctxt ->
                 thm * basis -> thm * trim_result * (zeroness * thm) list
    datatype trim_mode = Neg_Trim | Pos_Trim | Sgn_Trim | Simple_Trim
    datatype trim_result
    = Aborted of order | Trimmed of zeroness * trimmed_thm option
    type trimmed_thm
    val try_drop_leading_term_ex:
       bool -> Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm option
    val try_prove_ev_eq: Lazy_Eval.eval_ctxt -> term * term -> thm option
    val try_prove_real_eq:
       bool -> Lazy_Eval.eval_ctxt -> term * term -> thm option
    val whnf_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> term option * expansion_thm * thm
    val zero_expansion: basis -> expansion_thm
    datatype zeroness = IsNeg | IsNonZero | IsPos | IsZero
    val zeroness_oracle:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt -> term -> zeroness * thm option
  end
structure Multiseries_Expansion: MULTISERIES_EXPANSION
structure Multiseries_Expansion_Basic: EXPANSION_INTERFACE
### ML warning (line 45 of "~~/src/HOL/Real_Asymp/real_asymp.ML"):
### Pattern is not exhaustive.
### ML warning (line 58 of "~~/src/HOL/Real_Asymp/real_asymp.ML"):
### Pattern is not exhaustive.
signature REAL_ASYMP =
  sig val tac: bool -> Proof.context -> int -> tactic end
structure Real_Asymp_Basic: REAL_ASYMP
functor Real_Asymp (Exp: EXPANSION_INTERFACE): REAL_ASYMP
### theory "HOL-Real_Asymp.Multiseries_Expansion"
### 13.704s elapsed time, 51.177s cpu time, 5.323s GC time
Loading theory "HOL-Real_Asymp.Multiseries_Expansion_Bounds" (required by "Fourier.Fourier" via "HOL-Real_Asymp.Real_Asymp")
### ML warning (line 365 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Matches are not exhaustive.
### ML warning (line 365 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Value identifier (convert_bounds') has not been referenced.
### ML warning (line 396 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Matches are not exhaustive.
### ML warning (line 481 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 451 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 510 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 589 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 632 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 709 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 826 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 957 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 944 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1003 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1043 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Value identifier (nonneg_power_expansion_bounds) has not been referenced.
### ML warning (line 1211 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1217 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1223 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
signature MULTISERIES_EXPANSION =
  sig
    val arctan_expansion:
       Lazy_Eval.eval_ctxt -> basis -> expansion_thm -> expansion_thm
    type basis
    datatype bounds
    =
         Bounds of lower_bound option * upper_bound option
       | Exact of expansion_thm
    val check_expansion: expr -> expansion_thm -> expansion_thm
    val compare_expansions:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis ->
           order * thm * expansion_thm * expansion_thm
    val compare_expansions':
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> comparison_result
    datatype comparison_result
    =
         Cmp_Asymp_Equiv of thm * thm
       | Cmp_Dominated of
           order * thm list * zeroness * trimmed_thm * expansion_thm *
           expansion_thm
    val compute_limit: Lazy_Eval.eval_ctxt -> term -> limit * thm
    val const_expansion:
       Lazy_Eval.eval_ctxt -> basis -> term -> expansion_thm
    val ev_zeroness_oracle: Lazy_Eval.eval_ctxt -> term -> thm option
    val exp_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> basis -> expansion_thm * basis
    val expand:
       Lazy_Eval.eval_ctxt -> expr -> basis -> expansion_thm * basis
    val expand_term:
       Lazy_Eval.eval_ctxt -> term -> basis -> expansion_thm * basis
    val expand_term_bounds:
       Lazy_Eval.eval_ctxt -> term -> basis -> bounds * basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list -> basis -> expansion_thm list * basis
    val expand_terms_bounds:
       Lazy_Eval.eval_ctxt -> term list -> basis -> bounds list * basis
    val expands_to_hd: thm -> thm
    type expansion_thm
    eqtype expr
    val extract_terms:
       int * bool ->
         Lazy_Eval.eval_ctxt -> basis -> term -> term * term option
    val find_greater_expansion:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm * thm * thm
    val find_smaller_expansion:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm * thm * thm
    val get_coeff: term -> term
    val get_eval: term -> term
    val get_expanded_fun: thm -> term
    val get_expanded_fun_bounds: bounds -> term
    val get_expansion: thm -> term
    val get_exponent: term -> term
    val get_intyness: Proof.context -> cterm -> intyness
    val get_parity: cterm -> parity
    val get_sign_oracles:
       Context.generic -> (string * (Proof.context -> int -> tactic)) list
    datatype intyness = Nat of thm | Neg_Nat of thm | No_Nat
    val is_vacuous: bounds -> bool
    val lift_bounds: basis -> bounds -> bounds
    datatype limit
    =
         Finite_Limit of term
       | Infinite_Limit of bool option
       | Zero_Limit of bool option
    val limit_of_expansion:
       bool * bool -> Lazy_Eval.eval_ctxt -> thm * basis -> limit * thm
    val limit_of_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> limit_result
    datatype limit_result
    = Exact_Limit of term | Limit_Bounds of term option * term option
    val ln_expansion:
       Lazy_Eval.eval_ctxt ->
         trimmed_thm -> expansion_thm -> basis -> expansion_thm * basis
    type lower_bound = expansion_thm * lower_bound_thm
    type lower_bound_thm
    val max_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val min_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val mk_eval_ctxt: Proof.context -> Lazy_Eval.eval_ctxt
    val mult_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds
    datatype parity = Even of thm | Odd of thm | Unknown_Parity
    val power_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val power_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * term * basis -> bounds
    val powr_const_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_const_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * term * basis -> bounds
    val powr_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds * basis
    val powr_nat_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_nat_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds * basis
    val prove_asymp_equiv: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_asymp_equiv_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_asymptotic_relation:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> order * thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_0_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_bot: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_bot_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_infinity: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_infinity_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_left_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_left_0_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_right_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_right_0_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_top: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_top_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_bigo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigo_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_bigtheta: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigtheta_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_compare_expansions: order -> thm list -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_greater_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_less_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_eventually_nonzero: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_eventually_nonzero_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_nhds_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_smallo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_smallo_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val register_sign_oracle:
       binding * (Proof.context -> int -> tactic) ->
         Context.generic -> Context.generic
    val retrim_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm * thm
    val retrim_pos_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * basis * trimmed_thm ->
           expansion_thm * thm * trimmed_thm
    val root_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val sgn_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm
    val sgn_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> bounds
    val simplify_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm
    val simplify_term: Lazy_Eval.eval_ctxt -> term -> term
    val simplify_trimmed_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * trimmed_thm -> expansion_thm * trimmed_thm
    val solve_eval_eq: thm -> thm
    val trim_expansion:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt ->
             expansion_thm * basis ->
               expansion_thm * zeroness * trimmed_thm option
    val trim_expansion_while_greater:
       bool ->
         term list option ->
           bool ->
             trim_mode option ->
               Lazy_Eval.eval_ctxt ->
                 thm * basis -> thm * trim_result * (zeroness * thm) list
    datatype trim_mode = Neg_Trim | Pos_Trim | Sgn_Trim | Simple_Trim
    datatype trim_result
    = Aborted of order | Trimmed of zeroness * trimmed_thm option
    type trimmed_thm
    val try_drop_leading_term_ex:
       bool -> Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm option
    val try_prove_ev_eq: Lazy_Eval.eval_ctxt -> term * term -> thm option
    val try_prove_real_eq:
       bool -> Lazy_Eval.eval_ctxt -> term * term -> thm option
    type upper_bound = expansion_thm * upper_bound_thm
    type upper_bound_thm
    val whnf_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> term option * expansion_thm * thm
    val zero_expansion: basis -> expansion_thm
    datatype zeroness = IsNeg | IsNonZero | IsPos | IsZero
    val zeroness_oracle:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt -> term -> zeroness * thm option
  end
structure Multiseries_Expansion: MULTISERIES_EXPANSION
structure Multiseries_Expansion_Bounds: EXPANSION_INTERFACE
structure Real_Asymp_Bounds: REAL_ASYMP
### theory "HOL-Real_Asymp.Multiseries_Expansion_Bounds"
### 2.071s elapsed time, 8.112s cpu time, 3.222s GC time
Loading theory "HOL-Real_Asymp.Real_Asymp" (required by "Fourier.Fourier")
signature REAL_ASYMP_DIAG =
  sig
    val expansion:
       Proof.context ->
         thm list ->
           bool * int -> term -> term -> term * Asymptotic_Basis.basis
    val expansion_cmd:
       Proof.context ->
         (Facts.ref * Token.src list) list list ->
           bool * int -> string -> string option -> unit
    val limit:
       Proof.context ->
         thm list -> term -> term -> Multiseries_Expansion.limit_result
    val limit_cmd:
       Proof.context ->
         (Facts.ref * Token.src list) list list ->
           string -> string option -> unit
    val pretty_limit: Proof.context -> term -> Pretty.T
  end
structure Real_Asymp_Diag: REAL_ASYMP_DIAG
### theory "HOL-Real_Asymp.Real_Asymp"
### 0.158s elapsed time, 0.440s cpu time, 0.000s GC time
*** Failed to load theory "Fourier.Fourier_Aux2" (unresolved "Fourier.Fourier_Aux1")
*** Failed to load theory "Fourier.Periodic" (unresolved "Fourier.Fourier_Aux2")
*** Failed to load theory "Fourier.Lspace" (unresolved "Fourier.Fourier_Aux1")
*** Failed to load theory "Fourier.Square_Integrable" (unresolved "Fourier.Fourier_Aux2", "Fourier.Lspace")
*** Failed to load theory "Fourier.Fourier" (unresolved "Fourier.Periodic", "Fourier.Square_Integrable")
*** Undefined fact: "Lim_eventually" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "by" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "using" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** Undefined fact: "tendsto_explicit" (line 411 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fourier/Fourier_Aux1.thy")
*** At command "lemmas" (line 411 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Fourier/Fourier_Aux1.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Girth_Chromatic
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "HOL-Library.Code_Target_Int" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
Loading theory "HOL-Library.Lattice_Algebras" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
Loading theory "HOL-Library.Log_Nat" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
Loading theory "Girth_Chromatic.Girth_Chromatic_Misc" (required by "Girth_Chromatic.Girth_Chromatic" via "Girth_Chromatic.Ugraphs")
### Code generator: dropping subsumed code equation
### 1 \<equiv> Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l \<equiv> ?l
### Code generator: dropping subsumed code equation
### ?k + 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m \<equiv> Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m \<equiv> Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l \<equiv> - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) \<equiv> Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) \<equiv> Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 \<equiv> 0
### theory "HOL-Library.Code_Abstract_Nat"
### 0.075s elapsed time, 0.535s cpu time, 0.048s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k * 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One \<equiv> - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One \<equiv> ?k
### Code generator: dropping subsumed code equation
### 0 div ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k div 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n \<equiv> - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n \<equiv>
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n \<equiv>
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n \<equiv> snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### 0 mod ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k \<equiv> True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Neg ?l \<equiv> ?l \<le> ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Pos ?l \<equiv> ?k \<le> ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Neg ?l \<equiv> False
### theory "Girth_Chromatic.Girth_Chromatic_Misc"
### 0.091s elapsed time, 0.661s cpu time, 0.048s GC time
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Pos ?l \<equiv> True
Loading theory "Girth_Chromatic.Ugraphs" (required by "Girth_Chromatic.Girth_Chromatic")
### Code generator: dropping subsumed code equation
### 0 \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l \<equiv> ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l \<equiv> ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 < 0 \<equiv> False
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### if ?n = 0 \<or> ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### Suc ?m \<le> ?n \<equiv> ?m < ?n
### Code generator: dropping subsumed code equation
### 0 \<le> ?n \<equiv> True
### theory "HOL-Library.Log_Nat"
### 0.167s elapsed time, 1.226s cpu time, 0.096s GC time
### Code generator: dropping subsumed code equation
### ?m < Suc ?n \<equiv> ?m \<le> ?n
### Code generator: dropping subsumed code equation
### ?n < 0 \<equiv> False
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
Found termination order: "{}"
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) \<equiv> numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 \<equiv> 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) \<equiv> - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) \<equiv> nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) \<equiv> 0
### Code generator: dropping subsumed code equation
### of_nat ?n \<equiv>
### semiring_1_class.of_nat_aux (\<lambda>i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Int"
### 0.199s elapsed time, 1.496s cpu time, 0.096s GC time
### theory "HOL-Library.Code_Target_Nat"
### 0.131s elapsed time, 1.020s cpu time, 0.048s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation")
Found termination order: "size_list size <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
### theory "HOL-Library.Code_Target_Numeral"
### 0.071s elapsed time, 0.532s cpu time, 0.050s GC time
### theory "Girth_Chromatic.Ugraphs"
### 0.203s elapsed time, 1.573s cpu time, 0.098s GC time
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
### Ignoring duplicate rewrite rule:
### of_nat (sum ?f1 ?A1) \<equiv> \<Sum>x\<in>?A1. of_nat (?f1 x)
### ML warning (line 19 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 18 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
locale linorder_stupid_syntax
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_stupid_syntax less_eq less"
locale linorder_no_ub
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
locale linorder_no_lb
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
locale constr_dense_linorder
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and between :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 81 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (xT) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.min (\<le>)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.max (\<le>)) ?xs ?x
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 1.482s elapsed time, 7.392s cpu time, 0.872s GC time
### Ignoring duplicate rewrite rule:
### sup ?x1 (sup ?x1 ?y1) \<equiv> sup ?x1 ?y1
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "\<And>a. \<bar>a\<bar> = sup a (- a)"
### theory "HOL-Library.Lattice_Algebras"
### 2.981s elapsed time, 9.876s cpu time, 1.040s GC time
Loading theory "HOL-Library.Interval" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
Loading theory "HOL-Library.Float" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float \<Rightarrow> float
  abs_float == abs :: float \<Rightarrow> float
  uminus_float == uminus :: float \<Rightarrow> float
  one_float == one_class.one :: float
  times_float == times :: float \<Rightarrow> float \<Rightarrow> float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float \<Rightarrow> float \<Rightarrow> float
  less_eq_float == less_eq :: float \<Rightarrow> float \<Rightarrow> bool
  less_float == less :: float \<Rightarrow> float \<Rightarrow> bool
  plus_float == plus :: float \<Rightarrow> float \<Rightarrow> float
  equal_float == equal_class.equal ::
    float \<Rightarrow> float \<Rightarrow> bool
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float \<Rightarrow> float \<Rightarrow> float
  sup_float == sup :: float \<Rightarrow> float \<Rightarrow> float
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> (float \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
  less_interval == less ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 \<equiv> ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<equiv> ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 - ?c1 \<equiv> ?a1 - (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + (?b1 - ?c1) \<equiv> ?a1 + ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 = ?c1 \<equiv> ?a1 = ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 = ?c1 - ?b1 \<equiv> ?a1 + ?b1 = ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - (?b1 - ?c1) \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 + ?c1 \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 < ?c1 \<equiv> ?a1 < ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 < ?c1 - ?b1 \<equiv> ?a1 + ?b1 < ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 \<le> ?c1 \<equiv> ?a1 \<le> ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 \<le> ?c1 - ?b1 \<equiv> ?a1 + ?b1 \<le> ?c1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: (linordered_semiring) times
  times_interval == times ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
### Ignoring duplicate rewrite rule:
### ?i1 \<in> {?l1..?u1} \<equiv> ?l1 \<le> ?i1 \<and> ?i1 \<le> ?u1
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Metis: Unused theorems: "Lattices.linorder_class.min.left_commute"
### theory "HOL-Library.Float"
### 1.610s elapsed time, 10.133s cpu time, 1.154s GC time
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Rewrite rule not in simpset:
### power_down ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1
### then truncate_down (Suc ?p1) ((power_down ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_down (Suc ?p1) (?x1 * power_down ?p1 ?x1 ?n1)
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set \<Rightarrow> bool
### Ignoring duplicate rewrite rule:
### power_up ?p1 ?x1 0 \<equiv> 1
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
### Rewrite rule not in simpset:
### power_up ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1 then truncate_up ?p1 ((power_up ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_up ?p1 (?x1 * power_up ?p1 ?x1 ?n1)
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a interval \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### theory "HOL-Library.Interval"
### 2.414s elapsed time, 16.146s cpu time, 2.419s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
### theory "HOL-Library.Interval_Float"
### 0.965s elapsed time, 6.240s cpu time, 0.240s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Girth_Chromatic.Girth_Chromatic" via "HOL-Decision_Procs.Approximation")
consts
  horner ::
    "(nat \<Rightarrow> nat)
     \<Rightarrow> (nat \<Rightarrow> nat \<Rightarrow> nat)
                   \<Rightarrow> nat
                                 \<Rightarrow> nat
         \<Rightarrow> nat \<Rightarrow> real \<Rightarrow> real"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 3.288s elapsed time, 18.894s cpu time, 1.948s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Girth_Chromatic.Girth_Chromatic")
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln ?x1 \<le> ln ?y1 \<equiv> ?x1 \<le> ?y1
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. 0) (\<lambda>x. Suc 0) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. Suc 0) (\<lambda>x. 0) <*mlex*>
   case_sum (\<lambda>p. size (fst (snd (snd p))))
    (\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 204 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 17.545s elapsed time, 44.679s cpu time, 8.070s GC time
Loading theory "Girth_Chromatic.Girth_Chromatic"
locale edge_space
  fixes n :: "nat"
    and p :: "real"
  assumes "edge_space p"
locale edge_space
  fixes n :: "nat"
    and p :: "real"
  assumes "edge_space p"
### Ignoring duplicate rewrite rule:
### nat \<lceil>?x1\<rceil> \<le> ?a1 \<equiv> ?x1 \<le> real ?a1
### theory "Girth_Chromatic.Girth_Chromatic"
### 1.408s elapsed time, 2.446s cpu time, 0.274s GC time
### Introduced fixed type variable(s): 'a in "xs__"
### Ignoring duplicate rewrite rule:
### nat \<lceil>?x1\<rceil> \<le> ?a1 \<equiv> ?x1 \<le> real ?a1
*** Failed to finish proof (line 668 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Girth_Chromatic/Girth_Chromatic.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>0 < \<epsilon>;
***      \<forall>\<^sup>\<infinity>x.
***         12 * real k * real x powr - (\<epsilon> / 2) < 1\<rbrakk>
***     \<Longrightarrow> \<forall>\<^sup>\<infinity>n.
***                          12 * real k * real n powr - (\<epsilon> / 2)
***                          \<le> \<epsilon>
*** At command "by" (line 668 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Girth_Chromatic/Girth_Chromatic.thy")
*** Failed to finish proof (line 668 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Girth_Chromatic/Girth_Chromatic.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>0 < \<epsilon>;
***      \<forall>\<^sup>\<infinity>x.
***         12 * real k * real x powr - (\<epsilon> / 2) < 1\<rbrakk>
***     \<Longrightarrow> \<forall>\<^sup>\<infinity>n.
***                          12 * real k * real n powr - (\<epsilon> / 2)
***                          \<le> \<epsilon>
*** At command "by" (line 668 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Girth_Chromatic/Girth_Chromatic.thy")

==========
Graph_Saturation
Loading theory "Graph_Saturation.MissingRelation"
### theory "Graph_Saturation.MissingRelation"
### 0.117s elapsed time, 0.471s cpu time, 0.031s GC time
Loading theory "Graph_Saturation.LabeledGraphs" (required by "Graph_Saturation.CombinedCorrectness" via "Graph_Saturation.GraphRewriting" via "Graph_Saturation.RulesAndChains")
### theory "Graph_Saturation.LabeledGraphs"
### 0.531s elapsed time, 2.076s cpu time, 0.172s GC time
Loading theory "Graph_Saturation.LabeledGraphSemantics" (required by "Graph_Saturation.CombinedCorrectness" via "Graph_Saturation.StandardRules" via "Graph_Saturation.StandardModels")
Loading theory "Graph_Saturation.RulesAndChains" (required by "Graph_Saturation.CombinedCorrectness" via "Graph_Saturation.GraphRewriting")
Proofs for inductive predicate(s) "WPC"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "Graph_Saturation.RulesAndChains"
### 0.495s elapsed time, 3.651s cpu time, 0.661s GC time
Loading theory "Graph_Saturation.GraphRewriting" (required by "Graph_Saturation.CombinedCorrectness")
### Introduced fixed type variable(s): 'c, 'd in "A__" or "B__" or "x__"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
### theory "Graph_Saturation.GraphRewriting"
### 0.495s elapsed time, 3.561s cpu time, 0.216s GC time
*** exception THM 0 raised (line 310 of "drule.ML"):
*** OF: multiple unifiers
*** \<lbrakk>valid_selector ?Rules ?sel;
***  ?UNION ?Rules (edges \<circ> snd) \<subseteq> ?L \<times> UNIV;
***  edges (graph_of ?G) \<subseteq> ?L \<times> UNIV\<rbrakk>
*** \<Longrightarrow> edges (graph_of (mk_chain ?sel ?Rules ?G ?i))
***                   \<subseteq> ?L \<times> UNIV
*** valid_selector Rules sel
*** UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV
*** edges (graph_of G) \<subseteq> L \<times> UNIV
*** At command "using" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy")
*** Failed to finish proof (line 514 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>(a, x, y) \<in> edges (snd R); sel G = Some (R, f);
***      UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV;
***      R \<in> Rules; graph_homomorphism (fst R) (graph_of G) f;
***      \<not> extensible R (graph_of G) f;
***      \<forall>a.
***         (\<exists>aa b.
***             (aa, b) \<in> Rules \<and>
***             (\<exists>ba.
***                 graph_homomorphism aa (graph_of G) ba \<and>
***                 a = nextMax (Range ba) \<and>
***                 \<not> extensible (aa, b) (graph_of G)
***                         ba)) \<longrightarrow>
***         nextMax (Range f) \<le> a;
***      subgraph (fst R) (snd R); graph (snd R); finite (vertices (snd R));
***      finite (edges (snd R))\<rbrakk>
***     \<Longrightarrow> a \<in> L
*** At command "by" (line 514 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy")
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### \<lbrakk>(?a, ?b) \<in> ?r; (?b, ?c) \<in> ?s\<rbrakk>
### \<Longrightarrow> (?a, ?c) \<in> ?r O ?s
### Rule already declared as introduction (intro)
### \<lbrakk>(?a, ?b) \<in> ?r; (?b, ?c) \<in> ?s\<rbrakk>
### \<Longrightarrow> (?a, ?c) \<in> ?r O ?s
### theory "Graph_Saturation.LabeledGraphSemantics"
### 2.014s elapsed time, 10.894s cpu time, 1.805s GC time
Loading theory "Graph_Saturation.RuleSemanticsConnection" (required by "Graph_Saturation.CombinedCorrectness" via "Graph_Saturation.StandardRules")
Loading theory "Graph_Saturation.StandardModels" (required by "Graph_Saturation.CombinedCorrectness" via "Graph_Saturation.StandardRules")
### theory "Graph_Saturation.StandardModels"
### 0.071s elapsed time, 0.499s cpu time, 0.000s GC time
Found termination order: "size <*mlex*> {}"
### theory "Graph_Saturation.RuleSemanticsConnection"
### 0.269s elapsed time, 1.261s cpu time, 0.032s GC time
Loading theory "Graph_Saturation.StandardRules" (required by "Graph_Saturation.CombinedCorrectness")
### theory "Graph_Saturation.StandardRules"
### 0.339s elapsed time, 2.465s cpu time, 0.069s GC time
Loading theory "Graph_Saturation.CombinedCorrectness"
### theory "Graph_Saturation.CombinedCorrectness"
### 0.170s elapsed time, 1.136s cpu time, 0.075s GC time
*** Extra variables on rhs: "UNION"
*** The error(s) above occurred in definition:
*** "the_model C Rs \<equiv>
*** let L = fst ` UNION Rs (edges \<circ> snd) \<union>
***         {S_Bot, S_Top, S_Idt} \<union>
***         S_Const ` C;
***     Rules = Rs \<union> standard_rules C L;
***     sel = non_constructive_selector Rules
*** in the_lcg sel Rules (0, {})"
*** At command "definition" (line 11 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/CombinedCorrectness.thy")
*** Failed to finish proof (line 514 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>(a, x, y) \<in> edges (snd R); sel G = Some (R, f);
***      UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV;
***      R \<in> Rules; graph_homomorphism (fst R) (graph_of G) f;
***      \<not> extensible R (graph_of G) f;
***      \<forall>a.
***         (\<exists>aa b.
***             (aa, b) \<in> Rules \<and>
***             (\<exists>ba.
***                 graph_homomorphism aa (graph_of G) ba \<and>
***                 a = nextMax (Range ba) \<and>
***                 \<not> extensible (aa, b) (graph_of G)
***                         ba)) \<longrightarrow>
***         nextMax (Range f) \<le> a;
***      subgraph (fst R) (snd R); graph (snd R); finite (vertices (snd R));
***      finite (edges (snd R))\<rbrakk>
***     \<Longrightarrow> a \<in> L
*** At command "by" (line 514 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy")
*** exception THM 0 raised (line 310 of "drule.ML"):
*** OF: multiple unifiers
*** \<lbrakk>valid_selector ?Rules ?sel;
***  ?UNION ?Rules (edges \<circ> snd) \<subseteq> ?L \<times> UNIV;
***  edges (graph_of ?G) \<subseteq> ?L \<times> UNIV\<rbrakk>
*** \<Longrightarrow> edges (graph_of (mk_chain ?sel ?Rules ?G ?i))
***                   \<subseteq> ?L \<times> UNIV
*** valid_selector Rules sel
*** UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV
*** edges (graph_of G) \<subseteq> L \<times> UNIV
*** At command "using" (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy")

==========
Green
Loading theory "Green.General_Utils" (required by "Green.CircExample" via "Green.Green" via "Green.Paths" via "Green.Derivs")
### theory "Green.General_Utils"
### 0.065s elapsed time, 0.273s cpu time, 0.000s GC time
Loading theory "Green.Derivs" (required by "Green.CircExample" via "Green.Green" via "Green.Paths")
Loading theory "Green.Integrals" (required by "Green.CircExample" via "Green.Green" via "Green.Paths")
### theory "Green.Integrals"
### 0.192s elapsed time, 1.353s cpu time, 0.090s GC time
### theory "Green.Derivs"
### 0.334s elapsed time, 2.416s cpu time, 0.136s GC time
Loading theory "Green.Paths" (required by "Green.CircExample" via "Green.Green")
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?c1) piecewise_C1_differentiable_on ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 piecewise_C1_differentiable_on ?S1;
###  ?g1 piecewise_C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) piecewise_C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Undeclared classical rule
### continuous_on ?A ?f
Found termination order: "{}"
*** Failed to finish proof (line 695 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>f integrable_on {a..y}; \<not> y < x;
***      a \<le> x \<and> x \<le> b \<and> x \<notin> s\<rbrakk>
***     \<Longrightarrow> integral {a..y} f =
***                       integral {a..x} f + integral {x..y} f
*** At command "by" (line 695 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy")
Found termination order:
  "size_list (\<lambda>p. (nat \<circ> abs) (fst p)) <*mlex*> {}"
Found termination order:
  "size_list (\<lambda>p. (nat \<circ> abs) (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "chain_subdiv_path"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "Green.Paths"
### 1.667s elapsed time, 12.204s cpu time, 0.467s GC time
Loading theory "Green.Green" (required by "Green.CircExample")
*** Undefined fact: "Cauchy_Integral_Theorem.C1_differentiable_on_mult" (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Derivs.thy")
*** At command "using" (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Derivs.thy")
locale R2
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
  assumes "R2 i j"
locale green_typeII_cube
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and twoC :: "real \<times> real \<Rightarrow> real \<times> real"
    and F :: "real \<times> real \<Rightarrow> real \<times> real"
  assumes "green_typeII_cube i j twoC F"
locale green_typeII_chain
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and F :: "real \<times> real \<Rightarrow> real \<times> real"
    and
    two_chain :: "(real \<times> real \<Rightarrow> real \<times> real) set"
    and s :: "(real \<times> real) set"
  assumes "green_typeII_chain i j F two_chain s"
locale green_typeI_cube
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and twoC :: "real \<times> real \<Rightarrow> real \<times> real"
    and F :: "real \<times> real \<Rightarrow> real \<times> real"
  assumes "green_typeI_cube i j twoC F"
locale green_typeI_chain
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and F :: "real \<times> real \<Rightarrow> real \<times> real"
    and
    two_chain :: "(real \<times> real \<Rightarrow> real \<times> real) set"
    and s :: "(real \<times> real) set"
  assumes "green_typeI_chain i j F two_chain s"
locale green_typeI_typeII_chain
  fixes s :: "(real \<times> real) set"
    and i :: "real \<times> real"
    and j :: "real \<times> real"
    and F :: "real \<times> real \<Rightarrow> real \<times> real"
    and
    two_chain_typeI ::
      "(real \<times> real \<Rightarrow> real \<times> real) set"
    and
    two_chain_typeII ::
      "(real \<times> real \<Rightarrow> real \<times> real) set"
  assumes
    "green_typeI_typeII_chain s i j F two_chain_typeI two_chain_typeII"
### theory "Green.Green"
### 1.119s elapsed time, 7.438s cpu time, 0.304s GC time
Loading theory "Green.SymmetricR2Shapes" (required by "Green.CircExample")
locale R2
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
  assumes "R2 i j"
### theory "Green.SymmetricR2Shapes"
### 0.117s elapsed time, 0.783s cpu time, 0.052s GC time
Loading theory "Green.CircExample"
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
Loading theory "Green.DiamExample"
locale circle
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and d :: "real"
  assumes "circle i j d"
locale diamond
  fixes i :: "real \<times> real"
    and j :: "real \<times> real"
    and d :: "real"
  assumes "diamond i j d"
### theory "Green.CircExample"
### 0.494s elapsed time, 3.374s cpu time, 0.132s GC time
### theory "Green.DiamExample"
### 0.450s elapsed time, 3.050s cpu time, 0.132s GC time
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Metis: Unused theorems: "local.Cons.prems_4"
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_join" (line 839 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 839 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1045 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1045 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1388 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1388 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 947 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 947 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1246 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1246 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### [] = ?x21.1 # ?x22.1 \<equiv> False
### Ignoring duplicate rewrite rule:
### ?x21.1 # ?x22.1 = ?y21.1 # ?y22.1 \<equiv>
### ?x21.1 = ?y21.1 \<and> ?x22.1 = ?y22.1
### Metis: Unused theorems: "Product_Type.case_prodI2"
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 454 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 454 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 1448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 1448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "sum_not_0" (line 2004 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 2004 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** SMT: Solver "z3": Timed out (setting the configuration option "smt_timeout" might help)
*** At command "by" (line 902 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Metis: Unused theorems: "local.neqs2_1"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** SMT: Solver "z3": Timed out (setting the configuration option "smt_timeout" might help)
*** At command "by" (line 902 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy")
*** Undefined fact: "sum_not_0" (line 2004 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 2004 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 1448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 1448 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 705 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose" (line 454 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** At command "using" (line 454 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Green.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1246 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1246 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 947 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 947 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1388 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1388 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_imp_reverse" (line 1045 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 1045 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.valid_path_join" (line 839 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** At command "using" (line 839 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Paths.thy")
*** Undefined fact: "Cauchy_Integral_Theorem.C1_differentiable_on_mult" (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Derivs.thy")
*** At command "using" (line 489 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Derivs.thy")
*** Failed to finish proof (line 695 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>f integrable_on {a..y}; \<not> y < x;
***      a \<le> x \<and> x \<le> b \<and> x \<notin> s\<rbrakk>
***     \<Longrightarrow> integral {a..y} f =
***                       integral {a..x} f + integral {x..y} f
*** At command "by" (line 695 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Green/Integrals.thy")

==========
Gromov_Hyperbolicity
Loading theory "HOL-Cardinals.Fun_More" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
Loading theory "HOL-Cardinals.Order_Union" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions")
Loading theory "HOL-Cardinals.Order_Relation_More" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation" via "HOL-Cardinals.Wellfounded_More")
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "HOL-Library.Code_Target_Int" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
Loading theory "HOL-Library.Lattice_Algebras" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
Loading theory "HOL-Library.Log_Nat" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
### Code generator: dropping subsumed code equation
### 1 \<equiv> Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l \<equiv> ?l
### Code generator: dropping subsumed code equation
### ?k + 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m \<equiv> Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m \<equiv> Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l \<equiv> - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) \<equiv> Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) \<equiv> Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 \<equiv> 0
### theory "HOL-Library.Code_Abstract_Nat"
### 0.068s elapsed time, 0.508s cpu time, 0.059s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k * 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One \<equiv> - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One \<equiv> ?k
### Code generator: dropping subsumed code equation
### 0 div ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k div 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n \<equiv> - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n \<equiv>
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n \<equiv>
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n \<equiv> snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### 0 mod ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k \<equiv> True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Neg ?l \<equiv> ?l \<le> ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Pos ?l \<equiv> ?k \<le> ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l \<equiv> ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l \<equiv> ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 < 0 \<equiv> False
### theory "HOL-Cardinals.Fun_More"
### 0.085s elapsed time, 0.647s cpu time, 0.059s GC time
Loading theory "Ergodic_Theory.Fekete" (required by "Gromov_Hyperbolicity.Busemann_Function")
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### theory "HOL-Library.Log_Nat"
### 0.104s elapsed time, 0.809s cpu time, 0.059s GC time
### theory "HOL-Cardinals.Order_Union"
### 0.119s elapsed time, 0.916s cpu time, 0.059s GC time
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### if ?n = 0 \<or> ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### Suc ?m \<le> ?n \<equiv> ?m < ?n
### Code generator: dropping subsumed code equation
### 0 \<le> ?n \<equiv> True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n \<equiv> ?m \<le> ?n
### Code generator: dropping subsumed code equation
### ?n < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) \<equiv> numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 \<equiv> 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) \<equiv> - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) \<equiv> nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) \<equiv> 0
### theory "HOL-Library.Code_Target_Int"
### 0.169s elapsed time, 1.301s cpu time, 0.122s GC time
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
### Code generator: dropping subsumed code equation
### of_nat ?n \<equiv>
### semiring_1_class.of_nat_aux (\<lambda>i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.145s elapsed time, 1.147s cpu time, 0.063s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation")
### theory "HOL-Cardinals.Order_Relation_More"
### 0.249s elapsed time, 1.930s cpu time, 0.169s GC time
Loading theory "HOL-Cardinals.Wellfounded_More" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation")
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
### theory "HOL-Cardinals.Wellfounded_More"
### 0.027s elapsed time, 0.223s cpu time, 0.000s GC time
Loading theory "HOL-Cardinals.Wellorder_Relation" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
locale wo_rel
  fixes r :: "('a \<times> 'a) set"
  assumes "wo_rel r"
### theory "Ergodic_Theory.Fekete"
### 0.232s elapsed time, 1.819s cpu time, 0.111s GC time
### theory "HOL-Library.Code_Target_Numeral"
### 0.141s elapsed time, 1.087s cpu time, 0.097s GC time
### theory "HOL-Cardinals.Wellorder_Relation"
### 0.179s elapsed time, 1.395s cpu time, 0.090s GC time
Loading theory "HOL-Cardinals.Wellorder_Embedding" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions")
### theory "HOL-Cardinals.Wellorder_Embedding"
### 0.179s elapsed time, 1.400s cpu time, 0.062s GC time
Loading theory "HOL-Cardinals.Wellorder_Constructions" (required by "Gromov_Hyperbolicity.Library_Complements" via "HOL-Cardinals.Cardinal_Order_Relation")
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale wo_rel
  fixes r :: "('a \<times> 'a) set"
  assumes "wo_rel r"
### ML warning (line 19 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 18 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
locale linorder_stupid_syntax
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_stupid_syntax less_eq less"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "linordered_field_class.sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale linorder_no_ub
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
### theory "HOL-Cardinals.Wellorder_Constructions"
### 0.675s elapsed time, 5.213s cpu time, 0.297s GC time
Loading theory "HOL-Cardinals.Cardinal_Order_Relation" (required by "Gromov_Hyperbolicity.Library_Complements")
*** Undefined fact: "linordered_field_class.sign_simps" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
locale linorder_no_lb
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
locale constr_dense_linorder
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and between :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 81 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (xT) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.min (\<le>)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.max (\<le>)) ?xs ?x
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 2.222s elapsed time, 16.298s cpu time, 1.679s GC time
### theory "HOL-Cardinals.Cardinal_Order_Relation"
### 0.943s elapsed time, 6.402s cpu time, 1.061s GC time
Loading theory "Gromov_Hyperbolicity.Library_Complements"
### Ignoring duplicate rewrite rule:
### homeomorphism {} {} ?f1 ?g1 \<equiv> True
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "\<And>a. \<bar>a\<bar> = sup a (- a)"
### Ignoring duplicate rewrite rule:
### infdist ?x1 {?y1} \<equiv> dist ?x1 ?y1
### Ignoring duplicate rewrite rule:
### 1 / ?x1 = \<infinity> \<equiv> ?x1 = 0
### Ignoring duplicate rewrite rule:
### sup ?x1 (sup ?x1 ?y1) \<equiv> sup ?x1 ?y1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "Gromov_Hyperbolicity.Library_Complements"
### 1.779s elapsed time, 13.277s cpu time, 0.783s GC time
Loading theory "Gromov_Hyperbolicity.Eexp_Eln"
Loading theory "Gromov_Hyperbolicity.Hausdorff_Distance" (required by "Gromov_Hyperbolicity.Metric_Completion" via "Gromov_Hyperbolicity.Isometries")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Gromov_Hyperbolicity.Hausdorff_Distance"
### 0.128s elapsed time, 1.005s cpu time, 0.048s GC time
Loading theory "Gromov_Hyperbolicity.Isometries" (required by "Gromov_Hyperbolicity.Metric_Completion")
### theory "Gromov_Hyperbolicity.Eexp_Eln"
### 0.715s elapsed time, 5.296s cpu time, 1.502s GC time
### theory "HOL-Library.Lattice_Algebras"
### 5.172s elapsed time, 38.262s cpu time, 4.107s GC time
Loading theory "HOL-Library.Interval" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
Loading theory "HOL-Library.Float" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
class geodesic_space = metric_space +
  assumes "geodesic": "geodesic_subset UNIV"
### Ignoring duplicate rewrite rule:
### 0 \<le> hausdorff_distance ?A1 ?B1 \<equiv> True
### Metis: Unused theorems: "Set.UNIV_I"
### Metis: Unused theorems: "Set.UNIV_I"
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float \<Rightarrow> float
  abs_float == abs :: float \<Rightarrow> float
  uminus_float == uminus :: float \<Rightarrow> float
  one_float == one_class.one :: float
  times_float == times :: float \<Rightarrow> float \<Rightarrow> float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float \<Rightarrow> float \<Rightarrow> float
  less_eq_float == less_eq :: float \<Rightarrow> float \<Rightarrow> bool
  less_float == less :: float \<Rightarrow> float \<Rightarrow> bool
  plus_float == plus :: float \<Rightarrow> float \<Rightarrow> float
  equal_float == equal_class.equal ::
    float \<Rightarrow> float \<Rightarrow> bool
### Metis: Unused theorems: "Set.UNIV_I"
### Metis: Unused theorems: "Eexp_Eln.eln_simps_2", "Eexp_Eln.eln_simps_3"
### Metis: Unused theorems: "Eexp_Eln.eln_simps_1", "Eexp_Eln.eln_simps_3"
### Metis: Unused theorems: "Eexp_Eln.eln_simps_1", "Eexp_Eln.eln_simps_2"
### Metis: Unused theorems: "Eexp_Eln.eln_simps_1", "Eexp_Eln.eln_simps_2"
### Metis: Unused theorems: "Eexp_Eln.ennexp.simps_1", "Eexp_Eln.ennexp.simps_2", "Eexp_Eln.ennexp_0"
### Metis: Unused theorems: "Eexp_Eln.ennexp.simps_1", "Eexp_Eln.ennexp.simps_2", "Eexp_Eln.ennexp.simps_3"
### Metis: Falling back on "metis (full_types)"...
### Metis: Falling back on "metis (mono_tags)"...
### Metis: Unused theorems: "Set.UNIV_I"
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float \<Rightarrow> float \<Rightarrow> float
  sup_float == sup :: float \<Rightarrow> float \<Rightarrow> float
class uniquely_geodesic_space = geodesic_space +
  assumes
    "uniquely_geodesic":
      "\<And>x y G H.
          \<lbrakk>geodesic_segment_between G x y;
           geodesic_segment_between H x y\<rbrakk>
          \<Longrightarrow> G = H"
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
class uniquely_geodesic_space = geodesic_space +
  assumes
    "uniquely_geodesic":
      "\<And>x y G H.
          \<lbrakk>geodesic_segment_between G x y;
           geodesic_segment_between H x y\<rbrakk>
          \<Longrightarrow> G = H"
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
  less_interval == less ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
locale complete_space_with_middle
  fixes x0 :: "'a"
    and y0 :: "'a"
  assumes "complete_space_with_middle TYPE('a)"
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> (float \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval \<Rightarrow> 'a interval
### Metis: Unused theorems: "Eexp_Eln.eexp_lt_eexp_iff_lt", "Eexp_Eln.eexp_special_values_2", "Eexp_Eln.eexp_special_values_3"
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
### Metis: Unused theorems: "Eexp_Eln.eexp_lt_eexp_iff_lt", "Eexp_Eln.eexp_special_values_2", "Eexp_Eln.eexp_special_values_3"
### Metis: Unused theorems: "Eexp_Eln.eexp_le_eexp_iff_le", "Eexp_Eln.eexp_special_values_2", "Eexp_Eln.eexp_special_values_3"
instantiation
  interval :: (linordered_semiring) times
  times_interval == times ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
### Metis: Unused theorems: "Eexp_Eln.eexp_le_eexp_iff_le", "Eexp_Eln.eexp_special_values_2", "Eexp_Eln.eexp_special_values_3"
### Metis: Falling back on "metis (full_types)"...
### Metis: Falling back on "metis (mono_tags)"...
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
### theory "Gromov_Hyperbolicity.Isometries"
### 2.221s elapsed time, 16.855s cpu time, 2.080s GC time
Loading theory "Gromov_Hyperbolicity.Metric_Completion"
instantiation
  metric_completion :: (metric_space) metric_space
  dist_metric_completion == dist ::
    'a metric_completion
    \<Rightarrow> 'a metric_completion \<Rightarrow> real
  uniformity_metric_completion == uniformity ::
    ('a metric_completion \<times> 'a metric_completion) filter
  open_metric_completion == open ::
    'a metric_completion set \<Rightarrow> bool
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### theory "Gromov_Hyperbolicity.Metric_Completion"
### 0.224s elapsed time, 1.737s cpu time, 0.080s GC time
Loading theory "Gromov_Hyperbolicity.Gromov_Hyperbolicity"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Library.Float"
### 2.287s elapsed time, 17.428s cpu time, 2.723s GC time
class metric_space_with_deltaG = metric_space +
  fixes deltaG :: "'a itself \<Rightarrow> real"
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set \<Rightarrow> bool
class Gromov_hyperbolic_space = metric_space_with_deltaG +
  assumes
    "hyperb_quad_ineq0": "Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV"
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a interval \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### theory "HOL-Library.Interval"
### 2.771s elapsed time, 21.262s cpu time, 2.887s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
instantiation
  metric_completion :: (Gromov_hyperbolic_space) Gromov_hyperbolic_space
  deltaG_metric_completion == deltaG ::
    'a metric_completion itself \<Rightarrow> real
class Gromov_hyperbolic_space = metric_space_with_deltaG +
  assumes
    "hyperb_quad_ineq0": "Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
class metric_tree = geodesic_space +
  assumes
    "geod_union":
      "\<And>G x y H z.
          \<lbrakk>geodesic_segment_between G x y;
           geodesic_segment_between H y z; G \<inter> H = {y}\<rbrakk>
          \<Longrightarrow> geodesic_segment_between (G \<union> H) x z"
class metric_tree = geodesic_space +
  assumes
    "geod_union":
      "\<And>G x y H z.
          \<lbrakk>geodesic_segment_between G x y;
           geodesic_segment_between H y z; G \<inter> H = {y}\<rbrakk>
          \<Longrightarrow> geodesic_segment_between (G \<union> H) x z"
Found termination order: "length <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "HOL-Library.Interval_Float"
### 1.061s elapsed time, 5.889s cpu time, 0.227s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem" via "HOL-Decision_Procs.Approximation")
*** Undefined fact: "linordered_field_class.sign_simps" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** At command "by" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
class metric_tree_with_delta = metric_space_with_deltaG + metric_tree +
  assumes "delta0": "deltaG TYPE('a) = 0"
consts
  horner ::
    "(nat \<Rightarrow> nat)
     \<Rightarrow> (nat \<Rightarrow> nat \<Rightarrow> nat)
                   \<Rightarrow> nat
                                 \<Rightarrow> nat
         \<Rightarrow> nat \<Rightarrow> real \<Rightarrow> real"
class Gromov_hyperbolic_space_0 = Gromov_hyperbolic_space +
  assumes "delta0": "deltaG TYPE('a) = 0"
instantiation
  real :: metric_tree_with_delta
  deltaG_real == deltaG :: real itself \<Rightarrow> real
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
### theory "Gromov_Hyperbolicity.Gromov_Hyperbolicity"
### 3.107s elapsed time, 17.648s cpu time, 2.653s GC time
Loading theory "Gromov_Hyperbolicity.Gromov_Boundary"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
locale Turn_into_distance
  fixes f :: "'a \<Rightarrow> 'a \<Rightarrow> real"
  assumes "Turn_into_distance f"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
instantiation
  Gromov_completion :: (Gromov_hyperbolic_space) metric_space
  dist_Gromov_completion == dist ::
    'a Gromov_completion
    \<Rightarrow> 'a Gromov_completion \<Rightarrow> real
  uniformity_Gromov_completion == uniformity ::
    ('a Gromov_completion \<times> 'a Gromov_completion) filter
  open_Gromov_completion == open ::
    'a Gromov_completion set \<Rightarrow> bool
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### ?i1 \<in> {?l1..?u1} \<equiv> ?l1 \<le> ?i1 \<and> ?i1 \<le> ?u1
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### theory "Gromov_Hyperbolicity.Gromov_Boundary"
### 1.614s elapsed time, 11.201s cpu time, 2.454s GC time
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 \<equiv> ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<equiv> ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 - ?c1 \<equiv> ?a1 - (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + (?b1 - ?c1) \<equiv> ?a1 + ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 = ?c1 \<equiv> ?a1 = ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 = ?c1 - ?b1 \<equiv> ?a1 + ?b1 = ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - (?b1 - ?c1) \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 + ?c1 \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 < ?c1 \<equiv> ?a1 < ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 < ?c1 - ?b1 \<equiv> ?a1 + ?b1 < ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 \<le> ?c1 \<equiv> ?a1 \<le> ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 \<le> ?c1 - ?b1 \<equiv> ?a1 + ?b1 \<le> ?c1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Metis: Unused theorems: "Lattices.linorder_class.min.left_commute"
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### \<Prod>x\<in>?A1. ?y1 \<equiv> ?y1 ^ card ?A1
*** Undefined fact: "linordered_field_class.sign_simps" (line 1819 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** At command "by" (line 1819 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "linordered_field_class.sign_simps" (line 73 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
*** At command "by" (line 73 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 4.564s elapsed time, 26.738s cpu time, 3.069s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Gromov_Hyperbolicity.Morse_Gromov_Theorem")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rewrite rule not in simpset:
### power_down ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1
### then truncate_down (Suc ?p1) ((power_down ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_down (Suc ?p1) (?x1 * power_down ?p1 ?x1 ?n1)
### Ignoring duplicate rewrite rule:
### power_up ?p1 ?x1 0 \<equiv> 1
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Rewrite rule not in simpset:
### power_up ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1 then truncate_up ?p1 ((power_up ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_up ?p1 (?x1 * power_up ?p1 ?x1 ?n1)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### Gromov_product_at ?e1 ?x1 ?x1 \<equiv> dist ?e1 ?x1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. 0) (\<lambda>x. Suc 0) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<le> 0 \<equiv>
### 0 \<le> ?a1 \<and> ?b1 \<le> 0 \<or> ?a1 \<le> 0 \<and> 0 \<le> ?b1
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<le> 0 \<equiv>
### 0 \<le> ?a1 \<and> ?b1 \<le> 0 \<or> ?a1 \<le> 0 \<and> 0 \<le> ?b1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<le> 0 \<equiv>
### 0 \<le> ?a1 \<and> ?b1 \<le> 0 \<or> ?a1 \<le> 0 \<and> 0 \<le> ?b1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### ?x1 - ?y1 \<le> ?z1 \<equiv>
### (?y1 = - \<infinity> \<longrightarrow> ?z1 = \<infinity>) \<and>
### (?y1 = \<infinity> \<longrightarrow>
###  ?x1 = \<infinity> \<longrightarrow> ?z1 = \<infinity>) \<and>
### (\<bar>?y1\<bar> \<noteq> \<infinity> \<longrightarrow> ?x1 \<le> ?z1 + ?y1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<le> 0 \<equiv>
### 0 \<le> ?a1 \<and> ?b1 \<le> 0 \<or> ?a1 \<le> 0 \<and> 0 \<le> ?b1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<le> 0 \<equiv>
### 0 \<le> ?a1 \<and> ?b1 \<le> 0 \<or> ?a1 \<le> 0 \<and> 0 \<le> ?b1
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### closure (range to_Gromov_completion) \<equiv> UNIV
### Ignoring duplicate rewrite rule:
### 0 \<le> ?t1 \<Longrightarrow> esqrt (ereal ?t1) \<equiv> ereal (sqrt ?t1)
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln ?x1 \<le> ln ?y1 \<equiv> ?x1 \<le> ?y1
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. Suc 0) (\<lambda>x. 0) <*mlex*>
   case_sum (\<lambda>p. size (fst (snd (snd p))))
    (\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 204 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 44.335s elapsed time, 179.725s cpu time, 19.664s GC time
Loading theory "Gromov_Hyperbolicity.Morse_Gromov_Theorem"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "Gromov_Hyperbolicity.Morse_Gromov_Theorem"
### 2.568s elapsed time, 7.889s cpu time, 0.402s GC time
Loading theory "Gromov_Hyperbolicity.Bonk_Schramm_Extension"
Loading theory "Gromov_Hyperbolicity.Boundary_Extension"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Failed to finish proof (line 821 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>real n \<le> log 2 (lambda * (b - a) / (10 * delta));
***      0 < lambda * (b - a); 0 < delta\<rbrakk>
***     \<Longrightarrow> 2 ^ n \<le> lambda * (b - a) / (10 * delta)
*** At command "by" (line 821 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy")
### theory "Gromov_Hyperbolicity.Boundary_Extension"
### 0.891s elapsed time, 6.113s cpu time, 0.275s GC time
Loading theory "Gromov_Hyperbolicity.Busemann_Function"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "Gromov_Hyperbolicity.Busemann_Function"
### 0.878s elapsed time, 5.420s cpu time, 0.171s GC time
Loading theory "Gromov_Hyperbolicity.Isometries_Classification"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
class metric_space = uniformity_dist + first_countable_topology + t4_space +
  uniform_space +
  assumes "dist_eq_0_iff": "\<And>x y. (dist x y = 0) = (x = y)"
    and "dist_triangle2": "\<And>x y z. dist x y \<le> dist x z + dist y z"
### theory "Gromov_Hyperbolicity.Isometries_Classification"
### 0.762s elapsed time, 4.281s cpu time, 0.249s GC time
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
consts
  map_aux ::
    "'a Bonk_Schramm_extension_unfolded
     \<Rightarrow> nat + 'a Bonk_Schramm_extension_unfolded set"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### topological_space.closed open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>topological_space.closed open ?S;
###  topological_space.closed open ?T\<rbrakk>
### \<Longrightarrow> topological_space.closed open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### topological_space.closed open UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>topological_space.closed open ?S;
###  topological_space.closed open ?T\<rbrakk>
### \<Longrightarrow> topological_space.closed open (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. topological_space.closed open (?B x) \<Longrightarrow>
### topological_space.closed open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. topological_space.closed open S \<Longrightarrow>
### topological_space.closed open (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S;
###  \<forall>T\<in>?S. topological_space.closed open T\<rbrakk>
### \<Longrightarrow> topological_space.closed open (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A;
###  \<forall>x\<in>?A. topological_space.closed open (?B x)\<rbrakk>
### \<Longrightarrow> topological_space.closed open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; topological_space.closed open ?T\<rbrakk>
### \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>topological_space.closed open ?S; open ?T\<rbrakk>
### \<Longrightarrow> topological_space.closed open (?S - ?T)
### Ignoring duplicate introduction (intro)
### topological_space.closed open ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> topological_space.closed open (- ?S)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### No map function defined for Bonk_Schramm_Extension.Bonk_Schramm_extension_unfolded. This will cause problems later on.
instantiation
  Bonk_Schramm_extension :: (metric_space) metric_space
  dist_Bonk_Schramm_extension == dist ::
    'a Bonk_Schramm_extension
    \<Rightarrow> 'a Bonk_Schramm_extension \<Rightarrow> real
  uniformity_Bonk_Schramm_extension == uniformity ::
    ('a Bonk_Schramm_extension \<times> 'a Bonk_Schramm_extension) filter
  open_Bonk_Schramm_extension == open ::
    'a Bonk_Schramm_extension set \<Rightarrow> bool
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
instantiation
  Bonk_Schramm_extension :: (Gromov_hyperbolic_space)
    Gromov_hyperbolic_space_geodesic
  deltaG_Bonk_Schramm_extension == deltaG ::
    'a Bonk_Schramm_extension itself \<Rightarrow> real
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "Gromov_Hyperbolicity.Bonk_Schramm_Extension"
### 4.716s elapsed time, 24.260s cpu time, 1.050s GC time
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Failed to apply proof method (line 409 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy"):
*** using this:
***   (\<lambda>n. from_Gromov_completion (Gromov_extension f (u n)))
***   \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** goal (1 subgoal):
***  1. (\<lambda>n. f (from_Gromov_completion (u n)))
***     \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** At command "apply" (line 409 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Rule already declared as safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Failed to apply proof method (line 627 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy"):
*** using this:
***   (\<lambda>n. from_Gromov_completion (Gromov_extension f (u n)))
***   \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** goal (1 subgoal):
***  1. (\<lambda>n. f (from_Gromov_completion (u n)))
***     \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** At command "apply" (line 627 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy")
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x < ?y \<Longrightarrow> exp ?x < exp ?y
### Ignoring duplicate safe introduction (intro!)
### ?x \<le> ?y \<Longrightarrow> exp ?x \<le> exp ?y
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    additive_strength f xi - 2 * deltaG TYPE('a) * (1 / real n) =
***    (real n * additive_strength f xi - 2 * deltaG TYPE('a)) / real n
*** (\<lambda>x. additive_strength f xi - 2 * deltaG TYPE('a) * (1 / real x))
*** \<longlonglongrightarrow> additive_strength f xi - 2 * deltaG TYPE('a) * 0
*** At command "using" (line 394 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "linordered_field_class.sign_simps" (line 1059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
*** At command "by" (line 1059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ignoring duplicate rewrite rule:
### deltaG TYPE(?'a1) \<equiv> 0
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### LIM x topological_space.at_within open ?a ?s.
###    x :> topological_space.nhds open ?a
### Rule already declared as introduction (intro)
### LIM x ?F. ?k :> topological_space.nhds open ?k
*** Undefined fact: "linordered_field_class.sign_simps" (line 1059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
*** At command "by" (line 1059 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    additive_strength f xi - 2 * deltaG TYPE('a) * (1 / real n) =
***    (real n * additive_strength f xi - 2 * deltaG TYPE('a)) / real n
*** (\<lambda>x. additive_strength f xi - 2 * deltaG TYPE('a) * (1 / real x))
*** \<longlonglongrightarrow> additive_strength f xi - 2 * deltaG TYPE('a) * 0
*** At command "using" (line 394 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy")
*** Failed to apply proof method (line 627 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy"):
*** using this:
***   (\<lambda>n. from_Gromov_completion (Gromov_extension f (u n)))
***   \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** goal (1 subgoal):
***  1. (\<lambda>n. f (from_Gromov_completion (u n)))
***     \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** At command "apply" (line 627 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy")
*** Failed to apply proof method (line 409 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy"):
*** using this:
***   (\<lambda>n. from_Gromov_completion (Gromov_extension f (u n)))
***   \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** goal (1 subgoal):
***  1. (\<lambda>n. f (from_Gromov_completion (u n)))
***     \<longlonglongrightarrow> from_Gromov_completion (Gromov_extension f x)
*** At command "apply" (line 409 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy")
*** Failed to finish proof (line 821 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>real n \<le> log 2 (lambda * (b - a) / (10 * delta));
***      0 < lambda * (b - a); 0 < delta\<rbrakk>
***     \<Longrightarrow> 2 ^ n \<le> lambda * (b - a) / (10 * delta)
*** At command "by" (line 821 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 73 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
*** At command "by" (line 73 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Metric_Completion.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 1819 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** At command "by" (line 1819 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** At command "by" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 424 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")
*** At command "by" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy")

==========
Group-Ring-Module
Loading theory "Group-Ring-Module.Algebra1" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7" via "Group-Ring-Module.Algebra6" via "Group-Ring-Module.Algebra5" via "Group-Ring-Module.Algebra4" via "Group-Ring-Module.Algebra3" via "Group-Ring-Module.Algebra2")
consts
  nasc_seq ::
    "nat set \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat"
consts
  ndec_seq ::
    "nat set \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat"
consts
  dec_seq :: "int set \<Rightarrow> int \<Rightarrow> nat \<Rightarrow> int"
instantiation
  ant :: {minus,one,plus,times,uminus,zero,ord}
  less_eq_ant == less_eq :: ant \<Rightarrow> ant \<Rightarrow> bool
  less_ant == less :: ant \<Rightarrow> ant \<Rightarrow> bool
  zero_ant == zero_class.zero :: ant
  uminus_ant == uminus :: ant \<Rightarrow> ant
  times_ant == times :: ant \<Rightarrow> ant \<Rightarrow> ant
  plus_ant == plus :: ant \<Rightarrow> ant \<Rightarrow> ant
  one_ant == one_class.one :: ant
  minus_ant == minus :: ant \<Rightarrow> ant \<Rightarrow> ant
consts
  Amin :: "nat \<Rightarrow> (nat \<Rightarrow> ant) \<Rightarrow> ant"
consts
  Amax :: "nat \<Rightarrow> (nat \<Rightarrow> ant) \<Rightarrow> ant"
consts
  aasc_seq ::
    "ant set \<Rightarrow> ant \<Rightarrow> nat \<Rightarrow> ant"
consts
  ASum :: "(nat \<Rightarrow> ant) \<Rightarrow> nat \<Rightarrow> ant"
consts
  Zmax :: "nat \<Rightarrow> (nat \<Rightarrow> int) \<Rightarrow> int"
### Metis: Unused theorems: "Algebra1.diff_ant_def"
### Metis: Unused theorems: "Algebra1.diff_ant_def"
locale Order
  fixes D :: "('a, 'b) Order_scheme"  (structure)
  assumes "Order D"
locale Torder
  fixes D :: "('a, 'b) Order_scheme"  (structure)
  assumes "Torder D"
locale Worder
  fixes D :: "('a, 'b) Order_scheme"  (structure)
  assumes "Worder D"
### theory "Group-Ring-Module.Algebra1"
### 5.500s elapsed time, 25.514s cpu time, 2.451s GC time
Loading theory "Group-Ring-Module.Algebra2" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7" via "Group-Ring-Module.Algebra6" via "Group-Ring-Module.Algebra5" via "Group-Ring-Module.Algebra4" via "Group-Ring-Module.Algebra3")
### Rewrite rule not in simpset:
### \<lbrakk>?A1 \<subseteq> ?B1; ?a1 \<in> ?B1\<rbrakk>
### \<Longrightarrow> insert ?a1 ?A1 \<subseteq> ?B1 \<equiv> True
### Metis: Unused theorems: "??.unknown"
locale Group
  fixes G :: "('a, 'b) Group_scheme"  (structure)
  assumes "Group G"
### theory "Group-Ring-Module.Algebra2"
### 4.121s elapsed time, 18.905s cpu time, 0.960s GC time
Loading theory "Group-Ring-Module.Algebra3" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7" via "Group-Ring-Module.Algebra6" via "Group-Ring-Module.Algebra5" via "Group-Ring-Module.Algebra4")
*** Undefined fact: "linorder_antisym_conv2" (line 2403 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra3.thy")
*** At command "apply" (line 2403 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra3.thy")
### theory "Group-Ring-Module.Algebra3"
### 4.177s elapsed time, 26.211s cpu time, 1.457s GC time
Loading theory "Group-Ring-Module.Algebra4" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7" via "Group-Ring-Module.Algebra6" via "Group-Ring-Module.Algebra5")
locale aGroup
  fixes A :: "('a, 'b) aGroup_scheme"  (structure)
  assumes "aGroup A"
locale Ring
  fixes R :: "('a, 'b) Ring_scheme"  (structure)
  assumes "Ring R"
consts
  nscal ::
    "('a, 'more) Ring_scheme
     \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a"
consts
  npow ::
    "('a, 'more) Ring_scheme
     \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a"
consts
  nprod ::
    "('a, 'more) Ring_scheme
     \<Rightarrow> (nat \<Rightarrow> 'a)
                   \<Rightarrow> nat \<Rightarrow> 'a"
consts
  nsum ::
    "('a, 'more) aGroup_scheme
     \<Rightarrow> (nat \<Rightarrow> 'a)
                   \<Rightarrow> nat \<Rightarrow> 'a"
\<lbrakk>?i \<le> ?n; ?j \<le> ?n; ?i \<noteq> ?j\<rbrakk>
\<Longrightarrow> inj_on (transpos ?i ?j) {i. i \<le> ?n}
consts
  sum_pr_ideals ::
    "('a, 'm) Ring_scheme
     \<Rightarrow> (nat \<Rightarrow> 'a)
                   \<Rightarrow> nat \<Rightarrow> 'a set"
consts
  ideal_n_prod ::
    "('a, 'm) Ring_scheme
     \<Rightarrow> nat
                   \<Rightarrow> (nat \<Rightarrow> 'a set)
                                 \<Rightarrow> 'a set"
consts
  ideal_pow ::
    "'a set
     \<Rightarrow> ('a, 'more) Ring_scheme
                   \<Rightarrow> nat \<Rightarrow> 'a set"
### Rewrite rule not in simpset:
### (\<And>x. x \<in> ?A1 \<Longrightarrow> ?f1 x \<in> ?B1 x) \<Longrightarrow>
### ?f1 \<in> Pi ?A1 ?B1 \<equiv> True
locale Idomain
  fixes R :: "('a, 'b) Ring_scheme"  (structure)
  assumes "Idomain R"
locale Corps
  fixes K :: "('a, 'b) Ring_scheme"  (structure)
  assumes "Corps K"
### Ignoring duplicate rewrite rule:
### aI\<^bsub>?A1\<^esub> \<equiv> \<lambda>x\<in>carrier ?A1. x
### theory "Group-Ring-Module.Algebra4"
### 6.929s elapsed time, 48.238s cpu time, 8.634s GC time
Loading theory "Group-Ring-Module.Algebra5" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7" via "Group-Ring-Module.Algebra6")
consts
  ac_fProd_Rg ::
    "nat
     \<Rightarrow> (nat \<Rightarrow> ('a, 'more) Ring_scheme)
                   \<Rightarrow> (nat \<Rightarrow> 'a) set"
locale TwoRings
  fixes R :: "('a, 'b) Ring_scheme"  (structure)
    and R' :: "('c, 'd) Ring_scheme"  (structure)
  assumes "TwoRings R R'"
locale PolynRg
  fixes R :: "('a, 'b) Ring_scheme"  (structure)
    and S :: "('a, 'c) Ring_scheme"  (structure)
    and X :: "'a"  (structure)
  assumes "PolynRg R S X"
### theory "Group-Ring-Module.Algebra5"
### 3.107s elapsed time, 24.409s cpu time, 1.433s GC time
Loading theory "Group-Ring-Module.Algebra6" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8" via "Group-Ring-Module.Algebra7")
### Ambiguous input (line 4680 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra6.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>Hensel_next" ("_position" R) ("_position" S) ("_position" X)
###       ("_position" t) ("_position" R') ("_position" Y) ("_position" f)
###       ("_position" m) ("_position" gh))
###     ("_Eps" ("_position" gh1)
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" gh1)
###           ("\<^const>Product_Type.Times"
###             ("_applC" ("_position" carrier) ("_position" R))
###             ("_applC" ("_position" carrier) ("_position" R))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Orderings.ord_class.less_eq"
###             ("_applC" ("_position" deg)
###               ("_cargs" ("_position" R)
###                 ("_cargs" ("_position" S)
###                   ("_cargs" ("_position" X)
###                     ("_applC" ("_position" fst) ("_position" gh1))))))
###             ("_applC" ("_position" deg)
###               ("_cargs" ("_position" R')
###                 ("_cargs"
###                   ("\<^const>Algebra4.QRING" ("_position" S)
###                     ("\<^const>Algebra4.Rxa" ("_position" S)
###                       ("_position" t)))
###                   ("_cargs" ("_position" Y)
###                     ("_applC" ("_position" erH)
###                       ("_cargs" ("_position" R)
###                         ("_cargs" ("_position" S)
###                           ("_cargs" ("_position" X)
###                             ("_cargs" ("_position" R')
###                               ("_cargs"
###                                 ("\<^const>Algebra4.QRING" ("_position" S)
###                                   ("\<^const>Algebra4.Rxa" ("_position" S)
###                                     ("_position" t)))
###                                 ("_cargs" ("_position" Y)
###                                   ("_cargs"
###                                     ("_applC" ("_position" pj)
### ("_cargs" ("_position" S)
###   ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t))))
###                                     ("_applC" ("_position" fst)
### ("_position" gh1)))))))))))))))
###           ("\<^const>HOL.conj"
###             ("_applC" ("_position" P_mod)
###               ("_cargs" ("_position" R)
###                 ("_cargs" ("_position" S)
###                   ("_cargs" ("_position" X)
###                     ("_cargs"
###                       ("\<^const>Algebra4.Rxa" ("_position" S)
###                         ("\<^const>Algebra4.NPOW" ("_position" t)
###                           ("_position" S) ("_position" m)))
###                       ("\<^const>Algebra4.aGroup.pop_indexed"
###                         ("_applC" ("_position" fst) ("_position" gh))
###                         ("_index" ("_position" R))
###                         ("\<^const>Algebra4.aGroup.mop_indexed"
###                           ("_index" ("_position" R))
###                           ("_applC" ("_position" fst)
###                             ("_position" gh1)))))))))
###             ("\<^const>HOL.conj"
###               ("\<^const>Orderings.ord_class.less_eq"
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" deg)
###                     ("_cargs" ("_position" R)
###                       ("_cargs" ("_position" S)
###                         ("_cargs" ("_position" X)
###                           ("_applC" ("_position" snd) ("_position" gh1))))))
###                   ("_applC" ("_position" deg)
###                     ("_cargs" ("_position" R')
###                       ("_cargs"
###                         ("\<^const>Algebra4.QRING" ("_position" S)
###                           ("\<^const>Algebra4.Rxa" ("_position" S)
###                             ("_position" t)))
###                         ("_cargs" ("_position" Y)
###                           ("_applC" ("_position" erH)
###                             ("_cargs" ("_position" R)
###                               ("_cargs" ("_position" S)
###                                 ("_cargs" ("_position" X)
###                                   ("_cargs" ("_position" R')
###                                     ("_cargs"
### ("\<^const>Algebra4.QRING" ("_position" S)
###   ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t)))
### ("_cargs" ("_position" Y)
###   ("_cargs"
###     ("_applC" ("_position" pj)
###       ("_cargs" ("_position" S)
###         ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t))))
###     ("_applC" ("_position" fst) ("_position" gh1)))))))))))))))
###                 ("_applC" ("_position" deg)
###                   ("_cargs" ("_position" R)
###                     ("_cargs" ("_position" S)
###                       ("_cargs" ("_position" X) ("_position" f))))))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" P_mod)
###                   ("_cargs" ("_position" R)
###                     ("_cargs" ("_position" S)
###                       ("_cargs" ("_position" X)
###                         ("_cargs"
###                           ("\<^const>Algebra4.Rxa" ("_position" S)
###                             ("\<^const>Algebra4.NPOW" ("_position" t)
###                               ("_position" S) ("_position" m)))
###                           ("\<^const>Algebra4.aGroup.pop_indexed"
###                             ("_applC" ("_position" snd) ("_position" gh))
###                             ("_index" ("_position" R))
###                             ("\<^const>Algebra4.aGroup.mop_indexed"
###                               ("_index" ("_position" R))
###                               ("_applC" ("_position" snd)
###                                 ("_position" gh1)))))))))
###                 ("_applC" ("_position" P_mod)
###                   ("_cargs" ("_position" R)
###                     ("_cargs" ("_position" S)
###                       ("_cargs" ("_position" X)
###                         ("_cargs"
###                           ("\<^const>Algebra4.Rxa" ("_position" S)
###                             ("\<^const>Algebra4.NPOW" ("_position" t)
###                               ("_position" S)
###                               ("_applC" ("_position" Suc) ("_position" m))))
###                           ("\<^const>Algebra4.aGroup.pop_indexed"
###                             ("_position" f) ("_index" ("_position" R))
###                             ("\<^const>Algebra4.aGroup.mop_indexed"
###                               ("_index" ("_position" R))
###                               ("\<^const>Algebra4.Ring.tp_indexed"
###                                 ("_applC" ("_position" fst)
###                                   ("_position" gh1))
###                                 ("_index" ("_position" R))
###                                 ("_applC" ("_position" snd)
###                                   ("_position" gh1))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>Hensel_next" ("_position" R) ("_position" S) ("_position" X)
###     ("_position" t) ("_position" R') ("_position" Y) ("_position" f)
###     ("_position" m)
###     ("\<^const>HOL.eq" ("_position" gh)
###       ("_Eps" ("_position" gh1)
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" gh1)
###             ("\<^const>Product_Type.Times"
###               ("_applC" ("_position" carrier) ("_position" R))
###               ("_applC" ("_position" carrier) ("_position" R))))
###           ("\<^const>HOL.conj"
###             ("\<^const>Orderings.ord_class.less_eq"
###               ("_applC" ("_position" deg)
###                 ("_cargs" ("_position" R)
###                   ("_cargs" ("_position" S)
###                     ("_cargs" ("_position" X)
###                       ("_applC" ("_position" fst) ("_position" gh1))))))
###               ("_applC" ("_position" deg)
###                 ("_cargs" ("_position" R')
###                   ("_cargs"
###                     ("\<^const>Algebra4.QRING" ("_position" S)
###                       ("\<^const>Algebra4.Rxa" ("_position" S)
###                         ("_position" t)))
###                     ("_cargs" ("_position" Y)
###                       ("_applC" ("_position" erH)
###                         ("_cargs" ("_position" R)
###                           ("_cargs" ("_position" S)
###                             ("_cargs" ("_position" X)
###                               ("_cargs" ("_position" R')
###                                 ("_cargs"
###                                   ("\<^const>Algebra4.QRING" ("_position" S)
###                                     ("\<^const>Algebra4.Rxa" ("_position" S)
### ("_position" t)))
###                                   ("_cargs" ("_position" Y)
###                                     ("_cargs"
### ("_applC" ("_position" pj)
###   ("_cargs" ("_position" S)
###     ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t))))
### ("_applC" ("_position" fst) ("_position" gh1)))))))))))))))
###             ("\<^const>HOL.conj"
###               ("_applC" ("_position" P_mod)
###                 ("_cargs" ("_position" R)
###                   ("_cargs" ("_position" S)
###                     ("_cargs" ("_position" X)
###                       ("_cargs"
###                         ("\<^const>Algebra4.Rxa" ("_position" S)
###                           ("\<^const>Algebra4.NPOW" ("_position" t)
###                             ("_position" S) ("_position" m)))
###                         ("\<^const>Algebra4.aGroup.pop_indexed"
###                           ("_applC" ("_position" fst) ("_position" gh))
###                           ("_index" ("_position" R))
###                           ("\<^const>Algebra4.aGroup.mop_indexed"
###                             ("_index" ("_position" R))
###                             ("_applC" ("_position" fst)
###                               ("_position" gh1)))))))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Orderings.ord_class.less_eq"
###                   ("\<^const>Groups.plus_class.plus"
###                     ("_applC" ("_position" deg)
###                       ("_cargs" ("_position" R)
###                         ("_cargs" ("_position" S)
###                           ("_cargs" ("_position" X)
###                             ("_applC" ("_position" snd)
###                               ("_position" gh1))))))
###                     ("_applC" ("_position" deg)
###                       ("_cargs" ("_position" R')
###                         ("_cargs"
###                           ("\<^const>Algebra4.QRING" ("_position" S)
###                             ("\<^const>Algebra4.Rxa" ("_position" S)
###                               ("_position" t)))
###                           ("_cargs" ("_position" Y)
###                             ("_applC" ("_position" erH)
###                               ("_cargs" ("_position" R)
###                                 ("_cargs" ("_position" S)
###                                   ("_cargs" ("_position" X)
###                                     ("_cargs" ("_position" R')
### ("_cargs"
###   ("\<^const>Algebra4.QRING" ("_position" S)
###     ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t)))
###   ("_cargs" ("_position" Y)
###     ("_cargs"
###       ("_applC" ("_position" pj)
###         ("_cargs" ("_position" S)
###           ("\<^const>Algebra4.Rxa" ("_position" S) ("_position" t))))
###       ("_applC" ("_position" fst) ("_position" gh1)))))))))))))))
###                   ("_applC" ("_position" deg)
###                     ("_cargs" ("_position" R)
###                       ("_cargs" ("_position" S)
###                         ("_cargs" ("_position" X) ("_position" f))))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" P_mod)
###                     ("_cargs" ("_position" R)
###                       ("_cargs" ("_position" S)
###                         ("_cargs" ("_position" X)
###                           ("_cargs"
###                             ("\<^const>Algebra4.Rxa" ("_position" S)
###                               ("\<^const>Algebra4.NPOW" ("_position" t)
###                                 ("_position" S) ("_position" m)))
###                             ("\<^const>Algebra4.aGroup.pop_indexed"
###                               ("_applC" ("_position" snd) ("_position" gh))
###                               ("_index" ("_position" R))
###                               ("\<^const>Algebra4.aGroup.mop_indexed"
###                                 ("_index" ("_position" R))
###                                 ("_applC" ("_position" snd)
###                                   ("_position" gh1)))))))))
###                   ("_applC" ("_position" P_mod)
###                     ("_cargs" ("_position" R)
###                       ("_cargs" ("_position" S)
###                         ("_cargs" ("_position" X)
###                           ("_cargs"
###                             ("\<^const>Algebra4.Rxa" ("_position" S)
###                               ("\<^const>Algebra4.NPOW" ("_position" t)
###                                 ("_position" S)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" m))))
###                             ("\<^const>Algebra4.aGroup.pop_indexed"
###                               ("_position" f) ("_index" ("_position" R))
###                               ("\<^const>Algebra4.aGroup.mop_indexed"
###                                 ("_index" ("_position" R))
###                                 ("\<^const>Algebra4.Ring.tp_indexed"
###                                   ("_applC" ("_position" fst)
###                                     ("_position" gh1))
###                                   ("_index" ("_position" R))
###                                   ("_applC" ("_position" snd)
###                                     ("_position" gh1)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  Hensel_pair ::
    "('a, 'b) Ring_scheme
     \<Rightarrow> ('a, 'c) Ring_scheme
                   \<Rightarrow> 'a \<Rightarrow> 'a
            \<Rightarrow> ('a set, 'm) Ring_scheme
                          \<Rightarrow> 'a set
  \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a
            \<Rightarrow> nat \<Rightarrow> 'a \<times> 'a"
### theory "Group-Ring-Module.Algebra6"
### 4.817s elapsed time, 30.268s cpu time, 6.982s GC time
Loading theory "Group-Ring-Module.Algebra7" (required by "Group-Ring-Module.Algebra9" via "Group-Ring-Module.Algebra8")
locale Module
  fixes M :: "('a, 'b, 'c) Module_scheme"  (structure)
    and R :: "('b, 'd) Ring_scheme"  (structure)
  assumes "Module M R"
consts
  natm ::
    "('a, 'm) aGroup_scheme
     \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a"
### Ignoring duplicate rewrite rule:
### ant ?z1 = - \<infinity> \<equiv> False
### theory "Group-Ring-Module.Algebra7"
### 3.756s elapsed time, 26.129s cpu time, 1.534s GC time
Loading theory "Group-Ring-Module.Algebra8" (required by "Group-Ring-Module.Algebra9")
### theory "Group-Ring-Module.Algebra8"
### 0.926s elapsed time, 5.992s cpu time, 0.570s GC time
Loading theory "Group-Ring-Module.Algebra9"
consts
  add_set ::
    "('a \<Rightarrow> 'a \<Rightarrow> 'a)
     \<Rightarrow> 'a set \<Rightarrow> nat \<Rightarrow> 'a set"
### Ignoring duplicate rewrite rule:
### ?b1 \<le> ?y \<Longrightarrow> max ?y ?b1 \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?a1 \<le> ?y \<Longrightarrow> max ?a1 ?y \<equiv> ?y
consts
  aSum ::
    "('a, 'm) aGroup_scheme
     \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> 'a"
### Ambiguous input (line 4200 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra9.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("\<^fixed>fm_gen_by_prod" ("_position" R) ("_position" P)
###       ("_position" M) ("_position" N))
###     ("\<^const>HOL.conj"
###       ("\<^const>Algebra7.MODULE" ("_position" R) ("_position" P))
###       ("_applC" ("_position" free_generator)
###         ("_cargs" ("_position" R)
###           ("_cargs" ("_position" P)
###             ("\<^const>Algebra9.prod_carr" ("_position" M)
###               ("_position" N))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>fm_gen_by_prod" ("_position" R) ("_position" P) ("_position" M)
###     ("\<^const>HOL.iff" ("_position" N)
###       ("\<^const>HOL.conj"
###         ("\<^const>Algebra7.MODULE" ("_position" R) ("_position" P))
###         ("_applC" ("_position" free_generator)
###           ("_cargs" ("_position" R)
###             ("_cargs" ("_position" P)
###               ("\<^const>Algebra9.prod_carr" ("_position" M)
###                 ("_position" N)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^fixed>fm_gen_by_prod" ("_position" R) ("_position" P)
###       ("_position" M)
###       ("\<^const>HOL.iff" ("_position" N)
###         ("\<^const>Algebra7.MODULE" ("_position" R) ("_position" P))))
###     ("_applC" ("_position" free_generator)
###       ("_cargs" ("_position" R)
###         ("_cargs" ("_position" P)
###           ("\<^const>Algebra9.prod_carr" ("_position" M)
###             ("_position" N)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>Algebra7.MODULE"
###       ("\<^fixed>fm_gen_by_prod" ("_position" R) ("_position" P)
###         ("_position" M)
###         ("\<^const>HOL.iff" ("_position" N) ("_position" R)))
###       ("_position" P))
###     ("_applC" ("_position" free_generator)
###       ("_cargs" ("_position" R)
###         ("_cargs" ("_position" P)
###           ("\<^const>Algebra9.prod_carr" ("_position" M)
###             ("_position" N)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4420 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra9.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>tensor_relations" ("_position" R) ("_position" M)
###       ("_position" N) ("_position" MN))
###     ("\<^const>Algebra9.Least_submodule" ("_position" R) ("_position" MN)
###       ("\<^const>Set.union"
###         ("\<^const>Set.union"
###           ("\<^const>Set.union"
###             ("\<^const>Algebra9.tensor_relations1" ("_position" R)
###               ("_position" M) ("_position" N) ("_position" MN))
###             ("\<^const>Algebra9.tensor_relations2" ("_position" R)
###               ("_position" M) ("_position" N) ("_position" MN)))
###           ("\<^const>Algebra9.tensor_relations3" ("_position" R)
###             ("_position" M) ("_position" N) ("_position" MN)))
###         ("\<^const>Algebra9.tensor_relations4" ("_position" R)
###           ("_position" M) ("_position" N) ("_position" MN))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>tensor_relations" ("_position" R) ("_position" M)
###     ("_position" N)
###     ("\<^const>HOL.eq" ("_position" MN)
###       ("\<^const>Algebra9.Least_submodule" ("_position" R) ("_position" MN)
###         ("\<^const>Set.union"
###           ("\<^const>Set.union"
###             ("\<^const>Set.union"
###               ("\<^const>Algebra9.tensor_relations1" ("_position" R)
###                 ("_position" M) ("_position" N) ("_position" MN))
###               ("\<^const>Algebra9.tensor_relations2" ("_position" R)
###                 ("_position" M) ("_position" N) ("_position" MN)))
###             ("\<^const>Algebra9.tensor_relations3" ("_position" R)
###               ("_position" M) ("_position" N) ("_position" MN)))
###           ("\<^const>Algebra9.tensor_relations4" ("_position" R)
###             ("_position" M) ("_position" N) ("_position" MN)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Group-Ring-Module.Algebra9"
### 5.244s elapsed time, 34.828s cpu time, 8.008s GC time
\<lbrakk>R module N; R module M; invmfun R M N f \<in> mHom R N M;
 ?m \<in> carrier N\<rbrakk>
\<Longrightarrow> invmfun R M N f ?m \<in> carrier M
\<lbrakk>?R module ?M; ?R module ?N; ?f \<in> mHom ?R ?M ?N\<rbrakk>
\<Longrightarrow> ?f\<^sup>\<flat>\<^bsub>?R ?M, ?N\<^esub>
                  \<in> mHom ?R (?M /\<^sub>m (ker\<^bsub>?M,?N\<^esub> ?f))
                         ?N
\<lbrakk>?R module ?M; submodule ?R ?M ?H\<rbrakk>
\<Longrightarrow> mpj ?M ?H \<in> mHom ?R ?M (?M /\<^sub>m ?H)
\<lbrakk>R module Zm R e; R module M3; R module ?N;
 z1 \<in> mHom R M3 (Zm R e); ?g \<in> mHom R (Zm R e) ?N\<rbrakk>
\<Longrightarrow> compos M3 ?g z1 \<in> mHom R M3 ?N
\<lbrakk>R module M1; R module M2; R module ?L; f \<in> mHom R M1 M2;
 ?f \<in> mHom R M2 ?L\<rbrakk>
\<Longrightarrow> sup_sharp R M1 M2 ?L f ?f \<in> mHom R M1 ?L
*** Undefined fact: "linorder_antisym_conv2" (line 2403 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra3.thy")
*** At command "apply" (line 2403 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Group-Ring-Module/Algebra3.thy")

==========
HOL-CSP
Loading theory "HOL-Eisbach.Eisbach" (required by "HOL-CSP.CSP")
Loading theory "HOL-Library.Infinite_Set" (required by "HOL-CSP.Sync")
Loading theory "HOL-CSP.Introduction"
Loading theory "HOL-CSP.Process"
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
consts
  enumerate :: "'a set \<Rightarrow> nat \<Rightarrow> 'a"
structure Eisbach_Rule_Insts: sig end
### theory "HOL-Library.Infinite_Set"
### 0.187s elapsed time, 1.402s cpu time, 0.089s GC time
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Eisbach.Eisbach"
### 0.651s elapsed time, 3.945s cpu time, 0.766s GC time
instantiation
  list :: (type) order
  less_eq_list == less_eq ::
    'a list \<Rightarrow> 'a list \<Rightarrow> bool
  less_list == less :: 'a list \<Rightarrow> 'a list \<Rightarrow> bool
### theory "HOL-CSP.Introduction"
### 0.680s elapsed time, 4.143s cpu time, 0.752s GC time
instantiation
  process :: (type) below
  below_process == below ::
    'a process \<Rightarrow> 'a process \<Rightarrow> bool
### theory "HOL-CSP.Process"
### 1.152s elapsed time, 6.462s cpu time, 0.883s GC time
*** Failed to load theory "HOL-CSP.Bot" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Det" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Hide" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Mprefix" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Ndet" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Seq" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Skip" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Stop" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Sync" (unresolved "HOL-CSP.Process")
*** Failed to load theory "HOL-CSP.Mndet" (unresolved "HOL-CSP.Mprefix", "HOL-CSP.Ndet", "HOL-CSP.Process", "HOL-CSP.Stop")
*** Failed to load theory "HOL-CSP.CSP" (unresolved "HOL-CSP.Bot", "HOL-CSP.Det", "HOL-CSP.Hide", "HOL-CSP.Mndet", "HOL-CSP.Mprefix", "HOL-CSP.Ndet", "HOL-CSP.Seq", "HOL-CSP.Skip", "HOL-CSP.Stop", "HOL-CSP.Sync")
*** Failed to load theory "HOL-CSP.Assertions" (unresolved "HOL-CSP.CSP")
*** Failed to load theory "HOL-CSP.Conclusion" (unresolved "HOL-CSP.Assertions")
*** Failed to load theory "HOL-CSP.CopyBuffer" (unresolved "HOL-CSP.Assertions")
*** Type unification failed: Clash of types "_ list" and "_ \<times> _"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  INTER X ::
***   (??'a process \<Rightarrow> (??'a event list \<times> ??'a event set) set)
***   \<Rightarrow> ??'b
*** Operand:   D :: ??'a process \<Rightarrow> ??'a event list set
*** 
*** At command "definition" (line 916 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/HOL-CSP/Process.thy")

==========
Incompleteness
Loading theory "FinFun.FinFun" (required by "Incompleteness.Goedel_I" via "Incompleteness.Pf_Predicates" via "Incompleteness.Coding_Predicates" via "Incompleteness.Coding" via "Incompleteness.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
bundle finfun
locale finfun_rec_wf_aux
  fixes cnst :: "'b \<Rightarrow> 'c"
    and upd :: "'a \<Rightarrow> 'b \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "finfun_rec_wf_aux cnst upd"
locale finfun_rec_wf
  fixes cnst :: "'b \<Rightarrow> 'c"
    and upd :: "'a \<Rightarrow> 'b \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "finfun_rec_wf cnst upd"
### Introduced fixed type variable(s): 'd in "c__"
### Introduced fixed type variable(s): 'c, 'd in "a__" or "b__" or "g__"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
instantiation
  finfun :: ({card_UNIV,equal}, equal) equal
  equal_finfun == equal_class.equal ::
    'a \<Rightarrow>f 'b
    \<Rightarrow> 'a \<Rightarrow>f 'b \<Rightarrow> bool
instantiation
  finfun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_finfun == finite_UNIV :: ('a \<Rightarrow>f 'b, bool) phantom
instantiation
  finfun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_finfun == card_UNIV_class.card_UNIV ::
    ('a \<Rightarrow>f 'b, nat) phantom
bundle finfun_syntax
bundle no_finfun_syntax
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Introduced fixed type variable(s): 'e in "a__" or "g'__"
### Introduced fixed type variable(s): 'd in "c__"
### Introduced fixed type variable(s): 'd in "b__" or "g'__"
### Introduced fixed type variable(s): 'f in "c__"
### Introduced fixed type variable(s): 'd, 'e in "a__" or "fa__"
### Introduced fixed type variable(s): 'g in "b__" or "g__"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Ignoring duplicate rewrite rule:
### ?f1 \<in> finfun \<Longrightarrow> curry ?f1 \<in> finfun \<equiv> True
### Ignoring duplicate rewrite rule:
### ?f1 \<in> finfun \<Longrightarrow> curry ?f1 ?a1 \<in> finfun \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>?P ?a; \<And>x. ?P x \<Longrightarrow> x = ?a\<rbrakk>
### \<Longrightarrow> (THE x. ?P x) = ?a
### theory "FinFun.FinFun"
### 1.449s elapsed time, 4.411s cpu time, 0.692s GC time
Loading theory "Nominal2.Nominal2_Base" (required by "Incompleteness.Goedel_I" via "Incompleteness.Pf_Predicates" via "Incompleteness.Coding_Predicates" via "Incompleteness.Coding" via "Incompleteness.SyntaxN" via "Nominal2.Nominal2")
consts
  sort_of :: "atom \<Rightarrow> atom_sort"
consts
  nat_of :: "atom \<Rightarrow> nat"
instantiation
  perm :: group_add
  minus_perm == minus :: perm \<Rightarrow> perm \<Rightarrow> perm
  uminus_perm == uminus :: perm \<Rightarrow> perm
  zero_perm == zero_class.zero :: perm
  plus_perm == plus :: perm \<Rightarrow> perm \<Rightarrow> perm
class pt = type +
  fixes permute :: "perm \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "permute_zero": "\<And>x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "\<And>p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
instantiation
  atom :: pt
  permute_atom == permute :: perm \<Rightarrow> atom \<Rightarrow> atom
instantiation
  perm :: pt
  permute_perm == permute :: perm \<Rightarrow> perm \<Rightarrow> perm
instantiation
  fun :: (pt, pt) pt
  permute_fun == permute ::
    perm
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  bool :: pt
  permute_bool == permute :: perm \<Rightarrow> bool \<Rightarrow> bool
instantiation
  set :: (pt) pt
  permute_set == permute :: perm \<Rightarrow> 'a set \<Rightarrow> 'a set
instantiation
  unit :: pt
  permute_unit == permute :: perm \<Rightarrow> unit \<Rightarrow> unit
instantiation
  prod :: (pt, pt) pt
  permute_prod == permute ::
    perm \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
consts
  permute_prod ::
    "perm \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b"
instantiation
  sum :: (pt, pt) pt
  permute_sum == permute :: perm \<Rightarrow> 'a + 'b \<Rightarrow> 'a + 'b
consts
  permute_sum :: "perm \<Rightarrow> 'a + 'b \<Rightarrow> 'a + 'b"
instantiation
  list :: (pt) pt
  permute_list == permute ::
    perm \<Rightarrow> 'a list \<Rightarrow> 'a list
consts
  permute_list :: "perm \<Rightarrow> 'a list \<Rightarrow> 'a list"
instantiation
  option :: (pt) pt
  permute_option == permute ::
    perm \<Rightarrow> 'a option \<Rightarrow> 'a option
consts
  permute_option :: "perm \<Rightarrow> 'a option \<Rightarrow> 'a option"
instantiation
  multiset :: (pt) pt
  permute_multiset == permute ::
    perm \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
instantiation
  fset :: (pt) pt
  permute_fset == permute ::
    perm \<Rightarrow> 'a fset \<Rightarrow> 'a fset
instantiation
  finfun :: (pt, pt) pt
  permute_finfun == permute ::
    perm \<Rightarrow> ('a, 'b) finfun \<Rightarrow> ('a, 'b) finfun
instantiation
  char :: pt
  permute_char == permute :: perm \<Rightarrow> char \<Rightarrow> char
instantiation
  nat :: pt
  permute_nat == permute :: perm \<Rightarrow> nat \<Rightarrow> nat
instantiation
  int :: pt
  permute_int == permute :: perm \<Rightarrow> int \<Rightarrow> int
class pure = pt +
  assumes "permute_pure": "\<And>p x. p \<bullet> x = x"
### ML warning (line 76 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 94 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 116 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Matches are not exhaustive.
### ML warning (line 119 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 130 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 156 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Pattern is not exhaustive.
infix 1 ||>>>
infix 1 |>>>
signature NOMINAL_BASIC =
  sig
    val case_sum_const: typ -> typ -> typ -> term
    val dest_fsetT: typ -> typ
    val dest_listT: typ -> typ
    val dest_perm: term -> term * term
    val fixed_nonfixed_args: Proof.context -> term -> term * term list
    val fold_left: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
    val is_fixed: Proof.context -> term -> bool
    val is_true: term -> bool
    val last2: 'a list -> 'a * 'a
    val long_name: Proof.context -> string -> string
    val map4:
       ('a -> 'b -> 'c -> 'd -> 'e) ->
         'a list -> 'b list -> 'c list -> 'd list -> 'e list
    val mk_All: string * typ -> term -> term
    val mk_all: string * typ -> term -> term
    val mk_case_sum: term -> term -> term
    val mk_equiv: thm -> thm
    val mk_exists: string * typ -> term -> term
    val mk_id: term -> term
    val mk_minus: term -> term
    val mk_perm: term -> term -> term
    val mk_perm_ty: typ -> term -> term -> term
    val mk_plus: term -> term -> term
    val order: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
    val order_default:
       ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
    val perm_const: typ -> term
    val perm_ty: typ -> typ
    val remove_dups: ('a * 'a -> bool) -> 'a list -> 'a list
    val safe_mk_equiv: thm -> thm
    val split_filter: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_last2: 'a list -> 'a list * 'a * 'a
    val split_triples: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
    val trace: bool ref
    val trace_msg: (unit -> string) -> unit
    val |>>> : 'a * ('a -> 'b * 'c) -> 'b list * 'c
    val ||>>> : ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
  end
structure Nominal_Basic: NOMINAL_BASIC
val order = fn: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
val dest_listT = fn: typ -> typ
val mk_perm = fn: term -> term -> term
val mk_plus = fn: term -> term -> term
val split_filter = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val fold_left = fn: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
val split_last2 = fn: 'a list -> 'a list * 'a * 'a
val order_default = fn:
   ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
val perm_const = fn: typ -> term
val last2 = fn: 'a list -> 'a * 'a
val mk_perm_ty = fn: typ -> term -> term -> term
val case_sum_const = fn: typ -> typ -> typ -> term
val is_fixed = fn: Proof.context -> term -> bool
val mk_id = fn: term -> term
val mk_All = fn: string * typ -> term -> term
val map4 = fn:
   ('a -> 'b -> 'c -> 'd -> 'e) ->
     'a list -> 'b list -> 'c list -> 'd list -> 'e list
val is_true = fn: term -> bool
val safe_mk_equiv = fn: thm -> thm
val trace = ref false: bool ref
val mk_all = fn: string * typ -> term -> term
val mk_case_sum = fn: term -> term -> term
val dest_fsetT = fn: typ -> typ
val remove_dups = fn: ('a * 'a -> bool) -> 'a list -> 'a list
val fixed_nonfixed_args = fn: Proof.context -> term -> term * term list
val |>>> = fn: 'a * ('a -> 'b * 'c) -> 'b list * 'c
val dest_perm = fn: term -> term * term
val mk_equiv = fn: thm -> thm
val perm_ty = fn: typ -> typ
val mk_exists = fn: string * typ -> term -> term
val long_name = fn: Proof.context -> string -> string
val split_triples = fn: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val mk_minus = fn: term -> term
val ||>>> = fn: ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
val trace_msg = fn: (unit -> string) -> unit
### ML warning (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
### ML warning (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Value identifier (p') has not been referenced.
### ML warning (line 239 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
signature NOMINAL_THMDECLS =
  sig
    val eqvt_add: attribute
    val eqvt_del: attribute
    val eqvt_raw_add: attribute
    val eqvt_raw_del: attribute
    val eqvt_transform: Proof.context -> thm -> thm
    val get_eqvts_raw_thms: Proof.context -> thm list
    val get_eqvts_thms: Proof.context -> thm list
    val is_eqvt: Proof.context -> term -> bool
  end
structure Nominal_ThmDecls: NOMINAL_THMDECLS
### ML warning (line 72 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_permeq.ML"):
### Value identifier (pre_thms) has not been referenced.
### ML warning (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_permeq.ML"):
### Value identifier (post_thms) has not been referenced.
infix 4 addpres
infix 4 addposts
infix 4 addexcls
signature NOMINAL_PERMEQ =
  sig
    val addexcls: eqvt_config * string list -> eqvt_config
    val addposts: eqvt_config * thm list -> eqvt_config
    val addpres: eqvt_config * thm list -> eqvt_config
    val args_parser: (thm list * string list) context_parser
    val delposts: eqvt_config -> eqvt_config
    val delpres: eqvt_config -> eqvt_config
    datatype eqvt_config
    =
         Eqvt_Config of
             {excluded: string list,
              post_thms: thm list, pre_thms: thm list, strict_mode: bool}
    val eqvt_conv: Proof.context -> eqvt_config -> conv
    val eqvt_relaxed_config: eqvt_config
    val eqvt_rule: Proof.context -> eqvt_config -> thm -> thm
    val eqvt_strict_config: eqvt_config
    val eqvt_tac: Proof.context -> eqvt_config -> int -> tactic
    val perm_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val perm_strict_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val trace_eqvt: bool Config.T
  end
structure Nominal_Permeq: NOMINAL_PERMEQ
class le_eqvt = pt + order +
  assumes
    "le_eqvt":
      "\<And>p x y.
          p \<bullet> (x \<le> y) = (p \<bullet> x \<le> p \<bullet> y)"
class inf_eqvt = complete_lattice + pt +
  assumes "inf_eqvt": "\<And>p X. p \<bullet> Inf X = Inf (p \<bullet> X)"
instantiation
  bool :: le_eqvt
instantiation
  fun :: (pt, le_eqvt) le_eqvt
instantiation
  bool :: inf_eqvt
instantiation
  fun :: (pt, inf_eqvt) inf_eqvt
class pt = type +
  fixes permute :: "perm \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "permute_zero": "\<And>x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "\<And>p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
class fs = pt +
  assumes "finite_supp": "\<And>x. finite (supp x)"
### Metis: Unused theorems: "Nominal2_Base.pt_class.permute_minus_cancel_2"
### Metis: Unused theorems: "Set.empty_subsetI", "local.insert_3", "Nominal2_Base.supp_swap"
class at_base = pt +
  fixes atom :: "'a \<Rightarrow> atom"
  assumes "atom_eq_iff": "\<And>a b. (atom a = atom b) = (a = b)"
  assumes
    "atom_eqvt": "\<And>p a. p \<bullet> atom a = atom (p \<bullet> a)"
class at = at_base +
  assumes
    "sort_of_atom_eq": "\<And>a b. sort_of (atom a) = sort_of (atom b)"
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> atom ?b1 \<equiv> ?a1 \<sharp> ?b1
### ML warning (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 279 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 278 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 277 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
type cns_info = (term * typ * typ list * bool list) list
signature NOMINAL_LIBRARY =
  sig
    val all_dtyp_constrs_types: Old_Datatype_Aux.descr -> cns_info list
    val atom_const: typ -> term
    val atom_ty: typ -> typ
    val atomify: Proof.context -> term -> term
    val atomify_ty: Proof.context -> typ -> term -> term
    val atomize: Proof.context -> thm -> thm
    val atomize_concl: Proof.context -> thm -> thm
    val atomize_rule: Proof.context -> int -> thm -> thm
    type cns_info = (term * typ * typ list * bool list) list
    val conj_tac: Proof.context -> (int -> tactic) -> int -> tactic
    val finite_const: typ -> term
    val fold_append: term list -> term
    val fold_conj: term list -> term
    val fold_conj_balanced: term list -> term
    val fold_union: term list -> term
    val fold_union_env: typ list -> term list -> term
    val fresh_args: Proof.context -> term -> term list
    val fresh_const: typ -> term
    val fresh_star_const: typ -> term
    val fresh_star_ty: typ -> typ
    val fresh_ty: typ -> typ
    val is_atom: Proof.context -> typ -> bool
    val is_atom_fset: Proof.context -> typ -> bool
    val is_atom_list: Proof.context -> typ -> bool
    val is_atom_set: Proof.context -> typ -> bool
    val listify: Proof.context -> term -> term
    val listify_ty: Proof.context -> typ -> term -> term
    val mk_append: term * term -> term
    val mk_atom: term -> term
    val mk_atom_fset: term -> term
    val mk_atom_fset_ty: typ -> term -> term
    val mk_atom_list: term -> term
    val mk_atom_list_ty: typ -> term -> term
    val mk_atom_set: term -> term
    val mk_atom_set_ty: typ -> term -> term
    val mk_atom_ty: typ -> term -> term
    val mk_binop_env: typ list -> string -> term * term -> term
    val mk_conj: term * term -> term
    val mk_diff: term * term -> term
    val mk_finite: term -> term
    val mk_finite_ty: typ -> term -> term
    val mk_fresh: term -> term -> term
    val mk_fresh_star: term -> term -> term
    val mk_fresh_star_ty: typ -> term -> term -> term
    val mk_fresh_ty: typ -> term -> term -> term
    val mk_full_horn: (string * typ) list -> term list -> term -> term
    val mk_sort_of: term -> term
    val mk_supp: term -> term
    val mk_supp_rel: term -> term -> term
    val mk_supp_rel_ty: typ -> term -> term -> term
    val mk_supp_ty: typ -> term -> term
    val mk_supports: term -> term -> term
    val mk_supports_ty: typ -> term -> term -> term
    val mk_union: term * term -> term
    val mk_union_env: typ list -> term * term -> term
    val pat_completeness_simp: thm list -> Proof.context -> tactic
    val prove_termination_fun:
       thm list -> Proof.context -> Function.info * local_theory
    val prove_termination_ind: Proof.context -> int -> tactic
    val setify: Proof.context -> term -> term
    val setify_ty: Proof.context -> typ -> term -> term
    val size_ss: simpset
    val strip_full_horn: term -> (string * typ) list * term list * term
    val supp_const: typ -> term
    val supp_rel_const: typ -> term
    val supp_rel_ty: typ -> typ
    val supp_ty: typ -> typ
    val supports_const: typ -> term
    val to_set: term -> term
    val to_set_ty: typ -> term -> term
    val transform_prem1: Proof.context -> string list -> thm -> thm
    val transform_prem2: Proof.context -> string list -> thm -> thm
  end
structure Nominal_Library: NOMINAL_LIBRARY
val conj_tac = fn: Proof.context -> (int -> tactic) -> int -> tactic
val is_atom_fset = fn: Proof.context -> typ -> bool
val mk_union_env = fn: typ list -> term * term -> term
val size_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb =
                        Net {atoms =
                             {("HOL.eq",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Abs ("...", "?'d1", ...), name = "HOL.simp_thms_38",
  ...}]})},
                             comb = Leaf [], var = Leaf []},
                        var =
                        Leaf
                         [{elhs = "\<exists>x. ?t1 = x \<and> ?P1 x",
                           extra = false, fo = false, lhs =
                           Const ("HOL.Ex",
                                  "(... ... ...) \<Rightarrow> bool") $
                             Abs ("x", "?'d1",
                               Const ("...", ...) $ (... $ ... $ ...) $
                                 ...),
                           name = "HOL.simp_thms_40", perm = false, thm =
                           "\<exists>x. ?t1 ... x \<and> ?P1 x \<equiv>
                            ?P1 ?t1"},
                          {elhs = "\<exists>x. x = ?t1 \<and> ?P1 x",
                           extra = false, fo = false, lhs =
                           Const ("HOL.Ex", "(...) ... bool") $
                             Abs ("x", "?'d1",
                               Const ("...",
"bool \<Rightarrow> bool \<Rightarrow> bool") $
                                 ... $ ...),
                           name = "HOL.simp_thms_39", perm = false, thm =
                           "\<exists>x. ... ... ... ... ... ... \<equiv>
                            ?P1 ?t1"},
                          {elhs = "\<exists>x. x = ?t1", extra = false, fo =
                           true, lhs =
                           Const ("HOL.Ex", "... ... ...") $
                             Abs ("x", "...", ... $ ... $ ...),
                           name = "HOL.simp_thms_37", perm = false, thm =
                           "...x... ... ... ... \<equiv> True"},
                          {elhs = "\<exists>x. ?y", extra = false, fo =
                           true, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                           name = "HOL.simp_thms_36", perm = false, thm =
                           "......... ... ... ?y"},
                          {elhs = "...x... ... ... ...", extra = false, fo =
                           false, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                           name = "HOL.ex_simps_6", perm = false, thm =
                           "... ... ..."},
                          {elhs = "......... ...", extra = false, fo =
                           false, lhs =
                           Const ("...", ...) $ Abs ("...", "?'e1", ...),
                           name = "HOL.ex_simps_5", ...},
                          {elhs = "...", extra = false, fo = false, lhs =
                           Const ("...",
                                  "(?'d1 \<Rightarrow> bool)
                                   \<Rightarrow> bool") $
                             ...,
                           ...},
                          {elhs = "...", extra = false, fo = false, ...},
                          {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "\<forall>x. ?t1 \<noteq> x", extra =
                            false, fo = true, lhs =
                            Const ("HOL.All", "(...) ... bool") $
                              Abs ("x", "?'d1",
                                Const ("...", "bool \<Rightarrow> bool") $
                                  ...),
                            name = "HOL.simp_thms_44", perm = false, thm =
                            "\<forall>x. ?t1 ... x \<equiv> False"},
                           {elhs = "\<forall>x. x \<noteq> ?t1", extra =
                            false, fo = true, lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "HOL.simp_thms_43", perm = false, thm =
                            "...x... ... ... ... \<equiv> False"},
                           {elhs = "\<forall>x. ... ... ... ... ... ...",
                            extra = false, fo = false, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.simp_thms_42", perm = false, thm =
                            "......... ... ... ... ..."},
                           {elhs = "...x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "HOL.simp_thms_41", perm = false, thm =
                            "... ... ..."},
                           {elhs = "......... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'b1", ...),
                            name = "HOL.simp_thms_35", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...",
                                   "(?'f1 \<Rightarrow> bool)
                                    \<Rightarrow> bool") $
                              ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "\<not> True", extra = false, fo =
                               true, lhs =
                               Const ("HOL.Not", "...") $
                                 Const ("HOL.True", "..."),
                               name = "HOL.simp_thms_7", perm = false, thm =
                               "... True ... False"}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "\<not> False", extra = false, fo =
                                true, lhs =
                                Const ("HOL.Not", "...") $
                                  Const ("...", ...),
                                name = "HOL.simp_thms_8", perm = false,
                                thm = "... ... ... ..."}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]}),
                                ("HOL.Not",
                                  Net {atoms = {}, comb = Leaf [...], var =
 Leaf [...]})},
                              comb =
                              Net {atoms =
                                   {("HOL.eq",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("HOL.conj",
 Net {atoms = {}, comb = ..., var = ...}),
                                     ("HOL.disj", Net {atoms = {}, ...}),
                                     ("HOL.implies", ...)},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "THE x. x ... ?y", extra = false, fo =
                            true, lhs =
                            Const ("HOL.The", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.the_eq_trivial", perm = false, thm =
                            "... ...... ... ... ?y"}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...x... PROP ?V", extra = false, fo =
                            true, lhs =
                            Const ("Pure.all", "...") $ Abs ("x", ..., ...),
                            name = "Pure.triv_forall_equality", perm =
                            false, thm = "... ... ... ..."}]}),
                  ("Wellfounded.wf",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("Wellfounded.measure",
                                 Net {atoms = {}, comb = ..., var = ...})},
                              comb = Leaf [], var = Leaf []},
                         var = Leaf []})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]})},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}})},
                                  comb = Leaf [], var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]})},
 comb = Leaf [], var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?x1 ... ?x1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1"),
                                     name = "HOL.simp_thms_6", perm = false,
                                     thm = "... ... ..."}]}}),
                       ("HOL.conj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.conj", Net {atoms = {}, comb = ..., var = ...}),
    ("HOL.implies", Net {atoms = {}, ...})},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]),
                                     ("HOL.False",
 Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, comb = ..., var = ...})}, comb =
  Net {atoms = {("HOL.conj", ...)}, comb = Leaf [...], var = Leaf [...]},
  var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "... ... ...", extra = false,
fo = true, lhs = Const ("...", ...) $ Var ((...), "bool") $ ..., name =
"HOL.simp_thms_25", ...}]}}),
                       ("HOL.disj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.disj", Net {atoms = {}, ...}), ("HOL.implies", ...)}, comb =
  Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf [{elhs = "...", extra = false, fo = true, ...}]),
                                     ("HOL.False",
 Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs =
Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
...}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {("HOL.Trueprop", ...)},
  comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.member",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var = Leaf []}),
                       ("HOL.implies",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.False", Net {atoms = {}, ...})},
                              comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("HOL.True", ...), ...}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("Groups.times_class.times",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {...}, comb = ..., var = ...})},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Sum_Type.sum.case_sum",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}}),
                            ("Basic_BNF_LFPs.prod.size_prod",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var = Leaf []}},
     {congs =
      ({(?, "\<lbrakk>?P \<equiv> ?P';
              ?P' \<Longrightarrow> ?Q \<equiv> ?Q'\<rbrakk>
             \<Longrightarrow> ?P \<longrightarrow> ?Q \<equiv>
                               ?P' \<longrightarrow> ?Q'"),
         (?, "\<lbrakk>PROP ?P \<equiv> PROP ?P';
               PROP ?P' \<Longrightarrow> PROP ?Q \<equiv> PROP ?Q'\<rbrakk>
              \<Longrightarrow> (PROP ?P =simp=> PROP ?Q) \<equiv>
                                (PROP ?P' =simp=> PROP ?Q')")},
       []),
      loop_tacs =
      [("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a \<Rightarrow> bool") $
                                  ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 85630}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 85674}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms = {}, comb = Leaf [], var =
                             Net {atoms = {}, comb = Leaf [], var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "HOL.neq", proc = fn,
stamp = Stamp 85780}]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs =
 Const ("...",
        "?'a \<Rightarrow> (?'a \<Rightarrow> ?'b) \<Rightarrow> ?'b") $
   ... $ ...,
 name = "HOL.let_simp", proc = fn, stamp = Stamp 85904}]}}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("Groups.plus_class.plus", Net {atoms = {}, ...}),
    ("Groups.times_class.times", ...)},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms =
  {("Nat.Suc", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var = Leaf []}})},
                     comb = Leaf [], var = Leaf []},
                var = Leaf []},
           var = Leaf []},
      solvers =
      ([Solver {id = Stamp 85392, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 85394, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val mk_finite = fn: term -> term
val fresh_args = fn: Proof.context -> term -> term list
val atom_ty = fn: typ -> typ
val mk_atom_set = fn: term -> term
val mk_fresh_star_ty = fn: typ -> term -> term -> term
val fresh_star_ty = fn: typ -> typ
val mk_full_horn = fn: (string * typ) list -> term list -> term -> term
val atomize_rule = fn: Proof.context -> int -> thm -> thm
val prove_termination_ind = fn: Proof.context -> int -> tactic
val supp_const = fn: typ -> term
val mk_diff = fn: term * term -> term
val supp_rel_const = fn: typ -> term
val setify_ty = fn: Proof.context -> typ -> term -> term
val transform_prem2 = fn: Proof.context -> string list -> thm -> thm
val fold_append = fn: term list -> term
val atomize = fn: Proof.context -> thm -> thm
val atom_const = fn: typ -> term
val mk_supports = fn: term -> term -> term
val fresh_star_const = fn: typ -> term
val is_atom_list = fn: Proof.context -> typ -> bool
val strip_full_horn = fn: term -> (string * typ) list * term list * term
val fold_conj = fn: term list -> term
val listify = fn: Proof.context -> term -> term
val fold_union = fn: term list -> term
val mk_union = fn: term * term -> term
val mk_atom = fn: term -> term
val mk_append = fn: term * term -> term
val all_dtyp_constrs_types = fn: Old_Datatype_Aux.descr -> cns_info list
val fold_union_env = fn: typ list -> term list -> term
val mk_fresh = fn: term -> term -> term
val is_atom_set = fn: Proof.context -> typ -> bool
val mk_sort_of = fn: term -> term
val listify_ty = fn: Proof.context -> typ -> term -> term
val mk_atom_fset_ty = fn: typ -> term -> term
val mk_fresh_star = fn: term -> term -> term
val to_set_ty = fn: typ -> term -> term
val mk_atom_ty = fn: typ -> term -> term
val mk_supp_rel_ty = fn: typ -> term -> term -> term
val prove_termination_fun = fn:
   thm list -> Proof.context -> Function.info * local_theory
val atomify = fn: Proof.context -> term -> term
val mk_atom_set_ty = fn: typ -> term -> term
val atomify_ty = fn: Proof.context -> typ -> term -> term
val supp_rel_ty = fn: typ -> typ
val pat_completeness_simp = fn: thm list -> Proof.context -> tactic
val mk_conj = fn: term * term -> term
val finite_const = fn: typ -> term
val setify = fn: Proof.context -> term -> term
val is_atom = fn: Proof.context -> typ -> bool
val mk_atom_fset = fn: term -> term
val mk_atom_list_ty = fn: typ -> term -> term
val transform_prem1 = fn: Proof.context -> string list -> thm -> thm
val mk_finite_ty = fn: typ -> term -> term
val mk_fresh_ty = fn: typ -> term -> term -> term
val mk_binop_env = fn: typ list -> string -> term * term -> term
val atomize_concl = fn: Proof.context -> thm -> thm
val fresh_const = fn: typ -> term
val fresh_ty = fn: typ -> typ
val fold_conj_balanced = fn: term list -> term
val supports_const = fn: typ -> term
val to_set = fn: term -> term
val mk_supp = fn: term -> term
val mk_supports_ty = fn: typ -> term -> term -> term
val supp_ty = fn: typ -> typ
val mk_supp_rel = fn: term -> term -> term
val mk_atom_list = fn: term -> term
val mk_supp_ty = fn: typ -> term -> term
### Metis: Unused theorems: "Nominal2_Base.eqvt_apply"
### ML warning (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_atoms.ML"):
### Value identifier (arg) has not been referenced.
signature ATOM_DECL =
  sig val add_atom_decl: binding * binding option -> theory -> theory end
structure Atom_Decl: ATOM_DECL
### ML warning (line 40 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Value identifier (context) has not been referenced.
### ML warning (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Matches are not exhaustive.
### ML warning (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
### ML warning (line 125 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
signature NOMINAL_EQVT =
  sig
    val equivariance_cmd: string -> Proof.context -> local_theory
    val raw_equivariance:
       Proof.context -> term list -> thm -> thm list -> thm list
  end
structure Nominal_Eqvt: NOMINAL_EQVT
### theory "Nominal2.Nominal2_Base"
### 2.489s elapsed time, 6.121s cpu time, 0.444s GC time
Loading theory "Nominal2.Nominal2_Abs" (required by "Incompleteness.Goedel_I" via "Incompleteness.Pf_Predicates" via "Incompleteness.Coding_Predicates" via "Incompleteness.Coding" via "Incompleteness.SyntaxN" via "Nominal2.Nominal2")
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_set_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_set (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 \<and>
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 \<and>
### ?R1 (?p1 \<bullet> ?x1) ?y1 \<and> ?p1 \<bullet> ?bs1 = ?cs1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_res_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_res (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 \<and>
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 \<and> ?R1 (?p1 \<bullet> ?x1) ?y1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_lst_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_lst (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - set ?bs1 = ?f1 ?y1 - set ?cs1 \<and>
### (?f1 ?x1 - set ?bs1) \<sharp>* ?p1 \<and>
### ?R1 (?p1 \<bullet> ?x1) ?y1 \<and> ?p1 \<bullet> ?bs1 = ?cs1
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### ?P1 \<le> ?Q1 \<equiv> ?P1 \<longrightarrow> ?Q1
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_set_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_set (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>set (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_lst_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_lst (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>lst (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_res_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_res (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>res (=) supp p (?cs1, ?y1)
Found termination order: "{}"
instantiation
  abs_set :: (pt) pt
  permute_abs_set == permute ::
    perm \<Rightarrow> 'a abs_set \<Rightarrow> 'a abs_set
instantiation
  abs_res :: (pt) pt
  permute_abs_res == permute ::
    perm \<Rightarrow> 'a abs_res \<Rightarrow> 'a abs_res
instantiation
  abs_lst :: (pt) pt
  permute_abs_lst == permute ::
    perm \<Rightarrow> 'a abs_lst \<Rightarrow> 'a abs_lst
Found termination order: "{}"
### ML warning (line 927 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/Nominal2_Abs.thy"):
### Pattern is not exhaustive.
val alpha_single_simproc = fn:
   thm -> 'a -> Proof.context -> cterm -> thm option
Found termination order: "{}"
### theory "Nominal2.Nominal2_Abs"
### 1.274s elapsed time, 4.634s cpu time, 1.079s GC time
Loading theory "Nominal2.Nominal2_FCB" (required by "Incompleteness.Goedel_I" via "Incompleteness.Pf_Predicates" via "Incompleteness.Coding_Predicates" via "Incompleteness.Coding" via "Incompleteness.SyntaxN" via "Nominal2.Nominal2")
val all_trivials = fn: (Proof.context -> Proof.method) context_parser
### theory "Nominal2.Nominal2_FCB"
### 0.077s elapsed time, 0.479s cpu time, 0.000s GC time
Loading theory "Nominal2.Nominal2" (required by "Incompleteness.Goedel_I" via "Incompleteness.Pf_Predicates" via "Incompleteness.Coding_Predicates" via "Incompleteness.Coding" via "Incompleteness.SyntaxN")
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
signature NOMINAL_DT_DATA =
  sig
    datatype alpha_result
    =
         AlphaResult of
             {alpha_bn_names: string list,
              alpha_bn_trms: term list,
              alpha_bn_tys: typ list,
              alpha_cases: thm list,
              alpha_intros: thm list,
              alpha_names: string list,
              alpha_raw_induct: thm,
              alpha_trms: term list, alpha_tys: typ list}
    datatype bclause = BC of bmode * (term option * int) list * int list
    datatype bmode = Lst | Res | Set
    type bn_info = term * int * (int * term option) list list
    val get_all_info: Proof.context -> (string * info) list
    val get_info: Proof.context -> string -> info option
    type info =
       {distinct: thm list,
        inject: thm list,
        strong_exhaust: thm list, strong_inducts: thm list}
    val mk_infos:
       string list ->
         thm list ->
           thm list -> thm list -> thm list -> (string * info) list
    datatype raw_dt_info
    =
         RawDtInfo of
             {raw_all_cns: term list list,
              raw_cns_info: cns_info list,
              raw_distinct_thms: thm list,
              raw_dt_names: string list,
              raw_dts: Old_Datatype.spec list,
              raw_exhaust_thms: thm list,
              raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
              raw_induct_thm: thm,
              raw_induct_thms: thm list,
              raw_inject_thms: thm list,
              raw_size_thms: thm list,
              raw_size_trms: term list,
              raw_ty_args: (string * sort) list, raw_tys: typ list}
    val register_info: string * info -> Context.generic -> Context.generic
    val the_info: Proof.context -> string -> info
    datatype user_data
    =
         UserData of
             {bclauses: bclause list list list,
              bn_eqs: (Attrib.binding * term) list,
              bn_funs: (binding * typ * mixfix) list,
              cn_names: string list,
              cn_tys: (string * string) list, dts: Old_Datatype.spec list}
  end
structure Nominal_Dt_Data: NOMINAL_DT_DATA
type bn_info = term * int * (int * term option) list list
datatype raw_dt_info
=
     RawDtInfo of
         {raw_all_cns: term list list,
          raw_cns_info: cns_info list,
          raw_distinct_thms: thm list,
          raw_dt_names: string list,
          raw_dts: Old_Datatype.spec list,
          raw_exhaust_thms: thm list,
          raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
          raw_induct_thm: thm,
          raw_induct_thms: thm list,
          raw_inject_thms: thm list,
          raw_size_thms: thm list,
          raw_size_trms: term list,
          raw_ty_args: (string * sort) list, raw_tys: typ list}
datatype user_data
=
     UserData of
         {bclauses: Nominal_Dt_Data.bclause list list list,
          bn_eqs: (Attrib.binding * term) list,
          bn_funs: (binding * typ * mixfix) list,
          cn_names: string list,
          cn_tys: (string * string) list, dts: Old_Datatype.spec list}
datatype bmode = Lst | Res | Set
datatype bclause = BC of bmode * (term option * int) list * int list
type info =
   {distinct: thm list,
    inject: thm list, strong_exhaust: thm list, strong_inducts: thm list}
datatype alpha_result
=
     AlphaResult of
         {alpha_bn_names: string list,
          alpha_bn_trms: term list,
          alpha_bn_tys: typ list,
          alpha_cases: thm list,
          alpha_intros: thm list,
          alpha_names: string list,
          alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
constructor Lst: bmode
constructor UserData:
   {bclauses: bclause list list list,
    bn_eqs: (Attrib.binding * term) list,
    bn_funs: (binding * typ * mixfix) list,
    cn_names: string list,
    cn_tys: (string * string) list, dts: Old_Datatype.spec list}
     -> user_data
val the_info = fn: Proof.context -> string -> info
val register_info = fn: string * info -> Context.generic -> Context.generic
val get_all_info = fn: Proof.context -> (string * info) list
constructor BC: bmode * (term option * int) list * int list -> bclause
val get_info = fn: Proof.context -> string -> info option
constructor Res: bmode
constructor AlphaResult:
   {alpha_bn_names: string list,
    alpha_bn_trms: term list,
    alpha_bn_tys: typ list,
    alpha_cases: thm list,
    alpha_intros: thm list,
    alpha_names: string list,
    alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
     -> alpha_result
constructor RawDtInfo:
   {raw_all_cns: term list list,
    raw_cns_info: cns_info list,
    raw_distinct_thms: thm list,
    raw_dt_names: string list,
    raw_dts: Old_Datatype.spec list,
    raw_exhaust_thms: thm list,
    raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
    raw_induct_thm: thm,
    raw_induct_thms: thm list,
    raw_inject_thms: thm list,
    raw_size_thms: thm list,
    raw_size_trms: term list,
    raw_ty_args: (string * sort) list, raw_tys: typ list}
     -> raw_dt_info
constructor Set: bmode
val mk_infos = fn:
   string list ->
     thm list -> thm list -> thm list -> thm list -> (string * info) list
### ML warning (line 82 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
### ML warning (line 286 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Value identifier (lthy) has not been referenced.
### ML warning (line 523 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_RAWFUNS =
  sig
    val define_raw_bn_perms:
       raw_dt_info ->
         bn_info list -> local_theory -> term list * thm list * local_theory
    val define_raw_bns:
       raw_dt_info ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             local_theory ->
               term list * thm list * bn_info list * thm list * local_theory
    val define_raw_fvs:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             Proof.context ->
               term list * term list * thm list * thm list * local_theory
    val define_raw_perms:
       raw_dt_info ->
         local_theory -> (term list * thm list * thm list) * local_theory
    val get_all_binders: bclause list -> (term option * int) list
    val is_recursive_binder: bclause -> bool
    val raw_prove_eqvt:
       term list -> thm list -> thm list -> Proof.context -> thm list
  end
structure Nominal_Dt_RawFuns: NOMINAL_DT_RAWFUNS
val get_all_binders = fn: bclause list -> (term option * int) list
val raw_prove_eqvt = fn:
   term list -> thm list -> thm list -> Proof.context -> thm list
val define_raw_bns = fn:
   raw_dt_info ->
     (binding * typ option * mixfix) list ->
       Specification.multi_specs ->
         local_theory ->
           term list * thm list * bn_info list * thm list * local_theory
val define_raw_fvs = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         Proof.context ->
           term list * term list * thm list * thm list * local_theory
val define_raw_bn_perms = fn:
   raw_dt_info ->
     bn_info list -> local_theory -> term list * thm list * local_theory
val is_recursive_binder = fn: bclause -> bool
val define_raw_perms = fn:
   raw_dt_info ->
     local_theory -> (term list * thm list * thm list) * local_theory
### ML warning (line 385 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
### ML warning (line 604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Value identifier (alpha_bn_names) has not been referenced.
### ML warning (line 604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Value identifier (alpha_names) has not been referenced.
### ML warning (line 828 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_ALPHA =
  sig
    val alpha_prove:
       term list ->
         (term * (term * term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val comb_binders:
       Proof.context ->
         bmode -> term list -> (term option * int) list -> term
    val define_raw_alpha:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             term list -> Proof.context -> alpha_result * local_theory
    val induct_prove:
       typ list ->
         (typ * (term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val mk_alpha_permute_rsp: Proof.context -> thm -> thm
    val mk_funs_rsp: Proof.context -> thm -> thm
    val raw_alpha_bn_rsp: alpha_result -> thm list -> thm list -> thm list
    val raw_constrs_rsp:
       Proof.context ->
         alpha_result -> term list list -> thm list -> thm list list
    val raw_fv_bn_rsp_aux:
       Proof.context ->
         alpha_result ->
           term list -> term list -> term list -> thm list -> thm list
    val raw_perm_bn_rsp:
       Proof.context -> alpha_result -> term list -> thm list -> thm list
    val raw_prove_alpha_distincts:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_alpha_eq_iff:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_bn_imp: Proof.context -> alpha_result -> thm list
    val raw_prove_equivp:
       Proof.context ->
         alpha_result ->
           thm list -> thm list -> thm list -> thm list * thm list
    val raw_prove_refl: Proof.context -> alpha_result -> thm -> thm list
    val raw_prove_sym: Proof.context -> alpha_result -> thm list -> thm list
    val raw_prove_trans:
       Proof.context -> alpha_result -> thm list -> thm list -> thm list
    val raw_size_rsp_aux:
       Proof.context -> alpha_result -> thm list -> thm list
  end
structure Nominal_Dt_Alpha: NOMINAL_DT_ALPHA
val raw_size_rsp_aux = fn:
   Proof.context -> alpha_result -> thm list -> thm list
val induct_prove = fn:
   typ list ->
     (typ * (term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_prove_refl = fn: Proof.context -> alpha_result -> thm -> thm list
val raw_prove_trans = fn:
   Proof.context -> alpha_result -> thm list -> thm list -> thm list
val raw_fv_bn_rsp_aux = fn:
   Proof.context ->
     alpha_result ->
       term list -> term list -> term list -> thm list -> thm list
val raw_perm_bn_rsp = fn:
   Proof.context -> alpha_result -> term list -> thm list -> thm list
val alpha_prove = fn:
   term list ->
     (term * (term * term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_alpha_bn_rsp = fn: alpha_result -> thm list -> thm list -> thm list
val define_raw_alpha = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         term list -> Proof.context -> alpha_result * local_theory
val raw_prove_alpha_distincts = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val comb_binders = fn:
   Proof.context -> bmode -> term list -> (term option * int) list -> term
val raw_prove_equivp = fn:
   Proof.context ->
     alpha_result -> thm list -> thm list -> thm list -> thm list * thm list
val raw_constrs_rsp = fn:
   Proof.context ->
     alpha_result -> term list list -> thm list -> thm list list
val raw_prove_alpha_eq_iff = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val mk_alpha_permute_rsp = fn: Proof.context -> thm -> thm
val mk_funs_rsp = fn: Proof.context -> thm -> thm
val raw_prove_bn_imp = fn: Proof.context -> alpha_result -> thm list
val raw_prove_sym = fn:
   Proof.context -> alpha_result -> thm list -> thm list
### theory "Nominal2.Nominal2"
### 0.667s elapsed time, 2.330s cpu time, 0.119s GC time
*** Failed to load theory "Incompleteness.SyntaxN" (unresolved "Nominal2.Nominal2")
*** Failed to load theory "Incompleteness.Coding" (unresolved "Incompleteness.SyntaxN")
*** Failed to load theory "Incompleteness.Predicates" (unresolved "Incompleteness.SyntaxN")
*** Failed to load theory "Incompleteness.Sigma" (unresolved "Incompleteness.Predicates")
*** Failed to load theory "Incompleteness.Coding_Predicates" (unresolved "Incompleteness.Coding", "Incompleteness.Sigma")
*** Failed to load theory "Incompleteness.Functions" (unresolved "Incompleteness.Coding_Predicates")
*** Failed to load theory "Incompleteness.Pf_Predicates" (unresolved "Incompleteness.Coding_Predicates")
*** Failed to load theory "Incompleteness.Goedel_I" (unresolved "Incompleteness.Functions", "Incompleteness.Pf_Predicates")
*** Failed to load theory "Incompleteness.II_Prelims" (unresolved "Incompleteness.Pf_Predicates")
*** Failed to load theory "Incompleteness.Pseudo_Coding" (unresolved "Incompleteness.II_Prelims")
*** Failed to load theory "Incompleteness.Quote" (unresolved "Incompleteness.Pseudo_Coding")
*** Failed to load theory "Incompleteness.Goedel_II" (unresolved "Incompleteness.Goedel_I", "Incompleteness.Quote")
*** ML error (line 210 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_quot.ML"):
*** Value or constructor (auto_fixes) has not been declared in structure Variable
*** At command "ML_file" (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/Nominal2.thy")

==========
Irrationality_J_Hancl
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "HOL-Library.Code_Target_Int" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
Loading theory "HOL-Library.Lattice_Algebras" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
Loading theory "HOL-Library.Log_Nat" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
### theory "HOL-Library.Code_Abstract_Nat"
### 0.040s elapsed time, 0.271s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### 1 \<equiv> Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l \<equiv> ?l
### Code generator: dropping subsumed code equation
### ?k + 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m \<equiv> Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m \<equiv> Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n \<equiv> Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n \<equiv> Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n \<equiv> Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n \<equiv> Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l \<equiv> - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) \<equiv> Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) \<equiv> Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n \<equiv> Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n \<equiv> Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k * 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n \<equiv> - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n \<equiv> fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One \<equiv> - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One \<equiv> ?k
### Code generator: dropping subsumed code equation
### 0 div ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k div 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n \<equiv> - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n \<equiv>
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n \<equiv>
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n \<equiv> snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One \<equiv> 0
### Code generator: dropping subsumed code equation
### 0 mod ?k \<equiv> 0
### Code generator: dropping subsumed code equation
### ?k mod 0 \<equiv> ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k \<equiv> True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) \<equiv> equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) \<equiv> False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Neg ?l \<equiv> ?l \<le> ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k \<le> 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> Int.Pos ?l \<equiv> ?k \<le> ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k \<le> 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 \<le> Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 \<le> 0 \<equiv> True
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l \<equiv> ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 \<equiv> True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l \<equiv> ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l \<equiv> False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l \<equiv> True
### Code generator: dropping subsumed code equation
### 0 < 0 \<equiv> False
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### if ?n = 0 \<or> ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) \<equiv>
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) \<equiv>
### if ?m \<le> ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) \<equiv>
### case divmod ?m ?n of (q, r) \<Rightarrow> (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) \<equiv> (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) num.One \<equiv> (numeral (num.Bit1 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) num.One \<equiv> (numeral (num.Bit0 ?m), 0)
### Code generator: dropping subsumed code equation
### divmod num.One num.One \<equiv> (Numeral1, 0)
### Code generator: dropping subsumed code equation
### Suc ?m \<le> ?n \<equiv> ?m < ?n
### Code generator: dropping subsumed code equation
### 0 \<le> ?n \<equiv> True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n \<equiv> ?m \<le> ?n
### Code generator: dropping subsumed code equation
### ?n < 0 \<equiv> False
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
### theory "HOL-Library.Log_Nat"
### 0.154s elapsed time, 1.159s cpu time, 0.044s GC time
### Code generator: dropping subsumed code equation
### of_nat ?n \<equiv>
### semiring_1_class.of_nat_aux (\<lambda>i. i + (1::?'a)) ?n (0::?'a)
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) \<equiv> numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 \<equiv> 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) \<equiv> - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) \<equiv> nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 \<equiv> 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) \<equiv> 0
### theory "HOL-Library.Code_Target_Nat"
### 0.150s elapsed time, 1.121s cpu time, 0.091s GC time
### theory "HOL-Library.Code_Target_Int"
### 0.198s elapsed time, 1.475s cpu time, 0.091s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation")
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
### theory "HOL-Library.Code_Target_Numeral"
### 0.118s elapsed time, 0.921s cpu time, 0.027s GC time
### Ignoring duplicate rewrite rule:
### of_nat (?m1 * ?n1) \<equiv> of_nat ?m1 * of_nat ?n1
### ML warning (line 19 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 18 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
locale linorder_stupid_syntax
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_stupid_syntax less_eq less"
locale linorder_no_ub
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
locale linorder_no_lb
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
locale constr_dense_linorder
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and between :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 81 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (xT) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.min (\<le>)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.max (\<le>)) ?xs ?x
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 1.322s elapsed time, 5.682s cpu time, 0.714s GC time
### Ignoring duplicate rewrite rule:
### sup ?x1 (sup ?x1 ?y1) \<equiv> sup ?x1 ?y1
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "\<And>a. \<bar>a\<bar> = sup a (- a)"
### theory "HOL-Library.Lattice_Algebras"
### 2.657s elapsed time, 7.746s cpu time, 0.799s GC time
Loading theory "HOL-Library.Interval" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
Loading theory "HOL-Library.Float" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float \<Rightarrow> float
  abs_float == abs :: float \<Rightarrow> float
  uminus_float == uminus :: float \<Rightarrow> float
  one_float == one_class.one :: float
  times_float == times :: float \<Rightarrow> float \<Rightarrow> float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float \<Rightarrow> float \<Rightarrow> float
  less_eq_float == less_eq :: float \<Rightarrow> float \<Rightarrow> bool
  less_float == less :: float \<Rightarrow> float \<Rightarrow> bool
  plus_float == plus :: float \<Rightarrow> float \<Rightarrow> float
  equal_float == equal_class.equal ::
    float \<Rightarrow> float \<Rightarrow> bool
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
  less_interval == less ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> bool
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float \<Rightarrow> float \<Rightarrow> float
  sup_float == sup :: float \<Rightarrow> float \<Rightarrow> float
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  interval :: (linordered_semiring) times
  times_interval == times ::
    'a interval \<Rightarrow> 'a interval \<Rightarrow> 'a interval
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> (float \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### Ignoring duplicate rewrite rule:
### ?i1 \<in> {?l1..?u1} \<equiv> ?l1 \<le> ?i1 \<and> ?i1 \<le> ?u1
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
### Metis: Unused theorems: "Lattices.linorder_class.min.left_commute"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 \<equiv> ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) \<equiv> ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 \<equiv> ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) \<equiv> ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 - ?c1 \<equiv> ?a1 - (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + (?b1 - ?c1) \<equiv> ?a1 + ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 = ?c1 \<equiv> ?a1 = ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 = ?c1 - ?b1 \<equiv> ?a1 + ?b1 = ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - (?b1 - ?c1) \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 + ?c1 \<equiv> ?a1 + ?c1 - ?b1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 < ?c1 \<equiv> ?a1 < ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 < ?c1 - ?b1 \<equiv> ?a1 + ?b1 < ?c1
### Ignoring duplicate rewrite rule:
### ?a1 - ?b1 \<le> ?c1 \<equiv> ?a1 \<le> ?c1 + ?b1
### Ignoring duplicate rewrite rule:
### ?a1 \<le> ?c1 - ?b1 \<equiv> ?a1 + ?b1 \<le> ?c1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set \<Rightarrow> bool
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a interval \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### theory "HOL-Library.Interval"
### 1.955s elapsed time, 12.358s cpu time, 1.304s GC time
### theory "HOL-Library.Float"
### 1.949s elapsed time, 12.360s cpu time, 1.259s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Rewrite rule not in simpset:
### power_down ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1
### then truncate_down (Suc ?p1) ((power_down ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_down (Suc ?p1) (?x1 * power_down ?p1 ?x1 ?n1)
### Ignoring duplicate rewrite rule:
### power_up ?p1 ?x1 0 \<equiv> 1
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<le> ?a1 * ?b1 \<equiv>
### (0::?'a1) \<le> ?a1 \<and> (0::?'a1) \<le> ?b1 \<or>
### ?a1 \<le> (0::?'a1) \<and> ?b1 \<le> (0::?'a1)
### Rewrite rule not in simpset:
### power_up ?p1 ?x1 (Suc ?n1) \<equiv>
### if odd ?n1 then truncate_up ?p1 ((power_up ?p1 ?x1 (Suc ?n1 div 2))\<^sup>2)
### else truncate_up ?p1 (?x1 * power_up ?p1 ?x1 ?n1)
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "length <*mlex*> {}"
### theory "HOL-Library.Interval_Float"
### 1.027s elapsed time, 8.009s cpu time, 0.304s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl" via "HOL-Decision_Procs.Approximation")
consts
  horner ::
    "(nat \<Rightarrow> nat)
     \<Rightarrow> (nat \<Rightarrow> nat \<Rightarrow> nat)
                   \<Rightarrow> nat
                                 \<Rightarrow> nat
         \<Rightarrow> nat \<Rightarrow> real \<Rightarrow> real"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 3.550s elapsed time, 20.066s cpu time, 2.275s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Irrationality_J_Hancl.Irrationality_J_Hancl")
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln ?x1 \<le> ln ?y1 \<equiv> ?x1 \<le> ?y1
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. 0) (\<lambda>x. Suc 0) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. Suc 0) (\<lambda>x. 0) <*mlex*>
   case_sum (\<lambda>p. size (fst (snd (snd p))))
    (\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 204 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 18.343s elapsed time, 46.635s cpu time, 9.068s GC time
Loading theory "Irrationality_J_Hancl.Irrationality_J_Hancl"
### Ambiguous input (line 41 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater"
###       ("_constrain" ("_position" x) ("_type_name" real))
###       ("\<^const>Groups.one_class.one")))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" filterlim)
###       ("_cargs" ("_applC" ("_vec_type") ("_position" x))
###         ("_cargs" ("_position" at_top) ("_position" sequentially))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater"
###       ("_constrain" ("_position" x) ("_type_name" real))
###       ("\<^const>Groups.one_class.one")))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" filterlim)
###       ("_cargs"
###         ("_applC" ("\<^const>Power.power_class.power") ("_position" x))
###         ("_cargs" ("_position" at_top) ("_position" sequentially))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 91 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("\<^const>Power.power_class.power"
###         ("_Numeral" ("_constify" ("_position" 2)))
###         ("_applC" ("_position" Suc) ("_position" n))))
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("_vec_type")
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###             ("_applC" ("_position" Suc) ("_position" n))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("\<^const>Power.power_class.power"
###         ("_Numeral" ("_constify" ("_position" 2)))
###         ("_applC" ("_position" Suc) ("_position" n))))
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("\<^const>Power.power_class.power")
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###             ("_applC" ("_position" Suc) ("_position" n))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 92 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_from_to_prod" ("_position" j) ("_position" s)
###       ("_applC" ("_position" Suc) ("_position" n))
###       ("\<^const>Transcendental.powr" ("_position" a)
###         ("\<^const>Power.power_class.power"
###           ("_Numeral" ("_constify" ("_position" 2))) ("_position" j))))
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("_vec_type")
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###             ("_applC" ("_position" Suc) ("_position" n))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_from_to_prod" ("_position" j) ("_position" s)
###       ("_applC" ("_position" Suc) ("_position" n))
###       ("\<^const>Transcendental.powr" ("_position" a)
###         ("\<^const>Power.power_class.power"
###           ("_Numeral" ("_constify" ("_position" 2))) ("_position" j))))
###     ("\<^const>Transcendental.powr" ("_position" a)
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("\<^const>Power.power_class.power")
###             ("_Numeral" ("_constify" ("_position" 2))))
###           ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###             ("_applC" ("_position" Suc) ("_position" n))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Irrationality_J_Hancl.Irrationality_J_Hancl"
### 0.668s elapsed time, 2.472s cpu time, 0.138s GC time
*** Failed to apply proof method (line 791 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy"):
*** using this:
***   (\<lambda>n.
***       real_of_int (b (n + 1)) / real_of_int (a (n + 1)) /
***       (real_of_int (b n) / real_of_int (a n)))
***   \<longlonglongrightarrow> 0
*** goal (1 subgoal):
***  1. (\<lambda>n.
***         norm (real_of_int (b (Suc n)) / real_of_int (a (Suc n))) /
***         norm (real_of_int (b n) / real_of_int (a n)))
***     \<longlonglongrightarrow> 0
*** At command "apply" (line 791 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** Failed to apply initial proof method (line 1041 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy"):
*** goal:
*** No subgoals!
*** At command "by" (line 1041 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ambiguous input (line 532 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less"
###     ("_applC" ("_position" sum)
###       ("_cargs"
###         ("_applC" ("_vec_type") ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###           ("_position" n))))
###     ("\<^const>Power.power_class.power"
###       ("_constrain" ("_Numeral" ("_constify" ("_position" 2)))
###         ("_type_name" real))
###       ("\<^const>Groups.plus_class.plus" ("_position" n)
###         ("\<^const>Groups.one_class.one")))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Orderings.ord_class.less"
###     ("_applC" ("_position" sum)
###       ("_cargs"
###         ("_applC" ("\<^const>Power.power_class.power")
###           ("_Numeral" ("_constify" ("_position" 2))))
###         ("\<^const>Set_Interval.ord_class.atLeastAtMost" ("_position" s)
###           ("_position" n))))
###     ("\<^const>Power.power_class.power"
###       ("_constrain" ("_Numeral" ("_constify" ("_position" 2)))
###         ("_type_name" real))
###       ("\<^const>Groups.plus_class.plus" ("_position" n)
###         ("\<^const>Groups.one_class.one")))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
*** Undefined fact: "linordered_field_class.sign_simps" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** At command "by" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** At command "by" (line 438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** Failed to apply initial proof method (line 1041 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy"):
*** goal:
*** No subgoals!
*** At command "by" (line 1041 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")
*** Failed to apply proof method (line 791 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy"):
*** using this:
***   (\<lambda>n.
***       real_of_int (b (n + 1)) / real_of_int (a (n + 1)) /
***       (real_of_int (b n) / real_of_int (a n)))
***   \<longlonglongrightarrow> 0
*** goal (1 subgoal):
***  1. (\<lambda>n.
***         norm (real_of_int (b (Suc n)) / real_of_int (a (Suc n))) /
***         norm (real_of_int (b n) / real_of_int (a n)))
***     \<longlonglongrightarrow> 0
*** At command "apply" (line 791 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy")

==========
Jacobson_Basic_Algebra
Loading theory "HOL-Library.FuncSet" (required by "Jacobson_Basic_Algebra.Ring_Theory" via "Jacobson_Basic_Algebra.Group_Theory" via "Jacobson_Basic_Algebra.Set_Theory")
### theory "HOL-Library.FuncSet"
### 0.351s elapsed time, 1.800s cpu time, 0.099s GC time
Loading theory "Jacobson_Basic_Algebra.Set_Theory" (required by "Jacobson_Basic_Algebra.Ring_Theory" via "Jacobson_Basic_Algebra.Group_Theory")
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale map
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "map \<alpha> S T"
locale surjective_map
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "surjective_map \<alpha> S T"
locale injective_map
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "injective_map \<alpha> S T"
locale bijective
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "bijective \<alpha> S T"
locale bijective_map
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "bijective_map \<alpha> S T"
locale map
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "map \<alpha> S T"
locale equivalence
  fixes S :: "'a set"
    and E :: "('a \<times> 'a) set"
  assumes "equivalence S E"
locale partition
  fixes S :: "'a set"
    and P :: "'a set set"
  assumes "partition S P"
locale equivalence
  fixes S :: "'a set"
    and E :: "('a \<times> 'a) set"
  assumes "equivalence S E"
locale partition
  fixes S :: "'a set"
    and P :: "'a set set"
  assumes "partition S P"
locale equivalence
  fixes S :: "'a set"
    and E :: "('a \<times> 'a) set"
  assumes "equivalence S E"
locale equivalence
  fixes S :: "'a set"
    and E :: "('a \<times> 'a) set"
  assumes "equivalence S E"
locale fiber_relation_notation
  fixes S :: "'a set"
locale fiber_relation
  fixes \<alpha> :: "'a \<Rightarrow> 'b"
    and S :: "'a set"
    and T :: "'b set"
  assumes "fiber_relation \<alpha> S T"
### theory "Jacobson_Basic_Algebra.Set_Theory"
### 0.340s elapsed time, 2.177s cpu time, 0.071s GC time
Loading theory "Jacobson_Basic_Algebra.Group_Theory" (required by "Jacobson_Basic_Algebra.Ring_Theory")
locale Group_Theory.monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "monoid M (\<cdot>) \<one>"
locale submonoid
  fixes N :: "'a set"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "submonoid N M (\<cdot>) \<one>"
locale transformations
  fixes S :: "'a set"
locale transformation_monoid
  fixes M :: "('a \<Rightarrow> 'a) set"
    and S :: "'a set"
  assumes "transformation_monoid M S"
locale Group_Theory.monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "monoid M (\<cdot>) \<one>"
locale submonoid
  fixes N :: "'a set"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "submonoid N M (\<cdot>) \<one>"
locale Group_Theory.group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "group G (\<cdot>) \<one>"
locale subgroup
  fixes G :: "'a set"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup G M (\<cdot>) \<one>"
locale Group_Theory.monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "monoid M (\<cdot>) \<one>"
locale transformations
  fixes S :: "'a set"
locale transformation_group
  fixes G :: "('a \<Rightarrow> 'a) set"
    and S :: "'a set"
  assumes "transformation_group G S"
locale monoid_isomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_isomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale monoid_isomorphism'
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_isomorphism' \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale monoid_isomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_isomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale left_translations_of_monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "left_translations_of_monoid M (\<cdot>) \<one>"
locale Group_Theory.monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "monoid M (\<cdot>) \<one>"
locale left_translations_of_group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "left_translations_of_group G (\<cdot>) \<one>"
locale Group_Theory.group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "group G (\<cdot>) \<one>"
locale right_translations_of_group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "right_translations_of_group G (\<cdot>) \<one>"
locale commutative_monoid
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "commutative_monoid M (\<cdot>) \<one>"
locale abelian_group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "abelian_group G (\<cdot>) \<one>"
locale transformation_group
  fixes G :: "('a \<Rightarrow> 'a) set"
    and S :: "'a set"
  assumes "transformation_group G S"
locale monoid_isomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_isomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale coset_notation
  fixes
    composition :: "'a \<Rightarrow> 'b \<Rightarrow> 'c"
      (infixl \<open>\<cdot>\<close> 70)
locale subgroup_of_group
  fixes H :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup_of_group H G (\<cdot>) \<one>"
locale subgroup
  fixes G :: "'a set"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup G M (\<cdot>) \<one>"
locale Group_Theory.group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "group G (\<cdot>) \<one>"
locale subgroup_of_group
  fixes H :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup_of_group H G (\<cdot>) \<one>"
locale monoid_congruence
  fixes M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and E :: "('a \<times> 'a) set"
  assumes "monoid_congruence M (\<cdot>) \<one> E"
locale group_congruence
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and E :: "('a \<times> 'a) set"
  assumes "group_congruence G (\<cdot>) \<one> E"
locale normal_subgroup
  fixes K :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "normal_subgroup K G (\<cdot>) \<one>"
locale subgroup_of_group
  fixes H :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup_of_group H G (\<cdot>) \<one>"
locale group_congruence
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and E :: "('a \<times> 'a) set"
  assumes "group_congruence G (\<cdot>) \<one> E"
locale normal_subgroup
  fixes K :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "normal_subgroup K G (\<cdot>) \<one>"
locale Group_Theory.group
  fixes G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "group G (\<cdot>) \<one>"
locale normal_subgroup
  fixes K :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "normal_subgroup K G (\<cdot>) \<one>"
locale subgroup_of_abelian_group
  fixes H :: "'a set"
    and G :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
  assumes "subgroup_of_abelian_group H G (\<cdot>) \<one>"
locale monoid_homomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_homomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale monoid_epimorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_epimorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale monoid_monomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_monomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
locale monoid_homomorphism
  fixes \<eta> :: "'a \<Rightarrow> 'b"
    and M :: "'a set"
    and
    composition :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and unit :: "'a"  (\<open>\<one>\<close>)
    and M' :: "'b set"
    and
    composition' :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixl \<open>\<cdot>''\<close> 70)
    and unit' :: "'b"  (\<open>\<one>''\<close>)
  assumes
    "monoid_homomorphism \<eta> M (\<cdot>) \<one> M' (\<cdot>') \<one>'"
### theory "Jacobson_Basic_Algebra.Group_Theory"
### 2.324s elapsed time, 11.517s cpu time, 0.821s GC time
*** Failed to load theory "Jacobson_Basic_Algebra.Ring_Theory" (unresolved "Jacobson_Basic_Algebra.Group_Theory")
*** Ambiguous input (line 1347 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Jacobson_Basic_Algebra/Group_Theory.thy") produces 2 parse trees:
*** ("\<^const>HOL.Trueprop"
***   ("\<^const>local.source.invertible" ("_position" a)))
*** ("\<^const>HOL.Trueprop"
***   ("\<^const>local.target.invertible" ("_position" a)))
*** Ambiguous input
*** 2 terms are type correct:
*** (invertible (a::<position>))
*** (invertible(a::<position>))
*** Failed to parse prop
*** At command "theorem" (line 1346 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Jacobson_Basic_Algebra/Group_Theory.thy")

==========
KD_Tree
Loading theory "KD_Tree.KDTree"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "KD_Tree.KDTree"
### 0.718s elapsed time, 1.447s cpu time, 0.099s GC time
Loading theory "KD_Tree.Nearest_Neighbors"
Loading theory "KD_Tree.Range_Search"
Loading theory "KD_Tree.Balanced"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### theory "KD_Tree.Nearest_Neighbors"
### 0.396s elapsed time, 2.905s cpu time, 0.598s GC time
### theory "KD_Tree.Range_Search"
### 0.409s elapsed time, 2.997s cpu time, 0.598s GC time
Found termination order:
  "(\<lambda>p. size_list length (snd (snd p))) <*mlex*> {}"
### theory "KD_Tree.Balanced"
### 0.605s elapsed time, 4.553s cpu time, 0.663s GC time
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
### Metis: Unused theorems: "Orderings.order_class.dual_order.refl", "List.in_set_takeD", "List.in_set_dropD", "Balanced.partition_filter_2", "Balanced.partition_filter_3"
### Metis: Unused theorems: "Orderings.order_class.le_less", "List.in_set_dropD", "Balanced.partition_filter_1", "Balanced.partition_filter_3"
### Metis: Unused theorems: "Orderings.order_class.le_less", "List.in_set_takeD", "Balanced.partition_filter_1", "Balanced.partition_filter_3"
### Metis: Unused theorems: "Orderings.order_class.dual_order.refl", "List.in_set_takeD", "List.in_set_dropD", "Balanced.partition_filter_1", "Balanced.partition_filter_2"
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
### Metis: Unused theorems: "Orderings.linorder_class.not_le_imp_less"
### Metis: Unused theorems: "Orderings.linorder_class.not_le_imp_less"
*** Interrupt

==========
Laplace_Transform
Loading theory "Laplace_Transform.Laplace_Transform_Library" (required by "Laplace_Transform.Laplace_Transform" via "Laplace_Transform.Existence" via "Laplace_Transform.Piecewise_Continuous")
Loading theory "Laplace_Transform.Lerch_Lemma" (required by "Laplace_Transform.Laplace_Transform" via "Laplace_Transform.Uniqueness")
### theory "Laplace_Transform.Lerch_Lemma"
### 0.029s elapsed time, 0.096s cpu time, 0.000s GC time
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Laplace_Transform.Laplace_Transform_Library"
### 0.132s elapsed time, 0.560s cpu time, 0.022s GC time
Loading theory "Laplace_Transform.Piecewise_Continuous" (required by "Laplace_Transform.Laplace_Transform" via "Laplace_Transform.Existence")
### Ignoring duplicate rewrite rule:
### eventually ((\<le>) ?c1) at_top \<equiv> True
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** At command "by" (line 165 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Metis: Falling back on "metis (mono_tags)"...
*** Undefined fact: "sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")
*** At command "apply" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")
### theory "Laplace_Transform.Piecewise_Continuous"
### 0.329s elapsed time, 2.247s cpu time, 0.079s GC time
Loading theory "Laplace_Transform.Existence" (required by "Laplace_Transform.Laplace_Transform")
*** Failed to apply initial proof method (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Piecewise_Continuous.thy"):
*** using this:
***   \<lbrakk>a < ?i; ?i \<le> b\<rbrakk>
***   \<Longrightarrow> \<forall>\<^sub>F x in at_left ?i. f x = g x
***   \<lbrakk>?i \<in> I; a < ?i; ?i \<le> b\<rbrakk>
***   \<Longrightarrow> (f \<longlongrightarrow> l ?i) (at_left ?i)
*** goal (1 subgoal):
***  1. \<lbrakk>i \<in> I; a < i; i \<le> b\<rbrakk>
***     \<Longrightarrow> (g \<longlongrightarrow> l i) (at_left i)
*** At command "by" (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Piecewise_Continuous.thy")
### Metis: Unused theorems: "local.that_1", "local.that_2", "Set_Interval.ord_class.greaterThanLessThan_iff"
### Ignoring duplicate rewrite rule:
### a < i \<equiv> True
### Metis: Unused theorems: "local.that_1", "local.that_2", "Set_Interval.ord_class.greaterThanLessThan_iff"
### Ignoring duplicate rewrite rule:
### i < b \<equiv> True
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Laplace_Transform.Existence"
### 0.367s elapsed time, 2.800s cpu time, 0.142s GC time
Loading theory "Laplace_Transform.Uniqueness" (required by "Laplace_Transform.Laplace_Transform")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### eventually ((\<le>) ?c1) at_top \<equiv> True
*** Failed to apply initial proof method (line 160 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** using this:
***   \<forall>\<^sub>F k in at_top.
***      local.laplace_integrand s t =
***      indicat_real {A..k} t *\<^sub>R local.laplace_integrand s t
***   ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** goal (1 subgoal):
***  1. ((\<lambda>k.
***          indicat_real {A..k} t *\<^sub>R
***          local.laplace_integrand s t) \<longlongrightarrow>
***      local.laplace_integrand s t)
***      at_top
*** At command "by" (line 160 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### theory "Laplace_Transform.Uniqueness"
### 0.309s elapsed time, 2.358s cpu time, 0.082s GC time
Loading theory "Laplace_Transform.Laplace_Transform"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### theory "Laplace_Transform.Laplace_Transform"
### 0.042s elapsed time, 0.292s cpu time, 0.026s GC time
### Metis: Unused theorems: "Complex.scaleR_complex.sel_1"
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** At command "apply" (line 311 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
SMT: Solver z3: Counterexample found (possibly spurious)
*** Failed to apply initial proof method (line 626 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. I t = integral {a..t0} f + integral {t0..t} f
*** At command "by" (line 626 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate rewrite rule:
### interior {?a1..?b1} \<equiv> {?a1<..<?b1}
### Ignoring duplicate rewrite rule:
### eventually ((<) ?c1) at_top \<equiv> True
*** Failed to apply initial proof method (line 462 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..k}.
***      f x = (if x \<le> 0 then f0 else f x)
***   (f \<longlongrightarrow> f x) (at x within {0..k})
*** goal (1 subgoal):
***  1. ((\<lambda>x. if x \<le> 0 then f0 else f x) \<longlongrightarrow> f x)
***      (at x within {0..k})
*** At command "by" (line 462 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### eventually ((<) ?c1) at_top \<equiv> True
*** Failed to apply proof method (line 726 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. i \<noteq> y \<Longrightarrow>
***     integral {a..y} f = integral {a..i} f + integral {i..y} f
*** At command "apply" (line 726 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
*** Failed to apply proof method (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; i < x'; x' < b; x' \<notin> I\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
*** Failed to apply proof method (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; i < x'; x' < b; x' \<notin> I\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** At command "by" (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** Failed to apply initial proof method (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Uniqueness.thy"):
*** using this:
***   \<forall>\<^sub>F b in at_top.
***      I (complex_of_real (s0 + real (Suc n))) b =
***      integral {exp (- b)..1}
***       (\<lambda>u.
***           u ^ n *\<^sub>R (complex_of_real (u powr s0) * f (- ln u)))
***   (I (complex_of_real (s0 + real (Suc n))) \<longlongrightarrow> 0) at_top
*** goal (1 subgoal):
***  1. ((\<lambda>b.
***          integral {exp (- b)..1}
***           (\<lambda>u.
***               u ^ n *\<^sub>R
***               (complex_of_real (u powr s0) *
***                f (- ln u)))) \<longlongrightarrow>
***      0)
***      at_top
*** At command "by" (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Uniqueness.thy")
*** Failed to apply proof method (line 897 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; x \<le> x'; x' \<le> b\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 897 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply proof method (line 897 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; x \<le> x'; x' \<le> b\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 897 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply initial proof method (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Uniqueness.thy"):
*** using this:
***   \<forall>\<^sub>F b in at_top.
***      I (complex_of_real (s0 + real (Suc n))) b =
***      integral {exp (- b)..1}
***       (\<lambda>u.
***           u ^ n *\<^sub>R (complex_of_real (u powr s0) * f (- ln u)))
***   (I (complex_of_real (s0 + real (Suc n))) \<longlongrightarrow> 0) at_top
*** goal (1 subgoal):
***  1. ((\<lambda>b.
***          integral {exp (- b)..1}
***           (\<lambda>u.
***               u ^ n *\<^sub>R
***               (complex_of_real (u powr s0) *
***                f (- ln u)))) \<longlongrightarrow>
***      0)
***      at_top
*** At command "by" (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Uniqueness.thy")
*** Failed to apply proof method (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; i < x'; x' < b; x' \<notin> I\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** At command "by" (line 846 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply proof method (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. \<And>x'.
***        \<lbrakk>dist x' x < 1; i < x'; x' < b; x' \<notin> I\<rbrakk>
***        \<Longrightarrow> integral {a..i} f + integral {i..x'} f =
***                          integral {a..x'} f
*** At command "apply" (line 862 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply proof method (line 726 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. i \<noteq> y \<Longrightarrow>
***     integral {a..y} f = integral {a..i} f + integral {i..y} f
*** At command "apply" (line 726 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply initial proof method (line 462 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..k}.
***      f x = (if x \<le> 0 then f0 else f x)
***   (f \<longlongrightarrow> f x) (at x within {0..k})
*** goal (1 subgoal):
***  1. ((\<lambda>x. if x \<le> 0 then f0 else f x) \<longlongrightarrow> f x)
***      (at x within {0..k})
*** At command "by" (line 462 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply initial proof method (line 626 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** goal (1 subgoal):
***  1. I t = integral {a..t0} f + integral {t0..t} f
*** At command "by" (line 626 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** At command "apply" (line 311 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply initial proof method (line 160 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy"):
*** using this:
***   \<forall>\<^sub>F k in at_top.
***      local.laplace_integrand s t =
***      indicat_real {A..k} t *\<^sub>R local.laplace_integrand s t
***   ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** goal (1 subgoal):
***  1. ((\<lambda>k.
***          indicat_real {A..k} t *\<^sub>R
***          local.laplace_integrand s t) \<longlongrightarrow>
***      local.laplace_integrand s t)
***      at_top
*** At command "by" (line 160 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Existence.thy")
*** Failed to apply initial proof method (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Piecewise_Continuous.thy"):
*** using this:
***   \<lbrakk>a < ?i; ?i \<le> b\<rbrakk>
***   \<Longrightarrow> \<forall>\<^sub>F x in at_left ?i. f x = g x
***   \<lbrakk>?i \<in> I; a < ?i; ?i \<le> b\<rbrakk>
***   \<Longrightarrow> (f \<longlongrightarrow> l ?i) (at_left ?i)
*** goal (1 subgoal):
***  1. \<lbrakk>i \<in> I; a < i; i \<le> b\<rbrakk>
***     \<Longrightarrow> (g \<longlongrightarrow> l i) (at_left i)
*** At command "by" (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Piecewise_Continuous.thy")
*** Undefined fact: "sign_simps" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")
*** At command "apply" (line 211 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** PROP ?psi \<Longrightarrow> PROP ?psi
*** ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
*** At command "by" (line 165 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy")

==========
List_Update
Loading theory "HOL-Library.While_Combinator" (required by "List_Update.TS" via "List_Update.OPT2" via "List_Update.RExp_Var" via "Regular-Sets.Equivalence_Checking")
Loading theory "List_Update.Prob_Theory" (required by "List_Update.Move_to_Front" via "List_Update.Competitive_Analysis")
Loading theory "List_Update.Bit_Strings" (required by "List_Update.BIT")
Loading theory "List_Update.On_Off" (required by "List_Update.Move_to_Front")
Loading theory "List-Index.List_Index" (required by "List_Update.Move_to_Front" via "List_Update.Swaps" via "List_Update.Inversion")
Loading theory "Regular-Sets.Regular_Set" (required by "List_Update.TS" via "List_Update.OPT2" via "List_Update.RExp_Var" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative" via "Regular-Sets.Regular_Exp")
consts
  find_index ::
    "('a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> nat"
locale On_Off
  fixes
    step ::
      "'state
       \<Rightarrow> 'request \<Rightarrow> 'answer \<Rightarrow> 'state"
    and
    t :: "'state
          \<Rightarrow> 'request \<Rightarrow> 'answer \<Rightarrow> nat"
    and wf :: "'state \<Rightarrow> 'request list \<Rightarrow> bool"
### Missing patterns in function definition:
### \<And>a v va. T a (v # va) [] = undefined
### \<And>a v va. T a [] (v # va) = undefined
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### theory "List_Update.Bit_Strings"
### 0.189s elapsed time, 1.338s cpu time, 0.115s GC time
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
consts
  map_index' ::
    "nat
     \<Rightarrow> (nat \<Rightarrow> 'a \<Rightarrow> 'b)
                   \<Rightarrow> 'a list \<Rightarrow> 'b list"
Found termination order: "size <*mlex*> {}"
consts
  insert_nth ::
    "nat \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list"
Found termination order: "{}"
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
### theory "List-Index.List_Index"
### 0.392s elapsed time, 2.709s cpu time, 0.238s GC time
Loading theory "List_Update.Inversion" (required by "List_Update.Move_to_Front" via "List_Update.Swaps")
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
### theory "List_Update.Inversion"
### 0.044s elapsed time, 0.309s cpu time, 0.000s GC time
Loading theory "List_Update.Swaps" (required by "List_Update.Move_to_Front")
### theory "HOL-Library.While_Combinator"
### 0.448s elapsed time, 3.106s cpu time, 0.238s GC time
### theory "List_Update.Swaps"
### 0.098s elapsed time, 0.670s cpu time, 0.053s GC time
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
### theory "List_Update.Prob_Theory"
### 0.732s elapsed time, 4.872s cpu time, 0.775s GC time
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### theory "List_Update.On_Off"
### 0.932s elapsed time, 6.172s cpu time, 0.838s GC time
Loading theory "List_Update.Competitive_Analysis" (required by "List_Update.Move_to_Front")
locale On_Off
  fixes
    step ::
      "'state
       \<Rightarrow> 'request \<Rightarrow> 'answer \<Rightarrow> 'state"
    and
    t :: "'state
          \<Rightarrow> 'request \<Rightarrow> 'answer \<Rightarrow> nat"
    and wf :: "'state \<Rightarrow> 'request list \<Rightarrow> bool"
### Missing patterns in function definition:
### \<And>a v va. steps a (v # va) [] = undefined
### \<And>a v va. steps a [] (v # va) = undefined
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
datatype 'a ref = ref of 'a
ROOT.ML:16: warning: Value identifier (A_) has not been referenced.
ROOT.ML:13: warning: Value identifier (x22) has not been referenced.
ROOT.ML:13: warning: Value identifier (x21) has not been referenced.
ROOT.ML:13: warning: Value identifier (A_) has not been referenced.
ROOT.ML:12: warning: Value identifier (x22) has not been referenced.
ROOT.ML:12: warning: Value identifier (x21) has not been referenced.
ROOT.ML:12: warning: Value identifier (A_) has not been referenced.
ROOT.ML:23: warning: Value identifier (f) has not been referenced.
ROOT.ML:25: warning: Value identifier (f) has not been referenced.
ROOT.ML:28: warning: Value identifier (f) has not been referenced.
ROOT.ML:31: warning: Matches are not exhaustive.
Found near fun image f (... ...) = Set (... ... xs)
ROOT.ML:33: warning: Value identifier (y) has not been referenced.
ROOT.ML:33: warning: Value identifier (A_) has not been referenced.
ROOT.ML:39: warning: Value identifier (x) has not been referenced.
ROOT.ML:39: warning: Value identifier (A_) has not been referenced.
ROOT.ML:48: warning: Value identifier (p) has not been referenced.
ROOT.ML:56: warning: Matches are not exhaustive.
Found near fun product (Set xs) (... ...) = Set (... ... xs)
structure Generated_Code:
  sig
    val conc: 'a equal -> 'a list set -> 'a list set -> 'a list set
    type 'a equal
    type 'a set
  end
overloading
  lang_pow \<equiv> compow ::
    nat \<Rightarrow> 'a list set \<Rightarrow> 'a list set
consts
  lang_pow :: "nat \<Rightarrow> 'a list set \<Rightarrow> 'a list set"
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### set_pmf ?p1 \<inter> ?s1 \<noteq> {} \<Longrightarrow>
### set_pmf (cond_pmf ?p1 ?s1) \<equiv> set_pmf ?p1 \<inter> ?s1
### theory "Regular-Sets.Regular_Set"
### 2.410s elapsed time, 16.095s cpu time, 2.094s GC time
Loading theory "Regular-Sets.Regular_Exp" (required by "List_Update.TS" via "List_Update.OPT2" via "List_Update.RExp_Var" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative")
\<lbrakk>finite ?A;
 \<And>a.
    \<lbrakk>a \<in> set_pmf ?M; ?f a \<noteq> (0::?'b)\<rbrakk>
    \<Longrightarrow> a \<in> ?A\<rbrakk>
\<Longrightarrow> measure_pmf.expectation ?M ?f =
                  (\<Sum>a\<in>?A. pmf ?M a *\<^sub>R ?f a)
set_pmf ?p \<inter> ?s \<noteq> {} \<Longrightarrow>
pmf (cond_pmf ?p ?s) ?x =
(if ?x \<in> ?s then pmf ?p ?x / measure_pmf.prob ?p ?s else 0)
\<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
\<Longrightarrow> pmf (cond_pmf
                        (bernoulli_pmf ?p1 \<bind>
                         (\<lambda>b.
                             if b then map_pmf Inl ?Da1
                             else map_pmf Inr ?Db1))
                        {f. \<exists>e. Inl e = f})
                   ?x =
                  (if ?x \<in> {f. \<exists>e. Inl e = f}
                   then pmf (bernoulli_pmf ?p1 \<bind>
                             (\<lambda>b.
                                 if b then map_pmf Inl ?Da1
                                 else map_pmf Inr ?Db1))
                         ?x /
                        measure_pmf.prob
                         (bernoulli_pmf ?p1 \<bind>
                          (\<lambda>b.
                              if b then map_pmf Inl ?Da1
                              else map_pmf Inr ?Db1))
                         {f. \<exists>e. Inl e = f}
                   else 0)
"\<lambda>a.
    case a of Inl e \<Rightarrow> Inl (fa e)
    | Inr e \<Rightarrow> Inr (fb e)"
  :: "'a + 'b \<Rightarrow> 'c + 'd"
"(\<bind>)"
  :: "'a pmf \<Rightarrow> ('a \<Rightarrow> 'b pmf) \<Rightarrow> 'b pmf"
Found termination order: "{}"
### theory "List_Update.Competitive_Analysis"
### 1.699s elapsed time, 11.610s cpu time, 1.373s GC time
Loading theory "List_Update.Move_to_Front"
### Rule already declared as elimination (elim)
### \<lbrakk>?w \<in> ?A @@ ?B;
###  \<And>u v.
###     \<lbrakk>u \<in> ?A; v \<in> ?B; ?w = u @ v\<rbrakk>
###     \<Longrightarrow> ?thesis\<rbrakk>
### \<Longrightarrow> ?thesis
consts
  lang :: "'a rexp \<Rightarrow> 'a list set"
consts
  nullable :: "'a rexp \<Rightarrow> bool"
consts
  rexp_empty :: "'a rexp \<Rightarrow> bool"
instantiation
  rexp :: (order) order
  less_eq_rexp == less_eq ::
    'a rexp \<Rightarrow> 'a rexp \<Rightarrow> bool
  less_rexp == less :: 'a rexp \<Rightarrow> 'a rexp \<Rightarrow> bool
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
?A \<inter> set ?xs = set (filter (\<lambda>x. x \<in> ?A) ?xs)
instantiation
  rexp :: (linorder) linorder
### theory "Regular-Sets.Regular_Exp"
### 2.075s elapsed time, 12.452s cpu time, 1.607s GC time
Loading theory "Regular-Sets.NDerivative" (required by "List_Update.TS" via "List_Update.OPT2" via "List_Update.RExp_Var" via "Regular-Sets.Equivalence_Checking")
locale MTF_Off
  fixes as :: "(nat \<times> nat list) list"
    and rs :: "'a list"
    and s0 :: "'a list"
  assumes "MTF_Off as rs s0"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### theory "List_Update.Move_to_Front"
### 3.107s elapsed time, 19.538s cpu time, 3.144s GC time
Loading theory "List_Update.MTF2_Effects" (required by "List_Update.BIT")
Loading theory "List_Update.Partial_Cost_Model" (required by "List_Update.TS" via "List_Update.OPT2")
### theory "List_Update.MTF2_Effects"
### 0.226s elapsed time, 1.743s cpu time, 0.183s GC time
Loading theory "List_Update.BIT"
### theory "List_Update.Partial_Cost_Model"
### 0.259s elapsed time, 1.995s cpu time, 0.183s GC time
Loading theory "List_Update.List_Factoring" (required by "List_Update.TS")
Found termination order:
  "(\<lambda>p. size (fst p)) <*mlex*>
   (\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
### Missing patterns in function definition:
### \<And>a va vb v. steps' a (va # vb) [] (Suc v) = undefined
### \<And>a va vb v. steps' a [] (va # vb) (Suc v) = undefined
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
linarith_split_limit exceeded (current value is 9)
Found termination order: "(\<lambda>p. size_list size (fst p)) <*mlex*> {}"
locale BIT_Off
  fixes acts :: "(nat \<times> nat list) list"
    and qs :: "'a list"
    and init :: "'a list"
  assumes "BIT_Off acts qs init"
### theory "List_Update.List_Factoring"
### 1.368s elapsed time, 10.394s cpu time, 3.193s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### distinct init \<equiv> True
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
consts
  norm :: "'a rexp \<Rightarrow> 'a rexp"
consts
  nderiv :: "'a \<Rightarrow> 'a rexp \<Rightarrow> 'a rexp"
### theory "Regular-Sets.NDerivative"
### 3.468s elapsed time, 25.557s cpu time, 5.468s GC time
Loading theory "Regular-Sets.Equivalence_Checking" (required by "List_Update.TS" via "List_Update.OPT2" via "List_Update.RExp_Var")
### theory "List_Update.BIT"
### 1.996s elapsed time, 15.004s cpu time, 3.631s GC time
Loading theory "List_Update.BIT_pairwise"
Proofs for coinductive predicate(s) "bisimilar"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the coinduction rule ...
  Proving the simplification rules ...
consts
  add_atoms :: "'a rexp \<Rightarrow> 'a list \<Rightarrow> 'a list"
### theory "Regular-Sets.Equivalence_Checking"
### 0.255s elapsed time, 1.507s cpu time, 0.087s GC time
Loading theory "List_Update.RExp_Var" (required by "List_Update.TS" via "List_Update.OPT2")
Found termination order: "size <*mlex*> {}"
### theory "List_Update.BIT_pairwise"
### 0.294s elapsed time, 1.666s cpu time, 0.087s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### theory "List_Update.RExp_Var"
### 0.724s elapsed time, 3.350s cpu time, 0.360s GC time
Loading theory "List_Update.OPT2" (required by "List_Update.TS")
### Missing patterns in function definition:
### \<And>v vb vc. OPT2 (v # vb # vc) [] = undefined
### \<And>v vb vc va. OPT2 (v # vb # vc) [va] = undefined
### \<And>v vb vc va ve vg vh.
###    OPT2 (v # vb # vc) (va # ve # vg # vh) = undefined
### (6 more)
Found termination order: "(\<lambda>p. length (fst p)) <*mlex*> {}"
### theory "List_Update.OPT2"
### 1.597s elapsed time, 8.255s cpu time, 4.089s GC time
Loading theory "List_Update.Phase_Partitioning" (required by "List_Update.TS")
Found termination order: "{}"
### theory "List_Update.Phase_Partitioning"
### 0.270s elapsed time, 0.973s cpu time, 0.314s GC time
Loading theory "List_Update.BIT_2comp_on2"
Loading theory "List_Update.TS"
### theory "List_Update.BIT_2comp_on2"
### 0.818s elapsed time, 2.497s cpu time, 0.109s GC time
Found termination order: "{}"
### Introduced fixed type variable(s): 'b in "B__" or "qa__" or "xa__"
### theory "List_Update.TS"
### 1.525s elapsed time, 5.253s cpu time, 0.162s GC time
Loading theory "List_Update.Comb"
linarith_split_limit exceeded (current value is 9)
"mtf2"
  :: "nat \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list"
### theory "List_Update.Comb"
### 0.728s elapsed time, 3.753s cpu time, 0.067s GC time
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
"config'_rand BIT s0 qs"
  :: "('a list \<times> bool list \<times> 'a list) pmf"
"Inv"
  :: "'b list \<Rightarrow> 'b list \<Rightarrow> ('b \<times> 'b) set"
### Ignoring duplicate rewrite rule:
### distinct init \<equiv> True
### Ignoring duplicate rewrite rule:
### of_int (int ?n1) \<equiv> of_nat ?n1
### Introduced fixed type variable(s): 'b in "init__"
### Ignoring duplicate rewrite rule:
### distinct init \<equiv> True
### Ignoring duplicate rewrite rule:
### distinct init \<equiv> True
### Ignoring duplicate rewrite rule:
### distinct init \<equiv> True
\<lbrakk>?c \<in> ?A \<union> ?B; ?c \<in> ?A \<Longrightarrow> ?P;
 ?c \<in> ?B \<Longrightarrow> ?P\<rbrakk>
\<Longrightarrow> ?P
\<lbrakk>?c \<in> ?A \<union> ?B; ?c \<in> ?A \<Longrightarrow> ?P;
 ?c \<in> ?B \<Longrightarrow> ?P\<rbrakk>
\<Longrightarrow> ?P
\<lbrakk>?qs \<in> Lxx ?x ?y;
 ?qs \<in> lang (seq [Atom ?x, Atom ?x]) \<Longrightarrow> ?P ?x ?y ?qs;
 ?qs
 \<in> lang
        (seq [question (Atom ?x), Atom ?y, Atom ?x,
              Star (Times (Atom ?y) (Atom ?x)), Atom ?y,
              Atom ?y]) \<Longrightarrow>
 ?P ?x ?y ?qs;
 ?qs
 \<in> lang
        (seq [question (Atom ?x), Atom ?y, Atom ?x,
              Star (Times (Atom ?y) (Atom ?x)), Atom ?x]) \<Longrightarrow>
 ?P ?x ?y ?qs;
 ?qs
 \<in> lang (seq [question (Atom ?x), Atom ?y, Atom ?y]) \<Longrightarrow>
 ?P ?x ?y ?qs\<rbrakk>
\<Longrightarrow> ?P ?x ?y ?qs
"A"
  :: "(nat list \<Rightarrow> 'is) \<times>
      (nat list \<times> 'is
       \<Rightarrow> nat
                     \<Rightarrow> (nat \<times> nat list) \<times> 'is)"
\<lbrakk>?x0.0 \<noteq> ?y0.0; 0 \<le> ?c;
 set ?\<sigma> \<subseteq> {?x0.0, ?y0.0};
 ?P (map_pmf (Pair [?x0.0, ?y0.0]) (fst ?A [?x0.0, ?y0.0])) ?x0.0
  [?x0.0, ?y0.0];
 \<And>a b \<sigma> s.
    \<lbrakk>\<sigma> \<in> Lxx a b; a \<noteq> b; {a, b} = {?x0.0, ?y0.0};
     ?P s a [?x0.0, ?y0.0]; set \<sigma> \<subseteq> {a, b}\<rbrakk>
    \<Longrightarrow> T\<^sub>p_on_rand' ?A s \<sigma>
                      \<le> ?c *
                            real
                             (T\<^sub>p [a, b] \<sigma>
                               (OPT2 \<sigma> [a, b])) \<and>
                      ?P (Partial_Cost_Model.config'_rand ?A s \<sigma>)
                       (last \<sigma>) [?x0.0, ?y0.0]\<rbrakk>
\<Longrightarrow> T\<^sub>p_on_rand' ?A
                   (fst ?A [?x0.0, ?y0.0] \<bind>
                    (\<lambda>is. return_pmf ([?x0.0, ?y0.0], is)))
                   ?\<sigma>
                  \<le> ?c * real (T\<^sub>p_opt [?x0.0, ?y0.0] ?\<sigma>) +
                        ?c
real (T\<^sub>p ?s0.0 ?qs (Partial_Cost_Model.off2 ?A (?s0.0, ?x) ?qs)) =
T\<^sub>p_on_rand' (Partial_Cost_Model.embed ?A) (return_pmf (?s0.0, ?x))
 ?qs
"Partial_Cost_Model.T_on'"
  :: "('a list \<Rightarrow> 'b) \<times>
      ('a list \<times> 'b
       \<Rightarrow> 'a \<Rightarrow> (nat \<times> nat list) \<times> 'b)
      \<Rightarrow> 'a list \<times> 'b
                    \<Rightarrow> 'a list \<Rightarrow> nat"
"Partial_Cost_Model.embed"
  :: "('a list \<Rightarrow> 'b) \<times>
      ('a list \<times> 'b
       \<Rightarrow> 'a \<Rightarrow> (nat \<times> nat list) \<times> 'b)
      \<Rightarrow> ('a list \<Rightarrow> 'b pmf) \<times>
                    ('a list \<times> 'b
                     \<Rightarrow> 'a \<Rightarrow> ((nat \<times>
                nat list) \<times>
               'b) pmf)"
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?p1; ?p1 < 1\<rbrakk>
### \<Longrightarrow> set_pmf (bernoulli_pmf ?p1) \<equiv> UNIV
### Introduced fixed type variable(s): 'a in "addum__"
### Undeclared classical rule
### ?x \<notin> set ?xs \<Longrightarrow> count_list ?xs ?x = 0
"\<lambda>i. ALG'_det Strat (A @ [b]) init i y"
  :: "nat \<Rightarrow> nat"
L (concS ?M1.0 ?M2.0) = L ?M1.0 @@ L ?M2.0
L (set ?rs) = lang (verund ?rs)
L (substL (lang ?E) ?\<sigma>) = lang (subst ?E ?\<sigma>)
check_eqv ?r ?s \<Longrightarrow> lang ?r = lang ?s
lang (subst (w2rexp (?xs @ ?ys)) ?\<sigma>) =
lang (subst (w2rexp ?xs) ?\<sigma>) @@ lang (subst (w2rexp ?ys) ?\<sigma>)
check_eqv ?r ?s \<Longrightarrow> lang ?r = lang ?s
check_eqv ?r ?s \<Longrightarrow> lang ?r = lang ?s
check_eqv ?r ?s \<Longrightarrow> lang ?r = lang ?s
check_eqv ?r ?s \<Longrightarrow> lang ?r = lang ?s
### Introduced fixed type variable(s): 'b in "q__" or "s__"
### Metis: Falling back on "metis (full_types)"...
*** Type unification failed: Clash of types "_ \<Rightarrow> _" and "real"
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (=) (T\<^sub>p_on_rand' BIT s qs) :: real \<Rightarrow> bool
*** Operand:   bit :: ??'a \<Rightarrow> nat \<Rightarrow> bool
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** No coercion known for type constructors: "fun" and "real"
*** At command "lemma" (line 180 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/List_Update/Comb.thy")

==========
Lower_Semicontinuous
Loading theory "Lower_Semicontinuous.Lower_Semicontinuous"
### Ignoring duplicate rewrite rule:
### 0 < dist ?x1 ?y1 \<equiv> ?x1 \<noteq> ?y1
### Ignoring duplicate rewrite rule:
### ?x1 \<in> ball ?x1 ?e1 \<equiv> 0 < ?e1
*** Undefined fact: "tendsto_explicit" (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
*** At command "using" (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
### Metis: Unused theorems: "Lower_Semicontinuous.continuous_isCont"
### Metis: Unused theorems: "Lower_Semicontinuous.lsc_hull_ex_unique"
### theory "Lower_Semicontinuous.Lower_Semicontinuous"
### 0.655s elapsed time, 3.851s cpu time, 0.185s GC time
*** Undefined fact: "fst_linear" (line 1306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
*** At command "using" (line 1306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
### Metis: Unused theorems: "Lower_Semicontinuous.convex_on_ereal_univ"
### Metis: Unused theorems: "local.assms_2", "local.assms_3", "local.assms_4"
### Metis: Unused theorems: "local.assms_1", "local.assms_3", "local.assms_4"
### Metis: Unused theorems: "local.assms_3", "local.assms_4"
### Metis: Unused theorems: "Lower_Semicontinuous.convex_on_ereal_univ"
*** Undefined fact: "fst_linear" (line 1306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
*** At command "using" (line 1306 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
*** Undefined fact: "tendsto_explicit" (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")
*** At command "using" (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy")

==========
Lp
Loading theory "Ergodic_Theory.SG_Library_Complement" (required by "Lp.Functional_Spaces")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_derivative (\<lambda>x. x)) ?F1 \<equiv> True
### Rule already declared as introduction (intro)
### closed UNIV
### Ignoring duplicate rewrite rule:
### (id has_derivative id) (at ?a1) \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_derivative (\<lambda>x. 0::?'b1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. of_real (?g1 x)) has_derivative
###  (\<lambda>x. of_real (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x + ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x + ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) ?F1) \<Longrightarrow>
### ((\<lambda>x. \<Sum>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>x. \<Sum>i\<in>?I1. ?f'1 i x))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. - ?f1 x) has_derivative (\<lambda>x. - ?f'1 x)) ?F1 \<equiv>
### True
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) ?F1;
###  (?g1 has_derivative ?g'1) ?F1\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x - ?g1 x) has_derivative
###                    (\<lambda>x. ?f'1 x - ?g'1 x))
###                    ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x * ?g1 x) has_derivative
###                    (\<lambda>h. ?f1 ?x1 * ?g'1 h + ?f'1 h * ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?s1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?s1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x *\<^sub>R ?g1 x) has_derivative
###                    (\<lambda>h.
###                        ?f1 ?x1 *\<^sub>R ?g'1 h + ?f'1 h *\<^sub>R ?g1 ?x1))
###                    (at ?x1 within ?s1) \<equiv>
###                   True
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate rewrite rule:
### (\<And>i.
###     i \<in> ?I1 \<Longrightarrow>
###     (?f1 i has_derivative ?f'1 i) (at ?x1 within ?S1)) \<Longrightarrow>
### ((\<lambda>x. \<Prod>i\<in>?I1. ?f1 i x) has_derivative
###  (\<lambda>y.
###      \<Sum>i\<in>?I1. ?f'1 i y * (\<Prod>j\<in>?I1 - {i}. ?f1 j ?x1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate rewrite rule:
### (?f1 has_derivative ?f'1) (at ?x1 within ?S1) \<Longrightarrow>
### ((\<lambda>x. ?f1 x ^ ?n1) has_derivative
###  (\<lambda>y. of_nat ?n1 * ?f'1 y * ?f1 ?x1 ^ (?n1 - 1)))
###  (at ?x1 within ?S1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 ?x1 \<noteq> (0::?'a1);
###  (?f1 has_derivative ?f'1) (at ?x1 within ?S1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. inverse (?f1 x)) has_derivative
###                    (\<lambda>h.
###                        - (inverse (?f1 ?x1) * ?f'1 h * inverse (?f1 ?x1))))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate rewrite rule:
### \<lbrakk>(?f1 has_derivative ?f'1) (at ?x1 within ?S1);
###  (?g1 has_derivative ?g'1) (at ?x1 within ?S1);
###  ?g1 ?x1 \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f1 x / ?g1 x) has_derivative
###                    (\<lambda>h.
###                        - ?f1 ?x1 *
###                        (inverse (?g1 ?x1) * ?g'1 h * inverse (?g1 ?x1)) +
###                        ?f'1 h / ?g1 ?x1))
###                    (at ?x1 within ?S1) \<equiv>
###                   True
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable ?F1 \<equiv> True
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>finite ?s1; \<forall>a\<in>?s1. ?f1 a differentiable ?net1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. \<Sum>a\<in>?s1. ?f1 a x) differentiable
###                   ?net1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable ?F1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable ?F1; ?g1 differentiable ?F1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) differentiable ?F1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?f1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1; ?g1 ?x1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x / ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable at ?x1 within ?s1 \<Longrightarrow>
### (\<lambda>x. ?f1 x ^ ?n1) differentiable at ?x1 within ?s1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?c1) has_vector_derivative (0::?'a1)) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_vector_derivative 1) ?net1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. ?k1) has_field_derivative (0::?'a1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. x) has_field_derivative (1::?'a1)) ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (?g1 has_derivative ?g'1) ?F1 \<Longrightarrow>
### ((\<lambda>x. cnj (?g1 x)) has_derivative (\<lambda>x. cnj (?g'1 x)))
###  ?F1 \<equiv>
### True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable at ?x1 within ?s1;
###  ?g1 differentiable at ?x1 within ?s1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. (?f1 x, ?g1 x)) differentiable at ?x1
###                   within ?s1 \<equiv>
###                   True
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### id differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z * ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>z. - ?f1 z) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z + ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>z. ?f1 z - ?g1 z) differentiable_on ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1;
###  \<And>x. x \<in> ?S1 \<Longrightarrow> ?f1 x \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> (\<lambda>x. inverse (?f1 x)) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 differentiable_on ?S1; ?g1 differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ((\<lambda>x. (norm x)\<^sup>2) has_derivative
###  (\<lambda>x. 2 *\<^sub>R (?a1 \<bullet> x)))
###  (at ?a1) \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. (norm x)\<^sup>2) differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<noteq> (0::?'a1) \<Longrightarrow>
### norm differentiable at ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (0::?'a1) \<notin> ?S1 \<Longrightarrow>
### norm differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (*) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?c1) field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. z) field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### id field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (+) ?c1 field_differentiable ?F1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>z. ?a1) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x + ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### ?f1 C1_differentiable_on ?S1 \<Longrightarrow>
### (\<lambda>x. - ?f1 x) C1_differentiable_on ?S1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x - ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x * ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 C1_differentiable_on ?S1; ?g1 C1_differentiable_on ?S1\<rbrakk>
### \<Longrightarrow> (\<lambda>x. ?f1 x *\<^sub>R ?g1 x) C1_differentiable_on
###                   ?S1 \<equiv>
###                   True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale finite_borel_measure'
  fixes M :: "'a measure"
  assumes "finite_borel_measure' M"
### theory "Ergodic_Theory.SG_Library_Complement"
### 0.628s elapsed time, 4.563s cpu time, 0.246s GC time
Loading theory "Lp.Functional_Spaces"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, real_vector) real_vector
  scaleR_fun == scaleR ::
    real
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
instantiation
  quasinorm :: (real_vector) preorder
  less_eq_quasinorm == less_eq ::
    'a quasinorm \<Rightarrow> 'a quasinorm \<Rightarrow> bool
  less_quasinorm == less ::
    'a quasinorm \<Rightarrow> 'a quasinorm \<Rightarrow> bool
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
### theory "Lp.Functional_Spaces"
### 0.922s elapsed time, 6.912s cpu time, 0.291s GC time
Loading theory "Lp.Lp"
### Ignoring duplicate rewrite rule:
### ?x1 + ?y1 = (0::?'a1) \<equiv> ?x1 = (0::?'a1) \<and> ?y1 = (0::?'a1)
### Metis: Unused theorems: "Groups.ab_semigroup_add_class.add.commute"
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### theory "Lp.Lp"
### 0.677s elapsed time, 4.219s cpu time, 0.797s GC time
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### e2ennreal \<infinity> \<equiv> \<top>
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "borel_measurable_continuous_on1" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "using" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
*** Undefined fact: "Lim_eventually" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "by" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** Undefined fact: "Lim_eventually" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "by" (line 2074 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** At command "using" (line 628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Lp/Lp.thy")
*** Undefined fact: "tendsto_explicit" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "using" (line 1169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** Undefined fact: "borel_measurable_continuous_on1" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** At command "by" (line 1034 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")
*** exception THM 0 raised (line 309 of "drule.ML"):
*** OF: no unifiers
*** \<lbrakk>(?f \<longlongrightarrow> ?l) ?F;
***  \<forall>\<^sub>F x in ?F. ?f x = ?g x\<rbrakk>
*** \<Longrightarrow> (?g \<longlongrightarrow> ?l) ?F
*** \<forall>\<^sub>F n in sequentially.
***    f (n - k) / real (n - k + k) = f (n - k) / real n
*** (\<lambda>n. f (n - k) / real (n - k + k)) \<longlonglongrightarrow> l
*** At command "with" (line 343 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy")

==========
Mason_Stothers
Loading theory "Mason_Stothers.Mason_Stothers"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "\<And>x.
          x \<noteq> (0::'a) \<Longrightarrow>
          \<exists>A.
             (\<forall>x. x \<in># A \<longrightarrow> prime_elem x) \<and>
             normalize (prod_mset A) = normalize x"
class factorial_semiring_gcd = factorial_semiring + semiring_Gcd +
  assumes "gcd_eq_gcd_factorial": "\<And>a b. gcd a b = gcd_factorial a b"
    and "lcm_eq_lcm_factorial": "\<And>a b. lcm a b = lcm_factorial a b"
    and "Gcd_eq_Gcd_factorial": "\<And>A. Gcd A = Gcd_factorial A"
    and "Lcm_eq_Lcm_factorial": "\<And>A. Lcm A = Lcm_factorial A"
### theory "Mason_Stothers.Mason_Stothers"
### 0.514s elapsed time, 0.768s cpu time, 0.026s GC time
*** Type unification failed: Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  multiplicity :: ??'a \<Rightarrow> ??'a \<Rightarrow> nat
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 150 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Mason_Stothers/Mason_Stothers.thy")

==========
Nominal2
Loading theory "HOL-Library.Cancellation" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Infinite_Set" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
Loading theory "HOL-Library.Nat_Bijection" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.FSet" via "HOL-Library.Countable")
Loading theory "HOL-Library.Old_Datatype" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.FSet" via "HOL-Library.Countable")
Loading theory "HOL-Library.Phantom_Type" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "FinFun.FinFun" via "HOL-Library.Cardinality")
Loading theory "HOL-Library.Quotient_Syntax" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List" via "HOL-Library.Quotient_Set")
### theory "HOL-Library.Quotient_Syntax"
### 0.019s elapsed time, 0.129s cpu time, 0.000s GC time
Loading theory "HOL-Library.Quotient_Option" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
Loading theory "HOL-Library.Quotient_Product" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
Loading theory "HOL-Library.Quotient_Set" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
### theory "HOL-Library.Quotient_Option"
### 0.061s elapsed time, 0.492s cpu time, 0.047s GC time
### theory "HOL-Library.Quotient_Product"
### 0.073s elapsed time, 0.582s cpu time, 0.047s GC time
### theory "HOL-Library.Quotient_Set"
### 0.081s elapsed time, 0.633s cpu time, 0.047s GC time
Loading theory "HOL-Library.Quotient_List" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs")
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
consts
  enumerate :: "'a set \<Rightarrow> nat \<Rightarrow> 'a"
### theory "HOL-Library.Infinite_Set"
### 0.286s elapsed time, 2.254s cpu time, 0.186s GC time
### theory "HOL-Library.Nat_Bijection"
### 0.311s elapsed time, 2.469s cpu time, 0.186s GC time
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### theory "HOL-Library.Quotient_List"
### 0.351s elapsed time, 2.748s cpu time, 0.258s GC time
### Metis: Unused theorems: "??.unknown"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.471s elapsed time, 3.702s cpu time, 0.305s GC time
Loading theory "HOL-Library.Countable" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.FSet")
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.485s elapsed time, 3.802s cpu time, 0.305s GC time
Loading theory "HOL-Library.Multiset" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
### theory "HOL-Library.Phantom_Type"
### 0.688s elapsed time, 5.115s cpu time, 0.895s GC time
Loading theory "HOL-Library.Cardinality" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "FinFun.FinFun")
### Metis: Unused theorems: "??.unknown"
### Additional type variable(s) in locale specification "CARD_1": 'a
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
### Introduced fixed type variable(s): 'b in "xs__" or "ys__"
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
  plus_multiset == plus ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
### Additional type variable(s) in locale specification "countable": 'a
### Additional type variable(s) in locale specification "card2": 'a
class countable = type +
  assumes "ex_inj": "\<exists>to_nat. inj to_nat"
class card2 = finite +
  assumes "two_le_card": "2 \<le> CARD('a)"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
### Ignoring duplicate rewrite rule:
### finite UNIV \<equiv> False
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a \<times> 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV ::
    ('a \<times> 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a \<Rightarrow> 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV ::
    ('a \<Rightarrow> 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
### Partially applied constant "Multiset.inf_subset_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) \<equiv>
### fold (\<inter>#) ?xs ?x
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
### Partially applied constant "Multiset.sup_subset_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) \<equiv>
### fold (\<union>#) ?xs ?x
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### Code generator: dropping subsumed code equation
### List.coset [] \<subseteq> set [] \<equiv> False
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
### theory "HOL-Library.Cardinality"
### 0.972s elapsed time, 7.459s cpu time, 1.057s GC time
Loading theory "FinFun.FinFun" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set \<Rightarrow> 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set \<Rightarrow> 'a multiset
### theory "HOL-Library.Countable"
### 1.253s elapsed time, 9.406s cpu time, 1.692s GC time
Loading theory "HOL-Library.FSet" (required by "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
bundle finfun
instantiation
  fset :: (finite) finite
instantiation
  fset :: (type) {minus,bounded_lattice_bot,distrib_lattice}
  inf_fset == inf :: 'a fset \<Rightarrow> 'a fset \<Rightarrow> 'a fset
  bot_fset == bot :: 'a fset
  sup_fset == sup :: 'a fset \<Rightarrow> 'a fset \<Rightarrow> 'a fset
  less_eq_fset == less_eq ::
    'a fset \<Rightarrow> 'a fset \<Rightarrow> bool
  less_fset == less :: 'a fset \<Rightarrow> 'a fset \<Rightarrow> bool
  minus_fset == minus :: 'a fset \<Rightarrow> 'a fset \<Rightarrow> 'a fset
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset \<Rightarrow> nat
locale comp_fun_commute
  fixes f :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
  assumes "comp_fun_commute f"
instantiation
  fset :: (equal) equal
  equal_fset == equal_class.equal ::
    'a fset \<Rightarrow> 'a fset \<Rightarrow> bool
instantiation
  fset :: (type) conditionally_complete_lattice
  Inf_fset == Inf :: 'a fset set \<Rightarrow> 'a fset
  Sup_fset == Sup :: 'a fset set \<Rightarrow> 'a fset
consts
  mset :: "'a list \<Rightarrow> 'a multiset"
### Introduced fixed type variable(s): 'd, 'e, 'f in "f__" or "g__"
### Introduced fixed type variable(s): 'h in "A__"
instantiation
  fset :: (finite) complete_lattice
  top_fset == top :: 'a fset
locale finfun_rec_wf_aux
  fixes cnst :: "'b \<Rightarrow> 'c"
    and upd :: "'a \<Rightarrow> 'b \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "finfun_rec_wf_aux cnst upd"
instantiation
  fset :: (finite) complete_boolean_algebra
  uminus_fset == uminus :: 'a fset \<Rightarrow> 'a fset
locale finfun_rec_wf
  fixes cnst :: "'b \<Rightarrow> 'c"
    and upd :: "'a \<Rightarrow> 'b \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "finfun_rec_wf cnst upd"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
locale comm_monoid_mset
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
### Introduced fixed type variable(s): 'd in "c__"
### Introduced fixed type variable(s): 'c, 'd in "a__" or "b__" or "g__"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "\<And>a b. (a \<le> b) = (\<exists>c. b = a + c)"
instantiation
  finfun :: ({card_UNIV,equal}, equal) equal
  equal_finfun == equal_class.equal ::
    'a \<Rightarrow>f 'b
    \<Rightarrow> 'a \<Rightarrow>f 'b \<Rightarrow> bool
instantiation
  finfun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_finfun == finite_UNIV :: ('a \<Rightarrow>f 'b, bool) phantom
instantiation
  finfun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_finfun == card_UNIV_class.card_UNIV ::
    ('a \<Rightarrow>f 'b, nat) phantom
bundle finfun_syntax
bundle no_finfun_syntax
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "\<And>a. (1::'a) * a = a"
### Introduced fixed type variable(s): 'e in "a__" or "g'__"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Introduced fixed type variable(s): 'd in "c__"
### Introduced fixed type variable(s): 'd in "b__" or "g'__"
### Introduced fixed type variable(s): 'f in "c__"
### Introduced fixed type variable(s): 'd, 'e in "a__" or "fa__"
### Ignoring duplicate rewrite rule:
### ?f1 \<in> finfun \<Longrightarrow> curry ?f1 \<in> finfun \<equiv> True
### Ignoring duplicate rewrite rule:
### ?f1 \<in> finfun \<Longrightarrow> curry ?f1 ?a1 \<in> finfun \<equiv> True
### Introduced fixed type variable(s): 'g in "b__" or "g__"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### \<lbrakk>?P ?a; \<And>x. ?P x \<Longrightarrow> x = ?a\<rbrakk>
### \<Longrightarrow> (THE x. ?P x) = ?a
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
  less_multiset == less ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order: "(\<lambda>p. length (fst p)) <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
  assumes "comp_fun_commute f"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal ::
    'a multiset \<Rightarrow> 'a multiset \<Rightarrow> bool
locale comp_fun_idem
  fixes f :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
  assumes "comp_fun_idem f"
locale comm_monoid_fset
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fset (\<^bold>*) \<^bold>1"
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a multiset \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
locale semilattice_fset
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice_fset (\<^bold>*)"
### theory "FinFun.FinFun"
### 2.089s elapsed time, 14.938s cpu time, 2.064s GC time
locale semilattice_order_fset
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
      (infix \<open>\<^bold>\<le>\<close> 50)
    and
    less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
      (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order_fset (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Introduced fixed type variable(s): 'd, 'e, 'f in "f__" or "g__"
### Introduced fixed type variable(s): 'd, 'e in "X__" or "f__" or "g__"
### Introduced fixed type variable(s): 'd, 'e in "f__"
### Introduced fixed type variable(s): 'd in "X__"
### Introduced fixed type variable(s): 'd, 'e, 'f in "R__" or "S__"
### Introduced fixed type variable(s): 'd, 'e in "R__"
Proofs for inductive predicate(s) "rel_mset'"
### Ignoring duplicate rewrite rule:
### mset (map ?f1 ?xs1) \<equiv> image_mset ?f1 (mset ?xs1)
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
### Ignoring duplicate rewrite rule:
### mset (map ?f1 ?xs1) \<equiv> image_mset ?f1 (mset ?xs1)
  Proving the simplification rules ...
### Introduced fixed type variable(s): 'd in "z__"
### Introduced fixed type variable(s): 'd in "P__"
### theory "HOL-Library.Multiset"
### 3.395s elapsed time, 24.769s cpu time, 3.294s GC time
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
instantiation
  fset :: (type) size
  size_fset == size :: 'a fset \<Rightarrow> nat
instantiation
  fset :: (exhaustive) exhaustive
  exhaustive_fset == exhaustive_class.exhaustive ::
    ('a fset \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
Found termination order: "(\<lambda>p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (full_exhaustive) full_exhaustive
  full_exhaustive_fset == full_exhaustive_class.full_exhaustive ::
    ('a fset \<times> (unit \<Rightarrow> term)
     \<Rightarrow> (bool \<times> term list) option)
    \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option
Found termination order: "(\<lambda>p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (random) random
  random_fset == random_class.random ::
    natural
    \<Rightarrow> natural \<times> natural
                  \<Rightarrow> ('a fset \<times>
                                 (unit \<Rightarrow> term)) \<times>
                                natural \<times> natural
### Additional type variable(s) in specification of "random_aux_fset_rel": 'a
### Additional type variable(s) in specification of "random_aux_fset_dom": 'a
Found termination order: "(\<lambda>p. nat_of_natural (fst p)) <*mlex*> {}"
### theory "HOL-Library.FSet"
### 2.982s elapsed time, 19.827s cpu time, 2.267s GC time
Loading theory "Nominal2.Nominal2_Base" (required by "Nominal2.Nominal2")
consts
  sort_of :: "atom \<Rightarrow> atom_sort"
consts
  nat_of :: "atom \<Rightarrow> nat"
instantiation
  perm :: group_add
  minus_perm == minus :: perm \<Rightarrow> perm \<Rightarrow> perm
  uminus_perm == uminus :: perm \<Rightarrow> perm
  zero_perm == zero_class.zero :: perm
  plus_perm == plus :: perm \<Rightarrow> perm \<Rightarrow> perm
class pt = type +
  fixes permute :: "perm \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "permute_zero": "\<And>x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "\<And>p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
instantiation
  atom :: pt
  permute_atom == permute :: perm \<Rightarrow> atom \<Rightarrow> atom
instantiation
  perm :: pt
  permute_perm == permute :: perm \<Rightarrow> perm \<Rightarrow> perm
instantiation
  fun :: (pt, pt) pt
  permute_fun == permute ::
    perm
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  bool :: pt
  permute_bool == permute :: perm \<Rightarrow> bool \<Rightarrow> bool
instantiation
  set :: (pt) pt
  permute_set == permute :: perm \<Rightarrow> 'a set \<Rightarrow> 'a set
instantiation
  unit :: pt
  permute_unit == permute :: perm \<Rightarrow> unit \<Rightarrow> unit
instantiation
  prod :: (pt, pt) pt
  permute_prod == permute ::
    perm \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b
consts
  permute_prod ::
    "perm \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b"
instantiation
  sum :: (pt, pt) pt
  permute_sum == permute :: perm \<Rightarrow> 'a + 'b \<Rightarrow> 'a + 'b
consts
  permute_sum :: "perm \<Rightarrow> 'a + 'b \<Rightarrow> 'a + 'b"
instantiation
  list :: (pt) pt
  permute_list == permute ::
    perm \<Rightarrow> 'a list \<Rightarrow> 'a list
consts
  permute_list :: "perm \<Rightarrow> 'a list \<Rightarrow> 'a list"
instantiation
  option :: (pt) pt
  permute_option == permute ::
    perm \<Rightarrow> 'a option \<Rightarrow> 'a option
consts
  permute_option :: "perm \<Rightarrow> 'a option \<Rightarrow> 'a option"
instantiation
  multiset :: (pt) pt
  permute_multiset == permute ::
    perm \<Rightarrow> 'a multiset \<Rightarrow> 'a multiset
instantiation
  fset :: (pt) pt
  permute_fset == permute ::
    perm \<Rightarrow> 'a fset \<Rightarrow> 'a fset
instantiation
  finfun :: (pt, pt) pt
  permute_finfun == permute ::
    perm \<Rightarrow> ('a, 'b) finfun \<Rightarrow> ('a, 'b) finfun
instantiation
  char :: pt
  permute_char == permute :: perm \<Rightarrow> char \<Rightarrow> char
instantiation
  nat :: pt
  permute_nat == permute :: perm \<Rightarrow> nat \<Rightarrow> nat
instantiation
  int :: pt
  permute_int == permute :: perm \<Rightarrow> int \<Rightarrow> int
class pure = pt +
  assumes "permute_pure": "\<And>p x. p \<bullet> x = x"
### ML warning (line 76 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 94 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 116 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Matches are not exhaustive.
### ML warning (line 119 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 131 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 130 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 156 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_basics.ML"):
### Pattern is not exhaustive.
infix 1 ||>>>
infix 1 |>>>
signature NOMINAL_BASIC =
  sig
    val case_sum_const: typ -> typ -> typ -> term
    val dest_fsetT: typ -> typ
    val dest_listT: typ -> typ
    val dest_perm: term -> term * term
    val fixed_nonfixed_args: Proof.context -> term -> term * term list
    val fold_left: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
    val is_fixed: Proof.context -> term -> bool
    val is_true: term -> bool
    val last2: 'a list -> 'a * 'a
    val long_name: Proof.context -> string -> string
    val map4:
       ('a -> 'b -> 'c -> 'd -> 'e) ->
         'a list -> 'b list -> 'c list -> 'd list -> 'e list
    val mk_All: string * typ -> term -> term
    val mk_all: string * typ -> term -> term
    val mk_case_sum: term -> term -> term
    val mk_equiv: thm -> thm
    val mk_exists: string * typ -> term -> term
    val mk_id: term -> term
    val mk_minus: term -> term
    val mk_perm: term -> term -> term
    val mk_perm_ty: typ -> term -> term -> term
    val mk_plus: term -> term -> term
    val order: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
    val order_default:
       ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
    val perm_const: typ -> term
    val perm_ty: typ -> typ
    val remove_dups: ('a * 'a -> bool) -> 'a list -> 'a list
    val safe_mk_equiv: thm -> thm
    val split_filter: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_last2: 'a list -> 'a list * 'a * 'a
    val split_triples: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
    val trace: bool ref
    val trace_msg: (unit -> string) -> unit
    val |>>> : 'a * ('a -> 'b * 'c) -> 'b list * 'c
    val ||>>> : ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
  end
structure Nominal_Basic: NOMINAL_BASIC
val order = fn: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
val dest_listT = fn: typ -> typ
val mk_perm = fn: term -> term -> term
val mk_plus = fn: term -> term -> term
val split_filter = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val fold_left = fn: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
val split_last2 = fn: 'a list -> 'a list * 'a * 'a
val order_default = fn:
   ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
val perm_const = fn: typ -> term
val last2 = fn: 'a list -> 'a * 'a
val mk_perm_ty = fn: typ -> term -> term -> term
val case_sum_const = fn: typ -> typ -> typ -> term
val is_fixed = fn: Proof.context -> term -> bool
val mk_id = fn: term -> term
val mk_All = fn: string * typ -> term -> term
val map4 = fn:
   ('a -> 'b -> 'c -> 'd -> 'e) ->
     'a list -> 'b list -> 'c list -> 'd list -> 'e list
val is_true = fn: term -> bool
val safe_mk_equiv = fn: thm -> thm
val trace = ref false: bool ref
val mk_all = fn: string * typ -> term -> term
val mk_case_sum = fn: term -> term -> term
val dest_fsetT = fn: typ -> typ
val remove_dups = fn: ('a * 'a -> bool) -> 'a list -> 'a list
val fixed_nonfixed_args = fn: Proof.context -> term -> term * term list
val |>>> = fn: 'a * ('a -> 'b * 'c) -> 'b list * 'c
val dest_perm = fn: term -> term * term
val mk_equiv = fn: thm -> thm
val perm_ty = fn: typ -> typ
val mk_exists = fn: string * typ -> term -> term
val long_name = fn: Proof.context -> string -> string
val split_triples = fn: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val mk_minus = fn: term -> term
val ||>>> = fn: ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
val trace_msg = fn: (unit -> string) -> unit
### ML warning (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
### ML warning (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Value identifier (p') has not been referenced.
### ML warning (line 239 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
signature NOMINAL_THMDECLS =
  sig
    val eqvt_add: attribute
    val eqvt_del: attribute
    val eqvt_raw_add: attribute
    val eqvt_raw_del: attribute
    val eqvt_transform: Proof.context -> thm -> thm
    val get_eqvts_raw_thms: Proof.context -> thm list
    val get_eqvts_thms: Proof.context -> thm list
    val is_eqvt: Proof.context -> term -> bool
  end
structure Nominal_ThmDecls: NOMINAL_THMDECLS
### ML warning (line 72 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_permeq.ML"):
### Value identifier (pre_thms) has not been referenced.
### ML warning (line 78 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_permeq.ML"):
### Value identifier (post_thms) has not been referenced.
infix 4 addpres
infix 4 addposts
infix 4 addexcls
signature NOMINAL_PERMEQ =
  sig
    val addexcls: eqvt_config * string list -> eqvt_config
    val addposts: eqvt_config * thm list -> eqvt_config
    val addpres: eqvt_config * thm list -> eqvt_config
    val args_parser: (thm list * string list) context_parser
    val delposts: eqvt_config -> eqvt_config
    val delpres: eqvt_config -> eqvt_config
    datatype eqvt_config
    =
         Eqvt_Config of
             {excluded: string list,
              post_thms: thm list, pre_thms: thm list, strict_mode: bool}
    val eqvt_conv: Proof.context -> eqvt_config -> conv
    val eqvt_relaxed_config: eqvt_config
    val eqvt_rule: Proof.context -> eqvt_config -> thm -> thm
    val eqvt_strict_config: eqvt_config
    val eqvt_tac: Proof.context -> eqvt_config -> int -> tactic
    val perm_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val perm_strict_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val trace_eqvt: bool Config.T
  end
structure Nominal_Permeq: NOMINAL_PERMEQ
class le_eqvt = pt + order +
  assumes
    "le_eqvt":
      "\<And>p x y.
          p \<bullet> (x \<le> y) = (p \<bullet> x \<le> p \<bullet> y)"
class inf_eqvt = complete_lattice + pt +
  assumes "inf_eqvt": "\<And>p X. p \<bullet> Inf X = Inf (p \<bullet> X)"
instantiation
  bool :: le_eqvt
instantiation
  fun :: (pt, le_eqvt) le_eqvt
instantiation
  bool :: inf_eqvt
instantiation
  fun :: (pt, inf_eqvt) inf_eqvt
class pt = type +
  fixes permute :: "perm \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "permute_zero": "\<And>x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "\<And>p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
class fs = pt +
  assumes "finite_supp": "\<And>x. finite (supp x)"
### Metis: Unused theorems: "Nominal2_Base.pt_class.permute_minus_cancel_2"
### Metis: Unused theorems: "Set.empty_subsetI", "local.insert_3", "Nominal2_Base.supp_swap"
class at_base = pt +
  fixes atom :: "'a \<Rightarrow> atom"
  assumes "atom_eq_iff": "\<And>a b. (atom a = atom b) = (a = b)"
  assumes
    "atom_eqvt": "\<And>p a. p \<bullet> atom a = atom (p \<bullet> a)"
class at = at_base +
  assumes
    "sort_of_atom_eq": "\<And>a b. sort_of (atom a) = sort_of (atom b)"
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> atom ?b1 \<equiv> ?a1 \<sharp> ?b1
### ML warning (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 279 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 278 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 277 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
type cns_info = (term * typ * typ list * bool list) list
signature NOMINAL_LIBRARY =
  sig
    val all_dtyp_constrs_types: Old_Datatype_Aux.descr -> cns_info list
    val atom_const: typ -> term
    val atom_ty: typ -> typ
    val atomify: Proof.context -> term -> term
    val atomify_ty: Proof.context -> typ -> term -> term
    val atomize: Proof.context -> thm -> thm
    val atomize_concl: Proof.context -> thm -> thm
    val atomize_rule: Proof.context -> int -> thm -> thm
    type cns_info = (term * typ * typ list * bool list) list
    val conj_tac: Proof.context -> (int -> tactic) -> int -> tactic
    val finite_const: typ -> term
    val fold_append: term list -> term
    val fold_conj: term list -> term
    val fold_conj_balanced: term list -> term
    val fold_union: term list -> term
    val fold_union_env: typ list -> term list -> term
    val fresh_args: Proof.context -> term -> term list
    val fresh_const: typ -> term
    val fresh_star_const: typ -> term
    val fresh_star_ty: typ -> typ
    val fresh_ty: typ -> typ
    val is_atom: Proof.context -> typ -> bool
    val is_atom_fset: Proof.context -> typ -> bool
    val is_atom_list: Proof.context -> typ -> bool
    val is_atom_set: Proof.context -> typ -> bool
    val listify: Proof.context -> term -> term
    val listify_ty: Proof.context -> typ -> term -> term
    val mk_append: term * term -> term
    val mk_atom: term -> term
    val mk_atom_fset: term -> term
    val mk_atom_fset_ty: typ -> term -> term
    val mk_atom_list: term -> term
    val mk_atom_list_ty: typ -> term -> term
    val mk_atom_set: term -> term
    val mk_atom_set_ty: typ -> term -> term
    val mk_atom_ty: typ -> term -> term
    val mk_binop_env: typ list -> string -> term * term -> term
    val mk_conj: term * term -> term
    val mk_diff: term * term -> term
    val mk_finite: term -> term
    val mk_finite_ty: typ -> term -> term
    val mk_fresh: term -> term -> term
    val mk_fresh_star: term -> term -> term
    val mk_fresh_star_ty: typ -> term -> term -> term
    val mk_fresh_ty: typ -> term -> term -> term
    val mk_full_horn: (string * typ) list -> term list -> term -> term
    val mk_sort_of: term -> term
    val mk_supp: term -> term
    val mk_supp_rel: term -> term -> term
    val mk_supp_rel_ty: typ -> term -> term -> term
    val mk_supp_ty: typ -> term -> term
    val mk_supports: term -> term -> term
    val mk_supports_ty: typ -> term -> term -> term
    val mk_union: term * term -> term
    val mk_union_env: typ list -> term * term -> term
    val pat_completeness_simp: thm list -> Proof.context -> tactic
    val prove_termination_fun:
       thm list -> Proof.context -> Function.info * local_theory
    val prove_termination_ind: Proof.context -> int -> tactic
    val setify: Proof.context -> term -> term
    val setify_ty: Proof.context -> typ -> term -> term
    val size_ss: simpset
    val strip_full_horn: term -> (string * typ) list * term list * term
    val supp_const: typ -> term
    val supp_rel_const: typ -> term
    val supp_rel_ty: typ -> typ
    val supp_ty: typ -> typ
    val supports_const: typ -> term
    val to_set: term -> term
    val to_set_ty: typ -> term -> term
    val transform_prem1: Proof.context -> string list -> thm -> thm
    val transform_prem2: Proof.context -> string list -> thm -> thm
  end
structure Nominal_Library: NOMINAL_LIBRARY
val conj_tac = fn: Proof.context -> (int -> tactic) -> int -> tactic
val is_atom_fset = fn: Proof.context -> typ -> bool
val mk_union_env = fn: typ list -> term * term -> term
val size_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb =
                        Net {atoms =
                             {("HOL.eq",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Abs ("...", "?'d1", ...), name = "HOL.simp_thms_38",
  ...}]})},
                             comb = Leaf [], var = Leaf []},
                        var =
                        Leaf
                         [{elhs = "\<exists>x. ?t1 = x \<and> ?P1 x",
                           extra = false, fo = false, lhs =
                           Const ("HOL.Ex",
                                  "(... ... ...) \<Rightarrow> bool") $
                             Abs ("x", "?'d1",
                               Const ("...", ...) $ (... $ ... $ ...) $
                                 ...),
                           name = "HOL.simp_thms_40", perm = false, thm =
                           "\<exists>x. ?t1 ... x \<and> ?P1 x \<equiv>
                            ?P1 ?t1"},
                          {elhs = "\<exists>x. x = ?t1 \<and> ?P1 x",
                           extra = false, fo = false, lhs =
                           Const ("HOL.Ex", "(...) ... bool") $
                             Abs ("x", "?'d1",
                               Const ("...",
"bool \<Rightarrow> bool \<Rightarrow> bool") $
                                 ... $ ...),
                           name = "HOL.simp_thms_39", perm = false, thm =
                           "\<exists>x. ... ... ... ... ... ... \<equiv>
                            ?P1 ?t1"},
                          {elhs = "\<exists>x. x = ?t1", extra = false, fo =
                           true, lhs =
                           Const ("HOL.Ex", "... ... ...") $
                             Abs ("x", "...", ... $ ... $ ...),
                           name = "HOL.simp_thms_37", perm = false, thm =
                           "...x... ... ... ... \<equiv> True"},
                          {elhs = "\<exists>x. ?y", extra = false, fo =
                           true, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                           name = "HOL.simp_thms_36", perm = false, thm =
                           "......... ... ... ?y"},
                          {elhs = "...x... ... ... ...", extra = false, fo =
                           false, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                           name = "HOL.ex_simps_6", perm = false, thm =
                           "... ... ..."},
                          {elhs = "......... ...", extra = false, fo =
                           false, lhs =
                           Const ("...", ...) $ Abs ("...", "?'e1", ...),
                           name = "HOL.ex_simps_5", ...},
                          {elhs = "...", extra = false, fo = false, lhs =
                           Const ("...",
                                  "(?'d1 \<Rightarrow> bool)
                                   \<Rightarrow> bool") $
                             ...,
                           ...},
                          {elhs = "...", extra = false, fo = false, ...},
                          {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "\<forall>x. ?t1 \<noteq> x", extra =
                            false, fo = true, lhs =
                            Const ("HOL.All", "(...) ... bool") $
                              Abs ("x", "?'d1",
                                Const ("...", "bool \<Rightarrow> bool") $
                                  ...),
                            name = "HOL.simp_thms_44", perm = false, thm =
                            "\<forall>x. ?t1 ... x \<equiv> False"},
                           {elhs = "\<forall>x. x \<noteq> ?t1", extra =
                            false, fo = true, lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "HOL.simp_thms_43", perm = false, thm =
                            "...x... ... ... ... \<equiv> False"},
                           {elhs = "\<forall>x. ... ... ... ... ... ...",
                            extra = false, fo = false, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.simp_thms_42", perm = false, thm =
                            "......... ... ... ... ..."},
                           {elhs = "...x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "HOL.simp_thms_41", perm = false, thm =
                            "... ... ..."},
                           {elhs = "......... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'b1", ...),
                            name = "HOL.simp_thms_35", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...",
                                   "(?'f1 \<Rightarrow> bool)
                                    \<Rightarrow> bool") $
                              ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "\<not> True", extra = false, fo =
                               true, lhs =
                               Const ("HOL.Not", "...") $
                                 Const ("HOL.True", "..."),
                               name = "HOL.simp_thms_7", perm = false, thm =
                               "... True ... False"}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "\<not> False", extra = false, fo =
                                true, lhs =
                                Const ("HOL.Not", "...") $
                                  Const ("...", ...),
                                name = "HOL.simp_thms_8", perm = false,
                                thm = "... ... ... ..."}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]}),
                                ("HOL.Not",
                                  Net {atoms = {}, comb = Leaf [...], var =
 Leaf [...]})},
                              comb =
                              Net {atoms =
                                   {("HOL.eq",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("HOL.conj",
 Net {atoms = {}, comb = ..., var = ...}),
                                     ("HOL.disj", Net {atoms = {}, ...}),
                                     ("HOL.implies", ...)},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "THE x. x ... ?y", extra = false, fo =
                            true, lhs =
                            Const ("HOL.The", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.the_eq_trivial", perm = false, thm =
                            "... ...... ... ... ?y"}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...x... PROP ?V", extra = false, fo =
                            true, lhs =
                            Const ("Pure.all", "...") $ Abs ("x", ..., ...),
                            name = "Pure.triv_forall_equality", perm =
                            false, thm = "... ... ... ..."}]}),
                  ("Wellfounded.wf",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("Wellfounded.measure",
                                 Net {atoms = {}, comb = ..., var = ...})},
                              comb = Leaf [], var = Leaf []},
                         var = Leaf []})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]})},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}})},
                                  comb = Leaf [], var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]})},
 comb = Leaf [], var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?x1 ... ?x1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1"),
                                     name = "HOL.simp_thms_6", perm = false,
                                     thm = "... ... ..."}]}}),
                       ("HOL.conj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.conj", Net {atoms = {}, comb = ..., var = ...}),
    ("HOL.implies", Net {atoms = {}, ...})},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
   ...}]),
                                     ("HOL.False",
 Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, comb = ..., var = ...})}, comb =
  Net {atoms = {("HOL.conj", ...)}, comb = Leaf [...], var = Leaf [...]},
  var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "... ... ...", extra = false,
fo = true, lhs = Const ("...", ...) $ Var ((...), "bool") $ ..., name =
"HOL.simp_thms_25", ...}]}}),
                       ("HOL.disj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.disj", Net {atoms = {}, ...}), ("HOL.implies", ...)}, comb =
  Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf [{elhs = "...", extra = false, fo = true, ...}]),
                                     ("HOL.False",
 Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs =
Const ("...", "bool \<Rightarrow> bool \<Rightarrow> bool") $ ... $ ...,
...}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {("HOL.Trueprop", ...)},
  comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.member",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var = Leaf []}),
                       ("HOL.implies",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.False", Net {atoms = {}, ...})},
                              comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("HOL.True", ...), ...}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("Groups.times_class.times",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {...}, comb = ..., var = ...})},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Sum_Type.sum.case_sum",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}}),
                            ("Basic_BNF_LFPs.prod.size_prod",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var = Leaf []}},
     {congs =
      ({(?, "\<lbrakk>?P \<equiv> ?P';
              ?P' \<Longrightarrow> ?Q \<equiv> ?Q'\<rbrakk>
             \<Longrightarrow> ?P \<longrightarrow> ?Q \<equiv>
                               ?P' \<longrightarrow> ?Q'"),
         (?, "\<lbrakk>PROP ?P \<equiv> PROP ?P';
               PROP ?P' \<Longrightarrow> PROP ?Q \<equiv> PROP ?Q'\<rbrakk>
              \<Longrightarrow> (PROP ?P =simp=> PROP ?Q) \<equiv>
                                (PROP ?P' =simp=> PROP ?Q')")},
       []),
      loop_tacs =
      [("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a \<Rightarrow> bool") $
                                  ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 85630}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 85674}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms = {}, comb = Leaf [], var =
                             Net {atoms = {}, comb = Leaf [], var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "HOL.neq", proc = fn,
stamp = Stamp 85780}]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs =
 Const ("...",
        "?'a \<Rightarrow> (?'a \<Rightarrow> ?'b) \<Rightarrow> ?'b") $
   ... $ ...,
 name = "HOL.let_simp", proc = fn, stamp = Stamp 85904}]}}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("Groups.plus_class.plus", Net {atoms = {}, ...}),
    ("Groups.times_class.times", ...)},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms =
  {("Nat.Suc", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var = Leaf []}})},
                     comb = Leaf [], var = Leaf []},
                var = Leaf []},
           var = Leaf []},
      solvers =
      ([Solver {id = Stamp 85392, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 85394, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val mk_finite = fn: term -> term
val fresh_args = fn: Proof.context -> term -> term list
val atom_ty = fn: typ -> typ
val mk_atom_set = fn: term -> term
val mk_fresh_star_ty = fn: typ -> term -> term -> term
val fresh_star_ty = fn: typ -> typ
val mk_full_horn = fn: (string * typ) list -> term list -> term -> term
val atomize_rule = fn: Proof.context -> int -> thm -> thm
val prove_termination_ind = fn: Proof.context -> int -> tactic
val supp_const = fn: typ -> term
val mk_diff = fn: term * term -> term
val supp_rel_const = fn: typ -> term
val setify_ty = fn: Proof.context -> typ -> term -> term
val transform_prem2 = fn: Proof.context -> string list -> thm -> thm
val fold_append = fn: term list -> term
val atomize = fn: Proof.context -> thm -> thm
val atom_const = fn: typ -> term
val mk_supports = fn: term -> term -> term
val fresh_star_const = fn: typ -> term
val is_atom_list = fn: Proof.context -> typ -> bool
val strip_full_horn = fn: term -> (string * typ) list * term list * term
val fold_conj = fn: term list -> term
val listify = fn: Proof.context -> term -> term
val fold_union = fn: term list -> term
val mk_union = fn: term * term -> term
val mk_atom = fn: term -> term
val mk_append = fn: term * term -> term
val all_dtyp_constrs_types = fn: Old_Datatype_Aux.descr -> cns_info list
val fold_union_env = fn: typ list -> term list -> term
val mk_fresh = fn: term -> term -> term
val is_atom_set = fn: Proof.context -> typ -> bool
val mk_sort_of = fn: term -> term
val listify_ty = fn: Proof.context -> typ -> term -> term
val mk_atom_fset_ty = fn: typ -> term -> term
val mk_fresh_star = fn: term -> term -> term
val to_set_ty = fn: typ -> term -> term
val mk_atom_ty = fn: typ -> term -> term
val mk_supp_rel_ty = fn: typ -> term -> term -> term
val prove_termination_fun = fn:
   thm list -> Proof.context -> Function.info * local_theory
val atomify = fn: Proof.context -> term -> term
val mk_atom_set_ty = fn: typ -> term -> term
val atomify_ty = fn: Proof.context -> typ -> term -> term
val supp_rel_ty = fn: typ -> typ
val pat_completeness_simp = fn: thm list -> Proof.context -> tactic
val mk_conj = fn: term * term -> term
val finite_const = fn: typ -> term
val setify = fn: Proof.context -> term -> term
val is_atom = fn: Proof.context -> typ -> bool
val mk_atom_fset = fn: term -> term
val mk_atom_list_ty = fn: typ -> term -> term
val transform_prem1 = fn: Proof.context -> string list -> thm -> thm
val mk_finite_ty = fn: typ -> term -> term
val mk_fresh_ty = fn: typ -> term -> term -> term
val mk_binop_env = fn: typ list -> string -> term * term -> term
val atomize_concl = fn: Proof.context -> thm -> thm
val fresh_const = fn: typ -> term
val fresh_ty = fn: typ -> typ
val fold_conj_balanced = fn: term list -> term
val supports_const = fn: typ -> term
val to_set = fn: term -> term
val mk_supp = fn: term -> term
val mk_supports_ty = fn: typ -> term -> term -> term
val supp_ty = fn: typ -> typ
val mk_supp_rel = fn: term -> term -> term
val mk_atom_list = fn: term -> term
val mk_supp_ty = fn: typ -> term -> term
### ML warning (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_atoms.ML"):
### Value identifier (arg) has not been referenced.
signature ATOM_DECL =
  sig val add_atom_decl: binding * binding option -> theory -> theory end
structure Atom_Decl: ATOM_DECL
### Metis: Unused theorems: "Nominal2_Base.eqvt_apply"
### ML warning (line 40 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Value identifier (context) has not been referenced.
### ML warning (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Matches are not exhaustive.
### ML warning (line 93 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
### ML warning (line 125 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
signature NOMINAL_EQVT =
  sig
    val equivariance_cmd: string -> Proof.context -> local_theory
    val raw_equivariance:
       Proof.context -> term list -> thm -> thm list -> thm list
  end
structure Nominal_Eqvt: NOMINAL_EQVT
### theory "Nominal2.Nominal2_Base"
### 2.711s elapsed time, 8.733s cpu time, 2.054s GC time
Loading theory "Nominal2.Atoms"
Loading theory "Nominal2.Eqvt"
instantiation
  name :: at
  atom_name == atom :: name \<Rightarrow> atom
  permute_name == permute :: perm \<Rightarrow> name \<Rightarrow> name
Loading theory "Nominal2.Nominal2_Abs" (required by "Nominal2.Nominal2")
val it = false: bool
### theory "Nominal2.Eqvt"
### 0.081s elapsed time, 0.625s cpu time, 0.068s GC time
"atom a"
  :: "atom"
?p \<bullet> Ex \<equiv> Ex
?p \<bullet> If \<equiv> If
?p \<bullet> (=) \<equiv> (=)
?p \<bullet> All \<equiv> All
?p \<bullet> Ex1 \<equiv> Ex1
?p \<bullet> Not \<equiv> Not
?p \<bullet> Bex \<equiv> Bex
?p \<bullet> (\<circ>) \<equiv> (\<circ>)
?p \<bullet> True \<equiv> True
?p \<bullet> (\<and>) \<equiv> (\<and>)
?p \<bullet> (\<or>) \<equiv> (\<or>)
?p \<bullet> rev \<equiv> rev
?p \<bullet> Ball \<equiv> Ball
?p \<bullet> False \<equiv> False
?p \<bullet> (`) \<equiv> (`)
?p \<bullet> foldr \<equiv> foldr
?p \<bullet> insert \<equiv> insert
?p \<bullet> (\<in>) \<equiv> (\<in>)
?p \<bullet> (-`) \<equiv> (-`)
?p \<bullet> (|`|) \<equiv> (|`|)
?p \<bullet> fun_upd \<equiv> fun_upd
?p \<bullet> (\<longrightarrow>) \<equiv> (\<longrightarrow>)
?p \<bullet> (@) \<equiv> (@)
?p \<bullet> filter \<equiv> filter
?p \<bullet> Collect \<equiv> Collect
?p \<bullet> finsert \<equiv> finsert
?p \<bullet> (|\<in>|) \<equiv> (|\<in>|)
?p \<bullet> Inl \<equiv> Inl
?p \<bullet> Inr \<equiv> Inr
?p \<bullet> distinct \<equiv> distinct
?p \<bullet> [] \<equiv> []
?p \<bullet> map \<equiv> map
?p \<bullet> set \<equiv> set
?p \<bullet> fset \<equiv> fset
?p \<bullet> (#) \<equiv> (#)
?p \<bullet> removeAll \<equiv> removeAll
?p \<bullet> (``) \<equiv> (``)
?p \<bullet> finite \<equiv> finite
?p \<bullet> HOL.induct_forall \<equiv> HOL.induct_forall
?p \<bullet> add_mset \<equiv> add_mset
?p \<bullet> set_mset \<equiv> set_mset
?p \<bullet> Pair \<equiv> Pair
?p \<bullet> HOL.induct_implies \<equiv> HOL.induct_implies
?p \<bullet> flip \<equiv> flip
?p \<bullet> swap \<equiv> swap
?p \<bullet> None \<equiv> None
?p \<bullet> Some \<equiv> Some
?p \<bullet> finfun_const \<equiv> finfun_const
?p \<bullet> length \<equiv> length
?p \<bullet> finfun_update \<equiv> finfun_update
?p \<bullet> fst \<equiv> fst
?p \<bullet> snd \<equiv> snd
?p \<bullet> (+) \<equiv> (+)
?p \<bullet> (+) \<equiv> (+)
?p \<bullet> {#} \<equiv> {#}
?p \<bullet> 0 \<equiv> 0
?p \<bullet> (\<inter>) \<equiv> (\<inter>)
?p \<bullet> (|\<inter>|) \<equiv> (|\<inter>|)
?p \<bullet> (\<union>) \<equiv> (\<union>)
?p \<bullet> (|\<union>|) \<equiv> (|\<union>|)
?p \<bullet> {} \<equiv> {}
?p \<bullet> {||} \<equiv> {||}
?p \<bullet> UNIV \<equiv> UNIV
?p \<bullet> (-) \<equiv> (-)
?p \<bullet> fresh_star \<equiv> fresh_star
?p \<bullet> map_option \<equiv> map_option
?p \<bullet> (\<subset>) \<equiv> (\<subset>)
?p \<bullet> finfun_apply \<equiv> finfun_apply
?p \<bullet> uminus \<equiv> uminus
?p \<bullet> uminus \<equiv> uminus
?p \<bullet> supp \<equiv> supp
?p \<bullet> (\<le>) \<equiv> (\<le>)
?p \<bullet> (\<subseteq>) \<equiv> (\<subseteq>)
?p \<bullet> (|\<subseteq>|) \<equiv> (|\<subseteq>|)
?p \<bullet> case_prod \<equiv> case_prod
?p \<bullet> fresh \<equiv> fresh
?p \<bullet> permute \<equiv> permute
?p \<bullet> Inf \<equiv> Inf
?p \<bullet> \<Inter> \<equiv> \<Inter>
?p \<bullet> \<Union> \<equiv> \<Union>
?p \<bullet> atom \<equiv> atom
?p \<bullet> lfp \<equiv> lfp
?p \<bullet> (?a \<leftrightarrow> ?b) =
(?p \<bullet> ?a \<leftrightarrow> ?p \<bullet> ?b)
?p \<bullet> atom ?a = atom (?p \<bullet> ?a)
(?p \<bullet> ?as) \<sharp>* (?p \<bullet> ?x) = ?as \<sharp>* ?x
?p \<bullet> set_mset ?M = set_mset (?p \<bullet> ?M)
?p \<bullet> ?a \<sharp> ?p \<bullet> ?x = ?a \<sharp> ?x
?p \<bullet> supp ?x = supp (?p \<bullet> ?x)
?p \<bullet> finfun_apply ?f ?b =
finfun_apply (?p \<bullet> ?f) (?p \<bullet> ?b)
?p \<bullet> finfun_const ?b = finfun_const (?p \<bullet> ?b)
?p \<bullet> finfun_update ?f ?a ?b =
finfun_update (?p \<bullet> ?f) (?p \<bullet> ?a) (?p \<bullet> ?b)
?p \<bullet> ?f |`| ?S = (?p \<bullet> ?f) |`| (?p \<bullet> ?S)
(?p \<bullet> ?S |\<subseteq>| ?p \<bullet> ?T) = (?S |\<subseteq>| ?T)
?p \<bullet> (?S |\<inter>| ?T) = ?p \<bullet> ?S |\<inter>| ?p \<bullet> ?T
?p \<bullet> (?S |\<union>| ?T) = ?p \<bullet> ?S |\<union>| ?p \<bullet> ?T
(?p \<bullet> ?x |\<in>| ?p \<bullet> ?S) = (?x |\<in>| ?S)
?p \<bullet> map_option ?f ?x =
map_option (?p \<bullet> ?f) (?p \<bullet> ?x)
?p \<bullet> length ?xs = length (?p \<bullet> ?xs)
distinct (?p \<bullet> ?xs) = distinct ?xs
?p \<bullet> filter ?f ?xs = filter (?p \<bullet> ?f) (?p \<bullet> ?xs)
?p \<bullet> removeAll ?x ?xs =
removeAll (?p \<bullet> ?x) (?p \<bullet> ?xs)
?p \<bullet> map ?f ?xs = map (?p \<bullet> ?f) (?p \<bullet> ?xs)
?p \<bullet> rev ?xs = rev (?p \<bullet> ?xs)
?p \<bullet> (?xs @ ?ys) = ?p \<bullet> ?xs @ ?p \<bullet> ?ys
?p \<bullet> (case ?x of (x, xa) \<Rightarrow> ?P x xa) =
(case ?p \<bullet> ?x of (x, xa) \<Rightarrow> (?p \<bullet> ?P) x xa)
?p \<bullet> snd ?x = snd (?p \<bullet> ?x)
?p \<bullet> fst ?x = fst (?p \<bullet> ?x)
?p \<bullet> (?f \<circ> ?g) = ?p \<bullet> ?f \<circ> ?p \<bullet> ?g
?p \<bullet> ?f(?x := ?y) = (?p \<bullet> ?f)
(?p \<bullet> ?x := ?p \<bullet> ?y)
finite (?p \<bullet> ?A) = finite ?A
?p \<bullet> lfp ?F = lfp (?p \<bullet> ?F)
?p \<bullet> Inf ?X = Inf (?p \<bullet> ?X)
(?p \<bullet> ?x \<le> ?p \<bullet> ?y) = (?x \<le> ?y)
?p \<bullet> foldr ?f ?xs = foldr (?p \<bullet> ?f) (?p \<bullet> ?xs)
?p \<bullet> ?f -` ?A = (?p \<bullet> ?f) -` (?p \<bullet> ?A)
(?p \<bullet> ?S \<subset> ?p \<bullet> ?T) = (?S \<subset> ?T)
(?p \<bullet> ?S \<subseteq> ?p \<bullet> ?T) = (?S \<subseteq> ?T)
?p \<bullet> - ?A = - (?p \<bullet> ?A)
?p \<bullet> (?A - ?B) = ?p \<bullet> ?A - ?p \<bullet> ?B
?p \<bullet> \<Union> ?A = \<Union> (?p \<bullet> ?A)
?p \<bullet> (?A \<union> ?B) = ?p \<bullet> ?A \<union> ?p \<bullet> ?B
?p \<bullet> \<Inter> ?S = \<Inter> (?p \<bullet> ?S)
?p \<bullet> (?A \<inter> ?B) = ?p \<bullet> ?A \<inter> ?p \<bullet> ?B
?p \<bullet> UNIV = UNIV
?p \<bullet> ?R `` ?A = (?p \<bullet> ?R) `` (?p \<bullet> ?A)
?p \<bullet> ?f ` ?A = (?p \<bullet> ?f) ` (?p \<bullet> ?A)
(\<forall>x\<in>?p \<bullet> ?S. (?p \<bullet> ?P) x) =
(\<forall>x\<in>?S. ?P x)
(\<exists>x\<in>?p \<bullet> ?S. (?p \<bullet> ?P) x) =
(\<exists>x\<in>?S. ?P x)
?p \<bullet> {x. ?P x} = {x. (?p \<bullet> ?P) x}
(?p \<bullet> ?x \<in> ?p \<bullet> ?A) = (?x \<in> ?A)
(?p \<bullet> ?A \<or> ?p \<bullet> ?B) = (?A \<or> ?B)
?p \<bullet> False = False
?p \<bullet> True = True
?p \<bullet> (if ?b then ?x else ?y) =
(if ?p \<bullet> ?b then ?p \<bullet> ?x else ?p \<bullet> ?y)
(\<exists>!x. (?p \<bullet> ?P) x) = (\<exists>!x. ?P x)
(\<exists>x. (?p \<bullet> ?P) x) = (\<exists>x. ?P x)
HOL.induct_forall (?p \<bullet> ?P) = HOL.induct_forall ?P
(\<forall>x. (?p \<bullet> ?P) x) = (\<forall>x. ?P x)
HOL.induct_implies (?p \<bullet> ?A) (?p \<bullet> ?B) =
HOL.induct_implies ?A ?B
(?p \<bullet> ?A \<longrightarrow> ?p \<bullet> ?B) =
(?A \<longrightarrow> ?B)
(?p \<bullet> ?A \<and> ?p \<bullet> ?B) = (?A \<and> ?B)
(\<not> ?p \<bullet> ?A) = (\<not> ?A)
(?p \<bullet> ?x = ?p \<bullet> ?y) = (?x = ?y)
?p \<bullet> - ?q = - (?p \<bullet> ?q)
?p \<bullet> (?a \<rightleftharpoons> ?b) =
(?p \<bullet> ?a \<rightleftharpoons> ?p \<bullet> ?b)
?p \<bullet> (?p1.0 + ?p2.0) = ?p \<bullet> ?p1.0 + ?p \<bullet> ?p2.0
?p \<bullet> 0 = 0
?p \<bullet> (?M + ?N) = ?p \<bullet> ?M + ?p \<bullet> ?N
?p \<bullet> add_mset ?x ?M = add_mset (?p \<bullet> ?x) (?p \<bullet> ?M)
?p \<bullet> {#} = {#}
?p \<bullet> fset ?S = fset (?p \<bullet> ?S)
?p \<bullet> finsert ?x ?S = finsert (?p \<bullet> ?x) (?p \<bullet> ?S)
?p \<bullet> {||} = {||}
?p \<bullet> set ?xs = set (?p \<bullet> ?xs)
?p \<bullet> insert ?x ?A = insert (?p \<bullet> ?x) (?p \<bullet> ?A)
?p \<bullet> {} = {}
?p \<bullet> Inr ?y = Inr (?p \<bullet> ?y)
?p \<bullet> Inl ?x = Inl (?p \<bullet> ?x)
?p \<bullet> Some ?x = Some (?p \<bullet> ?x)
?p \<bullet> None = None
?p \<bullet> (?x # ?xs) = ?p \<bullet> ?x # ?p \<bullet> ?xs
?p \<bullet> [] = []
?p \<bullet> (?x, ?y) = (?p \<bullet> ?x, ?p \<bullet> ?y)
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_set_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_set (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 \<and>
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 \<and>
### ?R1 (?p1 \<bullet> ?x1) ?y1 \<and> ?p1 \<bullet> ?bs1 = ?cs1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_res_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_res (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 \<and>
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 \<and> ?R1 (?p1 \<bullet> ?x1) ?y1
Found termination order: "{}"
consts
  sort_of_ty :: "ty \<Rightarrow> atom_sort"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_lst_rel
###  ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) \<Longrightarrow>
### alpha_lst (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) \<equiv>
### ?f1 ?x1 - set ?bs1 = ?f1 ?y1 - set ?cs1 \<and>
### (?f1 ?x1 - set ?bs1) \<sharp>* ?p1 \<and>
### ?R1 (?p1 \<bullet> ?x1) ?y1 \<and> ?p1 \<bullet> ?bs1 = ?cs1
instantiation
  Atoms.var :: at_base
  atom_var == atom :: Atoms.var \<Rightarrow> atom
  permute_var == permute ::
    perm \<Rightarrow> Atoms.var \<Rightarrow> Atoms.var
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### ?P1 \<le> ?Q1 \<equiv> ?P1 \<longrightarrow> ?Q1
### theory "Nominal2.Atoms"
### 0.568s elapsed time, 2.401s cpu time, 0.189s GC time
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_set_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_set (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>set (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_lst_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_lst (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>lst (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_res_rel
###  ((?bs1, ?x1), ?cs1, ?y1) \<Longrightarrow>
### alpha_abs_res (?bs1, ?x1) (?cs1, ?y1) \<equiv>
### \<exists>p. (?bs1, ?x1) \<approx>res (=) supp p (?cs1, ?y1)
Found termination order: "{}"
instantiation
  abs_set :: (pt) pt
  permute_abs_set == permute ::
    perm \<Rightarrow> 'a abs_set \<Rightarrow> 'a abs_set
instantiation
  abs_res :: (pt) pt
  permute_abs_res == permute ::
    perm \<Rightarrow> 'a abs_res \<Rightarrow> 'a abs_res
instantiation
  abs_lst :: (pt) pt
  permute_abs_lst == permute ::
    perm \<Rightarrow> 'a abs_lst \<Rightarrow> 'a abs_lst
Found termination order: "{}"
### ML warning (line 927 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/Nominal2_Abs.thy"):
### Pattern is not exhaustive.
val alpha_single_simproc = fn:
   thm -> 'a -> Proof.context -> cterm -> thm option
Found termination order: "{}"
### theory "Nominal2.Nominal2_Abs"
### 1.249s elapsed time, 4.856s cpu time, 0.279s GC time
Loading theory "Nominal2.Nominal2_FCB" (required by "Nominal2.Nominal2")
val all_trivials = fn: (Proof.context -> Proof.method) context_parser
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### theory "Nominal2.Nominal2_FCB"
### 0.093s elapsed time, 0.731s cpu time, 0.072s GC time
Loading theory "Nominal2.Nominal2"
signature NOMINAL_DT_DATA =
  sig
    datatype alpha_result
    =
         AlphaResult of
             {alpha_bn_names: string list,
              alpha_bn_trms: term list,
              alpha_bn_tys: typ list,
              alpha_cases: thm list,
              alpha_intros: thm list,
              alpha_names: string list,
              alpha_raw_induct: thm,
              alpha_trms: term list, alpha_tys: typ list}
    datatype bclause = BC of bmode * (term option * int) list * int list
    datatype bmode = Lst | Res | Set
    type bn_info = term * int * (int * term option) list list
    val get_all_info: Proof.context -> (string * info) list
    val get_info: Proof.context -> string -> info option
    type info =
       {distinct: thm list,
        inject: thm list,
        strong_exhaust: thm list, strong_inducts: thm list}
    val mk_infos:
       string list ->
         thm list ->
           thm list -> thm list -> thm list -> (string * info) list
    datatype raw_dt_info
    =
         RawDtInfo of
             {raw_all_cns: term list list,
              raw_cns_info: cns_info list,
              raw_distinct_thms: thm list,
              raw_dt_names: string list,
              raw_dts: Old_Datatype.spec list,
              raw_exhaust_thms: thm list,
              raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
              raw_induct_thm: thm,
              raw_induct_thms: thm list,
              raw_inject_thms: thm list,
              raw_size_thms: thm list,
              raw_size_trms: term list,
              raw_ty_args: (string * sort) list, raw_tys: typ list}
    val register_info: string * info -> Context.generic -> Context.generic
    val the_info: Proof.context -> string -> info
    datatype user_data
    =
         UserData of
             {bclauses: bclause list list list,
              bn_eqs: (Attrib.binding * term) list,
              bn_funs: (binding * typ * mixfix) list,
              cn_names: string list,
              cn_tys: (string * string) list, dts: Old_Datatype.spec list}
  end
structure Nominal_Dt_Data: NOMINAL_DT_DATA
type bn_info = term * int * (int * term option) list list
datatype raw_dt_info
=
     RawDtInfo of
         {raw_all_cns: term list list,
          raw_cns_info: cns_info list,
          raw_distinct_thms: thm list,
          raw_dt_names: string list,
          raw_dts: Old_Datatype.spec list,
          raw_exhaust_thms: thm list,
          raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
          raw_induct_thm: thm,
          raw_induct_thms: thm list,
          raw_inject_thms: thm list,
          raw_size_thms: thm list,
          raw_size_trms: term list,
          raw_ty_args: (string * sort) list, raw_tys: typ list}
datatype user_data
=
     UserData of
         {bclauses: Nominal_Dt_Data.bclause list list list,
          bn_eqs: (Attrib.binding * term) list,
          bn_funs: (binding * typ * mixfix) list,
          cn_names: string list,
          cn_tys: (string * string) list, dts: Old_Datatype.spec list}
datatype bmode = Lst | Res | Set
datatype bclause = BC of bmode * (term option * int) list * int list
type info =
   {distinct: thm list,
    inject: thm list, strong_exhaust: thm list, strong_inducts: thm list}
datatype alpha_result
=
     AlphaResult of
         {alpha_bn_names: string list,
          alpha_bn_trms: term list,
          alpha_bn_tys: typ list,
          alpha_cases: thm list,
          alpha_intros: thm list,
          alpha_names: string list,
          alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
constructor Lst: bmode
constructor UserData:
   {bclauses: bclause list list list,
    bn_eqs: (Attrib.binding * term) list,
    bn_funs: (binding * typ * mixfix) list,
    cn_names: string list,
    cn_tys: (string * string) list, dts: Old_Datatype.spec list}
     -> user_data
val the_info = fn: Proof.context -> string -> info
val register_info = fn: string * info -> Context.generic -> Context.generic
val get_all_info = fn: Proof.context -> (string * info) list
constructor BC: bmode * (term option * int) list * int list -> bclause
val get_info = fn: Proof.context -> string -> info option
constructor Res: bmode
constructor AlphaResult:
   {alpha_bn_names: string list,
    alpha_bn_trms: term list,
    alpha_bn_tys: typ list,
    alpha_cases: thm list,
    alpha_intros: thm list,
    alpha_names: string list,
    alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
     -> alpha_result
constructor RawDtInfo:
   {raw_all_cns: term list list,
    raw_cns_info: cns_info list,
    raw_distinct_thms: thm list,
    raw_dt_names: string list,
    raw_dts: Old_Datatype.spec list,
    raw_exhaust_thms: thm list,
    raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
    raw_induct_thm: thm,
    raw_induct_thms: thm list,
    raw_inject_thms: thm list,
    raw_size_thms: thm list,
    raw_size_trms: term list,
    raw_ty_args: (string * sort) list, raw_tys: typ list}
     -> raw_dt_info
constructor Set: bmode
val mk_infos = fn:
   string list ->
     thm list -> thm list -> thm list -> thm list -> (string * info) list
### ML warning (line 82 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
### ML warning (line 286 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Value identifier (lthy) has not been referenced.
### ML warning (line 523 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_RAWFUNS =
  sig
    val define_raw_bn_perms:
       raw_dt_info ->
         bn_info list -> local_theory -> term list * thm list * local_theory
    val define_raw_bns:
       raw_dt_info ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             local_theory ->
               term list * thm list * bn_info list * thm list * local_theory
    val define_raw_fvs:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             Proof.context ->
               term list * term list * thm list * thm list * local_theory
    val define_raw_perms:
       raw_dt_info ->
         local_theory -> (term list * thm list * thm list) * local_theory
    val get_all_binders: bclause list -> (term option * int) list
    val is_recursive_binder: bclause -> bool
    val raw_prove_eqvt:
       term list -> thm list -> thm list -> Proof.context -> thm list
  end
structure Nominal_Dt_RawFuns: NOMINAL_DT_RAWFUNS
val get_all_binders = fn: bclause list -> (term option * int) list
val raw_prove_eqvt = fn:
   term list -> thm list -> thm list -> Proof.context -> thm list
val define_raw_bns = fn:
   raw_dt_info ->
     (binding * typ option * mixfix) list ->
       Specification.multi_specs ->
         local_theory ->
           term list * thm list * bn_info list * thm list * local_theory
val define_raw_fvs = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         Proof.context ->
           term list * term list * thm list * thm list * local_theory
val define_raw_bn_perms = fn:
   raw_dt_info ->
     bn_info list -> local_theory -> term list * thm list * local_theory
val is_recursive_binder = fn: bclause -> bool
val define_raw_perms = fn:
   raw_dt_info ->
     local_theory -> (term list * thm list * thm list) * local_theory
### ML warning (line 385 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
### ML warning (line 604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Value identifier (alpha_bn_names) has not been referenced.
### ML warning (line 604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Value identifier (alpha_names) has not been referenced.
### ML warning (line 828 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_ALPHA =
  sig
    val alpha_prove:
       term list ->
         (term * (term * term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val comb_binders:
       Proof.context ->
         bmode -> term list -> (term option * int) list -> term
    val define_raw_alpha:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             term list -> Proof.context -> alpha_result * local_theory
    val induct_prove:
       typ list ->
         (typ * (term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val mk_alpha_permute_rsp: Proof.context -> thm -> thm
    val mk_funs_rsp: Proof.context -> thm -> thm
    val raw_alpha_bn_rsp: alpha_result -> thm list -> thm list -> thm list
    val raw_constrs_rsp:
       Proof.context ->
         alpha_result -> term list list -> thm list -> thm list list
    val raw_fv_bn_rsp_aux:
       Proof.context ->
         alpha_result ->
           term list -> term list -> term list -> thm list -> thm list
    val raw_perm_bn_rsp:
       Proof.context -> alpha_result -> term list -> thm list -> thm list
    val raw_prove_alpha_distincts:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_alpha_eq_iff:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_bn_imp: Proof.context -> alpha_result -> thm list
    val raw_prove_equivp:
       Proof.context ->
         alpha_result ->
           thm list -> thm list -> thm list -> thm list * thm list
    val raw_prove_refl: Proof.context -> alpha_result -> thm -> thm list
    val raw_prove_sym: Proof.context -> alpha_result -> thm list -> thm list
    val raw_prove_trans:
       Proof.context -> alpha_result -> thm list -> thm list -> thm list
    val raw_size_rsp_aux:
       Proof.context -> alpha_result -> thm list -> thm list
  end
structure Nominal_Dt_Alpha: NOMINAL_DT_ALPHA
val raw_size_rsp_aux = fn:
   Proof.context -> alpha_result -> thm list -> thm list
val induct_prove = fn:
   typ list ->
     (typ * (term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_prove_refl = fn: Proof.context -> alpha_result -> thm -> thm list
val raw_prove_trans = fn:
   Proof.context -> alpha_result -> thm list -> thm list -> thm list
val raw_fv_bn_rsp_aux = fn:
   Proof.context ->
     alpha_result ->
       term list -> term list -> term list -> thm list -> thm list
val raw_perm_bn_rsp = fn:
   Proof.context -> alpha_result -> term list -> thm list -> thm list
val alpha_prove = fn:
   term list ->
     (term * (term * term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_alpha_bn_rsp = fn: alpha_result -> thm list -> thm list -> thm list
val define_raw_alpha = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         term list -> Proof.context -> alpha_result * local_theory
val raw_prove_alpha_distincts = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val comb_binders = fn:
   Proof.context -> bmode -> term list -> (term option * int) list -> term
val raw_prove_equivp = fn:
   Proof.context ->
     alpha_result -> thm list -> thm list -> thm list -> thm list * thm list
val raw_constrs_rsp = fn:
   Proof.context ->
     alpha_result -> term list list -> thm list -> thm list list
val raw_prove_alpha_eq_iff = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val mk_alpha_permute_rsp = fn: Proof.context -> thm -> thm
val mk_funs_rsp = fn: Proof.context -> thm -> thm
val raw_prove_bn_imp = fn: Proof.context -> alpha_result -> thm list
val raw_prove_sym = fn:
   Proof.context -> alpha_result -> thm list -> thm list
### theory "Nominal2.Nominal2"
### 0.679s elapsed time, 1.874s cpu time, 0.096s GC time
*** ML error (line 210 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/nominal_dt_quot.ML"):
*** Value or constructor (auto_fixes) has not been declared in structure Variable
*** At command "ML_file" (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Nominal2/Nominal2.thy")

==========
Order_Lattice_Props
Loading theory "Order_Lattice_Props.Order_Lattice_Props_Loc"
Loading theory "Order_Lattice_Props.Order_Lattice_Props_Wenzel"
Loading theory "Order_Lattice_Props.Sup_Lattice"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class preorder_lean = ord +
  assumes "preorder_refl": "\<And>x. x \<le> x"
    and
    "preorder_trans":
      "\<And>x y z.
          \<lbrakk>x \<le> y; y \<le> z\<rbrakk>
          \<Longrightarrow> x \<le> z"
class order_lean = preorder_lean +
  assumes
    "order_antisym":
      "\<And>x y.
          \<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> x = y"
instantiation
  dual :: (ord) ord
  less_eq_dual == less_eq ::
    'a dual \<Rightarrow> 'a dual \<Rightarrow> bool
  less_dual == less :: 'a dual \<Rightarrow> 'a dual \<Rightarrow> bool
instantiation
  dual :: (lattice) lattice
  inf_dual == inf :: 'a dual \<Rightarrow> 'a dual \<Rightarrow> 'a dual
  sup_dual == sup :: 'a dual \<Rightarrow> 'a dual \<Rightarrow> 'a dual
class Sup_lattice = Sup + order_lean +
  assumes
    "Sups_upper":
      "\<And>x X. x \<in> X \<Longrightarrow> x \<le> \<Squnion> X"
    and
    "Sups_least":
      "\<And>X z.
          (\<And>x. x \<in> X \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> X \<le> z"
instantiation
  dual :: (complete_lattice) complete_lattice
  Inf_dual == Inf :: 'a dual set \<Rightarrow> 'a dual
  Sup_dual == Sup :: 'a dual set \<Rightarrow> 'a dual
  bot_dual == bot :: 'a dual
  top_dual == top :: 'a dual
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
### theory "Order_Lattice_Props.Order_Lattice_Props_Wenzel"
### 0.718s elapsed time, 3.463s cpu time, 0.210s GC time
class Inf_lattice = Inf + order_lean +
  assumes
    "Infi_lower":
      "\<And>x X. x \<in> X \<Longrightarrow> \<Sqinter> X \<le> x"
    and
    "Infi_greatest":
      "\<And>X z.
          (\<And>x. x \<in> X \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> X"
### Partially applied constant "Sup_Lattice.Sup_lattice_class.infs" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin infs (set (?x # ?xs)) \<equiv> fold infs ?xs ?x
### Partially applied constant "Sup_Lattice.Sup_lattice_class.sups" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin sups (set (?x # ?xs)) \<equiv> fold sups ?xs ?x
### Partially applied constant "Sup_Lattice.Inf_lattice_class.supi" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin supi (set (?x # ?xs)) \<equiv> fold supi ?xs ?x
### Partially applied constant "Sup_Lattice.Inf_lattice_class.infi" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin infi (set (?x # ?xs)) \<equiv> fold infi ?xs ?x
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class preorder = ord +
  assumes
    "less_le_not_le":
      "\<And>x y. (x < y) = (x \<le> y \<and> \<not> y \<le> x)"
    and "order_refl": "\<And>x. x \<le> x"
    and
    "order_trans":
      "\<And>x y z.
          \<lbrakk>x \<le> y; y \<le> z\<rbrakk>
          \<Longrightarrow> x \<le> z"
class order = preorder +
  assumes
    "antisym":
      "\<And>x y.
          \<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> x = y"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
*** Failed to apply initial proof method (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy"):
*** goal (1 subgoal):
***  1. \<Squnion> (\<Inter>x\<in>X. {y. y \<le> x}) = \<Sqinter> X
*** At command "by" (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy")
Failure node
Enter MATCH
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax.
   gfp (?f57 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
         ax) \<equiv>\<^sup>?
?f57
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (?f57 a b c d e f g h i j k l m n o p q r s t u v
                            w x y z aa ab ac ad ae af ag ah ai aj ak al am
                            an ao ap aq ar as at au av aw
                            ax))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax.
   lfp (?f57 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
         ax) \<equiv>\<^sup>?
?f57
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (?f57 a b c d e f g h i j k l m n o p q r s t u v
                            w x y z aa ab ac ad ae af ag ah ai aj ak al am
                            an ao ap aq ar as at au av aw
                            ax))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
### theory "Order_Lattice_Props.Sup_Lattice"
### 3.025s elapsed time, 14.894s cpu time, 1.176s GC time
Loading theory "Order_Lattice_Props.Order_Duality"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay.
   gfp (?f58 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax
         ay) \<equiv>\<^sup>?
?f58
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (?f58 a b c d e f g h i j k l m n o p q r
                                    s t u v w x y z aa ab ac ad ae af ag ah
                                    ai aj ak al am an ao ap aq ar as at au
                                    av aw ax
                                    ay)))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay.
   lfp (?f58 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax
         ay) \<equiv>\<^sup>?
?f58
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (?f58 a b c d e f g h i j k l m n o p q r
                                    s t u v w x y z aa ab ac ad ae af ag ah
                                    ai aj ak al am an ao ap aq ar as at au
                                    av aw ax
                                    ay)))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az.
   lfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
         az) \<equiv>\<^sup>?
?f59
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
      af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
      az))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az.
   gfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
         az) \<equiv>\<^sup>?
?f59
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
      af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
      az))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class dual = type +
  fixes dual :: "'a \<Rightarrow> 'a"
  assumes "inj_dual": "inj \<partial>"
    and "invol_dual": "\<partial> \<circ> \<partial> = id"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba.
   lfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba) \<equiv>\<^sup>?
?f60
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab
              ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
              ax ay az
              ba)))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba.
   gfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba) \<equiv>\<^sup>?
?f60
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab
              ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
              ax ay az
              ba)))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class preorder = ord +
  assumes
    "less_le_not_le":
      "\<And>x y. (x < y) = (x \<le> y \<and> \<not> y \<le> x)"
    and "order_refl": "\<And>x. x \<le> x"
    and
    "order_trans":
      "\<And>x y z.
          \<lbrakk>x \<le> y; y \<le> z\<rbrakk>
          \<Longrightarrow> x \<le> z"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb.
   lfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb) \<equiv>\<^sup>?
?f61
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y
                      z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq
                      ar as at au av aw ax ay az ba
                      bb))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class dual = type +
  fixes dual :: "'a \<Rightarrow> 'a"
  assumes "inj_dual": "inj \<partial>"
    and "invol_dual": "\<partial> \<circ> \<partial> = id"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc.
   lfp (?f62 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc) \<equiv>\<^sup>?
?f62
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (?f62 a b c d e f g h i j k l m n o p q r s t u
                              v w x y z aa ab ac ad ae af ag ah ai aj ak al
                              am an ao ap aq ar as at au av aw ax ay az ba
                              bb bc)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb.
   gfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb) \<equiv>\<^sup>?
?f61
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y
                      z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq
                      ar as at au av aw ax ay az ba
                      bb))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd.
   lfp (?f63 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd) \<equiv>\<^sup>?
?f63
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (?f63 a b c d e f g h i j k l m n o p q
r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as
at au av aw ax ay az ba bb bc
bd))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc.
   gfp (?f62 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc) \<equiv>\<^sup>?
?f62
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (?f62 a b c d e f g h i j k l m n o p q r s t u
                              v w x y z aa ab ac ad ae af ag ah ai aj ak al
                              am an ao ap aq ar as at au av aw ax ay az ba
                              bb bc)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be.
   lfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be) \<equiv>\<^sup>?
?f64
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
        ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba
        bb bc bd
        be)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class dual = type +
  fixes dual :: "'a \<Rightarrow> 'a"
  assumes "inj_dual": "inj \<partial>"
    and "invol_dual": "\<partial> \<circ> \<partial> = id"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf.
   lfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf) \<equiv>\<^sup>?
?f65
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (\<lambda>bf.
          lfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa
                ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au
                av aw ax ay az ba bb bc bd be
                bf))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd.
   gfp (?f63 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd) \<equiv>\<^sup>?
?f63
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (?f63 a b c d e f g h i j k l m n o p q
r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as
at au av aw ax ay az ba bb bc
bd))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf bg.
   lfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf bg) \<equiv>\<^sup>?
?f66
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (\<lambda>bf.
          lfp (\<lambda>bg.
                  lfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x
                        y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap
                        aq ar as at au av aw ax ay az ba bb bc bd be bf
                        bg)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
class order = preorder +
  assumes
    "antisym":
      "\<And>x y.
          \<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> x = y"
### Unification bound exceeded
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax.
   lfp (?f57 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
         ax) \<equiv>\<^sup>?
?f57
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (?f57 a b c d e f g h i j k l m n o p q r s t u v
                            w x y z aa ab ac ad ae af ag ah ai aj ak al am
                            an ao ap aq ar as at au av aw
                            ax))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be.
   gfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be) \<equiv>\<^sup>?
?f64
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
        ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba
        bb bc bd
        be)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay.
   lfp (?f58 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax
         ay) \<equiv>\<^sup>?
?f58
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (?f58 a b c d e f g h i j k l m n o p q r
                                    s t u v w x y z aa ab ac ad ae af ag ah
                                    ai aj ak al am an ao ap aq ar as at au
                                    av aw ax
                                    ay)))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az.
   lfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
         az) \<equiv>\<^sup>?
?f59
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
      af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
      az))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf.
   gfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf) \<equiv>\<^sup>?
?f65
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (\<lambda>bf.
          gfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa
                ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au
                av aw ax ay az ba bb bc bd be
                bf))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class ord_with_dual = dual + ord +
  assumes
    "ord_dual":
      "\<And>x y.
          x \<le> y \<Longrightarrow> \<partial> y \<le> \<partial> x"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba.
   lfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba) \<equiv>\<^sup>?
?f60
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab
              ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
              ax ay az
              ba)))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf bg.
   gfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf bg) \<equiv>\<^sup>?
?f66
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (\<lambda>bf.
          gfp (\<lambda>bg.
                  gfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x
                        y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap
                        aq ar as at au av aw ax ay az ba bb bc bd be bf
                        bg)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
### Unification bound exceeded
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax.
   gfp (?f57 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
         ax) \<equiv>\<^sup>?
?f57
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (?f57 a b c d e f g h i j k l m n o p q r s t u v
                            w x y z aa ab ac ad ae af ag ah ai aj ak al am
                            an ao ap aq ar as at au av aw
                            ax))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb.
   lfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb) \<equiv>\<^sup>?
?f61
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y
                      z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq
                      ar as at au av aw ax ay az ba
                      bb))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay.
   gfp (?f58 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax
         ay) \<equiv>\<^sup>?
?f58
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (?f58 a b c d e f g h i j k l m n o p q r
                                    s t u v w x y z aa ab ac ad ae af ag ah
                                    ai aj ak al am an ao ap aq ar as at au
                                    av aw ax
                                    ay)))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az.
   gfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
         az) \<equiv>\<^sup>?
?f59
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (?f59 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
      af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay
      az))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc.
   lfp (?f62 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc) \<equiv>\<^sup>?
?f62
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (?f62 a b c d e f g h i j k l m n o p q r s t u
                              v w x y z aa ab ac ad ae af ag ah ai aj ak al
                              am an ao ap aq ar as at au av aw ax ay az ba
                              bb bc)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba.
   gfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba) \<equiv>\<^sup>?
?f60
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (?f60 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab
              ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw
              ax ay az
              ba)))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb.
   gfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb) \<equiv>\<^sup>?
?f61
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (?f61 a b c d e f g h i j k l m n o p q r s t u v w x y
                      z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq
                      ar as at au av aw ax ay az ba
                      bb))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd.
   lfp (?f63 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd) \<equiv>\<^sup>?
?f63
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (?f63 a b c d e f g h i j k l m n o p q
r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as
at au av aw ax ay az ba bb bc
bd))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc.
   gfp (?f62 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc) \<equiv>\<^sup>?
?f62
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (?f62 a b c d e f g h i j k l m n o p q r s t u
                              v w x y z aa ab ac ad ae af ag ah ai aj ak al
                              am an ao ap aq ar as at au av aw ax ay az ba
                              bb bc)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be.
   lfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be) \<equiv>\<^sup>?
?f64
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
        ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba
        bb bc bd
        be)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd.
   gfp (?f63 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd) \<equiv>\<^sup>?
?f63
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (?f63 a b c d e f g h i j k l m n o p q
r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as
at au av aw ax ay az ba bb bc
bd))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf.
   lfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf) \<equiv>\<^sup>?
?f65
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (\<lambda>bf.
          lfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa
                ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au
                av aw ax ay az ba bb bc bd be
                bf))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be.
   gfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be) \<equiv>\<^sup>?
?f64
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (?f64 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
        ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba
        bb bc bd
        be)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf bg.
   lfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf bg) \<equiv>\<^sup>?
?f66
 (lfp (\<lambda>a.
          lfp (\<lambda>b.
                  lfp (\<lambda>c.
                          lfp (\<lambda>d.
                                  lfp (\<lambda>e.
    lfp (\<lambda>f.
            lfp (\<lambda>g.
                    lfp (\<lambda>h.
                            lfp (\<lambda>i.
                                    lfp (\<lambda>j.
      lfp (\<lambda>k.
              lfp (\<lambda>l.
                      lfp (\<lambda>m.
                              lfp (\<lambda>n.
lfp (\<lambda>o.
        lfp (\<lambda>p.
                lfp (\<lambda>q.
                        lfp (\<lambda>r.
                                lfp (\<lambda>s.
  lfp (\<lambda>t.
          lfp (\<lambda>u.
                  lfp (\<lambda>v.
                          lfp (\<lambda>w.
                                  lfp (\<lambda>x.
    lfp (\<lambda>y.
            lfp (\<lambda>z.
                    lfp (\<lambda>aa.
                            lfp (\<lambda>ab.
                                    lfp (\<lambda>ac.
      lfp (\<lambda>ad.
              lfp (\<lambda>ae.
                      lfp (\<lambda>af.
                              lfp (\<lambda>ag.
lfp (\<lambda>ah.
        lfp (\<lambda>ai.
                lfp (\<lambda>aj.
                        lfp (\<lambda>ak.
                                lfp (\<lambda>al.
  lfp (\<lambda>am.
          lfp (\<lambda>an.
                  lfp (\<lambda>ao.
                          lfp (\<lambda>ap.
                                  lfp (\<lambda>aq.
    lfp (\<lambda>ar.
            lfp (\<lambda>as.
                    lfp (\<lambda>at.
                            lfp (\<lambda>au.
                                    lfp (\<lambda>av.
      lfp (\<lambda>aw.
              lfp (\<lambda>ax.
                      lfp (\<lambda>ay.
                              lfp (\<lambda>az.
lfp (\<lambda>ba.
        lfp (\<lambda>bb.
                lfp (\<lambda>bc.
                        lfp (\<lambda>bd.
                                lfp (\<lambda>be.
  lfp (\<lambda>bf.
          lfp (\<lambda>bg.
                  lfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x
                        y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap
                        aq ar as at au av aw ax ay az ba bb bc bd be bf
                        bg)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
### Unification bound exceeded
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf.
   gfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf) \<equiv>\<^sup>?
?f65
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (\<lambda>bf.
          gfp (?f65 a b c d e f g h i j k l m n o p q r s t u v w x y z aa
                ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au
                av aw ax ay az ba bb bc bd be
                bf))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
Enter MATCH
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
\<lambda>a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae
   af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc
   bd be bf bg.
   gfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad
         ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
         ba bb bc bd be bf bg) \<equiv>\<^sup>?
?f66
 (gfp (\<lambda>a.
          gfp (\<lambda>b.
                  gfp (\<lambda>c.
                          gfp (\<lambda>d.
                                  gfp (\<lambda>e.
    gfp (\<lambda>f.
            gfp (\<lambda>g.
                    gfp (\<lambda>h.
                            gfp (\<lambda>i.
                                    gfp (\<lambda>j.
      gfp (\<lambda>k.
              gfp (\<lambda>l.
                      gfp (\<lambda>m.
                              gfp (\<lambda>n.
gfp (\<lambda>o.
        gfp (\<lambda>p.
                gfp (\<lambda>q.
                        gfp (\<lambda>r.
                                gfp (\<lambda>s.
  gfp (\<lambda>t.
          gfp (\<lambda>u.
                  gfp (\<lambda>v.
                          gfp (\<lambda>w.
                                  gfp (\<lambda>x.
    gfp (\<lambda>y.
            gfp (\<lambda>z.
                    gfp (\<lambda>aa.
                            gfp (\<lambda>ab.
                                    gfp (\<lambda>ac.
      gfp (\<lambda>ad.
              gfp (\<lambda>ae.
                      gfp (\<lambda>af.
                              gfp (\<lambda>ag.
gfp (\<lambda>ah.
        gfp (\<lambda>ai.
                gfp (\<lambda>aj.
                        gfp (\<lambda>ak.
                                gfp (\<lambda>al.
  gfp (\<lambda>am.
          gfp (\<lambda>an.
                  gfp (\<lambda>ao.
                          gfp (\<lambda>ap.
                                  gfp (\<lambda>aq.
    gfp (\<lambda>ar.
            gfp (\<lambda>as.
                    gfp (\<lambda>at.
                            gfp (\<lambda>au.
                                    gfp (\<lambda>av.
      gfp (\<lambda>aw.
              gfp (\<lambda>ax.
                      gfp (\<lambda>ay.
                              gfp (\<lambda>az.
gfp (\<lambda>ba.
        gfp (\<lambda>bb.
                gfp (\<lambda>bc.
                        gfp (\<lambda>bd.
                                gfp (\<lambda>be.
  gfp (\<lambda>bf.
          gfp (\<lambda>bg.
                  gfp (?f66 a b c d e f g h i j k l m n o p q r s t u v w x
                        y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap
                        aq ar as at au av aw ax ay az ba bb bc bd be bf
                        bg)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Failure node
### Unification bound exceeded
class lattice_with_dual = lattice + dual +
  assumes
    "sup_dual_def":
      "\<And>x y.
          \<partial> (x \<squnion> y) =
          \<partial> x \<sqinter> \<partial> y"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
### theory "Order_Lattice_Props.Order_Lattice_Props_Loc"
### 4.409s elapsed time, 20.629s cpu time, 1.449s GC time
class Sup_lattice_with_dual = dual + Sup_lattice +
  assumes
    "Sups_dual_def": "\<partial> \<circ> Sup = Infs \<circ> (`) \<partial>"
class Inf_lattice_with_dual = dual + Inf_lattice +
  assumes
    "Sups_dual_def": "\<partial> \<circ> Supi = Inf \<circ> (`) \<partial>"
class complete_lattice_with_dual = complete_lattice + dual +
  assumes
    "Sups_dual_def": "\<partial> \<circ> Sup = Inf \<circ> (`) \<partial>"
class complete_lattice_with_dual = complete_lattice + dual +
  assumes
    "Sups_dual_def": "\<partial> \<circ> Sup = Inf \<circ> (`) \<partial>"
### theory "Order_Lattice_Props.Order_Duality"
### 4.145s elapsed time, 10.977s cpu time, 1.365s GC time
Loading theory "Order_Lattice_Props.Order_Lattice_Props"
### Metis: Unused theorems: "Orderings.order_class.eq_iff"
### Ignoring duplicate rewrite rule:
### \<partial>\<^sub>F \<circ> \<partial>\<^sub>F \<equiv> id
### Ignoring duplicate rewrite rule:
### \<partial>\<^sub>F \<circ> \<partial>\<^sub>F \<equiv> id
### Metis: Unused theorems: "Fun.inj_def", "Fun.the_inv_f_f"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class ord_with_dual = dual + ord +
  assumes
    "ord_dual":
      "\<And>x y.
          x \<le> y \<Longrightarrow> \<partial> y \<le> \<partial> x"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class ord_with_dual = dual + ord +
  assumes
    "ord_dual":
      "\<And>x y.
          x \<le> y \<Longrightarrow> \<partial> y \<le> \<partial> x"
class ord = type +
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
class preorder = ord +
  assumes
    "less_le_not_le":
      "\<And>x y. (x < y) = (x \<le> y \<and> \<not> y \<le> x)"
    and "order_refl": "\<And>x. x \<le> x"
    and
    "order_trans":
      "\<And>x y z.
          \<lbrakk>x \<le> y; y \<le> z\<rbrakk>
          \<Longrightarrow> x \<le> z"
class order = preorder +
  assumes
    "antisym":
      "\<And>x y.
          \<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> x = y"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
*** Failed to apply initial proof method (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy"):
*** goal (1 subgoal):
***  1. \<Squnion> (\<Inter>x\<in>X. {y. y \<le> x}) = \<Sqinter> X
*** At command "by" (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy")
class ord_with_dual = dual + ord +
  assumes
    "ord_dual":
      "\<And>x y.
          x \<le> y \<Longrightarrow> \<partial> y \<le> \<partial> x"
class lattice_with_dual = lattice + order_with_dual +
  assumes
    "sup_dual_def":
      "\<And>x y.
          \<partial> (x \<squnion> y) =
          \<partial> x \<sqinter> \<partial> y"
class complete_lattice_with_dual = complete_lattice +
  bounded_lattice_with_dual +
  assumes
    "Sups_dual_def": "\<partial> \<circ> Sup = Inf \<circ> (`) \<partial>"
*** Failed to apply initial proof method (line 652 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy"):
*** goal (1 subgoal):
***  1. \<Sqinter> (\<Inter>x\<in>X. Collect ((\<le>) x)) = \<Squnion> X
*** At command "by" (line 652 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy")
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "\<And>x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "\<And>x. x \<squnion> - x = \<top>"
  assumes "diff_eq": "\<And>x y. x - y = x \<sqinter> - y"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
### Ignoring duplicate rewrite rule:
### \<partial>\<^sub>F \<circ> \<partial>\<^sub>F \<equiv> id
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes
    "Inf_lower":
      "\<And>x A. x \<in> A \<Longrightarrow> \<Sqinter> A \<le> x"
    and
    "Inf_greatest":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow>
          z \<le> \<Sqinter> A"
    and
    "Sup_upper":
      "\<And>x A. x \<in> A \<Longrightarrow> x \<le> \<Squnion> A"
    and
    "Sup_least":
      "\<And>A z.
          (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow>
          \<Squnion> A \<le> z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
instantiation
  iso :: (complete_lattice) complete_lattice
  Inf_iso == Inf :: 'a iso set \<Rightarrow> 'a iso
  Sup_iso == Sup :: 'a iso set \<Rightarrow> 'a iso
  bot_iso == bot :: 'a iso
  sup_iso == sup :: 'a iso \<Rightarrow> 'a iso \<Rightarrow> 'a iso
  top_iso == top :: 'a iso
  inf_iso == inf :: 'a iso \<Rightarrow> 'a iso \<Rightarrow> 'a iso
  less_eq_iso == less_eq :: 'a iso \<Rightarrow> 'a iso \<Rightarrow> bool
  less_iso == less :: 'a iso \<Rightarrow> 'a iso \<Rightarrow> bool
class complete_heyting_algebra = complete_lattice +
  assumes
    "ch_dist":
      "\<And>x Y.
          x \<sqinter> \<Squnion> Y = \<Squnion> ((\<sqinter>) x ` Y)"
class complete_co_heyting_algebra = complete_lattice +
  assumes
    "co_ch_dist":
      "\<And>x Y.
          x \<squnion> \<Sqinter> Y = \<Sqinter> ((\<squnion>) x ` Y)"
instantiation
  set :: (type) complete_boolean_algebra_alt_with_dual
  dual_set == dual :: 'a set \<Rightarrow> 'a set
class atomic_boolean_algebra = boolean_algebra +
  assumes
    "atomicity":
      "\<And>x.
          x \<noteq> \<bottom> \<Longrightarrow>
          \<exists>y. atom y \<and> y \<le> x"
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "\<And>x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "\<And>x. x \<squnion> - x = \<top>"
  assumes "diff_eq": "\<And>x y. x - y = x \<sqinter> - y"
### theory "Order_Lattice_Props.Order_Lattice_Props"
### 5.559s elapsed time, 16.398s cpu time, 2.938s GC time
Loading theory "Order_Lattice_Props.Galois_Connections"
Loading theory "Order_Lattice_Props.Representations"
### theory "Order_Lattice_Props.Galois_Connections"
### 0.118s elapsed time, 0.846s cpu time, 0.060s GC time
Loading theory "Order_Lattice_Props.Closure_Operators"
Loading theory "Order_Lattice_Props.Fixpoint_Fusion"
instantiation
  downset :: (ord) order
  less_eq_downset == less_eq ::
    'a downset \<Rightarrow> 'a downset \<Rightarrow> bool
  less_downset == less ::
    'a downset \<Rightarrow> 'a downset \<Rightarrow> bool
### theory "Order_Lattice_Props.Fixpoint_Fusion"
### 0.056s elapsed time, 0.436s cpu time, 0.050s GC time
instantiation
  upset :: (ord) order
  less_eq_upset == less_eq ::
    'a upset \<Rightarrow> 'a upset \<Rightarrow> bool
  less_upset == less :: 'a upset \<Rightarrow> 'a upset \<Rightarrow> bool
instantiation
  downsets :: (order) Inf_lattice
  Inf_downsets == Inf :: 'a downsets set \<Rightarrow> 'a downsets
  less_eq_downsets == less_eq ::
    'a downsets \<Rightarrow> 'a downsets \<Rightarrow> bool
  less_downsets == less ::
    'a downsets \<Rightarrow> 'a downsets \<Rightarrow> bool
instantiation
  upsets :: (order_with_dual) Inf_lattice
  Inf_upsets == Inf :: 'a upsets set \<Rightarrow> 'a upsets
  less_eq_upsets == less_eq ::
    'a upsets \<Rightarrow> 'a upsets \<Rightarrow> bool
  less_upsets == less ::
    'a upsets \<Rightarrow> 'a upsets \<Rightarrow> bool
### Metis: Unused theorems: "local.assms_1"
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "\<And>x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "\<And>x. x \<squnion> - x = \<top>"
  assumes "diff_eq": "\<And>x y. x - y = x \<sqinter> - y"
instantiation
  atoms :: (boolean_algebra) boolean_algebra
  minus_atoms == minus ::
    'a atoms \<Rightarrow> 'a atoms \<Rightarrow> 'a atoms
  uminus_atoms == uminus :: 'a atoms \<Rightarrow> 'a atoms
  bot_atoms == bot :: 'a atoms
  top_atoms == top :: 'a atoms
  inf_atoms == inf :: 'a atoms \<Rightarrow> 'a atoms \<Rightarrow> 'a atoms
  sup_atoms == sup :: 'a atoms \<Rightarrow> 'a atoms \<Rightarrow> 'a atoms
  less_eq_atoms == less_eq ::
    'a atoms \<Rightarrow> 'a atoms \<Rightarrow> bool
  less_atoms == less :: 'a atoms \<Rightarrow> 'a atoms \<Rightarrow> bool
class cl_op = ord +
  fixes cl_op :: "'a \<Rightarrow> 'a"
  assumes "clop_ext": "\<And>x. x \<le> cl_op x"
    and
    "clop_iso":
      "\<And>x y. x \<le> y \<Longrightarrow> cl_op x \<le> cl_op y"
    and "clop_wtrans": "\<And>x. cl_op (cl_op x) \<le> cl_op x"
class atomic_boolean_algebra = boolean_algebra +
  assumes
    "atomicity":
      "\<And>x.
          x \<noteq> \<bottom> \<Longrightarrow>
          \<exists>y. atom y \<and> y \<le> x"
instantiation
  atoms :: (complete_boolean_algebra_alt) complete_boolean_algebra_alt
  Inf_atoms == Inf :: 'a atoms set \<Rightarrow> 'a atoms
  Sup_atoms == Sup :: 'a atoms set \<Rightarrow> 'a atoms
### theory "Order_Lattice_Props.Representations"
### 1.097s elapsed time, 8.705s cpu time, 0.483s GC time
### Ignoring duplicate rewrite rule:
### \<partial>\<^sub>F \<circ> \<partial>\<^sub>F \<equiv> id
instantiation
  cl_op_im :: (clattice_with_clop) complete_lattice
  Inf_cl_op_im == Inf :: 'a cl_op_im set \<Rightarrow> 'a cl_op_im
  Sup_cl_op_im == Sup :: 'a cl_op_im set \<Rightarrow> 'a cl_op_im
  bot_cl_op_im == bot :: 'a cl_op_im
  sup_cl_op_im == sup ::
    'a cl_op_im \<Rightarrow> 'a cl_op_im \<Rightarrow> 'a cl_op_im
  top_cl_op_im == top :: 'a cl_op_im
  inf_cl_op_im == inf ::
    'a cl_op_im \<Rightarrow> 'a cl_op_im \<Rightarrow> 'a cl_op_im
  less_eq_cl_op_im == less_eq ::
    'a cl_op_im \<Rightarrow> 'a cl_op_im \<Rightarrow> bool
  less_cl_op_im == less ::
    'a cl_op_im \<Rightarrow> 'a cl_op_im \<Rightarrow> bool
### theory "Order_Lattice_Props.Closure_Operators"
### 1.221s elapsed time, 9.635s cpu time, 0.549s GC time
*** Failed to apply initial proof method (line 652 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy"):
*** goal (1 subgoal):
***  1. \<Sqinter> (\<Inter>x\<in>X. Collect ((\<le>) x)) = \<Squnion> X
*** At command "by" (line 652 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy")
*** Failed to apply initial proof method (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy"):
*** goal (1 subgoal):
***  1. \<Squnion> (\<Inter>x\<in>X. {y. y \<le> x}) = \<Sqinter> X
*** At command "by" (line 501 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy")
*** Failed to apply initial proof method (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy"):
*** goal (1 subgoal):
***  1. \<Squnion> (\<Inter>x\<in>X. {y. y \<le> x}) = \<Sqinter> X
*** At command "by" (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy")

==========
Partial_Function_MR
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Partial_Function_MR.Partial_Function_MR_Examples" via "HOL-Library.Monad_Syntax")
Loading theory "Partial_Function_MR.Partial_Function_MR" (required by "Partial_Function_MR.Partial_Function_MR_Examples")
signature PARTIAL_FUNCTION_MR =
  sig
    val add_partial_function_mr:
       string ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             local_theory -> thm list * local_theory
    val add_partial_function_mr_cmd:
       string ->
         (binding * string option * mixfix) list ->
           Specification.multi_specs_cmd ->
             local_theory -> thm list * local_theory
    val init:
       string ->
         (term * term list * typ * typ * typ list -> term) ->
           (typ list * typ list -> typ) ->
             (typ -> typ list * typ list) ->
               thm list -> thm list -> declaration
  end
### theory "Partial_Function_MR.Partial_Function_MR"
### 0.064s elapsed time, 0.149s cpu time, 0.000s GC time
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.082s elapsed time, 0.171s cpu time, 0.000s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Partial_Function_MR.Partial_Function_MR_Examples")
### theory "HOL-Library.Monad_Syntax"
### 0.020s elapsed time, 0.020s cpu time, 0.000s GC time
*** Failed to load theory "Partial_Function_MR.Partial_Function_MR_Examples" (unresolved "Partial_Function_MR.Partial_Function_MR")
*** ML error (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Partial_Function_MR/partial_function_mr.ML"):
*** Type error in function application.
***    Function: Spec_Rules.add :
***       binding ->
***         Spec_Rules.rough_classification ->
***           term list -> thm list -> local_theory -> local_theory
***    Argument: Spec_Rules.equational_recdef : Spec_Rules.rough_classification
***    Reason:
***       Can't unify binding with Spec_Rules.rough_classification
***          (Different type constructors)
*** ML error (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Partial_Function_MR/partial_function_mr.ML"):
*** Type error in function application.
***    Function: Spec_Rules.add Spec_Rules.equational_recdef :
***       Spec_Rules.rough_classification ->
***         term list -> thm list -> local_theory -> local_theory
***    Argument: ([f], simps) : term list * 'a
***    Reason:
***       Can't unify Spec_Rules.rough_classification to term list * 'a
***          (Incompatible types)
*** ML error (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Partial_Function_MR/partial_function_mr.ML"):
*** Type error in function application.
***    Function: #> :
***       (term list -> thm list -> local_theory -> local_theory) *
***       ((thm list -> local_theory -> local_theory) -> 'a)
***         -> term list -> 'a
***    Argument:
***       (
***          Spec_Rules.add Spec_Rules.equational_recdef ([f], simps),
***          Local_Theory.note ((... ..., ...), simps)
***          )
***       : (term list -> thm list -> local_theory -> local_theory) *
***         (local_theory -> (string * thm list) * local_theory)
***    Reason:
***       Can't unify local_theory to thm list -> local_theory -> local_theory
***          (Incompatible types)
*** ML error (line 315 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Partial_Function_MR/partial_function_mr.ML"):
*** Type error in function application.
***    Function: |-> :
***       ((string * thm list) * local_theory) *
***       (string * thm list -> local_theory -> 'a)
***         -> 'a
***    Argument:
***       (
***          lthy |> Local_Theory.note (eq_abinding, [...]),
***          (fn (_, ...) => ... #>> ... #>> hd)
***          )
***       : ((string * thm list) * local_theory) *
***         (string * thm list -> term list -> 'a * 'b)
***    Reason:
***       Can't unify local_theory = Context.Proof.context with
***          term list (*In Basis*) (Different type constructors)
*** At command "ML_file" (line 9 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Partial_Function_MR/Partial_Function_MR.thy")

==========
Poincare_Disc
Loading theory "Complex_Geometry.More_Set" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines" via "Complex_Geometry.Circlines")
Loading theory "Complex_Geometry.More_Transcendental" (required by "Poincare_Disc.Hyperbolic_Functions" via "Complex_Geometry.More_Complex")
Loading theory "HOL-Library.Quadratic_Discriminant" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Unitary11_Matrices" via "Complex_Geometry.Matrices" via "Complex_Geometry.Quadratic")
Loading theory "Complex_Geometry.Linear_Systems" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Unitary11_Matrices" via "Complex_Geometry.Matrices")
Loading theory "Poincare_Disc.Tarski"
### theory "Complex_Geometry.More_Set"
### 0.039s elapsed time, 0.267s cpu time, 0.000s GC time
locale TarskiAbsolute
  fixes
    cong ::
      "'p \<Rightarrow> 'p \<Rightarrow> 'p
   \<Rightarrow> 'p \<Rightarrow> bool"
    and betw :: "'p \<Rightarrow> 'p \<Rightarrow> 'p \<Rightarrow> bool"
  assumes "TarskiAbsolute cong betw"
### theory "Complex_Geometry.Linear_Systems"
### 0.076s elapsed time, 0.513s cpu time, 0.032s GC time
### theory "HOL-Library.Quadratic_Discriminant"
### 0.085s elapsed time, 0.570s cpu time, 0.032s GC time
locale TarskiHyperbolic
  fixes
    cong ::
      "'a \<Rightarrow> 'a \<Rightarrow> 'a
   \<Rightarrow> 'a \<Rightarrow> bool"
    and betw :: "'a \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "TarskiHyperbolic cong betw"
### theory "Complex_Geometry.More_Transcendental"
### 0.146s elapsed time, 1.016s cpu time, 0.032s GC time
Loading theory "Complex_Geometry.Canonical_Angle" (required by "Poincare_Disc.Hyperbolic_Functions" via "Complex_Geometry.More_Complex")
locale ElementaryTarskiHyperbolic
  fixes
    cong ::
      "'a \<Rightarrow> 'a \<Rightarrow> 'a
   \<Rightarrow> 'a \<Rightarrow> bool"
    and betw :: "'a \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "ElementaryTarskiHyperbolic cong betw"
### theory "Poincare_Disc.Tarski"
### 0.170s elapsed time, 1.160s cpu time, 0.071s GC time
### theory "Complex_Geometry.Canonical_Angle"
### 0.103s elapsed time, 0.693s cpu time, 0.033s GC time
Loading theory "Complex_Geometry.More_Complex" (required by "Poincare_Disc.Hyperbolic_Functions")
### theory "Complex_Geometry.More_Complex"
### 0.383s elapsed time, 2.612s cpu time, 0.117s GC time
Loading theory "Complex_Geometry.Angles" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines" via "Complex_Geometry.Circlines" via "Complex_Geometry.Elementary_Complex_Geometry")
Loading theory "Complex_Geometry.Quadratic" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Unitary11_Matrices" via "Complex_Geometry.Matrices")
Loading theory "Poincare_Disc.Hyperbolic_Functions"
### theory "Poincare_Disc.Hyperbolic_Functions"
### 0.047s elapsed time, 0.344s cpu time, 0.000s GC time
### theory "Complex_Geometry.Angles"
### 0.107s elapsed time, 0.739s cpu time, 0.063s GC time
Loading theory "Complex_Geometry.Elementary_Complex_Geometry" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines" via "Complex_Geometry.Circlines")
### theory "Complex_Geometry.Quadratic"
### 0.310s elapsed time, 2.103s cpu time, 0.105s GC time
Loading theory "Complex_Geometry.Matrices" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Unitary11_Matrices")
### theory "Complex_Geometry.Elementary_Complex_Geometry"
### 0.375s elapsed time, 2.378s cpu time, 0.116s GC time
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
Found termination order: "{}"
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
Found termination order: "{}"
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
linarith_split_limit exceeded (current value is 9)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Complex_Geometry.Matrices"
### 1.972s elapsed time, 13.120s cpu time, 1.208s GC time
Loading theory "Complex_Geometry.Homogeneous_Coordinates" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Moebius")
Loading theory "Complex_Geometry.Unitary11_Matrices" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius")
Loading theory "Complex_Geometry.Unitary_Matrices" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines" via "Complex_Geometry.Circlines" via "Complex_Geometry.Hermitean_Matrices")
### theory "Complex_Geometry.Unitary_Matrices"
### 0.241s elapsed time, 1.647s cpu time, 0.891s GC time
Loading theory "Complex_Geometry.Hermitean_Matrices" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines" via "Complex_Geometry.Circlines")
### theory "Complex_Geometry.Unitary11_Matrices"
### 0.356s elapsed time, 2.408s cpu time, 0.953s GC time
### theory "Complex_Geometry.Hermitean_Matrices"
### 0.097s elapsed time, 0.653s cpu time, 0.030s GC time
### theory "Complex_Geometry.Homogeneous_Coordinates"
### 1.034s elapsed time, 7.066s cpu time, 1.123s GC time
Loading theory "Complex_Geometry.Moebius" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius")
instantiation
  moebius :: group_add
  minus_moebius == minus ::
    moebius \<Rightarrow> moebius \<Rightarrow> moebius
  uminus_moebius == uminus_class.uminus :: moebius \<Rightarrow> moebius
  zero_moebius == zero_class.zero :: moebius
  plus_moebius == plus ::
    moebius \<Rightarrow> moebius \<Rightarrow> moebius
### theory "Complex_Geometry.Moebius"
### 0.852s elapsed time, 5.527s cpu time, 0.251s GC time
Loading theory "Complex_Geometry.Circlines" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius" via "Complex_Geometry.Oriented_Circlines")
### theory "Complex_Geometry.Circlines"
### 1.574s elapsed time, 7.317s cpu time, 1.444s GC time
Loading theory "Complex_Geometry.Oriented_Circlines" (required by "Poincare_Disc.Poincare_Lines" via "Complex_Geometry.Unit_Circle_Preserving_Moebius")
### theory "Complex_Geometry.Oriented_Circlines"
### 0.368s elapsed time, 1.131s cpu time, 0.063s GC time
Loading theory "Complex_Geometry.Circlines_Angle" (required by "Poincare_Disc.Poincare_Lines")
Loading theory "Complex_Geometry.Unit_Circle_Preserving_Moebius" (required by "Poincare_Disc.Poincare_Lines")
Found termination order: "{}"
### theory "Complex_Geometry.Circlines_Angle"
### 0.206s elapsed time, 0.929s cpu time, 0.051s GC time
### theory "Complex_Geometry.Unit_Circle_Preserving_Moebius"
### 0.335s elapsed time, 1.402s cpu time, 0.119s GC time
Loading theory "Poincare_Disc.Poincare_Lines"
### theory "Poincare_Disc.Poincare_Lines"
### 0.363s elapsed time, 2.820s cpu time, 0.127s GC time
Loading theory "Poincare_Disc.Poincare_Lines_Ideal_Points"
### theory "Poincare_Disc.Poincare_Lines_Ideal_Points"
### 0.146s elapsed time, 1.127s cpu time, 0.049s GC time
Loading theory "Poincare_Disc.Poincare_Distance"
### theory "Poincare_Disc.Poincare_Distance"
### 0.271s elapsed time, 2.095s cpu time, 0.089s GC time
Loading theory "Poincare_Disc.Poincare_Between"
Loading theory "Poincare_Disc.Poincare_Circles"
### theory "Poincare_Disc.Poincare_Between"
### 0.110s elapsed time, 0.864s cpu time, 0.044s GC time
Loading theory "Poincare_Disc.Poincare_Lines_Axis_Intersections"
### theory "Poincare_Disc.Poincare_Circles"
### 0.242s elapsed time, 1.865s cpu time, 0.094s GC time
Loading theory "Poincare_Disc.Poincare"
### theory "Poincare_Disc.Poincare_Lines_Axis_Intersections"
### 0.358s elapsed time, 1.886s cpu time, 0.104s GC time
Loading theory "Poincare_Disc.Poincare_Perpendicular"
### theory "Poincare_Disc.Poincare_Perpendicular"
### 0.122s elapsed time, 0.523s cpu time, 0.036s GC time
instantiation
  p_point :: metric_space
  dist_p_point == dist :: p_point \<Rightarrow> p_point \<Rightarrow> real
  uniformity_p_point == uniformity :: (p_point \<times> p_point) filter
  open_p_point == open :: p_point set \<Rightarrow> bool
### theory "Poincare_Disc.Poincare"
### 0.445s elapsed time, 1.660s cpu time, 0.090s GC time
*** Undefined fact: "sign_simps" (line 282 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "by" (line 282 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Undefined fact: "sign_simps" (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "apply" (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 586 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "by" (line 586 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Circles.thy")
*** At command "by" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Circles.thy")
\<lbrakk>1 \<le> ?x; 1 \<le> ?y\<rbrakk>
\<Longrightarrow> arcosh ?x + arcosh ?y =
                  arcosh
                   (?x * ?y + sqrt ((?x\<^sup>2 - 1) * (?y\<^sup>2 - 1)))
*** Failed to load theory "Poincare_Disc.Poincare_Tarski" (unresolved "Poincare_Disc.Poincare")
*** Undefined fact: "linordered_field_class.sign_simps" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Circles.thy")
*** At command "by" (line 83 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Circles.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 586 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "by" (line 586 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Undefined fact: "sign_simps" (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "apply" (line 248 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Undefined fact: "sign_simps" (line 282 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** At command "by" (line 282 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy")
*** Inner syntax error (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare.thy")
*** at ": { 0 <..} . principal { ( x , y ) . dist_class.dist x y < e } )"
*** Failed to parse prop
*** At command "definition" (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Poincare_Disc/Poincare.thy")

==========
Polynomial_Interpolation
Loading theory "Polynomial_Interpolation.Missing_Unsorted" (required by "Polynomial_Interpolation.Polynomial_Interpolation" via "Polynomial_Interpolation.Newton_Interpolation" via "Polynomial_Interpolation.Ring_Hom_Poly" via "Polynomial_Interpolation.Missing_Polynomial")
Loading theory "Polynomial_Interpolation.Improved_Code_Equations"
Loading theory "Polynomial_Interpolation.Neville_Aitken_Interpolation" (required by "Polynomial_Interpolation.Polynomial_Interpolation")
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary" (required by "Polynomial_Interpolation.Is_Rat_To_Rat")
Loading theory "Polynomial_Interpolation.Divmod_Int"
Loading theory "Polynomial_Interpolation.Ring_Hom" (required by "Polynomial_Interpolation.Polynomial_Interpolation" via "Polynomial_Interpolation.Newton_Interpolation" via "Polynomial_Interpolation.Ring_Hom_Poly")
### theory "Polynomial_Interpolation.Divmod_Int"
### 0.029s elapsed time, 0.203s cpu time, 0.000s GC time
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?a1; ?a1 \<noteq> 1\<rbrakk>
### \<Longrightarrow> log ?a1 (?a1 ^ ?b1) \<equiv> real ?b1
### Code generator: dropping subsumed code equation
### divmod_integer ?k ?l \<equiv>
### if ?k = 0 then (0, 0)
### else if 0 < ?l
###      then if 0 < ?k then Code_Numeral.divmod_abs ?k ?l
###           else case Code_Numeral.divmod_abs ?k ?l of
###                (r, s) \<Rightarrow>
###                  if s = 0 then (- r, 0) else (- r - 1, ?l - s)
###      else if ?l = 0 then (0, ?k)
###           else apsnd uminus
###                 (if ?k < 0 then Code_Numeral.divmod_abs ?k ?l
###                  else case Code_Numeral.divmod_abs ?k ?l of
###                       (r, s) \<Rightarrow>
###                         if s = 0 then (- r, 0) else (- r - 1, - ?l - s))
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n \<equiv>
### let k = integer_of_nat ?m; l = integer_of_nat ?n
### in map_prod nat_of_integer nat_of_integer
###     (if k = 0 then (0, 0)
###      else if l = 0 then (0, k) else Code_Numeral.divmod_abs k l)
### Code generator: dropping subsumed code equation
### ?n choose ?k \<equiv>
### if ?n < ?k then 0
### else if ?n < 2 * ?k then ?n choose (?n - ?k)
###      else fold_atLeastAtMost_nat (*) (?n - ?k + 1) ?n 1 div fact ?k
### theory "Polynomial_Interpolation.Improved_Code_Equations"
### 0.323s elapsed time, 2.405s cpu time, 0.157s GC time
Found termination order: "size_list (\<lambda>p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### max_list_non_empty [] = undefined
Found termination order: "length <*mlex*> {}"
locale zero_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "zero_hom hom"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "\<And>x.
          sgn x =
          (if x = (0::'a) then 0::'a
           else if (0::'a) < x then 1::'a else - (1::'a))"
locale one_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "one_hom hom"
locale times_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "times_hom hom"
locale plus_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "plus_hom hom"
locale semigroup_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "semigroup_mult_hom hom"
locale semigroup_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "semigroup_add_hom hom"
locale monoid_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_mult_hom hom"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "\<And>a. (1::'a) * a = a"
locale monoid_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_add_hom hom"
### theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary"
### 0.607s elapsed time, 4.584s cpu time, 0.336s GC time
Loading theory "Polynomial_Interpolation.Is_Rat_To_Rat"
locale group_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "group_add_hom hom"
*** Failed to finish proof (line 261 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. \<bar>a * Gcd (set xs)\<bar> = \<bar>a\<bar> * Gcd (set xs)
*** At command "by" (line 261 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
locale ab_semigroup_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "ab_semigroup_mult_hom hom"
*** Failed to finish proof (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. \<bar>k\<bar> * lcm m n = \<bar>k * lcm m n\<bar>
*** At command "by" (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
locale ab_semigroup_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "ab_semigroup_add_hom hom"
*** Failed to finish proof (line 281 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. xs \<noteq> [] \<longrightarrow>
***     \<bar>a * Lcm (set xs)\<bar> = \<bar>a\<bar> * Lcm (set xs)
*** At command "by" (line 281 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
locale comm_monoid_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_mult_hom hom"
Found termination order: "length <*mlex*> {}"
*** Undefined fact: "sign_simps" (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
*** At command "by" (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
locale comm_monoid_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_add_hom hom"
locale ab_group_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "ab_group_add_hom hom"
### theory "Polynomial_Interpolation.Neville_Aitken_Interpolation"
### 0.691s elapsed time, 5.202s cpu time, 0.378s GC time
locale semiring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "semiring_hom hom"
locale ring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "ring_hom hom"
locale comm_semiring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_semiring_hom hom"
locale comm_ring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_ring_hom hom"
locale idom_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "idom_hom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
locale idom_divide_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "idom_divide_hom hom"
locale field_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "field_hom hom"
locale field_char_0_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "field_char_0_hom hom"
locale zero_hom_0
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "zero_hom_0 hom"
locale one_hom_1
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "one_hom_1 hom"
locale monoid_mult_hom_1
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_mult_hom_1 hom"
locale monoid_add_hom_0
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_add_hom_0 hom"
locale comm_monoid_mult_hom_1
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_mult_hom_1 hom"
locale comm_monoid_add_hom_0
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_add_hom_0 hom"
locale injective
  fixes f :: "'a \<Rightarrow> 'b"
  assumes "injective f"
locale inj_zero_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_zero_hom hom"
locale inj_one_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_one_hom hom"
locale inj_semigroup_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_semigroup_mult_hom hom"
locale inj_semigroup_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_semigroup_add_hom hom"
locale inj_monoid_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_monoid_mult_hom hom"
locale inj_monoid_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_monoid_add_hom hom"
locale inj_comm_monoid_mult_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_comm_monoid_mult_hom hom"
locale inj_comm_monoid_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_comm_monoid_add_hom hom"
locale inj_semiring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_semiring_hom hom"
locale inj_comm_semiring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_comm_semiring_hom hom"
locale inj_group_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_group_add_hom hom"
locale inj_ab_group_add_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_ab_group_add_hom hom"
locale inj_ring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_ring_hom hom"
locale inj_comm_ring_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_comm_ring_hom hom"
### theory "Polynomial_Interpolation.Missing_Unsorted"
### 1.222s elapsed time, 9.093s cpu time, 0.601s GC time
Loading theory "Polynomial_Interpolation.Missing_Polynomial" (required by "Polynomial_Interpolation.Polynomial_Interpolation" via "Polynomial_Interpolation.Newton_Interpolation" via "Polynomial_Interpolation.Ring_Hom_Poly")
locale inj_idom_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_idom_hom hom"
locale field_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "field_hom hom"
locale surjective
  fixes f :: "'a \<Rightarrow> 'b"
  assumes "surjective f"
locale bijective
  fixes f :: "'a \<Rightarrow> 'b"
  assumes "bijective f"
locale bijective
  fixes f :: "'a \<Rightarrow> 'b"
  assumes "bijective f"
locale monoid_mult_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_mult_isom hom"
locale monoid_add_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "monoid_add_isom hom"
locale comm_monoid_mult_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_mult_isom hom"
class is_rat = field_char_0 +
  fixes is_rat :: "'a \<Rightarrow> bool"
    and to_rat :: "'a \<Rightarrow> rat"
  assumes
    "is_rat":
      "\<And>x.
          is_rat x =
          (x \<in> field_char_0.Rats (/) (1::'a) (+) (0::'a) (-))"
    and
    "to_rat":
      "\<And>x.
          to_rat x =
          (if x \<in> field_char_0.Rats (/) (1::'a) (+) (0::'a) (-)
           then THE y. x = field_char_0.of_rat (/) (1::'a) (+) (0::'a) (-) y
           else 0)"
instantiation
  rat :: is_rat
  is_rat_rat == is_rat :: rat \<Rightarrow> bool
  to_rat_rat == to_rat :: rat \<Rightarrow> rat
instantiation
  real :: is_rat
  is_rat_real == is_rat :: real \<Rightarrow> bool
  to_rat_real == to_rat :: real \<Rightarrow> rat
locale comm_monoid_add_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_monoid_add_isom hom"
instantiation
  complex :: is_rat
  is_rat_complex == is_rat :: complex \<Rightarrow> bool
  to_rat_complex == to_rat :: complex \<Rightarrow> rat
### theory "Polynomial_Interpolation.Is_Rat_To_Rat"
### 1.035s elapsed time, 6.977s cpu time, 0.929s GC time
### theory "Polynomial_Interpolation.Missing_Polynomial"
### 0.382s elapsed time, 2.267s cpu time, 0.614s GC time
locale semiring_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "semiring_isom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
locale comm_semiring_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_semiring_isom hom"
locale ring_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "ring_isom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### inv hom (sum_mset ?X1) \<equiv> sum_mset (image_mset (inv hom) ?X1)
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### inv hom (sum_mset ?X1) \<equiv> sum_mset (image_mset (inv hom) ?X1)
locale comm_ring_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "comm_ring_isom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### inv hom (sum_mset ?X1) \<equiv> sum_mset (image_mset (inv hom) ?X1)
### Ignoring duplicate rewrite rule:
### inv (inv hom) (sum_mset ?X1) \<equiv>
### sum_mset (image_mset (inv (inv hom)) ?X1)
locale idom_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "idom_isom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### inv hom (sum_mset ?X1) \<equiv> sum_mset (image_mset (inv hom) ?X1)
### Ignoring duplicate rewrite rule:
### inv (inv hom) (sum_mset ?X1) \<equiv>
### sum_mset (image_mset (inv (inv hom)) ?X1)
locale field_isom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "field_isom hom"
### Ignoring duplicate rewrite rule:
### hom (sum_mset ?X1) \<equiv> sum_mset (image_mset hom ?X1)
### Ignoring duplicate rewrite rule:
### inv hom (sum_mset ?X1) \<equiv> sum_mset (image_mset (inv hom) ?X1)
### Ignoring duplicate rewrite rule:
### inv (inv hom) (sum_mset ?X1) \<equiv>
### sum_mset (image_mset (inv (inv hom)) ?X1)
### Ignoring duplicate rewrite rule:
### inv (inv (inv hom)) (sum_mset ?X1) \<equiv>
### sum_mset (image_mset (inv (inv (inv hom))) ?X1)
locale inj_idom_divide_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "inj_idom_divide_hom hom"
locale field_hom
  fixes hom :: "'a \<Rightarrow> 'b"
  assumes "field_hom hom"
### theory "Polynomial_Interpolation.Ring_Hom"
### 2.602s elapsed time, 14.231s cpu time, 1.355s GC time
*** Failed to load theory "Polynomial_Interpolation.Lagrange_Interpolation" (unresolved "Polynomial_Interpolation.Missing_Polynomial")
*** Failed to load theory "Polynomial_Interpolation.Ring_Hom_Poly" (unresolved "Polynomial_Interpolation.Missing_Polynomial")
*** Failed to load theory "Polynomial_Interpolation.Newton_Interpolation" (unresolved "Polynomial_Interpolation.Ring_Hom_Poly")
*** Failed to load theory "Polynomial_Interpolation.Polynomial_Interpolation" (unresolved "Polynomial_Interpolation.Lagrange_Interpolation", "Polynomial_Interpolation.Newton_Interpolation")
*** Type unification failed: Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  gcd :: ??'a \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::{factorial_ring_gcd,field} not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 246 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Polynomial.thy")
*** Undefined fact: "sign_simps" (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
*** At command "by" (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
*** Failed to finish proof (line 281 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. xs \<noteq> [] \<longrightarrow>
***     \<bar>a * Lcm (set xs)\<bar> = \<bar>a\<bar> * Lcm (set xs)
*** At command "by" (line 281 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
*** Failed to finish proof (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. \<bar>k\<bar> * lcm m n = \<bar>k * lcm m n\<bar>
*** At command "by" (line 276 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")
*** Failed to finish proof (line 261 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy"):
*** goal (1 subgoal):
***  1. \<bar>a * Gcd (set xs)\<bar> = \<bar>a\<bar> * Gcd (set xs)
*** At command "by" (line 261 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy")

==========
Priority_Search_Trees
Loading theory "HOL-Data_Structures.Cmp" (required by "Priority_Search_Trees.PST_RBT")
Loading theory "HOL-Data_Structures.Less_False" (required by "Priority_Search_Trees.Prio_Map_Specs" via "HOL-Data_Structures.Map_Specs" via "HOL-Data_Structures.AList_Upd_Del" via "HOL-Data_Structures.Sorted_Less")
Loading theory "HOL-Library.Tree" (required by "Priority_Search_Trees.PST_RBT" via "HOL-Data_Structures.Isin2" via "HOL-Data_Structures.Tree2")
### theory "HOL-Data_Structures.Less_False"
### 0.037s elapsed time, 0.162s cpu time, 0.000s GC time
Loading theory "HOL-Data_Structures.Sorted_Less" (required by "Priority_Search_Trees.Prio_Map_Specs" via "HOL-Data_Structures.Map_Specs" via "HOL-Data_Structures.AList_Upd_Del")
### theory "HOL-Data_Structures.Sorted_Less"
### 0.065s elapsed time, 0.329s cpu time, 0.044s GC time
Loading theory "HOL-Data_Structures.AList_Upd_Del" (required by "Priority_Search_Trees.Prio_Map_Specs" via "HOL-Data_Structures.Map_Specs")
Loading theory "HOL-Data_Structures.List_Ins_Del" (required by "Priority_Search_Trees.PST_RBT" via "HOL-Data_Structures.Isin2" via "HOL-Data_Structures.Set_Specs")
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "HOL-Data_Structures.Cmp"
### 0.328s elapsed time, 1.936s cpu time, 0.128s GC time
Found termination order:
  "(\<lambda>p. size_list size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Data_Structures.List_Ins_Del"
### 0.245s elapsed time, 1.587s cpu time, 0.143s GC time
Loading theory "HOL-Data_Structures.Set_Specs" (required by "Priority_Search_Trees.PST_RBT" via "HOL-Data_Structures.Isin2")
locale Set
  fixes empty :: "'s"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
  assumes "Set empty insert delete isin set invar"
locale Set_by_Ordered
  fixes empty :: "'t"
    and insert :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and delete :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and isin :: "'t \<Rightarrow> 'a \<Rightarrow> bool"
    and inorder :: "'t \<Rightarrow> 'a list"
    and inv :: "'t \<Rightarrow> bool"
  assumes "Set_by_Ordered empty insert delete isin inorder inv"
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
consts
  left :: "'a tree \<Rightarrow> 'a tree"
consts
  right :: "'a tree \<Rightarrow> 'a tree"
locale Set2
  fixes empty :: "'s"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and union :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and inter :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and diff :: "'s \<Rightarrow> 's \<Rightarrow> 's"
  assumes "Set2 empty delete isin set invar insert union inter diff"
### theory "HOL-Data_Structures.Set_Specs"
### 0.102s elapsed time, 0.508s cpu time, 0.000s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Data_Structures.AList_Upd_Del"
### 0.454s elapsed time, 2.763s cpu time, 0.225s GC time
Loading theory "HOL-Data_Structures.Map_Specs" (required by "Priority_Search_Trees.Prio_Map_Specs")
locale Map
  fixes empty :: "'m"
    and update :: "'a \<Rightarrow> 'b \<Rightarrow> 'm \<Rightarrow> 'm"
    and delete :: "'a \<Rightarrow> 'm \<Rightarrow> 'm"
    and lookup :: "'m \<Rightarrow> 'a \<Rightarrow> 'b option"
    and invar :: "'m \<Rightarrow> bool"
  assumes "Map empty update delete lookup invar"
Found termination order: "size <*mlex*> {}"
locale Map_by_Ordered
  fixes empty :: "'t"
    and update :: "'a \<Rightarrow> 'b \<Rightarrow> 't \<Rightarrow> 't"
    and delete :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and lookup :: "'t \<Rightarrow> 'a \<Rightarrow> 'b option"
    and inorder :: "'t \<Rightarrow> ('a \<times> 'b) list"
    and inv :: "'t \<Rightarrow> bool"
  assumes "Map_by_Ordered empty update delete lookup inorder inv"
### theory "HOL-Data_Structures.Map_Specs"
### 0.041s elapsed time, 0.197s cpu time, 0.000s GC time
Loading theory "Priority_Search_Trees.Prio_Map_Specs"
class height = type +
  fixes height :: "'a \<Rightarrow> nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree \<Rightarrow> nat
locale PrioMap
  fixes empty :: "'m"
    and update :: "'a \<Rightarrow> 'b \<Rightarrow> 'm \<Rightarrow> 'm"
    and delete :: "'a \<Rightarrow> 'm \<Rightarrow> 'm"
    and invar :: "'m \<Rightarrow> bool"
    and lookup :: "'m \<Rightarrow> 'a \<Rightarrow> 'b option"
    and is_empty :: "'m \<Rightarrow> bool"
    and getmin :: "'m \<Rightarrow> 'a \<times> 'b"
  assumes "PrioMap empty update delete invar lookup is_empty getmin"
locale PrioMap_by_Ordered
  fixes empty :: "'t"
    and update :: "'a \<Rightarrow> 'b \<Rightarrow> 't \<Rightarrow> 't"
    and delete :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and inorder :: "'t \<Rightarrow> ('a \<times> 'b) list"
    and inv :: "'t \<Rightarrow> bool"
    and lookup :: "'t \<Rightarrow> 'a \<Rightarrow> 'b option"
    and is_empty :: "'t \<Rightarrow> bool"
    and getmin :: "'t \<Rightarrow> 'a \<times> 'b"
  assumes
    "PrioMap_by_Ordered empty update delete inorder inv lookup is_empty
      getmin"
Found termination order: "size <*mlex*> {}"
### theory "Priority_Search_Trees.Prio_Map_Specs"
### 0.056s elapsed time, 0.274s cpu time, 0.000s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.395s elapsed time, 6.027s cpu time, 0.911s GC time
Loading theory "HOL-Data_Structures.Tree2" (required by "Priority_Search_Trees.PST_RBT" via "HOL-Data_Structures.Isin2")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Data_Structures.Tree2"
### 0.218s elapsed time, 0.839s cpu time, 0.036s GC time
Loading theory "HOL-Data_Structures.Isin2" (required by "Priority_Search_Trees.PST_RBT")
Loading theory "HOL-Data_Structures.Lookup2" (required by "Priority_Search_Trees.PST_RBT")
Loading theory "Priority_Search_Trees.PST_General" (required by "Priority_Search_Trees.PST_RBT")
### theory "Priority_Search_Trees.PST_General"
### 0.161s elapsed time, 0.524s cpu time, 0.056s GC time
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### theory "HOL-Data_Structures.Lookup2"
### 0.245s elapsed time, 0.718s cpu time, 0.056s GC time
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### theory "HOL-Data_Structures.Isin2"
### 0.406s elapsed time, 1.043s cpu time, 0.056s GC time
*** Failed to load theory "Priority_Search_Trees.PST_RBT" (unresolved "Priority_Search_Trees.PST_General")
*** Type unification failed: Clash of types "_ \<Rightarrow> _" and "_ tree"
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:  \<langle>l, kp, b\<rangle> :: ??'a tree
*** Operand:   r :: ??'b
*** 
*** At command "text" (line 9 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Priority_Search_Trees/PST_General.thy")

==========
Probabilistic_Prime_Tests
Loading theory "HOL-Cardinals.Fun_More" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
Loading theory "HOL-Cardinals.Order_Relation_More" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation" via "HOL-Cardinals.Wellfounded_More")
Loading theory "HOL-Cardinals.Order_Union" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions")
Loading theory "HOL-Algebra.Exponent" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Sylow")
Loading theory "HOL-Computational_Algebra.Squarefree" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries")
Loading theory "HOL-Number_Theory.Cong" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
Loading theory "HOL-Library.Fun_Lexorder" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Library.Poly_Mapping")
Loading theory "HOL-Library.Permutation" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Divisibility")
Proofs for inductive predicate(s) "perm"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Library.Fun_Lexorder"
### 0.044s elapsed time, 0.370s cpu time, 0.000s GC time
Loading theory "HOL-Algebra.Congruence" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
### theory "HOL-Cardinals.Fun_More"
### 0.065s elapsed time, 0.542s cpu time, 0.000s GC time
Loading theory "HOL-Algebra.Cycles" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Sym_Groups")
### Ignoring duplicate safe introduction (intro!)
### ?xs <~~> ?ys \<Longrightarrow> ?z # ?xs <~~> ?z # ?ys
### Ignoring duplicate safe introduction (intro!)
### ?xs <~~> ?ys \<Longrightarrow> ?z # ?xs <~~> ?z # ?ys
### theory "HOL-Cardinals.Order_Union"
### 0.120s elapsed time, 0.903s cpu time, 0.102s GC time
Loading theory "HOL-Library.Equipollence" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Algebra.Product_Groups")
### theory "HOL-Library.Permutation"
### 0.147s elapsed time, 1.141s cpu time, 0.102s GC time
Loading theory "HOL-Library.Groups_Big_Fun" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Library.Poly_Mapping")
### theory "HOL-Algebra.Exponent"
### 0.152s elapsed time, 1.175s cpu time, 0.102s GC time
Loading theory "HOL-Library.More_List" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Library.Poly_Mapping")
locale comm_monoid_fun
  fixes
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fun (\<^bold>*) \<^bold>1"
### theory "HOL-Computational_Algebra.Squarefree"
### 0.186s elapsed time, 1.439s cpu time, 0.102s GC time
Loading theory "HOL-Library.Power_By_Squaring" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Mod_Exp")
class unique_euclidean_semiring = euclidean_semiring_cancel +
  fixes division_segment :: "'a \<Rightarrow> 'a"
  assumes
    "euclidean_size_mult":
      "\<And>a b.
          euclidean_size (a * b) = euclidean_size a * euclidean_size b"
  assumes
    "is_unit_division_segment": "\<And>a. is_unit (division_segment a)"
    and
    "division_segment_mult":
      "\<And>a b.
          \<lbrakk>a \<noteq> (0::'a); b \<noteq> (0::'a)\<rbrakk>
          \<Longrightarrow> division_segment (a * b) =
                            division_segment a * division_segment b"
    and
    "division_segment_mod":
      "\<And>b a.
          \<lbrakk>b \<noteq> (0::'a); \<not> b dvd a\<rbrakk>
          \<Longrightarrow> division_segment (a mod b) = division_segment b"
  assumes
    "div_bounded":
      "\<And>b r q.
          \<lbrakk>b \<noteq> (0::'a);
           division_segment r = division_segment b;
           euclidean_size r < euclidean_size b\<rbrakk>
          \<Longrightarrow> (q * b + r) div b = q"
### theory "HOL-Cardinals.Order_Relation_More"
### 0.241s elapsed time, 1.843s cpu time, 0.196s GC time
Loading theory "HOL-Cardinals.Wellfounded_More" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding" via "HOL-Cardinals.Wellorder_Relation")
### theory "HOL-Cardinals.Wellfounded_More"
### 0.025s elapsed time, 0.211s cpu time, 0.000s GC time
Loading theory "HOL-Cardinals.Wellorder_Relation" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions" via "HOL-Cardinals.Wellorder_Embedding")
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
locale wo_rel
  fixes r :: "('a \<times> 'a) set"
  assumes "wo_rel r"
### theory "HOL-Library.Equipollence"
### 0.199s elapsed time, 1.505s cpu time, 0.170s GC time
Loading theory "HOL-Number_Theory.Eratosthenes" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
Found termination order: "length <*mlex*> {}"
### theory "HOL-Library.More_List"
### 0.220s elapsed time, 1.634s cpu time, 0.239s GC time
Loading theory "HOL-Number_Theory.Fib" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "\<And>a. (1::'a) * a = a"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
class monoid_mult = semigroup_mult + power +
  assumes "mult_1_left": "\<And>a. (1::'a) * a = a"
    and "mult_1_right": "\<And>a. a * (1::'a) = a"
### theory "HOL-Library.Power_By_Squaring"
### 0.240s elapsed time, 1.796s cpu time, 0.239s GC time
Loading theory "HOL-Number_Theory.Prime_Powers" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
### theory "HOL-Cardinals.Wellorder_Relation"
### 0.262s elapsed time, 1.878s cpu time, 0.694s GC time
Loading theory "HOL-Cardinals.Wellorder_Embedding" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation" via "HOL-Cardinals.Wellorder_Constructions")
### theory "HOL-Library.Groups_Big_Fun"
### 0.395s elapsed time, 2.901s cpu time, 0.788s GC time
Loading theory "HOL-Library.Poly_Mapping" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups")
Proofs for inductive predicate(s) "cycle_decomp"
Found termination order: "size <*mlex*> {}"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Number_Theory.Eratosthenes"
### 0.231s elapsed time, 1.669s cpu time, 0.618s GC time
### theory "HOL-Algebra.Cycles"
### 0.503s elapsed time, 3.697s cpu time, 0.890s GC time
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Cardinals.Wellorder_Embedding"
### 0.198s elapsed time, 1.528s cpu time, 0.106s GC time
Loading theory "HOL-Cardinals.Wellorder_Constructions" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic" via "HOL-Cardinals.Cardinal_Order_Relation")
### theory "HOL-Number_Theory.Fib"
### 0.381s elapsed time, 2.843s cpu time, 0.656s GC time
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
class zero = type +
  fixes zero :: "'a"
class monoid_add = semigroup_add + zero +
  assumes "add_0_left": "\<And>a. (0::'a) + a = a"
    and "add_0_right": "\<And>a. a + (0::'a) = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "\<And>a. (0::'a) + a = a"
### theory "HOL-Algebra.Congruence"
### 0.957s elapsed time, 7.208s cpu time, 1.181s GC time
Loading theory "HOL-Algebra.Order" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
class group_add = cancel_semigroup_add + minus + monoid_add + uminus +
  assumes "left_minus": "\<And>a. - a + a = (0::'a)"
  assumes "add_uminus_conv_diff": "\<And>a b. a + - b = a - b"
class mult_zero = times + zero +
  assumes "mult_zero_left": "\<And>a. (0::'a) * a = (0::'a)"
  assumes "mult_zero_right": "\<And>a. a * (0::'a) = (0::'a)"
locale wo_rel
  fixes r :: "('a \<times> 'a) set"
  assumes "wo_rel r"
### theory "HOL-Number_Theory.Cong"
### 1.183s elapsed time, 8.986s cpu time, 1.307s GC time
Loading theory "HOL-Number_Theory.Mod_Exp" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
instantiation
  poly_mapping :: (type, zero) zero
  zero_poly_mapping == zero_class.zero :: 'a \<Rightarrow>\<^sub>0 'b
Loading theory "HOL-Number_Theory.Totient" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
instantiation
  poly_mapping :: (type, monoid_add) monoid_add
  plus_poly_mapping == plus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    \<Rightarrow> ('a \<Rightarrow>\<^sub>0 'b)
                  \<Rightarrow> 'a \<Rightarrow>\<^sub>0 'b
instantiation
  poly_mapping :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly_mapping == minus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    \<Rightarrow> ('a \<Rightarrow>\<^sub>0 'b)
                  \<Rightarrow> 'a \<Rightarrow>\<^sub>0 'b
instantiation
  poly_mapping :: (type, ab_group_add) ab_group_add
  uminus_poly_mapping == uminus ::
    ('a \<Rightarrow>\<^sub>0 'b) \<Rightarrow> 'a \<Rightarrow>\<^sub>0 'b
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
instantiation
  poly_mapping :: (zero, zero_neq_one) zero_neq_one
  one_poly_mapping == one_class.one :: 'a \<Rightarrow>\<^sub>0 'b
### theory "HOL-Number_Theory.Prime_Powers"
### 1.021s elapsed time, 7.656s cpu time, 1.843s GC time
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
instantiation
  poly_mapping :: (monoid_add, semiring_0) semiring_0
  times_poly_mapping == times ::
    ('a \<Rightarrow>\<^sub>0 'b)
    \<Rightarrow> ('a \<Rightarrow>\<^sub>0 'b)
                  \<Rightarrow> 'a \<Rightarrow>\<^sub>0 'b
### theory "HOL-Cardinals.Wellorder_Constructions"
### 0.843s elapsed time, 6.397s cpu time, 1.233s GC time
Loading theory "HOL-Cardinals.Cardinal_Order_Relation" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Cardinals.Cardinal_Arithmetic")
instantiation
  poly_mapping :: (linorder, {zero,linorder}) linorder
  less_eq_poly_mapping == less_eq ::
    ('a \<Rightarrow>\<^sub>0 'b)
    \<Rightarrow> ('a \<Rightarrow>\<^sub>0 'b) \<Rightarrow> bool
  less_poly_mapping == less ::
    ('a \<Rightarrow>\<^sub>0 'b)
    \<Rightarrow> ('a \<Rightarrow>\<^sub>0 'b) \<Rightarrow> bool
class euclidean_semiring_cancel = euclidean_semiring +
  assumes
    "div_mult_self1":
      "\<And>b a c.
          b \<noteq> (0::'a) \<Longrightarrow>
          (a + c * b) div b = c + a div b"
    and
    "div_mult_mult1":
      "\<And>c a b.
          c \<noteq> (0::'a) \<Longrightarrow> c * a div (c * b) = a div b"
consts
  totient_naive ::
    "nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat"
### theory "HOL-Number_Theory.Mod_Exp"
### 0.620s elapsed time, 4.645s cpu time, 1.141s GC time
### Metis: Unused theorems: "local.eeq_2"
### theory "HOL-Number_Theory.Totient"
### 0.616s elapsed time, 4.612s cpu time, 1.141s GC time
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
instantiation
  poly_mapping :: (type, zero) size
  size_poly_mapping == size ::
    ('a \<Rightarrow>\<^sub>0 'b) \<Rightarrow> nat
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
### theory "HOL-Algebra.Order"
### 1.234s elapsed time, 9.428s cpu time, 1.495s GC time
Loading theory "HOL-Algebra.Lattice" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
### theory "HOL-Library.Poly_Mapping"
### 1.672s elapsed time, 12.790s cpu time, 1.786s GC time
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
### theory "HOL-Cardinals.Cardinal_Order_Relation"
### 0.781s elapsed time, 6.081s cpu time, 0.416s GC time
Loading theory "HOL-Cardinals.Cardinal_Arithmetic" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups")
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
### theory "HOL-Cardinals.Cardinal_Arithmetic"
### 0.217s elapsed time, 1.647s cpu time, 0.111s GC time
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
### theory "HOL-Algebra.Lattice"
### 0.834s elapsed time, 6.455s cpu time, 0.369s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.Group")
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### Metis: Unused theorems: "Cycles.least_powerI_2"
### Metis: Unused theorems: "Cycles.least_powerI_1"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### theory "HOL-Algebra.Complete_Lattice"
### 0.755s elapsed time, 5.930s cpu time, 0.285s GC time
Loading theory "HOL-Algebra.Galois_Connection" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Loading theory "HOL-Algebra.Group" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
overloading
  nat_pow \<equiv> pow ::
    ('a, 'b) monoid_scheme
    \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> 'a
overloading
  int_pow \<equiv> pow ::
    ('a, 'b) monoid_scheme
    \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'a
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale connection
  fixes G :: "('a, 'c, 'b, 'd, 'e) galcon_scheme"  (structure)
  assumes "connection G"
locale galois_connection
  fixes G :: "('a, 'b, 'c, 'd, 'e) galcon_scheme"  (structure)
  assumes "galois_connection G"
locale retract
  fixes G :: "('a, 'b, 'c, 'd, 'e) galcon_scheme"  (structure)
  assumes "retract G"
locale coretract
  fixes G :: "('a, 'b, 'c, 'd, 'e) galcon_scheme"  (structure)
  assumes "coretract G"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale galois_bijection
  fixes G :: "('a, 'b, 'c, 'd, 'e) galcon_scheme"  (structure)
  assumes "galois_bijection G"
### theory "HOL-Algebra.Galois_Connection"
### 0.855s elapsed time, 6.713s cpu time, 0.454s GC time
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "group_hom G H h"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
### theory "HOL-Algebra.Group"
### 1.302s elapsed time, 10.214s cpu time, 0.641s GC time
Loading theory "HOL-Algebra.Bij" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Zassenhaus" via "HOL-Algebra.Group_Action")
Loading theory "HOL-Algebra.Coset" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
Loading theory "HOL-Algebra.FiniteProduct" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.Module" via "HOL-Algebra.Ring")
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Algebra.Bij"
### 0.092s elapsed time, 0.712s cpu time, 0.000s GC time
### Rule already declared as introduction (intro)
### ?P ?x \<Longrightarrow> \<exists>x. ?P x
locale normal
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "normal H G"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and
    f :: "'b \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
locale ACeD
  fixes D :: "'a set"
    and
    f :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
      (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### theory "HOL-Algebra.FiniteProduct"
### 0.555s elapsed time, 4.367s cpu time, 0.313s GC time
Loading theory "HOL-Algebra.Ring" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.Module")
### Ambiguous input (line 611 of "~~/src/HOL/Algebra/Coset.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###       ("_position" H))
###     ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" carrier) ("_position" G)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" y)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>Set.member"
###             ("\<^const>Group.monoid.mult_indexed"
###               ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                 ("_position" x))
###               ("_index" ("_position" G)) ("_position" y))
###             ("_position" H)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###     ("\<^const>HOL.eq" ("_position" H)
###       ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" x)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" y)
###               ("_applC" ("_position" carrier) ("_position" G)))
###             ("\<^const>Set.member"
###               ("\<^const>Group.monoid.mult_indexed"
###                 ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                   ("_position" x))
###                 ("_index" ("_position" G)) ("_position" y))
###               ("_position" H))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Ignoring duplicate rewrite rule:
### \<Prod>x\<in>?A1. ?y1 \<equiv> ?y1 ^ card ?A1
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
### theory "HOL-Algebra.Coset"
### 1.508s elapsed time, 11.632s cpu time, 0.739s GC time
Loading theory "HOL-Algebra.Group_Action" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Zassenhaus")
Loading theory "HOL-Algebra.Sylow" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Loading theory "HOL-Algebra.Divisibility" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Loading theory "HOL-Algebra.Generated_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
Proofs for inductive predicate(s) "generatep"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale group_action
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and E :: "'c set"
    and \<phi> :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "group_action G E \<phi>"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
locale faithful_action
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and E :: "'c set"
    and \<phi> :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "faithful_action G E \<phi>"
locale transitive_action
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and E :: "'c set"
    and \<phi> :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "transitive_action G E \<phi>"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "monoid_cancel G"
locale sylow
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
  assumes "sylow G p a m"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
locale comm_monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_monoid_cancel G"
### theory "HOL-Algebra.Group_Action"
### 0.473s elapsed time, 2.877s cpu time, 0.309s GC time
Loading theory "HOL-Algebra.Zassenhaus" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
locale sylow_central
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
    and H :: "'a set"
    and M1 :: "'a set"
    and M :: "'a set set"
  assumes "sylow_central G p a m M1 M"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
    and "H \<equiv> {g \<in> carrier G. M1 #> g = M1}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale sylow
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
  assumes "sylow G p a m"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
locale sylow_central
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
    and H :: "'a set"
    and M1 :: "'a set"
    and M :: "'a set set"
  assumes "sylow_central G p a m M1 M"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
    and "H \<equiv> {g \<in> carrier G. M1 #> g = M1}"
locale sylow_central
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
    and H :: "'a set"
    and M1 :: "'a set"
    and M :: "'a set set"
  assumes "sylow_central G p a m M1 M"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
    and "H \<equiv> {g \<in> carrier G. M1 #> g = M1}"
locale sylow_central
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and p :: "nat"
    and a :: "nat"
    and m :: "nat"
    and calM :: "'a set set"
    and RelM :: "('a set \<times> 'a set) set"
    and H :: "'a set"
    and M1 :: "'a set"
    and M :: "'a set set"
  assumes "sylow_central G p a m M1 M"
  defines "calM \<equiv> {s. s \<subseteq> carrier G \<and> card s = p ^ a}"
    and
    "RelM \<equiv>
     {(N1, N2).
      N1 \<in> calM \<and>
      N2 \<in> calM \<and> (\<exists>g\<in>carrier G. N1 = N2 #> g)}"
    and "H \<equiv> {g \<in> carrier G. M1 #> g = M1}"
### theory "HOL-Algebra.Sylow"
### 1.075s elapsed time, 6.928s cpu time, 3.305s GC time
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### theory "HOL-Algebra.Zassenhaus"
### 0.226s elapsed time, 1.358s cpu time, 0.129s GC time
### ML warning (line 45 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
### theory "HOL-Algebra.Generated_Groups"
### 1.255s elapsed time, 8.104s cpu time, 3.478s GC time
Loading theory "HOL-Algebra.Solvable_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Sym_Groups")
Proofs for inductive predicate(s) "solvable_seq"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale factorial_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "factorial_monoid G"
### theory "HOL-Algebra.Solvable_Groups"
### 0.214s elapsed time, 1.696s cpu time, 0.144s GC time
Loading theory "HOL-Algebra.Sym_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
Proofs for inductive predicate(s) "swapidseq_ext"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "HOL-Algebra.Sym_Groups"
### 0.554s elapsed time, 4.296s cpu time, 0.375s GC time
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "ring_hom_cring R S h"
### Rewrite rule not in simpset:
### \<bar>1::?'a1\<bar> \<equiv> 1::?'a1
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Rewrite rule not in simpset:
### \<bar>1::?'a1\<bar> \<equiv> 1::?'a1
locale gcd_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "gcd_condition_monoid G"
### theory "HOL-Algebra.Ring"
### 3.545s elapsed time, 25.839s cpu time, 4.667s GC time
Loading theory "HOL-Algebra.AbelCoset" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom" via "HOL-Algebra.Ideal")
Loading theory "HOL-Algebra.Module" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
locale primeness_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "primeness_condition_monoid G"
locale divisor_chain_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "divisor_chain_condition_monoid G"
### Ignoring duplicate rewrite rule:
### finite ?S1 \<Longrightarrow>
### \<Sum>k\<in>?S1. if k = ?a1 then ?b1 k else (0::?'a1) \<equiv>
### if ?a1 \<in> ?S1 then ?b1 ?a1 else (0::?'a1)
### Ignoring duplicate rewrite rule:
### Abs_poly_mapping (lookup ?y) \<equiv> ?y
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
### theory "HOL-Algebra.Divisibility"
### 3.203s elapsed time, 23.447s cpu time, 4.613s GC time
locale abelian_group_hom
  fixes G :: "('a, 'b) ring_scheme"  (structure)
    and H :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "abelian_group_hom G H h"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
locale additive_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "additive_subgroup H G"
locale abelian_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_subgroup H G"
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
### theory "HOL-Algebra.Module"
### 2.254s elapsed time, 17.251s cpu time, 4.768s GC time
### theory "HOL-Algebra.AbelCoset"
### 3.741s elapsed time, 27.918s cpu time, 5.432s GC time
Loading theory "HOL-Algebra.Ideal" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom")
### Ignoring duplicate rewrite rule:
### Group.monoid G \<equiv> True
locale ideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ideal I R"
### Rule already declared as safe introduction (intro!)
### Group.group G
### Rule already declared as safe introduction (intro!)
### Group.group H
locale principalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "principalideal I R"
locale maximalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "maximalideal I R"
locale primeideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "primeideal I R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Metis: Unused theorems: "local.assms_3"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Algebra.Ideal"
### 2.367s elapsed time, 18.013s cpu time, 0.891s GC time
Loading theory "HOL-Algebra.Ideal_Product" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Chinese_Remainder")
Loading theory "HOL-Algebra.RingHom" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
Proofs for inductive predicate(s) "ideal_prodp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale ring_hom_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "ring_hom_ring R S h"
### Ignoring duplicate rewrite rule:
### \<lbrakk>?f1 \<in> ?A1 \<rightarrow> carrier G;
###  ?g1 \<in> ?A1 \<rightarrow> carrier G\<rbrakk>
### \<Longrightarrow> \<Otimes>x\<in>?A1. ?f1 x \<otimes> ?g1 x \<equiv>
###                   finprod G ?f1 ?A1 \<otimes> finprod G ?g1 ?A1
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Algebra.Ideal_Product"
### 0.587s elapsed time, 4.661s cpu time, 0.195s GC time
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>?P ?x; ?x \<in> ?A\<rbrakk>
### \<Longrightarrow> \<exists>x\<in>?A. ?P x
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
### Rule already declared as introduction (intro)
### \<lbrakk>?b = ?f ?x; ?x \<in> ?A\<rbrakk> \<Longrightarrow> ?b \<in> ?f ` ?A
### theory "HOL-Algebra.RingHom"
### 1.146s elapsed time, 9.116s cpu time, 0.553s GC time
Loading theory "HOL-Algebra.QuotRing" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Chinese_Remainder" via "HOL-Algebra.Weak_Morphisms")
Loading theory "HOL-Algebra.UnivPoly" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale bound
  fixes z :: "'a"
    and n :: "nat"
    and f :: "nat \<Rightarrow> 'a"
  assumes "bound z n f"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Metis: Unused theorems: "local.m_ac_2"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
carrier \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> = ?carrier
partial_object.more \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
?more
carrier_update ?carrier'
 \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier' ?carrier, \<dots> = ?more\<rparr>
partial_object.more_update ?more'
 \<lparr>carrier = ?carrier, \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, \<dots> = ?more' ?more\<rparr>
(\<otimes>\<^bsub>\<lparr>carrier = ?carrier, mult = ?mult, one = ?one, \<dots> = ?more\<rparr>\<^esub>) =
?mult
\<one>\<^bsub>\<lparr>carrier = ?carrier, mult = ?mult, one = ?one, \<dots> = ?more\<rparr>\<^esub> =
?one
monoid.more
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
?more
mult_update ?mult'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult' ?mult, one = ?one,
   \<dots> = ?more\<rparr>
one_update ?one'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult, one = ?one' ?one,
   \<dots> = ?more\<rparr>
monoid.more_update ?more'
 \<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
    \<dots> = ?more\<rparr> =
\<lparr>carrier = ?carrier, mult = ?mult, one = ?one,
   \<dots> = ?more' ?more\<rparr>
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>subgroup ?H1 G; ?x1 \<in> ?H1\<rbrakk>
### \<Longrightarrow> inv\<^bsub>G\<lparr>carrier := ?H1\<rparr>\<^esub> ?x1 \<equiv>
###                   inv ?x1
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group H \<equiv> True
### theory "HOL-Algebra.QuotRing"
### 2.841s elapsed time, 22.545s cpu time, 1.558s GC time
Loading theory "HOL-Algebra.IntRing" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Loading theory "HOL-Algebra.Weak_Morphisms" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Chinese_Remainder")
locale weak_group_morphism
  fixes f :: "'a \<Rightarrow> 'c"
    and H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "weak_group_morphism f H G"
### Ignoring duplicate rewrite rule:
### h \<in> hom G H \<equiv> True
locale weak_ring_morphism
  fixes f :: "'a \<Rightarrow> 'c"
    and I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "weak_ring_morphism f I R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### theory "HOL-Algebra.IntRing"
### 0.836s elapsed time, 6.539s cpu time, 0.402s GC time
### theory "HOL-Algebra.Weak_Morphisms"
### 0.918s elapsed time, 7.198s cpu time, 0.402s GC time
Loading theory "HOL-Algebra.Chinese_Remainder" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<oplus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<zero> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<ominus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<otimes> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<one> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<zero> \<oplus> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<one> \<otimes> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> ?y \<oplus> \<zero> \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<ominus> (\<ominus> ?y) \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<ominus> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> \<zero> \<otimes> ?x1 \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> ?x1 \<otimes> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<oplus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<zero> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<ominus> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>?x1 \<in> carrier R; ?y1 \<in> carrier R\<rbrakk>
### \<Longrightarrow> ?x1 \<otimes> ?y1 \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### \<one> \<in> carrier R \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<zero> \<oplus> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<one> \<otimes> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> ?y \<oplus> \<zero> \<equiv> ?y
### Ignoring duplicate rewrite rule:
### ?y \<in> carrier R \<Longrightarrow> \<ominus> (\<ominus> ?y) \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<ominus> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> \<zero> \<otimes> ?x1 \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow> ?x1 \<otimes> \<zero> \<equiv> \<zero>
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
### theory "HOL-Algebra.Chinese_Remainder"
### 0.775s elapsed time, 6.038s cpu time, 0.432s GC time
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  defines "P \<equiv> UP R"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
\<lbrakk>?M \<subseteq> carrier G; ?g \<in> carrier G;
 ?h \<in> carrier G\<rbrakk>
\<Longrightarrow> ?M #>\<^bsub>add_monoid G\<^esub>
                  ?g #>\<^bsub>add_monoid G\<^esub>
                  ?h =
                  ?M #>\<^bsub>add_monoid G\<^esub> ?g \<oplus> ?h
\<lbrakk>abelian_group ?G; ?M \<subseteq> carrier ?G; ?g \<in> carrier ?G;
 ?h \<in> carrier ?G\<rbrakk>
\<Longrightarrow> ?M +>\<^bsub>?G\<^esub> ?g +>\<^bsub>?G\<^esub> ?h =
                  ?M +>\<^bsub>?G\<^esub> ?g \<oplus>\<^bsub>?G\<^esub> ?h
locale UP_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
    and s :: "'c"
    and Eval :: "(nat \<Rightarrow> 'a) \<Rightarrow> 'c"
  assumes "UP_univ_prop R S h s"
  defines "P \<equiv> UP R"
    and "Eval \<equiv> eval R S h s"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P \<equiv> UP R"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier R \<Longrightarrow>
### \<ominus> ?x1 = \<zero> \<equiv> ?x1 = \<zero>
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
### theory "HOL-Algebra.UnivPoly"
### 9.780s elapsed time, 74.182s cpu time, 4.365s GC time
Loading theory "HOL-Algebra.Multiplicative_Group" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Residues")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P \<equiv> UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P \<equiv> UP R"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat \<Rightarrow> 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P \<equiv> UP R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
### theory "HOL-Algebra.Multiplicative_Group"
### 2.225s elapsed time, 15.282s cpu time, 0.902s GC time
Loading theory "HOL-Algebra.Elementary_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups" via "HOL-Algebra.Product_Groups")
Loading theory "HOL-Algebra.Ring_Divisibility" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Polynomials")
Loading theory "HOL-Algebra.Subrings" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Generated_Fields" via "HOL-Algebra.Generated_Rings")
Loading theory "HOL-Number_Theory.Residues" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
locale group_disjoint_sum
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and A :: "'a set"
    and B :: "'a set"
  assumes "group_disjoint_sum G A B"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R \<equiv> residue_ring m"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R \<equiv> residue_ring m"
locale subring
  fixes H :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "subring H R"
locale subcring
  fixes H :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "subcring H R"
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R \<equiv> residue_ring (int p)"
locale subdomain
  fixes H :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "subdomain H R"
locale subfield
  fixes K :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "subfield K R"
### theory "HOL-Algebra.Elementary_Groups"
### 0.799s elapsed time, 5.248s cpu time, 0.529s GC time
Loading theory "HOL-Algebra.Exact_Sequence" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
locale factorial_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "factorial_domain R"
Loading theory "HOL-Algebra.Product_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Free_Abelian_Groups")
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R \<equiv> residue_ring (int p)"
Proofs for inductive predicate(s) "exact_seq"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale noetherian_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "noetherian_ring R"
### Ignoring duplicate rewrite rule:
### ?x1 \<in> carrier G \<Longrightarrow> ?x1 [^] ord ?x1 \<equiv> \<one>
### Ambiguous input (line 69 of "~~/src/HOL/Algebra/Exact_Sequence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###         ("_tuple"
###           ("\<^const>List.list.Cons" ("_position" G1) ("_position" l))
###           ("_tuple_arg" ("_position" q)))
###         ("_index" ("_position" g1)) ("_position" G2))
###       ("_index" ("_position" g2)) ("_position" G3))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("_tuple" ("\<^const>List.list.Cons" ("_position" G1) ("_position" l))
###         ("_tuple_arg" ("_position" q)))
###       ("_index" ("_position" g1))
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed" ("_position" G2)
###         ("_index" ("_position" g2)) ("_position" G3)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 140 of "~~/src/HOL/Algebra/Exact_Sequence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###         ("_tuple" ("_list" ("_position" G1))
###           ("_tuple_arg" ("\<^const>List.list.Nil")))
###         ("_index" ("_position" g1)) ("_position" G2))
###       ("_index" ("_position" g2)) ("_position" G3))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("_tuple" ("_list" ("_position" G1))
###         ("_tuple_arg" ("\<^const>List.list.Nil")))
###       ("_index" ("_position" g1))
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed" ("_position" G2)
###         ("_index" ("_position" g2)) ("_position" G3)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 158 of "~~/src/HOL/Algebra/Exact_Sequence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###         ("_tuple" ("_list" ("_position" G1))
###           ("_tuple_arg" ("\<^const>List.list.Nil")))
###         ("_index" ("_position" g1)) ("_position" G2))
###       ("_index" ("_position" g2)) ("_position" G3))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("_tuple" ("_list" ("_position" G1))
###         ("_tuple_arg" ("\<^const>List.list.Nil")))
###       ("_index" ("_position" g1))
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed" ("_position" G2)
###         ("_index" ("_position" g2)) ("_position" G3)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 174 of "~~/src/HOL/Algebra/Exact_Sequence.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###         ("_tuple" ("_list" ("_position" G1))
###           ("_tuple_arg" ("\<^const>List.list.Nil")))
###         ("_index" ("_position" g1)) ("_position" G2))
###       ("_index" ("_position" g2)) ("_position" G3))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" exact_seq)
###     ("\<^const>Exact_Sequence.exact_seq_arrow_indexed"
###       ("_tuple" ("_list" ("_position" G1))
###         ("_tuple_arg" ("\<^const>List.list.Nil")))
###       ("_index" ("_position" g1))
###       ("\<^const>Exact_Sequence.exact_seq_arrow_indexed" ("_position" G2)
###         ("_index" ("_position" g2)) ("_position" G3)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale noetherian_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "noetherian_domain R"
### theory "HOL-Algebra.Product_Groups"
### 1.605s elapsed time, 12.221s cpu time, 8.747s GC time
Loading theory "HOL-Algebra.Free_Abelian_Groups" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
### theory "HOL-Number_Theory.Residues"
### 2.486s elapsed time, 18.602s cpu time, 9.276s GC time
Loading theory "HOL-Number_Theory.Euler_Criterion" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Quadratic_Reciprocity" via "HOL-Number_Theory.Gauss")
Loading theory "HOL-Number_Theory.Pocklington" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
### theory "HOL-Algebra.Exact_Sequence"
### 1.890s elapsed time, 14.488s cpu time, 8.747s GC time
locale principal_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "principal_domain R"
### theory "HOL-Number_Theory.Euler_Criterion"
### 0.204s elapsed time, 1.617s cpu time, 0.000s GC time
Loading theory "HOL-Number_Theory.Gauss" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory" via "HOL-Number_Theory.Quadratic_Reciprocity")
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
### Ignoring duplicate rewrite rule:
### (\<otimes>\<^bsub>mult_of ?R1\<^esub>) \<equiv>
### (\<otimes>\<^bsub>?R1\<^esub>)
### Ignoring duplicate rewrite rule:
### \<one>\<^bsub>mult_of ?R1\<^esub> \<equiv> \<one>\<^bsub>?R1\<^esub>
locale GAUSS
  fixes p :: "nat"
    and a :: "int"
  assumes "GAUSS p a"
locale euclidean_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and \<phi> :: "'a \<Rightarrow> nat"
  assumes "euclidean_domain R \<phi>"
### theory "HOL-Number_Theory.Pocklington"
### 0.366s elapsed time, 2.910s cpu time, 0.269s GC time
Loading theory "HOL-Number_Theory.Residue_Primitive_Roots" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
Proofs for inductive predicate(s) "residue_primroot"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
### Ignoring duplicate rewrite rule:
### (\<otimes>\<^bsub>mult_of ?R1\<^esub>) \<equiv>
### (\<otimes>\<^bsub>?R1\<^esub>)
### Ignoring duplicate rewrite rule:
### \<one>\<^bsub>mult_of ?R1\<^esub> \<equiv> \<one>\<^bsub>?R1\<^esub>
### theory "HOL-Number_Theory.Gauss"
### 0.277s elapsed time, 2.214s cpu time, 0.269s GC time
Loading theory "HOL-Number_Theory.Quadratic_Reciprocity" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol" via "HOL-Number_Theory.Number_Theory")
locale QR
  fixes p :: "nat"
    and q :: "nat"
  assumes "QR p q"
### theory "HOL-Number_Theory.Residue_Primitive_Roots"
### 0.345s elapsed time, 2.721s cpu time, 0.338s GC time
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>(x, y). x \<otimes> y)
### \<in> hom (subgroup_generated G A \<times>\<times> subgroup_generated G B)
###        G \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (\<lambda>(x, y). x \<otimes> y)
### \<in> hom (subgroup_generated G A \<times>\<times> subgroup_generated G B)
###        G \<equiv>
### True
### Ignoring duplicate rewrite rule:
### (\<lambda>(x, y). x \<otimes> y)
### \<in> hom (subgroup_generated G A \<times>\<times> subgroup_generated G B)
###        G \<equiv>
### True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Number_Theory.Quadratic_Reciprocity"
### 0.478s elapsed time, 3.780s cpu time, 0.338s GC time
Loading theory "HOL-Number_Theory.Number_Theory" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Legendre_Symbol")
### Ignoring duplicate rewrite rule:
### carrier (subgroup_generated G A) \<equiv> A
### Ignoring duplicate rewrite rule:
### carrier (subgroup_generated G B) \<equiv> B
### theory "HOL-Algebra.Free_Abelian_Groups"
### 1.230s elapsed time, 9.729s cpu time, 0.894s GC time
### theory "HOL-Algebra.Subrings"
### 3.822s elapsed time, 29.022s cpu time, 10.170s GC time
Loading theory "HOL-Algebra.Embedded_Algebras" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Loading theory "HOL-Algebra.Generated_Rings" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Generated_Fields")
Proofs for inductive predicate(s) "generate_ringp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale embedded_algebra
  fixes K :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "embedded_algebra K R"
Found termination order: "{}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "independent"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "HOL-Algebra.Generated_Rings"
### 0.736s elapsed time, 5.865s cpu time, 0.275s GC time
Loading theory "HOL-Algebra.Generated_Fields" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Proofs for inductive predicate(s) "dimension"
  Proving monotonicity ...
  Proving the introduction rules ...
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Proofs for inductive predicate(s) "generate_fieldp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Number_Theory.Number_Theory"
### 2.911s elapsed time, 22.248s cpu time, 10.456s GC time
Loading theory "Probabilistic_Prime_Tests.Legendre_Symbol" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol")
### theory "Probabilistic_Prime_Tests.Legendre_Symbol"
### 0.173s elapsed time, 1.363s cpu time, 0.000s GC time
### theory "HOL-Algebra.Generated_Fields"
### 2.262s elapsed time, 17.185s cpu time, 10.105s GC time
### Introduced fixed type variable(s): 'b in "t__"
### Introduced fixed type variable(s): 'b in "t__"
### Introduced fixed type variable(s): 'b in "t__"
locale ring_hom_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a \<Rightarrow> 'c"
  assumes "ring_hom_ring R S h"
locale subalgebra
  fixes K :: "'a set"
    and V :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "subalgebra K V R"
\<lbrakk>Group.group ?G;
 \<And>H. H \<in> ?A \<Longrightarrow> subgroup H ?G;
 ?A \<noteq> {}\<rbrakk>
\<Longrightarrow> subgroup (\<Inter> ?A) ?G
\<lbrakk>Group.group ?G; subgroup ?I ?G; subgroup ?J ?G\<rbrakk>
\<Longrightarrow> subgroup (?I \<inter> ?J) ?G
### theory "HOL-Algebra.Embedded_Algebras"
### 4.705s elapsed time, 36.589s cpu time, 11.329s GC time
### theory "HOL-Algebra.Ring_Divisibility"
### 8.877s elapsed time, 68.460s cpu time, 21.862s GC time
Loading theory "HOL-Algebra.Polynomials" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
### Ignoring duplicate rewrite rule:
### Group.group C \<equiv> True
### Ignoring duplicate rewrite rule:
### g \<in> hom B C \<equiv> True
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
Found termination order: "length <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### Group.group A \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group B \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group C \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group B \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group C \<equiv> True
Found termination order: "length <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (fst p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
Found termination order: "{}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### Ignoring duplicate rewrite rule:
### \<Prod>x\<in>?A1. ?y1 \<equiv> ?y1 ^ card ?A1
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
### Ignoring duplicate rewrite rule:
### carrier (mult_of ?R1) \<equiv> carrier ?R1 - {\<zero>\<^bsub>?R1\<^esub>}
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### theory "HOL-Algebra.Polynomials"
### 13.421s elapsed time, 101.371s cpu time, 4.336s GC time
Loading theory "HOL-Algebra.Polynomial_Divisibility" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Algebraic_Closure" via "HOL-Algebra.Indexed_Polynomials")
linarith_split_limit exceeded (current value is 9)
### theory "HOL-Algebra.Polynomial_Divisibility"
### 17.958s elapsed time, 95.716s cpu time, 21.858s GC time
Loading theory "HOL-Algebra.Finite_Extensions" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Algebraic_Closure")
Loading theory "HOL-Algebra.Indexed_Polynomials" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra" via "HOL-Algebra.Algebraic_Closure")
Proofs for inductive predicate(s) "simple_extensionp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order: "{}"
Proofs for inductive predicate(s) "indexed_psetp"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
Found termination order: "{}"
Found termination order: "{}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### theory "HOL-Algebra.Indexed_Polynomials"
### 5.557s elapsed time, 19.528s cpu time, 2.576s GC time
### theory "HOL-Algebra.Finite_Extensions"
### 10.344s elapsed time, 44.108s cpu time, 22.017s GC time
Loading theory "HOL-Algebra.Algebraic_Closure" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" via "HOL-Algebra.Algebra")
Proofs for inductive predicate(s) "iso_incl"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
locale algebraic_closure
  fixes L :: "('a, 'b) ring_scheme"  (structure)
    and K :: "'a set"
  assumes "algebraic_closure L K"
locale algebraically_closed
  fixes L :: "('a, 'b) ring_scheme"  (structure)
  assumes "algebraically_closed L"
### theory "HOL-Algebra.Algebraic_Closure"
### 4.200s elapsed time, 17.450s cpu time, 2.021s GC time
Loading theory "HOL-Algebra.Algebra" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol" via "Probabilistic_Prime_Tests.Algebraic_Auxiliaries")
### theory "HOL-Algebra.Algebra"
### 1.532s elapsed time, 6.064s cpu time, 1.206s GC time
Loading theory "Probabilistic_Prime_Tests.Algebraic_Auxiliaries" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness" via "Probabilistic_Prime_Tests.Jacobi_Symbol")
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_add_left_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_add_right_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_add_left_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_mult_left_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_add_right_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_mult_right_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_mult_left_eq"
### Metis: Unused theorems: "Euclidean_Division.euclidean_semiring_cancel_class.mod_mult_right_eq"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "Probabilistic_Prime_Tests.Algebraic_Auxiliaries"
### 0.771s elapsed time, 4.205s cpu time, 0.000s GC time
Loading theory "Probabilistic_Prime_Tests.Generalized_Primality_Test" (required by "Probabilistic_Prime_Tests.Fermat_Test")
Loading theory "Probabilistic_Prime_Tests.Residues_Nat" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness")
Loading theory "Probabilistic_Prime_Tests.Jacobi_Symbol" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness")
*** Failed to apply initial proof method (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** goal (1 subgoal):
***  1. n = unit_factor n * prod_mset (prime_factorization n)
*** At command "by" (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")
locale residues_mult_nat
  fixes n :: "nat"
    and G :: "nat monoid"
  assumes "residues_mult_nat n"
  defines "G \<equiv> Residues_Mult n"
*** Failed to apply initial proof method (line 452 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** using this:
***   card (prime_factors n) = Suc 0
*** goal (1 subgoal):
***  1. (\<Prod>p\<in>prime_factors n. p ^ multiplicity p n) = normalize n
*** At command "by" (line 452 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")
*** Failed to apply initial proof method (line 470 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** goal (1 subgoal):
***  1. (\<Prod>p\<in>prime_factors x. p ^ multiplicity p x) = normalize x
*** At command "by" (line 470 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")
locale residues_nat
  fixes n :: "nat"
    and R :: "nat ring"
  assumes "residues_nat n"
  defines "R \<equiv> Residues_nat n"
locale residues_nat_prime
  fixes p :: "nat"
    and R :: "nat ring"
  assumes "residues_nat_prime p"
  defines "R \<equiv> Residues_nat p"
locale prob_primality_test
  fixes P :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and n :: "nat"
  assumes "prob_primality_test P n"
locale good_prob_primality_test
  fixes P :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and n :: "nat"
    and q :: "real"
  assumes "good_prob_primality_test P n q"
### theory "Probabilistic_Prime_Tests.Generalized_Primality_Test"
### 0.780s elapsed time, 5.727s cpu time, 0.941s GC time
### theory "Probabilistic_Prime_Tests.Jacobi_Symbol"
### 0.804s elapsed time, 5.853s cpu time, 0.000s GC time
Loading theory "Probabilistic_Prime_Tests.QuadRes" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness" via "Probabilistic_Prime_Tests.Euler_Witness")
### theory "Probabilistic_Prime_Tests.QuadRes"
### 0.064s elapsed time, 0.497s cpu time, 0.000s GC time
### theory "Probabilistic_Prime_Tests.Residues_Nat"
### 1.149s elapsed time, 8.597s cpu time, 0.905s GC time
Loading theory "Probabilistic_Prime_Tests.Carmichael_Numbers" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness")
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
### theory "Probabilistic_Prime_Tests.Carmichael_Numbers"
### 0.094s elapsed time, 0.740s cpu time, 0.000s GC time
Loading theory "Probabilistic_Prime_Tests.Euler_Witness" (required by "Probabilistic_Prime_Tests.Fermat_Test" via "Probabilistic_Prime_Tests.Fermat_Witness")
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
locale euler_witness_context
  fixes p :: "nat"
  assumes "euler_witness_context p"
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
### theory "Probabilistic_Prime_Tests.Euler_Witness"
### 0.523s elapsed time, 4.195s cpu time, 0.000s GC time
Loading theory "Probabilistic_Prime_Tests.Fermat_Witness" (required by "Probabilistic_Prime_Tests.Fermat_Test")
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
linarith_split_limit exceeded (current value is 0)
Loading theory "Probabilistic_Prime_Tests.Solovay_Strassen_Test"
### theory "Probabilistic_Prime_Tests.Fermat_Witness"
### 0.550s elapsed time, 4.103s cpu time, 0.620s GC time
Loading theory "Probabilistic_Prime_Tests.Fermat_Test"
### theory "Probabilistic_Prime_Tests.Solovay_Strassen_Test"
### 0.588s elapsed time, 4.598s cpu time, 0.620s GC time
Loading theory "Probabilistic_Prime_Tests.Miller_Rabin_Test"
linarith_split_limit exceeded (current value is 9)
### theory "Probabilistic_Prime_Tests.Miller_Rabin_Test"
### 1.799s elapsed time, 14.401s cpu time, 0.790s GC time
locale fermat_test_not_Carmichael_number
  fixes n :: "nat"
  assumes "fermat_test_not_Carmichael_number n"
### theory "Probabilistic_Prime_Tests.Fermat_Test"
### 2.206s elapsed time, 17.648s cpu time, 0.790s GC time
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Ignoring duplicate rewrite rule:
### Group.group G \<equiv> True
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
*** Failed to apply initial proof method (line 470 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** goal (1 subgoal):
***  1. (\<Prod>p\<in>prime_factors x. p ^ multiplicity p x) = normalize x
*** At command "by" (line 470 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")
*** Failed to apply initial proof method (line 452 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** using this:
***   card (prime_factors n) = Suc 0
*** goal (1 subgoal):
***  1. (\<Prod>p\<in>prime_factors n. p ^ multiplicity p n) = normalize n
*** At command "by" (line 452 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")
*** Failed to apply initial proof method (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy"):
*** goal (1 subgoal):
***  1. n = unit_factor n * prod_mset (prime_factorization n)
*** At command "by" (line 401 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy")

==========
Projective_Geometry
Loading theory "Projective_Geometry.Higher_Projective_Space_Rank_Axioms" (required by "Projective_Geometry.Desargues_2D")
Loading theory "Projective_Geometry.Higher_Projective_Space_Axioms"
Loading theory "Projective_Geometry.Projective_Plane_Axioms" (required by "Projective_Geometry.Pappus_Desargues")
Loading theory "Projective_Geometry.Projective_Space_Axioms"
### theory "Projective_Geometry.Higher_Projective_Space_Rank_Axioms"
### 0.041s elapsed time, 0.197s cpu time, 0.000s GC time
Loading theory "Projective_Geometry.Matroid_Rank_Properties" (required by "Projective_Geometry.Desargues_2D")
### theory "Projective_Geometry.Projective_Plane_Axioms"
### 0.055s elapsed time, 0.251s cpu time, 0.000s GC time
Loading theory "Projective_Geometry.Pappus_Property" (required by "Projective_Geometry.Pappus_Desargues")
### theory "Projective_Geometry.Projective_Space_Axioms"
### 0.055s elapsed time, 0.251s cpu time, 0.000s GC time
### theory "Projective_Geometry.Higher_Projective_Space_Axioms"
### 0.061s elapsed time, 0.270s cpu time, 0.000s GC time
### theory "Projective_Geometry.Matroid_Rank_Properties"
### 0.071s elapsed time, 0.336s cpu time, 0.031s GC time
Loading theory "Projective_Geometry.Desargues_2D"
Loading theory "Projective_Geometry.Desargues_3D"
### theory "Projective_Geometry.Pappus_Property"
### 0.163s elapsed time, 0.969s cpu time, 0.078s GC time
Loading theory "Projective_Geometry.Pascal_Property" (required by "Projective_Geometry.Pappus_Desargues")
### theory "Projective_Geometry.Desargues_3D"
### 0.131s elapsed time, 0.867s cpu time, 0.047s GC time
### theory "Projective_Geometry.Pascal_Property"
### 0.102s elapsed time, 0.639s cpu time, 0.042s GC time
Loading theory "Projective_Geometry.Desargues_Property" (required by "Projective_Geometry.Pappus_Desargues")
*** Undefined fact: "linorder_antisym_conv1" (line 158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Projective_Geometry/Matroid_Rank_Properties.thy")
*** At command "by" (line 156 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Projective_Geometry/Matroid_Rank_Properties.thy")
### theory "Projective_Geometry.Desargues_Property"
### 0.153s elapsed time, 1.161s cpu time, 0.098s GC time
Loading theory "Projective_Geometry.Pappus_Desargues"
### theory "Projective_Geometry.Desargues_2D"
### 0.374s elapsed time, 2.601s cpu time, 0.187s GC time
### theory "Projective_Geometry.Pappus_Desargues"
### 0.116s elapsed time, 0.887s cpu time, 0.056s GC time
*** Undefined fact: "linorder_antisym_conv1" (line 158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Projective_Geometry/Matroid_Rank_Properties.thy")
*** At command "by" (line 156 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Projective_Geometry/Matroid_Rank_Properties.thy")

==========
Psi_Calculi
Loading theory "Psi_Calculi.Chain" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Weak_Simulation" via "Psi_Calculi.Simulation" via "Psi_Calculi.Semantics" via "Psi_Calculi.Frame" via "Psi_Calculi.Agent" via "Psi_Calculi.Subst_Term")
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1, ?y1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?y1
### Rewrite rule not in simpset:
### ?p1 \<bullet> ?x1 mem ?xs1 \<equiv> ?p1 \<bullet> ?x1 mem ?p1 \<bullet> ?xs1
### Rewrite rule not in simpset:
### ?p1 \<bullet> (?S1 \<subseteq> ?T1) \<equiv>
### ?p1 \<bullet> ?S1 \<subseteq> ?p1 \<bullet> ?T1
### Rewrite rule not in simpset:
### ?p1 \<bullet> length ?xs1 \<equiv> length (?p1 \<bullet> ?xs1)
### Rewrite rule not in simpset:
### ?p1 \<bullet> distinct ?xs1 \<equiv> distinct (?p1 \<bullet> ?xs1)
### Rewrite rule not in simpset:
### ?p1 \<bullet> map ?f1 ?lst1 \<equiv>
### map (?p1 \<bullet> ?f1) (?p1 \<bullet> ?lst1)
### Rewrite rule not in simpset:
### ?p1 \<bullet> ?Xs1 \<times> ?Ys1 \<equiv>
### (?p1 \<bullet> ?Xs1) \<times> ?p1 \<bullet> ?Ys1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> supp ?x1 \<equiv> supp (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?X1 \<subseteq> ?Y1) \<equiv>
### ?pi1 \<bullet> ?X1 \<subseteq> ?pi1 \<bullet> ?Y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?X1 - ?Y1) \<equiv> ?pi1 \<bullet> ?X1 - ?pi1 \<bullet> ?Y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 = ?y1) \<equiv> ?pi1 \<bullet> ?x1 = ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 \<in> ?X1) \<equiv>
### ?pi1 \<bullet> ?x1 \<in> ?pi1 \<bullet> ?X1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> ?b1 \<sharp>* ?x1 \<equiv>
### (?pi1 \<bullet> ?b1) \<sharp>* (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> ?a1 \<sharp>* ?x1 \<equiv>
### (?pi1 \<bullet> ?a1) \<sharp>* (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> ?a1 \<sharp> ?x1 \<equiv>
### ?pi1 \<bullet> ?a1 \<sharp> ?pi1 \<bullet> ?x1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> [?a1].?x1 \<equiv>
### [(?pi1 \<bullet> ?a1)].(?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### \<exists>!x. ?P1 x \<Longrightarrow>
### ?pi1 \<bullet> (THE x. ?P1 x) \<equiv>
### THE x. ?pi1 \<bullet> ?P1 (rev ?pi1 \<bullet> x)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (\<exists>!x. ?P1 x) \<equiv>
### \<exists>!x. ?pi1 \<bullet> ?P1 (rev ?pi1 \<bullet> x)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (\<exists>x. ?P1 x) \<equiv>
### \<exists>x. ?pi1 \<bullet> ?P1 (rev ?pi1 \<bullet> x)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> HOL.induct_forall ?P1 \<equiv>
### HOL.induct_forall (\<lambda>x. ?pi1 \<bullet> ?P1 (rev ?pi1 \<bullet> x))
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (\<forall>x. ?P1 x) \<equiv>
### \<forall>x. ?pi1 \<bullet> ?P1 (rev ?pi1 \<bullet> x)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> - numeral ?n1 \<equiv> - numeral ?n1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> numeral ?n1 \<equiv> numeral ?n1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> numeral ?n1 \<equiv> numeral ?n1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> set ?xs1 \<equiv> set (?pi1 \<bullet> ?xs1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> insert ?x1 ?X1 \<equiv>
### insert (?pi1 \<bullet> ?x1) (?pi1 \<bullet> ?X1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> {} \<equiv> {}
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?X1 \<union> ?Y1) \<equiv>
### ?pi1 \<bullet> ?X1 \<union> ?pi1 \<bullet> ?Y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 div ?y1) \<equiv>
### ?pi1 \<bullet> ?x1 div ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 * ?y1) \<equiv> ?pi1 \<bullet> ?x1 * ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 - ?y1) \<equiv> ?pi1 \<bullet> ?x1 - ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 + ?y1) \<equiv> ?pi1 \<bullet> ?x1 + ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> max ?x1 ?y1 \<equiv>
### max (?pi1 \<bullet> ?x1) (?pi1 \<bullet> ?y1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> min ?x1 ?y1 \<equiv>
### min (?pi1 \<bullet> ?x1) (?pi1 \<bullet> ?y1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> 1 \<equiv> 1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> 0 \<equiv> 0
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 div ?y1) \<equiv>
### ?pi1 \<bullet> ?x1 div ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 * ?y1) \<equiv> ?pi1 \<bullet> ?x1 * ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 - ?y1) \<equiv> ?pi1 \<bullet> ?x1 - ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?x1 + ?y1) \<equiv> ?pi1 \<bullet> ?x1 + ?pi1 \<bullet> ?y1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> max ?x1 ?y1 \<equiv>
### max (?pi1 \<bullet> ?x1) (?pi1 \<bullet> ?y1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> min ?x1 ?y1 \<equiv>
### min (?pi1 \<bullet> ?x1) (?pi1 \<bullet> ?y1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> 1 \<equiv> 1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> 0 \<equiv> 0
### Rewrite rule not in simpset:
### ?pi1 \<bullet> Suc ?x1 \<equiv> Suc (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> snd ?x1 \<equiv> snd (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> fst ?x1 \<equiv> fst (?pi1 \<bullet> ?x1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?l1.1 @ ?l2.1) \<equiv>
### ?pi1 \<bullet> ?l1.1 @ ?pi1 \<bullet> ?l2.1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> HOL.induct_implies ?A1 ?B1 \<equiv>
### HOL.induct_implies (?pi1 \<bullet> ?A1) (?pi1 \<bullet> ?B1)
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (\<not> ?A1) \<equiv> \<not> ?pi1 \<bullet> ?A1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?A1 \<and> ?B1) \<equiv>
### ?pi1 \<bullet> ?A1 \<and> ?pi1 \<bullet> ?B1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?A1 \<or> ?B1) \<equiv>
### ?pi1 \<bullet> ?A1 \<or> ?pi1 \<bullet> ?B1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (?A1 \<longrightarrow> ?B1) \<equiv>
### ?pi1 \<bullet> ?A1 \<longrightarrow> ?pi1 \<bullet> ?B1
### Rewrite rule not in simpset:
### ?pi1 \<bullet> (if ?b1 then ?c1.1 else ?c2.1) \<equiv>
### if ?pi1 \<bullet> ?b1 then ?pi1 \<bullet> ?c1.1 else ?pi1 \<bullet> ?c2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
Found termination order: "(\<lambda>p. size_list size (snd p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> [] \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### theory "Psi_Calculi.Chain"
### 0.768s elapsed time, 3.631s cpu time, 0.150s GC time
Loading theory "Psi_Calculi.Subst_Term" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Weak_Simulation" via "Psi_Calculi.Simulation" via "Psi_Calculi.Semantics" via "Psi_Calculi.Frame" via "Psi_Calculi.Agent")
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ambiguous input (line 15 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" xvec)
###     ("_idts" ("_position" Tvec) ("_idts" ("_position" T) ("_position" x))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" length) ("_position" xvec))
###           ("_applC" ("_position" length) ("_position" Tvec))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" distinct) ("_position" xvec)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Set.subset_eq"
###               ("_applC" ("_position" set) ("_position" xvec))
###               ("_applC" ("_position" supp) ("_position" T))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>Nominal.fresh"
###                 ("_constrain" ("_position" x) ("_type_name" name))
###                 ("\<^fixed>subst" ("_position" T) ("_position" xvec)
###                   ("_position" Tvec))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Nominal.fresh" ("_position" x) ("_position" Tvec)))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" xvec)
###     ("_idts" ("_position" Tvec) ("_idts" ("_position" T) ("_position" x))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" length) ("_position" xvec))
###           ("_applC" ("_position" length) ("_position" Tvec))))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" distinct) ("_position" xvec)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Set.subset_eq"
###               ("_applC" ("_position" set) ("_position" xvec))
###               ("_applC" ("_position" supp) ("_position" T))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^fixed>subst"
###                 ("\<^const>Nominal.fresh"
###                   ("_constrain" ("_position" x) ("_type_name" name))
###                   ("_position" T))
###                 ("_position" xvec) ("_position" Tvec)))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Nominal.fresh" ("_position" x) ("_position" Tvec)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
locale substType
  fixes
    subst ::
      "'a \<Rightarrow> name list \<Rightarrow> 'b list \<Rightarrow> 'a"
      (\<open>_[_::=_]\<close> [80, 80, 80] 130)
  assumes "substType subst"
### Ambiguous input (line 55 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>subst"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" M))
###     ("_position" xvec) ("_position" Tvec)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh" ("_position" x)
###     ("\<^fixed>subst" ("_position" M) ("_position" xvec)
###       ("_position" Tvec))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 69 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>subst"
###     ("\<^const>Nominal.fresh_star" ("_position" yvec) ("_position" M))
###     ("_position" xvec) ("_position" Tvec)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" yvec)
###     ("\<^fixed>subst" ("_position" M) ("_position" xvec)
###       ("_position" Tvec))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>subst"
###     ("\<^const>Nominal.fresh_star" ("_position" Xs) ("_position" T))
###     ("_position" xvec) ("_position" Tvec)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" Xs)
###     ("\<^fixed>subst" ("_position" T) ("_position" xvec)
###       ("_position" Tvec))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 115 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>subst"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec) ("_position" T))
###     ("_position" xvec) ("_position" Tvec)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" xvec)
###     ("\<^fixed>subst" ("_position" T) ("_position" xvec)
###       ("_position" Tvec))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 126 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>subst"
###     ("\<^const>Nominal.fresh_star"
###       ("_applC" ("_position" set) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" T)))
###     ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###     ("_position" Tvec)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star"
###     ("_applC" ("_position" set) ("_position" xvec))
###     ("\<^fixed>subst"
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" T))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###       ("_position" Tvec))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 187 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.seqSubst"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" T))
###     ("_position" \<sigma>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh" ("_position" x)
###     ("\<^const>local.seqSubst" ("_position" T) ("_position" \<sigma>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 199 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Subst_Term.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.seqSubst"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec) ("_position" T))
###     ("_position" \<sigma>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" xvec)
###     ("\<^const>local.seqSubst" ("_position" T) ("_position" \<sigma>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Psi_Calculi.Subst_Term"
### 0.119s elapsed time, 0.746s cpu time, 0.024s GC time
Loading theory "Psi_Calculi.Agent" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Weak_Simulation" via "Psi_Calculi.Simulation" via "Psi_Calculi.Semantics" via "Psi_Calculi.Frame")
### length descr: 5
### length new_type_names: 3
### perm_empty_thms
### perm_append_thms
### perm_eq_thms
### representing sets
### big_rep_name: psi_Rep_input_Rep_psiCase_Rep_set
Proofs for inductive predicate(s) "psi_Rep_set", "input_Rep_set", "psiCase_Rep_set"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
### proving closure under permutation...
### defining type...
### prove that new types are in class pt_<name> ...
### prove that new types are in class cp_<name1>_<name2> ...
### proving finite support for the new datatype
### proving strong induction theorem ...
### defining recursion combinator ...
Proofs for inductive predicate(s) "psi_input_psiCase_rec_set_1", "psi_input_psiCase_rec_set_2", "psi_input_psiCase_rec_set_3"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> \<zero> \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### ?a1 \<sharp> ?x3.1 \<and> ?a1 \<sharp> ?x2.1 \<and> ?a1 \<sharp> ?x1.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?x2.1\<lparr>?x1.1 \<equiv>
### ?a1 \<sharp> ?x2.1 \<and> ?a1 \<sharp> ?x1.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> Case ?x1.1 \<equiv> ?a1 \<sharp> ?x1.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?x2.1 \<parallel> ?x1.1 \<equiv>
### ?a1 \<sharp> ?x2.1 \<and> ?a1 \<sharp> ?x1.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### ?a1 \<sharp> [?x1.1].?x2.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> \<lbrace>?x1.1\<rbrace> \<equiv> ?a1 \<sharp> ?x1.1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> !?x1.1 \<equiv> ?a1 \<sharp> ?x1.1
Found termination order: "size_list size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> [] \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
consts
  resChain ::
    "name list
     \<Rightarrow> ('a, 'b, 'c) psi \<Rightarrow> ('a, 'b, 'c) psi"
consts
  inputChain ::
    "name list
     \<Rightarrow> 'a \<Rightarrow> ('a, 'b, 'c) psi
                                    \<Rightarrow> ('a, 'b, 'c) input"
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
locale substPsi
  fixes
    substTerm ::
      "'a \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'a"
    and
    substAssert ::
      "'b \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'b"
    and
    substCond ::
      "'c \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'c"
  assumes "substPsi substTerm substAssert substCond"
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> [] \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1 # ?xs1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?xs1
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> (?x1, ?y1) \<equiv> ?a1 \<sharp> ?x1 \<and> ?a1 \<sharp> ?y1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?xvec1 \<sharp>* ?yvec1 \<equiv> ?yvec1 \<sharp>* ?xvec1
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?M; ?x \<sharp> ?xvec; ?x \<sharp> ?Tvec\<rbrakk>
### \<Longrightarrow> ?x \<sharp> substTerm ?M ?xvec ?Tvec
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?M; ?x \<sharp> ?xvec; ?x \<sharp> ?Tvec\<rbrakk>
### \<Longrightarrow> ?x \<sharp> substCond ?M ?xvec ?Tvec
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?M; ?x \<sharp> ?xvec; ?x \<sharp> ?Tvec\<rbrakk>
### \<Longrightarrow> ?x \<sharp> substAssert ?M ?xvec ?Tvec
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?Tvec; ?x \<sharp> ?xvec; ?x \<sharp> ?P\<rbrakk>
### \<Longrightarrow> ?x \<sharp> subs ?P ?xvec ?Tvec
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?Tvec; ?x \<sharp> ?xvec; ?x \<sharp> ?I\<rbrakk>
### \<Longrightarrow> ?x \<sharp> subs' ?I ?xvec ?Tvec
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<sharp> ?Tvec; ?x \<sharp> ?xvec; ?x \<sharp> ?C\<rbrakk>
### \<Longrightarrow> ?x \<sharp> subs'' ?C ?xvec ?Tvec
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
Found termination order: "(\<lambda>p. size_list size (fst p)) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
Found termination order: "(\<lambda>p. size_list size (fst p)) <*mlex*> {}"
### theory "Psi_Calculi.Agent"
### 7.296s elapsed time, 21.693s cpu time, 3.860s GC time
Loading theory "Psi_Calculi.Close_Subst" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Bisim_Subst")
Loading theory "Psi_Calculi.Frame" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Weak_Simulation" via "Psi_Calculi.Simulation" via "Psi_Calculi.Semantics")
Loading theory "Psi_Calculi.Structural_Congruence" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Bisim_Struct_Cong")
Proofs for inductive predicate(s) "structCong"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
locale substPsi
  fixes
    substTerm ::
      "'a \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'a"
    and
    substAssert ::
      "'b \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'b"
    and
    substCond ::
      "'c \<Rightarrow> name list \<Rightarrow> 'a list \<Rightarrow> 'c"
  assumes "substPsi substTerm substAssert substCond"
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### theory "Psi_Calculi.Structural_Congruence"
### 0.127s elapsed time, 0.996s cpu time, 0.067s GC time
### theory "Psi_Calculi.Close_Subst"
### 0.158s elapsed time, 1.217s cpu time, 0.121s GC time
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Rewrite rule not in simpset:
### ?P[<?\<sigma>>] \<equiv>
### foldl (\<lambda>Q (xvec, Tvec). subs Q xvec Tvec) ?P ?\<sigma>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### length descr: 2
### length new_type_names: 1
### perm_empty_thms
### perm_append_thms
### perm_eq_thms
### representing sets
### big_rep_name: frame_Rep_set
Proofs for inductive predicate(s) "frame_Rep_set"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
### proving closure under permutation...
### defining type...
### prove that new types are in class pt_<name> ...
### prove that new types are in class cp_<name1>_<name2> ...
### proving finite support for the new datatype
### proving strong induction theorem ...
### defining recursion combinator ...
Proofs for inductive predicate(s) "frame_rec_set"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ambiguous input (line 22 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" frameResChain)
###       ("_cargs" ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###         ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("_applC" ("_position" frameResChain)
###         ("_cargs" ("_position" xs) ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" frameResChain)
###       ("_cargs" ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###         ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("_applC" ("_position" frameResChain)
###         ("_cargs" ("_position" xs) ("_position" F))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  frameResChain :: "name list \<Rightarrow> 'a frame \<Rightarrow> 'a frame"
### Ambiguous input (line 33 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 41 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>HOL.disj"
###       ("\<^const>Set.member" ("_position" x)
###         ("_applC" ("_position" set) ("_position" xvec)))
###       ("\<^const>Nominal.fresh" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>HOL.disj"
###       ("\<^const>Set.member" ("_position" x)
###         ("_applC" ("_position" set) ("_position" xvec)))
###       ("\<^const>Nominal.fresh" ("_position" x) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 49 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" Xs)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("_Ball" ("_position" x) ("_position" Xs)
###       ("\<^const>HOL.disj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" set) ("_position" xvec)))
###         ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" Xs)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("_Ball" ("_position" x) ("_position" Xs)
###       ("\<^const>HOL.disj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" set) ("_position" xvec)))
###         ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 60 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star"
###     ("_applC" ("_position" set) ("_position" xvec))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star"
###     ("_applC" ("_position" set) ("_position" xvec))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 91 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 65 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star"
###     ("_applC" ("_position" set)
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec)))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star"
###     ("_applC" ("_position" set)
###       ("\<^const>Nominal.perm" ("_position" p) ("_position" xvec)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 106 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.append" ("_position" xvec) ("_position" yvec))
###       ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 171 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 184 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" y) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 67 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Nominal.perm" ("_position" p)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Nominal.perm" ("_position" p)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Nominal.perm" ("_position" p)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Nominal.perm" ("_position" p)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 136 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 222 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 478 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 596 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" a) ("_position" F))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.list.Cons" ("_position" a) ("_position" A\<^sub>F))
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" a) ("_position" F))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>List.list.Cons" ("_position" a) ("_position" A\<^sub>F))
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" a) ("_position" F))
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.list.Cons" ("_position" a) ("_position" A\<^sub>F))
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" a) ("_position" F))
###     ("\<^const>Agent.resChain"
###       ("\<^const>List.list.Cons" ("_position" a) ("_position" A\<^sub>F))
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale assertionAux
  fixes
    SCompose :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>\<otimes>\<close> 80)
    and
    SImp :: "'b \<Rightarrow> 'c \<Rightarrow> bool"
      (\<open>_ \<turnstile> _\<close> [70, 70] 70)
    and SBottom :: "'b"  (\<open>\<bottom>\<close> 90)
    and
    SChanEq :: "'a \<Rightarrow> 'a \<Rightarrow> 'c"
      (\<open>_ \<leftrightarrow> _\<close> [80, 80] 80)
  assumes "assertionAux (\<otimes>) SImp (\<bottom>) SChanEq"
### Ambiguous input (line 283 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" yvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 556 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" b)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" a) ("_tuple_arg" ("_position" b))))
###         ("\<^const>Agent.resChain" ("_position" A\<^sub>F')
###           ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" b)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" a) ("_tuple_arg" ("_position" b))))
###         ("\<^const>Agent.resChain" ("_position" A\<^sub>F')
###           ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" b)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" a) ("_tuple_arg" ("_position" b))))
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F')
###           ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" b)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" a) ("_tuple_arg" ("_position" b))))
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F')
###           ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 293 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh" ("_position" x)
###     ("\<^const>Frame.frameResChain" ("_position" yvec')
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh" ("_position" x)
###     ("\<^const>Agent.resChain" ("_position" yvec')
###       ("_applC" ("_position" FAssert) ("_position" \<Psi>')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ambiguous input (line 696 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh" ("_position" x)
###     ("\<^fixed>SChanEq" ("_position" M) ("_position" N))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>SChanEq"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" M))
###     ("_position" N)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 310 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Not"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Not"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec')
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 913 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xs)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" ys)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xs)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frameResChain" ("_position" ys)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xs)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" ys)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xs)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F))))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.resChain" ("_position" ys)
###         ("_applC" ("_position" FAssert) ("_position" \<Psi>\<^sub>F'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1108 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" \<Psi>')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs"
###           ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###           ("_position" \<Psi>')))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("_applC" ("_position" insertAssertion)
###           ("_cargs" ("_position" F) ("_position" \<Psi>')))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" \<Psi>')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###           ("_position" \<Psi>')))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("_applC" ("_position" insertAssertion)
###           ("_cargs" ("_position" F) ("_position" \<Psi>')))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" \<Psi>')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs"
###           ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###           ("_position" \<Psi>')))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("_applC" ("_position" insertAssertion)
###           ("_cargs" ("_position" F) ("_position" \<Psi>')))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" \<Psi>')))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###           ("_position" \<Psi>')))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("_applC" ("_position" insertAssertion)
###           ("_cargs" ("_position" F) ("_position" \<Psi>')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1134 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" G)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" mergeFrame)
###         ("_cargs"
###           ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###           ("_position" G)))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("_applC" ("_position" mergeFrame)
###           ("_cargs" ("_position" F) ("_position" G)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" G)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" mergeFrame)
###         ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###           ("_position" G)))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("_applC" ("_position" mergeFrame)
###           ("_cargs" ("_position" F) ("_position" G)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" G)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" mergeFrame)
###         ("_cargs"
###           ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###           ("_position" G)))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("_applC" ("_position" mergeFrame)
###           ("_cargs" ("_position" F) ("_position" G)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" G)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" mergeFrame)
###         ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###           ("_position" G)))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("_applC" ("_position" mergeFrame)
###           ("_cargs" ("_position" F) ("_position" G)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1174 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" P)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" P)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" P)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" P)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?p1 \<bullet> \<bottom> \<equiv> \<bottom>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ambiguous input (line 1300 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("_Ball" ("_position" x) ("_applC" ("_position" set) ("_position" xvec))
###       ("\<^const>HOL.disj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" set) ("_position" yvec)))
###         ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("_Ball" ("_position" x) ("_applC" ("_position" set) ("_position" xvec))
###       ("\<^const>HOL.disj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" set) ("_position" yvec)))
###         ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1319 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Nominal.fresh_star" ("_position" xvec) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh_star" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Nominal.fresh_star" ("_position" xvec) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1332 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Nominal.fresh" ("_position" x) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?xvec1 \<sharp>* (\<bottom>) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?Xs1 \<sharp>* (\<bottom>) \<equiv> True
### Ambiguous input (line 1427 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("_position" F)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("_position" F)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1450 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp" ("_position" F)
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp" ("_position" F)
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1472 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("_position" F)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("_position" F)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1483 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ambiguous input (line 1522 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1531 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1588 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1596 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1604 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1612 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1620 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1628 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Frame.frameResChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Agent.resChain" ("_position" yvec)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("\<^const>Agent.resChain" ("_position" yvec) ("_position" F)))
###     ("\<^const>Frame.frameResChain" ("_position" yvec)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1436 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1437 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1492 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1493 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1438 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1462 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1650 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1657 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1667 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Frame.frameResChain" ("_position" xvec)
###             ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Frame.frameResChain" ("_position" xvec)
###             ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1549 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("_position" F))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1678 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Frame.frameResChain" ("_position" xvec)
###             ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("_applC" ("_position" extractFrame)
###           ("\<^const>Frame.frameResChain" ("_position" xvec)
###             ("_position" P)))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_applC" ("_position" extractFrame) ("_position" P))
###           ("_position" \<Psi>))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1689 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatImp"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1700 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1551 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###         ("\<^const>Frame.frame.FRes" ("_position" y')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###         ("\<^const>Frame.frame.FRes" ("_position" y')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###         ("\<^const>Agent.psi.Res" ("_position" y')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###         ("\<^const>Agent.psi.Res" ("_position" y')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1841 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###         ("_position" \<Psi>\<^sub>F))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>G)
###           ("_position" \<Psi>\<^sub>G))))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.append" ("_position" A\<^sub>F)
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>G)))
###       ("\<^fixed>SCompose" ("_position" \<Psi>\<^sub>F)
###         ("_position" \<Psi>\<^sub>G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###         ("_position" \<Psi>\<^sub>F))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>G)
###           ("_position" \<Psi>\<^sub>G))))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.append" ("_position" A\<^sub>F)
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>G)))
###       ("\<^fixed>SCompose" ("_position" \<Psi>\<^sub>F)
###         ("_position" \<Psi>\<^sub>G)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1553 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1859 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###         ("_position" \<Psi>\<^sub>F))
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>G)
###           ("_position" \<Psi>\<^sub>G))))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.append" ("_position" A\<^sub>F)
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>G)))
###       ("\<^fixed>SCompose" ("_position" \<Psi>\<^sub>F)
###         ("_position" \<Psi>\<^sub>G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###         ("_position" \<Psi>\<^sub>F))
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>G)
###           ("_position" \<Psi>\<^sub>G))))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.append" ("_position" A\<^sub>F)
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>G)))
###       ("\<^fixed>SCompose" ("_position" \<Psi>\<^sub>F)
###         ("_position" \<Psi>\<^sub>G)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ambiguous input (line 1871 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_position" F) ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_position" F) ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_position" F) ("_position" \<Psi>))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" insertAssertion)
###         ("_cargs" ("_position" F) ("_position" \<Psi>))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1879 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Frame.frameResChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" P)))
###     ("\<^const>Agent.resChain" ("_position" xvec)
###       ("_applC" ("_position" extractFrame) ("_position" P)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1888 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" F))
###     ("_position" F)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.resChain" ("_position" xvec) ("_position" F))
###     ("_position" F)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1511 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1555 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 32 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" x')
###       ("\<^const>Agent.psi.Res" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" x')
###       ("\<^const>Frame.frame.FRes" ("_position" y')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1724 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("_position" \<Psi>'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("_position" \<Psi>'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1559 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("_position" F))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1726 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs"
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("_position" \<Psi>'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" insertAssertion)
###       ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###         ("_position" \<Psi>)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("_position" \<Psi>'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1789 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mergeFrame)
###       ("_cargs"
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###         ("_position" G)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F\<^sub>G)
###       ("_position" \<Psi>\<^sub>F\<^sub>G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mergeFrame)
###       ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###         ("_position" G)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F\<^sub>G)
###       ("_position" \<Psi>\<^sub>F\<^sub>G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1561 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###         ("\<^const>Frame.frame.FRes" ("_position" x')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###         ("\<^const>Frame.frame.FRes" ("_position" x')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###         ("\<^const>Agent.psi.Res" ("_position" x')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###         ("\<^const>Agent.psi.Res" ("_position" x')
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale assertion
  fixes SCompose :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and SImp :: "'b \<Rightarrow> 'c \<Rightarrow> bool"
    and SBottom :: "'b"
    and SChanEq :: "'a \<Rightarrow> 'a \<Rightarrow> 'c"
  assumes "assertion SCompose SImp SBottom SChanEq"
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ambiguous input (line 1563 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###             ("_position" F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ambiguous input (line 1791 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F\<^sub>G)
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F\<^sub>G)
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1794 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F\<^sub>G)
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F\<^sub>G)
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1566 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_DDDOT")
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Nominal.perm"
###           ("_list"
###             ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###           ("\<^const>Nominal.perm"
###             ("_list"
###               ("_tuple" ("_position" y) ("_tuple_arg" ("_position" y'))))
###             ("_position" F)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ambiguous input (line 1731 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F)
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Nominal.fresh_star" ("_position" A\<^sub>F)
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1800 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mergeFrame)
###       ("_cargs"
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###         ("_position" G)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F\<^sub>G)
###       ("_position" \<Psi>\<^sub>F\<^sub>G))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mergeFrame)
###       ("_cargs" ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###         ("_position" G)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F\<^sub>G)
###       ("_position" \<Psi>\<^sub>F\<^sub>G))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2085 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2087 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" G) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" G) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" G) ("_position" F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" G) ("_position" F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ambiguous input (line 2089 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))
###       ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))
###       ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))
###       ("_position" F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>local.mergeFrame" ("_position" F) ("_position" G)))
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))
###       ("_position" F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### theory "Psi_Calculi.Frame"
### 1.399s elapsed time, 6.541s cpu time, 0.336s GC time
### Ambiguous input (line 2091 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))
###       ("_position" F))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))
###       ("_position" F))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" G))
###       ("_position" F))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameStatEq"
###     ("\<^const>local.mergeFrame"
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G))
###       ("_position" F))
###     ("\<^const>local.mergeFrame" ("_position" F)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" G)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Loading theory "Psi_Calculi.Semantics" (required by "Psi_Calculi.Weak_Bisim_Subst" via "Psi_Calculi.Weak_Bisim_Struct_Cong" via "Psi_Calculi.Weak_Bisim_Pres" via "Psi_Calculi.Weak_Bisimulation" via "Psi_Calculi.Weak_Simulation" via "Psi_Calculi.Simulation")
### Ambiguous input (line 1569 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 32 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Agent.psi.Res" ("_position" y')
###       ("\<^const>Agent.psi.Res" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Frame.frame.FRes" ("_position" y')
###       ("\<^const>Frame.frame.FRes" ("_position" x')
###         ("\<^const>Frame.frameResChain" ("_position" A\<^sub>F)
###           ("_applC" ("_position" FAssert)
###             ("\<^const>Nominal.perm"
###               ("_list"
###                 ("_tuple" ("_position" x) ("_tuple_arg" ("_position" x'))))
###               ("\<^const>Nominal.perm"
###                 ("_list"
###                   ("_tuple" ("_position" y)
###                     ("_tuple_arg" ("_position" y'))))
###                 ("_position" \<Psi>\<^sub>F)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1576 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 16 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" y)
###         ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>local.FrameImp"
###       ("\<^const>Frame.frame.FRes" ("_position" x)
###         ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###       ("_position" \<phi>))
###     ("\<^const>local.FrameImp"
###       ("\<^const>Agent.psi.Res" ("_position" y)
###         ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###       ("_position" \<phi>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1578 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Frame.frame.FRes" ("_position" y) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("\<^const>Agent.psi.Res" ("_position" y) ("_position" F)))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1579 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("_position" \<phi>)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>local.FrameImp"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("_position" \<phi>)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Metis: Unused theorems: "local.Associativity"
### Ambiguous input (line 2154 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" guarded)
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" P))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" guarded)
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" P))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2158 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" P)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>x\<^sub>P)
###       ("_position" \<Psi>\<^sub>x\<^sub>P))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" extractFrame)
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" P)))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>x\<^sub>P)
###       ("_position" \<Psi>\<^sub>x\<^sub>P))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1751 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>F'))
###       ("_position" \<Psi>\<^sub>F))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>F'))
###       ("_position" \<Psi>\<^sub>F))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1752 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm"
###       ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###       ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F)))
###     ("\<^const>Nominal.perm"
###       ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###       ("\<^const>Frame.FAssertJudge"
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>F'))
###         ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm"
###       ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###       ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F)))
###     ("\<^const>Nominal.perm"
###       ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###       ("\<^const>Frame.FAssertJudge"
###         ("\<^const>List.list.Cons" ("_position" x) ("_position" A\<^sub>F'))
###         ("_position" \<Psi>\<^sub>F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1753 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge" ("_position" A\<^sub>F)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>?pi1 \<bullet> ?x1.1\<rparr>?pi1 \<bullet> ?x2.1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<langle>\<epsilon>, ?x1.1\<rangle> \<equiv>
### \<langle>\<epsilon>, ?pi1 \<bullet> ?x1.1\<rangle>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<box> ?x3.1 \<Rightarrow> ?x2.1 ?x1.1  \<equiv>
### \<box> (?pi1 \<bullet>
###         ?x3.1) \<Rightarrow> (?pi1 \<bullet> ?x2.1) (?pi1 \<bullet> ?x1.1) 
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<bottom>\<^sub>c \<equiv> \<bottom>\<^sub>c
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<nu>?x1.1?x2.1 \<equiv>
### \<nu>(?pi1 \<bullet> ?x1.1)(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<rparr>?x2.1.?x1.1 \<equiv>
### \<rparr>(?pi1 \<bullet> ?x2.1).(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> !?x1.1 \<equiv> !(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lbrace>?x1.1\<rbrace> \<equiv>
### \<lbrace>(?pi1 \<bullet> ?x1.1)\<rbrace>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<lparr>\<nu>?x1.1\<rparr>?x2.1 \<equiv>
### \<lparr>\<nu>(?pi1 \<bullet> ?x1.1)\<rparr>(?pi1 \<bullet> ?x2.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1 \<parallel> ?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1) \<parallel> (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Case ?x1.1 \<equiv> Case (?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x2.1\<lparr>?x1.1 \<equiv>
### (?pi1 \<bullet> ?x2.1)\<lparr>(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> ?x3.1\<langle>?x2.1\<rangle>.?x1.1 \<equiv>
### (?pi1 \<bullet>
###  ?x3.1)\<langle>(?pi1 \<bullet> ?x2.1)\<rangle>.(?pi1 \<bullet> ?x1.1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> \<zero> \<equiv> \<zero>
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> None \<equiv> None
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> Some ?x1 \<equiv> Some (?pi1 \<bullet> ?x1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1, ?y1) \<equiv> (?pi1 \<bullet> ?x1, ?pi1 \<bullet> ?y1)
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> (?x1 # ?xs1) \<equiv>
### ?pi1 \<bullet> ?x1 # ?pi1 \<bullet> ?xs1
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> [] \<equiv> []
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> () \<equiv> ()
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> False \<equiv> False
### Ignoring duplicate rewrite rule:
### ?pi1 \<bullet> True \<equiv> True
### Ambiguous input (line 1817 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" y) ("_position" A\<^sub>F))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" y)
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" F)))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" y) ("_position" A\<^sub>F))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1818 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Frame.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Frame.frame.FRes" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" y) ("_position" A\<^sub>F))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Agent.psi.Res" ("_position" x) ("_position" F))
###     ("\<^const>Frame.FAssertJudge"
###       ("\<^const>List.list.Cons" ("_position" y) ("_position" A\<^sub>F))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" y))))
###         ("_position" \<Psi>\<^sub>F)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### length descr: 2
### length new_type_names: 1
### perm_empty_thms
### perm_append_thms
### perm_eq_thms
### representing sets
### big_rep_name: boundOutput_Rep_set
Proofs for inductive predicate(s) "boundOutput_Rep_set"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
### proving closure under permutation...
### defining type...
### prove that new types are in class pt_<name> ...
### prove that new types are in class cp_<name1>_<name2> ...
### proving finite support for the new datatype
### proving strong induction theorem ...
### defining recursion combinator ...
Proofs for inductive predicate(s) "boundOutput_rec_set"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### \<not> False \<equiv> True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 \<equiv> ?a1 \<noteq> ?b1
### Ignoring duplicate rewrite rule:
### ?y \<and> ?y \<equiv> ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) \<equiv> True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### Ambiguous input (line 16 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" BOresChain)
###       ("_cargs" ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###         ("_position" B)))
###     ("\<^const>Semantics.boundOutput.BStep" ("_position" x)
###       ("_applC" ("_position" BOresChain)
###         ("_cargs" ("_position" xs) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" BOresChain)
###       ("_cargs" ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###         ("_position" B)))
###     ("\<^const>Frame.frame.FRes" ("_position" x)
###       ("_applC" ("_position" BOresChain)
###         ("_cargs" ("_position" xs) ("_position" B))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" BOresChain)
###       ("_cargs" ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###         ("_position" B)))
###     ("\<^const>Agent.psi.Res" ("_position" x)
###       ("_applC" ("_position" BOresChain)
###         ("_cargs" ("_position" xs) ("_position" B))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  BOresChain ::
    "name list
     \<Rightarrow> ('a, 'b, 'c) boundOutput
                   \<Rightarrow> ('a, 'b, 'c) boundOutput"
### Ambiguous input (line 19 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^fixed>BOresChainJudge" ("_position" xvec) ("_position" B))
###   ("_applC" ("_position" BOresChain)
###     ("_cargs" ("_position" xvec) ("_position" B))))
### ("\<^const>Pure.eq"
###   ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" B))
###   ("_applC" ("_position" BOresChain)
###     ("_cargs" ("_position" xvec) ("_position" B))))
### ("\<^const>Pure.eq"
###   ("\<^const>Agent.resChain" ("_position" xvec) ("_position" B))
###   ("_applC" ("_position" BOresChain)
###     ("_cargs" ("_position" xvec) ("_position" B))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 26 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Semantics.BOresChainJudge"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Semantics.BOresChainJudge"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Semantics.BOresChainJudge" ("_position" xvec)
###         ("_position" B)))
###     ("\<^const>Semantics.BOresChainJudge"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Semantics.BOresChainJudge" ("_position" xvec)
###         ("_position" B)))
###     ("\<^const>Frame.frameResChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Agent.resChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Frame.frameResChain" ("_position" xvec) ("_position" B)))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Nominal.perm" ("_position" perm)
###       ("\<^const>Semantics.BOresChainJudge" ("_position" xvec)
###         ("_position" B)))
###     ("\<^const>Agent.resChain"
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" xvec))
###       ("\<^const>Nominal.perm" ("_position" perm) ("_position" B)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Psi_Calculi.Semantics"
### 0.704s elapsed time, 1.546s cpu time, 0.249s GC time
*** Inner lexical error (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** at "' P = N' \<prec>' P') = (xvec = [] \<and> N = N' \<and> P = P')"
*** Failed to parse prop
*** At command "lemma" (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** At command "by" (line 27 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** Failed to load theory "Psi_Calculi.Simulation" (unresolved "Psi_Calculi.Semantics")
*** Failed to load theory "Psi_Calculi.Sum" (unresolved "Psi_Calculi.Semantics")
*** Failed to load theory "Psi_Calculi.Bisimulation" (unresolved "Psi_Calculi.Simulation")
*** Failed to load theory "Psi_Calculi.Sim_Pres" (unresolved "Psi_Calculi.Simulation")
*** Failed to load theory "Psi_Calculi.Sim_Struct_Cong" (unresolved "Psi_Calculi.Simulation")
*** Failed to load theory "Psi_Calculi.Tau_Chain" (unresolved "Psi_Calculi.Semantics")
*** Failed to load theory "Psi_Calculi.Weak_Stat_Imp" (unresolved "Psi_Calculi.Tau_Chain")
*** Failed to load theory "Psi_Calculi.Weak_Simulation" (unresolved "Psi_Calculi.Simulation", "Psi_Calculi.Tau_Chain")
*** Failed to load theory "Psi_Calculi.Bisim_Pres" (unresolved "Psi_Calculi.Bisimulation", "Psi_Calculi.Sim_Pres")
*** Failed to load theory "Psi_Calculi.Weak_Cong_Simulation" (unresolved "Psi_Calculi.Tau_Chain", "Psi_Calculi.Weak_Simulation")
*** Failed to load theory "Psi_Calculi.Weak_Stat_Imp_Pres" (unresolved "Psi_Calculi.Weak_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Weak_Sim_Pres" (unresolved "Psi_Calculi.Sim_Pres", "Psi_Calculi.Weak_Simulation", "Psi_Calculi.Weak_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Bisim_Struct_Cong" (unresolved "Psi_Calculi.Bisim_Pres", "Psi_Calculi.Sim_Struct_Cong")
*** Failed to load theory "Psi_Calculi.Bisim_Subst" (unresolved "Psi_Calculi.Bisim_Struct_Cong")
*** Failed to load theory "Psi_Calculi.Weak_Bisimulation" (unresolved "Psi_Calculi.Bisim_Struct_Cong", "Psi_Calculi.Weak_Simulation", "Psi_Calculi.Weak_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Weak_Cong_Sim_Pres" (unresolved "Psi_Calculi.Weak_Cong_Simulation", "Psi_Calculi.Weak_Sim_Pres")
*** Failed to load theory "Psi_Calculi.Weak_Bisim_Pres" (unresolved "Psi_Calculi.Weak_Bisimulation", "Psi_Calculi.Weak_Sim_Pres", "Psi_Calculi.Weak_Stat_Imp_Pres")
*** Failed to load theory "Psi_Calculi.Weak_Psi_Congruence" (unresolved "Psi_Calculi.Weak_Bisimulation", "Psi_Calculi.Weak_Cong_Simulation")
*** Failed to load theory "Psi_Calculi.Weakening" (unresolved "Psi_Calculi.Weak_Bisimulation")
*** Failed to load theory "Psi_Calculi.Weaken_Transition" (unresolved "Psi_Calculi.Weakening")
*** Failed to load theory "Psi_Calculi.Weaken_Stat_Imp" (unresolved "Psi_Calculi.Weaken_Transition")
*** Failed to load theory "Psi_Calculi.Weak_Bisim_Struct_Cong" (unresolved "Psi_Calculi.Bisim_Struct_Cong", "Psi_Calculi.Weak_Bisim_Pres")
*** Failed to load theory "Psi_Calculi.Weaken_Simulation" (unresolved "Psi_Calculi.Weaken_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Weak_Bisim_Subst" (unresolved "Psi_Calculi.Bisim_Subst", "Psi_Calculi.Weak_Bisim_Pres", "Psi_Calculi.Weak_Bisim_Struct_Cong")
*** Failed to load theory "Psi_Calculi.Weaken_Bisimulation" (unresolved "Psi_Calculi.Weaken_Simulation", "Psi_Calculi.Weaken_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Weak_Cong_Pres" (unresolved "Psi_Calculi.Weak_Bisim_Pres", "Psi_Calculi.Weak_Cong_Sim_Pres", "Psi_Calculi.Weak_Psi_Congruence")
*** Failed to load theory "Psi_Calculi.Weak_Cong_Struct_Cong" (unresolved "Psi_Calculi.Weak_Bisim_Struct_Cong", "Psi_Calculi.Weak_Cong_Pres")
*** Failed to load theory "Psi_Calculi.Weak_Congruence" (unresolved "Psi_Calculi.Bisim_Subst", "Psi_Calculi.Weak_Cong_Struct_Cong")
*** Failed to load theory "Psi_Calculi.Tau" (unresolved "Psi_Calculi.Bisim_Struct_Cong", "Psi_Calculi.Weak_Congruence")
*** Failed to load theory "Psi_Calculi.Tau_Sim" (unresolved "Psi_Calculi.Sum", "Psi_Calculi.Tau")
*** Failed to load theory "Psi_Calculi.Tau_Stat_Imp" (unresolved "Psi_Calculi.Tau_Sim", "Psi_Calculi.Weaken_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Tau_Laws_No_Weak" (unresolved "Psi_Calculi.Tau_Sim", "Psi_Calculi.Tau_Stat_Imp")
*** Failed to load theory "Psi_Calculi.Tau_Laws_Weak" (unresolved "Psi_Calculi.Tau_Sim", "Psi_Calculi.Tau_Stat_Imp", "Psi_Calculi.Weak_Congruence", "Psi_Calculi.Weaken_Bisimulation")
*** Inner lexical error (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** at "' P = N' \<prec>' P') = (xvec = [] \<and> N = N' \<and> P = P')"
*** Failed to parse prop
*** At command "lemma" (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** At command "by" (line 27 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** Inner lexical error (line 38 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")
*** at "' P = N' \<prec>' P') = (xvec = [] \<and> N = N' \<and> P = P')"
*** Failed to parse prop
*** At command "lemma" (line 29 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy")

==========
Relation_Algebra
Loading theory "Relation_Algebra.More_Boolean_Algebra"
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "\<And>x. inf x (- x) = bot"
    and "sup_compl_top": "\<And>x. sup x (- x) = top"
  assumes "diff_eq": "\<And>x y. x - y = inf x (- y)"
### theory "Relation_Algebra.More_Boolean_Algebra"
### 0.410s elapsed time, 1.456s cpu time, 0.086s GC time
Loading theory "Relation_Algebra.Relation_Algebra"
### theory "Relation_Algebra.Relation_Algebra"
### 0.677s elapsed time, 2.845s cpu time, 0.612s GC time
*** Failed to load theory "Relation_Algebra.Relation_Algebra_Models" (unresolved "Relation_Algebra.Relation_Algebra")
*** Failed to load theory "Relation_Algebra.Relation_Algebra_RTC" (unresolved "Relation_Algebra.Relation_Algebra")
*** Failed to load theory "Relation_Algebra.Relation_Algebra_Tests" (unresolved "Relation_Algebra.Relation_Algebra")
*** Failed to load theory "Relation_Algebra.Relation_Algebra_Vectors" (unresolved "Relation_Algebra.Relation_Algebra")
*** Failed to load theory "Relation_Algebra.Relation_Algebra_Functions" (unresolved "Relation_Algebra.Relation_Algebra_Tests", "Relation_Algebra.Relation_Algebra_Vectors")
*** Failed to load theory "Relation_Algebra.Relation_Algebra_Direct_Products" (unresolved "Relation_Algebra.Relation_Algebra_Functions")
*** exception FAIL NONE raised (line 161 of "General/scan.ML")
*** At command "class" (line 26 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Relation_Algebra/Relation_Algebra.thy")

==========
Root_Balanced_Tree
Loading theory "HOL-Data_Structures.Cmp" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree" via "HOL-Data_Structures.Tree_Set")
Loading theory "HOL-Data_Structures.Less_False" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree" via "HOL-Data_Structures.Tree_Set" via "HOL-Data_Structures.Set_Specs" via "HOL-Data_Structures.List_Ins_Del" via "HOL-Data_Structures.Sorted_Less")
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "Amortized_Complexity.Amortized_Framework0" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree")
Loading theory "Root_Balanced_Tree.Time_Monad" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree")
Loading theory "HOL-Data_Structures.Balance" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree")
### theory "HOL-Data_Structures.Less_False"
### 0.082s elapsed time, 0.327s cpu time, 0.000s GC time
Loading theory "HOL-Data_Structures.Sorted_Less" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree" via "HOL-Data_Structures.Tree_Set" via "HOL-Data_Structures.Set_Specs" via "HOL-Data_Structures.List_Ins_Del")
locale Amortized
  fixes init :: "'s"
    and nxt :: "'o \<Rightarrow> 's \<Rightarrow> 's"
    and inv :: "'s \<Rightarrow> bool"
    and t :: "'o \<Rightarrow> 's \<Rightarrow> real"
    and \<Phi> :: "'s \<Rightarrow> real"
    and U :: "'o \<Rightarrow> 's \<Rightarrow> real"
  assumes "Amortized init nxt inv t \<Phi> U"
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### theory "HOL-Data_Structures.Sorted_Less"
### 0.131s elapsed time, 0.462s cpu time, 0.068s GC time
Loading theory "HOL-Data_Structures.List_Ins_Del" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree" via "HOL-Data_Structures.Tree_Set" via "HOL-Data_Structures.Set_Specs")
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
class linorder = order +
  assumes "linear": "\<And>x y. x \<le> y \<or> y \<le> x"
Found termination order: "length <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "HOL-Data_Structures.Cmp"
### 0.712s elapsed time, 3.414s cpu time, 0.310s GC time
Found termination order: "{}"
### theory "HOL-Data_Structures.List_Ins_Del"
### 0.544s elapsed time, 2.837s cpu time, 0.242s GC time
Loading theory "HOL-Data_Structures.Set_Specs" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree" via "HOL-Data_Structures.Tree_Set")
locale Set
  fixes empty :: "'s"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
  assumes "Set empty insert delete isin set invar"
locale table_insert
  fixes a :: "real"
    and c :: "real"
  assumes "table_insert a c"
locale Set_by_Ordered
  fixes empty :: "'t"
    and insert :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and delete :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and isin :: "'t \<Rightarrow> 'a \<Rightarrow> bool"
    and inorder :: "'t \<Rightarrow> 'a list"
    and inv :: "'t \<Rightarrow> bool"
  assumes "Set_by_Ordered empty insert delete isin inorder inv"
### theory "HOL-Data_Structures.Balance"
### 1.110s elapsed time, 5.262s cpu time, 1.217s GC time
Found termination order: "{}"
locale Set2
  fixes empty :: "'s"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and union :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and inter :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and diff :: "'s \<Rightarrow> 's \<Rightarrow> 's"
  assumes "Set2 empty delete isin set invar insert union inter diff"
### theory "HOL-Data_Structures.Set_Specs"
### 0.403s elapsed time, 1.894s cpu time, 0.907s GC time
Loading theory "HOL-Data_Structures.Tree_Set" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "Root_Balanced_Tree.Root_Balanced_Tree")
(\<Sum>i<?n. t\<^sub>i\<^sub>n\<^sub>c\<^sub>r (incr.state ?f i))
\<le> (\<Sum>i<?n. 2)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Root_Balanced_Tree.Time_Monad"
### 1.409s elapsed time, 7.157s cpu time, 1.323s GC time
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### ML warning (line 19 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 18 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 92 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### split_min \<langle>\<rangle> = undefined
Found termination order: "size <*mlex*> {}"
locale linorder_stupid_syntax
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_stupid_syntax less_eq less"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
locale linorder_no_ub
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
### theory "HOL-Data_Structures.Tree_Set"
### 2.026s elapsed time, 10.345s cpu time, 1.680s GC time
Found termination order: "{}"
locale linorder_no_lb
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
locale constr_dense_linorder
  fixes less_eq :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and less :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
    and between :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 81 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (xT) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.min (\<le>)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (\<le>) (set (?x # ?xs)) \<equiv> fold (ord.max (\<le>)) ?xs ?x
(\<Sum>i<?n. t\<^sub>i\<^sub>n\<^sub>s (local.ins.state ?f i))
\<le> (\<Sum>i<?n. a + 1)
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 4.442s elapsed time, 22.724s cpu time, 3.214s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab" via "HOL-Decision_Procs.Approximation")
Found termination order: "{}"
Found termination order: "{}"
consts
  horner ::
    "(nat \<Rightarrow> nat)
     \<Rightarrow> (nat \<Rightarrow> nat \<Rightarrow> nat)
                   \<Rightarrow> nat
                                 \<Rightarrow> nat
         \<Rightarrow> nat \<Rightarrow> real \<Rightarrow> real"
Found termination order: "{}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "{}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order: "{}"
### theory "Amortized_Complexity.Amortized_Framework0"
### 6.525s elapsed time, 33.653s cpu time, 3.721s GC time
Loading theory "Root_Balanced_Tree.Root_Balanced_Tree" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab")
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
linarith_split_limit exceeded (current value is 9)
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
Found termination order: "{}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   {}"
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 5.947s elapsed time, 33.184s cpu time, 1.315s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Root_Balanced_Tree.Root_Balanced_Tree_Tab")
### Additional type variable(s) in locale specification "RBTi1": 'a
locale RBTi1
  fixes bal_i :: "nat \<Rightarrow> nat \<Rightarrow> bool"
  assumes "RBTi1 TYPE('a) bal_i"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### hchild \<langle>\<rangle> = undefined
Found termination order: "{}"
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### real_of_float ?x \<le> ?z \<Longrightarrow>
### real_of_float (float_round_down ?prec ?x) \<le> ?z
### Rule already declared as introduction (intro)
### ?x \<le> real_of_float ?xa \<Longrightarrow>
### ?x \<le> real_of_float (float_round_up ?prec ?xa)
### Additional type variable(s) in locale specification "RBTi2": 'a
locale RBTi2
  fixes bal_i :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and e :: "real"
  assumes "RBTi2 TYPE('a) bal_i e"
### Ignoring duplicate rewrite rule:
### \<lbrakk>0 < ?x1; 0 < ?y1\<rbrakk>
### \<Longrightarrow> ln ?x1 \<le> ln ?y1 \<equiv> ?x1 \<le> ?y1
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### lb_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1 then Some (- the (ub_ln ?prec1 (float_divr ?prec1 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_down ?prec1
###                     (x * lb_ln_horner ?prec1 (get_even ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_down ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner
###                             (max (?x1 * lapprox_rat ?prec1 2 3 - 1) 0)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_down ?prec1
###                              (float_round_down ?prec1
###                                (lb_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
### Rewrite rule not in simpset:
### ub_ln ?prec1 ?x1 \<equiv>
### if ?x1 \<le> 0 then None
### else if ?x1 < 1
###      then Some (- the (lb_ln ?prec1 (float_divl (max ?prec1 1) 1 ?x1)))
###      else let horner =
###                 \<lambda>x.
###                    float_round_up ?prec1
###                     (x * ub_ln_horner ?prec1 (get_odd ?prec1) 1 x)
###           in if ?x1 \<le> Float 3 (- 1) then Some (horner (?x1 - 1))
###              else if ?x1 < Float 1 1
###                   then Some
###                         (float_round_up ?prec1
###                           (horner (Float 1 (- 1)) +
###                            horner (?x1 * rapprox_rat ?prec1 2 3 - 1)))
###                   else let l = bitlen (mantissa ?x1) - 1
###                        in Some
###                            (float_plus_up ?prec1
###                              (float_round_up ?prec1
###                                (ub_ln2 ?prec1 * Float (exponent ?x1 + l) 0))
###                              (horner (Float (mantissa ?x1) (- l) - 1)))
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
locale RBTi2_Amor
  fixes bal_i :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and e :: "real"
  assumes "RBTi2_Amor TYPE('a) bal_i e"
Found termination order: "{}"
Found termination order: "{}"
### Abstraction on left hand side of equation, in theorem:
### I_RBTi2.up3 ?x ?sib ?twist ?u \<equiv>
### case ?u of Same2 \<Rightarrow> Same2
### | Bal2 t \<Rightarrow> Bal2 (node ?twist t ?x ?sib)
### | Unbal2 t n1 h1 \<Rightarrow>
###     let n2 = Root_Balanced_Tree.size_tree ?sib; t' = node ?twist t ?x ?sib;
###         n' = n1 + n2 + 1; h' = h1 + 1
###     in if int h' \<le> \<lceil>c * log 2 (real n' + 1)\<rceil>
###        then Unbal2 t' n' h'
###        else Let (Root_Balanced_Tree.bal_tree n' t') Bal2
### Abstraction on left hand side of equation, in theorem:
### I_RBTi2.ins3 ?n ?d ?x \<langle>\<rangle> \<equiv>
### if int (?d + 1) \<le> \<lceil>c * log 2 (real (?n + 1) + 1)\<rceil>
### then Bal2 \<langle>\<langle>\<rangle>, ?x, \<langle>\<rangle>\<rangle>
### else Unbal2 \<langle>\<langle>\<rangle>, ?x, \<langle>\<rangle>\<rangle> 1 1
### Abstraction on left hand side of equation, in theorem:
### I_RBTi2.ins3 ?n ?d ?x \<langle>?l, ?y, ?r\<rangle> \<equiv>
### case cmp ?x ?y of
### LT \<Rightarrow>
###   Let (I_RBTi2.ins3 ?n (?d + 1) ?x ?l) (I_RBTi2.up3 ?y ?r False)
### | EQ \<Rightarrow> Same2
### | GT \<Rightarrow>
###     Let (I_RBTi2.ins3 ?n (?d + 1) ?x ?r) (I_RBTi2.up3 ?y ?l True)
locale RBTid1
  fixes bal_i :: "nat \<Rightarrow> nat \<Rightarrow> bool"
  assumes "RBTid1 TYPE('a) bal_i"
Found termination order: "{}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
locale RBTid2
  fixes bal_i :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and e :: "real"
  assumes "RBTid2 TYPE('a) bal_i e"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Abstraction on left hand side of equation, in theorem:
### I_RBTid2.insert3_d ?x (?t, ?n, ?dl) \<equiv>
### Let (I_RBTi2.ins3 (?n + ?dl) 0 ?x ?t)
###  (case_up2 (?t, ?n, ?dl) (\<lambda>t'. (t', ?n + 1, ?dl))
###    (\<lambda>x xa xb. undefined))
### theory "Root_Balanced_Tree.Root_Balanced_Tree"
### 14.374s elapsed time, 78.061s cpu time, 9.456s GC time
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. 0) (\<lambda>x. Suc 0) <*mlex*> {}"
*** Failed to finish proof (line 1809 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>\<not> bal_d (n - Suc 0) (Suc dl); del x t = Some t'\<rbrakk>
***     \<Longrightarrow> \<Phi> (Balance.bal_tree (n - Suc 0) t') = 0
*** At command "by" (line 1809 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy")
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (\<lambda>p. size (fst (snd p)))
    (\<lambda>p. size (fst (snd p))) <*mlex*>
   case_sum (\<lambda>x. Suc 0) (\<lambda>x. 0) <*mlex*>
   case_sum (\<lambda>p. size (fst (snd (snd p))))
    (\<lambda>p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 204 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 36.858s elapsed time, 111.609s cpu time, 15.303s GC time
Loading theory "Root_Balanced_Tree.Root_Balanced_Tree_Tab"
locale Min_tab
  fixes p :: "nat \<Rightarrow> nat \<Rightarrow> bool"
    and tab :: "nat list"
  assumes "Min_tab p tab"
Found termination order: "{}"
### theory "Root_Balanced_Tree.Root_Balanced_Tree_Tab"
### 0.501s elapsed time, 0.869s cpu time, 0.075s GC time
*** Failed to finish proof (line 1809 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>\<not> bal_d (n - Suc 0) (Suc dl); del x t = Some t'\<rbrakk>
***     \<Longrightarrow> \<Phi> (Balance.bal_tree (n - Suc 0) t') = 0
*** At command "by" (line 1809 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy")

==========
Skip_Lists
Loading theory "Monad_Normalisation.Monad_Normalisation" (required by "Skip_Lists.Geometric_PMF")
Loading theory "Skip_Lists.Pi_pmf"
Loading theory "Skip_Lists.Misc"
signature MONAD_RULES =
  sig
    val get_distrib_rule: Proof.context -> string -> thm option
    val get_distrib_rules: Context.generic -> thm list
    val get_monad: Proof.context -> string -> info option
    val get_monad_rules: Context.generic -> thm list
    type info =
       {bind_assoc: thm option,
        bind_commute: thm option,
        bind_return: thm option, return_bind: thm option}
  end
structure Monad_Rules: MONAD_RULES
### Metis: Unused theorems: "List.linorder_class.sorted_list_of_set_2", "List.linorder_class.sorted_list_of_set_3"
### theory "Skip_Lists.Misc"
### 0.109s elapsed time, 0.631s cpu time, 0.031s GC time
### ML warning (line 28 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Monad_Normalisation/monad_normalisation.ML"):
### Matches are not exhaustive.
signature MONAD_NORMALISATION =
  sig val normalise_step: Proof.context -> cterm -> thm option end
structure Monad_Normalisation: MONAD_NORMALISATION
### theory "Monad_Normalisation.Monad_Normalisation"
### 0.186s elapsed time, 1.199s cpu time, 0.062s GC time
### theory "Skip_Lists.Pi_pmf"
### 0.359s elapsed time, 2.485s cpu time, 0.111s GC time
Loading theory "Skip_Lists.Geometric_PMF"
### theory "Skip_Lists.Geometric_PMF"
### 0.410s elapsed time, 2.764s cpu time, 0.088s GC time
Loading theory "Skip_Lists.Skip_List"
*** Failed to finish proof (line 51 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Geometric_PMF.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>summable (\<lambda>x. p * (real x * (1 - p) ^ x)); 0 < p;
***      p \<le> 1\<rbrakk>
***     \<Longrightarrow> summable (\<lambda>x. real x * (1 - p) ^ x)
*** At command "by" (line 51 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Geometric_PMF.thy")
locale random_skip_list
  fixes p :: "real"
### Rule already declared as introduction (intro)
### open {}
locale random_skip_list
  fixes p :: "real"
### Ambiguous input (line 304 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Skip_List.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_set_almost_everywhere" ("_position" x)
###     ("\<^const>Set_Interval.ord_class.atLeastAtMost"
###       ("_constrain" ("\<^const>Groups.zero_class.zero") ("_type_name" real))
###       ("\<^const>Groups.one_class.one"))
###     ("_position" lborel)
###     ("\<^const>HOL.eq"
###       ("\<^const>Fields.inverse_class.inverse_divide"
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one")
###           ("\<^const>Power.power_class.power" ("_position" x)
###             ("_position" n)))
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one") ("_position" x)))
###       ("_applC" ("_position" sum)
###         ("_cargs" ("_applC" ("_vec_type") ("_position" x))
###           ("\<^const>Set_Interval.ord_class.lessThan" ("_position" n)))))))
### ("\<^const>HOL.Trueprop"
###   ("_set_almost_everywhere" ("_position" x)
###     ("\<^const>Set_Interval.ord_class.atLeastAtMost"
###       ("_constrain" ("\<^const>Groups.zero_class.zero") ("_type_name" real))
###       ("\<^const>Groups.one_class.one"))
###     ("_position" lborel)
###     ("\<^const>HOL.eq"
###       ("\<^const>Fields.inverse_class.inverse_divide"
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one")
###           ("\<^const>Power.power_class.power" ("_position" x)
###             ("_position" n)))
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one") ("_position" x)))
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("\<^const>Power.power_class.power") ("_position" x))
###           ("\<^const>Set_Interval.ord_class.lessThan" ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ambiguous input (line 309 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Skip_List.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_set_almost_everywhere" ("_position" x)
###     ("\<^const>Set_Interval.ord_class.greaterThanLessThan"
###       ("_constrain" ("\<^const>Groups.zero_class.zero") ("_type_name" real))
###       ("\<^const>Groups.one_class.one"))
###     ("_position" lborel)
###     ("\<^const>HOL.eq"
###       ("\<^const>Fields.inverse_class.inverse_divide"
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one")
###           ("\<^const>Power.power_class.power" ("_position" x)
###             ("_position" n)))
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one") ("_position" x)))
###       ("_applC" ("_position" sum)
###         ("_cargs" ("_applC" ("_vec_type") ("_position" x))
###           ("\<^const>Set_Interval.ord_class.lessThan" ("_position" n)))))))
### ("\<^const>HOL.Trueprop"
###   ("_set_almost_everywhere" ("_position" x)
###     ("\<^const>Set_Interval.ord_class.greaterThanLessThan"
###       ("_constrain" ("\<^const>Groups.zero_class.zero") ("_type_name" real))
###       ("\<^const>Groups.one_class.one"))
###     ("_position" lborel)
###     ("\<^const>HOL.eq"
###       ("\<^const>Fields.inverse_class.inverse_divide"
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one")
###           ("\<^const>Power.power_class.power" ("_position" x)
###             ("_position" n)))
###         ("\<^const>Groups.minus_class.minus"
###           ("\<^const>Groups.one_class.one") ("_position" x)))
###       ("_applC" ("_position" sum)
###         ("_cargs"
###           ("_applC" ("\<^const>Power.power_class.power") ("_position" x))
###           ("\<^const>Set_Interval.ord_class.lessThan" ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Metis: Falling back on "metis (full_types)"...
### Metis: Falling back on "metis (mono_tags)"...
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
locale random_skip_list
  fixes p :: "real"
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Rule already declared as introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Rule already declared as introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Rule already declared as introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### theory "Skip_Lists.Skip_List"
### 1.135s elapsed time, 6.917s cpu time, 0.357s GC time
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
### Ignoring duplicate rewrite rule:
### lsteps [] ?f1 ?l1 ?up1 ?left1 \<equiv> 0
linarith_split_limit exceeded (current value is 9)
*** Failed to finish proof (line 51 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Geometric_PMF.thy"):
*** goal (1 subgoal):
***  1. \<lbrakk>summable (\<lambda>x. p * (real x * (1 - p) ^ x)); 0 < p;
***      p \<le> 1\<rbrakk>
***     \<Longrightarrow> summable (\<lambda>x. real x * (1 - p) ^ x)
*** At command "by" (line 51 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Skip_Lists/Geometric_PMF.thy")

==========
Smooth_Manifolds
Loading theory "HOL-Library.Function_Algebras" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More")
Loading theory "HOL-Library.Quotient_Syntax" (required by "Smooth_Manifolds.Projective_Space" via "HOL-Library.Quotient_Set")
Loading theory "HOL-Types_To_Sets.Prerequisites" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More" via "HOL-Types_To_Sets.Linear_Algebra_On")
Loading theory "HOL-Types_To_Sets.Types_To_Sets" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More" via "HOL-Types_To_Sets.Linear_Algebra_On")
### theory "HOL-Library.Quotient_Syntax"
### 0.018s elapsed time, 0.089s cpu time, 0.000s GC time
Loading theory "HOL-Library.Quotient_Set" (required by "Smooth_Manifolds.Projective_Space")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
locale local_typedef
  fixes S :: "'b set"
    and s :: "'s itself"
  assumes "local_typedef TYPE('s) S"
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
### ML warning (line 74 of "~~/src/HOL/Types_To_Sets/Examples/Prerequisites.thy"):
### Pattern is not exhaustive.
structure More_Simplifier:
  sig
    val asm_full_var_simplify: Proof.context -> thm -> thm
    val var_simplified:
       Context.generic * Token.T list ->
         attribute * (Context.generic * Token.T list)
    val var_simplify_only: Proof.context -> thm list -> thm -> thm
  end
signature LOCAL_TYPEDEF =
  sig
    val cancel_type_definition: thm -> thm
    val cancel_type_definition_attr: attribute
  end
structure Local_Typedef: LOCAL_TYPEDEF
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
### theory "HOL-Types_To_Sets.Prerequisites"
### 0.060s elapsed time, 0.341s cpu time, 0.000s GC time
### theory "HOL-Library.Quotient_Set"
### 0.077s elapsed time, 0.464s cpu time, 0.039s GC time
signature UNOVERLOADING =
  sig
    val unoverload: cterm -> thm -> thm
    val unoverload_attr: cterm -> attribute
  end
structure Unoverloading: UNOVERLOADING
### theory "HOL-Library.Function_Algebras"
### 0.135s elapsed time, 0.848s cpu time, 0.039s GC time
signature INTERNALIZE_SORT =
  sig
    val internalize_sort: ctyp -> thm -> typ * thm
    val internalize_sort_attr: typ -> attribute
  end
structure Internalize_Sort: INTERNALIZE_SORT
### Metis: Unused theorems: "??.unknown"
### ML warning (line 41 of "~~/src/HOL/Types_To_Sets/unoverload_type.ML"):
### Matches are not exhaustive.
signature UNOVERLOAD_TYPE =
  sig
    val unoverload_type: Context.generic -> indexname list -> thm -> thm
    val unoverload_type_attr: indexname list -> attribute
  end
structure Unoverload_Type: UNOVERLOAD_TYPE
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### Metis: Unused theorems: "??.unknown"
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Value identifier (ctxt') has not been referenced.
### ML warning (line 40 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 66 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
structure Unoverload_Def:
  sig
    val unoverload_def: binding option -> thm -> theory -> theory
    val unoverload_def1_cmd:
       binding option * (Facts.ref * Token.src list) -> theory -> theory
  end
### theory "HOL-Types_To_Sets.Types_To_Sets"
### 0.281s elapsed time, 1.218s cpu time, 0.079s GC time
Loading theory "HOL-Types_To_Sets.Group_On_With" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More" via "HOL-Types_To_Sets.Linear_Algebra_On" via "HOL-Types_To_Sets.Linear_Algebra_On_With")
### Metis: Unused theorems: "??.unknown"
locale semigroup_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "semigroup_add_on_with S pls"
locale ab_semigroup_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes "ab_semigroup_add_on_with S pls"
locale comm_monoid_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and z :: "'a"
  assumes "comm_monoid_add_on_with S pls z"
locale comm_monoid_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and z :: "'a"
  assumes "comm_monoid_add_on_with S pls z"
locale ab_group_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and z :: "'a"
    and mns :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and um :: "'a \<Rightarrow> 'a"
  assumes "ab_group_add_on_with S pls z mns um"
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
locale local_typedef_ab_group_add_on_with
  fixes pls :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and z :: "'b"
    and mns :: "'b \<Rightarrow> 'b \<Rightarrow> 'b"
    and um :: "'b \<Rightarrow> 'b"
    and S :: "'b set"
    and s :: "'s itself"
  assumes "local_typedef_ab_group_add_on_with TYPE('s) pls z mns um S"
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
locale ab_group_add_on_with
  fixes S :: "'a set"
    and pls :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and z :: "'a"
    and mns :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and um :: "'a \<Rightarrow> 'a"
  assumes "ab_group_add_on_with S pls z mns um"
### theory "HOL-Types_To_Sets.Group_On_With"
### 0.406s elapsed time, 1.650s cpu time, 0.064s GC time
Loading theory "HOL-Types_To_Sets.Linear_Algebra_On_With" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More" via "HOL-Types_To_Sets.Linear_Algebra_On")
locale ab_group_add
  fixes plus :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and zero :: "'a"
    and minus :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and uminus :: "'a \<Rightarrow> 'a"
  assumes "class.ab_group_add plus zero minus uminus"
  notes
    "add.semigroup_axioms" = (\<open>semigroup plus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add.assoc" =
      (\<open>plus (plus ?a ?b) ?c = plus ?a (plus ?b ?c)\<close>)
      ["ac_simps"]
  notes
    "semigroup_add_axioms" = (\<open>class.semigroup_add plus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add_assoc" =
      (\<open>plus (plus ?a ?b) ?c = plus ?a (plus ?b ?c)\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes
    "add.abel_semigroup_axioms" = (\<open>abel_semigroup plus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add.commute" = (\<open>plus ?a ?b = plus ?b ?a\<close>) ["ac_simps"]
  notes theorem
    "add.left_commute" =
      (\<open>plus ?b (plus ?a ?c) = plus ?a (plus ?b ?c)\<close>)
      ["ac_simps"]
  notes
    "ab_semigroup_add_axioms" = (\<open>class.ab_semigroup_add plus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add_commute" = (\<open>plus ?a ?b = plus ?b ?a\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes
    (\<open>plus ?b (plus ?a ?c) = plus ?a (plus ?b ?c)\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "add_ac" = \<open>plus (plus ?a ?b) ?c = plus ?a (plus ?b ?c)\<close>
      \<open>plus ?a ?b = plus ?b ?a\<close>
      \<open>plus ?b (plus ?a ?c) = plus ?a (plus ?b ?c)\<close>
  notes
    "add.monoid_axioms" = (\<open>monoid plus zero\<close>)
      ["attribute" "<attribute>"]
  notes "add.left_neutral" = (\<open>plus zero ?a = ?a\<close>) ["simp"]
  notes "add.right_neutral" = (\<open>plus ?a zero = ?a\<close>) ["simp"]
  notes
    "sum_list.monoid_list_axioms" = (\<open>monoid_list plus zero\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum_list.eq_foldr" =
      (\<open>monoid_add.sum_list plus zero ?xs =
              foldr plus ?xs zero\<close>)
      ["code"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "sum_list.Nil" =
      (\<open>monoid_add.sum_list plus zero [] = zero\<close>) ["simp"]
  notes theorem
    "sum_list.Cons" =
      (\<open>monoid_add.sum_list plus zero (?x # ?xs) =
              plus ?x (monoid_add.sum_list plus zero ?xs)\<close>)
      ["simp"]
  notes theorem
    "sum_list.append" =
      (\<open>monoid_add.sum_list plus zero (?xs @ ?ys) =
              plus (monoid_add.sum_list plus zero ?xs)
               (monoid_add.sum_list plus zero ?ys)\<close>)
      ["simp"]
  notes
    "monoid_add_axioms" = (\<open>class.monoid_add plus zero\<close>)
      ["attribute" "<attribute>"]
  notes "add_0_left" = \<open>plus zero ?a = ?a\<close>
  notes "add_0_right" = \<open>plus ?a zero = ?a\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum_list_def" =
      \<open>monoid_add.sum_list plus zero \<equiv>
             monoid_list.F plus zero\<close>
  notes theorem
    "fold_plus_sum_list_rev" =
      \<open>fold plus ?xs =
             plus (monoid_add.sum_list plus zero (rev ?xs))\<close>
  notes theorem
    "size_list_conv_sum_list" =
      \<open>size_list ?f ?xs = sum_list (map ?f ?xs) + length ?xs\<close>
  notes theorem
    "length_concat" =
      \<open>length (concat ?xss) = sum_list (map length ?xss)\<close>
  notes theorem
    "length_product_lists" =
      \<open>length (product_lists ?xss) =
             foldr (*) (map length ?xss) 1\<close>
  notes theorem
    "sum_list_map_filter" =
      \<open>(\<And>x.
                 \<lbrakk>x \<in> set ?xs; \<not> ?P x\<rbrakk>
                 \<Longrightarrow> ?f x = zero) \<Longrightarrow>
             monoid_add.sum_list plus zero (map ?f (filter ?P ?xs)) =
             monoid_add.sum_list plus zero (map ?f ?xs)\<close>
  notes theorem
    "sum_list_triv" =
      \<open>(\<Sum>x\<leftarrow>?xs. ?r) = of_nat (length ?xs) * ?r\<close>
  notes theorem
    "sum_list_0" =
      (\<open>monoid_add.sum_list plus zero (map (\<lambda>x. zero) ?xs) =
              zero\<close>)
      ["simp"]
  notes theorem
    "sum_list_distinct_conv_sum_set" =
      \<open>distinct ?xs \<Longrightarrow>
             sum_list (map ?f ?xs) = sum ?f (set ?xs)\<close>
  notes theorem
    "interv_sum_list_conv_sum_set_nat" =
      \<open>sum_list (map ?f [?m..<?n]) = sum ?f (set [?m..<?n])\<close>
  notes theorem
    "interv_sum_list_conv_sum_set_int" =
      \<open>sum_list (map ?f [?k..?l]) = sum ?f (set [?k..?l])\<close>
  notes theorem
    "sum_list_sum_nth" =
      \<open>sum_list ?xs = sum ((!) ?xs) {0..<length ?xs}\<close>
  notes theorem
    "sum_list_map_filter'" =
      \<open>monoid_add.sum_list plus zero (map ?f (filter ?P ?xs)) =
             monoid_add.sum_list plus zero
              (map (\<lambda>x. if ?P x then ?f x else zero) ?xs)\<close>
  notes
    "add.comm_monoid_axioms" = (\<open>comm_monoid plus zero\<close>)
      ["attribute" "<attribute>"]
  notes "add.comm_neutral" = \<open>plus ?a zero = ?a\<close>
  notes
    "sum.comm_monoid_set_axioms" =
      (\<open>comm_monoid_set plus zero\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum.eq_fold" =
      \<open>comm_monoid_add.sum plus zero ?g ?A =
             Finite_Set.fold (plus \<circ> ?g) zero ?A\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "sum.infinite" =
      (\<open>infinite ?A \<Longrightarrow>
              comm_monoid_add.sum plus zero ?g ?A = zero\<close>)
      ["simp"]
  notes theorem
    "sum.empty" =
      (\<open>comm_monoid_add.sum plus zero ?g {} = zero\<close>) ["simp"]
  notes theorem
    "sum.insert" =
      (\<open>\<lbrakk>finite ?A; ?x \<notin> ?A\<rbrakk>
              \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                 (insert ?x ?A) =
                                plus (?g ?x)
                                 (comm_monoid_add.sum plus zero ?g
                                   ?A)\<close>)
      ["simp"]
  notes theorem
    "sum.remove" =
      \<open>\<lbrakk>finite ?A; ?x \<in> ?A\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                               plus (?g ?x)
                                (comm_monoid_add.sum plus zero ?g
                                  (?A - {?x}))\<close>
  notes theorem
    "sum.insert_remove" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (insert ?x ?A) =
             plus (?g ?x)
              (comm_monoid_add.sum plus zero ?g (?A - {?x}))\<close>
  notes theorem
    "sum.insert_if" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (insert ?x ?A) =
             (if ?x \<in> ?A then comm_monoid_add.sum plus zero ?g ?A
              else plus (?g ?x)
                    (comm_monoid_add.sum plus zero ?g ?A))\<close>
  notes theorem
    "sum.neutral" =
      \<open>\<forall>x\<in>?A. ?g x = zero \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g ?A = zero\<close>
  notes theorem
    "sum.neutral_const" =
      (\<open>comm_monoid_add.sum plus zero (\<lambda>_. zero) ?A =
              zero\<close>)
      ["simp"]
  notes theorem
    "sum.union_inter" =
      \<open>\<lbrakk>finite ?A; finite ?B\<rbrakk>
             \<Longrightarrow> plus
                                (comm_monoid_add.sum plus zero ?g
                                  (?A \<union> ?B))
                                (comm_monoid_add.sum plus zero ?g
                                  (?A \<inter> ?B)) =
                               plus (comm_monoid_add.sum plus zero ?g ?A)
                                (comm_monoid_add.sum plus zero ?g
                                  ?B)\<close>
  notes theorem
    "sum.union_inter_neutral" =
      \<open>\<lbrakk>finite ?A; finite ?B;
              \<forall>x\<in>?A \<inter> ?B. ?g x = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (?A \<union> ?B) =
                               plus (comm_monoid_add.sum plus zero ?g ?A)
                                (comm_monoid_add.sum plus zero ?g
                                  ?B)\<close>
  notes theorem
    "sum.union_disjoint" =
      \<open>\<lbrakk>finite ?A; finite ?B; ?A \<inter> ?B = {}\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (?A \<union> ?B) =
                               plus (comm_monoid_add.sum plus zero ?g ?A)
                                (comm_monoid_add.sum plus zero ?g
                                  ?B)\<close>
  notes theorem
    "sum.union_diff2" =
      \<open>\<lbrakk>finite ?A; finite ?B\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (?A \<union> ?B) =
                               plus
                                (plus
                                  (comm_monoid_add.sum plus zero ?g
                                    (?A - ?B))
                                  (comm_monoid_add.sum plus zero ?g
                                    (?B - ?A)))
                                (comm_monoid_add.sum plus zero ?g
                                  (?A \<inter> ?B))\<close>
  notes theorem
    "sum.subset_diff" =
      \<open>\<lbrakk>?B \<subseteq> ?A; finite ?A\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                               plus
                                (comm_monoid_add.sum plus zero ?g (?A - ?B))
                                (comm_monoid_add.sum plus zero ?g
                                  ?B)\<close>
  notes theorem
    "sum.Int_Diff" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g ?A =
             plus (comm_monoid_add.sum plus zero ?g (?A \<inter> ?B))
              (comm_monoid_add.sum plus zero ?g (?A - ?B))\<close>
  notes theorem
    "sum.setdiff_irrelevant" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (?A - {x. ?g x = zero}) =
             comm_monoid_add.sum plus zero ?g ?A\<close>
  notes theorem
    "sum.not_neutral_contains_not_neutral" =
      (\<open>\<lbrakk>comm_monoid_add.sum plus zero ?g ?A \<noteq> zero;
               \<And>a.
                  \<lbrakk>a \<in> ?A; ?g a \<noteq> zero\<rbrakk>
                  \<Longrightarrow> ?thesis\<rbrakk>
              \<Longrightarrow> ?thesis\<close>)
      ["consumes" - 1, "case_names" "1"]
  notes theorem
    "sum.reindex" =
      \<open>inj_on ?h ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (?h ` ?A) =
             comm_monoid_add.sum plus zero (?g \<circ> ?h) ?A\<close>
  notes theorem
    "sum.cong" =
      (\<open>\<lbrakk>?A = ?B;
               \<And>x. x \<in> ?B \<Longrightarrow> ?g x = ?h x\<rbrakk>
              \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                                comm_monoid_add.sum plus zero ?h ?B\<close>)
      ["fundef_cong"]
  notes theorem
    "sum.cong_simp" =
      (\<open>\<lbrakk>?A = ?B;
               \<And>x. x \<in> ?B =simp=> ?g x = ?h x\<rbrakk>
              \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                                comm_monoid_add.sum plus zero ?h ?B\<close>)
      ["cong"]
  notes theorem
    "sum.reindex_cong" =
      \<open>\<lbrakk>inj_on ?l ?B; ?A = ?l ` ?B;
              \<And>x.
                 x \<in> ?B \<Longrightarrow> ?g (?l x) = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                               comm_monoid_add.sum plus zero ?h ?B\<close>
  notes theorem
    "sum.UNION_disjoint" =
      \<open>\<lbrakk>finite ?I; \<forall>i\<in>?I. finite (?A i);
              \<forall>i\<in>?I.
                 \<forall>j\<in>?I.
                    i \<noteq> j \<longrightarrow>
                    ?A i \<inter> ?A j = {}\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (\<Union> (?A ` ?I)) =
                               comm_monoid_add.sum plus zero
                                (\<lambda>x.
                                    comm_monoid_add.sum plus zero ?g (?A x))
                                ?I\<close>
  notes theorem
    "sum.Union_disjoint" =
      \<open>\<lbrakk>\<forall>A\<in>?C. finite A;
              \<forall>A\<in>?C.
                 \<forall>B\<in>?C.
                    A \<noteq> B \<longrightarrow>
                    A \<inter> B = {}\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (\<Union> ?C) =
                               (comm_monoid_add.sum plus zero \<circ>
                                comm_monoid_add.sum plus zero)
                                ?g ?C\<close>
  notes theorem
    "sum.distrib" =
      \<open>comm_monoid_add.sum plus zero (\<lambda>x. plus (?g x) (?h x))
              ?A =
             plus (comm_monoid_add.sum plus zero ?g ?A)
              (comm_monoid_add.sum plus zero ?h ?A)\<close>
  notes theorem
    "sum.Sigma" =
      \<open>\<lbrakk>finite ?A; \<forall>x\<in>?A. finite (?B x)\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero
                                (\<lambda>x.
                                    comm_monoid_add.sum plus zero (?g x)
                                     (?B x))
                                ?A =
                               comm_monoid_add.sum plus zero
                                (\<lambda>(x, y). ?g x y)
                                (Sigma ?A ?B)\<close>
  notes theorem
    "sum.related" =
      \<open>\<lbrakk>?R zero zero;
              \<forall>x1 y1 x2 y2.
                 ?R x1 x2 \<and> ?R y1 y2 \<longrightarrow>
                 ?R (plus x1 y1) (plus x2 y2);
              finite ?S; \<forall>x\<in>?S. ?R (?h x) (?g x)\<rbrakk>
             \<Longrightarrow> ?R (comm_monoid_add.sum plus zero ?h ?S)
                                (comm_monoid_add.sum plus zero ?g
                                  ?S)\<close>
  notes theorem
    "sum.mono_neutral_cong_left" =
      \<open>\<lbrakk>finite ?T; ?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?h i = zero;
              \<And>x. x \<in> ?S \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?S =
                               comm_monoid_add.sum plus zero ?h ?T\<close>
  notes theorem
    "sum.mono_neutral_cong_right" =
      \<open>\<lbrakk>finite ?T; ?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero;
              \<And>x. x \<in> ?S \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?T =
                               comm_monoid_add.sum plus zero ?h ?S\<close>
  notes theorem
    "sum.mono_neutral_left" =
      \<open>\<lbrakk>finite ?T; ?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?S =
                               comm_monoid_add.sum plus zero ?g ?T\<close>
  notes theorem
    "sum.mono_neutral_right" =
      \<open>\<lbrakk>finite ?T; ?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?T =
                               comm_monoid_add.sum plus zero ?g ?S\<close>
  notes theorem
    "sum.mono_neutral_cong" =
      \<open>\<lbrakk>finite ?T; finite ?S;
              \<And>i. i \<in> ?T - ?S \<Longrightarrow> ?h i = zero;
              \<And>i. i \<in> ?S - ?T \<Longrightarrow> ?g i = zero;
              \<And>x.
                 x \<in> ?S \<inter> ?T \<Longrightarrow>
                 ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?S =
                               comm_monoid_add.sum plus zero ?h ?T\<close>
  notes theorem
    "sum.reindex_bij_betw" =
      \<open>bij_betw ?h ?S ?T \<Longrightarrow>
             comm_monoid_add.sum plus zero (\<lambda>x. ?g (?h x)) ?S =
             comm_monoid_add.sum plus zero ?g ?T\<close>
  notes theorem
    "sum.reindex_bij_witness" =
      \<open>\<lbrakk>\<And>a. a \<in> ?S \<Longrightarrow> ?i (?j a) = a;
              \<And>a. a \<in> ?S \<Longrightarrow> ?j a \<in> ?T;
              \<And>b. b \<in> ?T \<Longrightarrow> ?j (?i b) = b;
              \<And>b. b \<in> ?T \<Longrightarrow> ?i b \<in> ?S;
              \<And>a.
                 a \<in> ?S \<Longrightarrow> ?h (?j a) = ?g a\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?S =
                               comm_monoid_add.sum plus zero ?h ?T\<close>
  notes theorem
    "sum.reindex_bij_betw_not_neutral" =
      \<open>\<lbrakk>finite ?S'; finite ?T';
              bij_betw ?h (?S - ?S') (?T - ?T');
              \<And>a. a \<in> ?S' \<Longrightarrow> ?g (?h a) = zero;
              \<And>b. b \<in> ?T' \<Longrightarrow> ?g b = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero
                                (\<lambda>x. ?g (?h x)) ?S =
                               comm_monoid_add.sum plus zero ?g ?T\<close>
  notes theorem
    "sum.reindex_nontrivial" =
      \<open>\<lbrakk>finite ?A;
              \<And>x y.
                 \<lbrakk>x \<in> ?A; y \<in> ?A; x \<noteq> y;
                  ?h x = ?h y\<rbrakk>
                 \<Longrightarrow> ?g (?h x) = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g (?h ` ?A) =
                               comm_monoid_add.sum plus zero (?g \<circ> ?h)
                                ?A\<close>
  notes theorem
    "sum.reindex_bij_witness_not_neutral" =
      \<open>\<lbrakk>finite ?S'; finite ?T';
              \<And>a. a \<in> ?S - ?S' \<Longrightarrow> ?i (?j a) = a;
              \<And>a.
                 a \<in> ?S - ?S' \<Longrightarrow> ?j a \<in> ?T - ?T';
              \<And>b. b \<in> ?T - ?T' \<Longrightarrow> ?j (?i b) = b;
              \<And>b.
                 b \<in> ?T - ?T' \<Longrightarrow> ?i b \<in> ?S - ?S';
              \<And>a. a \<in> ?S' \<Longrightarrow> ?g a = zero;
              \<And>b. b \<in> ?T' \<Longrightarrow> ?h b = zero;
              \<And>a.
                 a \<in> ?S \<Longrightarrow> ?h (?j a) = ?g a\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?S =
                               comm_monoid_add.sum plus zero ?h ?T\<close>
  notes theorem
    "sum.delta_remove" =
      \<open>finite ?S \<Longrightarrow>
             comm_monoid_add.sum plus zero
              (\<lambda>k. if k = ?a then ?b k else ?c k) ?S =
             (if ?a \<in> ?S
              then plus (?b ?a)
                    (comm_monoid_add.sum plus zero ?c (?S - {?a}))
              else comm_monoid_add.sum plus zero ?c (?S - {?a}))\<close>
  notes theorem
    "sum.delta" =
      (\<open>finite ?S \<Longrightarrow>
              comm_monoid_add.sum plus zero
               (\<lambda>k. if k = ?a then ?b k else zero) ?S =
              (if ?a \<in> ?S then ?b ?a else zero)\<close>)
      ["simp"]
  notes theorem
    "sum.delta'" =
      (\<open>finite ?S \<Longrightarrow>
              comm_monoid_add.sum plus zero
               (\<lambda>k. if ?a = k then ?b k else zero) ?S =
              (if ?a \<in> ?S then ?b ?a else zero)\<close>)
      ["simp"]
  notes theorem
    "sum.If_cases" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero
              (\<lambda>x. if ?P x then ?h x else ?g x) ?A =
             plus (comm_monoid_add.sum plus zero ?h (?A \<inter> {x. ?P x}))
              (comm_monoid_add.sum plus zero ?g
                (?A \<inter> - {x. ?P x}))\<close>
  notes theorem
    "sum.cartesian_product" =
      \<open>comm_monoid_add.sum plus zero
              (\<lambda>x. comm_monoid_add.sum plus zero (?g x) ?B) ?A =
             comm_monoid_add.sum plus zero (\<lambda>(x, y). ?g x y)
              (?A \<times> ?B)\<close>
  notes theorem
    "sum.inter_restrict" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (?A \<inter> ?B) =
             comm_monoid_add.sum plus zero
              (\<lambda>x. if x \<in> ?B then ?g x else zero) ?A\<close>
  notes theorem
    "sum.inter_filter" =
      \<open>finite ?A \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {x \<in> ?A. ?P x} =
             comm_monoid_add.sum plus zero
              (\<lambda>x. if ?P x then ?g x else zero) ?A\<close>
  notes theorem
    "sum.Union_comp" =
      \<open>\<lbrakk>\<forall>A\<in>?B. finite A;
              \<And>A1 A2 x.
                 \<lbrakk>A1 \<in> ?B; A2 \<in> ?B; A1 \<noteq> A2;
                  x \<in> A1; x \<in> A2\<rbrakk>
                 \<Longrightarrow> ?g x = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (\<Union> ?B) =
                               (comm_monoid_add.sum plus zero \<circ>
                                comm_monoid_add.sum plus zero)
                                ?g ?B\<close>
  notes theorem
    "sum.swap" =
      \<open>comm_monoid_add.sum plus zero
              (\<lambda>i. comm_monoid_add.sum plus zero (?g i) ?B) ?A =
             comm_monoid_add.sum plus zero
              (\<lambda>j.
                  comm_monoid_add.sum plus zero (\<lambda>i. ?g i j) ?A)
              ?B\<close>
  notes theorem
    "sum.swap_restrict" =
      \<open>\<lbrakk>finite ?A; finite ?B\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero
                                (\<lambda>x.
                                    comm_monoid_add.sum plus zero (?g x)
                                     {y \<in> ?B. ?R x y})
                                ?A =
                               comm_monoid_add.sum plus zero
                                (\<lambda>y.
                                    comm_monoid_add.sum plus zero
                                     (\<lambda>x. ?g x y)
                                     {x \<in> ?A. ?R x y})
                                ?B\<close>
  notes theorem
    "sum.image_gen" =
      \<open>finite ?S \<Longrightarrow>
             comm_monoid_add.sum plus zero ?h ?S =
             comm_monoid_add.sum plus zero
              (\<lambda>y.
                  comm_monoid_add.sum plus zero ?h {x \<in> ?S. ?g x = y})
              (?g ` ?S)\<close>
  notes theorem
    "sum.group" =
      \<open>\<lbrakk>finite ?S; finite ?T; ?g ` ?S \<subseteq> ?T\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero
                                (\<lambda>y.
                                    comm_monoid_add.sum plus zero ?h
                                     {x \<in> ?S. ?g x = y})
                                ?T =
                               comm_monoid_add.sum plus zero ?h ?S\<close>
  notes theorem
    "sum.Plus" =
      \<open>\<lbrakk>finite ?A; finite ?B\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g
                                (?A <+> ?B) =
                               plus
                                (comm_monoid_add.sum plus zero
                                  (?g \<circ> Inl) ?A)
                                (comm_monoid_add.sum plus zero
                                  (?g \<circ> Inr) ?B)\<close>
  notes theorem
    "sum.same_carrier" =
      \<open>\<lbrakk>finite ?C; ?A \<subseteq> ?C; ?B \<subseteq> ?C;
              \<And>a. a \<in> ?C - ?A \<Longrightarrow> ?g a = zero;
              \<And>b.
                 b \<in> ?C - ?B \<Longrightarrow> ?h b = zero\<rbrakk>
             \<Longrightarrow> (comm_monoid_add.sum plus zero ?g ?A =
                                comm_monoid_add.sum plus zero ?h ?B) =
                               (comm_monoid_add.sum plus zero ?g ?C =
                                comm_monoid_add.sum plus zero ?h ?C)\<close>
  notes theorem
    "sum.same_carrierI" =
      \<open>\<lbrakk>finite ?C; ?A \<subseteq> ?C; ?B \<subseteq> ?C;
              \<And>a. a \<in> ?C - ?A \<Longrightarrow> ?g a = zero;
              \<And>b. b \<in> ?C - ?B \<Longrightarrow> ?h b = zero;
              comm_monoid_add.sum plus zero ?g ?C =
              comm_monoid_add.sum plus zero ?h ?C\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g ?A =
                               comm_monoid_add.sum plus zero ?h ?B\<close>
  notes theorem
    "sum.eq_general" =
      \<open>\<lbrakk>\<And>y.
                         y \<in> ?B \<Longrightarrow>
                         \<exists>!x. x \<in> ?A \<and> ?h x = y;
              \<And>x.
                 x \<in> ?A \<Longrightarrow>
                 ?h x \<in> ?B \<and> ?\<gamma> (?h x) = ?\<phi> x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?\<phi> ?A =
                               comm_monoid_add.sum plus zero ?\<gamma>
                                ?B\<close>
  notes theorem
    "sum.eq_general_inverses" =
      \<open>\<lbrakk>\<And>y.
                         y \<in> ?B \<Longrightarrow>
                         ?k y \<in> ?A \<and> ?h (?k y) = y;
              \<And>x.
                 x \<in> ?A \<Longrightarrow>
                 ?h x \<in> ?B \<and>
                 ?k (?h x) = x \<and> ?\<gamma> (?h x) = ?\<phi> x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?\<phi> ?A =
                               comm_monoid_add.sum plus zero ?\<gamma>
                                ?B\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum.G_def" =
      \<open>comm_monoid_add.sum' plus zero ?p ?I \<equiv>
             if finite {x \<in> ?I. ?p x \<noteq> zero}
             then comm_monoid_add.sum plus zero ?p
                   {x \<in> ?I. ?p x \<noteq> zero}
             else zero\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "sum.finite_Collect_op" =
      \<open>\<lbrakk>finite {i \<in> ?I. ?x i \<noteq> zero};
              finite {i \<in> ?I. ?y i \<noteq> zero}\<rbrakk>
             \<Longrightarrow> finite
                                {i \<in> ?I.
                                 plus (?x i) (?y i) \<noteq> zero}\<close>
  notes theorem
    "sum.empty'" =
      (\<open>comm_monoid_add.sum' plus zero ?p {} = zero\<close>) ["simp"]
  notes theorem
    "sum.eq_sum" =
      (\<open>finite ?I \<Longrightarrow>
              comm_monoid_add.sum' plus zero ?p ?I =
              comm_monoid_add.sum plus zero ?p ?I\<close>)
      ["simp"]
  notes theorem
    "sum.insert'" =
      (\<open>finite {x \<in> ?I. ?p x \<noteq> zero} \<Longrightarrow>
              comm_monoid_add.sum' plus zero ?p (insert ?i ?I) =
              (if ?i \<in> ?I then comm_monoid_add.sum' plus zero ?p ?I
               else plus (?p ?i)
                     (comm_monoid_add.sum' plus zero ?p ?I))\<close>)
      ["simp"]
  notes theorem
    "sum.distrib_triv'" =
      \<open>finite ?I \<Longrightarrow>
             comm_monoid_add.sum' plus zero (\<lambda>i. plus (?g i) (?h i))
              ?I =
             plus (comm_monoid_add.sum' plus zero ?g ?I)
              (comm_monoid_add.sum' plus zero ?h ?I)\<close>
  notes theorem
    "sum.non_neutral'" =
      \<open>comm_monoid_add.sum' plus zero ?g
              {x \<in> ?I. ?g x \<noteq> zero} =
             comm_monoid_add.sum' plus zero ?g ?I\<close>
  notes theorem
    "sum.distrib'" =
      \<open>\<lbrakk>finite {x \<in> ?I. ?g x \<noteq> zero};
              finite {x \<in> ?I. ?h x \<noteq> zero}\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero
                                (\<lambda>i. plus (?g i) (?h i)) ?I =
                               plus (comm_monoid_add.sum' plus zero ?g ?I)
                                (comm_monoid_add.sum' plus zero ?h
                                  ?I)\<close>
  notes theorem
    "sum.cong'" =
      \<open>\<lbrakk>?A = ?B;
              \<And>x. x \<in> ?B \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero ?g ?A =
                               comm_monoid_add.sum' plus zero ?h ?B\<close>
  notes theorem
    "sum.mono_neutral_cong_left'" =
      \<open>\<lbrakk>?S \<subseteq> ?T;
              \<And>i. i \<in> ?T - ?S \<Longrightarrow> ?h i = zero;
              \<And>x. x \<in> ?S \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero ?g ?S =
                               comm_monoid_add.sum' plus zero ?h ?T\<close>
  notes theorem
    "sum.mono_neutral_cong_right'" =
      \<open>\<lbrakk>?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero;
              \<And>x. x \<in> ?S \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero ?g ?T =
                               comm_monoid_add.sum' plus zero ?h ?S\<close>
  notes theorem
    "sum.mono_neutral_left'" =
      \<open>\<lbrakk>?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero ?g ?S =
                               comm_monoid_add.sum' plus zero ?g ?T\<close>
  notes theorem
    "sum.mono_neutral_right'" =
      \<open>\<lbrakk>?S \<subseteq> ?T;
              \<forall>i\<in>?T - ?S. ?g i = zero\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum' plus zero ?g ?T =
                               comm_monoid_add.sum' plus zero ?g ?S\<close>
  notes theorem
    "sum.atLeastLessThan_reindex" =
      \<open>bij_betw ?h {?m..<?n} {?h ?m..<?h ?n} \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?h ?m..<?h ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> ?h) {?m..<?n}\<close>
  notes theorem
    "sum.atLeastAtMost_reindex" =
      \<open>bij_betw ?h {?m..?n} {?h ?m..?h ?n} \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?h ?m..?h ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> ?h) {?m..?n}\<close>
  notes theorem
    "sum.atLeastLessThan_shift_bounds" =
      \<open>comm_monoid_add.sum plus zero ?g {?m + ?k..<?n + ?k} =
             comm_monoid_add.sum plus zero (?g \<circ> (+) ?k)
              {?m..<?n}\<close>
  notes theorem
    "sum.atLeastAtMost_shift_bounds" =
      \<open>comm_monoid_add.sum plus zero ?g {?m + ?k..?n + ?k} =
             comm_monoid_add.sum plus zero (?g \<circ> (+) ?k)
              {?m..?n}\<close>
  notes theorem
    "sum.atLeast_Suc_lessThan_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {Suc ?m..<Suc ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> Suc)
              {?m..<?n}\<close>
  notes theorem
    "sum.atLeast_Suc_atMost_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {Suc ?m..Suc ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> Suc) {?m..?n}\<close>
  notes theorem
    "sum.atLeast_int_lessThan_int_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {int ?m..<int ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> int)
              {?m..<?n}\<close>
  notes theorem
    "sum.atLeast_int_atMost_int_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {int ?m..int ?n} =
             comm_monoid_add.sum plus zero (?g \<circ> int) {?m..?n}\<close>
  notes theorem
    "sum.atLeast0_lessThan_Suc" =
      \<open>comm_monoid_add.sum plus zero ?g {0..<Suc ?n} =
             plus (comm_monoid_add.sum plus zero ?g {0..<?n})
              (?g ?n)\<close>
  notes theorem
    "sum.atLeast0_atMost_Suc" =
      \<open>comm_monoid_add.sum plus zero ?g {0..Suc ?n} =
             plus (comm_monoid_add.sum plus zero ?g {0..?n})
              (?g (Suc ?n))\<close>
  notes theorem
    "sum.atLeast0_lessThan_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {0..<Suc ?n} =
             plus (?g 0)
              (comm_monoid_add.sum plus zero (?g \<circ> Suc)
                {0..<?n})\<close>
  notes theorem
    "sum.atLeast0_atMost_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {0..Suc ?n} =
             plus (?g 0)
              (comm_monoid_add.sum plus zero (?g \<circ> Suc)
                {0..?n})\<close>
  notes theorem
    "sum.atLeast_Suc_lessThan" =
      \<open>?m < ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..<?n} =
             plus (?g ?m)
              (comm_monoid_add.sum plus zero ?g {Suc ?m..<?n})\<close>
  notes theorem
    "sum.atLeast_Suc_atMost" =
      \<open>?m \<le> ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..?n} =
             plus (?g ?m)
              (comm_monoid_add.sum plus zero ?g {Suc ?m..?n})\<close>
  notes theorem
    "sum.ivl_cong" =
      \<open>\<lbrakk>?a = ?c; ?b = ?d;
              \<And>x.
                 \<lbrakk>?c \<le> x; x < ?d\<rbrakk>
                 \<Longrightarrow> ?g x = ?h x\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero ?g {?a..<?b} =
                               comm_monoid_add.sum plus zero ?h
                                {?c..<?d}\<close>
  notes theorem
    "sum.atLeastLessThan_shift_0" =
      \<open>comm_monoid_add.sum plus zero ?g {?m..<?n} =
             comm_monoid_add.sum plus zero (?g \<circ> (+) ?m)
              {0..<?n - ?m}\<close>
  notes theorem
    "sum.atLeastAtMost_shift_0" =
      \<open>?m \<le> ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..?n} =
             comm_monoid_add.sum plus zero (?g \<circ> (+) ?m)
              {0..?n - ?m}\<close>
  notes theorem
    "sum.atLeastLessThan_concat" =
      \<open>\<lbrakk>?m \<le> ?n; ?n \<le> ?p\<rbrakk>
             \<Longrightarrow> plus
                                (comm_monoid_add.sum plus zero ?g {?m..<?n})
                                (comm_monoid_add.sum plus zero ?g
                                  {?n..<?p}) =
                               comm_monoid_add.sum plus zero ?g
                                {?m..<?p}\<close>
  notes theorem
    "sum.atLeastLessThan_rev" =
      \<open>comm_monoid_add.sum plus zero ?g {?n..<?m} =
             comm_monoid_add.sum plus zero
              (\<lambda>i. ?g (?m + ?n - Suc i)) {?n..<?m}\<close>
  notes theorem
    "sum.atLeastAtMost_rev" =
      \<open>comm_monoid_add.sum plus zero ?g {?n..?m} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (?m + ?n - i))
              {?n..?m}\<close>
  notes theorem
    "sum.atLeastLessThan_rev_at_least_Suc_atMost" =
      \<open>comm_monoid_add.sum plus zero ?g {?n..<?m} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (?m + ?n - i))
              {Suc ?n..?m}\<close>
  notes theorem
    "sum.zero_middle" =
      \<open>\<lbrakk>1 \<le> ?p; ?k \<le> ?p\<rbrakk>
             \<Longrightarrow> comm_monoid_add.sum plus zero
                                (\<lambda>j.
                                    if j < ?k then ?g j
                                    else if j = ?k then zero
   else ?h (j - Suc 0))
                                {..?p} =
                               comm_monoid_add.sum plus zero
                                (\<lambda>j. if j < ?k then ?g j else ?h j)
                                {..?p - Suc 0}\<close>
  notes theorem
    "sum.atMost_Suc" =
      (\<open>comm_monoid_add.sum plus zero ?g {..Suc ?n} =
              plus (comm_monoid_add.sum plus zero ?g {..?n})
               (?g (Suc ?n))\<close>)
      ["simp"]
  notes theorem
    "sum.lessThan_Suc" =
      (\<open>comm_monoid_add.sum plus zero ?g {..<Suc ?n} =
              plus (comm_monoid_add.sum plus zero ?g {..<?n})
               (?g ?n)\<close>)
      ["simp"]
  notes theorem
    "sum.cl_ivl_Suc" =
      (\<open>comm_monoid_add.sum plus zero ?g {?m..Suc ?n} =
              (if Suc ?n < ?m then zero
               else plus (comm_monoid_add.sum plus zero ?g {?m..?n})
                     (?g (Suc ?n)))\<close>)
      ["simp"]
  notes theorem
    "sum.op_ivl_Suc" =
      (\<open>comm_monoid_add.sum plus zero ?g {?m..<Suc ?n} =
              (if ?n < ?m then zero
               else plus (comm_monoid_add.sum plus zero ?g {?m..<?n})
                     (?g ?n))\<close>)
      ["simp"]
  notes theorem
    "sum.head" =
      \<open>?m \<le> ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..?n} =
             plus (?g ?m)
              (comm_monoid_add.sum plus zero ?g {?m<..?n})\<close>
  notes theorem
    "sum.ub_add_nat" =
      \<open>?m \<le> ?n + 1 \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..?n + ?p} =
             plus (comm_monoid_add.sum plus zero ?g {?m..?n})
              (comm_monoid_add.sum plus zero ?g {?n + 1..?n + ?p})\<close>
  notes theorem
    "sum.nat_group" =
      \<open>comm_monoid_add.sum plus zero
              (\<lambda>m.
                  comm_monoid_add.sum plus zero ?g {m * ?k..<m * ?k + ?k})
              {..<?n} =
             comm_monoid_add.sum plus zero ?g {..<?n * ?k}\<close>
  notes theorem
    "sum.triangle_reindex" =
      \<open>comm_monoid_add.sum plus zero (\<lambda>(i, j). ?g i j)
              {(i, j). i + j < ?n} =
             comm_monoid_add.sum plus zero
              (\<lambda>k.
                  comm_monoid_add.sum plus zero (\<lambda>i. ?g i (k - i))
                   {..k})
              {..<?n}\<close>
  notes theorem
    "sum.triangle_reindex_eq" =
      \<open>comm_monoid_add.sum plus zero (\<lambda>(i, j). ?g i j)
              {(i, j). i + j \<le> ?n} =
             comm_monoid_add.sum plus zero
              (\<lambda>k.
                  comm_monoid_add.sum plus zero (\<lambda>i. ?g i (k - i))
                   {..k})
              {..?n}\<close>
  notes theorem
    "sum.nat_diff_reindex" =
      \<open>comm_monoid_add.sum plus zero (\<lambda>i. ?g (?n - Suc i))
              {..<?n} =
             comm_monoid_add.sum plus zero ?g {..<?n}\<close>
  notes theorem
    "sum.shift_bounds_nat_ivl" =
      \<open>comm_monoid_add.sum plus zero ?g {?m + ?k..<?n + ?k} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (i + ?k))
              {?m..<?n}\<close>
  notes theorem
    "sum.shift_bounds_cl_nat_ivl" =
      \<open>comm_monoid_add.sum plus zero ?g {?m + ?k..?n + ?k} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (i + ?k))
              {?m..?n}\<close>
  notes theorem
    "sum.shift_bounds_cl_Suc_ivl" =
      \<open>comm_monoid_add.sum plus zero ?g {Suc ?m..Suc ?n} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
              {?m..?n}\<close>
  notes theorem
    "sum.Suc_reindex_ivl" =
      \<open>?m \<le> ?n \<Longrightarrow>
             plus (comm_monoid_add.sum plus zero ?g {?m..?n})
              (?g (Suc ?n)) =
             plus (?g ?m)
              (comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
                {?m..?n})\<close>
  notes theorem
    "sum.shift_bounds_Suc_ivl" =
      \<open>comm_monoid_add.sum plus zero ?g {Suc ?m..<Suc ?n} =
             comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
              {?m..<?n}\<close>
  notes theorem
    "sum.atMost_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {..Suc ?n} =
             plus (?g 0)
              (comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
                {..?n})\<close>
  notes theorem
    "sum.lessThan_Suc_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {..<Suc ?n} =
             plus (?g 0)
              (comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
                {..<?n})\<close>
  notes theorem
    "sum.atMost_shift" =
      \<open>comm_monoid_add.sum plus zero ?g {..?n} =
             plus (?g 0)
              (comm_monoid_add.sum plus zero (\<lambda>i. ?g (Suc i))
                {..<?n})\<close>
  notes theorem
    "sum.last_plus" =
      \<open>?m \<le> ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..?n} =
             plus (?g ?n)
              (comm_monoid_add.sum plus zero ?g {?m..<?n})\<close>
  notes theorem
    "sum.nested_swap" =
      \<open>comm_monoid_add.sum plus zero
              (\<lambda>i. comm_monoid_add.sum plus zero (?a i) {0..<i})
              {0..?n} =
             comm_monoid_add.sum plus zero
              (\<lambda>j.
                  comm_monoid_add.sum plus zero (\<lambda>i. ?a i j)
                   {Suc j..?n})
              {0..<?n}\<close>
  notes theorem
    "sum.nested_swap'" =
      \<open>comm_monoid_add.sum plus zero
              (\<lambda>i. comm_monoid_add.sum plus zero (?a i) {..<i})
              {..?n} =
             comm_monoid_add.sum plus zero
              (\<lambda>j.
                  comm_monoid_add.sum plus zero (\<lambda>i. ?a i j)
                   {Suc j..?n})
              {..<?n}\<close>
  notes theorem
    "sum.atLeast1_atMost_eq" =
      \<open>comm_monoid_add.sum plus zero ?g {Suc 0..?n} =
             comm_monoid_add.sum plus zero (\<lambda>k. ?g (Suc k))
              {..<?n}\<close>
  notes theorem
    "sum.atLeastLessThan_Suc" =
      \<open>?a \<le> ?b \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?a..<Suc ?b} =
             plus (comm_monoid_add.sum plus zero ?g {?a..<?b})
              (?g ?b)\<close>
  notes theorem
    "sum.nat_ivl_Suc'" =
      \<open>?m \<le> Suc ?n \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g {?m..Suc ?n} =
             plus (?g (Suc ?n))
              (comm_monoid_add.sum plus zero ?g {?m..?n})\<close>
  notes theorem
    "sum.in_pairs" =
      \<open>comm_monoid_add.sum plus zero ?g {2 * ?m..Suc (2 * ?n)} =
             comm_monoid_add.sum plus zero
              (\<lambda>i. plus (?g (2 * i)) (?g (Suc (2 * i))))
              {?m..?n}\<close>
  notes theorem
    "sum.in_pairs_0" =
      \<open>comm_monoid_add.sum plus zero ?g {..Suc (2 * ?n)} =
             comm_monoid_add.sum plus zero
              (\<lambda>i. plus (?g (2 * i)) (?g (Suc (2 * i))))
              {..?n}\<close>
  notes theorem
    "sum.F_parametric" =
      (\<open>bi_unique ?A \<Longrightarrow>
              rel_fun (rel_fun ?A (=)) (rel_fun (rel_set ?A) (=))
               (comm_monoid_add.sum plus zero)
               (comm_monoid_add.sum plus zero)\<close>)
      ["transfer_rule"]
  notes
    "sum_list.comm_monoid_list_axioms" =
      (\<open>comm_monoid_list plus zero\<close>)
      ["attribute" "<attribute>"]
  notes theorem
    "sum_list.rev" =
      (\<open>monoid_add.sum_list plus zero (rev ?xs) =
              monoid_add.sum_list plus zero ?xs\<close>)
      ["simp"]
  notes
    "sum.comm_monoid_list_set_axioms" =
      (\<open>comm_monoid_list_set plus zero\<close>)
      ["attribute" "<attribute>"]
  notes theorem
    "sum.distinct_set_conv_list" =
      \<open>distinct ?xs \<Longrightarrow>
             comm_monoid_add.sum plus zero ?g (set ?xs) =
             monoid_add.sum_list plus zero (map ?g ?xs)\<close>
  notes theorem
    "sum.set_conv_list" =
      (\<open>comm_monoid_add.sum plus zero ?g (set ?xs) =
              monoid_add.sum_list plus zero (map ?g (remdups ?xs))\<close>)
      ["code"]
  notes
    "comm_monoid_add_axioms" =
      (\<open>class.comm_monoid_add plus zero\<close>)
      ["attribute" "<attribute>"]
  notes "add_0" = \<open>plus zero ?a = ?a\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum_def" =
      \<open>comm_monoid_add.sum plus zero \<equiv>
             comm_monoid_set.F plus zero\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "sum'_def" =
      \<open>comm_monoid_add.sum' plus zero \<equiv>
             comm_monoid_set.G plus zero\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "sum_shift_lb_Suc0_0_upt" =
      \<open>?f 0 = zero \<Longrightarrow>
             comm_monoid_add.sum plus zero ?f {Suc 0..<?k} =
             comm_monoid_add.sum plus zero ?f {0..<?k}\<close>
  notes theorem
    "sum_shift_lb_Suc0_0" =
      \<open>?f 0 = zero \<Longrightarrow>
             comm_monoid_add.sum plus zero ?f {Suc 0..?k} =
             comm_monoid_add.sum plus zero ?f {0..?k}\<close>
  notes theorem
    "sum_list_map_remove1" =
      \<open>?x \<in> set ?xs \<Longrightarrow>
             monoid_add.sum_list plus zero (map ?f ?xs) =
             plus (?f ?x)
              (monoid_add.sum_list plus zero
                (map ?f (remove1 ?x ?xs)))\<close>
  notes theorem
    "distinct_sum_list_conv_Sum" =
      \<open>distinct ?xs \<Longrightarrow>
             monoid_add.sum_list plus zero ?xs =
             comm_monoid_add.sum plus zero (\<lambda>x. x) (set ?xs)\<close>
  notes theorem
    "sum_list_addf" =
      \<open>monoid_add.sum_list plus zero
              (map (\<lambda>x. plus (?f x) (?g x)) ?xs) =
             plus (monoid_add.sum_list plus zero (map ?f ?xs))
              (monoid_add.sum_list plus zero (map ?g ?xs))\<close>
  notes
    "add.group_axioms" = (\<open>group plus zero uminus\<close>)
      ["attribute" "<attribute>"]
  notes "add.group_left_neutral" = \<open>plus zero ?a = ?a\<close>
  notes
    "add.left_inverse" = (\<open>plus (uminus ?a) ?a = zero\<close>)
      ["simp"]
  notes theorem
    "add.left_cancel" = \<open>(plus ?a ?b = plus ?a ?c) = (?b = ?c)\<close>
  notes theorem
    "add.inverse_unique" =
      \<open>plus ?a ?b = zero \<Longrightarrow> uminus ?a = ?b\<close>
  notes theorem
    "add.inverse_neutral" = (\<open>uminus zero = zero\<close>) ["simp"]
  notes theorem
    "add.inverse_inverse" = (\<open>uminus (uminus ?a) = ?a\<close>)
      ["simp"]
  notes theorem
    "add.right_inverse" = (\<open>plus ?a (uminus ?a) = zero\<close>)
      ["simp"]
  notes theorem
    "add.inverse_distrib_swap" =
      \<open>uminus (plus ?a ?b) = plus (uminus ?b) (uminus ?a)\<close>
  notes theorem
    "add.right_cancel" =
      \<open>(plus ?b ?a = plus ?c ?a) = (?b = ?c)\<close>
  notes
    "cancel_semigroup_add_axioms" =
      (\<open>class.cancel_semigroup_add plus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add_left_imp_eq" =
      \<open>plus ?a ?b = plus ?a ?c \<Longrightarrow> ?b = ?c\<close>
  notes
    "add_right_imp_eq" =
      \<open>plus ?b ?a = plus ?c ?a \<Longrightarrow> ?b = ?c\<close>
  notes theorem
    "add_left_cancel" =
      (\<open>(plus ?a ?b = plus ?a ?c) = (?b = ?c)\<close>) ["simp"]
  notes theorem
    "add_right_cancel" =
      (\<open>(plus ?b ?a = plus ?c ?a) = (?b = ?c)\<close>) ["simp"]
  notes theorem "inj_on_add" = (\<open>inj_on (plus ?a) ?A\<close>) ["simp"]
  notes theorem "inj_add_left" = \<open>inj (plus ?a)\<close>
  notes theorem
    "inj_on_add'" = (\<open>inj_on (\<lambda>b. plus b ?a) ?A\<close>)
      ["simp"]
  notes theorem
    "bij_betw_add" =
      (\<open>bij_betw (plus ?a) ?A ?B = (plus ?a ` ?A = ?B)\<close>)
      ["simp"]
  notes
    "group_add_axioms" =
      (\<open>class.group_add minus plus zero uminus\<close>)
      ["attribute" "<attribute>"]
  notes "left_minus" = \<open>plus (uminus ?a) ?a = zero\<close>
  notes
    "add_uminus_conv_diff" =
      (\<open>plus ?a (uminus ?b) = minus ?a ?b\<close>) ["simp"]
  notes theorem
    "diff_conv_add_uminus" =
      \<open>minus ?a ?b = plus ?a (uminus ?b)\<close>
  notes theorem
    "minus_unique" =
      \<open>plus ?a ?b = zero \<Longrightarrow> uminus ?a = ?b\<close>
  notes theorem "minus_zero" = \<open>uminus zero = zero\<close>
  notes theorem "minus_minus" = \<open>uminus (uminus ?a) = ?a\<close>
  notes theorem "right_minus" = \<open>plus ?a (uminus ?a) = zero\<close>
  notes theorem "diff_self" = (\<open>minus ?a ?a = zero\<close>) ["simp"]
  notes theorem
    "minus_add_cancel" = (\<open>plus (uminus ?a) (plus ?a ?b) = ?b\<close>)
      ["simp"]
  notes theorem
    "add_minus_cancel" = (\<open>plus ?a (plus (uminus ?a) ?b) = ?b\<close>)
      ["simp"]
  notes theorem
    "diff_add_cancel" = (\<open>plus (minus ?a ?b) ?b = ?a\<close>) ["simp"]
  notes theorem
    "add_diff_cancel" = (\<open>minus (plus ?a ?b) ?b = ?a\<close>) ["simp"]
  notes theorem
    "minus_add" =
      \<open>uminus (plus ?a ?b) = plus (uminus ?b) (uminus ?a)\<close>
  notes theorem
    "right_minus_eq" = (\<open>(minus ?a ?b = zero) = (?a = ?b)\<close>)
      ["simp"]
  notes theorem
    "eq_iff_diff_eq_0" = \<open>(?a = ?b) = (minus ?a ?b = zero)\<close>
  notes theorem
    "diff_0" = (\<open>minus zero ?a = uminus ?a\<close>) ["simp"]
  notes theorem
    "diff_0_right" = (\<open>minus ?a zero = ?a\<close>) ["simp"]
  notes theorem
    "diff_minus_eq_add" = (\<open>minus ?a (uminus ?b) = plus ?a ?b\<close>)
      ["simp"]
  notes theorem
    "neg_equal_iff_equal" =
      (\<open>(uminus ?a = uminus ?b) = (?a = ?b)\<close>) ["simp"]
  notes theorem
    "neg_equal_0_iff_equal" =
      (\<open>(uminus ?a = zero) = (?a = zero)\<close>) ["simp"]
  notes theorem
    "neg_0_equal_iff_equal" =
      (\<open>(zero = uminus ?a) = (zero = ?a)\<close>) ["simp"]
  notes theorem
    "equation_minus_iff" =
      \<open>(?a = uminus ?b) = (?b = uminus ?a)\<close>
  notes theorem
    "minus_equation_iff" =
      \<open>(uminus ?a = ?b) = (uminus ?b = ?a)\<close>
  notes theorem
    "eq_neg_iff_add_eq_0" =
      \<open>(?a = uminus ?b) = (plus ?a ?b = zero)\<close>
  notes theorem
    "add_eq_0_iff2" = \<open>(plus ?a ?b = zero) = (?a = uminus ?b)\<close>
  notes theorem
    "neg_eq_iff_add_eq_0" =
      \<open>(uminus ?a = ?b) = (plus ?a ?b = zero)\<close>
  notes theorem
    "add_eq_0_iff" = \<open>(plus ?a ?b = zero) = (?b = uminus ?a)\<close>
  notes theorem
    "minus_diff_eq" = (\<open>uminus (minus ?a ?b) = minus ?b ?a\<close>)
      ["simp"]
  notes theorem
    "add_diff_eq" =
      (\<open>plus ?a (minus ?b ?c) = minus (plus ?a ?b) ?c\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "diff_add_eq_diff_diff_swap" =
      \<open>minus ?a (plus ?b ?c) = minus (minus ?a ?c) ?b\<close>
  notes theorem
    "diff_eq_eq" = (\<open>(minus ?a ?b = ?c) = (?a = plus ?c ?b)\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "eq_diff_eq" = (\<open>(?a = minus ?c ?b) = (plus ?a ?b = ?c)\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "diff_diff_eq2" =
      (\<open>minus ?a (minus ?b ?c) = minus (plus ?a ?c) ?b\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "diff_eq_diff_eq" =
      \<open>minus ?a ?b = minus ?c ?d \<Longrightarrow>
             (?a = ?b) = (?c = ?d)\<close>
  notes theorem
    "minus_comp_minus" = (\<open>uminus \<circ> uminus = id\<close>)
      ["simp"]
  notes
    "cancel_ab_semigroup_add_axioms" =
      (\<open>class.cancel_ab_semigroup_add plus minus\<close>)
      ["attribute" "<attribute>"]
  notes
    "add_diff_cancel_left'" = (\<open>minus (plus ?a ?b) ?a = ?b\<close>)
      ["simp"]
  notes
    "diff_diff_add" =
      (\<open>minus (minus ?a ?b) ?c = minus ?a (plus ?b ?c)\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "add_diff_cancel_right'" = (\<open>minus (plus ?a ?b) ?b = ?a\<close>)
      ["simp"]
  notes theorem
    "add_diff_cancel_left" =
      (\<open>minus (plus ?c ?a) (plus ?c ?b) = minus ?a ?b\<close>)
      ["simp"]
  notes theorem
    "add_diff_cancel_right" =
      (\<open>minus (plus ?a ?c) (plus ?b ?c) = minus ?a ?b\<close>)
      ["simp"]
  notes theorem
    "diff_right_commute" =
      \<open>minus (minus ?a ?c) ?b = minus (minus ?a ?b) ?c\<close>
  notes
    "cancel_comm_monoid_add_axioms" =
      (\<open>class.cancel_comm_monoid_add plus minus zero\<close>)
      ["attribute" "<attribute>"]
  notes theorem "diff_zero" = (\<open>minus ?a zero = ?a\<close>) ["simp"]
  notes theorem "diff_cancel" = (\<open>minus ?a ?a = zero\<close>) ["simp"]
  notes theorem
    "add_implies_diff" =
      \<open>plus ?c ?b = ?a \<Longrightarrow> ?c = minus ?a ?b\<close>
  notes theorem
    "add_cancel_right_right" =
      (\<open>(?a = plus ?a ?b) = (?b = zero)\<close>) ["simp"]
  notes theorem
    "add_cancel_right_left" =
      (\<open>(?a = plus ?b ?a) = (?b = zero)\<close>) ["simp"]
  notes theorem
    "add_cancel_left_right" =
      (\<open>(plus ?a ?b = ?a) = (?b = zero)\<close>) ["simp"]
  notes theorem
    "add_cancel_left_left" =
      (\<open>(plus ?b ?a = ?a) = (?b = zero)\<close>) ["simp"]
  notes
    "ab_group_add_axioms" =
      (\<open>class.ab_group_add plus zero minus uminus\<close>)
      ["attribute" "<attribute>"]
  notes "ab_left_minus" = \<open>plus (uminus ?a) ?a = zero\<close>
  notes
    "ab_diff_conv_add_uminus" =
      \<open>minus ?a ?b = plus ?a (uminus ?b)\<close>
  notes theorem
    "uminus_add_conv_diff" =
      (\<open>plus (uminus ?a) ?b = minus ?b ?a\<close>) ["simp"]
  notes theorem
    "minus_add_distrib" =
      (\<open>uminus (plus ?a ?b) = plus (uminus ?a) (uminus ?b)\<close>)
      ["simp"]
  notes theorem
    "diff_add_eq" =
      (\<open>plus (minus ?a ?b) ?c = minus (plus ?a ?c) ?b\<close>)
      ["algebra_simps", "algebra_split_simps", "field_simps",
        "field_split_simps"]
  notes theorem
    "minus_diff_commute" =
      \<open>minus (uminus ?b) ?a = minus (uminus ?a) ?b\<close>
  notes theorem "surj_plus" = (\<open>surj (plus ?a)\<close>) ["simp"]
  notes theorem
    "inj_diff_right" = (\<open>inj (\<lambda>b. minus b ?a)\<close>)
      ["simp"]
  notes theorem
    "surj_diff_right" = (\<open>surj (\<lambda>x. minus x ?a)\<close>)
      ["simp"]
  notes theorem
    "translation_Compl" = \<open>plus ?a ` (- ?t) = - plus ?a ` ?t\<close>
  notes theorem
    "translation_subtract_Compl" =
      \<open>(\<lambda>x. minus x ?a) ` (- ?t) =
             - (\<lambda>x. minus x ?a) ` ?t\<close>
  notes theorem
    "translation_diff" =
      \<open>plus ?a ` (?s - ?t) = plus ?a ` ?s - plus ?a ` ?t\<close>
  notes theorem
    "translation_subtract_diff" =
      \<open>(\<lambda>x. minus x ?a) ` (?s - ?t) =
             (\<lambda>x. minus x ?a) ` ?s -
             (\<lambda>x. minus x ?a) ` ?t\<close>
  notes theorem
    "translation_Int" =
      \<open>plus ?a ` (?s \<inter> ?t) =
             plus ?a ` ?s \<inter> plus ?a ` ?t\<close>
  notes theorem
    "translation_subtract_Int" =
      \<open>(\<lambda>x. minus x ?a) ` (?s \<inter> ?t) =
             (\<lambda>x. minus x ?a) ` ?s \<inter>
             (\<lambda>x. minus x ?a) ` ?t\<close>
  notes theorem
    "uminus_sum_list_map" =
      \<open>uminus (monoid_add.sum_list plus zero (map ?f ?xs)) =
             monoid_add.sum_list plus zero
              (map (uminus \<circ> ?f) ?xs)\<close>
  notes theorem
    "sum_list_subtractf" =
      \<open>monoid_add.sum_list plus zero
              (map (\<lambda>x. minus (?f x) (?g x)) ?xs) =
             minus (monoid_add.sum_list plus zero (map ?f ?xs))
              (monoid_add.sum_list plus zero (map ?g ?xs))\<close>
locale module
  fixes
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
locale vector_space
  fixes
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "vector_space (*s)"
Enter MATCH
\<lambda>a b c d e f g h i j. i \<equiv>\<^sup>?
\<lambda>a b c d e f. ?Rha42
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg17
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf17
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl pls' mns' um' zero' scl'.
   ?a17 (?aa17 S pls mns um zero scl) (?ab17 S' pls' mns' um' zero' scl')
Enter MATCH
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg17
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf17
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl pls' mns' um' zero' scl'.
   ?a17 (?aa17 S pls mns um zero scl) (?ab17 S' pls' mns' um' zero' scl')
Enter MATCH
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf17
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl pls' mns' um' zero' scl'.
   ?a17 (?aa17 S pls mns um zero scl) (?ab17 S' pls' mns' um' zero' scl')
Enter MATCH
\<lambda>a b c d e f g h i j. i \<equiv>\<^sup>?
\<lambda>a b c d e f. ?Rha45
\<lambda>a b c d e f g h i j. j \<equiv>\<^sup>? \<lambda>a b c d e f. ?Rh44
### theory "HOL-Types_To_Sets.Linear_Algebra_On_With"
### 0.719s elapsed time, 2.314s cpu time, 0.540s GC time
Loading theory "HOL-Types_To_Sets.Linear_Algebra_On" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth" via "Smooth_Manifolds.Analysis_More")
\<lambda>a b c d e f g h i j. i \<equiv>\<^sup>?
\<lambda>a b c d e f. ?Rha44
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg19
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf19
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl b pls' mns' um' zero' scl' b'.
   ?a19 (?aa19 S pls mns um zero scl b)
    (?ab19 S' pls' mns' um' zero' scl' b')
Enter MATCH
\<lambda>a b c d e f g h i j. j \<equiv>\<^sup>? \<lambda>a b c d e f. ?Rh44
\<lambda>a b c d e f g h i j. i \<equiv>\<^sup>?
\<lambda>a b c d e f. ?Rha44
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg19
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf19
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl b pls' mns' um' zero' scl' b'.
   ?a19 (?aa19 S pls mns um zero scl b)
    (?ab19 S' pls' mns' um' zero' scl' b')
Enter MATCH
\<lambda>a b c d e f g h i j. i \<equiv>\<^sup>?
\<lambda>a b c d e f. ?Rha44
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg19
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf19
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl b pls' mns' um' zero' scl' b'.
   ?a19 (?aa19 S pls mns um zero scl b)
    (?ab19 S' pls' mns' um' zero' scl' b')
Enter MATCH
\<lambda>a b c d. rel_set C \<equiv>\<^sup>? \<lambda>a b c d. ?Rg19
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf19
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl b pls' mns' um' zero' scl' b'.
   ?a19 (?aa19 S pls mns um zero scl b)
    (?ab19 S' pls' mns' um' zero' scl' b')
Enter MATCH
\<lambda>a b. rel_set A \<equiv>\<^sup>? \<lambda>a b. ?Rf19
?x' \<equiv>\<^sup>?
\<lambda>S S' pls mns um zero scl b pls' mns' um' zero' scl' b'.
   ?a19 (?aa19 S pls mns um zero scl b)
    (?ab19 S' pls' mns' um' zero' scl' b')
locale module_on
  fixes S :: "'b set"
    and
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "module_on S (*s)"
locale module_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "module_pair_on S1 S2 scale1 scale2"
locale module_hom_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and
    s1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*a\<close> 75)
    and
    s2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
      (infixr \<open>*b\<close> 75)
    and f :: "'b \<Rightarrow> 'c"
  assumes "module_hom_on S1 S2 (*a) (*b) f"
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale vector_space_on
  fixes S :: "'b set"
    and
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "vector_space_on S (*s)"
locale linear_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and s1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and f :: "'b \<Rightarrow> 'c"
  assumes "linear_on S1 S2 s1 s2 f"
locale finite_dimensional_vector_space_on
  fixes S :: "'a set"
    and scale :: "'b \<Rightarrow> 'a \<Rightarrow> 'a"
    and basis :: "'a set"
  assumes "finite_dimensional_vector_space_on S scale basis"
locale vector_space_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "vector_space_pair_on S1 S2 scale1 scale2"
locale finite_dimensional_vector_space_pair_1_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and Basis1 :: "'b set"
  assumes
    "finite_dimensional_vector_space_pair_1_on S1 S2 scale1 scale2 Basis1"
locale finite_dimensional_vector_space_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and Basis1 :: "'b set"
    and Basis2 :: "'c set"
  assumes
    "finite_dimensional_vector_space_pair_on S1 S2 scale1 scale2 Basis1
      Basis2"
locale local_typedef_module_on
  fixes S :: "'b set"
    and scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s :: "'s itself"
  assumes "local_typedef_module_on TYPE('s) S scale"
### Rule already declared as introduction (intro)
### (\<And>x y. ?A x y \<Longrightarrow> ?B (?f x) (?g y)) \<Longrightarrow>
### (?A ===> ?B) ?f ?g
locale local_typedef_vector_space_on
  fixes S :: "'b set"
    and scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s :: "'s itself"
  assumes "local_typedef_vector_space_on TYPE('s) S scale"
locale local_typedef_finite_dimensional_vector_space_on
  fixes S :: "'b set"
    and scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and Basis :: "'b set"
    and s :: "'s itself"
  assumes
    "local_typedef_finite_dimensional_vector_space_on TYPE('s) S scale
      Basis"
locale local_typedef_module_pair
  fixes S1 :: "'b set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s :: "'s itself"
    and S2 :: "'c set"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and t :: "'t itself"
  assumes "local_typedef_module_pair TYPE('s) TYPE('t) S1 scale1 S2 scale2"
locale local_typedef_vector_space_pair
  fixes S1 :: "'b set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and s :: "'s itself"
    and S2 :: "'c set"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and t :: "'t itself"
  assumes
    "local_typedef_vector_space_pair TYPE('s) TYPE('t) S1 scale1 S2 scale2"
locale local_typedef_finite_dimensional_vector_space_pair_1
  fixes S1 :: "'b set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and Basis1 :: "'b set"
    and s :: "'s itself"
    and S2 :: "'c set"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and t :: "'t itself"
  assumes
    "local_typedef_finite_dimensional_vector_space_pair_1 TYPE('s) TYPE('t)
      S1 scale1 Basis1 S2 scale2"
locale local_typedef_finite_dimensional_vector_space_pair
  fixes S1 :: "'b set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and Basis1 :: "'b set"
    and s :: "'s itself"
    and S2 :: "'c set"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and Basis2 :: "'c set"
    and t :: "'t itself"
  assumes
    "local_typedef_finite_dimensional_vector_space_pair TYPE('s) TYPE('t) S1
      scale1 Basis1 S2 scale2 Basis2"
locale module_on
  fixes S :: "'b set"
    and
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "module_on S (*s)"
locale vector_space_on
  fixes S :: "'b set"
    and
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "vector_space_on S (*s)"
locale module
  fixes
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
  notes
    "module_axioms" = (\<open>module (*s)\<close>)
      ["attribute" "<attribute>"]
  notes
    "scale_right_distrib" =
      (\<open>?a *s (?x + ?y) = ?a *s ?x + ?a *s ?y\<close>)
      ["algebra_simps", "algebra_split_simps"]
  notes
    "scale_left_distrib" =
      (\<open>(?a + ?b) *s ?x = ?a *s ?x + ?b *s ?x\<close>)
      ["algebra_simps", "algebra_split_simps"]
  notes
    "scale_scale" = (\<open>?a *s ?b *s ?x = (?a * ?b) *s ?x\<close>)
      ["simp"]
  notes "scale_one" = (\<open>(1::'a) *s ?x = ?x\<close>) ["simp"]
  notes theorem
    "scale_left_commute" = \<open>?a *s ?b *s ?x = ?b *s ?a *s ?x\<close>
  notes theorem
    "scale_zero_left" = (\<open>(0::'a) *s ?x = (0::'b)\<close>) ["simp"]
  notes theorem
    "scale_minus_left" = (\<open>- ?a *s ?x = - (?a *s ?x)\<close>) ["simp"]
  notes theorem
    "scale_left_diff_distrib" =
      (\<open>(?a - ?b) *s ?x = ?a *s ?x - ?b *s ?x\<close>)
      ["algebra_simps", "algebra_split_simps"]
  notes theorem
    "scale_sum_left" =
      \<open>sum ?f ?A *s ?x = (\<Sum>a\<in>?A. ?f a *s ?x)\<close>
  notes theorem
    "scale_zero_right" = (\<open>?a *s (0::'b) = (0::'b)\<close>) ["simp"]
  notes theorem
    "scale_minus_right" = (\<open>?a *s - ?x = - (?a *s ?x)\<close>)
      ["simp"]
  notes theorem
    "scale_right_diff_distrib" =
      (\<open>?a *s (?x - ?y) = ?a *s ?x - ?a *s ?y\<close>)
      ["algebra_simps", "algebra_split_simps"]
  notes theorem
    "scale_sum_right" =
      \<open>?a *s sum ?f ?A = (\<Sum>x\<in>?A. ?a *s ?f x)\<close>
  notes theorem
    "sum_constant_scale" =
      \<open>(\<Sum>x\<in>?A. ?y) = of_nat (card ?A) *s ?y\<close>
  notes theorem
    "scale_left_distrib_NO_MATCH" =
      \<open>NO_MATCH (?x div ?y) ?c \<Longrightarrow>
             (?a + ?b) *s ?x = ?a *s ?x + ?b *s ?x\<close>
  notes theorem
    "scale_right_distrib_NO_MATCH" =
      \<open>NO_MATCH (?x div ?y) ?a \<Longrightarrow>
             ?a *s (?x + ?y) = ?a *s ?x + ?a *s ?y\<close>
  notes theorem
    "scale_left_diff_distrib_NO_MATCH" =
      \<open>NO_MATCH (?x div ?y) ?c \<Longrightarrow>
             (?a - ?b) *s ?x = ?a *s ?x - ?b *s ?x\<close>
  notes theorem
    "scale_right_diff_distrib_NO_MATCH" =
      \<open>NO_MATCH (?x div ?y) ?a \<Longrightarrow>
             ?a *s (?x - ?y) = ?a *s ?x - ?a *s ?y\<close>
  notes theorem
    (\<open>NO_MATCH (?x div ?y) ?c \<Longrightarrow>
            (?a + ?b) *s ?x = ?a *s ?x + ?b *s ?x\<close>)
      ["field_simps", "field_split_simps"]
      (\<open>NO_MATCH (?x div ?y) ?a \<Longrightarrow>
              ?a *s (?x + ?y) = ?a *s ?x + ?a *s ?y\<close>)
      ["field_simps", "field_split_simps"]
      (\<open>NO_MATCH (?x div ?y) ?c \<Longrightarrow>
              (?a - ?b) *s ?x = ?a *s ?x - ?b *s ?x\<close>)
      ["field_simps", "field_split_simps"]
      (\<open>NO_MATCH (?x div ?y) ?a \<Longrightarrow>
              ?a *s (?x - ?y) = ?a *s ?x - ?a *s ?y\<close>)
      ["field_simps", "field_split_simps"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "subspace_def" =
      \<open>local.subspace ?S =
             ((0::'b) \<in> ?S \<and>
              (\<forall>x\<in>?S. \<forall>y\<in>?S. x + y \<in> ?S) \<and>
              (\<forall>c. \<forall>x\<in>?S. c *s x \<in> ?S))\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "subspaceI" =
      \<open>\<lbrakk>(0::'b) \<in> ?S;
              \<And>x y.
                 \<lbrakk>x \<in> ?S; y \<in> ?S\<rbrakk>
                 \<Longrightarrow> x + y \<in> ?S;
              \<And>c x.
                 x \<in> ?S \<Longrightarrow> c *s x \<in> ?S\<rbrakk>
             \<Longrightarrow> local.subspace ?S\<close>
  notes theorem
    "subspace_UNIV" = (\<open>local.subspace UNIV\<close>) ["simp"]
  notes theorem
    "subspace_single_0" = (\<open>local.subspace {0::'b}\<close>) ["simp"]
  notes theorem
    "subspace_0" =
      \<open>local.subspace ?S \<Longrightarrow> (0::'b) \<in> ?S\<close>
  notes theorem
    "subspace_add" =
      \<open>\<lbrakk>local.subspace ?S; ?x \<in> ?S; ?y \<in> ?S\<rbrakk>
             \<Longrightarrow> ?x + ?y \<in> ?S\<close>
  notes theorem
    "subspace_scale" =
      \<open>\<lbrakk>local.subspace ?S; ?x \<in> ?S\<rbrakk>
             \<Longrightarrow> ?c *s ?x \<in> ?S\<close>
  notes theorem
    "subspace_neg" =
      \<open>\<lbrakk>local.subspace ?S; ?x \<in> ?S\<rbrakk>
             \<Longrightarrow> - ?x \<in> ?S\<close>
  notes theorem
    "subspace_diff" =
      \<open>\<lbrakk>local.subspace ?S; ?x \<in> ?S; ?y \<in> ?S\<rbrakk>
             \<Longrightarrow> ?x - ?y \<in> ?S\<close>
  notes theorem
    "subspace_sum" =
      \<open>\<lbrakk>local.subspace ?A;
              \<And>x. x \<in> ?B \<Longrightarrow> ?f x \<in> ?A\<rbrakk>
             \<Longrightarrow> sum ?f ?B \<in> ?A\<close>
  notes theorem
    "subspace_Int" =
      \<open>(\<And>i.
                 i \<in> ?I \<Longrightarrow>
                 local.subspace (?s i)) \<Longrightarrow>
             local.subspace (\<Inter> (?s ` ?I))\<close>
  notes theorem
    "subspace_Inter" =
      \<open>Ball ?f local.subspace \<Longrightarrow>
             local.subspace (\<Inter> ?f)\<close>
  notes theorem
    "subspace_inter" =
      \<open>\<lbrakk>local.subspace ?A; local.subspace ?B\<rbrakk>
             \<Longrightarrow> local.subspace (?A \<inter> ?B)\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "span_explicit" =
      \<open>local.span ?b =
             {\<Sum>a\<in>t. r a *s a |t r.
              finite t \<and> t \<subseteq> ?b}\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "span_explicit'" =
      \<open>local.span ?b =
             {\<Sum>v | f v \<noteq> (0::'a). f v *s v |f.
              finite {v. f v \<noteq> (0::'a)} \<and>
              (\<forall>v.
                  f v \<noteq> (0::'a) \<longrightarrow>
                  v \<in> ?b)}\<close>
  notes theorem
    "span_alt" =
      \<open>local.span ?B =
             {\<Sum>x | f x \<noteq> (0::'a). f x *s x |f.
              {x. f x \<noteq> (0::'a)} \<subseteq> ?B \<and>
              finite {x. f x \<noteq> (0::'a)}}\<close>
  notes theorem
    "span_finite" =
      \<open>finite ?S \<Longrightarrow>
             local.span ?S =
             range (\<lambda>u. \<Sum>v\<in>?S. u v *s v)\<close>
  notes theorem
    "span_induct_alt" =
      (\<open>\<lbrakk>?x \<in> local.span ?S; ?h (0::'b);
               \<And>c x y.
                  \<lbrakk>x \<in> ?S; ?h y\<rbrakk>
                  \<Longrightarrow> ?h (c *s x + y)\<rbrakk>
              \<Longrightarrow> ?h ?x\<close>)
      ["consumes" 1, "case_names" base step, "induct" set : local.span]
  notes theorem
    "span_mono" =
      \<open>?A \<subseteq> ?B \<Longrightarrow>
             local.span ?A \<subseteq> local.span ?B\<close>
  notes theorem
    "span_base" =
      \<open>?a \<in> ?S \<Longrightarrow> ?a \<in> local.span ?S\<close>
  notes theorem
    "span_superset" = \<open>?S \<subseteq> local.span ?S\<close>
  notes theorem "span_zero" = \<open>(0::'b) \<in> local.span ?S\<close>
  notes theorem
    "span_UNIV" = (\<open>local.span UNIV = UNIV\<close>) ["simp"]
  notes theorem
    "span_add" =
      \<open>\<lbrakk>?x \<in> local.span ?S;
              ?y \<in> local.span ?S\<rbrakk>
             \<Longrightarrow> ?x + ?y \<in> local.span ?S\<close>
  notes theorem
    "span_scale" =
      \<open>?x \<in> local.span ?S \<Longrightarrow>
             ?c *s ?x \<in> local.span ?S\<close>
  notes theorem
    "subspace_span" = (\<open>local.subspace (local.span ?S)\<close>)
      ["iff"]
  notes theorem
    "span_neg" =
      \<open>?x \<in> local.span ?S \<Longrightarrow>
             - ?x \<in> local.span ?S\<close>
  notes theorem
    "span_diff" =
      \<open>\<lbrakk>?x \<in> local.span ?S;
              ?y \<in> local.span ?S\<rbrakk>
             \<Longrightarrow> ?x - ?y \<in> local.span ?S\<close>
  notes theorem
    "span_sum" =
      \<open>(\<And>x.
                 x \<in> ?A \<Longrightarrow>
                 ?f x \<in> local.span ?S) \<Longrightarrow>
             sum ?f ?A \<in> local.span ?S\<close>
  notes theorem
    "span_minimal" =
      \<open>\<lbrakk>?S \<subseteq> ?T; local.subspace ?T\<rbrakk>
             \<Longrightarrow> local.span ?S \<subseteq> ?T\<close>
  notes theorem
    "span_def" = \<open>local.span ?S = local.subspace hull ?S\<close>
  notes theorem
    "span_unique" =
      \<open>\<lbrakk>?S \<subseteq> ?T; local.subspace ?T;
              \<And>T'.
                 \<lbrakk>?S \<subseteq> T'; local.subspace T'\<rbrakk>
                 \<Longrightarrow> ?T \<subseteq> T'\<rbrakk>
             \<Longrightarrow> local.span ?S = ?T\<close>
  notes theorem
    "span_subspace_induct" =
      (\<open>\<lbrakk>?x \<in> local.span ?S; local.subspace ?P;
               \<And>x. x \<in> ?S \<Longrightarrow> x \<in> ?P\<rbrakk>
              \<Longrightarrow> ?x \<in> ?P\<close>)
      ["consumes" 2]
  notes theorem
    "span_induct" =
      (\<open>\<lbrakk>?x \<in> local.span ?S; local.subspace (Collect ?P);
               \<And>x. x \<in> ?S \<Longrightarrow> ?P x\<rbrakk>
              \<Longrightarrow> ?P ?x\<close>)
      ["consumes" 1, "case_names" base step, "induct" set : local.span]
  notes theorem
    "span_empty" = (\<open>local.span {} = {0::'b}\<close>) ["simp"]
  notes theorem
    "span_subspace" =
      \<open>\<lbrakk>?A \<subseteq> ?B; ?B \<subseteq> local.span ?A;
              local.subspace ?B\<rbrakk>
             \<Longrightarrow> local.span ?A = ?B\<close>
  notes theorem
    "span_span" = \<open>local.span (local.span ?A) = local.span ?A\<close>
  notes theorem
    "span_add_eq" =
      \<open>?x \<in> local.span ?S \<Longrightarrow>
             (?x + ?y \<in> local.span ?S) =
             (?y \<in> local.span ?S)\<close>
  notes theorem
    "span_add_eq2" =
      \<open>?y \<in> local.span ?S \<Longrightarrow>
             (?x + ?y \<in> local.span ?S) =
             (?x \<in> local.span ?S)\<close>
  notes theorem
    "span_singleton" =
      \<open>local.span {?x} = range (\<lambda>k. k *s ?x)\<close>
  notes theorem
    "span_Un" =
      \<open>local.span (?S \<union> ?T) =
             {x + y |x y.
              x \<in> local.span ?S \<and> y \<in> local.span ?T}\<close>
  notes theorem
    "span_insert" =
      \<open>local.span (insert ?a ?S) =
             {x. \<exists>k. x - k *s ?a \<in> local.span ?S}\<close>
  notes theorem
    "span_breakdown" =
      \<open>\<lbrakk>?b \<in> ?S; ?a \<in> local.span ?S\<rbrakk>
             \<Longrightarrow> \<exists>k.
                                  ?a - k *s ?b
                                  \<in> local.span (?S - {?b})\<close>
  notes theorem
    "span_breakdown_eq" =
      \<open>(?x \<in> local.span (insert ?a ?S)) =
             (\<exists>k. ?x - k *s ?a \<in> local.span ?S)\<close>
  notes theorem
    "span_clauses" =
      \<open>?a \<in> ?S \<Longrightarrow> ?a \<in> local.span ?S\<close>
      \<open>(0::'b) \<in> local.span ?S\<close>
      \<open>\<lbrakk>?x \<in> local.span ?S;
              ?y \<in> local.span ?S\<rbrakk>
             \<Longrightarrow> ?x + ?y \<in> local.span ?S\<close>
      \<open>?x \<in> local.span ?S \<Longrightarrow>
             ?c *s ?x \<in> local.span ?S\<close>
  notes theorem
    "span_eq_iff" =
      (\<open>(local.span ?s = ?s) = local.subspace ?s\<close>) ["simp"]
  notes theorem
    "span_eq" =
      \<open>(local.span ?S = local.span ?T) =
             (?S \<subseteq> local.span ?T \<and>
              ?T \<subseteq> local.span ?S)\<close>
  notes theorem
    "eq_span_insert_eq" =
      \<open>?x - ?y \<in> local.span ?S \<Longrightarrow>
             local.span (insert ?x ?S) = local.span (insert ?y ?S)\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "dependent_explicit" =
      \<open>local.dependent ?s =
             (\<exists>t u.
                 finite t \<and>
                 t \<subseteq> ?s \<and>
                 (\<Sum>v\<in>t. u v *s v) = (0::'b) \<and>
                 (\<exists>v\<in>t. u v \<noteq> (0::'a)))\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "dependent_mono" =
      \<open>\<lbrakk>local.dependent ?B; ?B \<subseteq> ?A\<rbrakk>
             \<Longrightarrow> local.dependent ?A\<close>
  notes theorem
    "independent_mono" =
      \<open>\<lbrakk>local.independent ?A; ?B \<subseteq> ?A\<rbrakk>
             \<Longrightarrow> local.independent ?B\<close>
  notes theorem
    "dependent_zero" =
      \<open>(0::'b) \<in> ?A \<Longrightarrow> local.dependent ?A\<close>
  notes theorem
    "independent_empty" = (\<open>local.independent {}\<close>)
      ["HOL.intro"]
  notes theorem
    "independent_explicit_module" =
      \<open>local.independent ?s =
             (\<forall>t u v.
                 finite t \<longrightarrow>
                 t \<subseteq> ?s \<longrightarrow>
                 (\<Sum>v\<in>t. u v *s v) = (0::'b) \<longrightarrow>
                 v \<in> t \<longrightarrow> u v = (0::'a))\<close>
  notes theorem
    "independentD" =
      \<open>\<lbrakk>local.independent ?s; finite ?t; ?t \<subseteq> ?s;
              (\<Sum>v\<in>?t. ?u v *s v) = (0::'b); ?v \<in> ?t\<rbrakk>
             \<Longrightarrow> ?u ?v = (0::'a)\<close>
  notes theorem
    "independent_Union_directed" =
      \<open>\<lbrakk>\<And>c d.
                         \<lbrakk>c \<in> ?C; d \<in> ?C\<rbrakk>
                         \<Longrightarrow> c \<subseteq> d \<or>
     d \<subseteq> c;
              \<And>c.
                 c \<in> ?C \<Longrightarrow> local.independent c\<rbrakk>
             \<Longrightarrow> local.independent (\<Union> ?C)\<close>
  notes theorem
    "dependent_finite" =
      \<open>finite ?S \<Longrightarrow>
             local.dependent ?S =
             (\<exists>u.
                 (\<exists>v\<in>?S. u v \<noteq> (0::'a)) \<and>
                 (\<Sum>v\<in>?S. u v *s v) = (0::'b))\<close>
  notes theorem
    "dependent_alt" =
      \<open>local.dependent ?B =
             (\<exists>X.
                 finite {x. X x \<noteq> (0::'a)} \<and>
                 {x. X x \<noteq> (0::'a)} \<subseteq> ?B \<and>
                 (\<Sum>x | X x \<noteq> (0::'a). X x *s x) = (0::'b) \<and>
                 (\<exists>x. X x \<noteq> (0::'a)))\<close>
  notes theorem
    "independent_alt" =
      \<open>local.independent ?B =
             (\<forall>X.
                 finite {x. X x \<noteq> (0::'a)} \<longrightarrow>
                 {x. X x \<noteq> (0::'a)} \<subseteq> ?B \<longrightarrow>
                 (\<Sum>x | X x \<noteq> (0::'a). X x *s x) =
                 (0::'b) \<longrightarrow>
                 (\<forall>x. X x = (0::'a)))\<close>
  notes theorem
    "independentD_alt" =
      \<open>\<lbrakk>local.independent ?B;
              finite {x. ?X x \<noteq> (0::'a)};
              {x. ?X x \<noteq> (0::'a)} \<subseteq> ?B;
              (\<Sum>x | ?X x \<noteq> (0::'a). ?X x *s x) =
              (0::'b)\<rbrakk>
             \<Longrightarrow> ?X ?x = (0::'a)\<close>
  notes theorem
    "independentD_unique" =
      \<open>\<lbrakk>local.independent ?B;
              finite {x. ?X x \<noteq> (0::'a)};
              {x. ?X x \<noteq> (0::'a)} \<subseteq> ?B;
              finite {x. ?Y x \<noteq> (0::'a)};
              {x. ?Y x \<noteq> (0::'a)} \<subseteq> ?B;
              (\<Sum>x | ?X x \<noteq> (0::'a). ?X x *s x) =
              (\<Sum>x | ?Y x \<noteq> (0::'a). ?Y x *s x)\<rbrakk>
             \<Longrightarrow> ?X = ?Y\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "representation_def" =
      \<open>local.representation ?basis ?v =
             (if local.independent ?basis \<and> ?v \<in> local.span ?basis
              then SOME f.
                      (\<forall>v.
                          f v \<noteq> (0::'a) \<longrightarrow>
                          v \<in> ?basis) \<and>
                      finite {v. f v \<noteq> (0::'a)} \<and>
                      (\<Sum>v | f v \<noteq> (0::'a). f v *s v) = ?v
              else (\<lambda>b. 0::'a))\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes theorem
    "unique_representation" =
      \<open>\<lbrakk>local.independent ?basis;
              \<And>v.
                 ?f v \<noteq> (0::'a) \<Longrightarrow> v \<in> ?basis;
              \<And>v.
                 ?g v \<noteq> (0::'a) \<Longrightarrow> v \<in> ?basis;
              finite {v. ?f v \<noteq> (0::'a)};
              finite {v. ?g v \<noteq> (0::'a)};
              (\<Sum>v | ?f v \<noteq> (0::'a). ?f v *s v) =
              (\<Sum>v | ?g v \<noteq> (0::'a). ?g v *s v)\<rbrakk>
             \<Longrightarrow> ?f = ?g\<close>
  notes theorem
    "representation_ne_zero" =
      \<open>local.representation ?basis ?v ?b \<noteq>
             (0::'a) \<Longrightarrow>
             ?b \<in> ?basis\<close>
  notes theorem
    "finite_representation" =
      \<open>finite
              {b. local.representation ?basis ?v b \<noteq> (0::'a)}\<close>
  notes theorem
    "sum_nonzero_representation_eq" =
      \<open>\<lbrakk>local.independent ?basis;
              ?v \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> (\<Sum>b | local.representation ?basis ?v
     b \<noteq>
    (0::'a).
                                  local.representation ?basis ?v b *s b) =
                               ?v\<close>
  notes theorem
    "sum_representation_eq" =
      \<open>\<lbrakk>local.independent ?basis; ?v \<in> local.span ?basis;
              finite ?B; ?basis \<subseteq> ?B\<rbrakk>
             \<Longrightarrow> (\<Sum>b\<in>?B.
                                  local.representation ?basis ?v b *s b) =
                               ?v\<close>
  notes theorem
    "representation_eqI" =
      \<open>\<lbrakk>local.independent ?basis; ?v \<in> local.span ?basis;
              \<And>b.
                 ?f b \<noteq> (0::'a) \<Longrightarrow> b \<in> ?basis;
              finite {b. ?f b \<noteq> (0::'a)};
              (\<Sum>b | ?f b \<noteq> (0::'a). ?f b *s b) = ?v\<rbrakk>
             \<Longrightarrow> local.representation ?basis ?v = ?f\<close>
  notes theorem
    "representation_basis" =
      \<open>\<lbrakk>local.independent ?basis; ?b \<in> ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis ?b =
                               (\<lambda>v.
                                   if v = ?b then 1::'a
                                   else (0::'a))\<close>
  notes theorem
    "representation_zero" =
      \<open>local.representation ?basis (0::'b) =
             (\<lambda>b. 0::'a)\<close>
  notes theorem
    "representation_diff" =
      \<open>\<lbrakk>local.independent ?basis; ?v \<in> local.span ?basis;
              ?u \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis (?u - ?v) =
                               (\<lambda>b.
                                   local.representation ?basis ?u b -
                                   local.representation ?basis ?v b)\<close>
  notes theorem
    "representation_neg" =
      \<open>\<lbrakk>local.independent ?basis;
              ?v \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis (- ?v) =
                               (\<lambda>b.
                                   - local.representation ?basis ?v
b)\<close>
  notes theorem
    "representation_add" =
      \<open>\<lbrakk>local.independent ?basis; ?v \<in> local.span ?basis;
              ?u \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis (?u + ?v) =
                               (\<lambda>b.
                                   local.representation ?basis ?u b +
                                   local.representation ?basis ?v b)\<close>
  notes theorem
    "representation_sum" =
      \<open>\<lbrakk>local.independent ?basis;
              \<And>i.
                 i \<in> ?I \<Longrightarrow>
                 ?v i \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis (sum ?v ?I) =
                               (\<lambda>b.
                                   \<Sum>i\<in>?I.
                                     local.representation ?basis (?v i)
b)\<close>
  notes theorem
    "representation_scale" =
      \<open>\<lbrakk>local.independent ?basis;
              ?v \<in> local.span ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis (?r *s ?v) =
                               (\<lambda>b.
                                   ?r *
                                   local.representation ?basis ?v b)\<close>
  notes theorem
    "representation_extend" =
      \<open>\<lbrakk>local.independent ?basis; ?v \<in> local.span ?basis';
              ?basis' \<subseteq> ?basis\<rbrakk>
             \<Longrightarrow> local.representation ?basis ?v =
                               local.representation ?basis' ?v\<close>
  notes theorem
    "spanning_subset_independent" =
      \<open>\<lbrakk>?B \<subseteq> ?A; local.independent ?A;
              ?A \<subseteq> local.span ?B\<rbrakk>
             \<Longrightarrow> ?A = ?B\<close>
  notes theorem
    "module_hom_scale_self" =
      (\<open>module_hom (*s) (*s) ((*s) ?c)\<close>) ["simp"]
  notes theorem
    "module_hom_scale_left" =
      (\<open>module_hom (*) (*s) (\<lambda>r. r *s ?x)\<close>) ["simp"]
  notes theorem "module_hom_id" = \<open>module_hom (*s) (*s) id\<close>
  notes theorem
    "module_hom_ident" = \<open>module_hom (*s) (*s) (\<lambda>x. x)\<close>
  notes theorem
    "module_hom_uminus" = \<open>module_hom (*s) (*s) uminus\<close>
  notes theorem
    "span_with" = \<open>local.span = span_with (+) (0::'b) (*s)\<close>
  notes theorem
    "dependent_with" =
      \<open>local.dependent = dependent_with (+) (0::'b) (*s)\<close>
  notes theorem
    "subspace_with" =
      \<open>local.subspace = subspace_with (+) (0::'b) (*s)\<close>
locale finite_dimensional_vector_space_on
  fixes S :: "'a set"
    and scale :: "'b \<Rightarrow> 'a \<Rightarrow> 'a"
    and basis :: "'a set"
  assumes "finite_dimensional_vector_space_on S scale basis"
locale module_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "module_pair_on S1 S2 scale1 scale2"
locale vector_space_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
  assumes "vector_space_pair_on S1 S2 scale1 scale2"
locale finite_dimensional_vector_space_pair_1_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and Basis1 :: "'b set"
  assumes
    "finite_dimensional_vector_space_pair_1_on S1 S2 scale1 scale2 Basis1"
locale finite_dimensional_vector_space_pair_on
  fixes S1 :: "'b set"
    and S2 :: "'c set"
    and scale1 :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
    and scale2 :: "'a \<Rightarrow> 'c \<Rightarrow> 'c"
    and Basis1 :: "'b set"
    and Basis2 :: "'c set"
  assumes
    "finite_dimensional_vector_space_pair_on S1 S2 scale1 scale2 Basis1
      Basis2"
### theory "HOL-Types_To_Sets.Linear_Algebra_On"
### 4.135s elapsed time, 8.294s cpu time, 0.992s GC time
Loading theory "Smooth_Manifolds.Analysis_More" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function" via "Smooth_Manifolds.Smooth")
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Rule already declared as introduction (intro)
### open {}
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
instantiation
  fun :: (type, scaleR) scaleR
  scaleR_fun == scaleR ::
    real
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
bundle no_matrix_mult
*** Undefined fact: "sum_not_0" (line 476 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** At command "by" (line 476 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** Undefined fact: "sum_not_0" (line 481 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** At command "by" (line 481 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
### Ignoring duplicate rewrite rule:
### topspace (subtopology ?U1 ?V1) \<equiv> topspace ?U1 \<inter> ?V1
### Ignoring duplicate rewrite rule:
### topspace (subtopology ?U1 ?V1) \<equiv> topspace ?U1 \<inter> ?V1
locale vector_space_on
  fixes S :: "'b set"
    and
    scale :: "'a \<Rightarrow> 'b \<Rightarrow> 'b"
      (infixr \<open>*s\<close> 75)
  assumes "vector_space_on S (*s)"
*** Failed to apply proof method (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy"):
*** goal (2 subgoals):
***  1. \<lbrakk>f x = g x; \<forall>\<^sub>F x in at x within X. f x = g x;
***      bounded_linear D;
***      ((\<lambda>y.
***           (1 / norm (y - x)) *\<^sub>R
***           (g y - (g x + D (y - x)))) \<longlongrightarrow>
***       (0::'b))
***       (at x within X)\<rbrakk>
***     \<Longrightarrow> \<forall>\<^sub>F xa in at x within X.
***                          ?f3 xa =
***                          (1 / norm (xa - x)) *\<^sub>R
***                          (f xa - (g x + D (xa - x)))
***  2. \<lbrakk>f x = g x; \<forall>\<^sub>F x in at x within X. f x = g x;
***      bounded_linear D;
***      ((\<lambda>y.
***           (1 / norm (y - x)) *\<^sub>R
***           (g y - (g x + D (y - x)))) \<longlongrightarrow>
***       (0::'b))
***       (at x within X)\<rbrakk>
***     \<Longrightarrow> (?f3 \<longlongrightarrow> (0::'b)) (at x within X)
*** At command "apply" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. ?c1) (at ?a1) \<equiv> \<lambda>x. 0::?'b1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### theory "Smooth_Manifolds.Analysis_More"
### 1.392s elapsed time, 8.139s cpu time, 0.341s GC time
Loading theory "Smooth_Manifolds.Chart" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Differentiable_Manifold" via "Smooth_Manifolds.Topological_Manifold")
Loading theory "Smooth_Manifolds.Smooth" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Bump_Function")
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. ?c1) (at ?a1) \<equiv> \<lambda>x. 0::?'b1
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. x) (at ?a1) \<equiv> \<lambda>x. x
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
consts
  nth_derivative ::
    "nat
     \<Rightarrow> ('a \<Rightarrow> 'b)
                   \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'b"
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. x) (at ?a1) \<equiv> \<lambda>x. x
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. x) (at ?a1) \<equiv> \<lambda>x. x
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. ?c1) (at ?a1) \<equiv> \<lambda>x. 0::?'b1
### theory "Smooth_Manifolds.Chart"
### 0.589s elapsed time, 4.082s cpu time, 0.260s GC time
Loading theory "Smooth_Manifolds.Topological_Manifold" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity" via "Smooth_Manifolds.Differentiable_Manifold")
locale manifold
  fixes charts :: "('a, 'e) chart set"
### theory "Smooth_Manifolds.Smooth"
### 0.640s elapsed time, 4.506s cpu time, 0.260s GC time
Loading theory "Smooth_Manifolds.Bump_Function" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity")
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### theory "Smooth_Manifolds.Topological_Manifold"
### 0.094s elapsed time, 0.720s cpu time, 0.049s GC time
Loading theory "Smooth_Manifolds.Differentiable_Manifold" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space" via "Smooth_Manifolds.Partition_Of_Unity")
### Ignoring duplicate rewrite rule:
### open {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed UNIV \<equiv> True
### Ignoring duplicate rewrite rule:
### closed ?S1 \<Longrightarrow> closed (insert ?a1 ?S1) \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {..<?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### open {?a1<..<?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {..?a1} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..} \<equiv> True
### Ignoring duplicate rewrite rule:
### closed {?a1..?b1} \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous bot ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous (at ?x1 within ?S1) id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 (\<lambda>x. ?c1) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?g1 ?a1 \<noteq> (0::?'b1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x / ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; 0 < ?f1 ?a1; ?f1 ?a1 \<noteq> 1;
###  0 < ?g1 ?a1\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. log (?f1 x) (?g1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; isCont ?g1 ?a1; ?f1 ?a1 \<noteq> 0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. ?f1 x powr ?g1 x) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; cos (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. tan (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?a1; sin (?f1 ?a1) \<noteq> (0::?'a1)\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. cot (?f1 x)) ?a1 \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous ?F1 ?g1 \<Longrightarrow>
### continuous ?F1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_on ?s1 ?g1 \<Longrightarrow>
### continuous_on ?s1 (\<lambda>x. cnj (?g1 x)) \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 id \<equiv> True
### Ignoring duplicate rewrite rule:
### continuous_map ?X1 ?X1 (\<lambda>x. x) \<equiv> True
### Ignoring duplicate rewrite rule:
### \<lbrakk>isCont ?f1 ?z1;
###  ?f1 ?z1 \<notin> \<real>\<^sub>\<le>\<^sub>0\<rbrakk>
### \<Longrightarrow> isCont (\<lambda>x. Ln (?f1 x)) ?z1 \<equiv> True
### theory "Smooth_Manifolds.Bump_Function"
### 0.094s elapsed time, 0.745s cpu time, 0.000s GC time
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** Failed to apply initial proof method (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at_right 0. exp (- inverse t) = f t
***   ((\<lambda>t. exp (- inverse t)) \<longlongrightarrow> 0) (at_right 0)
*** goal (1 subgoal):
***  1. (f \<longlongrightarrow> 0) (at_right 0)
*** At command "by" (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply initial proof method (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at_left 0. 0 = f t
*** goal (1 subgoal):
***  1. (f \<longlongrightarrow> 0) (at_left 0)
*** At command "by" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to finish proof (line 55 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          (1 + real k) * inverse (x ^ k) /
***          exp (inverse x)) \<longlongrightarrow>
***      0)
***      (at_right 0)
*** At command "by" (line 55 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply proof method (line 104 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at x. 0 = f t
*** goal (1 subgoal):
***  1. f \<midarrow>x\<rightarrow> f x
*** At command "apply" (line 104 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. ?c1) (at ?a1) \<equiv> \<lambda>x. 0::?'b1
### Rule already declared as introduction (intro)
### real_polynomial_function (\<lambda>x. ?c)
### Rule already declared as introduction (intro)
### \<lbrakk>real_polynomial_function ?f; real_polynomial_function ?g\<rbrakk>
### \<Longrightarrow> real_polynomial_function (\<lambda>x. ?f x + ?g x)
### Rule already declared as introduction (intro)
### \<lbrakk>real_polynomial_function ?f; real_polynomial_function ?g\<rbrakk>
### \<Longrightarrow> real_polynomial_function (\<lambda>x. ?f x * ?g x)
### Rule already declared as introduction (intro)
### \<lbrakk>real_polynomial_function ?f; real_polynomial_function ?g\<rbrakk>
### \<Longrightarrow> real_polynomial_function (\<lambda>x. ?f x - ?g x)
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale c_manifold'
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold' charts k"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
locale submanifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
    and S :: "'a set"
  assumes "submanifold charts k S"
locale c_manifolds
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
  assumes "c_manifolds k charts1 charts2"
*** Failed to apply proof method (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** goal (6 subgoals):
***  1. real_polynomial_function (\<lambda>a. pk a * exp (- (1 / a)))
***  2. pk 0 * exp (- (1 / 0)) = ?a6
***  3. ((\<lambda>x. x * x ^ (2 * k)) \<longlongrightarrow> ?b6)
***      (at 0 within {0..})
***  4. ?b6 \<noteq> 0
***  5. ?a6 / ?b6 = 0
***  6. \<forall>\<^sub>F x in at 0 within {0..}.
***        pk x * (exp (- inverse x) / x ^ (2 * k + 1)) =
***        inverse \<bar>x\<bar> *
***        (if x = 0 then 0 else pk x / x ^ (2 * k) * exp (- inverse x))
*** At command "apply" (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
locale c_manifolds
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
  assumes "c_manifolds k charts1 charts2"
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open src.carrier
locale c_manifolds
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
  assumes "c_manifolds k charts1 charts2"
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open src.carrier
locale c_manifolds
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
  assumes "c_manifolds k charts1 charts2"
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale diff_fun
  fixes k :: "enat"
    and charts :: "('a, 'c) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff_fun k charts f"
locale diff_fun
  fixes k :: "enat"
    and charts :: "('a, 'c) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff_fun k charts f"
locale diffeomorphism
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
    and f :: "'a \<Rightarrow> 'c"
    and f' :: "'c \<Rightarrow> 'a"
  assumes "Differentiable_Manifold.diffeomorphism k charts1 charts2 f f'"
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
locale diff_fun
  fixes k :: "enat"
    and charts :: "('a, 'c) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff_fun k charts f"
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### theory "Smooth_Manifolds.Differentiable_Manifold"
### 1.202s elapsed time, 8.277s cpu time, 0.355s GC time
Loading theory "Smooth_Manifolds.Partition_Of_Unity" (required by "Smooth_Manifolds.Cotangent_Space" via "Smooth_Manifolds.Tangent_Space")
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
Loading theory "Smooth_Manifolds.Product_Manifold"
Loading theory "Smooth_Manifolds.Projective_Space"
Loading theory "Smooth_Manifolds.Sphere"
locale c_manifold_prod
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
  assumes "c_manifold_prod k charts1 charts2"
### theory "Smooth_Manifolds.Product_Manifold"
### 0.148s elapsed time, 0.762s cpu time, 0.060s GC time
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
instantiation
  sphere :: (real_normed_vector) topological_space
  open_sphere == open :: 'a sphere set \<Rightarrow> bool
### theory "Smooth_Manifolds.Partition_Of_Unity"
### 0.270s elapsed time, 1.315s cpu time, 0.120s GC time
Loading theory "Smooth_Manifolds.Tangent_Space" (required by "Smooth_Manifolds.Cotangent_Space")
locale real_vector_space_on
  fixes S :: "'a set"
  assumes "real_vector_space_on S"
### theory "Smooth_Manifolds.Sphere"
### 0.368s elapsed time, 1.663s cpu time, 0.120s GC time
locale real_vector_space_pair_on
  fixes S :: "'a set"
    and T :: "'b set"
  assumes "real_vector_space_pair_on S T"
instantiation
  nonzero :: (euclidean_space) topological_space
  open_nonzero == open :: 'a nonzero set \<Rightarrow> bool
locale finite_dimensional_real_vector_space_on
  fixes S :: "'a set"
    and basis :: "'a set"
  assumes "finite_dimensional_real_vector_space_on S basis"
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
instantiation
  nonzero :: (euclidean_space) scaleR
  scaleR_nonzero == scaleR ::
    real \<Rightarrow> 'a nonzero \<Rightarrow> 'a nonzero
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
instantiation
  nonzero :: (euclidean_space) plus
  plus_nonzero == plus ::
    'a nonzero \<Rightarrow> 'a nonzero \<Rightarrow> 'a nonzero
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
instantiation
  nonzero :: (euclidean_space) minus
  minus_nonzero == minus ::
    'a nonzero \<Rightarrow> 'a nonzero \<Rightarrow> 'a nonzero
locale finite_dimensional_real_vector_space_pair_1_on
  fixes S1 :: "'a set"
    and S2 :: "'b set"
    and basis :: "'a set"
  assumes "finite_dimensional_real_vector_space_pair_1_on S1 S2 basis"
instantiation
  nonzero :: (euclidean_space) dist
  dist_nonzero == dist ::
    'a nonzero \<Rightarrow> 'a nonzero \<Rightarrow> real
instantiation
  nonzero :: (euclidean_space) norm
  norm_nonzero == norm :: 'a nonzero \<Rightarrow> real
Proofs for inductive predicate(s) "proj_rel"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### No map function defined for Projective_Space.nonzero. This will cause problems later on.
locale finite_dimensional_real_vector_space_pair_on
  fixes S1 :: "'a set"
    and S2 :: "'b set"
    and Basis1 :: "'a set"
    and Basis2 :: "'b set"
  assumes "finite_dimensional_real_vector_space_pair_on S1 S2 Basis1 Basis2"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Projective_Space.nonzero" found.
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
instantiation
  proj_space :: (euclidean_space) topological_space
  open_proj_space == open :: 'a proj_space set \<Rightarrow> bool
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Introduced fixed type variable(s): 'b in "a__"
### theory "Smooth_Manifolds.Projective_Space"
### 1.496s elapsed time, 10.162s cpu time, 1.811s GC time
\<lbrakk>diff_fun k (charts_submanifold W) ?a;
 diff_fun k (charts_submanifold W) ?b\<rbrakk>
\<Longrightarrow> diff_fun k (charts_submanifold W)
                   (\<lambda>x. ?a x *\<^sub>R ?b x)
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
locale diffeomorphism
  fixes k :: "enat"
    and charts1 :: "('a, 'b) chart set"
    and charts2 :: "('c, 'd) chart set"
    and f :: "'a \<Rightarrow> 'c"
    and f' :: "'c \<Rightarrow> 'a"
  assumes "Differentiable_Manifold.diffeomorphism k charts1 charts2 f f'"
locale submanifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
    and S :: "'a set"
  assumes "submanifold charts k S"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale submanifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
    and S :: "'a set"
  assumes "submanifold charts k S"
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
\<lbrakk>\<forall>x.
            x \<in> manifold_eucl.diff_fun_space k \<longrightarrow>
            X x \<in> UNIV;
 \<forall>x.
    x \<in> ?S \<longrightarrow>
    ?g x \<in> manifold_eucl.diff_fun_space k\<rbrakk>
\<Longrightarrow> X (\<lambda>x. \<Sum>i\<in>?S. ?g i x) =
                  (\<Sum>a\<in>?S. X (?g a))
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### theory "Smooth_Manifolds.Tangent_Space"
### 3.942s elapsed time, 27.592s cpu time, 4.211s GC time
Loading theory "Smooth_Manifolds.Cotangent_Space"
locale real_vector_space_pair_on
  fixes S :: "'a set"
    and T :: "'b set"
  assumes "real_vector_space_pair_on S T"
locale real_vector_space_on
  fixes S :: "'a set"
  assumes "real_vector_space_on S"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
locale diff
  fixes k :: "enat"
    and charts1 :: "('a, 'e) chart set"
    and charts2 :: "('b, 'f) chart set"
    and f :: "'a \<Rightarrow> 'b"
  assumes "diff k charts1 charts2 f"
locale c_manifold
  fixes charts :: "('a, 'b) chart set"
    and k :: "enat"
  assumes "c_manifold charts k"
### theory "Smooth_Manifolds.Cotangent_Space"
### 1.549s elapsed time, 7.770s cpu time, 2.316s GC time
### Ignoring duplicate rewrite rule:
### frechet_derivative (\<lambda>x. ?c1) (at ?a1) \<equiv> \<lambda>x. 0::?'b1
*** Failed to apply proof method (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** goal (6 subgoals):
***  1. real_polynomial_function (\<lambda>a. pk a * exp (- (1 / a)))
***  2. pk 0 * exp (- (1 / 0)) = ?a6
***  3. ((\<lambda>x. x * x ^ (2 * k)) \<longlongrightarrow> ?b6)
***      (at 0 within {0..})
***  4. ?b6 \<noteq> 0
***  5. ?a6 / ?b6 = 0
***  6. \<forall>\<^sub>F x in at 0 within {0..}.
***        pk x * (exp (- inverse x) / x ^ (2 * k + 1)) =
***        inverse \<bar>x\<bar> *
***        (if x = 0 then 0 else pk x / x ^ (2 * k) * exp (- inverse x))
*** At command "apply" (line 320 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply proof method (line 104 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at x. 0 = f t
*** goal (1 subgoal):
***  1. f \<midarrow>x\<rightarrow> f x
*** At command "apply" (line 104 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to finish proof (line 55 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** goal (1 subgoal):
***  1. ((\<lambda>x.
***          (1 + real k) * inverse (x ^ k) /
***          exp (inverse x)) \<longlongrightarrow>
***      0)
***      (at_right 0)
*** At command "by" (line 55 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply initial proof method (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at_left 0. 0 = f t
*** goal (1 subgoal):
***  1. (f \<longlongrightarrow> 0) (at_left 0)
*** At command "by" (line 86 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply initial proof method (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy"):
*** using this:
***   \<forall>\<^sub>F t in at_right 0. exp (- inverse t) = f t
***   ((\<lambda>t. exp (- inverse t)) \<longlongrightarrow> 0) (at_right 0)
*** goal (1 subgoal):
***  1. (f \<longlongrightarrow> 0) (at_right 0)
*** At command "by" (line 77 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy")
*** Failed to apply proof method (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy"):
*** goal (2 subgoals):
***  1. \<lbrakk>f x = g x; \<forall>\<^sub>F x in at x within X. f x = g x;
***      bounded_linear D;
***      ((\<lambda>y.
***           (1 / norm (y - x)) *\<^sub>R
***           (g y - (g x + D (y - x)))) \<longlongrightarrow>
***       (0::'b))
***       (at x within X)\<rbrakk>
***     \<Longrightarrow> \<forall>\<^sub>F xa in at x within X.
***                          ?f3 xa =
***                          (1 / norm (xa - x)) *\<^sub>R
***                          (f xa - (g x + D (xa - x)))
***  2. \<lbrakk>f x = g x; \<forall>\<^sub>F x in at x within X. f x = g x;
***      bounded_linear D;
***      ((\<lambda>y.
***           (1 / norm (y - x)) *\<^sub>R
***           (g y - (g x + D (y - x)))) \<longlongrightarrow>
***       (0::'b))
***       (at x within X)\<rbrakk>
***     \<Longrightarrow> (?f3 \<longlongrightarrow> (0::'b)) (at x within X)
*** At command "apply" (line 1044 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** Undefined fact: "sum_not_0" (line 481 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** At command "by" (line 481 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** Undefined fact: "sum_not_0" (line 476 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")
*** At command "by" (line 476 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy")

==========
Source_Coding_Theorem
Loading theory "Source_Coding_Theorem.Source_Coding_Theorem"
locale source_code
  fixes M :: "'a measure"
    and b :: "real"
    and fi :: "'b \<Rightarrow> real"
    and X :: "'a \<Rightarrow> 'b"
    and enc :: "'b list \<Rightarrow> bool list"
    and dec :: "bool list \<Rightarrow> 'b list option"
  assumes "source_code M b fi X enc dec"
locale source_code
  fixes M :: "'a measure"
    and b :: "real"
    and fi :: "'b \<Rightarrow> real"
    and X :: "'a \<Rightarrow> 'b"
    and enc :: "'b list \<Rightarrow> bool list"
    and dec :: "bool list \<Rightarrow> 'b list option"
  assumes "source_code M b fi X enc dec"
### theory "Source_Coding_Theorem.Source_Coding_Theorem"
### 0.421s elapsed time, 1.972s cpu time, 0.109s GC time
*** Undefined fact: "linordered_field_class.sign_simps" (line 533 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy")
*** At command "by" (line 533 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 533 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy")
*** At command "by" (line 533 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy")

==========
Stirling_Formula
Loading theory "HOL-Library.Function_Algebras" (required by "Stirling_Formula.Stirling_Formula" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
Loading theory "HOL-Library.Stirling" (required by "Stirling_Formula.Ln_Gamma_Asymptotics" via "Bernoulli.Bernoulli_FPS")
Loading theory "Bernoulli.Bernoulli" (required by "Stirling_Formula.Ln_Gamma_Asymptotics" via "Bernoulli.Bernoulli_FPS")
Loading theory "HOL-Library.Landau_Symbols" (required by "Stirling_Formula.Stirling_Formula" via "Landau_Symbols.Landau_More")
Loading theory "Landau_Symbols.Group_Sort" (required by "Stirling_Formula.Stirling_Formula" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs" via "Landau_Symbols.Landau_Real_Products")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a \<Rightarrow> 'b
instantiation
  fun :: (type, times) times
  times_fun == times ::
    ('a \<Rightarrow> 'b)
    \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b
locale groupsort
  fixes f :: "'a \<Rightarrow> 'b"
    and merge :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and g :: "'a list \<Rightarrow> 'c"
  assumes "groupsort f merge g"
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a \<Rightarrow> 'b
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.141s elapsed time, 0.997s cpu time, 0.054s GC time
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd p)) <*mlex*>
   (\<lambda>p. size (fst p)) <*mlex*> {}"
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### theory "Bernoulli.Bernoulli"
### 0.308s elapsed time, 2.172s cpu time, 0.177s GC time
Loading theory "Bernoulli.Periodic_Bernpoly" (required by "Stirling_Formula.Ln_Gamma_Asymptotics")
consts
  stirling_row_aux ::
    "'a \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list"
### theory "HOL-Library.Stirling"
### 0.330s elapsed time, 2.359s cpu time, 0.177s GC time
Loading theory "Bernoulli.Bernoulli_FPS" (required by "Stirling_Formula.Ln_Gamma_Asymptotics")
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
### theory "Bernoulli.Periodic_Bernpoly"
### 0.243s elapsed time, 1.894s cpu time, 0.104s GC time
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
Found termination order: "length <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### mset (filter ?P1 ?xs1) \<equiv> filter_mset ?P1 (mset ?xs1)
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
locale landau_pair
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    l :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    l' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and
    lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
    and R :: "real \<Rightarrow> real \<Rightarrow> bool"
  assumes "landau_pair L l L' l' Lr lr R"
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate rewrite rule:
### bernpoly ?n1 (0::?'a1) \<equiv> of_real (bernoulli ?n1)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
### Rule already declared as introduction (intro)
### (\<And>x. ?f x = ?g x) \<Longrightarrow> ?f = ?g
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### theory "Landau_Symbols.Group_Sort"
### 1.135s elapsed time, 8.392s cpu time, 1.021s GC time
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> L ?F ?f \<subseteq> L ?F ?g
### Rule already declared as introduction (intro)
### ?f \<in> L ?F ?g \<Longrightarrow> l ?F ?f \<subseteq> l ?F ?g
### Ignoring duplicate rewrite rule:
### (\<lambda>x. - ?f1 x) \<in> o[?F1](?g1) \<equiv> ?f1 \<in> o[?F1](?g1)
Found termination order: "(\<lambda>p. size (fst (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. norm (?f1 x)) \<in> O[?F1](\<lambda>x. norm (?g1 x)) \<equiv>
### ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### O[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> O[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### \<Omega>[?F1](\<lambda>x. ?c1 * ?f1 x) \<equiv> \<Omega>[?F1](?f1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> O[?F1](?g1) \<equiv> ?f1 \<in> O[?F1](?g1)
### Ignoring duplicate rewrite rule:
### ?c1 \<noteq> (0::?'b1) \<Longrightarrow>
### (\<lambda>x. ?c1 * ?f1 x) \<in> \<Omega>[?F1](?g1) \<equiv>
### ?f1 \<in> \<Omega>[?F1](?g1)
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
locale landau_symbol
  fixes
    L :: "'a filter
          \<Rightarrow> ('a \<Rightarrow> 'b)
                        \<Rightarrow> ('a \<Rightarrow> 'b) set"
    and
    L' ::
      "'c filter
       \<Rightarrow> ('c \<Rightarrow> 'b)
                     \<Rightarrow> ('c \<Rightarrow> 'b) set"
    and
    Lr ::
      "'a filter
       \<Rightarrow> ('a \<Rightarrow> real)
                     \<Rightarrow> ('a \<Rightarrow> real) set"
  assumes "landau_symbol L L' Lr"
### theory "Bernoulli.Bernoulli_FPS"
### 1.181s elapsed time, 8.951s cpu time, 1.005s GC time
### Ignoring duplicate rewrite rule:
### (\<lambda>x. inverse (?f1 x))
### \<in> \<Theta>[?F1](\<lambda>x. inverse (?g1 x)) \<equiv>
### ?f1 \<in> \<Theta>[?F1](?g1)
bundle asymp_equiv_notation
### theory "HOL-Library.Landau_Symbols"
### 1.833s elapsed time, 13.667s cpu time, 1.310s GC time
Loading theory "Landau_Symbols.Landau_Real_Products" (required by "Stirling_Formula.Stirling_Formula" via "Landau_Symbols.Landau_More" via "Landau_Symbols.Landau_Simprocs")
consts
  bigtheta_pow ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> 'b) set
                   \<Rightarrow> nat
                                 \<Rightarrow> ('a \<Rightarrow> 'b) set"
locale landau_function_family
  fixes F :: "'a filter"
    and H :: "('a \<Rightarrow> real) set"
  assumes "landau_function_family F H"
locale landau_function_family_pair
  fixes F :: "'a filter"
    and G :: "('a \<Rightarrow> real) set"
    and H :: "('a \<Rightarrow> real) set"
    and g :: "'a \<Rightarrow> real"
  assumes "landau_function_family_pair F G H g"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
consts
  landau_dominating_chain' ::
    "'a filter
     \<Rightarrow> ('a \<Rightarrow> real) list \<Rightarrow> bool"
consts
  nonneg_list :: "'a list \<Rightarrow> bool"
consts
  pos_list :: "'a list \<Rightarrow> bool"
locale landau_function_family_chain
  fixes F :: "'b filter"
    and gs :: "'a list"
    and get_param :: "'a \<Rightarrow> real"
    and get_fun :: "'a \<Rightarrow> 'b \<Rightarrow> real"
  assumes "landau_function_family_chain F gs get_fun"
instantiation
  primfun :: linorder
  less_eq_primfun == less_eq ::
    primfun \<Rightarrow> primfun \<Rightarrow> bool
  less_primfun == less :: primfun \<Rightarrow> primfun \<Rightarrow> bool
Found termination order: "{}"
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
### Ignoring duplicate rewrite rule:
### (\<lambda>x. ?f1 x powr ?p1) \<in> powr_closure ?f1 \<equiv> True
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### pos_primfun_list [] \<equiv> False
### Ignoring duplicate rewrite rule:
### pos_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> pos_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### nonneg_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### (0::?'b1) < ?x1 \<or> ?x1 = (0::?'b1) \<and> nonneg_primfun_list ?xs1
### Ignoring duplicate rewrite rule:
### iszero_primfun_list [] \<equiv> True
### Ignoring duplicate rewrite rule:
### iszero_primfun_list ((?uu1, ?x1) # ?xs1) \<equiv>
### ?x1 = (0::?'b1) \<and> iszero_primfun_list ?xs1
### theory "Landau_Symbols.Landau_Real_Products"
### 2.304s elapsed time, 12.315s cpu time, 0.680s GC time
Loading theory "Landau_Symbols.Landau_Simprocs" (required by "Stirling_Formula.Stirling_Formula" via "Landau_Symbols.Landau_More")
### ML warning (line 63 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (dest_bigtheta) has not been referenced.
### ML warning (line 176 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (x_name2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest2) has not been referenced.
### ML warning (line 185 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Value identifier (rest1) has not been referenced.
### ML warning (line 318 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 373 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Landau_Symbols/landau_simprocs.ML"):
### Pattern is not exhaustive.
signature LANDAU =
  sig
    val cancel_factor_conv: Proof.context -> cterm -> thm
    val cancel_factor_simproc: Proof.context -> cterm -> thm option
    val dest_landau: term -> term * term * term
    val landau_const_names: string list
    val landau_sum_limit: int Config.T
    val lift_landau_conv: conv -> conv
    val lift_landau_simproc:
       (Proof.context -> cterm -> thm option) ->
         Proof.context -> cterm -> thm option
    val simplify_landau_product_conv: Proof.context -> conv
    val simplify_landau_product_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_real_prod_prop_conv: Proof.context -> conv
    val simplify_landau_real_prod_prop_simproc:
       Proof.context -> cterm -> thm option
    val simplify_landau_sum_conv: Proof.context -> conv
    val simplify_landau_sum_simproc: Proof.context -> cterm -> thm option
  end
structure Landau: LANDAU
### theory "Landau_Symbols.Landau_Simprocs"
### 0.458s elapsed time, 1.953s cpu time, 1.230s GC time
Loading theory "Landau_Symbols.Landau_More" (required by "Stirling_Formula.Stirling_Formula")
val it =
   "(\<lambda>x.
        5 * (ln (ln x))\<^sup>2 / (2 * x) powr (15 / 10) * inverse 2)
    \<in> \<omega>(\<lambda>x.
                      3 * ln x * ln x / x * ln (ln (ln (ln x)))) \<equiv>
    3 = 0 \<or>
    5 * inverse (2 powr (15 / 10)) * inverse 2 \<noteq> 0 \<and>
    pos_primfun_list
     (group_primfuns
       [(LnChain 1, - 1), (LnChain 1, - 1), (LnChain 0, 1),
        (LnChain 4, - 1), (LnChain 2, real 2), (LnChain 0, - (15 / 10))])":
   thm
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### Ignoring duplicate simplification procedure "Landau_Simprocs.simplify_landau_sum"
### theory "Landau_Symbols.Landau_More"
### 0.169s elapsed time, 0.954s cpu time, 0.022s GC time
Loading theory "Stirling_Formula.Stirling_Formula"
*** Failed to apply initial proof method (line 252 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   (\<lambda>n. \<Sum>r<n. D (real r + x)) \<longlonglongrightarrow> P x
***   \<forall>\<^sub>F n in sequentially. (\<Sum>r<n. D (real r + x)) = p n x
*** goal (1 subgoal):
***  1. (\<lambda>n. p n x) \<longlonglongrightarrow> P x
*** At command "by" (line 252 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply initial proof method (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      ln (inverse (1 + x / real n)) + ln x - 1 / (2 * x) - p n x =
***      ln (real n) - S' n x - 1 / (2 * x)
***   (\<lambda>n. ln (inverse (1 + x / real n)) + ln x - 1 / (2 * x) - p n x)
***   \<longlonglongrightarrow> ln x - 1 / (2 * x) - P x
*** goal (1 subgoal):
***  1. (\<lambda>n. ln (real n) - S' n x - 1 / (2 * x))
***     \<longlonglongrightarrow> ln x - 1 / (2 * x) - P x
*** At command "by" (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
### theory "Stirling_Formula.Stirling_Formula"
### 0.590s elapsed time, 2.571s cpu time, 0.102s GC time
Loading theory "Stirling_Formula.Ln_Gamma_Asymptotics"
*** Failed to apply initial proof method (line 192 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      1 / (2 * (x + real n)) = c n - (ln (real n) - S' n x - 1 / (2 * x))
***   (\<lambda>n. 1 / (2 * (x + real n))) \<longlonglongrightarrow> 0
*** goal (1 subgoal):
***  1. (\<lambda>n. c n - (ln (real n) - S' n x - 1 / (2 * x)))
***     \<longlonglongrightarrow> 0
*** At command "by" (line 192 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
### Ignoring duplicate rewrite rule:
### 0 \<le> ?x1 \<Longrightarrow>
### ?x1 powr numeral ?n1 \<equiv> ?x1 ^ numeral ?n1
*** Undefined fact: "Lim_eventually" (line 415 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** At command "by" (line 415 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply terminal proof method (line 566 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** goal (1 subgoal):
***  1. \<And>x.
***        x \<in> {1..n} \<Longrightarrow>
***        (2 * real x)\<^sup>2 / (2 * real x - 1)\<^sup>2 =
***        (2 * real x) ^ 4 / (2 * real x * (2 * real x - 1))\<^sup>2
*** At command "by" (line 565 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
### Rule already declared as introduction (intro)
### open {}
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### closed {}
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Rule already declared as introduction (intro)
### closed UNIV
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Rule already declared as introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Rule already declared as introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Rule already declared as introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Rule already declared as introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Rule already declared as introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Rule already declared as introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Rule already declared as introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** Undefined fact: "holomorphic_higher_deriv" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 284 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 283 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
### Ignoring duplicate rewrite rule:
### 0 < ?n1 \<Longrightarrow>
### Ln (of_nat ?n1) \<equiv> complex_of_real (ln (real ?n1))
### theory "Stirling_Formula.Ln_Gamma_Asymptotics"
### 1.175s elapsed time, 6.152s cpu time, 1.584s GC time
*** Undefined fact: "has_vector_derivative_real_complex" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Type unification failed: No type arity fun :: banach
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:
***   stirling_integral m has_contour_integral /
***   (has_contour_integral - of_real x) ^ Suc j ::
***   ??'a
*** Operand:   complex_of_real :: real \<Rightarrow> complex
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operator failed:
*** No complex coercion from "??'a130" to fun
*** At command "hence" (line 955 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 875 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 875 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Failed to apply initial proof method (line 1225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy"):
*** goal (1 subgoal):
***  1. (deriv ^^ j)
***      (\<lambda>x.
***          (x - 1 / 2) * Ln x - x + complex_of_real (ln (2 * pi)) / 2 +
***          stirling_sum 0 m x) holomorphic_on
***     {s. 0 < Re s}
*** At command "by" (line 1225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "higher_deriv_diff" (line 1249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 1249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "higher_deriv_diff" (line 1249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 1249 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Failed to apply initial proof method (line 1225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy"):
*** goal (1 subgoal):
***  1. (deriv ^^ j)
***      (\<lambda>x.
***          (x - 1 / 2) * Ln x - x + complex_of_real (ln (2 * pi)) / 2 +
***          stirling_sum 0 m x) holomorphic_on
***     {s. 0 < Re s}
*** At command "by" (line 1225 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 875 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 875 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Type unification failed: No type arity fun :: banach
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:
***   stirling_integral m has_contour_integral /
***   (has_contour_integral - of_real x) ^ Suc j ::
***   ??'a
*** Operand:   complex_of_real :: real \<Rightarrow> complex
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operator failed:
*** No complex coercion from "??'a130" to fun
*** At command "hence" (line 955 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 510 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 284 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 283 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "has_vector_derivative_real_complex" (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 198 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Undefined fact: "holomorphic_higher_deriv" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** At command "by" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy")
*** Failed to apply terminal proof method (line 566 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** goal (1 subgoal):
***  1. \<And>x.
***        x \<in> {1..n} \<Longrightarrow>
***        (2 * real x)\<^sup>2 / (2 * real x - 1)\<^sup>2 =
***        (2 * real x) ^ 4 / (2 * real x * (2 * real x - 1))\<^sup>2
*** At command "by" (line 565 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Undefined fact: "Lim_eventually" (line 415 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** At command "by" (line 415 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply initial proof method (line 192 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      1 / (2 * (x + real n)) = c n - (ln (real n) - S' n x - 1 / (2 * x))
***   (\<lambda>n. 1 / (2 * (x + real n))) \<longlonglongrightarrow> 0
*** goal (1 subgoal):
***  1. (\<lambda>n. c n - (ln (real n) - S' n x - 1 / (2 * x)))
***     \<longlonglongrightarrow> 0
*** At command "by" (line 192 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply initial proof method (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   \<forall>\<^sub>F n in sequentially.
***      ln (inverse (1 + x / real n)) + ln x - 1 / (2 * x) - p n x =
***      ln (real n) - S' n x - 1 / (2 * x)
***   (\<lambda>n. ln (inverse (1 + x / real n)) + ln x - 1 / (2 * x) - p n x)
***   \<longlonglongrightarrow> ln x - 1 / (2 * x) - P x
*** goal (1 subgoal):
***  1. (\<lambda>n. ln (real n) - S' n x - 1 / (2 * x))
***     \<longlonglongrightarrow> ln x - 1 / (2 * x) - P x
*** At command "by" (line 280 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply initial proof method (line 252 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy"):
*** using this:
***   (\<lambda>n. \<Sum>r<n. D (real r + x)) \<longlonglongrightarrow> P x
***   \<forall>\<^sub>F n in sequentially. (\<Sum>r<n. D (real r + x)) = p n x
*** goal (1 subgoal):
***  1. (\<lambda>n. p n x) \<longlonglongrightarrow> P x
*** At command "by" (line 252 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy")
*** Failed to apply initial proof method (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at x within {0..1}. f x = f (frac x)
***   (f \<longlongrightarrow> f (frac x)) (at x within {0..1})
*** goal (1 subgoal):
***  1. ((\<lambda>x. f (frac x)) \<longlongrightarrow> f (frac x))
***      (at x within {0..1})
*** At command "by" (line 167 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_left (1::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (1::'a)) (at_left (1::'a))
*** At command "by" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")
*** Failed to apply initial proof method (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy"):
*** using this:
***   \<forall>\<^sub>F x in at_right (0::'a). x = frac x
***   ((\<lambda>x. x) \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** goal (1 subgoal):
***  1. (frac \<longlongrightarrow> (0::'a)) (at_right (0::'a))
*** At command "by" (line 100 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy")

==========
Stone_Relation_Algebras
Loading theory "Stone_Relation_Algebras.Fixpoints"
class order = preorder +
  assumes
    "antisym":
      "\<And>x y.
          \<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> x = y"
### theory "Stone_Relation_Algebras.Fixpoints"
### 0.914s elapsed time, 4.320s cpu time, 0.562s GC time
Loading theory "Stone_Relation_Algebras.Semirings"
class non_associative_left_semiring = one + times +
  bounded_semilattice_sup_bot +
  assumes
    "mult_left_sub_dist_sup":
      "\<And>x y z. x * y \<squnion> x * z \<le> x * (y \<squnion> z)"
  assumes
    "mult_right_dist_sup":
      "\<And>x y z. (x \<squnion> y) * z = x * z \<squnion> y * z"
  assumes "mult_left_zero": "\<And>x. bot * x = bot"
  assumes "mult_left_one": "\<And>x. (1::'a) * x = x"
  assumes "mult_sub_right_one": "\<And>x. x \<le> x * (1::'a)"
class pre_left_semiring = non_associative_left_semiring +
  assumes
    "mult_semi_associative": "\<And>x y z. x * y * z \<le> x * (y * z)"
class residuated_pre_left_semiring = divide + pre_left_semiring +
  assumes "lres_galois": "\<And>x y z. (x * y \<le> z) = (x \<le> z / y)"
class idempotent_left_zero_semiring = idempotent_left_semiring +
  assumes
    "mult_left_dist_sup":
      "\<And>x y z. x * (y \<squnion> z) = x * y \<squnion> x * z"
### Partially applied constant "Lattices.sup_class.sup" on left hand side of equation, in theorem:
### semiring.numeral num.One \<equiv> 1::?'a
### Partially applied constant "Lattices.sup_class.sup" on left hand side of equation, in theorem:
### semiring.numeral (num.Bit0 ?n) \<equiv>
### let m = semiring.numeral ?n in m \<squnion> m
### Partially applied constant "Lattices.sup_class.sup" on left hand side of equation, in theorem:
### semiring.numeral (num.Bit1 ?n) \<equiv>
### let m = semiring.numeral ?n in m \<squnion> m \<squnion> (1::?'a)
class idempotent_semiring = idempotent_left_zero_semiring +
  assumes "mult_right_zero": "\<And>x. x * bot = bot"
class bounded_non_associative_left_semiring = top +
  non_associative_left_semiring +
  assumes "sup_right_top": "\<And>x. x \<squnion> top = top"
### theory "Stone_Relation_Algebras.Semirings"
### 4.150s elapsed time, 9.599s cpu time, 0.491s GC time
Loading theory "Stone_Relation_Algebras.Relation_Algebras"
class conv = type +
  fixes conv :: "'a \<Rightarrow> 'a"
class bounded_distrib_allegory = one + times + bounded_distrib_lattice +
  conv +
  assumes "comp_associative": "\<And>x y z. x * y * z = x * (y * z)"
  assumes
    "comp_right_dist_sup":
      "\<And>x y z. (x \<squnion> y) * z = x * z \<squnion> y * z"
  assumes "comp_left_zero": "\<And>x. bot * x = bot"
  assumes "comp_left_one": "\<And>x. (1::'a) * x = x"
  assumes "conv_involutive": "\<And>x. x\<^sup>T\<^sup>T = x"
  assumes
    "conv_dist_sup":
      "\<And>x y. (x \<squnion> y)\<^sup>T = x\<^sup>T \<squnion> y\<^sup>T"
  assumes
    "conv_dist_comp": "\<And>x y. (x * y)\<^sup>T = y\<^sup>T * x\<^sup>T"
  assumes
    "dedekind_1":
      "\<And>x y z.
          x * y \<sqinter> z \<le> x * (y \<sqinter> x\<^sup>T * z)"
### theory "Stone_Relation_Algebras.Relation_Algebras"
### 5.876s elapsed time, 16.693s cpu time, 2.401s GC time
*** Failed to load theory "Stone_Relation_Algebras.Matrix_Relation_Algebras" (unresolved "Stone_Relation_Algebras.Relation_Algebras")
*** Failed to load theory "Stone_Relation_Algebras.Relation_Subalgebras" (unresolved "Stone_Relation_Algebras.Relation_Algebras")
*** Failed to load theory "Stone_Relation_Algebras.Linear_Order_Matrices" (unresolved "Stone_Relation_Algebras.Matrix_Relation_Algebras")
*** exception FAIL NONE raised (line 161 of "General/scan.ML")
*** At command "abbreviation" (line 1087 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Stone_Relation_Algebras/Relation_Algebras.thy")

==========
Sturm_Tarski
Loading theory "Sturm_Tarski.PolyMisc" (required by "Sturm_Tarski.Sturm_Tarski")
### theory "Sturm_Tarski.PolyMisc"
### 0.060s elapsed time, 0.151s cpu time, 0.000s GC time
*** Failed to load theory "Sturm_Tarski.Sturm_Tarski" (unresolved "Sturm_Tarski.PolyMisc")
*** Type unification failed: Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  gcd :: ??'a \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Sturm_Tarski/PolyMisc.thy")

==========
Weight_Balanced_Trees
Loading theory "HOL-Data_Structures.Cmp" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2")
Loading theory "HOL-Data_Structures.Less_False" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2" via "HOL-Data_Structures.Set_Specs" via "HOL-Data_Structures.List_Ins_Del" via "HOL-Data_Structures.Sorted_Less")
Loading theory "HOL-Library.Tree" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees_log")
### theory "HOL-Data_Structures.Less_False"
### 0.039s elapsed time, 0.164s cpu time, 0.000s GC time
Loading theory "HOL-Data_Structures.Sorted_Less" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2" via "HOL-Data_Structures.Set_Specs" via "HOL-Data_Structures.List_Ins_Del")
### theory "HOL-Data_Structures.Sorted_Less"
### 0.065s elapsed time, 0.355s cpu time, 0.046s GC time
Loading theory "HOL-Data_Structures.List_Ins_Del" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2" via "HOL-Data_Structures.Set_Specs")
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
### theory "HOL-Data_Structures.List_Ins_Del"
### 0.234s elapsed time, 1.227s cpu time, 0.072s GC time
Loading theory "HOL-Data_Structures.Set_Specs" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2")
locale Set
  fixes empty :: "'s"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
  assumes "Set empty insert delete isin set invar"
### theory "HOL-Data_Structures.Cmp"
### 0.395s elapsed time, 2.048s cpu time, 0.118s GC time
locale Set_by_Ordered
  fixes empty :: "'t"
    and insert :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and delete :: "'a \<Rightarrow> 't \<Rightarrow> 't"
    and isin :: "'t \<Rightarrow> 'a \<Rightarrow> bool"
    and inorder :: "'t \<Rightarrow> 'a list"
    and inv :: "'t \<Rightarrow> bool"
  assumes "Set_by_Ordered empty insert delete isin inorder inv"
locale Set2
  fixes empty :: "'s"
    and delete :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and isin :: "'s \<Rightarrow> 'a \<Rightarrow> bool"
    and set :: "'s \<Rightarrow> 'a set"
    and invar :: "'s \<Rightarrow> bool"
    and insert :: "'a \<Rightarrow> 's \<Rightarrow> 's"
    and union :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and inter :: "'s \<Rightarrow> 's \<Rightarrow> 's"
    and diff :: "'s \<Rightarrow> 's \<Rightarrow> 's"
  assumes "Set2 empty delete isin set invar insert union inter diff"
### theory "HOL-Data_Structures.Set_Specs"
### 0.109s elapsed time, 0.503s cpu time, 0.044s GC time
consts
  left :: "'a tree \<Rightarrow> 'a tree"
consts
  right :: "'a tree \<Rightarrow> 'a tree"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a \<Rightarrow> nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree \<Rightarrow> nat
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.421s elapsed time, 4.710s cpu time, 0.798s GC time
Loading theory "HOL-Data_Structures.Tree2" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees" via "HOL-Data_Structures.Isin2")
Loading theory "Weight_Balanced_Trees.Weight_Balanced_Trees_log"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale WBT0
  fixes \<alpha> :: "real"
  assumes "WBT0 \<alpha>"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Data_Structures.Tree2"
### 0.220s elapsed time, 1.159s cpu time, 0.038s GC time
Loading theory "HOL-Data_Structures.Isin2" (required by "Weight_Balanced_Trees.Weight_Balanced_Trees")
Found termination order: "size <*mlex*> {}"
### theory "Weight_Balanced_Trees.Weight_Balanced_Trees_log"
### 0.252s elapsed time, 1.229s cpu time, 0.038s GC time
Found termination order: "(\<lambda>p. size (fst p)) <*mlex*> {}"
### theory "HOL-Data_Structures.Isin2"
### 0.267s elapsed time, 0.575s cpu time, 0.064s GC time
Loading theory "Weight_Balanced_Trees.Weight_Balanced_Trees"
### theory "Weight_Balanced_Trees.Weight_Balanced_Trees"
### 0.008s elapsed time, 0.024s cpu time, 0.000s GC time
*** Type unification failed: Clash of types "_ \<Rightarrow> _" and "_ tree"
*** 
*** Type error in application: operator not of function type
*** 
*** Operator:  \<langle>n, l, a\<rangle> :: ??'a tree
*** Operand:   r :: ??'b
*** 
*** At command "lemma" (line 15 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Weight_Balanced_Trees/Weight_Balanced_Trees.thy")

==========
Winding_Number_Eval
Loading theory "HOL-Eisbach.Eisbach" (required by "Winding_Number_Eval.Winding_Number_Eval" via "HOL-Eisbach.Eisbach_Tools")
Loading theory "HOL-Computational_Algebra.Fraction_Field" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Normalized_Fraction")
Loading theory "HOL-Library.More_List" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial" via "HOL-Computational_Algebra.Polynomial")
Loading theory "HOL-Computational_Algebra.Field_as_Ring" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski")
Loading theory "Winding_Number_Eval.Missing_Analysis" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem")
Loading theory "Winding_Number_Eval.Missing_Topology" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Winding_Number_Eval.Missing_Transcendental")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
### Ignoring duplicate introduction (intro)
### open {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### open {}
### theory "Winding_Number_Eval.Missing_Analysis"
### 0.110s elapsed time, 0.752s cpu time, 0.054s GC time
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; open ?T\<rbrakk> \<Longrightarrow> open (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. open (?B x) \<Longrightarrow> open (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. open T\<rbrakk>
### \<Longrightarrow> open (\<Inter> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. open (?B x)\<rbrakk>
### \<Longrightarrow> open (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### closed {}
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<union> ?T)
### Ignoring duplicate introduction (intro)
### closed UNIV
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; closed ?T\<rbrakk>
### \<Longrightarrow> closed (?S \<inter> ?T)
### Ignoring duplicate introduction (intro)
### \<forall>x\<in>?A. closed (?B x) \<Longrightarrow>
### closed (\<Inter> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<forall>S\<in>?K. closed S \<Longrightarrow> closed (\<Inter> ?K)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?S; \<forall>T\<in>?S. closed T\<rbrakk>
### \<Longrightarrow> closed (\<Union> ?S)
### Ignoring duplicate introduction (intro)
### \<lbrakk>finite ?A; \<forall>x\<in>?A. closed (?B x)\<rbrakk>
### \<Longrightarrow> closed (\<Union> (?B ` ?A))
### Ignoring duplicate introduction (intro)
### \<lbrakk>open ?S; closed ?T\<rbrakk> \<Longrightarrow> open (?S - ?T)
### Ignoring duplicate introduction (intro)
### \<lbrakk>closed ?S; open ?T\<rbrakk> \<Longrightarrow> closed (?S - ?T)
### Ignoring duplicate introduction (intro)
### closed ?S \<Longrightarrow> open (- ?S)
### Ignoring duplicate introduction (intro)
### open ?S \<Longrightarrow> closed (- ?S)
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
*** Type unification failed: Variable 'a::type not of sort real_normed_vector
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  linepath ::
***   ??'a \<Rightarrow> ??'a \<Rightarrow> real \<Rightarrow> ??'a
*** Operand:   st :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::type not of sort real_normed_vector
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "obtain" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
### Ignoring duplicate introduction (intro)
### continuous_on ?s (linepath ?a ?b)
*** Type unification failed
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (*) c :: complex \<Rightarrow> complex
*** Operand:   x :: 'b
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Cannot generate coercion from "'b" to "complex"
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 61 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
structure Eisbach_Rule_Insts: sig end
### theory "HOL-Library.More_List"
### 0.227s elapsed time, 1.677s cpu time, 0.105s GC time
Loading theory "HOL-Computational_Algebra.Polynomial" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial")
*** Type unification failed: Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (-) (- w) :: ??'a \<Rightarrow> ??'a
*** Operand:   z :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
instantiation
  fract :: (idom) comm_ring_1
  uminus_fract == uminus :: 'a fract \<Rightarrow> 'a fract
  one_fract == one_class.one :: 'a fract
  times_fract == times ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  zero_fract == zero_class.zero :: 'a fract
  minus_fract == minus ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  plus_fract == plus ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
*** Type unification failed: Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  deriv ::
***   (??'a \<Rightarrow> ??'a) \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   \<lambda>x. c * x + b :: 'a \<Rightarrow> 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 133 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Undefined fact: "valid_path_compose_holomorphic" (line 80 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** At command "using" (line 80 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 182 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 182 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
### theory "Winding_Number_Eval.Missing_Topology"
### 0.440s elapsed time, 3.326s cpu time, 0.341s GC time
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
instantiation
  fract :: (idom) field
  inverse_fract == inverse :: 'a fract \<Rightarrow> 'a fract
  divide_fract == divide ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
*** Undefined fact: "linordered_field_class.sign_simps" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
instantiation
  fract :: (linordered_idom) linorder
  less_eq_fract == less_eq ::
    'a fract \<Rightarrow> 'a fract \<Rightarrow> bool
  less_fract == less :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> bool
### theory "HOL-Eisbach.Eisbach"
### 0.592s elapsed time, 4.457s cpu time, 0.424s GC time
Loading theory "HOL-Eisbach.Eisbach_Tools" (required by "Winding_Number_Eval.Winding_Number_Eval")
val try_map = fn: 'a Seq.seq -> 'a Seq.seq -> 'a Seq.seq
instantiation
  fract :: (linordered_idom) linordered_field
  sgn_fract == sgn :: 'a fract \<Rightarrow> 'a fract
  abs_fract == abs :: 'a fract \<Rightarrow> 'a fract
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
val uncurry_rule = fn: thm -> thm
val curry_rule = fn: thm -> thm
### Ignoring duplicate introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
### theory "HOL-Eisbach.Eisbach_Tools"
### 0.041s elapsed time, 0.325s cpu time, 0.000s GC time
instantiation
  fract :: (linordered_idom) distrib_lattice
  inf_fract == inf :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
  sup_fract == sup :: 'a fract \<Rightarrow> 'a fract \<Rightarrow> 'a fract
### theory "HOL-Computational_Algebra.Fraction_Field"
### 0.673s elapsed time, 5.118s cpu time, 0.456s GC time
Loading theory "HOL-Computational_Algebra.Normalized_Fraction" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc" via "HOL-Computational_Algebra.Polynomial_Factorial")
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. x) \<longlongrightarrow> ?a) (at ?a within ?s)
### Ignoring duplicate introduction (intro)
### ((\<lambda>x. ?k) \<longlongrightarrow> ?k) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ereal (?f x)) \<longlongrightarrow> ereal ?x) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. - ?f x) \<longlongrightarrow> - ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?c\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?x \<noteq> 0; (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?c * ?f x) \<longlongrightarrow> ?c * ?x) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>?y \<noteq> - \<infinity>; ?x \<noteq> - \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### \<lbrakk>\<bar>?y\<bar> \<noteq> \<infinity>;
###  (?f \<longlongrightarrow> ?x) ?F\<rbrakk>
### \<Longrightarrow> ((\<lambda>x. ?f x + ?y) \<longlongrightarrow> ?x + ?y) ?F
### Ignoring duplicate introduction (intro)
### (?f \<longlongrightarrow> ?x) ?F \<Longrightarrow>
### ((\<lambda>x. ennreal (?f x)) \<longlongrightarrow> ennreal ?x) ?F
class field = division_ring + idom_divide +
  assumes
    "field_inverse":
      "\<And>a.
          a \<noteq> (0::'a) \<Longrightarrow> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "\<And>a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
locale fract_as_normalized_quot
### theory "HOL-Computational_Algebra.Normalized_Fraction"
### 0.284s elapsed time, 2.205s cpu time, 0.091s GC time
instantiation
  real ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_real == division_segment :: real \<Rightarrow> real
  normalize_real == normalize :: real \<Rightarrow> real
  unit_factor_real == unit_factor :: real \<Rightarrow> real
  euclidean_size_real == euclidean_size :: real \<Rightarrow> nat
  modulo_real == modulo :: real \<Rightarrow> real \<Rightarrow> real
instantiation
  real :: euclidean_ring_gcd
  Gcd_real == Gcd :: real set \<Rightarrow> real
  Lcm_real == Lcm :: real set \<Rightarrow> real
  gcd_real == gcd :: real \<Rightarrow> real \<Rightarrow> real
  lcm_real == lcm :: real \<Rightarrow> real \<Rightarrow> real
instantiation
  rat ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_rat == division_segment :: rat \<Rightarrow> rat
  normalize_rat == normalize :: rat \<Rightarrow> rat
  unit_factor_rat == unit_factor :: rat \<Rightarrow> rat
  euclidean_size_rat == euclidean_size :: rat \<Rightarrow> nat
  modulo_rat == modulo :: rat \<Rightarrow> rat \<Rightarrow> rat
instantiation
  rat :: euclidean_ring_gcd
  Gcd_rat == Gcd :: rat set \<Rightarrow> rat
  Lcm_rat == Lcm :: rat set \<Rightarrow> rat
  gcd_rat == gcd :: rat \<Rightarrow> rat \<Rightarrow> rat
  lcm_rat == lcm :: rat \<Rightarrow> rat \<Rightarrow> rat
instantiation
  poly :: (zero) zero
  zero_poly == zero_class.zero :: 'a poly
instantiation
  complex ::
    {normalization_euclidean_semiring,unique_euclidean_ring,normalization_semidom_multiplicative}
  division_segment_complex == division_segment ::
    complex \<Rightarrow> complex
  normalize_complex == normalize :: complex \<Rightarrow> complex
  unit_factor_complex == unit_factor :: complex \<Rightarrow> complex
  euclidean_size_complex == euclidean_size :: complex \<Rightarrow> nat
  modulo_complex == modulo ::
    complex \<Rightarrow> complex \<Rightarrow> complex
instantiation
  complex :: euclidean_ring_gcd
  Gcd_complex == Gcd :: complex set \<Rightarrow> complex
  Lcm_complex == Lcm :: complex set \<Rightarrow> complex
  gcd_complex == gcd :: complex \<Rightarrow> complex \<Rightarrow> complex
  lcm_complex == lcm :: complex \<Rightarrow> complex \<Rightarrow> complex
### theory "HOL-Computational_Algebra.Field_as_Ring"
### 1.396s elapsed time, 10.499s cpu time, 0.716s GC time
consts
  Poly :: "'a list \<Rightarrow> 'a poly"
instantiation
  poly :: ({zero,equal}) equal
  equal_poly == equal_class.equal ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
instantiation
  poly :: (comm_monoid_add) comm_monoid_add
  plus_poly == plus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly == minus :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (ab_group_add) ab_group_add
  uminus_poly == uminus :: 'a poly \<Rightarrow> 'a poly
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
instantiation
  poly :: (comm_semiring_0) comm_semiring_0
  times_poly == times :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: (comm_semiring_1) comm_semiring_1
  one_poly == one_class.one :: 'a poly
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
instantiation
  poly :: (linordered_idom) linordered_idom
  sgn_poly == sgn :: 'a poly \<Rightarrow> 'a poly
  abs_poly == abs :: 'a poly \<Rightarrow> 'a poly
  less_eq_poly == less_eq ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
  less_poly == less :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> bool
### Ignoring duplicate elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
instantiation
  poly :: (idom_divide) idom_divide
  divide_poly == divide ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd (snd p)))))) <*mlex*> {}"
instantiation
  poly :: ({idom_divide,semidom_divide_unit_factor}) normalization_semidom
  normalize_poly == normalize :: 'a poly \<Rightarrow> 'a poly
  unit_factor_poly == unit_factor :: 'a poly \<Rightarrow> 'a poly
class field_unit_factor = field + unit_factor +
  assumes "unit_factor_field": "unit_factor = id"
Proofs for inductive predicate(s) "eucl_rel_poly"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
instantiation
  poly :: (field) semidom_modulo
  modulo_poly == modulo ::
    'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(\<lambda>p. size (snd (snd p))) <*mlex*> {}"
Found termination order:
  "(\<lambda>p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
### theory "HOL-Computational_Algebra.Polynomial"
### 5.120s elapsed time, 26.523s cpu time, 3.879s GC time
Loading theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem")
Loading theory "HOL-Computational_Algebra.Polynomial_Factorial" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski" via "Sturm_Tarski.PolyMisc")
### theory "HOL-Computational_Algebra.Fundamental_Theorem_Algebra"
### 0.185s elapsed time, 1.311s cpu time, 0.100s GC time
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Ignoring duplicate rewrite rule:
### (?a1 * ?b1) ^ ?n1 \<equiv> ?a1 ^ ?n1 * ?b1 ^ ?n1
### Rule already declared as elimination (elim)
### \<lbrakk>?b dvd ?a; \<And>k. ?a = ?b * k \<Longrightarrow> ?P\<rbrakk>
### \<Longrightarrow> ?P
instantiation
  poly :: ({factorial_ring_gcd,semiring_gcd_mult_normalize})
    factorial_ring_gcd
  Gcd_poly == Gcd :: 'a poly set \<Rightarrow> 'a poly
  Lcm_poly == Lcm :: 'a poly set \<Rightarrow> 'a poly
  gcd_poly == gcd :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
  lcm_poly == lcm :: 'a poly \<Rightarrow> 'a poly \<Rightarrow> 'a poly
instantiation
  poly :: ({factorial_ring_gcd,field,semiring_gcd_mult_normalize})
    {normalization_euclidean_semiring,unique_euclidean_ring}
  division_segment_poly == division_segment :: 'a poly \<Rightarrow> 'a poly
  euclidean_size_poly == euclidean_size :: 'a poly \<Rightarrow> nat
find_theorems
  name: "prod_mset_prime_factorization"

found 6 theorem(s):
Factorial_Ring.factorial_semiring_multiplicative_class.prod_mset_prime_factorization:
  ?x \<noteq> (0::?'a) \<Longrightarrow>
  prod_mset (prime_factorization ?x) = normalize ?x
Factorial_Ring.factorial_semiring_class.prod_mset_prime_factorization_weak:
  ?x \<noteq> (0::?'a) \<Longrightarrow>
  normalize (prod_mset (prime_factorization ?x)) = normalize ?x
local.field_poly.prod_mset_prime_factorization:
  ?x \<noteq> 0 \<Longrightarrow>
  prod_mset (field_poly.prime_factorization ?x) =
  smult (inverse (lead_coeff ?x)) ?x
Factorial_Ring.factorial_semiring_multiplicative.prod_mset_prime_factorization:
  \<lbrakk>class.factorial_semiring_multiplicative ?divide ?plus ?minus
            ?zero ?times ?one ?unit_factor ?normalize;
   ?x \<noteq> ?zero\<rbrakk>
  \<Longrightarrow> comm_monoid_mult.prod_mset ?times ?one
                     (factorial_semiring.prime_factorization ?zero ?times
                       ?one ?normalize ?x) =
                    ?normalize ?x
Factorial_Ring.factorial_semiring.prod_mset_prime_factorization_weak:
  \<lbrakk>class.factorial_semiring ?divide ?plus ?minus ?zero ?times ?one
            ?unit_factor ?normalize;
   ?x \<noteq> ?zero\<rbrakk>
  \<Longrightarrow> ?normalize
                     (comm_monoid_mult.prod_mset ?times ?one
                       (factorial_semiring.prime_factorization ?zero ?times
                         ?one ?normalize ?x)) =
                    ?normalize ?x
local.field_poly.prod_mset_prime_factorization_weak:
  ?x \<noteq> 0 \<Longrightarrow>
  smult
   (inverse (lead_coeff (prod_mset (field_poly.prime_factorization ?x))))
   (prod_mset (field_poly.prime_factorization ?x)) =
  smult (inverse (lead_coeff ?x)) ?x
### theory "HOL-Computational_Algebra.Polynomial_Factorial"
### 9.505s elapsed time, 17.869s cpu time, 3.949s GC time
Loading theory "Sturm_Tarski.PolyMisc" (required by "Winding_Number_Eval.Winding_Number_Eval" via "Winding_Number_Eval.Cauchy_Index_Theorem" via "Sturm_Tarski.Sturm_Tarski")
### theory "Sturm_Tarski.PolyMisc"
### 0.026s elapsed time, 0.045s cpu time, 0.000s GC time
*** Failed to load theory "Sturm_Tarski.Sturm_Tarski" (unresolved "Sturm_Tarski.PolyMisc")
*** Failed to load theory "Budan_Fourier.BF_Misc" (unresolved "Sturm_Tarski.Sturm_Tarski")
*** Failed to load theory "Winding_Number_Eval.Missing_Algebraic" (unresolved "Budan_Fourier.BF_Misc")
*** Failed to load theory "Winding_Number_Eval.Missing_Transcendental" (unresolved "Winding_Number_Eval.Missing_Algebraic")
*** Failed to load theory "Winding_Number_Eval.Cauchy_Index_Theorem" (unresolved "Sturm_Tarski.Sturm_Tarski", "Winding_Number_Eval.Missing_Algebraic", "Winding_Number_Eval.Missing_Transcendental")
*** Failed to load theory "Winding_Number_Eval.Winding_Number_Eval" (unresolved "Winding_Number_Eval.Cauchy_Index_Theorem")
*** Failed to load theory "Winding_Number_Eval.Winding_Number_Eval_Examples" (unresolved "Winding_Number_Eval.Winding_Number_Eval")
*** Type unification failed: Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  gcd :: ??'a \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   p :: 'a poly
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** failed to unify invariant arguments
*** Variable 'a::factorial_ring_gcd not of sort {factorial_ring_gcd,semiring_gcd_mult_normalize}
*** 
*** At command "lemma" (line 148 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Sturm_Tarski/PolyMisc.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 257 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** Undefined fact: "linordered_field_class.sign_simps" (line 182 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** At command "by" (line 182 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy")
*** Undefined fact: "valid_path_compose_holomorphic" (line 80 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** At command "using" (line 80 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed: Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  deriv ::
***   (??'a \<Rightarrow> ??'a) \<Rightarrow> ??'a \<Rightarrow> ??'a
*** Operand:   \<lambda>x. c * x + b :: 'a \<Rightarrow> 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::{inverse,times,real_normed_vector} not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 133 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed: Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (-) (- w) :: ??'a \<Rightarrow> ??'a
*** Operand:   z :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::real_normed_vector not of sort real_normed_field
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 110 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  (*) c :: complex \<Rightarrow> complex
*** Operand:   x :: 'b
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Cannot generate coercion from "'b" to "complex"
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "have" (line 61 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")
*** Type unification failed: Variable 'a::type not of sort real_normed_vector
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  linepath ::
***   ??'a \<Rightarrow> ??'a \<Rightarrow> real \<Rightarrow> ??'a
*** Operand:   st :: 'a
*** 
*** Coercion Inference:
*** 
*** Local coercion insertion on the operand failed:
*** Variable 'a::type not of sort real_normed_vector
*** 
*** Now trying to infer coercions globally.
*** 
*** Coercion inference failed:
*** weak unification of subtype constraints fails
*** 
*** 
*** At command "obtain" (line 43 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy")

==========
Word_Lib
Loading theory "HOL-Library.Sublist" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas")
Loading theory "Word_Lib.Hex_Words" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib" via "Word_Lib.Word_Syntax")
Loading theory "Word_Lib.Signed_Words" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib" via "Word_Lib.Word_Syntax" via "Word_Lib.WordBitwise_Signed")
Loading theory "Word_Lib.Word_Type_Syntax" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib" via "Word_Lib.Word_Syntax")
Loading theory "Word_Lib.Enumeration" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Enum")
Loading theory "Word_Lib.HOL_Lemmas" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned")
Loading theory "Word_Lib.More_Divides" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned")
structure Word_Syntax:
  sig
    val show_word_types: bool Config.T
    val tr': string -> Proof.context -> typ -> term list -> term
  end
### theory "Word_Lib.Hex_Words"
### 0.031s elapsed time, 0.251s cpu time, 0.000s GC time
### theory "Word_Lib.More_Divides"
### 0.030s elapsed time, 0.248s cpu time, 0.000s GC time
consts
  the_index :: "'a list \<Rightarrow> 'a \<Rightarrow> nat"
instantiation
  signed :: (len0) len0
  len_of_signed == len_of :: 'a signed itself \<Rightarrow> nat
### theory "Word_Lib.Word_Type_Syntax"
### 0.045s elapsed time, 0.373s cpu time, 0.000s GC time
class enum = finite +
  fixes enum :: "'a list"
    and enum_all :: "('a \<Rightarrow> bool) \<Rightarrow> bool"
    and enum_ex :: "('a \<Rightarrow> bool) \<Rightarrow> bool"
  assumes "UNIV_enum": "UNIV = set enum_class.enum"
    and "enum_distinct": "distinct enum_class.enum"
  assumes "enum_all_UNIV": "\<And>P. enum_class.enum_all P = Ball UNIV P"
  assumes "enum_ex_UNIV": "\<And>P. enum_class.enum_ex P = Bex UNIV P"
### theory "Word_Lib.Signed_Words"
### 0.053s elapsed time, 0.437s cpu time, 0.000s GC time
Loading theory "Word_Lib.Norm_Words" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib" via "Word_Lib.Word_Syntax")
Loading theory "Word_Lib.WordBitwise_Signed" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib" via "Word_Lib.Word_Syntax")
val is_refl = fn: term -> bool
val signed_dest_wordT = fn: typ -> int
val typ_size_of = fn: cterm -> int
val num_len = fn: term -> int
val unsigned_norm = fn: bool -> 'a -> Proof.context -> cterm -> thm option
### theory "Word_Lib.Norm_Words"
### 0.046s elapsed time, 0.336s cpu time, 0.051s GC time
### theory "Word_Lib.HOL_Lemmas"
### 0.143s elapsed time, 1.137s cpu time, 0.051s GC time
class enum_alt = type +
  fixes enum_alt :: "nat \<Rightarrow> 'a option"
consts
  prefixes :: "'a list \<Rightarrow> 'a list list"
val bw_tac_signed = fn: Proof.context -> int -> tactic
### theory "Word_Lib.WordBitwise_Signed"
### 0.161s elapsed time, 1.276s cpu time, 0.052s GC time
Loading theory "Word_Lib.Word_Syntax" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned" via "Word_Lib.Word_Lib")
class enumeration_alt = enum_alt +
  assumes
    "enum_alt_one_bound":
      "\<And>x. enum_alt x = None \<Longrightarrow> enum_alt (Suc x) = None"
  assumes "enum_alt_surj": "range enum_alt \<union> {None} = UNIV"
  assumes
    "enum_alt_inj":
      "\<And>x y.
          enum_alt x = enum_alt y \<Longrightarrow>
          x = y \<or> enum_alt x = None"
class enumeration_both = enum + enum_alt +
  assumes "enum_alt_rel": "enum_alt = alt_from_ord enum_class.enum"
Found termination order: "(\<lambda>p. length (snd p)) <*mlex*> {}"
instantiation
  bool :: enumeration_both
  enum_alt_bool == enum_alt :: nat \<Rightarrow> bool option
instantiation
  nat :: enumeration_alt
  enum_alt_nat == enum_alt :: nat \<Rightarrow> nat option
### theory "Word_Lib.Enumeration"
### 0.578s elapsed time, 4.488s cpu time, 0.259s GC time
consts
  suffixes :: "'a list \<Rightarrow> 'a list list"
Proofs for inductive predicate(s) "list_emb"
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
  Proving the induction rule ...
  Proving the simplification rules ...
### theory "Word_Lib.Word_Syntax"
### 0.436s elapsed time, 3.221s cpu time, 0.197s GC time
Loading theory "Word_Lib.Word_Lib" (required by "Word_Lib.Word_Lemmas_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_Next" via "Word_Lib.Aligned")
class signed_div = type +
  fixes sdiv :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
    and smod :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
instantiation
  int :: signed_div
  sdiv_int == sdiv :: int \<Rightarrow> int \<Rightarrow> int
  smod_int == smod :: int \<Rightarrow> int \<Rightarrow> int
instantiation
  word :: (len) signed_div
  sdiv_word == sdiv :: 'a word \<Rightarrow> 'a word \<Rightarrow> 'a word
  smod_word == smod :: 'a word \<Rightarrow> 'a word \<Rightarrow> 'a word
consts
  sublists :: "'a list \<Rightarrow> 'a list list"
### theory "Word_Lib.Word_Lib"
### 0.202s elapsed time, 1.438s cpu time, 0.104s GC time
### Ignoring duplicate rewrite rule:
### list_emb ?P1 [] ?ys1 \<equiv> True
### Ignoring duplicate rewrite rule:
### list_emb ?P1 (?x1 # ?xs1) [] \<equiv> False
### theory "HOL-Library.Sublist"
### 0.955s elapsed time, 7.146s cpu time, 0.436s GC time
*** Failed to load theory "Word_Lib.Word_Enum" (unresolved "Word_Lib.Word_Lib")
*** Failed to load theory "Word_Lib.Word_Setup_32" (unresolved "Word_Lib.Word_Enum")
*** Failed to load theory "Word_Lib.Word_Setup_64" (unresolved "Word_Lib.Word_Enum")
*** Failed to load theory "Word_Lib.Aligned" (unresolved "Word_Lib.Word_Lib")
*** Failed to load theory "Word_Lib.Word_Next" (unresolved "Word_Lib.Aligned")
*** Failed to load theory "Word_Lib.Word_Lemmas" (unresolved "Word_Lib.Word_Enum", "Word_Lib.Word_Next")
*** Failed to load theory "Word_Lib.Word_Lemmas_32" (unresolved "Word_Lib.Word_Lemmas", "Word_Lib.Word_Setup_32")
*** Failed to load theory "Word_Lib.Word_Lemmas_64" (unresolved "Word_Lib.Word_Lemmas", "Word_Lib.Word_Setup_64")
*** Type unification failed: No type arity fun :: bit_operations
*** 
*** Type error in application: incompatible operand type
*** 
*** Operator:  NOT :: ??'a \<Rightarrow> ??'a
*** Operand:   mask :: nat \<Rightarrow> ??'b word
*** 
*** At command "lemma" (line 169 of "~/Desktop/2024_sem1/AutomaticProofRepair/AFPs/afp-2019/thys/Word_Lib/Word_Lib.thy")

