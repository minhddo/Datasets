==========
Adaptive_State_Counting
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Adaptive_State_Counting/ASC/ASC_Example.thy ../../AFPs/afp-2020/thys/Adaptive_State_Counting/ASC/ASC_Example.thy
17c17
< This subsection provides a function to more easily create FSMs, only requiring a set of 
---
> This subsection provides a function to more easily create FSMs, only requiring a set of
23,25c23,25
< "from_rel rel q0 = \<lparr> succ = \<lambda> io p . { q . (p,io,q) \<in> rel }, 
<                     inputs = image (fst \<circ> fst \<circ> snd) rel, 
<                     outputs = image (snd \<circ> fst \<circ> snd) rel, 
---
> "from_rel rel q0 = \<lparr> succ = \<lambda> io p . { q . (p,io,q) \<in> rel },
>                     inputs = image (fst \<circ> fst \<circ> snd) rel,
>                     outputs = image (snd \<circ> fst \<circ> snd) rel,
30c30
< lemma nodes_from_rel : "nodes (from_rel rel q0) \<subseteq> insert q0 (image (snd \<circ> snd) rel)" 
---
> lemma nodes_from_rel : "nodes (from_rel rel q0) \<subseteq> insert q0 (image (snd \<circ> snd) rel)"
45c45
<         using \<open>\<And> q io p . q \<in> succ ?M io p \<Longrightarrow> q \<in> image (snd \<circ> snd) rel\<close> by blast 
---
>         using \<open>\<And> q io p . q \<in> succ ?M io p \<Longrightarrow> q \<in> image (snd \<circ> snd) rel\<close> by blast
51c51
<   
---
> 
56,57c56,57
<                           \<and> (\<forall> s1 x y . (x \<notin> image (fst \<circ> fst \<circ> snd) rel 
<                                             \<or> y \<notin> image (snd \<circ> fst \<circ> snd) rel) 
---
>                           \<and> (\<forall> s1 x y . (x \<notin> image (fst \<circ> fst \<circ> snd) rel
>                                             \<or> y \<notin> image (snd \<circ> fst \<circ> snd) rel)
70c70
<     by (simp add: Finite_Set.finite_subset) 
---
>     by (simp add: Finite_Set.finite_subset)
72c72
<     using assms by auto  
---
>     using assms by auto
76c76
<   moreover have "inputs ?M \<noteq> {}" 
---
>   moreover have "inputs ?M \<noteq> {}"
78c78
<   moreover have "outputs ?M \<noteq> {}" 
---
>   moreover have "outputs ?M \<noteq> {}"
82c82
<   
---
> 
90c90
< fun completely_specified_rel_over :: "('state \<times> ('in \<times> 'out) \<times> 'state) set \<Rightarrow> 'state set \<Rightarrow> bool" 
---
> fun completely_specified_rel_over :: "('state \<times> ('in \<times> 'out) \<times> 'state) set \<Rightarrow> 'state set \<Rightarrow> bool"
92,94c92,94
<   "completely_specified_rel_over rel nods = (\<forall> s1 \<in> nods . 
<                                                 \<forall> x \<in> image (fst \<circ> fst \<circ> snd) rel . 
<                                                   \<exists> y \<in> image (snd \<circ> fst \<circ> snd) rel . 
---
>   "completely_specified_rel_over rel nods = (\<forall> s1 \<in> nods .
>                                                 \<forall> x \<in> image (fst \<circ> fst \<circ> snd) rel .
>                                                   \<exists> y \<in> image (snd \<circ> fst \<circ> snd) rel .
104,105c104,105
<   proof 
<     fix x assume "x \<in> inputs (from_rel rel q0)" 
---
>   proof
>     fix x assume "x \<in> inputs (from_rel rel q0)"
108,109c108,109
<          
<     obtain y s2 where "y \<in> image (snd \<circ> fst \<circ> snd) rel" "(s1,(x,y),s2) \<in> rel" 
---
> 
>     obtain y s2 where "y \<in> image (snd \<circ> fst \<circ> snd) rel" "(s1,(x,y),s2) \<in> rel"
111c111
<       by (meson completely_specified_rel_over.elims(2)) 
---
>       by (meson completely_specified_rel_over.elims(2))
116c116
<     then show "\<exists>y\<in>outputs (from_rel rel q0). \<exists>s2. s2 \<in> succ (from_rel rel q0) (x, y) s1" 
---
>     then show "\<exists>y\<in>outputs (from_rel rel q0). \<exists>s2. s2 \<in> succ (from_rel rel q0) (x, y) s1"
126c126
<   "observable_rel rel = (\<forall> io s1 . { s2 . (s1,io,s2) \<in> rel } = {} 
---
>   "observable_rel rel = (\<forall> io s1 . { s2 . (s1,io,s2) \<in> rel } = {}
131c131
<   shows "observable (from_rel rel q0)"  (is "observable ?M")  
---
>   shows "observable (from_rel rel q0)"  (is "observable ?M")
142,143c142,143
< abbreviation "OFSM_rel rel q0 \<equiv> well_formed_rel rel 
<                                 \<and> completely_specified_rel_over rel (nodes (from_rel rel q0)) 
---
> abbreviation "OFSM_rel rel q0 \<equiv> well_formed_rel rel
>                                 \<and> completely_specified_rel_over rel (nodes (from_rel rel q0))
150c150
<   
---
> 
170,171c170,171
<     by (meson \<open>0 \<in> nodes M\<^sub>S\<close> \<open>1 \<in> succ M\<^sub>S (0, 0) 0\<close> succ_nodes) 
<     
---
>     by (meson \<open>0 \<in> nodes M\<^sub>S\<close> \<open>1 \<in> succ M\<^sub>S (0, 0) 0\<close> succ_nodes)
> 
176c176
<   ultimately show "nodes M\<^sub>S = {0,1}" 
---
>   ultimately show "nodes M\<^sub>S = {0,1}"
178c178
< next 
---
> next
182,183c182,183
<     by (meson \<open>0 \<in> nodes M\<^sub>I\<close> \<open>1 \<in> succ M\<^sub>I (0, 0) 0\<close> succ_nodes) 
<     
---
>     by (meson \<open>0 \<in> nodes M\<^sub>I\<close> \<open>1 \<in> succ M\<^sub>I (0, 0) 0\<close> succ_nodes)
> 
188c188
<   ultimately show "nodes M\<^sub>I = {0,1}" 
---
>   ultimately show "nodes M\<^sub>I = {0,1}"
191,192c191,192
<     
<   
---
> 
> 
197c197
<   have "well_formed_rel M\<^sub>S_rel" 
---
>   have "well_formed_rel M\<^sub>S_rel"
199c199
<   
---
> 
202,203c202,203
<   proof 
<     fix s1 assume "(s1::nat) \<in> nodes (from_rel M\<^sub>S_rel 0)" 
---
>   proof
>     fix s1 assume "(s1::nat) \<in> nodes (from_rel M\<^sub>S_rel 0)"
208c208
<     ultimately show "\<forall>x\<in>(fst \<circ> fst \<circ> snd) ` M\<^sub>S_rel. 
---
>     ultimately show "\<forall>x\<in>(fst \<circ> fst \<circ> snd) ` M\<^sub>S_rel.
213c213
<   moreover have "observable_rel M\<^sub>S_rel" 
---
>   moreover have "observable_rel M\<^sub>S_rel"
215,216c215,216
<   
<   ultimately have "OFSM_rel M\<^sub>S_rel 0" 
---
> 
>   ultimately have "OFSM_rel M\<^sub>S_rel 0"
221,222c221,222
< next 
<   have "well_formed_rel M\<^sub>I_rel" 
---
> next
>   have "well_formed_rel M\<^sub>I_rel"
224c224
<   
---
> 
227,228c227,228
<   proof 
<     fix s1 assume "(s1::nat) \<in> nodes (from_rel M\<^sub>I_rel 0)" 
---
>   proof
>     fix s1 assume "(s1::nat) \<in> nodes (from_rel M\<^sub>I_rel 0)"
233c233
<     show "\<forall>x\<in>(fst \<circ> fst \<circ> snd) ` M\<^sub>I_rel. 
---
>     show "\<forall>x\<in>(fst \<circ> fst \<circ> snd) ` M\<^sub>I_rel.
235,236c235,236
<       by (meson \<open>completely_specified_rel_over M\<^sub>I_rel (insert 0 ((snd \<circ> snd) ` M\<^sub>I_rel))\<close> 
<           \<open>s1 \<in> insert 0 ((snd \<circ> snd) ` M\<^sub>I_rel)\<close> completely_specified_rel_over.elims(2))    
---
>       by (meson \<open>completely_specified_rel_over M\<^sub>I_rel (insert 0 ((snd \<circ> snd) ` M\<^sub>I_rel))\<close>
>           \<open>s1 \<in> insert 0 ((snd \<circ> snd) ` M\<^sub>I_rel)\<close> completely_specified_rel_over.elims(2))
239c239
<   moreover have "observable_rel M\<^sub>I_rel" 
---
>   moreover have "observable_rel M\<^sub>I_rel"
241,242c241,242
<   
<   ultimately have "OFSM_rel M\<^sub>I_rel 0" 
---
> 
>   ultimately have "OFSM_rel M\<^sub>I_rel 0"
257c257
<   ultimately show "asc_fault_domain M\<^sub>S M\<^sub>I 2" 
---
>   ultimately show "asc_fault_domain M\<^sub>S M\<^sub>I 2"
263c263
<             succ = (\<lambda> a (p1,p2) . (if (p1 \<in> nodes M\<^sub>S \<and> p2 \<in> nodes M\<^sub>I \<and> (fst a \<in> inputs M\<^sub>S) 
---
>             succ = (\<lambda> a (p1,p2) . (if (p1 \<in> nodes M\<^sub>S \<and> p2 \<in> nodes M\<^sub>I \<and> (fst a \<in> inputs M\<^sub>S)
266c266
<                                       then {FAIL\<^sub>I} 
---
>                                       then {FAIL\<^sub>I}
272c272
<           \<rparr>" 
---
>           \<rparr>"
276c276
<   have "inputs M\<^sub>S = inputs M\<^sub>I" 
---
>   have "inputs M\<^sub>S = inputs M\<^sub>I"
282c282
<   ultimately show ?thesis 
---
>   ultimately show ?thesis
290c290
< lemma example_det_state_cover : "is_det_state_cover M\<^sub>S V\<^sub>I" 
---
> lemma example_det_state_cover : "is_det_state_cover M\<^sub>S V\<^sub>I"
292c292
<   have "d_reaches M\<^sub>S (initial M\<^sub>S) [] (initial M\<^sub>S)" 
---
>   have "d_reaches M\<^sub>S (initial M\<^sub>S) [] (initial M\<^sub>S)"
294c294
<   then have "initial M\<^sub>S \<in> d_reachable M\<^sub>S (initial M\<^sub>S)" 
---
>   then have "initial M\<^sub>S \<in> d_reachable M\<^sub>S (initial M\<^sub>S)"
297,298c297,298
<   have "d_reached_by M\<^sub>S (initial M\<^sub>S) [0] 1 [1] [0]" 
<   proof 
---
>   have "d_reached_by M\<^sub>S (initial M\<^sub>S) [0] 1 [1] [0]"
>   proof
300,301c300,301
<     length [0] = length [1] \<and> path M\<^sub>S (([0] || [0]) || [1]) (initial M\<^sub>S) 
<                             \<and> target (([0] || [0]) || [1]) (initial M\<^sub>S) = 1" 
---
>     length [0] = length [1] \<and> path M\<^sub>S (([0] || [0]) || [1]) (initial M\<^sub>S)
>                             \<and> target (([0] || [0]) || [1]) (initial M\<^sub>S) = 1"
303c303
<     
---
> 
305,310c305,310
<        length [0] = length ys2 
<           \<and> length [0] = length tr2 
<           \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S) 
<             \<longrightarrow> target (([0] || ys2) || tr2) (initial M\<^sub>S) = 1" 
<     proof 
<       fix ys2 tr2 assume "length [0] = length ys2 \<and> length [0] = length tr2 
---
>        length [0] = length ys2
>           \<and> length [0] = length tr2
>           \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)
>             \<longrightarrow> target (([0] || ys2) || tr2) (initial M\<^sub>S) = 1"
>     proof
>       fix ys2 tr2 assume "length [0] = length ys2 \<and> length [0] = length tr2
316,318c316,318
<         by (metis One_nat_def \<open>length [0] = length ys2 \<and> length [0] = length tr2 
<             \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)\<close> append.simps(1) append_butlast_last_id 
<             butlast_snoc length_butlast length_greater_0_conv list.size(3) nat.simps(3))  
---
>         by (metis One_nat_def \<open>length [0] = length ys2 \<and> length [0] = length tr2
>             \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)\<close> append.simps(1) append_butlast_last_id
>             butlast_snoc length_butlast length_greater_0_conv list.size(3) nat.simps(3))
321,322c321,322
<         by (metis One_nat_def \<open>length [0] = length ys2 \<and> length [0] = length tr2 
<             \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)\<close> append.simps(1) append_butlast_last_id 
---
>         by (metis One_nat_def \<open>length [0] = length ys2 \<and> length [0] = length tr2
>             \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)\<close> append.simps(1) append_butlast_last_id
324c324
<       ultimately have "path M\<^sub>S [((0,y2),t2)] (initial M\<^sub>S)" 
---
>       ultimately have "path M\<^sub>S [((0,y2),t2)] (initial M\<^sub>S)"
328c328
<       moreover have "\<And> y . succ M\<^sub>S (0,y) (initial M\<^sub>S) \<subseteq> {1}" 
---
>       moreover have "\<And> y . succ M\<^sub>S (0,y) (initial M\<^sub>S) \<subseteq> {1}"
330c330
<       ultimately have "t2 = 1" 
---
>       ultimately have "t2 = 1"
337,339c337,339
<        length [0] = length ys2 \<and> length [0] = length tr2 
<           \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S) 
<             \<longrightarrow> target (([0] || ys2) || tr2) (initial M\<^sub>S) = 1" 
---
>        length [0] = length ys2 \<and> length [0] = length tr2
>           \<and> path M\<^sub>S (([0] || ys2) || tr2) (initial M\<^sub>S)
>             \<longrightarrow> target (([0] || ys2) || tr2) (initial M\<^sub>S) = 1"
343c343
<   then have "d_reaches M\<^sub>S (initial M\<^sub>S) [0] 1" 
---
>   then have "d_reaches M\<^sub>S (initial M\<^sub>S) [0] 1"
345c345
<   then have "1 \<in> d_reachable M\<^sub>S (initial M\<^sub>S)" 
---
>   then have "1 \<in> d_reachable M\<^sub>S (initial M\<^sub>S)"
351c351
<   proof 
---
>   proof
358c358
<   ultimately have "d_reachable M\<^sub>S (initial M\<^sub>S) = {0,1}" 
---
>   ultimately have "d_reachable M\<^sub>S (initial M\<^sub>S) = {0,1}"
376,377c376,377
<         by blast 
<       then have "s = 0 \<or> s = 1" 
---
>         by blast
>       then have "s = 0 \<or> s = 1"
392c392
<   moreover have "V\<^sub>I = image ?f (d_reachable M\<^sub>S (initial M\<^sub>S))" 
---
>   moreover have "V\<^sub>I = image ?f (d_reachable M\<^sub>S (initial M\<^sub>S))"
395c395
<   ultimately show ?thesis 
---
>   ultimately show ?thesis
408c408
<   using example_productF example_det_state_cover by auto  
---
>   using example_productF example_det_state_cover by auto
413c413
< lemma OFSM_not_vacuous : 
---
> lemma OFSM_not_vacuous :
424,425c424,425
<   "\<exists> (M2::(nat,nat,nat) FSM) 
<      (M1::(nat,nat,nat) FSM) 
---
>   "\<exists> (M2::(nat,nat,nat) FSM)
>      (M1::(nat,nat,nat) FSM)
428c428
<      (V::(nat list set)) 
---
>      (V::(nat list set))
436,437c436,437
<   shows "\<exists> (M2::(nat,nat,nat) FSM) 
<            (M1::(nat,nat,nat) FSM) 
---
>   shows "\<exists> (M2::(nat,nat,nat) FSM)
>            (M1::(nat,nat,nat) FSM)
440c440
<            (V::(nat list set)) 
---
>            (V::(nat list set))
442c442
<            (m :: nat) . 
---
>            (m :: nat) .
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Adaptive_State_Counting/ASC/ASC_LB.thy ../../AFPs/afp-2020/thys/Adaptive_State_Counting/ASC/ASC_LB.thy
3c3
< begin 
---
> begin
10c10
< Function @{verbatim LB} calculates a lower bound on the number of states of some FSM in order for 
---
> Function @{verbatim LB} calculates a lower bound on the number of states of some FSM in order for
17,18c17,18
< Function @{verbatim Perm} calculates all possible reactions of an FSM to a set of inputs sequences 
< such that every set in the calculated set of reactions contains exactly one reaction for each input 
---
> Function @{verbatim Perm} calculates all possible reactions of an FSM to a set of inputs sequences
> such that every set in the calculated set of reactions contains exactly one reaction for each input
31,32c31,32
<   obtain f where f_def : "V'' = image f V 
<                                 \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M1 (initial M1) v)" 
---
>   obtain f where f_def : "V'' = image f V
>                                 \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M1 (initial M1) v)"
34,37c34,37
<   then have "f [] = []" 
<     using init_seq by (metis language_state_for_input_empty singleton_iff) 
<   then show ?thesis 
<     using init_seq f_def by (metis image_eqI) 
---
>   then have "f [] = []"
>     using init_seq by (metis language_state_for_input_empty singleton_iff)
>   then show ?thesis
>     using init_seq f_def by (metis image_eqI)
46c46
<   obtain f where "is_det_state_cover_ass M2 f \<and> V = f ` d_reachable M2 (initial M2)" 
---
>   obtain f where "is_det_state_cover_ass M2 f \<and> V = f ` d_reachable M2 (initial M2)"
48c48
<   moreover have "finite (d_reachable M2 (initial M2))" 
---
>   moreover have "finite (d_reachable M2 (initial M2))"
50c50
<     have "finite (nodes M2)" 
---
>     have "finite (nodes M2)"
52c52
<     moreover have "nodes M2 = reachable M2 (initial M2)" 
---
>     moreover have "nodes M2 = reachable M2 (initial M2)"
54c54
<     ultimately have "finite (reachable M2 (initial M2))" 
---
>     ultimately have "finite (reachable M2 (initial M2))"
56c56
<     moreover have "d_reachable M2 (initial M2) \<subseteq> reachable M2 (initial M2)" 
---
>     moreover have "d_reachable M2 (initial M2) \<subseteq> reachable M2 (initial M2)"
58,59c58,59
<     ultimately show ?thesis 
<       using infinite_super by blast 
---
>     ultimately show ?thesis
>       using infinite_super by blast
61c61
<   ultimately have "finite V" 
---
>   ultimately have "finite V"
63,66c63,66
<   moreover obtain f'' where "V'' = image f'' V 
<                               \<and> (\<forall> v \<in> V . f'' v \<in> language_state_for_input M1 (initial M1) v)" 
<     using assms(3) by auto 
<   ultimately show ?thesis 
---
>   moreover obtain f'' where "V'' = image f'' V
>                               \<and> (\<forall> v \<in> V . f'' v \<in> language_state_for_input M1 (initial M1) v)"
>     using assms(3) by auto
>   ultimately show ?thesis
75,76c75,76
<   obtain f where f_def : "V'' = image f V 
<                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)" 
---
>   obtain f where f_def : "V'' = image f V
>                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)"
78c78
<   then obtain v where v_def : "v \<in> V \<and> f v = vs" 
---
>   then obtain v where v_def : "v \<in> V \<and> f v = vs"
80c80
<   then have "vs \<in> language_state_for_input M (initial M) v" 
---
>   then have "vs \<in> language_state_for_input M (initial M) v"
82c82
<   then show ?thesis 
---
>   then show ?thesis
93,94c93,94
<   obtain f where f_def : "V'' = image f V 
<                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)" 
---
>   obtain f where f_def : "V'' = image f V
>                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)"
96c96
<   then obtain v1 v2 where v_def : "v1 \<in> V \<and> f v1 = vs1 \<and> v2 \<in> V \<and> f v2 = vs2" 
---
>   then obtain v1 v2 where v_def : "v1 \<in> V \<and> f v1 = vs1 \<and> v2 \<in> V \<and> f v2 = vs2"
99c99
<             "vs2 \<in> language_state_for_input M (initial M) v2" 
---
>             "vs2 \<in> language_state_for_input M (initial M) v2"
101,103c101,103
<   moreover have "v1 \<noteq> v2" 
<     using v_def assms(4) by blast 
<   ultimately show ?thesis 
---
>   moreover have "v1 \<noteq> v2"
>     using v_def assms(4) by blast
>   ultimately show ?thesis
112,113c112,113
<   obtain f where f_def : "image f V = V'' 
<                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)" 
---
>   obtain f where f_def : "image f V = V''
>                           \<and> (\<forall> v \<in> V . f v \<in> language_state_for_input M (initial M) v)"
115,117c115,117
<   then have "\<exists> v . f v = vs \<and> f v \<in> language_state_for_input M (initial M) v" 
<     using assms(2) by blast 
<   then show ?thesis 
---
>   then have "\<exists> v . f v = vs \<and> f v \<in> language_state_for_input M (initial M) v"
>     using assms(2) by blast
>   then show ?thesis
141c141
<     \<and> applicable_set M2 \<Omega>    
---
>     \<and> applicable_set M2 \<Omega>
155,156c155,156
<   then show "applicable_set M1 \<Omega>" 
<     unfolding applicable_set.simps applicable.simps 
---
>   then show "applicable_set M1 \<Omega>"
>     unfolding applicable_set.simps applicable.simps
163c163
< lemma perm_nonempty : 
---
> lemma perm_nonempty :
170c170
<   have "finite (nodes M2)" 
---
>   have "finite (nodes M2)"
173,174c173,174
<     by auto 
<   ultimately have "finite V" 
---
>     by auto
>   ultimately have "finite V"
176,177c176,177
<     by (metis assms(1) finite_imageI infinite_super is_det_state_cover.elims(2)) 
<   
---
>     by (metis assms(1) finite_imageI infinite_super is_det_state_cover.elims(2))
> 
179c179
<     using assms(1) det_state_cover_empty by blast 
---
>     using assms(1) det_state_cover_empty by blast
186,187c186,187
<       using infinite_subset by auto 
<     then show "Perm VS M1 \<noteq> {}" 
---
>       using infinite_subset by auto
>     then show "Perm VS M1 \<noteq> {}"
195,196c195,196
<       
<       obtain q2 where "d_reaches M2 (initial M2) vs q2" 
---
> 
>       obtain q2 where "d_reaches M2 (initial M2) vs q2"
198,200c198,200
<       then obtain vs' vsP where io_path : "length vs = length vs' 
<                                             \<and> length vs = length vsP 
<                                             \<and> (path M2 ((vs || vs') || vsP) (initial M2)) 
---
>       then obtain vs' vsP where io_path : "length vs = length vs'
>                                             \<and> length vs = length vsP
>                                             \<and> (path M2 ((vs || vs') || vsP) (initial M2))
203,204c203,204
<     
<       have "well_formed M2" 
---
> 
>       have "well_formed M2"
206c206
<       
---
> 
209,211c209,211
<         have "length (vs || vs') = length vsP" 
<           using io_path by simp 
<         then show ?thesis 
---
>         have "length (vs || vs') = length vsP"
>           using io_path by simp
>         then show ?thesis
214c214
<       moreover have "set (map fst (map fst ((vs || vs') || vsP))) \<subseteq> inputs M2" 
---
>       moreover have "set (map fst (map fst ((vs || vs') || vsP))) \<subseteq> inputs M2"
218c218
<       ultimately have "set vs \<subseteq> inputs M2" 
---
>       ultimately have "set vs \<subseteq> inputs M2"
220,221c220,221
<     
<       then have "set vs \<subseteq> inputs M1" 
---
> 
>       then have "set vs \<subseteq> inputs M1"
223,224c223,224
<     
<       then have "L\<^sub>i\<^sub>n M1 {vs} \<noteq> {}" 
---
> 
>       then have "L\<^sub>i\<^sub>n M1 {vs} \<noteq> {}"
226c226
<         by (metis FSM.nodes.initial) 
---
>         by (metis FSM.nodes.initial)
229c229
<       then obtain vs' where "vs' \<in> language_state_for_input M1 (initial M1) vs" 
---
>       then obtain vs' where "vs' \<in> language_state_for_input M1 (initial M1) vs"
235c235
<         moreover obtain f where "f vs = vs'" 
---
>         moreover obtain f where "f vs = vs'"
238c238
<           using Perm.simps \<open>vs' \<in> language_state_for_input M1 (initial M1) vs\<close> by blast     
---
>           using Perm.simps \<open>vs' \<in> language_state_for_input M1 (initial M1) vs\<close> by blast
242c242
<         then obtain F'' where "F'' \<in> Perm F M1" 
---
>         then obtain F'' where "F'' \<in> Perm F M1"
244,245c244,245
<         then obtain f where "F'' = image f F" 
<                             "(\<forall> v \<in> F . f v \<in> language_state_for_input M1 (initial M1) v)" 
---
>         then obtain f where "F'' = image f F"
>                             "(\<forall> v \<in> F . f v \<in> language_state_for_input M1 (initial M1) v)"
248,249c248,249
<         have "\<forall> v \<in> (insert vs F) . ?f v \<in> language_state_for_input M1 (initial M1) v" 
<         proof 
---
>         have "\<forall> v \<in> (insert vs F) . ?f v \<in> language_state_for_input M1 (initial M1) v"
>         proof
255c255
<               using \<open>vs' \<in> language_state_for_input M1 (initial M1) vs\<close> by auto 
---
>               using \<open>vs' \<in> language_state_for_input M1 (initial M1) vs\<close> by auto
261c261
<               using False \<open>\<forall>v\<in>F. f v \<in> language_state_for_input M1 (initial M1) v\<close> by auto 
---
>               using False \<open>\<forall>v\<in>F. f v \<in> language_state_for_input M1 (initial M1) v\<close> by auto
265,266c265,266
<           using Perm.simps by blast 
<         then show ?thesis 
---
>           using Perm.simps by blast
>         then show ?thesis
273c273
<     using \<open>[] \<in> V\<close> by blast 
---
>     using \<open>[] \<in> V\<close> by blast
275c275
<   
---
> 
288c288
<   obtain V'' where "V'' \<in> Perm V M1" 
---
>   obtain V'' where "V'' \<in> Perm V M1"
290,292c290,292
<   then obtain f where "V'' = image f V" 
<                       "(\<forall> v \<in> V . f v \<in> language_state_for_input M1 (initial M1) v)" 
<     by auto  
---
>   then obtain f where "V'' = image f V"
>                       "(\<forall> v \<in> V . f v \<in> language_state_for_input M1 (initial M1) v)"
>     by auto
299c299
<   then have "(image ?f V) \<in> Perm V M1" 
---
>   then have "(image ?f V) \<in> Perm V M1"
302c302
<     by (metis assms(5) fun_upd_same imageI) 
---
>     by (metis assms(5) fun_upd_same imageI)
304c304
<     using that by blast 
---
>     using that by blast
312c312
< Function @{verbatim R} calculates the set of suffixes of a sequence that reach a given state if 
---
> Function @{verbatim R} calculates the set of suffixes of a sequence that reach a given state if
317,318c317,318
< fun R :: "('in, 'out, 'state) FSM \<Rightarrow> 'state \<Rightarrow> ('in \<times> 'out) list 
<           \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list set" 
---
> fun R :: "('in, 'out, 'state) FSM \<Rightarrow> 'state \<Rightarrow> ('in \<times> 'out) list
>           \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list set"
320,321c320,321
<   "R M s vs xs = { vs@xs' | xs' . xs' \<noteq> [] 
<                                 \<and> prefix xs' xs 
---
>   "R M s vs xs = { vs@xs' | xs' . xs' \<noteq> []
>                                 \<and> prefix xs' xs
324c324
< lemma finite_R : "finite (R M s vs xs)" 
---
> lemma finite_R : "finite (R M s vs xs)"
326,333c326,333
<   have "R M s vs xs \<subseteq> { vs @ xs' | xs' .prefix xs' xs }" 
<     by auto 
<   then have "R M s vs xs \<subseteq> image (\<lambda> xs' . vs @ xs') {xs' . prefix xs' xs}" 
<     by auto
<   moreover have "{xs' . prefix xs' xs} = {take n xs | n . n \<le> length xs}" 
<   proof 
<     show "{xs'. prefix xs' xs} \<subseteq> {take n xs |n. n \<le> length xs}" 
<     proof 
---
>   have "R M s vs xs \<subseteq> { vs @ xs' | xs' .prefix xs' xs }"
>     by auto
>   then have "R M s vs xs \<subseteq> image (\<lambda> xs' . vs @ xs') {xs' . prefix xs' xs}"
>     by auto
>   moreover have "{xs' . prefix xs' xs} = {take n xs | n . n \<le> length xs}"
>   proof
>     show "{xs'. prefix xs' xs} \<subseteq> {take n xs |n. n \<le> length xs}"
>     proof
335,339c335,339
<       then obtain zs' where "xs' @ zs' = xs" 
<         by (metis (full_types) mem_Collect_eq prefixE) 
<       then obtain i where "xs' = take i xs \<and> i \<le> length xs" 
<         by (metis (full_types) append_eq_conv_conj le_cases take_all) 
<       then show "xs' \<in> {take n xs |n. n \<le> length xs}" 
---
>       then obtain zs' where "xs' @ zs' = xs"
>         by (metis (full_types) mem_Collect_eq prefixE)
>       then obtain i where "xs' = take i xs \<and> i \<le> length xs"
>         by (metis (full_types) append_eq_conv_conj le_cases take_all)
>       then show "xs' \<in> {take n xs |n. n \<le> length xs}"
342,343c342,343
<     show "{take n xs |n. n \<le> length xs} \<subseteq> {xs'. prefix xs' xs}" 
<       using take_is_prefix by force 
---
>     show "{take n xs |n. n \<le> length xs} \<subseteq> {xs'. prefix xs' xs}"
>       using take_is_prefix by force
347c347
<   ultimately show ?thesis 
---
>   ultimately show ?thesis
358c358
<   have "bij_betw ?f (\<Union> SS) SS" 
---
>   have "bij_betw ?f (\<Union> SS) SS"
360,361c360,361
<   then show ?thesis 
<     using bij_betw_same_card by blast 
---
>   then show ?thesis
>     using bij_betw_same_card by blast
368c368
< shows "card (image f SS) = card SS" 
---
> shows "card (image f SS) = card SS"
370c370
<   from assms(2) have "\<forall> S1 \<in> SS . \<forall> S2 \<in> SS . S1 = S2 \<or> f S1 \<inter> f S2 = {} 
---
>   from assms(2) have "\<forall> S1 \<in> SS . \<forall> S2 \<in> SS . S1 = S2 \<or> f S1 \<inter> f S2 = {}
377c377
<     then have "\<not> (\<exists> y \<in> F . f y = f x)" 
---
>     then have "\<not> (\<exists> y \<in> F . f y = f x)"
379c379
<     then have "f x \<notin> image f F" 
---
>     then have "f x \<notin> image f F"
381c381
<     then have "card (image f (insert x F)) = Suc (card (image f F))" 
---
>     then have "card (image f (insert x F)) = Suc (card (image f F))"
383c383
<     moreover have "card (f ` F) = card F" 
---
>     moreover have "card (f ` F) = card F"
385c385
<     moreover have "card (insert x F) = Suc (card F)" 
---
>     moreover have "card (insert x F) = Suc (card F)"
387c387
<     ultimately show ?case 
---
>     ultimately show ?case
390c390
<   then show ?thesis 
---
>   then show ?thesis
394,396d393
< 
< 
< 
406c403
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
408c405
<   and "distinct (states (xs || tr) (q2,q1))" 
---
>   and "distinct (states (xs || tr) (q2,q1))"
413c410
<   \<comment> \<open>Proof sketch: 
---
>   \<comment> \<open>Proof sketch:
419,420c416,417
<   have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}" 
<   proof 
---
>   have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}"
>   proof
422c419
<     then have "s \<in> io_targets M2 (initial M2) io" 
---
>     then have "s \<in> io_targets M2 (initial M2) io"
424c421
<     moreover have "io \<in> language_state M2 (initial M2)" 
---
>     moreover have "io \<in> language_state M2 (initial M2)"
426,427c423,424
<     ultimately show "io_targets M2 (initial M2) io = {s}" 
<       using assms(3) io_targets_observable_singleton_ex by (metis singletonD) 
---
>     ultimately show "io_targets M2 (initial M2) io = {s}"
>       using assms(3) io_targets_observable_singleton_ex by (metis singletonD)
430c427
<   moreover have "\<forall> io \<in> R M2 s vs xs . io_targets PM (initial PM) io 
---
>   moreover have "\<forall> io \<in> R M2 s vs xs . io_targets PM (initial PM) io
432,434c429,431
<   proof 
<     fix io assume io_assm : "io \<in> R M2 s vs xs" 
<     then have io_prefix : "prefix io (vs @ xs)" 
---
>   proof
>     fix io assume io_assm : "io \<in> R M2 s vs xs"
>     then have io_prefix : "prefix io (vs @ xs)"
436,438c433,435
<     then have io_lang_subs : "io \<in> L M1 \<and> io \<in> L M2" 
<       using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split) 
<     then have io_lang_inter : "io \<in> L M1 \<inter> L M2" 
---
>     then have io_lang_subs : "io \<in> L M1 \<and> io \<in> L M2"
>       using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split)
>     then have io_lang_inter : "io \<in> L M1 \<inter> L M2"
440,442c437,439
<     then have io_lang_pm : "io \<in> L PM" 
<       using productF_language assms by blast 
<     moreover obtain p2 p1 where "(p2,p1) \<in> io_targets PM (initial PM) io" 
---
>     then have io_lang_pm : "io \<in> L PM"
>       using productF_language assms by blast
>     moreover obtain p2 p1 where "(p2,p1) \<in> io_targets PM (initial PM) io"
444,448c441,445
<           io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI) 
<     ultimately have targets_pm : "io_targets PM (initial PM) io = {(p2,p1)}" 
<       using assms io_targets_observable_singleton_ex singletonD by (metis observable_productF) 
<     then obtain trP where trP_def : "target (io || trP) (initial PM) = (p2,p1) 
<                                       \<and> path PM (io || trP) (initial PM) 
---
>           io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI)
>     ultimately have targets_pm : "io_targets PM (initial PM) io = {(p2,p1)}"
>       using assms io_targets_observable_singleton_ex singletonD by (metis observable_productF)
>     then obtain trP where trP_def : "target (io || trP) (initial PM) = (p2,p1)
>                                       \<and> path PM (io || trP) (initial PM)
451,452c448,449
<         assume a1: "\<And>trP. target (io || trP) (initial PM) = (p2, p1) 
<                             \<and> path PM (io || trP) (initial PM) 
---
>         assume a1: "\<And>trP. target (io || trP) (initial PM) = (p2, p1)
>                             \<and> path PM (io || trP) (initial PM)
454c451
<         have "\<exists>ps. target (io || ps) (initial PM) = (p2, p1) 
---
>         have "\<exists>ps. target (io || ps) (initial PM) = (p2, p1)
459,462c456,459
<       qed 
<       then have trP_unique : "{ tr . path PM (io || tr) (initial PM) \<and> length io = length tr } 
<                               = { trP }" 
<         using observable_productF observable_path_unique_ex[of PM io "initial PM"] 
---
>       qed
>       then have trP_unique : "{ tr . path PM (io || tr) (initial PM) \<and> length io = length tr }
>                               = { trP }"
>         using observable_productF observable_path_unique_ex[of PM io "initial PM"]
466c463
<           f1: "{ps. path PM (io || ps) (initial PM) \<and> length io = length ps} = {pps} 
---
>           f1: "{ps. path PM (io || ps) (initial PM) \<and> length io = length ps} = {pps}
468,470c465,467
<           by (metis (no_types) \<open>\<And>thesis. \<lbrakk>observable PM; io \<in> L PM; \<And>tr. 
<                                           {t. path PM (io || t) (initial PM) 
<                                           \<and> length io = length t} = {tr} \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close> 
---
>           by (metis (no_types) \<open>\<And>thesis. \<lbrakk>observable PM; io \<in> L PM; \<And>tr.
>                                           {t. path PM (io || t) (initial PM)
>                                           \<and> length io = length t} = {tr} \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close>
479,482c476,479
<      
<     
<     obtain trIO2 where trIO2_def : "{tr . path M2 (io||tr) (initial M2) \<and> length io = length tr} 
<                                     = { trIO2 }" 
---
> 
> 
>     obtain trIO2 where trIO2_def : "{tr . path M2 (io||tr) (initial M2) \<and> length io = length tr}
>                                     = { trIO2 }"
484,485c481,482
<     obtain trIO1 where trIO1_def : "{tr . path M1 (io||tr) (initial M1) \<and> length io = length tr} 
<                                     = { trIO1 }" 
---
>     obtain trIO1 where trIO1_def : "{tr . path M1 (io||tr) (initial M1) \<and> length io = length tr}
>                                     = { trIO1 }"
488,489c485,486
<     have "path PM (io || trIO2 || trIO1) (initial M2, initial M1) 
<           \<and> length io = length trIO2 
---
>     have "path PM (io || trIO2 || trIO1) (initial M2, initial M1)
>           \<and> length io = length trIO2
492c489
<       have f1: "path M2 (io || trIO2) (initial M2) \<and> length io = length trIO2" 
---
>       have f1: "path M2 (io || trIO2) (initial M2) \<and> length io = length trIO2"
494c491
<       have f2: "path M1 (io || trIO1) (initial M1) \<and> length io = length trIO1" 
---
>       have f2: "path M1 (io || trIO1) (initial M1) \<and> length io = length trIO1"
498c495
<       then show ?thesis 
---
>       then show ?thesis
500,512c497,509
<     qed 
<     then have trP_split : "path PM (io || trIO2 || trIO1) (initial PM) 
<                             \<and> length io = length trIO2 
<                             \<and> length trIO2 = length trIO1" 
<       using assms(7) by auto 
<     then have trP_zip : "trIO2 || trIO1 = trP" 
<       using trP_def trP_unique using length_zip by fastforce 
< 
<     have "target (io || trIO2) (initial M2) = p2 
<           \<and> path M2 (io || trIO2) (initial M2) 
<           \<and> length io = length trIO2" 
<       using trP_zip trP_split assms(7) trP_def trIO2_def by auto 
<     then have "p2 \<in> io_targets M2 (initial M2) io" 
---
>     qed
>     then have trP_split : "path PM (io || trIO2 || trIO1) (initial PM)
>                             \<and> length io = length trIO2
>                             \<and> length trIO2 = length trIO1"
>       using assms(7) by auto
>     then have trP_zip : "trIO2 || trIO1 = trP"
>       using trP_def trP_unique using length_zip by fastforce
> 
>     have "target (io || trIO2) (initial M2) = p2
>           \<and> path M2 (io || trIO2) (initial M2)
>           \<and> length io = length trIO2"
>       using trP_zip trP_split assms(7) trP_def trIO2_def by auto
>     then have "p2 \<in> io_targets M2 (initial M2) io"
514,515c511,512
<     then have targets_2 : "io_targets M2 (initial M2) io = {p2}" 
<       by (metis state_component_2 io_assm singletonD)   
---
>     then have targets_2 : "io_targets M2 (initial M2) io = {p2}"
>       by (metis state_component_2 io_assm singletonD)
517,521c514,518
<     have "target (io || trIO1) (initial M1) = p1 
<             \<and> path M1 (io || trIO1) (initial M1) 
<             \<and> length io = length trIO1" 
<       using trP_zip trP_split assms(7) trP_def trIO1_def by auto 
<     then have "p1 \<in> io_targets M1 (initial M1) io" 
---
>     have "target (io || trIO1) (initial M1) = p1
>             \<and> path M1 (io || trIO1) (initial M1)
>             \<and> length io = length trIO1"
>       using trP_zip trP_split assms(7) trP_def trIO1_def by auto
>     then have "p1 \<in> io_targets M1 (initial M1) io"
523,524c520,521
<     then have targets_1 : "io_targets M1 (initial M1) io = {p1}" 
<       by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD) 
---
>     then have targets_1 : "io_targets M1 (initial M1) io = {p1}"
>       by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD)
526c523
<     have "io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io = {(p2,p1)}" 
---
>     have "io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io = {(p2,p1)}"
528,529c525,526
<     then show "io_targets PM (initial PM) io 
<                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io" 
---
>     then show "io_targets PM (initial PM) io
>                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io"
533,534c530,531
<   ultimately have state_components : "\<forall> io \<in> R M2 s vs xs . io_targets PM (initial PM) io 
<                                       = {s} \<times> io_targets M1 (initial M1) io" 
---
>   ultimately have state_components : "\<forall> io \<in> R M2 s vs xs . io_targets PM (initial PM) io
>                                       = {s} \<times> io_targets M1 (initial M1) io"
537,538c534,535
<   then have "\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)) 
<               = \<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (R M2 s vs xs))" 
---
>   then have "\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))
>               = \<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (R M2 s vs xs))"
540,541c537,538
<   then have "\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)) 
<               = {s} \<times> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))" 
---
>   then have "\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))
>               = {s} \<times> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))"
543,544c540,541
<   then have "card (\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))) 
<               = card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))" 
---
>   then have "card (\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)))
>               = card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))"
547c544
<   moreover have "card (\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))) 
---
>   moreover have "card (\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)))
550c547
<     assume assm : "card (UNION (R M2 s vs xs) (io_targets PM (initial PM))) \<noteq> card (R M2 s vs xs)"
---
>     assume assm : "card (\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) ) \<noteq> card (R M2 s vs xs)"
552,555c549,552
<     have "\<forall> io \<in> R M2 s vs xs . io \<in> L PM" 
<     proof 
<       fix io assume io_assm : "io \<in> R M2 s vs xs" 
<       then have "prefix io (vs @ xs)" 
---
>     have "\<forall> io \<in> R M2 s vs xs . io \<in> L PM"
>     proof
>       fix io assume io_assm : "io \<in> R M2 s vs xs"
>       then have "prefix io (vs @ xs)"
557,565c554,562
<       then have "io \<in> L M1 \<and> io \<in> L M2" 
<         using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split) 
<       then show "io \<in> L PM" 
<         using productF_language assms by blast 
<     qed
<     then have singletons : "\<forall> io \<in> R M2 s vs xs . (\<exists> t . io_targets PM (initial PM) io = {t})" 
<       using io_targets_observable_singleton_ex observable_productF assms by metis 
<     then have card_targets : "card (UNION (R M2 s vs xs) (io_targets PM (initial PM))) 
<                               = card (image (io_targets PM (initial PM)) (R M2 s vs xs))" 
---
>       then have "io \<in> L M1 \<and> io \<in> L M2"
>         using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split)
>       then show "io \<in> L PM"
>         using productF_language assms by blast
>     qed
>     then have singletons : "\<forall> io \<in> R M2 s vs xs . (\<exists> t . io_targets PM (initial PM) io = {t})"
>       using io_targets_observable_singleton_ex observable_productF assms by metis
>     then have card_targets : "card (\<Union>(io_targets PM (initial PM) ` R M2 s vs xs))
>                               = card (image (io_targets PM (initial PM)) (R M2 s vs xs))"
567c564
<             [of "image (io_targets PM (initial PM)) (R M2 s vs xs)"] 
---
>             [of "image (io_targets PM (initial PM)) (R M2 s vs xs)"]
569,570c566,567
<     
<     moreover have "card (image (io_targets PM (initial PM)) (R M2 s vs xs)) \<le> card (R M2 s vs xs)" 
---
> 
>     moreover have "card (image (io_targets PM (initial PM)) (R M2 s vs xs)) \<le> card (R M2 s vs xs)"
572,574c569,571
<     ultimately have card_le : "card (UNION (R M2 s vs xs) (io_targets PM (initial PM))) 
<                                 < card (R M2 s vs xs)" 
<       using assm by linarith 
---
>     ultimately have card_le : "card (\<Union>(io_targets PM (initial PM) ` R M2 s vs xs))
>                                 < card (R M2 s vs xs)"
>       using assm by linarith
576,577c573,574
<     have "\<exists> io1 \<in> (R M2 s vs xs) . \<exists> io2 \<in> (R M2 s vs xs) . io1 \<noteq> io2 
<             \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}"  
---
>     have "\<exists> io1 \<in> (R M2 s vs xs) . \<exists> io2 \<in> (R M2 s vs xs) . io1 \<noteq> io2
>             \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}"
579c576
<       assume "\<not> (\<exists>io1\<in>R M2 s vs xs. \<exists>io2\<in>R M2 s vs xs. io1 \<noteq> io2 
---
>       assume "\<not> (\<exists>io1\<in>R M2 s vs xs. \<exists>io2\<in>R M2 s vs xs. io1 \<noteq> io2
581,582c578,579
<       then have "\<forall>io1\<in>R M2 s vs xs. \<forall>io2\<in>R M2 s vs xs. io1 = io2 
<                   \<or> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 = {}" 
---
>       then have "\<forall>io1\<in>R M2 s vs xs. \<forall>io2\<in>R M2 s vs xs. io1 = io2
>                   \<or> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 = {}"
584c581
<       moreover have "\<forall>io\<in>R M2 s vs xs. io_targets PM (initial PM) io \<noteq> {}" 
---
>       moreover have "\<forall>io\<in>R M2 s vs xs. io_targets PM (initial PM) io \<noteq> {}"
586,587c583,584
<       ultimately have "card (image (io_targets PM (initial PM)) (R M2 s vs xs)) 
<                         = card (R M2 s vs xs)" 
---
>       ultimately have "card (image (io_targets PM (initial PM)) (R M2 s vs xs))
>                         = card (R M2 s vs xs)"
589,592c586,589
<               [of "R M2 s vs xs" "(io_targets PM (initial PM))"] 
<         by blast 
<       then show "False" 
<         using card_le card_targets by linarith 
---
>               [of "R M2 s vs xs" "(io_targets PM (initial PM))"]
>         by blast
>       then show "False"
>         using card_le card_targets by linarith
595,598c592,595
<     then have "\<exists> io1 io2 . io1 \<in> (R M2 s vs xs) 
<                             \<and> io2 \<in> (R M2 s vs xs) 
<                             \<and> io1 \<noteq> io2 
<                             \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}" 
---
>     then have "\<exists> io1 io2 . io1 \<in> (R M2 s vs xs)
>                             \<and> io2 \<in> (R M2 s vs xs)
>                             \<and> io1 \<noteq> io2
>                             \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}"
600c597
<     moreover have "\<forall> io1 io2 . (io1 \<in> (R M2 s vs xs) \<and> io2 \<in> (R M2 s vs xs) \<and> io1 \<noteq> io2) 
---
>     moreover have "\<forall> io1 io2 . (io1 \<in> (R M2 s vs xs) \<and> io2 \<in> (R M2 s vs xs) \<and> io1 \<noteq> io2)
603c600
<       assume " \<not> (\<forall>io1 io2. io1 \<in> R M2 s vs xs \<and> io2 \<in> R M2 s vs xs \<and> io1 \<noteq> io2 
---
>       assume " \<not> (\<forall>io1 io2. io1 \<in> R M2 s vs xs \<and> io2 \<in> R M2 s vs xs \<and> io1 \<noteq> io2
605,608c602,605
<       then obtain io1 io2 where io_def : "io1 \<in> R M2 s vs xs 
<                                           \<and> io2 \<in> R M2 s vs xs 
<                                           \<and> io1 \<noteq> io2 
<                                           \<and> length io1 = length io2" 
---
>       then obtain io1 io2 where io_def : "io1 \<in> R M2 s vs xs
>                                           \<and> io2 \<in> R M2 s vs xs
>                                           \<and> io1 \<noteq> io2
>                                           \<and> length io1 = length io2"
610c607
<       then have "prefix io1 (vs @ xs) \<and> prefix io2 (vs @ xs)" 
---
>       then have "prefix io1 (vs @ xs) \<and> prefix io2 (vs @ xs)"
612,614c609,611
<       then have "io1 = take (length io1) (vs @ xs) \<and> io2 = take (length io2) (vs @ xs)" 
<         by (metis append_eq_conv_conj prefixE) 
<       then show "False" 
---
>       then have "io1 = take (length io1) (vs @ xs) \<and> io2 = take (length io2) (vs @ xs)"
>         by (metis append_eq_conv_conj prefixE)
>       then show "False"
617,622c614,619
<   
<     ultimately obtain io1 io2 where rep_ios_def : 
<       "io1 \<in> (R M2 s vs xs) 
<         \<and> io2 \<in> (R M2 s vs xs) 
<         \<and> length io1 < length io2 
<         \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}" 
---
> 
>     ultimately obtain io1 io2 where rep_ios_def :
>       "io1 \<in> (R M2 s vs xs)
>         \<and> io2 \<in> (R M2 s vs xs)
>         \<and> length io1 < length io2
>         \<and> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 \<noteq> {}"
627c624
<       assume a1: "\<And>rep. (s, rep) \<in> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2 
---
>       assume a1: "\<And>rep. (s, rep) \<in> io_targets PM (initial PM) io1 \<inter> io_targets PM (initial PM) io2
635c632
<     then have rep_state : "io_targets PM (initial PM) io1 = {(s,rep)} 
---
>     then have rep_state : "io_targets PM (initial PM) io1 = {(s,rep)}
638,642c635,639
<     
<     obtain io1X io2X where rep_ios_split : "io1 = vs @ io1X 
<                                             \<and> prefix io1X xs 
<                                             \<and> io2 = vs @ io2X 
<                                             \<and> prefix io2X xs" 
---
> 
>     obtain io1X io2X where rep_ios_split : "io1 = vs @ io1X
>                                             \<and> prefix io1X xs
>                                             \<and> io2 = vs @ io2X
>                                             \<and> prefix io2X xs"
644c641
<     then have "length io1 > length vs" 
---
>     then have "length io1 > length vs"
647c644
<     
---
> 
653,655c650,652
<       by (meson language_state_prefix) 
<     then obtain trV where trV_def : "{tr . path PM (vs || tr) (initial PM) \<and> length vs = length tr} 
<                                       = { trV }" 
---
>       by (meson language_state_prefix)
>     then obtain trV where trV_def : "{tr . path PM (vs || tr) (initial PM) \<and> length vs = length tr}
>                                       = { trV }"
657c654
<             assms(2) assms(3) assms(7) observable_productF 
---
>             assms(2) assms(3) assms(7) observable_productF
660,661c657,658
<     
<     have "?qv \<in> io_targets PM (initial PM) vs" 
---
> 
>     have "?qv \<in> io_targets PM (initial PM) vs"
663c660
<     then have qv_simp[simp] : "?qv = (q2,q1)" 
---
>     then have qv_simp[simp] : "?qv = (q2,q1)"
665,666c662,664
<     then have "?qv \<in> nodes PM" 
<       using trV_def assms by blast  
---
>     then have "?qv \<in> nodes PM"
>       using trV_def assms by blast
> 
668d665
<     
670,673c667,670
<     
<     obtain tr1X_all where tr1X_all_def : "path PM (vs @ io1X || tr1X_all) (initial PM) 
<                                           \<and> length (vs @ io1X) = length tr1X_all" 
<       using rep_ios_def rep_ios_split by auto 
---
> 
>     obtain tr1X_all where tr1X_all_def : "path PM (vs @ io1X || tr1X_all) (initial PM)
>                                           \<and> length (vs @ io1X) = length tr1X_all"
>       using rep_ios_def rep_ios_split by auto
675c672
<     have "take (length vs) tr1X_all = trV" 
---
>     have "take (length vs) tr1X_all = trV"
677,678c674,675
<       have "path PM (vs || take (length vs) tr1X_all) (initial PM) 
<             \<and> length vs = length (take (length vs) tr1X_all)" 
---
>       have "path PM (vs || take (length vs) tr1X_all) (initial PM)
>             \<and> length vs = length (take (length vs) tr1X_all)"
680c677
<         by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj 
---
>         by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj
682c679
<       then show "take (length vs) tr1X_all = trV" 
---
>       then show "take (length vs) tr1X_all = trV"
687c684
<       have "length tr1X_all = length vs + length io1X" 
---
>       have "length tr1X_all = length vs + length io1X"
689c686
<       then have "length io1X = length tr1X_all - length vs" 
---
>       then have "length io1X = length tr1X_all - length vs"
691,692c688,689
<       then show ?thesis 
<         by (metis (no_types) FSM.path_append_elim \<open>take (length vs) tr1X_all = trV\<close> 
---
>       then show ?thesis
>         by (metis (no_types) FSM.path_append_elim \<open>take (length vs) tr1X_all = trV\<close>
694,695c691,692
<     qed  
<     then have io1X_lang : "io1X \<in> language_state PM ?qv" 
---
>     qed
>     then have io1X_lang : "io1X \<in> language_state PM ?qv"
697,700c694,697
<     then obtain tr1X' where tr1X'_def : "{tr . path PM (io1X || tr) ?qv \<and> length io1X = length tr} 
<                                           = { tr1X' }" 
<       using observable_path_unique_ex[of PM io1X ?qv] 
<             assms(2) assms(3) assms(7) observable_productF 
---
>     then obtain tr1X' where tr1X'_def : "{tr . path PM (io1X || tr) ?qv \<and> length io1X = length tr}
>                                           = { tr1X' }"
>       using observable_path_unique_ex[of PM io1X ?qv]
>             assms(2) assms(3) assms(7) observable_productF
702c699
<     moreover have "?tr1X \<in> { tr . path PM (io1X || tr) ?qv \<and> length io1X = length tr }" 
---
>     moreover have "?tr1X \<in> { tr . path PM (io1X || tr) ?qv \<and> length io1X = length tr }"
704c701
<     ultimately have tr1x_unique : "tr1X' = ?tr1X" 
---
>     ultimately have tr1x_unique : "tr1X' = ?tr1X"
706,707c703,704
<  
<     \<comment> \<open>get a path using io2X from the state reached by vs in PM\<close> 
---
> 
>     \<comment> \<open>get a path using io2X from the state reached by vs in PM\<close>
710,711c707,708
<                                           \<and> length (vs @ io2X) = length tr2X_all" 
<       using rep_ios_def rep_ios_split by auto 
---
>                                           \<and> length (vs @ io2X) = length tr2X_all"
>       using rep_ios_def rep_ios_split by auto
713c710
<     have "take (length vs) tr2X_all = trV" 
---
>     have "take (length vs) tr2X_all = trV"
715,716c712,713
<       have "path PM (vs || take (length vs) tr2X_all) (initial PM) 
<             \<and> length vs = length (take (length vs) tr2X_all)" 
---
>       have "path PM (vs || take (length vs) tr2X_all) (initial PM)
>             \<and> length vs = length (take (length vs) tr2X_all)"
718c715
<         by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj 
---
>         by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj
720c717
<       then show "take (length vs) tr2X_all = trV" 
---
>       then show "take (length vs) tr2X_all = trV"
725c722
<       have "length tr2X_all = length vs + length io2X" 
---
>       have "length tr2X_all = length vs + length io2X"
727c724
<       then have "length io2X = length tr2X_all - length vs" 
---
>       then have "length io2X = length tr2X_all - length vs"
729c726
<       then show ?thesis 
---
>       then show ?thesis
732c729
<     qed  
---
>     qed
734,735c731,732
<     then obtain tr2X' where tr2X'_def : "{tr . path PM (io2X || tr) ?qv \<and> length io2X = length tr} 
<                                           = { tr2X' }" 
---
>     then obtain tr2X' where tr2X'_def : "{tr . path PM (io2X || tr) ?qv \<and> length io2X = length tr}
>                                           = { tr2X' }"
738c735
<     moreover have "?tr2X \<in> { tr . path PM (io2X || tr) ?qv \<and> length io2X = length tr }" 
---
>     moreover have "?tr2X \<in> { tr . path PM (io2X || tr) ?qv \<and> length io2X = length tr }"
740c737
<     ultimately have tr2x_unique : "tr2X' = ?tr2X" 
---
>     ultimately have tr2x_unique : "tr2X' = ?tr2X"
745c742
<     have "io_targets PM (initial PM) (vs @ io1X) = {(s,rep)}" 
---
>     have "io_targets PM (initial PM) (vs @ io1X) = {(s,rep)}"
747,753c744,750
<     moreover have "io_targets PM (initial PM) vs = {?qv}" 
<       using assms(8) by auto 
<     ultimately have rep_via_1 : "io_targets PM ?qv io1X = {(s,rep)}" 
<       by (meson obs_PM observable_io_targets_split) 
<     then have rep_tgt_1 : "target (io1X || tr1X') ?qv = (s,rep)" 
<       using obs_PM observable_io_target_unique_target[of PM ?qv io1X "(s,rep)"] tr1X'_def by blast 
<     have length_1 : "length (io1X || tr1X') > 0" 
---
>     moreover have "io_targets PM (initial PM) vs = {?qv}"
>       using assms(8) by auto
>     ultimately have rep_via_1 : "io_targets PM ?qv io1X = {(s,rep)}"
>       by (meson obs_PM observable_io_targets_split)
>     then have rep_tgt_1 : "target (io1X || tr1X') ?qv = (s,rep)"
>       using obs_PM observable_io_target_unique_target[of PM ?qv io1X "(s,rep)"] tr1X'_def by blast
>     have length_1 : "length (io1X || tr1X') > 0"
755,757c752,754
<     
<     have tr1X_alt_def : "tr1X' = take (length io1X) tr" 
<       by (metis (no_types) assms(10) assms(9) obs_PM observable_path_prefix qv_simp 
---
> 
>     have tr1X_alt_def : "tr1X' = take (length io1X) tr"
>       by (metis (no_types) assms(10) assms(9) obs_PM observable_path_prefix qv_simp
759c756
<     moreover have "io1X = take (length io1X) xs" 
---
>     moreover have "io1X = take (length io1X) xs"
761,762c758,759
<     ultimately have "(io1X || tr1X') = take (length io1X) (xs || tr)" 
<       by (metis take_zip) 
---
>     ultimately have "(io1X || tr1X') = take (length io1X) (xs || tr)"
>       by (metis take_zip)
765c762
<           nat_le_linear take_all tr1X_def tr1x_unique) 
---
>           nat_le_linear take_all tr1X_def tr1x_unique)
767,768c764,765
<       by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_1 length_1 
<           less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr1X_def tr1x_unique) 
---
>       by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_1 length_1
>           less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr1X_def tr1x_unique)
771c768
<     have "io_targets PM (initial PM) (vs @ io2X) = {(s,rep)}" 
---
>     have "io_targets PM (initial PM) (vs @ io2X) = {(s,rep)}"
773,779c770,776
<     moreover have "io_targets PM (initial PM) vs = {?qv}" 
<       using assms(8) by auto 
<     ultimately have rep_via_2 : "io_targets PM ?qv io2X = {(s,rep)}" 
<       by (meson obs_PM observable_io_targets_split) 
<     then have rep_tgt_2 : "target (io2X || tr2X') ?qv = (s,rep)" 
<       using obs_PM observable_io_target_unique_target[of PM ?qv io2X "(s,rep)"] tr2X'_def by blast 
<     moreover have length_2 : "length (io2X || tr2X') > 0" 
---
>     moreover have "io_targets PM (initial PM) vs = {?qv}"
>       using assms(8) by auto
>     ultimately have rep_via_2 : "io_targets PM ?qv io2X = {(s,rep)}"
>       by (meson obs_PM observable_io_targets_split)
>     then have rep_tgt_2 : "target (io2X || tr2X') ?qv = (s,rep)"
>       using obs_PM observable_io_target_unique_target[of PM ?qv io2X "(s,rep)"] tr2X'_def by blast
>     moreover have length_2 : "length (io2X || tr2X') > 0"
781,782c778,779
<     
<     have tr2X_alt_def : "tr2X' = take (length io2X) tr" 
---
> 
>     have tr2X_alt_def : "tr2X' = take (length io2X) tr"
784c781
<     moreover have "io2X = take (length io2X) xs" 
---
>     moreover have "io2X = take (length io2X) xs"
786,789c783,786
<     ultimately have "(io2X || tr2X') = take (length io2X) (xs || tr)" 
<       by (metis take_zip) 
<     moreover have "length (xs || tr) \<ge> length (io2X || tr2X')" 
<       using calculation by auto 
---
>     ultimately have "(io2X || tr2X') = take (length io2X) (xs || tr)"
>       by (metis take_zip)
>     moreover have "length (xs || tr) \<ge> length (io2X || tr2X')"
>       using calculation by auto
791,792c788,789
<       by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_2 length_2 
<           less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr2X_def tr2x_unique) 
---
>       by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_2 length_2
>           less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr2X_def tr2x_unique)
797,800c794,797
<     have "length io1X \<noteq> length io2X" 
<       by (metis \<open>io1X = take (length io1X) xs\<close> \<open>io2X = take (length io2X) xs\<close> less_irrefl 
<           rep_ios_def rep_ios_split) 
<     moreover have "(states (xs || tr) ?qv) ! ((length io1X) - 1) 
---
>     have "length io1X \<noteq> length io2X"
>       by (metis \<open>io1X = take (length io1X) xs\<close> \<open>io2X = take (length io2X) xs\<close> less_irrefl
>           rep_ios_def rep_ios_split)
>     moreover have "(states (xs || tr) ?qv) ! ((length io1X) - 1)
803,811c800,808
<     ultimately have "\<not> (distinct (states (xs || tr) ?qv))" 
<       by (metis Suc_less_eq \<open>io1X = take (length io1X) xs\<close> 
<           \<open>io1X || tr1X' = take (length io1X) (xs || tr)\<close> \<open>io2X = take (length io2X) xs\<close> 
<           \<open>io2X || tr2X' = take (length io2X) (xs || tr)\<close> 
<           \<open>length (io1X || tr1X') \<le> length (xs || tr)\<close> \<open>length (io2X || tr2X') \<le> length (xs || tr)\<close> 
<           assms(10) diff_Suc_1 distinct_conv_nth gr0_conv_Suc le_imp_less_Suc length_1 length_2 
<           length_take map_snd_zip scan_length states_alt_def) 
<     then show "False" 
<       by (metis assms(11) states_alt_def) 
---
>     ultimately have "\<not> (distinct (states (xs || tr) ?qv))"
>       by (metis Suc_less_eq \<open>io1X = take (length io1X) xs\<close>
>           \<open>io1X || tr1X' = take (length io1X) (xs || tr)\<close> \<open>io2X = take (length io2X) xs\<close>
>           \<open>io2X || tr2X' = take (length io2X) (xs || tr)\<close>
>           \<open>length (io1X || tr1X') \<le> length (xs || tr)\<close> \<open>length (io2X || tr2X') \<le> length (xs || tr)\<close>
>           assms(10) diff_Suc_1 distinct_conv_nth gr0_conv_Suc le_imp_less_Suc length_1 length_2
>           length_take map_snd_zip scan_length states_alt_def)
>     then show "False"
>       by (metis assms(11) states_alt_def)
814,816c811,813
<   ultimately show ?thesis 
<     by linarith 
< qed 
---
>   ultimately show ?thesis
>     by linarith
> qed
820,821c817,818
< lemma R_state_component_2 :  
<   assumes "io \<in> (R M2 s vs xs)" 
---
> lemma R_state_component_2 :
>   assumes "io \<in> (R M2 s vs xs)"
823c820
< shows "io_targets M2 (initial M2) io = {s}" 
---
> shows "io_targets M2 (initial M2) io = {s}"
825c822
<   have "s \<in> io_targets M2 (initial M2) io" 
---
>   have "s \<in> io_targets M2 (initial M2) io"
827c824
<   moreover have "io \<in> language_state M2 (initial M2)" 
---
>   moreover have "io \<in> language_state M2 (initial M2)"
829,830c826,827
<   ultimately show "io_targets M2 (initial M2) io = {s}" 
<     using assms(2) io_targets_observable_singleton_ex by (metis singletonD) 
---
>   ultimately show "io_targets M2 (initial M2) io = {s}"
>     using assms(2) io_targets_observable_singleton_ex by (metis singletonD)
845c842
<   have "finite (nodes M2)" 
---
>   have "finite (nodes M2)"
848,850c845,847
<   have R_update : "\<And> q . R M2 q io (xs@[x]) = (if (q \<in> io_targets M2 (initial M2) (io @ xs @ [x])) 
<                                     then insert (io@xs@[x]) (R M2 q io xs)   
<                                     else R M2 q io xs)" 
---
>   have R_update : "\<And> q . R M2 q io (xs@[x]) = (if (q \<in> io_targets M2 (initial M2) (io @ xs @ [x]))
>                                     then insert (io@xs@[x]) (R M2 q io xs)
>                                     else R M2 q io xs)"
854c851
<     by (meson assms(1) io_targets_observable_singleton_ex snoc.prems(2)) 
---
>     by (meson assms(1) io_targets_observable_singleton_ex snoc.prems(2))
856c853
<   then have "R M2 q io (xs@[x]) = insert (io@xs@[x]) (R M2 q io xs)" 
---
>   then have "R M2 q io (xs@[x]) = insert (io@xs@[x]) (R M2 q io xs)"
858c855
<   moreover have "(io@xs@[x]) \<notin> (R M2 q io xs)" 
---
>   moreover have "(io@xs@[x]) \<notin> (R M2 q io xs)"
861c858
<     by (metis card_insert_disjoint finite_R) 
---
>     by (metis card_insert_disjoint finite_R)
864,865c861,862
<     by (metis (full_types) FSM.nodes.initial \<open>io_targets M2 (initial M2) (io@xs @ [x]) = {q}\<close> 
<         insertI1 io_targets_nodes) 
---
>     by (metis (full_types) FSM.nodes.initial \<open>io_targets M2 (initial M2) (io@xs @ [x]) = {q}\<close>
>         insertI1 io_targets_nodes)
867c864
<   have "\<forall> q' . q' \<noteq> q \<longrightarrow> R M2 q' io (xs@[x]) = R M2 q' io xs" 
---
>   have "\<forall> q' . q' \<noteq> q \<longrightarrow> R M2 q' io (xs@[x]) = R M2 q' io xs"
869,870c866,867
<     by auto  
<   then have "\<forall> q' . q' \<noteq> q \<longrightarrow> card (R M2 q' io (xs@[x])) = card (R M2 q' io xs)" 
---
>     by auto
>   then have "\<forall> q' . q' \<noteq> q \<longrightarrow> card (R M2 q' io (xs@[x])) = card (R M2 q' io xs)"
873c870
<   then have "(\<Sum>q\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x]))) 
---
>   then have "(\<Sum>q\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x])))
876,878c873,875
<   moreover have "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x]))) 
<                   = (\<Sum>q\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x]))) + (card (R M2 q io (xs@[x])))" 
<                 "(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) 
---
>   moreover have "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x])))
>                   = (\<Sum>q\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x]))) + (card (R M2 q io (xs@[x])))"
>                 "(\<Sum>q\<in>nodes M2. card (R M2 q io xs))
883c880
<     then show "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x]))) 
---
>     then show "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x])))
885c882
<               "(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) 
---
>               "(\<Sum>q\<in>nodes M2. card (R M2 q io xs))
888,891c885,888
<   qed 
<   ultimately have "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x]))) 
<                     = Suc (\<Sum>q\<in>nodes M2. card (R M2 q io xs))" 
<     using \<open>card (R M2 q io (xs@[x])) = Suc (card (R M2 q io xs))\<close> 
---
>   qed
>   ultimately have "(\<Sum>q\<in>nodes M2. card (R M2 q io (xs@[x])))
>                     = Suc (\<Sum>q\<in>nodes M2. card (R M2 q io xs))"
>     using \<open>card (R M2 q io (xs@[x])) = Suc (card (R M2 q io xs))\<close>
894c891
<   have "(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) = length xs" 
---
>   have "(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) = length xs"
898c895
<       by (metis (no_types) \<open>(io @ xs) @ [x] \<in> L M2 \<Longrightarrow> io @ xs \<in> L M2\<close> 
---
>       by (metis (no_types) \<open>(io @ xs) @ [x] \<in> L M2 \<Longrightarrow> io @ xs \<in> L M2\<close>
900,901c897,898
<   qed 
<   
---
>   qed
> 
905,906c902,903
<       by (metis (no_types) 
<           \<open>(\<Sum>q\<in>nodes M2. card (R M2 q io (xs @ [x]))) = Suc (\<Sum>q\<in>nodes M2. card (R M2 q io xs))\<close> 
---
>       by (metis (no_types)
>           \<open>(\<Sum>q\<in>nodes M2. card (R M2 q io (xs @ [x]))) = Suc (\<Sum>q\<in>nodes M2. card (R M2 q io xs))\<close>
908,909c905,906
<   qed   
< qed 
---
>   qed
> qed
919c916
<   then have "\<forall> q \<in> nodes M . card (R M q vs xs) \<le> m" 
---
>   then have "\<forall> q \<in> nodes M . card (R M q vs xs) \<le> m"
922,925c919,922
<     by (meson sum_mono) 
<   moreover have "sum (\<lambda> q . m) (nodes M) \<le> m * m" 
<     using assms(2) by auto 
<   ultimately have "sum (\<lambda> q . card (R M q vs xs)) (nodes M) \<le> m * m" 
---
>     by (meson sum_mono)
>   moreover have "sum (\<lambda> q . m) (nodes M) \<le> m * m"
>     using assms(2) by auto
>   ultimately have "sum (\<lambda> q . card (R M q vs xs)) (nodes M) \<le> m * m"
928c925
<   moreover have "Suc (m*m) \<le> sum (\<lambda> q . card (R M q vs xs)) (nodes M)" 
---
>   moreover have "Suc (m*m) \<le> sum (\<lambda> q . card (R M q vs xs)) (nodes M)"
932c929
<   
---
> 
940c937
<   then have "\<forall> q \<in> nodes M . card (R M q vs xs) \<le> m" 
---
>   then have "\<forall> q \<in> nodes M . card (R M q vs xs) \<le> m"
943,946c940,943
<     by (meson sum_mono) 
<   moreover have "sum (\<lambda> q . m) (nodes M) \<le> card (nodes M) * m" 
<     using assms(2) by auto 
<   ultimately have "sum (\<lambda> q . card (R M q vs xs)) (nodes M) \<le> card (nodes M) * m" 
---
>     by (meson sum_mono)
>   moreover have "sum (\<lambda> q . m) (nodes M) \<le> card (nodes M) * m"
>     using assms(2) by auto
>   ultimately have "sum (\<lambda> q . card (R M q vs xs)) (nodes M) \<le> card (nodes M) * m"
949c946
<   moreover have "Suc (card (nodes M)*m) \<le> sum (\<lambda> q . card (R M q vs xs)) (nodes M)" 
---
>   moreover have "Suc (card (nodes M)*m) \<le> sum (\<lambda> q . card (R M q vs xs)) (nodes M)"
951c948
<   ultimately show "False" 
---
>   ultimately show "False"
960c957
< Function @{verbatim RP} extends function @{verbatim MR} by adding all elements from a set of 
---
> Function @{verbatim RP} extends function @{verbatim MR} by adding all elements from a set of
965,967c962,964
< fun RP :: "('in, 'out, 'state) FSM \<Rightarrow> 'state \<Rightarrow> ('in \<times> 'out) list 
<             \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list set 
<             \<Rightarrow> ('in \<times> 'out) list set" 
---
> fun RP :: "('in, 'out, 'state) FSM \<Rightarrow> 'state \<Rightarrow> ('in \<times> 'out) list
>             \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list set
>             \<Rightarrow> ('in \<times> 'out) list set"
969c966
<   "RP M s vs xs V'' = R M s vs xs 
---
>   "RP M s vs xs V'' = R M s vs xs
975,976c972,973
< shows "RP M2 s vs xs V'' = R M2 s vs xs 
<         \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))" 
---
> shows "RP M2 s vs xs V'' = R M2 s vs xs
>         \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))"
980,981c977,978
<  
<   moreover have "R M2 s vs xs \<subseteq> RP M2 s vs xs V''" 
---
> 
>   moreover have "R M2 s vs xs \<subseteq> RP M2 s vs xs V''"
983c980
<   moreover have "RP M2 s vs xs V'' \<subseteq> R M2 s vs xs \<union> V''" 
---
>   moreover have "RP M2 s vs xs V'' \<subseteq> R M2 s vs xs \<union> V''"
985,993c982,990
<   ultimately obtain vs1 vs2 where vs_def : 
<        "vs1 \<noteq> vs2 \<and> vs1 \<in> V'' \<and> vs2 \<in> V'' 
<         \<and> vs1 \<notin> R M2 s vs xs \<and> vs2 \<notin> R M2 s vs xs 
<         \<and> vs1 \<in> RP M2 s vs xs V'' \<and> vs2 \<in> RP M2 s vs xs V''" 
<     by blast 
< 
<   then have "io_targets M2 (initial M2) vs1 = {s} \<and> io_targets M2 (initial M2) vs2 = {s}" 
<     by (metis (mono_tags, lifting) RP.simps Un_iff mem_Collect_eq) 
<   then have "io_targets M2 (initial M2) vs1 = io_targets M2 (initial M2) vs2" 
---
>   ultimately obtain vs1 vs2 where vs_def :
>        "vs1 \<noteq> vs2 \<and> vs1 \<in> V'' \<and> vs2 \<in> V''
>         \<and> vs1 \<notin> R M2 s vs xs \<and> vs2 \<notin> R M2 s vs xs
>         \<and> vs1 \<in> RP M2 s vs xs V'' \<and> vs2 \<in> RP M2 s vs xs V''"
>     by blast
> 
>   then have "io_targets M2 (initial M2) vs1 = {s} \<and> io_targets M2 (initial M2) vs2 = {s}"
>     by (metis (mono_tags, lifting) RP.simps Un_iff mem_Collect_eq)
>   then have "io_targets M2 (initial M2) vs1 = io_targets M2 (initial M2) vs2"
995,996c992,993
<  
<   obtain f where f_def : "is_det_state_cover_ass M2 f \<and> V = f ` d_reachable M2 (initial M2)" 
---
> 
>   obtain f where f_def : "is_det_state_cover_ass M2 f \<and> V = f ` d_reachable M2 (initial M2)"
998,1000c995,997
<   moreover have "V = image f (d_reachable M2 (initial M2))" 
<     using f_def by blast 
<   moreover have "map fst vs1 \<in> V \<and> map fst vs2 \<in> V" 
---
>   moreover have "V = image f (d_reachable M2 (initial M2))"
>     using f_def by blast
>   moreover have "map fst vs1 \<in> V \<and> map fst vs2 \<in> V"
1002c999
<   ultimately obtain r1 r2 where r_def : 
---
>   ultimately obtain r1 r2 where r_def :
1004,1005c1001,1002
<     "f r2 = map fst vs2 \<and> r2 \<in> d_reachable M2 (initial M2)" 
<     by force 
---
>     "f r2 = map fst vs2 \<and> r2 \<in> d_reachable M2 (initial M2)"
>     by force
1007,1008c1004,1005
<             "d_reaches M2 (initial M2) (map fst vs2) r2" 
<     by (metis f_def is_det_state_cover_ass.elims(2))+ 
---
>             "d_reaches M2 (initial M2) (map fst vs2) r2"
>     by (metis f_def is_det_state_cover_ass.elims(2))+
1012,1021c1009,1018
<   moreover have "io_targets M2 (initial M2) vs2 \<subseteq> {r2}" 
<     using d_reaches_io_target[of M2 "initial M2" "map fst vs2" r2 "map snd vs2"] 
<           \<open>d_reaches M2 (initial M2) (map fst vs2) r2\<close> by auto 
<   ultimately have "r1 = r2" 
<     using \<open>io_targets M2 (initial M2) vs1 = {s} \<and> io_targets M2 (initial M2) vs2 = {s}\<close> by auto 
< 
<   have "map fst vs1 \<noteq> map fst vs2" 
<     using assms(2) perm_inputs_diff vs_def by blast 
<   then have "r1 \<noteq> r2" 
<     using r_def(1) r_def(2) by force  
---
>   moreover have "io_targets M2 (initial M2) vs2 \<subseteq> {r2}"
>     using d_reaches_io_target[of M2 "initial M2" "map fst vs2" r2 "map snd vs2"]
>           \<open>d_reaches M2 (initial M2) (map fst vs2) r2\<close> by auto
>   ultimately have "r1 = r2"
>     using \<open>io_targets M2 (initial M2) vs1 = {s} \<and> io_targets M2 (initial M2) vs2 = {s}\<close> by auto
> 
>   have "map fst vs1 \<noteq> map fst vs2"
>     using assms(2) perm_inputs_diff vs_def by blast
>   then have "r1 \<noteq> r2"
>     using r_def(1) r_def(2) by force
1023c1020
<   then show "False" 
---
>   then show "False"
1025c1022
< qed 
---
> qed
1027c1024
< lemma finite_RP : 
---
> lemma finite_RP :
1031,1032c1028,1029
<   using assms RP_from_R finite_R by (metis finite_insert) 
<   
---
>   using assms RP_from_R finite_R by (metis finite_insert)
> 
1045c1042
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
1047c1044
<   and "distinct (states (xs || tr) (q2,q1))" 
---
>   and "distinct (states (xs || tr) (q2,q1))"
1050c1047
<   and "\<forall> s' \<in> set (states (xs || map fst tr) q2) . \<not> (\<exists> v \<in> V . d_reaches M2 (initial M2) v s')" 
---
>   and "\<forall> s' \<in> set (states (xs || map fst tr) q2) . \<not> (\<exists> v \<in> V . d_reaches M2 (initial M2) v s')"
1059c1056
<        the assumption that no state reached by a non-empty prefix of xs after vs is also reached by 
---
>        the assumption that no state reached by a non-empty prefix of xs after vs is also reached by
1063,1065c1060,1062
<   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs 
<                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs 
<                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))" 
---
>   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs
>                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs
>                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))"
1067c1064
<   show ?thesis 
---
>   show ?thesis
1073,1076c1070,1073
<     then obtain vs' where vs'_def : "vs' \<in> V'' 
<                                       \<and> vs' \<notin> R M2 s vs xs 
<                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)" 
<       using RP_cases by auto    
---
>     then obtain vs' where vs'_def : "vs' \<in> V''
>                                       \<and> vs' \<notin> R M2 s vs xs
>                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)"
>       using RP_cases by auto
1078c1075
<     have obs_PM : "observable PM" 
---
>     have obs_PM : "observable PM"
1081,1082c1078,1079
<     have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}" 
<     proof 
---
>     have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}"
>     proof
1084c1081
<       then have "s \<in> io_targets M2 (initial M2) io" 
---
>       then have "s \<in> io_targets M2 (initial M2) io"
1086c1083
<       moreover have "io \<in> language_state M2 (initial M2)" 
---
>       moreover have "io \<in> language_state M2 (initial M2)"
1088,1089c1085,1086
<       ultimately show "io_targets M2 (initial M2) io = {s}" 
<         using assms(3) io_targets_observable_singleton_ex by (metis singletonD) 
---
>       ultimately show "io_targets M2 (initial M2) io = {s}"
>         using assms(3) io_targets_observable_singleton_ex by (metis singletonD)
1092c1089
<     have "vs' \<in> L M1" 
---
>     have "vs' \<in> L M1"
1094,1095c1091,1092
<     then obtain s' where s'_def : "io_targets M1 (initial M1) vs' = {s'}" 
<       by (meson assms(2) io_targets_observable_singleton_ob) 
---
>     then obtain s' where s'_def : "io_targets M1 (initial M1) vs' = {s'}"
>       by (meson assms(2) io_targets_observable_singleton_ob)
1097c1094
<     moreover have "s' \<notin> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))" 
---
>     moreover have "s' \<notin> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))"
1099c1096
<       assume "\<not> s' \<notin> UNION (R M2 s vs xs) (io_targets M1 (initial M1))"
---
>       assume "\<not> s' \<notin> \<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)"
1102c1099
<         assume a1: "\<And>xs'. vs @ xs' \<in> R M2 s vs xs \<and> s' \<in> io_targets M1 (initial M1) (vs @ xs') 
---
>         assume a1: "\<And>xs'. vs @ xs' \<in> R M2 s vs xs \<and> s' \<in> io_targets M1 (initial M1) (vs @ xs')
1104c1101
<         obtain pps :: "('a \<times> 'b) list set \<Rightarrow> (('a \<times> 'b) list \<Rightarrow> 'c set) \<Rightarrow> 'c \<Rightarrow> ('a \<times> 'b) list" 
---
>         obtain pps :: "('a \<times> 'b) list set \<Rightarrow> (('a \<times> 'b) list \<Rightarrow> 'c set) \<Rightarrow> 'c \<Rightarrow> ('a \<times> 'b) list"
1108,1109c1105,1106
<         then have f2: "pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \<in> R M2 s vs xs 
<                         \<and> s' \<in> io_targets M1 (initial M1) (pps (R M2 s vs xs) 
---
>         then have f2: "pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \<in> R M2 s vs xs
>                         \<and> s' \<in> io_targets M1 (initial M1) (pps (R M2 s vs xs)
1111,1112c1108,1109
<           using \<open>\<not> s' \<notin> UNION (R M2 s vs xs) (io_targets M1 (initial M1))\<close> by blast
<         then have "\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps 
---
>           using \<open>\<not> s' \<notin> \<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\<close> by blast
>         then have "\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps
1117,1119c1114,1116
<       qed  
<       then obtain tr' where tr'_def : "path M2 (vs @ xs' || tr') (initial M2) 
<                                         \<and> length tr' = length (vs @ xs')" 
---
>       qed
>       then obtain tr' where tr'_def : "path M2 (vs @ xs' || tr') (initial M2)
>                                         \<and> length tr' = length (vs @ xs')"
1122,1127c1119,1124
<       then obtain trV' trX' where tr'_split : "trV' = take (length vs) tr'" 
<                                               "trX' = drop (length vs) tr'" 
<                                               "tr' = trV' @ trX'" 
<         by fastforce 
<       then have "path M2 (vs || trV') (initial M2) \<and> length trV' = length vs" 
<         by (metis (no_types) FSM.path_append_elim \<open>trV' = take (length vs) tr'\<close> 
---
>       then obtain trV' trX' where tr'_split : "trV' = take (length vs) tr'"
>                                               "trX' = drop (length vs) tr'"
>                                               "tr' = trV' @ trX'"
>         by fastforce
>       then have "path M2 (vs || trV') (initial M2) \<and> length trV' = length vs"
>         by (metis (no_types) FSM.path_append_elim \<open>trV' = take (length vs) tr'\<close>
1129d1125
<             
1131d1126
<       
1133c1128,1130
<       have "initial PM = (initial M2, initial M1)" 
---
> 
> 
>       have "initial PM = (initial M2, initial M1)"
1135c1132
<       moreover have "vs \<in> L M2" "vs \<in> L M1" 
---
>       moreover have "vs \<in> L M2" "vs \<in> L M1"
1137,1141c1134,1138
<       ultimately have "io_targets M1 (initial M1) vs = {q1}" 
<                       "io_targets M2 (initial M2) vs = {q2}" 
<         using productF_path_io_targets[of M2 M1 FAIL PM "initial M2" "initial M1" vs q2 q1] 
<         by (metis FSM.nodes.initial assms(7) assms(8) assms(2) assms(3) assms(4) assms(5) 
<             io_targets_observable_singleton_ex singletonD)+ 
---
>       ultimately have "io_targets M1 (initial M1) vs = {q1}"
>                       "io_targets M2 (initial M2) vs = {q2}"
>         using productF_path_io_targets[of M2 M1 FAIL PM "initial M2" "initial M1" vs q2 q1]
>         by (metis FSM.nodes.initial assms(7) assms(8) assms(2) assms(3) assms(4) assms(5)
>             io_targets_observable_singleton_ex singletonD)+
1143,1144c1140,1141
<       then have "target (vs || trV') (initial M2) = q2" 
<         using \<open>path M2 (vs || trV') (initial M2) \<and> length trV' = length vs\<close> io_target_target 
---
>       then have "target (vs || trV') (initial M2) = q2"
>         using \<open>path M2 (vs || trV') (initial M2) \<and> length trV' = length vs\<close> io_target_target
1146,1149c1143,1146
<       then have path_xs' : "path M2 (xs' || trX') q2 \<and> length trX' = length xs'" 
<         by (metis (no_types) FSM.path_append_elim 
<             \<open>path M2 (vs || trV') (initial M2) \<and> length trV' = length vs\<close> 
<             \<open>target (vs || trV') (initial M2) = q2\<close> append_eq_conv_conj length_drop tr'_def 
---
>       then have path_xs' : "path M2 (xs' || trX') q2 \<and> length trX' = length xs'"
>         by (metis (no_types) FSM.path_append_elim
>             \<open>path M2 (vs || trV') (initial M2) \<and> length trV' = length vs\<close>
>             \<open>target (vs || trV') (initial M2) = q2\<close> append_eq_conv_conj length_drop tr'_def
1151,1153c1148,1150
<       
<       
<       have "io_targets M2 (initial M2) (vs @ xs') = {s}" 
---
> 
> 
>       have "io_targets M2 (initial M2) (vs @ xs') = {s}"
1155,1157c1152,1154
<       then have "io_targets M2 q2 xs' = {s}" 
<         by (meson assms(3) observable_io_targets_split \<open>io_targets M2 (initial M2) vs = {q2}\<close>) 
<       then have target_xs' : "target (xs' || trX') q2 = s" 
---
>       then have "io_targets M2 q2 xs' = {s}"
>         by (meson assms(3) observable_io_targets_split \<open>io_targets M2 (initial M2) vs = {q2}\<close>)
>       then have target_xs' : "target (xs' || trX') q2 = s"
1159c1156
<       moreover have "length xs' > 0" 
---
>       moreover have "length xs' > 0"
1161c1158
<       ultimately have "last (states (xs' || trX') q2) = s" 
---
>       ultimately have "last (states (xs' || trX') q2) = s"
1163,1165c1160,1162
<       moreover have "length (states (xs' || trX') q2) > 0" 
<         using \<open>0 < length xs'\<close> path_xs' by auto 
<       ultimately have states_xs' : "s \<in> set (states (xs' || trX') q2)" 
---
>       moreover have "length (states (xs' || trX') q2) > 0"
>         using \<open>0 < length xs'\<close> path_xs' by auto
>       ultimately have states_xs' : "s \<in> set (states (xs' || trX') q2)"
1168c1165
<       have "vs @ xs \<in> L M2" 
---
>       have "vs @ xs \<in> L M2"
1170c1167
<       then obtain q' where "io_targets M2 (initial M2) (vs@xs) = {q'}" 
---
>       then obtain q' where "io_targets M2 (initial M2) (vs@xs) = {q'}"
1172c1169
<       then have "xs \<in> language_state M2 q2" 
---
>       then have "xs \<in> language_state M2 q2"
1174c1171
<               observable_io_targets_split[of M2 "initial M2" vs xs q' q2] 
---
>               observable_io_targets_split[of M2 "initial M2" vs xs q' q2]
1177,1178c1174,1175
<       moreover have "path PM (xs || map fst tr || map snd tr) (q2,q1) 
<                       \<and> length xs = length (map fst tr)" 
---
>       moreover have "path PM (xs || map fst tr || map snd tr) (q2,q1)
>                       \<and> length xs = length (map fst tr)"
1180c1177
<       moreover have "xs \<in> language_state PM (q2,q1)" 
---
>       moreover have "xs \<in> language_state PM (q2,q1)"
1182,1186c1179,1183
<       moreover have "q2 \<in> nodes M2" 
<         using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes 
<         by (metis FSM.nodes.initial insertI1) 
<       moreover have "q1 \<in> nodes M1" 
<         using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes 
---
>       moreover have "q2 \<in> nodes M2"
>         using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes
>         by (metis FSM.nodes.initial insertI1)
>       moreover have "q1 \<in> nodes M1"
>         using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes
1188,1190c1185,1187
<       ultimately have path_xs : "path M2 (xs || map fst tr) q2" 
<         using productF_path_reverse_ob_2(1)[of xs "map fst tr" "map snd tr" M2 M1 FAIL PM q2 q1] 
<               assms(2,3,4,5,7) 
---
>       ultimately have path_xs : "path M2 (xs || map fst tr) q2"
>         using productF_path_reverse_ob_2(1)[of xs "map fst tr" "map snd tr" M2 M1 FAIL PM q2 q1]
>               assms(2,3,4,5,7)
1193d1189
<       
1195c1191,1192
<       moreover have "prefix xs' xs" 
---
> 
>       moreover have "prefix xs' xs"
1198c1195
<         using \<open>path PM (xs || map fst tr || map snd tr) (q2, q1) \<and> length xs = length (map fst tr)\<close> 
---
>         using \<open>path PM (xs || map fst tr || map snd tr) (q2, q1) \<and> length xs = length (map fst tr)\<close>
1200c1197,1201
<         by (metis observable_path_prefix) 
---
>         by (metis observable_path_prefix)
> 
>       then have states_xs : "s \<in> set (states (xs || map fst tr) q2)"
>         by (metis assms(10) in_set_takeD length_map map_snd_zip path_xs' states_alt_def states_xs')
> 
1202,1203d1202
<       then have states_xs : "s \<in> set (states (xs || map fst tr) q2)" 
<         by (metis assms(10) in_set_takeD length_map map_snd_zip path_xs' states_alt_def states_xs') 
1205,1206d1203
<       
<       
1209,1210c1206,1207
<         obtain fV where fV_def : "is_det_state_cover_ass M2 fV 
<                                   \<and> V = fV ` d_reachable M2 (initial M2)" 
---
>         obtain fV where fV_def : "is_det_state_cover_ass M2 fV
>                                   \<and> V = fV ` d_reachable M2 (initial M2)"
1212,1214c1209,1211
<         moreover have "V = image fV (d_reachable M2 (initial M2))" 
<           using fV_def by blast 
<         moreover have "map fst vs' \<in> V" 
---
>         moreover have "V = image fV (d_reachable M2 (initial M2))"
>           using fV_def by blast
>         moreover have "map fst vs' \<in> V"
1216c1213
<         ultimately obtain qv where qv_def : "fV qv = map fst vs' \<and> qv\<in> d_reachable M2 (initial M2)" 
---
>         ultimately obtain qv where qv_def : "fV qv = map fst vs' \<and> qv\<in> d_reachable M2 (initial M2)"
1218c1215
<         then have "d_reaches M2 (initial M2) (map fst vs') qv" 
---
>         then have "d_reaches M2 (initial M2) (map fst vs') qv"
1220c1217
<         then have "io_targets M2 (initial M2) vs' \<subseteq> {qv}" 
---
>         then have "io_targets M2 (initial M2) vs' \<subseteq> {qv}"
1222c1219
<         moreover have "io_targets M2 (initial M2) vs' = {s}" 
---
>         moreover have "io_targets M2 (initial M2) vs' = {s}"
1224c1221
<         ultimately have "qv = s" 
---
>         ultimately have "qv = s"
1226,1227c1223,1224
<         then show ?thesis 
<           using \<open>d_reaches M2 (initial M2) (map fst vs') qv\<close> by blast 
---
>         then show ?thesis
>           using \<open>d_reaches M2 (initial M2) (map fst vs') qv\<close> by blast
1229c1226
<       
---
> 
1231c1228
<     qed 
---
>     qed
1234c1231
<                     = insert s' (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))" 
---
>                     = insert s' (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))"
1237,1239c1234,1236
<     moreover have "finite (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))" 
<     proof 
<       show "finite (R M2 s vs xs)" 
---
>     moreover have "finite (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))"
>     proof
>       show "finite (R M2 s vs xs)"
1241c1238
<       show "\<And>a. a \<in> R M2 s vs xs \<Longrightarrow> finite (io_targets M1 (initial M1) a)" 
---
>       show "\<And>a. a \<in> R M2 s vs xs \<Longrightarrow> finite (io_targets M1 (initial M1) a)"
1243,1244c1240,1241
<         fix a assume "a \<in> R M2 s vs xs" 
<         then have "prefix a (vs@xs)" 
---
>         fix a assume "a \<in> R M2 s vs xs"
>         then have "prefix a (vs@xs)"
1246,1248c1243,1245
<         then have "a \<in> L M1" 
<           using language_state_prefix by (metis IntD1 assms(1) prefix_def) 
<         then obtain p where "io_targets M1 (initial M1) a = {p}" 
---
>         then have "a \<in> L M1"
>           using language_state_prefix by (metis IntD1 assms(1) prefix_def)
>         then obtain p where "io_targets M1 (initial M1) a = {p}"
1250c1247
<         then show "finite (io_targets M1 (initial M1) a)" 
---
>         then show "finite (io_targets M1 (initial M1) a)"
1255,1256c1252,1253
<     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))  
<                      = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))" 
---
>     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))
>                      = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))"
1259,1261c1256,1258
<       
<     moreover have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                     = card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))" 
---
> 
>     moreover have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                     = card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))"
1263,1265c1260,1262
<     
<     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))" 
---
> 
>     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))"
1268,1270c1265,1267
<     then have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                 = Suc (card (R M2 s vs xs))" 
<       using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr] assms(1,10,11,2-9) by linarith 
---
>     then have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                 = Suc (card (R M2 s vs xs))"
>       using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr] assms(1,10,11,2-9) by linarith
1272c1269
<     moreover have "card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))" 
---
>     moreover have "card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))"
1275c1272
<     ultimately show ?thesis 
---
>     ultimately show ?thesis
1282c1279
<   assumes "io \<in> (RP M2 s vs xs V'')" 
---
>   assumes "io \<in> (RP M2 s vs xs V'')"
1286c1283
<   
---
> 
1298c1295
< shows "io_targets PM (initial PM) io 
---
> shows "io_targets PM (initial PM) io
1301,1303c1298,1300
<   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs 
<                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs 
<                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))" 
---
>   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs
>                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs
>                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))"
1305c1302
<   show ?thesis 
---
>   show ?thesis
1308c1305
<     then have io_prefix : "prefix io (vs @ xs)" 
---
>     then have io_prefix : "prefix io (vs @ xs)"
1310,1312c1307,1309
<     then have io_lang_subs : "io \<in> L M1 \<and> io \<in> L M2" 
<       using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split) 
<     then have io_lang_inter : "io \<in> L M1 \<inter> L M2" 
---
>     then have io_lang_subs : "io \<in> L M1 \<and> io \<in> L M2"
>       using assms(1) unfolding prefix_def by (metis IntE language_state language_state_split)
>     then have io_lang_inter : "io \<in> L M1 \<inter> L M2"
1314,1322c1311,1319
<     then have io_lang_pm : "io \<in> L PM" 
<       using productF_language assms by blast 
<     moreover obtain p2 p1 where "(p2,p1) \<in> io_targets PM (initial PM) io" 
<       by (metis assms(2) assms(3) assms(6) calculation insert_absorb insert_ident insert_not_empty 
<           io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI) 
<     ultimately have targets_pm : "io_targets PM (initial PM) io = {(p2,p1)}" 
<       using assms io_targets_observable_singleton_ex singletonD 
<       by (metis observable_productF) 
<     then obtain trP where trP_def : "target (io || trP) (initial PM) = (p2,p1) 
---
>     then have io_lang_pm : "io \<in> L PM"
>       using productF_language assms by blast
>     moreover obtain p2 p1 where "(p2,p1) \<in> io_targets PM (initial PM) io"
>       by (metis assms(2) assms(3) assms(6) calculation insert_absorb insert_ident insert_not_empty
>           io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI)
>     ultimately have targets_pm : "io_targets PM (initial PM) io = {(p2,p1)}"
>       using assms io_targets_observable_singleton_ex singletonD
>       by (metis observable_productF)
>     then obtain trP where trP_def : "target (io || trP) (initial PM) = (p2,p1)
1325c1322
<       assume a1: "\<And>trP. target (io || trP) (initial PM) = (p2, p1) 
---
>       assume a1: "\<And>trP. target (io || trP) (initial PM) = (p2, p1)
1327c1324
<       have "\<exists>ps. target (io || ps) (initial PM) = (p2, p1) \<and> path PM (io || ps) (initial PM) 
---
>       have "\<exists>ps. target (io || ps) (initial PM) = (p2, p1) \<and> path PM (io || ps) (initial PM)
1332,1334c1329,1331
<     qed 
<     then have trP_unique : "{tr . path PM (io || tr) (initial PM) \<and> length io = length tr} = {trP}" 
<       using observable_productF observable_path_unique_ex[of PM io "initial PM"] 
---
>     qed
>     then have trP_unique : "{tr . path PM (io || tr) (initial PM) \<and> length io = length tr} = {trP}"
>       using observable_productF observable_path_unique_ex[of PM io "initial PM"]
1338c1335
<         f1: "{ps. path PM (io || ps) (initial PM) \<and> length io = length ps} = {pps} 
---
>         f1: "{ps. path PM (io || ps) (initial PM) \<and> length io = length ps} = {pps}
1340,1342c1337,1339
<         by (metis (no_types) \<open>\<And>thesis. \<lbrakk>observable PM; io \<in> L PM; \<And>tr. 
<                               {t. path PM (io || t) (initial PM) \<and> length io = length t} = {tr} 
<                                \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close> 
---
>         by (metis (no_types) \<open>\<And>thesis. \<lbrakk>observable PM; io \<in> L PM; \<And>tr.
>                               {t. path PM (io || t) (initial PM) \<and> length io = length t} = {tr}
>                                \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close>
1351,1354c1348,1351
<          
<         
<     obtain trIO2 where trIO2_def : "{tr . path M2 (io || tr) (initial M2) \<and> length io = length tr} 
<                                     = { trIO2 }" 
---
> 
> 
>     obtain trIO2 where trIO2_def : "{tr . path M2 (io || tr) (initial M2) \<and> length io = length tr}
>                                     = { trIO2 }"
1356,1357c1353,1354
<     obtain trIO1 where trIO1_def : "{tr . path M1 (io || tr) (initial M1) \<and> length io = length tr} 
<                                     = { trIO1 }" 
---
>     obtain trIO1 where trIO1_def : "{tr . path M1 (io || tr) (initial M1) \<and> length io = length tr}
>                                     = { trIO1 }"
1360,1361c1357,1358
<     have "path PM (io || trIO2 || trIO1) (initial M2, initial M1) 
<           \<and> length io = length trIO2 \<and> length trIO2 = length trIO1" 
---
>     have "path PM (io || trIO2 || trIO1) (initial M2, initial M1)
>           \<and> length io = length trIO2 \<and> length trIO2 = length trIO1"
1363c1360
<       have f1: "path M2 (io || trIO2) (initial M2) \<and> length io = length trIO2" 
---
>       have f1: "path M2 (io || trIO2) (initial M2) \<and> length io = length trIO2"
1365c1362
<       have f2: "path M1 (io || trIO1) (initial M1) \<and> length io = length trIO1" 
---
>       have f2: "path M1 (io || trIO1) (initial M1) \<and> length io = length trIO1"
1367c1364
<       then have "length trIO2 = length trIO1" 
---
>       then have "length trIO2 = length trIO1"
1369c1366
<       then show ?thesis 
---
>       then show ?thesis
1371c1368
<     qed 
---
>     qed
1373,1382c1370,1379
<                            \<and> length io = length trIO2 \<and> length trIO2 = length trIO1" 
<       using assms(6) by auto 
<     then have trP_zip : "trIO2 || trIO1 = trP" 
<       using trP_def trP_unique length_zip by fastforce 
< 
<     have "target (io || trIO2) (initial M2) = p2 
<             \<and> path M2 (io || trIO2) (initial M2) 
<             \<and> length io = length trIO2" 
<       using trP_zip trP_split assms(6) trP_def trIO2_def by auto 
<     then have "p2 \<in> io_targets M2 (initial M2) io" 
---
>                            \<and> length io = length trIO2 \<and> length trIO2 = length trIO1"
>       using assms(6) by auto
>     then have trP_zip : "trIO2 || trIO1 = trP"
>       using trP_def trP_unique length_zip by fastforce
> 
>     have "target (io || trIO2) (initial M2) = p2
>             \<and> path M2 (io || trIO2) (initial M2)
>             \<and> length io = length trIO2"
>       using trP_zip trP_split assms(6) trP_def trIO2_def by auto
>     then have "p2 \<in> io_targets M2 (initial M2) io"
1384,1385c1381,1382
<     then have targets_2 : "io_targets M2 (initial M2) io = {p2}" 
<       by (meson assms(3) observable_io_target_is_singleton)    
---
>     then have targets_2 : "io_targets M2 (initial M2) io = {p2}"
>       by (meson assms(3) observable_io_target_is_singleton)
1387,1391c1384,1388
<     have "target (io || trIO1) (initial M1) = p1 
<           \<and> path M1 (io || trIO1) (initial M1) 
<           \<and> length io = length trIO1" 
<       using trP_zip trP_split assms(6) trP_def trIO1_def by auto 
<     then have "p1 \<in> io_targets M1 (initial M1) io" 
---
>     have "target (io || trIO1) (initial M1) = p1
>           \<and> path M1 (io || trIO1) (initial M1)
>           \<and> length io = length trIO1"
>       using trP_zip trP_split assms(6) trP_def trIO1_def by auto
>     then have "p1 \<in> io_targets M1 (initial M1) io"
1393,1394c1390,1391
<     then have targets_1 : "io_targets M1 (initial M1) io = {p1}" 
<       by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD) 
---
>     then have targets_1 : "io_targets M1 (initial M1) io = {p1}"
>       by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD)
1396c1393
<     have "io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io = {(p2,p1)}" 
---
>     have "io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io = {(p2,p1)}"
1398,1399c1395,1396
<     then show "io_targets PM (initial PM) io 
<                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io" 
---
>     then show "io_targets PM (initial PM) io
>                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io"
1401c1398
<   
---
> 
1404,1405c1401,1410
<     then have "io \<notin> R M2 s vs xs \<and> RP M2 s vs xs V'' = insert io (R M2 s vs xs)" 
<       using RP_cases assms(9) by (metis insertE) 
---
>     then have "io \<notin> R M2 s vs xs \<and> RP M2 s vs xs V'' = insert io (R M2 s vs xs)"
>       using RP_cases assms(9) by (metis insertE)
> 
>     have "io \<in> L M1" using assms(8) perm_language assms(9)
>       using False by auto
>     then obtain s' where s'_def : "io_targets M1 (initial M1) io = {s'}"
>       by (meson assms(2) io_targets_observable_singleton_ob)
>     then obtain tr1 where tr1_def : "target (io || tr1) (initial M1) = s'
>                                       \<and> path M1 (io || tr1) (initial M1) \<and> length tr1 = length io"
>       by (metis io_targets_elim singletonI)
1407,1415c1412
<     have "io \<in> L M1" using assms(8) perm_language assms(9) 
<       using False by auto 
<     then obtain s' where s'_def : "io_targets M1 (initial M1) io = {s'}" 
<       by (meson assms(2) io_targets_observable_singleton_ob) 
<     then obtain tr1 where tr1_def : "target (io || tr1) (initial M1) = s' 
<                                       \<and> path M1 (io || tr1) (initial M1) \<and> length tr1 = length io" 
<       by (metis io_targets_elim singletonI) 
<     
<     have "io_targets M2 (initial M2) io = {s}" 
---
>     have "io_targets M2 (initial M2) io = {s}"
1417,1418c1414,1415
<     then obtain tr2 where tr2_def : "target (io || tr2) (initial M2) = s 
<                                       \<and> path M2 (io || tr2) (initial M2) \<and> length tr2 = length io" 
---
>     then obtain tr2 where tr2_def : "target (io || tr2) (initial M2) = s
>                                       \<and> path M2 (io || tr2) (initial M2) \<and> length tr2 = length io"
1420c1417
<     then have paths : "path M2 (io || tr2) (initial M2) \<and> path M1 (io || tr1) (initial M1)" 
---
>     then have paths : "path M2 (io || tr2) (initial M2) \<and> path M1 (io || tr1) (initial M1)"
1424c1421
<     have "length io = length tr2" 
---
>     have "length io = length tr2"
1426c1423
<     moreover have "length tr2 = length tr1" 
---
>     moreover have "length tr2 = length tr1"
1428,1430c1425,1427
<     ultimately have "path PM (io || tr2 || tr1) (initial M2, initial M1)" 
<       using assms(6) assms(5) assms(4) paths  
<             productF_path_forward[of io tr2 tr1 M2 M1 FAIL PM "initial M2" "initial M1"] 
---
>     ultimately have "path PM (io || tr2 || tr1) (initial M2, initial M1)"
>       using assms(6) assms(5) assms(4) paths
>             productF_path_forward[of io tr2 tr1 M2 M1 FAIL PM "initial M2" "initial M1"]
1433,1435c1430,1432
<     moreover have "target (io || tr2 || tr1) (initial M2, initial M1) = (s,s')" 
<       by (simp add: tr1_def tr2_def) 
<     moreover have "length (tr2 || tr2) = length io" 
---
>     moreover have "target (io || tr2 || tr1) (initial M2, initial M1) = (s,s')"
>       by (simp add: tr1_def tr2_def)
>     moreover have "length (tr2 || tr2) = length io"
1437c1434
<     moreover have "(initial M2, initial M1) = initial PM" 
---
>     moreover have "(initial M2, initial M1) = initial PM"
1439,1444c1436,1441
<     ultimately have "(s,s') \<in> io_targets PM (initial PM) io" 
<       by (metis io_target_from_path length_zip tr1_def tr2_def) 
<     moreover have "observable PM" 
<       using assms(2) assms(3) assms(6) observable_productF by blast 
<     then have "io_targets PM (initial PM) io = {(s,s')}" 
<       by (meson calculation observable_io_target_is_singleton) 
---
>     ultimately have "(s,s') \<in> io_targets PM (initial PM) io"
>       by (metis io_target_from_path length_zip tr1_def tr2_def)
>     moreover have "observable PM"
>       using assms(2) assms(3) assms(6) observable_productF by blast
>     then have "io_targets PM (initial PM) io = {(s,s')}"
>       by (meson calculation observable_io_target_is_singleton)
1446,1447c1443,1444
<     then show ?thesis 
<       using \<open>io_targets M2 (initial M2) io = {s}\<close> \<open>io_targets M1 (initial M1) io = {s'}\<close> 
---
>     then show ?thesis
>       using \<open>io_targets M2 (initial M2) io = {s}\<close> \<open>io_targets M1 (initial M1) io = {s'}\<close>
1453c1450
<   
---
> 
1459c1456
<   and "is_det_state_cover M2 V" 
---
>   and "is_det_state_cover M2 V"
1461,1462c1458,1459
< shows "finite (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))" 
< proof 
---
> shows "finite (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))"
> proof
1464c1461
<   show "\<And>a. a \<in> RP M2 s vs xs V'' \<Longrightarrow> finite (io_targets M1 (initial M1) a)" 
---
>   show "\<And>a. a \<in> RP M2 s vs xs V'' \<Longrightarrow> finite (io_targets M1 (initial M1) a)"
1466c1463
<     fix a assume "a \<in> RP M2 s vs xs V''" 
---
>     fix a assume "a \<in> RP M2 s vs xs V''"
1468,1470c1465,1467
<     have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs 
<                       \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs 
<                                         \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))" 
---
>     have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs
>                       \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs
>                                         \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))"
1475c1472
<       then have "prefix a (vs@xs)" 
---
>       then have "prefix a (vs@xs)"
1477,1478c1474,1475
<       then show "a \<in> L M1" 
<         using language_state_prefix by (metis IntD1 assms(1) prefix_def) 
---
>       then show "a \<in> L M1"
>         using language_state_prefix by (metis IntD1 assms(1) prefix_def)
1481,1483c1478,1480
<       then have "a \<in> V'' \<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)" 
<         using RP_cases \<open>a \<in> RP M2 s vs xs V''\<close> by (metis insertE) 
<       then show "a \<in> L M1" 
---
>       then have "a \<in> V'' \<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)"
>         using RP_cases \<open>a \<in> RP M2 s vs xs V''\<close> by (metis insertE)
>       then show "a \<in> L M1"
1486c1483
<     then obtain p where "io_targets M1 (initial M1) a = {p}" 
---
>     then obtain p where "io_targets M1 (initial M1) a = {p}"
1488,1489c1485,1486
<     then show "finite (io_targets M1 (initial M1) a)" 
<       by simp   
---
>     then show "finite (io_targets M1 (initial M1) a)"
>       by simp
1502c1499
< shows "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')))" 
---
> shows "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')))"
1504c1501
<   have "\<forall> io \<in> RP M2 s vs xs V'' . io_targets PM (initial PM) io 
---
>   have "\<forall> io \<in> RP M2 s vs xs V'' . io_targets PM (initial PM) io
1506c1503
<   proof 
---
>   proof
1508,1509c1505,1506
<     then have "io_targets PM (initial PM) io 
<                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io" 
---
>     then have "io_targets PM (initial PM) io
>                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io"
1511,1512c1508,1509
<     moreover have "io_targets M2 (initial M2) io = {s}" 
<       using \<open>io \<in> RP M2 s vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s vs xs V''] 
---
>     moreover have "io_targets M2 (initial M2) io = {s}"
>       using \<open>io \<in> RP M2 s vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s vs xs V'']
1514c1511
<     ultimately show "io_targets PM (initial PM) io = {s} \<times> io_targets M1 (initial M1) io" 
---
>     ultimately show "io_targets PM (initial PM) io = {s} \<times> io_targets M1 (initial M1) io"
1517,1518c1514,1515
<   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')) 
<               = \<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V''))" 
---
>   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V''))
>               = \<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V''))"
1520,1521c1517,1518
<   moreover have "\<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V'')) 
<                   = {s} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s vs xs V''))" 
---
>   moreover have "\<Union> (image (\<lambda> io . {s} \<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V''))
>                   = {s} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s vs xs V''))"
1523,1524c1520,1521
<   ultimately have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')) 
<                     = {s} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))" 
---
>   ultimately have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V''))
>                     = {s} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))"
1526c1523
<   moreover have "finite ({s} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))" 
---
>   moreover have "finite ({s} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))"
1528c1525
<   ultimately show ?thesis 
---
>   ultimately show ?thesis
1540c1537
<       "sum (\<lambda> q . card (RP M2 q io xs V'')) (nodes M2) \<ge> length xs" 
---
>       "sum (\<lambda> q . card (RP M2 q io xs V'')) (nodes M2) \<ge> length xs"
1542c1539
<   have "sum (\<lambda> q . card (R M2 q io xs)) (nodes M2) = length xs" 
---
>   have "sum (\<lambda> q . card (R M2 q io xs)) (nodes M2) = length xs"
1545c1542
<     by (metis RP_from_R assms(3) assms(4) card_insert_le eq_iff finite_R) 
---
>     by (metis RP_from_R assms(3) assms(4) card_insert_le eq_iff finite_R)
1547,1548c1544,1545
<     by (metis (no_types, lifting) \<open>(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) = length xs\<close> 
<         \<open>\<And>q. card (R M2 q io xs) \<le> card (RP M2 q io xs V'')\<close> sum_mono) 
---
>     by (metis (no_types, lifting) \<open>(\<Sum>q\<in>nodes M2. card (R M2 q io xs)) = length xs\<close>
>         \<open>\<And>q. card (R M2 q io xs) \<le> card (RP M2 q io xs V'')\<close> sum_mono)
1552c1549
<   assumes "OFSM M2" 
---
>   assumes "OFSM M2"
1565,1566c1562,1563
<     using card_cartesian_product by blast 
<   
---
>     using card_cartesian_product by blast
> 
1569c1566
<   
---
> 
1571,1572c1568,1569
<     by (metis (no_types) \<open>card (nodes M2 \<times> nodes M1) = |M2| * |M1|\<close> \<open>finite (nodes M1)\<close> 
<         \<open>finite (nodes M2)\<close> \<open>nodes (product M2 M1) \<subseteq> nodes M2 \<times> nodes M1\<close> 
---
>     by (metis (no_types) \<open>card (nodes M2 \<times> nodes M1) = |M2| * |M1|\<close> \<open>finite (nodes M1)\<close>
>         \<open>finite (nodes M2)\<close> \<open>nodes (product M2 M1) \<subseteq> nodes M2 \<times> nodes M1\<close>
1576c1573
<   have "(\<forall> q \<in> nodes M2 . card (R M2 q vs xs) = m) \<or> (\<exists> q \<in> nodes M2 . card (R M2 q vs xs) > m)" 
---
>   have "(\<forall> q \<in> nodes M2 . card (R M2 q vs xs) = m) \<or> (\<exists> q \<in> nodes M2 . card (R M2 q vs xs) > m)"
1579,1580c1576,1577
<     
<     then have "\<forall> q \<in> nodes M2 . card (R M2 q vs xs) \<le> m" 
---
> 
>     then have "\<forall> q \<in> nodes M2 . card (R M2 q vs xs) \<le> m"
1583,1584c1580,1581
<       using \<open>\<not> ((\<forall>q\<in>nodes M2. card (R M2 q vs xs) = m) \<or> (\<exists>q\<in>nodes M2. m < card (R M2 q vs xs)))\<close> 
<             nat_neq_iff 
---
>       using \<open>\<not> ((\<forall>q\<in>nodes M2. card (R M2 q vs xs) = m) \<or> (\<exists>q\<in>nodes M2. m < card (R M2 q vs xs)))\<close>
>             nat_neq_iff
1587,1588c1584,1585
<     have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2) 
<           = sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'}) 
---
>     have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2)
>           = sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'})
1591,1592c1588,1589
<       by (meson \<open>finite (nodes M2)\<close> empty_subsetI insert_subset sum.subset_diff) 
<     moreover have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'}) 
---
>       by (meson \<open>finite (nodes M2)\<close> empty_subsetI insert_subset sum.subset_diff)
>     moreover have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'})
1595c1592
<       by (meson sum_mono DiffD1) 
---
>       by (meson sum_mono DiffD1)
1605,1608c1602,1605
<         using \<open>(\<Sum>q\<in>nodes M2 - {q'}. card (R M2 q vs xs)) \<le> (\<Sum>q\<in>nodes M2 - {q'}. m)\<close> 
<               \<open>(\<Sum>q\<in>nodes M2. card (R M2 q vs xs)) = (\<Sum>q\<in>nodes M2 - {q'}. card (R M2 q vs xs)) 
<                 + (\<Sum>q\<in>{q'}. card (R M2 q vs xs))\<close> 
<               \<open>(\<Sum>q\<in>{q'}. card (R M2 q vs xs)) < m\<close> 
---
>         using \<open>(\<Sum>q\<in>nodes M2 - {q'}. card (R M2 q vs xs)) \<le> (\<Sum>q\<in>nodes M2 - {q'}. m)\<close>
>               \<open>(\<Sum>q\<in>nodes M2. card (R M2 q vs xs)) = (\<Sum>q\<in>nodes M2 - {q'}. card (R M2 q vs xs))
>                 + (\<Sum>q\<in>{q'}. card (R M2 q vs xs))\<close>
>               \<open>(\<Sum>q\<in>{q'}. card (R M2 q vs xs)) < m\<close>
1611,1615c1608,1612
<       
<       
<     moreover have "sum (\<lambda> q . m) (nodes M2) \<le> card (nodes M2) * m" 
<       using assms(2) by auto 
<     ultimately have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2) < card (nodes M2) * m" 
---
> 
> 
>     moreover have "sum (\<lambda> q . m) (nodes M2) \<le> card (nodes M2) * m"
>       using assms(2) by auto
>     ultimately have "sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2) < card (nodes M2) * m"
1617,1618c1614,1615
<   
<     moreover have "Suc (card (nodes M2)*m) \<le> sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2)" 
---
> 
>     moreover have "Suc (card (nodes M2)*m) \<le> sum (\<lambda> q . card (R M2 q vs xs)) (nodes M2)"
1620c1617
<       by (metis Int_iff \<open>vs @ xs \<in> L M2 \<Longrightarrow> (\<Sum>q\<in>nodes M2. card (R M2 q vs xs)) = length xs\<close> 
---
>       by (metis Int_iff \<open>vs @ xs \<in> L M2 \<Longrightarrow> (\<Sum>q\<in>nodes M2. card (R M2 q vs xs)) = length xs\<close>
1622c1619
<    
---
> 
1628c1625
<     
---
> 
1630c1627
<     then have "card (R M2 ?q vs xs) = m" 
---
>     then have "card (R M2 ?q vs xs) = m"
1632c1629
<     
---
> 
1635c1632
<     then have "[] \<in> RP M2 ?q vs xs V''" 
---
>     then have "[] \<in> RP M2 ?q vs xs V''"
1641,1642c1638,1639
<       by (simp add: card_mono)  
<     
---
>       by (simp add: card_mono)
> 
1650,1651c1647,1648
<         using f1 by (metis (no_types) RP_from_R 
<                      \<open>card (R M2 (initial M2) vs xs) \<le> card (RP M2 (initial M2) vs xs V'')\<close> 
---
>         using f1 by (metis (no_types) RP_from_R
>                      \<open>card (R M2 (initial M2) vs xs) \<le> card (RP M2 (initial M2) vs xs V'')\<close>
1654,1655c1651,1652
<       
<     then show ?thesis 
---
> 
>     then show ?thesis
1657,1658c1654,1655
<       by blast 
<   next 
---
>       by blast
>   next
1664c1661
<       by (simp add: card_mono) 
---
>       by (simp add: card_mono)
1666,1668c1663,1665
<       by simp 
<     
<     show ?thesis 
---
>       by simp
> 
>     show ?thesis
1678c1675
< The following predicates describe the assumptions necessary to show that the value calculated by 
---
> The following predicates describe the assumptions necessary to show that the value calculated by
1682,1685c1679,1682
< fun Prereq :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list 
<               \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> 'in list set \<Rightarrow> 'state1 set \<Rightarrow> ('in, 'out) ATC set 
<               \<Rightarrow> ('in \<times> 'out) list set \<Rightarrow> bool" 
<   where 
---
> fun Prereq :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list
>               \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> 'in list set \<Rightarrow> 'state1 set \<Rightarrow> ('in, 'out) ATC set
>               \<Rightarrow> ('in \<times> 'out) list set \<Rightarrow> bool"
>   where
1687,1690c1684,1687
<     (finite T)                                                           
<     \<and> (vs @ xs) \<in> L M2 \<inter> L M1                                              
<     \<and> S \<subseteq> nodes M2                                                         
<     \<and> (\<forall> s1 \<in> S . \<forall> s2 \<in> S . s1 \<noteq> s2                                       
---
>     (finite T)
>     \<and> (vs @ xs) \<in> L M2 \<inter> L M1
>     \<and> S \<subseteq> nodes M2
>     \<and> (\<forall> s1 \<in> S . \<forall> s2 \<in> S . s1 \<noteq> s2
1696c1693
< fun Rep_Pre :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list 
---
> fun Rep_Pre :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list
1698,1699c1695,1696
<   "Rep_Pre M2 M1 vs xs = (\<exists> xs1 xs2 . prefix xs1 xs2 \<and> prefix xs2 xs \<and> xs1 \<noteq> xs2 
<     \<and> (\<exists> s2 . io_targets M2 (initial M2) (vs @ xs1) = {s2} 
---
>   "Rep_Pre M2 M1 vs xs = (\<exists> xs1 xs2 . prefix xs1 xs2 \<and> prefix xs2 xs \<and> xs1 \<noteq> xs2
>     \<and> (\<exists> s2 . io_targets M2 (initial M2) (vs @ xs1) = {s2}
1701c1698
<     \<and> (\<exists> s1 . io_targets M1 (initial M1) (vs @ xs1) = {s1} 
---
>     \<and> (\<exists> s1 . io_targets M1 (initial M1) (vs @ xs1) = {s1}
1705c1702
< fun Rep_Cov :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list set 
---
> fun Rep_Cov :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM \<Rightarrow> ('in \<times> 'out) list set
1707,1708c1704,1705
<   "Rep_Cov M2 M1 V'' vs xs = (\<exists> xs' vs' . xs' \<noteq> [] \<and> prefix xs' xs \<and> vs' \<in> V'' 
<     \<and> (\<exists> s2 . io_targets M2 (initial M2) (vs @ xs') = {s2} 
---
>   "Rep_Cov M2 M1 V'' vs xs = (\<exists> xs' vs' . xs' \<noteq> [] \<and> prefix xs' xs \<and> vs' \<in> V''
>     \<and> (\<exists> s2 . io_targets M2 (initial M2) (vs @ xs') = {s2}
1710c1707
<     \<and> (\<exists> s1 . io_targets M1 (initial M1) (vs @ xs') = {s1} 
---
>     \<and> (\<exists> s1 . io_targets M1 (initial M1) (vs @ xs') = {s1}
1721c1718
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
1730,1735c1727,1732
<      "i1 \<noteq> 0 
<       \<and> i1 \<noteq> i2 
<       \<and> i1 < length (states (xs || tr) (q2, q1)) 
<       \<and> i2 < length (states (xs || tr) (q2, q1)) 
<       \<and> (states (xs || tr) (q2, q1)) ! i1 = (states (xs || tr) (q2, q1)) ! i2" 
<     by (metis distinct_conv_nth) 
---
>      "i1 \<noteq> 0
>       \<and> i1 \<noteq> i2
>       \<and> i1 < length (states (xs || tr) (q2, q1))
>       \<and> i2 < length (states (xs || tr) (q2, q1))
>       \<and> (states (xs || tr) (q2, q1)) ! i1 = (states (xs || tr) (q2, q1)) ! i2"
>     by (metis distinct_conv_nth)
1737c1734
<   
---
> 
1744c1741
<   have obs_PM : "observable PM" 
---
>   have obs_PM : "observable PM"
1747c1744
<   have "initial PM = (initial M2, initial M1)" 
---
>   have "initial PM = (initial M2, initial M1)"
1749c1746
<   moreover have "vs \<in> L M2" "vs \<in> L M1" 
---
>   moreover have "vs \<in> L M2" "vs \<in> L M1"
1751,1753c1748,1750
<   ultimately have "io_targets M1 (initial M1) vs = {q1}" "io_targets M2 (initial M2) vs = {q2}" 
<     using productF_path_io_targets[of M2 M1 FAIL PM "initial M2" "initial M1" vs q2 q1] 
<     by (metis FSM.nodes.initial assms(2) assms(3) assms(4) assms(5) assms(9) assms(10) 
---
>   ultimately have "io_targets M1 (initial M1) vs = {q1}" "io_targets M2 (initial M2) vs = {q2}"
>     using productF_path_io_targets[of M2 M1 FAIL PM "initial M2" "initial M1" vs q2 q1]
>     by (metis FSM.nodes.initial assms(2) assms(3) assms(4) assms(5) assms(9) assms(10)
1757,1759c1754,1756
<   
<   have "(states (xs || tr) (q2, q1)) ! i1 \<in> io_targets PM (q2, q1) ?xs1" 
<     by (metis \<open>0 < length xs\<close> assms(6) assms(7) index_def map_snd_zip states_alt_def 
---
> 
>   have "(states (xs || tr) (q2, q1)) ! i1 \<in> io_targets PM (q2, q1) ?xs1"
>     by (metis \<open>0 < length xs\<close> assms(6) assms(7) index_def map_snd_zip states_alt_def
1761,1762c1758,1764
<   then have "io_targets PM (q2, q1) ?xs1 = {?st}" 
<     using obs_PM by (meson observable_io_target_is_singleton) 
---
>   then have "io_targets PM (q2, q1) ?xs1 = {?st}"
>     using obs_PM by (meson observable_io_target_is_singleton)
> 
>   have "path PM (?xs1 || ?tr1) (q2,q1)"
>     by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append)
>   then have "path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)"
>     by auto
1764,1771c1766,1768
<   have "path PM (?xs1 || ?tr1) (q2,q1)" 
<     by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append) 
<   then have "path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)" 
<     by auto
<   
<   have "vs @ ?xs1 \<in> L M2" 
<     by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix) 
<   then obtain q2' where "io_targets M2 (initial M2) (vs@?xs1) = {q2'}" 
---
>   have "vs @ ?xs1 \<in> L M2"
>     by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix)
>   then obtain q2' where "io_targets M2 (initial M2) (vs@?xs1) = {q2'}"
1774,1775c1771,1772
<     using assms(4) \<open>io_targets M2 (initial M2) vs = {q2}\<close> 
<           observable_io_targets_split[of M2 "initial M2" vs ?xs1 q2' q2] 
---
>     using assms(4) \<open>io_targets M2 (initial M2) vs = {q2}\<close>
>           observable_io_targets_split[of M2 "initial M2" vs ?xs1 q2' q2]
1777c1774
<   then have "?xs1 \<in> language_state M2 q2" 
---
>   then have "?xs1 \<in> language_state M2 q2"
1779c1776
<   moreover have "length ?xs1 = length (map snd ?tr1)" 
---
>   moreover have "length ?xs1 = length (map snd ?tr1)"
1781c1778
<   moreover have "length (map fst ?tr1) = length (map snd ?tr1)" 
---
>   moreover have "length (map fst ?tr1) = length (map snd ?tr1)"
1783,1787c1780,1784
<   moreover have "q2 \<in> nodes M2" 
<     using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes 
<     by (metis FSM.nodes.initial insertI1) 
<   moreover have "q1 \<in> nodes M1" 
<     using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes 
---
>   moreover have "q2 \<in> nodes M2"
>     using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes
>     by (metis FSM.nodes.initial insertI1)
>   moreover have "q1 \<in> nodes M1"
>     using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes
1789,1791c1786,1788
<   ultimately have 
<      "path M1 (?xs1 || map snd ?tr1) q1" 
<      "path M2 (?xs1 || map fst ?tr1) q2" 
---
>   ultimately have
>      "path M1 (?xs1 || map snd ?tr1) q1"
>      "path M2 (?xs1 || map fst ?tr1) q2"
1794,1796c1791,1793
<     using assms(2) assms(9) assms(10) \<open>path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)\<close> 
<           assms(4) 
<           productF_path_reverse_ob_2[of ?xs1 "map fst ?tr1" "map snd ?tr1" M2 M1 FAIL PM q2 q1] 
---
>     using assms(2) assms(9) assms(10) \<open>path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)\<close>
>           assms(4)
>           productF_path_reverse_ob_2[of ?xs1 "map fst ?tr1" "map snd ?tr1" M2 M1 FAIL PM q2 q1]
1798c1795
<   moreover have "target (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1) = ?st" 
---
>   moreover have "target (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1) = ?st"
1800c1797
<   ultimately have  
---
>   ultimately have
1802,1803c1799,1800
<      "target (?xs1 || map fst ?tr1) q2 = fst ?st" 
<     by simp+  
---
>      "target (?xs1 || map fst ?tr1) q2 = fst ?st"
>     by simp+
1806,1807c1803,1804
<   
<   have "(states (xs || tr) (q2, q1)) ! i2 \<in> io_targets PM (q2, q1) ?xs2" 
---
> 
>   have "(states (xs || tr) (q2, q1)) ! i2 \<in> io_targets PM (q2, q1) ?xs2"
1809,1810c1806,1807
<   then have "io_targets PM (q2, q1) ?xs2 = {?st}" 
<     using obs_PM by (metis index_def observable_io_target_is_singleton)  
---
>   then have "io_targets PM (q2, q1) ?xs2 = {?st}"
>     using obs_PM by (metis index_def observable_io_target_is_singleton)
1812,1814c1809,1811
<   have "path PM (?xs2 || ?tr2) (q2,q1)" 
<     by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append) 
<   then have "path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)" 
---
>   have "path PM (?xs2 || ?tr2) (q2,q1)"
>     by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append)
>   then have "path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)"
1817,1820c1814,1817
<   have "vs @ ?xs2 \<in> L M2" 
<     by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix) 
<   then obtain q2'' where "io_targets M2 (initial M2) (vs@?xs2) = {q2''}" 
<     using io_targets_observable_singleton_ob[of M2 "vs@?xs2" "initial M2"] assms(4) 
---
>   have "vs @ ?xs2 \<in> L M2"
>     by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix)
>   then obtain q2'' where "io_targets M2 (initial M2) (vs@?xs2) = {q2''}"
>     using io_targets_observable_singleton_ob[of M2 "vs@?xs2" "initial M2"] assms(4)
1824c1821
<           observable_io_targets_split[of M2 "initial M2" vs ?xs2 q2'' q2] 
---
>           observable_io_targets_split[of M2 "initial M2" vs ?xs2 q2'' q2]
1826c1823
<   then have "?xs2 \<in> language_state M2 q2" 
---
>   then have "?xs2 \<in> language_state M2 q2"
1828c1825
<   moreover have "length ?xs2 = length (map snd ?tr2)" using assms(7) 
---
>   moreover have "length ?xs2 = length (map snd ?tr2)" using assms(7)
1832,1834c1829,1831
<   moreover have "q2 \<in> nodes M2" 
<     using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes 
<     by (metis FSM.nodes.initial insertI1) 
---
>   moreover have "q2 \<in> nodes M2"
>     using \<open>io_targets M2 (initial M2) vs = {q2}\<close> io_targets_nodes
>     by (metis FSM.nodes.initial insertI1)
1836c1833
<     using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes 
---
>     using \<open>io_targets M1 (initial M1) vs = {q1}\<close> io_targets_nodes
1838,1840c1835,1837
<   ultimately have 
<      "path M1 (?xs2 || map snd ?tr2) q1" 
<      "path M2 (?xs2 || map fst ?tr2) q2" 
---
>   ultimately have
>      "path M1 (?xs2 || map snd ?tr2) q1"
>      "path M2 (?xs2 || map fst ?tr2) q2"
1843,1845c1840,1842
<     using assms(2) assms(9) assms(10) \<open>path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)\<close> 
<           assms(4) 
<           productF_path_reverse_ob_2[of ?xs2 "map fst ?tr2" "map snd ?tr2" M2 M1 FAIL PM q2 q1] 
---
>     using assms(2) assms(9) assms(10) \<open>path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)\<close>
>           assms(4)
>           productF_path_reverse_ob_2[of ?xs2 "map fst ?tr2" "map snd ?tr2" M2 M1 FAIL PM q2 q1]
1847c1844
<   moreover have "target (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1) = ?st" 
---
>   moreover have "target (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1) = ?st"
1849c1846
<   ultimately have  
---
>   ultimately have
1851c1848
<      "target (?xs2 || map fst ?tr2) q2 = fst ?st" 
---
>      "target (?xs2 || map fst ?tr2) q2 = fst ?st"
1854d1850
<   
1856,1867c1852,1856
<   have "io_targets M1 q1 ?xs1 = {snd ?st}" 
<     using \<open>path M1 (?xs1 || map snd ?tr1) q1\<close> \<open>target (?xs1 || map snd ?tr1) q1 = snd ?st\<close> 
<           \<open>length ?xs1 = length (map snd ?tr1)\<close> assms(3) obs_target_is_io_targets[of M1 ?xs1 
<           "map snd ?tr1" q1] 
<     by simp
<   then have tgt_1_1 : "io_targets M1 (initial M1) (vs @ ?xs1) = {snd ?st}" 
<     by (meson \<open>io_targets M1 (initial M1) vs = {q1}\<close> assms(3) observable_io_targets_append) 
<   
<   have "io_targets M2 q2 ?xs1 = {fst ?st}" 
<     using \<open>path M2 (?xs1 || map fst ?tr1) q2\<close> \<open>target (?xs1 || map fst ?tr1) q2 = fst ?st\<close> 
<           \<open>length ?xs1 = length (map snd ?tr1)\<close> assms(4) 
<           obs_target_is_io_targets[of M2 ?xs1 "map fst ?tr1" q2] 
---
> 
>   have "io_targets M1 q1 ?xs1 = {snd ?st}"
>     using \<open>path M1 (?xs1 || map snd ?tr1) q1\<close> \<open>target (?xs1 || map snd ?tr1) q1 = snd ?st\<close>
>           \<open>length ?xs1 = length (map snd ?tr1)\<close> assms(3) obs_target_is_io_targets[of M1 ?xs1
>           "map snd ?tr1" q1]
1869c1858,1866
<   then have tgt_1_2 : "io_targets M2 (initial M2) (vs @ ?xs1) = {fst ?st}" 
---
>   then have tgt_1_1 : "io_targets M1 (initial M1) (vs @ ?xs1) = {snd ?st}"
>     by (meson \<open>io_targets M1 (initial M1) vs = {q1}\<close> assms(3) observable_io_targets_append)
> 
>   have "io_targets M2 q2 ?xs1 = {fst ?st}"
>     using \<open>path M2 (?xs1 || map fst ?tr1) q2\<close> \<open>target (?xs1 || map fst ?tr1) q2 = fst ?st\<close>
>           \<open>length ?xs1 = length (map snd ?tr1)\<close> assms(4)
>           obs_target_is_io_targets[of M2 ?xs1 "map fst ?tr1" q2]
>     by simp
>   then have tgt_1_2 : "io_targets M2 (initial M2) (vs @ ?xs1) = {fst ?st}"
1871,1875c1868,1872
<   
<   have "io_targets M1 q1 ?xs2 = {snd ?st}" 
<     using \<open>path M1 (?xs2 || map snd ?tr2) q1\<close> \<open>target (?xs2 || map snd ?tr2) q1 = snd ?st\<close> 
<           \<open>length ?xs2 = length (map snd ?tr2)\<close> assms(3) 
<           obs_target_is_io_targets[of M1 ?xs2 "map snd ?tr2" q1] 
---
> 
>   have "io_targets M1 q1 ?xs2 = {snd ?st}"
>     using \<open>path M1 (?xs2 || map snd ?tr2) q1\<close> \<open>target (?xs2 || map snd ?tr2) q1 = snd ?st\<close>
>           \<open>length ?xs2 = length (map snd ?tr2)\<close> assms(3)
>           obs_target_is_io_targets[of M1 ?xs2 "map snd ?tr2" q1]
1877c1874
<   then have tgt_2_1 : "io_targets M1 (initial M1) (vs @ ?xs2) = {snd ?st}" 
---
>   then have tgt_2_1 : "io_targets M1 (initial M1) (vs @ ?xs2) = {snd ?st}"
1879,1883c1876,1880
<   
<   have "io_targets M2 q2 ?xs2 = {fst ?st}" 
<     using \<open>path M2 (?xs2 || map fst ?tr2) q2\<close> \<open>target (?xs2 || map fst ?tr2) q2 = fst ?st\<close> 
<           \<open>length ?xs2 = length (map snd ?tr2)\<close> assms(4) 
<           obs_target_is_io_targets[of M2 ?xs2 "map fst ?tr2" q2] 
---
> 
>   have "io_targets M2 q2 ?xs2 = {fst ?st}"
>     using \<open>path M2 (?xs2 || map fst ?tr2) q2\<close> \<open>target (?xs2 || map fst ?tr2) q2 = fst ?st\<close>
>           \<open>length ?xs2 = length (map snd ?tr2)\<close> assms(4)
>           obs_target_is_io_targets[of M2 ?xs2 "map fst ?tr2" q2]
1885c1882
<   then have tgt_2_2 : "io_targets M2 (initial M2) (vs @ ?xs2) = {fst ?st}" 
---
>   then have tgt_2_2 : "io_targets M2 (initial M2) (vs @ ?xs2) = {fst ?st}"
1888,1892c1885,1889
<   have "?xs1 \<noteq> []" using \<open>0 < length xs\<close> 
<     by auto  
<   have "prefix ?xs1 xs" 
<     using take_is_prefix by blast 
<   have "prefix ?xs2 xs" 
---
>   have "?xs1 \<noteq> []" using \<open>0 < length xs\<close>
>     by auto
>   have "prefix ?xs1 xs"
>     using take_is_prefix by blast
>   have "prefix ?xs2 xs"
1896c1893
<     have f1: "\<forall>n na. \<not> n < na \<or> Suc n \<le> na" 
---
>     have f1: "\<forall>n na. \<not> n < na \<or> Suc n \<le> na"
1898c1895
<     have f2: "Suc i1 \<le> length xs" 
---
>     have f2: "Suc i1 \<le> length xs"
1900c1897
<     have "Suc i2 \<le> length xs" 
---
>     have "Suc i2 \<le> length xs"
1902c1899
<     then show ?thesis 
---
>     then show ?thesis
1904c1901
<   qed 
---
>   qed
1910c1907
<           prefix_same_cases) 
---
>           prefix_same_cases)
1912,1914c1909,1911
<       by (meson Rep_Pre.elims(3) \<open>prefix (take (Suc i1) xs) (take (Suc i2) xs)\<close> 
<           \<open>prefix (take (Suc i2) xs) xs\<close> \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close> 
<           tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2) 
---
>       by (meson Rep_Pre.elims(3) \<open>prefix (take (Suc i1) xs) (take (Suc i2) xs)\<close>
>           \<open>prefix (take (Suc i2) xs) xs\<close> \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close>
>           tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2)
1918,1920c1915,1917
<       by (metis (no_types) \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close> append_eq_conv_conj 
<           append_take_drop_id) 
<     ultimately have "length ?xs2 < length ?xs1" 
---
>       by (metis (no_types) \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close> append_eq_conv_conj
>           append_take_drop_id)
>     ultimately have "length ?xs2 < length ?xs1"
1923,1925c1920,1922
<       using \<open>prefix (take (Suc i1) xs) xs\<close> \<open>prefix (take (Suc i2) xs) xs\<close> less_imp_le_nat 
<             prefix_length_prefix 
<       by blast 
---
>       using \<open>prefix (take (Suc i1) xs) xs\<close> \<open>prefix (take (Suc i2) xs) xs\<close> less_imp_le_nat
>             prefix_length_prefix
>       by blast
1927,1929c1924,1926
<       by (metis Rep_Pre.elims(3) \<open>prefix (take (Suc i1) xs) xs\<close> 
<           \<open>prefix (take (Suc i2) xs) (take (Suc i1) xs)\<close> \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close> 
<           tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2) 
---
>       by (metis Rep_Pre.elims(3) \<open>prefix (take (Suc i1) xs) xs\<close>
>           \<open>prefix (take (Suc i2) xs) (take (Suc i1) xs)\<close> \<open>take (Suc i1) xs \<noteq> take (Suc i2) xs\<close>
>           tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2)
1931,1932c1928,1929
<     
<   then show "False" 
---
> 
>   then show "False"
1936,1937c1933,1934
<   
<   
---
> 
> 
1949c1946
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
1951c1948
<   and "distinct (states (xs || tr) (q2,q1))" 
---
>   and "distinct (states (xs || tr) (q2,q1))"
1954c1951
<   and "\<not> Rep_Cov M2 M1 V'' vs xs"  
---
>   and "\<not> Rep_Cov M2 M1 V'' vs xs"
1957,1959c1954,1956
<   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs 
<                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs 
<                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))" 
---
>   have RP_cases : "RP M2 s vs xs V'' = R M2 s vs xs
>                     \<or> (\<exists> vs' \<in> V'' . vs' \<notin> R M2 s vs xs
>                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))"
1961c1958
<   show ?thesis 
---
>   show ?thesis
1964c1961
<     then show ?thesis 
---
>     then show ?thesis
1968,1970c1965,1967
<     then obtain vs' where vs'_def : "vs' \<in> V'' 
<                                       \<and> vs' \<notin> R M2 s vs xs 
<                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)" 
---
>     then obtain vs' where vs'_def : "vs' \<in> V''
>                                       \<and> vs' \<notin> R M2 s vs xs
>                                       \<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)"
1972,1974c1969,1971
<         
<     have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}" 
<     proof 
---
> 
>     have state_component_2 : "\<forall> io \<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}"
>     proof
1976c1973
<       then have "s \<in> io_targets M2 (initial M2) io" 
---
>       then have "s \<in> io_targets M2 (initial M2) io"
1978c1975
<       moreover have "io \<in> language_state M2 (initial M2)" 
---
>       moreover have "io \<in> language_state M2 (initial M2)"
1980,1981c1977,1978
<       ultimately show "io_targets M2 (initial M2) io = {s}" 
<         using assms(3) io_targets_observable_singleton_ex by (metis singletonD) 
---
>       ultimately show "io_targets M2 (initial M2) io = {s}"
>         using assms(3) io_targets_observable_singleton_ex by (metis singletonD)
1984c1981
<     have "vs' \<in> L M1" 
---
>     have "vs' \<in> L M1"
1986,1987c1983,1984
<     then obtain s' where s'_def : "io_targets M1 (initial M1) vs' = {s'}" 
<       by (meson assms(2) io_targets_observable_singleton_ob) 
---
>     then obtain s' where s'_def : "io_targets M1 (initial M1) vs' = {s'}"
>       by (meson assms(2) io_targets_observable_singleton_ob)
1989c1986
<     moreover have "s' \<notin> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))" 
---
>     moreover have "s' \<notin> \<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))"
1991,1992c1988,1989
<       assume "\<not> s' \<notin> UNION (R M2 s vs xs) (io_targets M1 (initial M1))"
<       then obtain xs' where xs'_def : "vs @ xs' \<in> R M2 s vs xs 
---
>       assume "\<not> s' \<notin> \<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)"
>       then obtain xs' where xs'_def : "vs @ xs' \<in> R M2 s vs xs
1995c1992
<         assume a1: "\<And>xs'. vs @ xs' \<in> R M2 s vs xs 
---
>         assume a1: "\<And>xs'. vs @ xs' \<in> R M2 s vs xs
1997c1994
<         obtain pps :: "('a \<times> 'b) list set \<Rightarrow> (('a \<times> 'b) list \<Rightarrow> 'c set) \<Rightarrow> 'c \<Rightarrow> ('a \<times> 'b) list" 
---
>         obtain pps :: "('a \<times> 'b) list set \<Rightarrow> (('a \<times> 'b) list \<Rightarrow> 'c set) \<Rightarrow> 'c \<Rightarrow> ('a \<times> 'b) list"
2001,2002c1998,1999
<         then have f2: "pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \<in> R M2 s vs xs 
<                         \<and> s' \<in> io_targets M1 (initial M1) 
---
>         then have f2: "pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \<in> R M2 s vs xs
>                         \<and> s' \<in> io_targets M1 (initial M1)
2004,2005c2001,2002
<           using \<open>\<not> s' \<notin> UNION (R M2 s vs xs) (io_targets M1 (initial M1))\<close> by blast
<         then have "\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \<and> ps \<noteq> [] 
---
>           using \<open>\<not> s' \<notin> \<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\<close> by blast
>         then have "\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \<and> ps \<noteq> []
2010,2014c2007,2011
<       qed  
<       
<       have "vs @ xs' \<in> L M1" 
<         using xs'_def by blast 
<       then have "io_targets M1 (initial M1) (vs@xs') = {s'}" 
---
>       qed
> 
>       have "vs @ xs' \<in> L M1"
>         using xs'_def by blast
>       then have "io_targets M1 (initial M1) (vs@xs') = {s'}"
2016,2018c2013,2015
<       moreover have "io_targets M1 (initial M1) (vs') = {s'}" 
<         using s'_def by blast 
<       moreover have "io_targets M2 (initial M2) (vs @ xs') = {s}" 
---
>       moreover have "io_targets M1 (initial M1) (vs') = {s'}"
>         using s'_def by blast
>       moreover have "io_targets M2 (initial M2) (vs @ xs') = {s}"
2020,2022c2017,2019
<       moreover have "io_targets M2 (initial M2) (vs') = {s}" 
<         by (metis (mono_tags, lifting) RP.simps Un_iff insertI1 mem_Collect_eq vs'_def) 
<       moreover have "xs' \<noteq> []" 
---
>       moreover have "io_targets M2 (initial M2) (vs') = {s}"
>         by (metis (mono_tags, lifting) RP.simps Un_iff insertI1 mem_Collect_eq vs'_def)
>       moreover have "xs' \<noteq> []"
2024c2021
<       moreover have "prefix xs' xs" 
---
>       moreover have "prefix xs' xs"
2026c2023
<       moreover have "vs' \<in> V''" 
---
>       moreover have "vs' \<in> V''"
2028c2025
<       ultimately have "Rep_Cov M2 M1 V'' vs xs" 
---
>       ultimately have "Rep_Cov M2 M1 V'' vs xs"
2031c2028
<       then show "False" 
---
>       then show "False"
2033c2030
<     qed 
---
>     qed
2036c2033
<                     = insert s' (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))" 
---
>                     = insert s' (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))"
2039,2041c2036,2038
<     moreover have "finite (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))" 
<     proof 
<       show "finite (R M2 s vs xs)" 
---
>     moreover have "finite (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))"
>     proof
>       show "finite (R M2 s vs xs)"
2043c2040
<       show "\<And>a. a \<in> R M2 s vs xs \<Longrightarrow> finite (io_targets M1 (initial M1) a)" 
---
>       show "\<And>a. a \<in> R M2 s vs xs \<Longrightarrow> finite (io_targets M1 (initial M1) a)"
2045,2046c2042,2043
<         fix a assume "a \<in> R M2 s vs xs" 
<         then have "prefix a (vs@xs)" 
---
>         fix a assume "a \<in> R M2 s vs xs"
>         then have "prefix a (vs@xs)"
2048,2050c2045,2047
<         then have "a \<in> L M1" 
<           using language_state_prefix by (metis IntD1 assms(1) prefix_def) 
<         then obtain p where "io_targets M1 (initial M1) a = {p}" 
---
>         then have "a \<in> L M1"
>           using language_state_prefix by (metis IntD1 assms(1) prefix_def)
>         then obtain p where "io_targets M1 (initial M1) a = {p}"
2052c2049
<         then show "finite (io_targets M1 (initial M1) a)" 
---
>         then show "finite (io_targets M1 (initial M1) a)"
2057,2058c2054,2055
<     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))  
<                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))" 
---
>     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))
>                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))"
2061,2063c2058,2060
<       
<     moreover have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                     = card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))" 
---
> 
>     moreover have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                     = card (\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))"
2065,2067c2062,2064
<     
<     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))" 
---
> 
>     ultimately have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                       = Suc (card (\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))"
2070,2073c2067,2070
<     then have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) 
<                   = Suc (card (R M2 s vs xs))" 
<       using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr] using assms(1,10,11,2-9) 
<       by linarith 
---
>     then have "card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))
>                   = Suc (card (R M2 s vs xs))"
>       using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr] using assms(1,10,11,2-9)
>       by linarith
2075c2072
<     moreover have "card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))" 
---
>     moreover have "card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))"
2078c2075
<     ultimately show ?thesis 
---
>     ultimately show ?thesis
2084,2086d2080
< 
< 
< 
2096c2090
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
2098c2092
<   and "\<not> Rep_Pre M2 M1 vs xs" 
---
>   and "\<not> Rep_Pre M2 M1 vs xs"
2101c2095
<   and "\<not> Rep_Cov M2 M1 V'' vs xs"  
---
>   and "\<not> Rep_Cov M2 M1 V'' vs xs"
2104c2098
<   have "distinct (states (xs || tr) (q2,q1))" 
---
>   have "distinct (states (xs || tr) (q2,q1))"
2106c2100
<   then show ?thesis 
---
>   then show ?thesis
2108c2102
<     using assms(1,10,12-14,2-9) by blast 
---
>     using assms(1,10,12-14,2-9) by blast
2114,2115d2107
< 
< 
2119,2120c2111,2112
< @{verbatim LB} adds together the number of elements in sets calculated via RP for a given set of 
< states and the number of ATC-reaction known to exist but not produced by a state reached by any of 
---
> @{verbatim LB} adds together the number of elements in sets calculated via RP for a given set of
> states and the number of ATC-reaction known to exist but not produced by a state reached by any of
2124,2127c2116,2119
< fun LB :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM 
<           \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> 'in list set 
<           \<Rightarrow> 'state1 set \<Rightarrow> ('in, 'out) ATC set 
<           \<Rightarrow> ('in \<times> 'out) list set \<Rightarrow> nat" 
---
> fun LB :: "('in, 'out, 'state1) FSM \<Rightarrow> ('in, 'out, 'state2) FSM
>           \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> ('in \<times> 'out) list \<Rightarrow> 'in list set
>           \<Rightarrow> 'state1 set \<Rightarrow> ('in, 'out) ATC set
>           \<Rightarrow> ('in \<times> 'out) list set \<Rightarrow> nat"
2129,2131c2121,2123
<   "LB M2 M1 vs xs T S \<Omega> V'' = 
<     (sum (\<lambda> s . card (RP M2 s vs xs V'')) S) 
<     + card ((D M1 T \<Omega>) - 
---
>   "LB M2 M1 vs xs T S \<Omega> V'' =
>     (sum (\<lambda> s . card (RP M2 s vs xs V'')) S)
>     + card ((D M1 T \<Omega>) -
2146,2148c2138,2140
< shows "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')) 
<         \<inter> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}" 
<       "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))) 
---
> shows "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))
>         \<inter> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}"
>       "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))
2150c2142
<       "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))) 
---
>       "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))
2153c2145
<   have "\<forall> io \<in> RP M2 s1 vs xs V'' . io_targets PM (initial PM) io 
---
>   have "\<forall> io \<in> RP M2 s1 vs xs V'' . io_targets PM (initial PM) io
2155c2147
<   proof 
---
>   proof
2157,2158c2149,2150
<     then have "io_targets PM (initial PM) io 
<                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io" 
---
>     then have "io_targets PM (initial PM) io
>                 = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io"
2160,2161c2152,2153
<     moreover have "io_targets M2 (initial M2) io = {s1}" 
<       using \<open>io \<in> RP M2 s1 vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s1 vs xs V''] 
---
>     moreover have "io_targets M2 (initial M2) io = {s1}"
>       using \<open>io \<in> RP M2 s1 vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s1 vs xs V'']
2163c2155
<     ultimately show "io_targets PM (initial PM) io = {s1} \<times> io_targets M1 (initial M1) io" 
---
>     ultimately show "io_targets PM (initial PM) io = {s1} \<times> io_targets M1 (initial M1) io"
2166,2167c2158,2159
<   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')) 
<               = \<Union> (image (\<lambda> io . {s1} \<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))" 
---
>   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))
>               = \<Union> (image (\<lambda> io . {s1} \<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))"
2169,2170c2161,2162
<   moreover have "\<Union> (image (\<lambda> io . {s1} \<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V'')) 
<                   = {s1} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))" 
---
>   moreover have "\<Union> (image (\<lambda> io . {s1} \<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))
>                   = {s1} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))"
2172c2164
<   ultimately have image_split_1 : 
---
>   ultimately have image_split_1 :
2174c2166
<       = {s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))" 
---
>       = {s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))"
2176,2177c2168,2169
<   then show "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))) 
<               = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))" 
---
>   then show "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))
>               = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))"
2179d2170
<   
2181d2171
<   
2183c2173,2175
<   have "\<forall> io \<in> RP M2 s2 vs xs V'' . io_targets PM (initial PM) io 
---
> 
> 
>   have "\<forall> io \<in> RP M2 s2 vs xs V'' . io_targets PM (initial PM) io
2187,2188c2179,2180
<     then have "io_targets PM (initial PM) io 
<                   = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io" 
---
>     then have "io_targets PM (initial PM) io
>                   = io_targets M2 (initial M2) io \<times> io_targets M1 (initial M1) io"
2190,2191c2182,2183
<     moreover have "io_targets M2 (initial M2) io = {s2}" 
<       using \<open>io \<in> RP M2 s2 vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s2 vs xs V''] 
---
>     moreover have "io_targets M2 (initial M2) io = {s2}"
>       using \<open>io \<in> RP M2 s2 vs xs V''\<close> assms(3) RP_state_component_2[of io M2 s2 vs xs V'']
2193c2185
<     ultimately show "io_targets PM (initial PM) io = {s2} \<times> io_targets M1 (initial M1) io" 
---
>     ultimately show "io_targets PM (initial PM) io = {s2} \<times> io_targets M1 (initial M1) io"
2196,2197c2188,2189
<   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) 
<               = \<Union> (image (\<lambda> io . {s2} \<times> io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))" 
---
>   then have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))
>               = \<Union> (image (\<lambda> io . {s2} \<times> io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))"
2200c2192
<                   = {s2} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))" 
---
>                   = {s2} \<times> \<Union> (image (\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))"
2202c2194
<   ultimately have image_split_2 : 
---
>   ultimately have image_split_2 :
2205,2206c2197,2198
<   then show "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))) 
<               = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))" 
---
>   then show "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))
>               = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))"
2209,2210c2201,2202
<   
<   have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')) 
---
> 
>   have "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))
2212,2213c2204,2205
<         = {s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')) 
<           \<inter> {s2} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))" 
---
>         = {s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))
>           \<inter> {s2} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))"
2215,2216c2207,2208
<   moreover have "{s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')) 
<                   \<inter> {s2} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')) = {}" 
---
>   moreover have "{s1} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))
>                   \<inter> {s2} \<times> \<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')) = {}"
2218,2220c2210,2212
<   ultimately show "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')) 
<                     \<inter> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}" 
<     by presburger  
---
>   ultimately show "\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))
>                     \<inter> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}"
>     by presburger
2234,2236c2226,2228
< shows "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')) 
<               \<union> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))) 
<        = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))) 
---
> shows "card (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))
>               \<union> \<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))
>        = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))
2239c2231
<   have "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))" 
---
>   have "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))"
2241c2233
<   moreover have "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))" 
---
>   moreover have "finite (\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))"
2243,2244c2235,2236
<   ultimately show ?thesis 
<     using LB_count_helper_RP_disjoint_and_cards[OF assms] 
---
>   ultimately show ?thesis
>     using LB_count_helper_RP_disjoint_and_cards[OF assms]
2246c2238
< qed 
---
> qed
2253c2245
<   and "well_formed M2"  
---
>   and "well_formed M2"
2256c2248
<   and "path PM (xs || tr) (q2,q1)" 
---
>   and "path PM (xs || tr) (q2,q1)"
2258c2250
<   and "\<not> Rep_Pre M2 M1 vs xs" 
---
>   and "\<not> Rep_Pre M2 M1 vs xs"
2261c2253
<   and "\<not> Rep_Cov M2 M1 V'' vs xs"  
---
>   and "\<not> Rep_Cov M2 M1 V'' vs xs"
2264c2256
<   and "s1 \<in> S" 
---
>   and "s1 \<in> S"
2268c2260
< shows "card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') 
---
> shows "card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'')
2271c2263
<       "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')) 
---
>       "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))
2275c2267
<   have "s1 \<in> nodes M2" 
---
>   have "s1 \<in> nodes M2"
2277c2269
<   have "s2 \<in> nodes M2" 
---
>   have "s2 \<in> nodes M2"
2279,2281c2271,2273
<   have "card (RP M2 s1 vs xs V'') 
<           = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))" 
<     using RP_count_alt_def[OF assms(1-5) \<open>s1 \<in> nodes M2\<close> assms(6-13)] 
---
>   have "card (RP M2 s1 vs xs V'')
>           = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))"
>     using RP_count_alt_def[OF assms(1-5) \<open>s1 \<in> nodes M2\<close> assms(6-13)]
2283,2285c2275,2277
<   moreover have "card (RP M2 s2 vs xs V'') 
<                   = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))" 
<     using RP_count_alt_def[OF assms(1-5) \<open>s2 \<in> nodes M2\<close> assms(6-13)] 
---
>   moreover have "card (RP M2 s2 vs xs V'')
>                   = card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))"
>     using RP_count_alt_def[OF assms(1-5) \<open>s2 \<in> nodes M2\<close> assms(6-13)]
2287,2288c2279,2280
<  
<   moreover show "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')) 
---
> 
>   moreover show "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))
2291c2283
<     assume "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')) 
---
>     assume "\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))
2297c2289
<       "t \<in> io_targets M1 (initial M1) io2" 
---
>       "t \<in> io_targets M1 (initial M1) io2"
2300,2301c2292,2293
<     
<     have dist_prop: "(\<forall> s1 \<in> S . \<forall> s2 \<in> S . s1 \<noteq> s2                                      
---
> 
>     have dist_prop: "(\<forall> s1 \<in> S . \<forall> s2 \<in> S . s1 \<noteq> s2
2304c2296
<                          B M1 io1 \<Omega> \<noteq> B M1 io2 \<Omega> ))" 
---
>                          B M1 io1 \<Omega> \<noteq> B M1 io2 \<Omega> ))"
2306,2308c2298,2300
<     
<     have "io_targets M1 (initial M1) io1 \<inter> io_targets M1 (initial M1) io2 = {}" 
<     proof (rule ccontr) 
---
> 
>     have "io_targets M1 (initial M1) io1 \<inter> io_targets M1 (initial M1) io2 = {}"
>     proof (rule ccontr)
2312,2313c2304,2305
<       
<       then obtain s1 s2 where "s1 \<in> io_targets M1 (initial M1) io1" 
---
> 
>       then obtain s1 s2 where "s1 \<in> io_targets M1 (initial M1) io1"
2317c2309
<       then have "io_targets M1 (initial M1) io1 = {s1}" 
---
>       then have "io_targets M1 (initial M1) io1 = {s1}"
2321c2313
<       then have "s1 = s2" 
---
>       then have "s1 = s2"
2323c2315
<         by auto 
---
>         by auto
2326,2327c2318,2319
<         using \<open>io_targets M1 (initial M1) io1 = {s1}\<close> \<open>io_targets M1 (initial M1) io2 = {s2}\<close> 
<         by auto 
---
>         using \<open>io_targets M1 (initial M1) io1 = {s1}\<close> \<open>io_targets M1 (initial M1) io2 = {s2}\<close>
>         by auto
2329c2321
<         using assms(15-17) dist_prop shared_elem_def(1,2) by blast 
---
>         using assms(15-17) dist_prop shared_elem_def(1,2) by blast
2331,2332c2323,2324
<     then show "False" 
<       using shared_elem_def(3,4) by blast 
---
>     then show "False"
>       using shared_elem_def(3,4) by blast
2335c2327
<   ultimately show "card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') 
---
>   ultimately show "card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'')
2337,2339c2329,2332
<           + card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))" 
<     by linarith 
< qed 
---
>           + card (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))"
>     by linarith
> qed
> 
2345d2337
<   
2352c2344
<   then obtain io where "io \<in> RP M2 s1 vs xs V'' \<and> io \<in> RP M2 s2 vs xs V''" 
---
>   then obtain io where "io \<in> RP M2 s1 vs xs V'' \<and> io \<in> RP M2 s2 vs xs V''"
2354,2355c2346,2347
<   then have "s1 \<in> io_targets M2 (initial M2) io" 
<             "s2 \<in> io_targets M2 (initial M2) io" 
---
>   then have "s1 \<in> io_targets M2 (initial M2) io"
>             "s2 \<in> io_targets M2 (initial M2) io"
2357,2359c2349,2351
<   then have "s1 = s2" 
<     using assms(1) by (metis observable_io_target_is_singleton singletonD) 
<   then show "False" 
---
>   then have "s1 = s2"
>     using assms(1) by (metis observable_io_target_is_singleton singletonD)
>   then show "False"
2367c2359
< where "\<forall> q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) . 
---
> where "\<forall> q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) .
2371,2373c2363,2365
<   let ?f = 
<     "\<lambda> q . if (q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))) 
<       then q 
---
>   let ?f =
>     "\<lambda> q . if (q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)))
>       then q
2376c2368
<   have "(\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) \<subseteq> nodes M1" 
---
>   have "(\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) \<subseteq> nodes M1"
2379,2380c2371,2372
<   then have "\<forall> q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) . 
<               ?f q \<in> nodes M1" 
---
>   then have "\<forall> q \<in> (\<Union> (image (\<lambda> s . \<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) .
>               ?f q \<in> nodes M1"
2384,2385c2376,2377
<                                                       (RP M2 s vs xs V''))) S))" 
<   proof 
---
>                                                       (RP M2 s vs xs V''))) S))"
>   proof
2387c2379
<     then have "?f x = x" 
---
>     then have "?f x = x"
2391c2383
<     then have "?f y = y" 
---
>     then have "?f y = y"
2395c2387
<     then show "x = y" using \<open>?f x = x\<close> \<open>?f y = y\<close> 
---
>     then show "x = y" using \<open>?f x = x\<close> \<open>?f y = y\<close>
2399c2391
<   ultimately show ?thesis 
---
>   ultimately show ?thesis
2403,2406c2395,2396
< 
< 
< 
< 
---
> abbreviation (input) UNION :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b set) \<Rightarrow> 'b set"
>   where "UNION A f \<equiv> \<Union> (f ` A)"
2419c2409
< shows "sum (\<lambda> s . card (RP M2 s vs xs V'')) S 
---
> shows "sum (\<lambda> s . card (RP M2 s vs xs V'')) S
2422c2412
<   have "finite (nodes M2)" 
---
>   have "finite (nodes M2)"
2424c2414
<   moreover have "S \<subseteq> nodes M2" 
---
>   moreover have "S \<subseteq> nodes M2"
2426,2427c2416,2417
<   ultimately have "finite S" 
<     using infinite_super by blast 
---
>   ultimately have "finite S"
>     using infinite_super by blast
2429c2419
<   then have "sum (\<lambda> s . card (RP M2 s vs xs V'')) S 
---
>   then have "sum (\<lambda> s . card (RP M2 s vs xs V'')) S
2436,2437c2426,2427
<     
<     have "(insert s S) \<subseteq> nodes M2" 
---
> 
>     have "(insert s S) \<subseteq> nodes M2"
2439c2429
<     then have "s \<in> nodes M2" 
---
>     then have "s \<in> nodes M2"
2442c2432
<     have "Prereq M2 M1 vs xs T S \<Omega> V''" 
---
>     have "Prereq M2 M1 vs xs T S \<Omega> V''"
2444,2445c2434,2435
<     then have "(\<Sum>s\<in>S. card (RP M2 s vs xs V'')) 
<                 = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))" 
---
>     then have "(\<Sum>s\<in>S. card (RP M2 s vs xs V''))
>                 = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))"
2447,2448c2437,2438
<     moreover have "(\<Sum>s'\<in>(insert s S). card (RP M2 s' vs xs V'')) 
<                     = (\<Sum>s'\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')" 
---
>     moreover have "(\<Sum>s'\<in>(insert s S). card (RP M2 s' vs xs V''))
>                     = (\<Sum>s'\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')"
2450,2452c2440,2442
<     ultimately have S_prop : "(\<Sum>s'\<in>(insert s S). card (RP M2 s' vs xs V'')) 
<                                = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)) 
<                                   + card (RP M2 s vs xs V'')" 
---
>     ultimately have S_prop : "(\<Sum>s'\<in>(insert s S). card (RP M2 s' vs xs V''))
>                                = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))
>                                   + card (RP M2 s vs xs V'')"
2455c2445
<     have "vs@xs \<in> L M1 \<inter> L M2" 
---
>     have "vs@xs \<in> L M1 \<inter> L M2"
2459,2463c2449,2453
<                           "path PM (xs || tr) (q2,q1)" 
<                           "length xs = length tr" 
<       using productF_language_state_intermediate[OF insert.prems(1) 
<             test_tools_props(1)[OF insert.prems(5,4)] OFSM_props(2,1)[OF insert.prems(3)] 
<                                     OFSM_props(2,1)[OF insert.prems(2)]] 
---
>                           "path PM (xs || tr) (q2,q1)"
>                           "length xs = length tr"
>       using productF_language_state_intermediate[OF insert.prems(1)
>             test_tools_props(1)[OF insert.prems(5,4)] OFSM_props(2,1)[OF insert.prems(3)]
>                                     OFSM_props(2,1)[OF insert.prems(2)]]
2465,2468c2455,2458
<     
<     
<     
<     have "card (RP M2 s vs xs V'') 
---
> 
> 
> 
>     have "card (RP M2 s vs xs V'')
2471,2476c2461,2466
<             RP_count_alt_def[OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _ 
<                                 \<open>s\<in>nodes M2\<close> test_tools_props(1)[OF insert.prems(5,4)] 
<                                 suffix_path insert.prems(8) 
<                                 test_tools_props(2)[OF insert.prems(5,4)] assms(6) insert.prems(9)] 
<       by linarith 
<     
---
>             RP_count_alt_def[OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _
>                                 \<open>s\<in>nodes M2\<close> test_tools_props(1)[OF insert.prems(5,4)]
>                                 suffix_path insert.prems(8)
>                                 test_tools_props(2)[OF insert.prems(5,4)] assms(6) insert.prems(9)]
>       by linarith
> 
2480,2481c2470,2471
<       have "(\<Sum>c\<in>insert s S. card (UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1)))) 
<             = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) 
---
>       have "(\<Sum>c\<in>insert s S. card (UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))))
>             = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))
2485,2489c2475,2479
<         using \<open>(\<Sum>s'\<in>insert s S. card (RP M2 s' vs xs V'')) 
<                 = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)) 
<                     + card (RP M2 s vs xs V'')\<close> 
<               \<open>card (RP M2 s vs xs V'') 
<                 = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\<close> 
---
>         using \<open>(\<Sum>s'\<in>insert s S. card (RP M2 s' vs xs V''))
>                 = (\<Sum>s\<in>S. card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))
>                     + card (RP M2 s vs xs V'')\<close>
>               \<open>card (RP M2 s vs xs V'')
>                 = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\<close>
2491c2481
<     qed 
---
>     qed
2494,2495c2484,2485
<   then show ?thesis 
<     using assms by blast 
---
>   then show ?thesis
>     using assms by blast
2499c2489
< lemma finite_insert_card : 
---
> lemma finite_insert_card :
2515,2516c2505,2506
<   and     "\<not> Rep_Cov M2 M1 V'' vs xs"               
< shows "sum (\<lambda> s . card (RP M2 s vs xs V'')) S 
---
>   and     "\<not> Rep_Cov M2 M1 V'' vs xs"
> shows "sum (\<lambda> s . card (RP M2 s vs xs V'')) S
2519c2509
<   have "finite (nodes M2)" 
---
>   have "finite (nodes M2)"
2521c2511
<   moreover have "S \<subseteq> nodes M2" 
---
>   moreover have "S \<subseteq> nodes M2"
2523,2524c2513,2514
<   ultimately have "finite S" 
<     using infinite_super by blast 
---
>   ultimately have "finite S"
>     using infinite_super by blast
2526c2516
<   then show "sum (\<lambda> s . card (RP M2 s vs xs V'')) S 
---
>   then show "sum (\<lambda> s . card (RP M2 s vs xs V'')) S
2534c2524
<     have "(insert s S) \<subseteq> nodes M2" 
---
>     have "(insert s S) \<subseteq> nodes M2"
2536c2526
<     then have "s \<in> nodes M2" 
---
>     then have "s \<in> nodes M2"
2539c2529
<     have "Prereq M2 M1 vs xs T S \<Omega> V''" 
---
>     have "Prereq M2 M1 vs xs T S \<Omega> V''"
2541,2542c2531,2532
<     then have applied_IH : "(\<Sum>s\<in>S. card (RP M2 s vs xs V'')) 
<                               = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)" 
---
>     then have applied_IH : "(\<Sum>s\<in>S. card (RP M2 s vs xs V''))
>                               = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)"
2546,2547c2536,2537
<                               "path PM (xs || tr) (q2,q1)" 
<                               "length xs = length tr" 
---
>                               "path PM (xs || tr) (q2,q1)"
>                               "length xs = length tr"
2549,2550c2539,2540
<             [OF insert.prems(1) test_tools_props(1)[OF insert.prems(5,4)] 
<                 OFSM_props(2,1)[OF insert.prems(3)] OFSM_props(2,1)[OF insert.prems(2)]] 
---
>             [OF insert.prems(1) test_tools_props(1)[OF insert.prems(5,4)]
>                 OFSM_props(2,1)[OF insert.prems(3)] OFSM_props(2,1)[OF insert.prems(2)]]
2552,2553c2542,2543
<       
<     have "s \<in> insert s S" 
---
> 
>     have "s \<in> insert s S"
2555,2556c2545,2546
<     
<     have "vs@xs \<in> L M1 \<inter> L M2" 
---
> 
>     have "vs@xs \<in> L M1 \<inter> L M2"
2559c2549
<     have "\<forall> s' \<in> S . (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
---
>     have "\<forall> s' \<in> S . (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
2561c2551
<     proof 
---
>     proof
2563c2553
<       
---
> 
2566c2556
<       have "s' \<in> insert s S" 
---
>       have "s' \<in> insert s S"
2569c2559
<       show "(\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
---
>       show "(\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
2571c2561
<         using OFSM_props(2,1)[OF assms(3)] OFSM_props(2,1,3)[OF assms(2)] 
---
>         using OFSM_props(2,1)[OF assms(3)] OFSM_props(2,1,3)[OF assms(2)]
2573c2563
<                 [OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _ test_tools_props(1)[OF insert.prems(5,4)] 
---
>                 [OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _ test_tools_props(1)[OF insert.prems(5,4)]
2575,2576c2565,2566
<                     insert.prems(6,9,7) \<open>s \<noteq> s'\<close> \<open>s \<in> insert s S\<close> \<open>s' \<in> insert s S\<close> 
<                     test_tools_props(4)[OF insert.prems(5,4)]] 
---
>                     insert.prems(6,9,7) \<open>s \<noteq> s'\<close> \<open>s \<in> insert s S\<close> \<open>s' \<in> insert s S\<close>
>                     test_tools_props(4)[OF insert.prems(5,4)]]
2579,2580c2569,2570
<     then have disj_insert : "(\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
<                                 \<inter> (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) = {}" 
---
>     then have disj_insert : "(\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
>                                 \<inter> (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) = {}"
2582c2572
<     have finite_S : "finite (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)" 
---
>     have finite_S : "finite (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)"
2586c2576
<       by (meson RP_io_targets_finite_M1 \<open>vs @ xs \<in> L M1 \<inter> L M2\<close> assms(2) assms(5) 
---
>       by (meson RP_io_targets_finite_M1 \<open>vs @ xs \<in> L M1 \<inter> L M2\<close> assms(2) assms(5)
2589,2591c2579,2581
<     
<     have "card (\<Union>s\<in>insert s S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
<           = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
---
> 
>     have "card (\<Union>s\<in>insert s S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
>           = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
2594,2595c2584,2585
<       have f1: "insert (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) 
<                     ((\<lambda>c. UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))) ` S) 
---
>       have f1: "insert (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))
>                     ((\<lambda>c. UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))) ` S)
2598c2588
<       have "\<forall>c. c \<in> S \<longrightarrow> UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)) 
---
>       have "\<forall>c. c \<in> S \<longrightarrow> UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))
2600c2590
<         by (meson \<open>\<forall>s'\<in>S. (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
---
>         by (meson \<open>\<forall>s'\<in>S. (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
2602c2592
<       then have "UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)) 
---
>       then have "UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))
2609c2599
<     have "card (RP M2 s vs xs V'') 
---
>     have "card (RP M2 s vs xs V'')
2611,2614c2601,2604
<       using assms(2) assms(3) 
<             RP_count_alt_def[OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _ \<open>s \<in> nodes M2\<close> 
<                                 test_tools_props(1)[OF insert.prems(5,4)] suffix_path 
<                                 insert.prems(8) test_tools_props(2)[OF insert.prems(5,4)] 
---
>       using assms(2) assms(3)
>             RP_count_alt_def[OF \<open>vs@xs \<in> L M1 \<inter> L M2\<close> _ _ _ _ \<open>s \<in> nodes M2\<close>
>                                 test_tools_props(1)[OF insert.prems(5,4)] suffix_path
>                                 insert.prems(8) test_tools_props(2)[OF insert.prems(5,4)]
2620c2610
<       have "(\<Sum>c\<in>insert s S. card (RP M2 c vs xs V'')) 
---
>       have "(\<Sum>c\<in>insert s S. card (RP M2 c vs xs V''))
2624,2628c2614,2618
<         using \<open>card (RP M2 s vs xs V'') 
<                 = card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\<close> 
<               \<open>card (\<Union>s\<in>insert s S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
<                 = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) 
<                   + card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\<close> applied_IH 
---
>         using \<open>card (RP M2 s vs xs V'')
>                 = card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\<close>
>               \<open>card (\<Union>s\<in>insert s S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
>                 = card (\<Union>s\<in>S. \<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)
>                   + card (\<Union>a\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\<close> applied_IH
2649,2650c2639,2640
< proof - 
<   have "(\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) \<subseteq> nodes M1" 
---
> proof -
>   have "(\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) \<subseteq> nodes M1"
2652c2642
<   moreover have "finite (nodes M1)" 
---
>   moreover have "finite (nodes M1)"
2654,2660c2644,2650
<   ultimately have "card (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) 
<                     \<le> card (nodes M1)" 
<     by (meson card_mono) 
<   
<   moreover have "(\<Sum>s\<in>S. card (RP M2 s vs xs V'')) 
<                     = card (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))" 
<     using LB_count_helper_RP_disjoint_M1_union[OF assms] 
---
>   ultimately have "card (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))
>                     \<le> card (nodes M1)"
>     by (meson card_mono)
> 
>   moreover have "(\<Sum>s\<in>S. card (RP M2 s vs xs V''))
>                     = card (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))"
>     using LB_count_helper_RP_disjoint_M1_union[OF assms]
2662,2663c2652,2653
<    
<   ultimately show ?thesis 
---
> 
>   ultimately show ?thesis
2674c2664
< where "q \<in> nodes M \<and> RS = IO_set M q \<Omega>" 
---
> where "q \<in> nodes M \<and> RS = IO_set M q \<Omega>"
2676c2666
<   have "RS \<in> image (\<lambda> io . B M io \<Omega>) (LS\<^sub>i\<^sub>n M (initial M) T)" 
---
>   have "RS \<in> image (\<lambda> io . B M io \<Omega>) (LS\<^sub>i\<^sub>n M (initial M) T)"
2678c2668
<   then obtain io where "RS = B M io \<Omega>" "io \<in> LS\<^sub>i\<^sub>n M (initial M) T" 
---
>   then obtain io where "RS = B M io \<Omega>" "io \<in> LS\<^sub>i\<^sub>n M (initial M) T"
2680c2670
<   then have "io \<in> language_state M (initial M)" 
---
>   then have "io \<in> language_state M (initial M)"
2682,2684c2672,2674
<   then obtain q where "{q} = io_targets M (initial M) io" 
<     by (metis assms(1) io_targets_observable_singleton_ob) 
<   then have "B M io \<Omega> = \<Union> (image (\<lambda> s . IO_set M s \<Omega>) {q})" 
---
>   then obtain q where "{q} = io_targets M (initial M) io"
>     by (metis assms(1) io_targets_observable_singleton_ob)
>   then have "B M io \<Omega> = \<Union> (image (\<lambda> s . IO_set M s \<Omega>) {q})"
2686c2676
<   then have "B M io \<Omega> = IO_set M q \<Omega>" 
---
>   then have "B M io \<Omega> = IO_set M q \<Omega>"
2688c2678
<   then have "RS = IO_set M q \<Omega>" using \<open>RS = B M io \<Omega>\<close> 
---
>   then have "RS = IO_set M q \<Omega>" using \<open>RS = B M io \<Omega>\<close>
2690,2692c2680,2682
<   moreover have "q \<in> nodes M" using \<open>{q} = io_targets M (initial M) io\<close> 
<     by (metis FSM.nodes.initial insertI1 io_targets_nodes) 
<   ultimately show ?thesis 
---
>   moreover have "q \<in> nodes M" using \<open>{q} = io_targets M (initial M) io\<close>
>     by (metis FSM.nodes.initial insertI1 io_targets_nodes)
>   ultimately show ?thesis
2701,2703c2691,2693
< proof 
<   assume "q \<in> (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))" 
<   then obtain s' where "s' \<in> S" "q \<in> (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s' vs xs V'')))" 
---
> proof
>   assume "q \<in> (\<Union>s\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))"
>   then obtain s' where "s' \<in> S" "q \<in> (\<Union> (image (io_targets M1 (initial M1)) (RP M2 s' vs xs V'')))"
2705c2695
<   then obtain xs' where "q \<in> io_targets M1 (initial M1) xs'" "xs' \<in> RP M2 s' vs xs V''" 
---
>   then obtain xs' where "q \<in> io_targets M1 (initial M1) xs'" "xs' \<in> RP M2 s' vs xs V''"
2707,2709c2697,2699
<   then have "{q} = io_targets M1 (initial M1) xs'" 
<     by (metis assms(1) observable_io_target_is_singleton) 
<   then have "B M1 xs' \<Omega> = \<Union> (image (\<lambda> s . IO_set M1 s \<Omega>) {q})" 
---
>   then have "{q} = io_targets M1 (initial M1) xs'"
>     by (metis assms(1) observable_io_target_is_singleton)
>   then have "B M1 xs' \<Omega> = \<Union> (image (\<lambda> s . IO_set M1 s \<Omega>) {q})"
2711c2701
<   then have "B M1 xs' \<Omega> = IO_set M1 q \<Omega>" 
---
>   then have "B M1 xs' \<Omega> = IO_set M1 q \<Omega>"
2713c2703
<   moreover have "B M1 xs' \<Omega> \<in> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}" 
---
>   moreover have "B M1 xs' \<Omega> \<in> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}"
2715,2717c2705,2707
<   ultimately have "IO_set M1 q \<Omega> \<in> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}" 
<     by blast 
<   moreover have "IO_set M1 q \<Omega> \<notin> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}" 
---
>   ultimately have "IO_set M1 q \<Omega> \<in> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}"
>     by blast
>   moreover have "IO_set M1 q \<Omega> \<notin> {B M1 xs' \<Omega> | xs' s' . s' \<in> S \<and> xs' \<in> RP M2 s' vs xs V''}"
2719c2709
<   ultimately show "False" 
---
>   ultimately show "False"
2722c2712
<   
---
> 
2739c2729
< shows "LB M2 M1 vs xs T S \<Omega> V'' \<le> |M1|" 
---
> shows "LB M2 M1 vs xs T S \<Omega> V'' \<le> |M1|"
2741c2731
<   
---
> 
2746,2747c2736,2737
<   
<   have "finite (nodes M1)" 
---
> 
>   have "finite (nodes M1)"
2749c2739
<   then have "finite ?D" 
---
>   then have "finite ?D"
2751c2741
<   then have "finite ?DB" 
---
>   then have "finite ?DB"
2754,2755c2744,2745
<   \<comment> \<open>Proof sketch: 
<       Construct a function f (via induction) that maps each response set in ?DB to some state 
---
>   \<comment> \<open>Proof sketch:
>       Construct a function f (via induction) that maps each response set in ?DB to some state
2757c2747
<       This is then used to show that each response sets in ?DB indicates the existence of 
---
>       This is then used to show that each response sets in ?DB indicates the existence of
2760,2761c2750,2751
<   have states_f : "\<And> DB' . DB' \<subseteq> ?DB \<Longrightarrow> \<exists> f . inj_on f DB' 
<                                                 \<and> image f DB' \<subseteq> (nodes M1) - ?RP 
---
>   have states_f : "\<And> DB' . DB' \<subseteq> ?DB \<Longrightarrow> \<exists> f . inj_on f DB'
>                                                 \<and> image f DB' \<subseteq> (nodes M1) - ?RP
2765c2755
<     have "finite DB'" 
---
>     have "finite DB'"
2768c2758
<       have "infinite ?DB" 
---
>       have "infinite ?DB"
2770c2760
<       then show "False" 
---
>       then show "False"
2772,2773c2762,2763
<     qed 
<     then show "\<exists> f . inj_on f DB' \<and> image f DB' \<subseteq> (nodes M1) - ?RP 
---
>     qed
>     then show "\<exists> f . inj_on f DB' \<and> image f DB' \<subseteq> (nodes M1) - ?RP
2781c2771
<       have "DB' \<subseteq> ?DB" 
---
>       have "DB' \<subseteq> ?DB"
2783,2786c2773,2776
<       obtain f' where "inj_on f' DB'" 
<                       "image f' DB' \<subseteq> (nodes M1) - ?RP" 
<                       "\<forall> RS \<in> DB' . IO_set M1 (f' RS) \<Omega> = RS"  
<         using insert.IH[OF insert.prems(1-9) \<open>DB' \<subseteq> ?DB\<close>] 
---
>       obtain f' where "inj_on f' DB'"
>                       "image f' DB' \<subseteq> (nodes M1) - ?RP"
>                       "\<forall> RS \<in> DB' . IO_set M1 (f' RS) \<Omega> = RS"
>         using insert.IH[OF insert.prems(1-9) \<open>DB' \<subseteq> ?DB\<close>]
2788,2789c2778,2779
<       
<       have "RS \<in> D M1 T \<Omega>" 
---
> 
>       have "RS \<in> D M1 T \<Omega>"
2791,2792c2781,2782
<       obtain q where "q \<in> nodes M1" "RS = IO_set M1 q \<Omega>" 
<         using insert.prems(2)  LB_count_helper_D_states[OF _ \<open>RS \<in> D M1 T \<Omega>\<close>] 
---
>       obtain q where "q \<in> nodes M1" "RS = IO_set M1 q \<Omega>"
>         using insert.prems(2)  LB_count_helper_D_states[OF _ \<open>RS \<in> D M1 T \<Omega>\<close>]
2794,2798c2784,2788
<       then have "IO_set M1 q \<Omega> \<in> ?DB" 
<         using insert.prems(10) by blast 
<       
<       have "q \<notin> ?RP" 
<         using insert.prems(2) LB_count_helper_LB2[OF _ \<open>IO_set M1 q \<Omega> \<in> ?DB\<close>] 
---
>       then have "IO_set M1 q \<Omega> \<in> ?DB"
>         using insert.prems(10) by blast
> 
>       have "q \<notin> ?RP"
>         using insert.prems(2) LB_count_helper_LB2[OF _ \<open>IO_set M1 q \<Omega> \<in> ?DB\<close>]
2802,2803c2792,2793
<       have "inj_on ?f (insert RS DB')" 
<       proof 
---
>       have "inj_on ?f (insert RS DB')"
>       proof
2805c2795
<         proof 
---
>         proof
2810c2800
<             have "\<forall>P c f. \<exists>Pa. ((c::'c) \<notin> f ` P \<or> (Pa::('a \<times> 'b) list set) \<in> P) 
---
>             have "\<forall>P c f. \<exists>Pa. ((c::'c) \<notin> f ` P \<or> (Pa::('a \<times> 'b) list set) \<in> P)
2823c2813
<           qed 
---
>           qed
2829c2819
<       moreover have "image ?f (insert RS DB') \<subseteq> (nodes M1) - ?RP" 
---
>       moreover have "image ?f (insert RS DB') \<subseteq> (nodes M1) - ?RP"
2832c2822
<         then have "image ?f {RS} \<subseteq> (nodes M1) - ?RP" 
---
>         then have "image ?f {RS} \<subseteq> (nodes M1) - ?RP"
2834c2824
<         moreover have "image ?f (insert RS DB') = image ?f {RS} \<union> image ?f DB'" 
---
>         moreover have "image ?f (insert RS DB') = image ?f {RS} \<union> image ?f DB'"
2836,2838c2826,2828
<         ultimately show ?thesis 
<           by (metis (no_types, lifting) \<open>image f' DB' \<subseteq> (nodes M1) - ?RP\<close> fun_upd_other image_cong 
<               image_insert insert.hyps(2) insert_subset) 
---
>         ultimately show ?thesis
>           by (metis (no_types, lifting) \<open>image f' DB' \<subseteq> (nodes M1) - ?RP\<close> fun_upd_other image_cong
>               image_insert insert.hyps(2) insert_subset)
2841,2843c2831,2833
<         using \<open>RS = IO_set M1 q \<Omega>\<close> \<open>\<forall>RS\<in>DB'. IO_set M1 (f' RS) \<Omega> = RS\<close> by auto 
<         
<       ultimately show ?case 
---
>         using \<open>RS = IO_set M1 q \<Omega>\<close> \<open>\<forall>RS\<in>DB'. IO_set M1 (f' RS) \<Omega> = RS\<close> by auto
> 
>       ultimately show ?case
2848c2838
<   have "?DB \<subseteq> ?DB" 
---
>   have "?DB \<subseteq> ?DB"
2850c2840
<   obtain f where "inj_on f ?DB" "image f ?DB \<subseteq> (nodes M1) - ?RP" 
---
>   obtain f where "inj_on f ?DB" "image f ?DB \<subseteq> (nodes M1) - ?RP"
2852c2842
<   have "finite (nodes M1 - ?RP)" 
---
>   have "finite (nodes M1 - ?RP)"
2854,2856c2844,2846
<   have "card ?DB \<le> card (nodes M1 - ?RP)" 
<     using card_inj_on_le[OF \<open>inj_on f ?DB\<close> \<open>image f ?DB \<subseteq> (nodes M1) - ?RP\<close> 
<                             \<open>finite (nodes M1 - ?RP)\<close>] 
---
>   have "card ?DB \<le> card (nodes M1 - ?RP)"
>     using card_inj_on_le[OF \<open>inj_on f ?DB\<close> \<open>image f ?DB \<subseteq> (nodes M1) - ?RP\<close>
>                             \<open>finite (nodes M1 - ?RP)\<close>]
2858,2859c2848,2849
<   
<   have "?RP \<subseteq> nodes M1" 
---
> 
>   have "?RP \<subseteq> nodes M1"
2861,2863c2851,2853
<   then have "card (nodes M1 - ?RP) = card (nodes M1) - card ?RP" 
<     by (meson \<open>finite (nodes M1)\<close> card_Diff_subset infinite_subset) 
<   then have "card ?DB \<le> card (nodes M1) - card ?RP" 
---
>   then have "card (nodes M1 - ?RP) = card (nodes M1) - card ?RP"
>     by (meson \<open>finite (nodes M1)\<close> card_Diff_subset infinite_subset)
>   then have "card ?DB \<le> card (nodes M1) - card ?RP"
2866c2856
<   have "vs @ xs \<in> L M2 \<inter> L M1" 
---
>   have "vs @ xs \<in> L M2 \<inter> L M1"
2868c2858
<   have "(sum (\<lambda> s . card (RP M2 s vs xs V'')) S) = card ?RP" 
---
>   have "(sum (\<lambda> s . card (RP M2 s vs xs V'')) S) = card ?RP"
2870c2860
<   moreover have "card ?RP \<le> card (nodes M1)" 
---
>   moreover have "card ?RP \<le> card (nodes M1)"
2872,2873c2862,2863
<   ultimately show ?thesis 
<     unfolding LB.simps using \<open>card ?DB \<le> card (nodes M1) - card ?RP\<close> 
---
>   ultimately show ?thesis
>     unfolding LB.simps using \<open>card ?DB \<le> card (nodes M1) - card ?RP\<close>
2876,2878c2866,2868
<   
<   
<   
---
> 
> 
> 
2892c2882
<   have "LB M2 M1 vs xs T S \<Omega> V'' \<le> card (nodes M1)" 
---
>   have "LB M2 M1 vs xs T S \<Omega> V'' \<le> card (nodes M1)"
2894c2884
<   moreover have "card (nodes M1) \<le> m" 
---
>   moreover have "card (nodes M1) \<le> m"
2896c2886
<   ultimately show "False" 
---
>   ultimately show "False"
==========
Affine_Arithmetic
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Affine_Approximation.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Affine_Approximation.thy
561c561
<   "ivls_of_aforms prec = map (\<lambda>a. Some (float_of (Inf_aform' prec a), float_of(Sup_aform' prec a)))"
---
>   "ivls_of_aforms prec = map (\<lambda>a. Interval' (float_of (Inf_aform' prec a)) (float_of(Sup_aform' prec a)))"
578c578
<   by (auto simp: bounded_by_def ivls_of_aforms_def Affine_def valuate_def Pi_iff
---
>   by (auto simp: bounded_by_def ivls_of_aforms_def Affine_def valuate_def Pi_iff set_of_eq
580c580
<       dest!: nth_in_AffineI split: option.splits)
---
>       dest!: nth_in_AffineI split: Interval'_splits)
690c690
< definition "mid_err ivl = ((fst ivl + snd ivl::float)/2, (snd ivl - fst ivl)/2)"
---
> definition "mid_err ivl = ((lower ivl + upper ivl::float)/2, (upper ivl - lower ivl)/2)"
1239c1239,1240
< definition "ivl_err l u \<equiv> (((u + l)/2, zero_pdevs::real pdevs), (u - l) / 2)"
---
> definition ivl_err :: "real interval \<Rightarrow> (real \<times> real pdevs) \<times> real"
>   where "ivl_err ivl \<equiv> (((upper ivl + lower ivl)/2, zero_pdevs::real pdevs), (upper ivl - lower ivl) / 2)"
1718,1719c1719,1720
< definition "Inf_aform_err p Rd = (float_of (truncate_down p (Inf_aform' p (fst Rd) - (snd Rd))))"
< definition "Sup_aform_err p Rd = (float_of (truncate_up p (Sup_aform' p (fst Rd) + (snd Rd))))"
---
> definition "Inf_aform_err p Rd = (float_of (truncate_down p (Inf_aform' p (fst Rd) - abs(snd Rd))))"
> definition "Sup_aform_err p Rd = (float_of (truncate_up p (Sup_aform' p (fst Rd) + abs(snd Rd))))"
1721,1724c1722,1739
< definition "approx_un p f a = do {
<   (rd) \<leftarrow> a;
<   (l, u) \<leftarrow> f (Inf_aform_err p rd) (Sup_aform_err p rd);
<   Some (ivl_err (real_of_float l) ((real_of_float u)))
---
> context includes interval.lifting begin
> lift_definition ivl_of_aform_err::"nat \<Rightarrow> aform_err \<Rightarrow> float interval"
>   is "\<lambda>p Rd. (Inf_aform_err p Rd, Sup_aform_err p Rd)"
>   by (auto simp: aform_err_def  Inf_aform_err_def Sup_aform_err_def
>       intro!: truncate_down_le truncate_up_le add_increasing[OF _ Inf_aform'_le_Sup_aform'])
> lemma lower_ivl_of_aform_err: "lower (ivl_of_aform_err p Rd) = Inf_aform_err p Rd"
>   and upper_ivl_of_aform_err: "upper (ivl_of_aform_err p Rd) = Sup_aform_err p Rd"
>   by (transfer, simp)+
> end
> 
> definition approx_un::"nat
>      \<Rightarrow> (float interval \<Rightarrow> float interval option)
>         \<Rightarrow> ((real \<times> real pdevs) \<times> real) option
>            \<Rightarrow> ((real \<times> real pdevs) \<times> real) option"
>   where "approx_un p f a = do {
>   rd \<leftarrow> a;
>   ivl \<leftarrow> f (ivl_of_aform_err p rd);
>   Some (ivl_err (real_interval ivl))
1727,1728c1742,1743
< definition interval_extension1::"(float \<Rightarrow> float \<Rightarrow> (float * float) option) \<Rightarrow> (real \<Rightarrow> real) \<Rightarrow> bool"
<   where "interval_extension1 F f \<longleftrightarrow> (\<forall>l u i s. F l u = Some (i, s) \<longrightarrow> f ` {l .. u} \<subseteq> {i .. s})"
---
> definition interval_extension1::"(float interval \<Rightarrow> (float interval) option) \<Rightarrow> (real \<Rightarrow> real) \<Rightarrow> bool"
>   where "interval_extension1 F f \<longleftrightarrow> (\<forall>ivl ivl'. F ivl = Some ivl' \<longrightarrow> (\<forall>x. x \<in>\<^sub>r ivl \<longrightarrow> f x \<in>\<^sub>r ivl'))"
1732,1733c1747,1749
<   assumes "F l u = Some (i, s)"
<   shows "f ` {l .. u} \<subseteq> {i .. s}"
---
>   assumes "F ivl = Some ivl'"
>   assumes "x \<in>\<^sub>r ivl"
>   shows "f x \<in>\<^sub>r ivl'"
1751,1752c1767,1768
< lemma aform_err_ivl_err[simp]: "aform_err e (ivl_err (l') (u')) = {l'..u'}"
<   by (auto simp: aform_err_def ivl_err_def aform_val_def divide_simps)
---
> lemma aform_err_ivl_err[simp]: "aform_err e (ivl_err ivl') = set_of ivl'"
>   by (auto simp: aform_err_def ivl_err_def aform_val_def divide_simps set_of_eq)
1762a1779,1785
> lemma ivl_of_aform_err:
>   fixes X
>   assumes e: "e \<in> UNIV \<rightarrow> {-1 .. 1}"
>   shows "x \<in> aform_err e X \<Longrightarrow> x \<in>\<^sub>r ivl_of_aform_err p X"
>   using Inf_Sup_aform_err[OF e, of X p]
>   by (auto simp: set_of_eq lower_ivl_of_aform_err upper_ivl_of_aform_err)
> 
1767c1790
<   assumes x: "case X'err of None \<Rightarrow> True | Some X'err \<Rightarrow> x \<in> aform_err e (X'err)"
---
>   assumes x: "case X'err of None \<Rightarrow> True | Some X'err \<Rightarrow> x \<in> aform_err e X'err"
1770,1774c1793,1795
<   from au obtain l' u' X' err
<     where F: " F (Inf_aform_err p (X', err)) (Sup_aform_err p (X', err)) = Some (l', u')"
<         (is "F ?i ?s = _")
<       and Y: "Ye = ivl_err (real_of_float l') (real_of_float u')"
<          (is "_ = (ivl_err ?l'  ?u')")
---
>   from au obtain ivl' X' err
>     where F: "F (ivl_of_aform_err p (X', err)) = Some (ivl')"
>       and Y: "Ye = ivl_err (real_interval ivl')"
1780,1784c1801,1806
<   also note Inf_Sup_aform_err[OF e, where p=p]
<   finally have "x \<in> {?i .. ?s}" .
<   then have "f x \<in> f ` {real_of_float ?i .. real_of_float ?s}" by (rule imageI)
<   also note interval_extension1D[OF ie F]
<   also have "{real_of_float l'..real_of_float u'} = aform_err e Ye" unfolding Y aform_err_ivl_err ..
---
>   from ivl_of_aform_err[OF e this]
>   have "x \<in>\<^sub>r ivl_of_aform_err p (X', err)" .
>   from interval_extension1D[OF ie F this]
>   have "f x \<in>\<^sub>r ivl'" .
>   also have "\<dots> = aform_err e Ye"
>     unfolding Y aform_err_ivl_err ..
1789,1791c1811,1813
<   (l, u) \<leftarrow> f (Inf_aform_err p rd) (Sup_aform_err p rd)
<              (Inf_aform_err p sd) (Sup_aform_err p sd);
<   Some (ivl_err (real_of_float l) ((real_of_float u)))
---
>   ivl \<leftarrow> f (ivl_of_aform_err p rd)
>              (ivl_of_aform_err p sd);
>   Some (ivl_err (real_interval ivl))
1794,1796c1816,1818
< definition interval_extension2::"(float \<Rightarrow> float \<Rightarrow> float \<Rightarrow> float \<Rightarrow> (float * float) option) \<Rightarrow> (real \<Rightarrow> real \<Rightarrow> real) \<Rightarrow> bool"
<   where "interval_extension2 F f \<longleftrightarrow> (\<forall>l u l' u' i s. F l u l' u' = Some (i, s) \<longrightarrow>
<     (\<lambda>(x, y). f x y) ` ({l .. u} \<times> {l' .. u'}) \<subseteq> {i .. s})"
---
> definition interval_extension2::"(float interval \<Rightarrow> float interval \<Rightarrow> float interval option) \<Rightarrow> (real \<Rightarrow> real \<Rightarrow> real) \<Rightarrow> bool"
>   where "interval_extension2 F f \<longleftrightarrow> (\<forall>ivl1 ivl2 ivl. F ivl1 ivl2 = Some ivl \<longrightarrow>
>     (\<forall>x y. x \<in>\<^sub>r ivl1 \<longrightarrow> y \<in>\<^sub>r ivl2 \<longrightarrow> f x y \<in>\<^sub>r ivl))"
1800,1801c1822,1823
<   assumes "F l u l' u' = Some (i, s)"
<   shows "(\<lambda>(x, y). f x y) ` ({l .. u} \<times> {l' .. u'}) \<subseteq> {i .. s}"
---
>   assumes "F ivl1 ivl2 = Some ivl"
>   shows "x \<in>\<^sub>r ivl1 \<Longrightarrow> y \<in>\<^sub>r ivl2 \<Longrightarrow> f x y \<in>\<^sub>r ivl"
1812,1817c1834,1836
<   from ab obtain l' u'
<     where F: "F (Inf_aform_err p (W', errw)) (Sup_aform_err p (W', errw))
<         (Inf_aform_err p (X', errx)) (Sup_aform_err p (X', errx)) = Some (l', u')"
<              (is "F ?i ?s ?i' ?s' = _")
<       and Y: "Ye = ivl_err (real_of_float l') (real_of_float u')"
<       (is "_ = ivl_err ?l' ?u'")
---
>   from ab obtain ivl'
>     where F: "F (ivl_of_aform_err p (W', errw)) (ivl_of_aform_err p (X', errx)) = Some ivl'"
>       and Y: "Ye = ivl_err (real_interval ivl')"
1819,1830c1838,1842
<   { note w
<     also note Inf_Sup_aform_err[OF e, where p=p]
<     finally have "w \<in> {?i .. ?s}" .
<   } moreover {
<     note x
<     also note Inf_Sup_aform_err[OF e, where p=p]
<     finally have "x \<in> {?i' .. ?s'}" .
<   } ultimately
<   have "f w x \<in> (\<lambda>(a, b). f a b) ` ({real_of_float ?i .. ?s} \<times> {real_of_float ?i' .. ?s'})"
<     by auto
<   also note interval_extension2D[OF ie F]
<   also have "{real_of_float l'..real_of_float u'} = aform_err e Ye" unfolding Y aform_err_ivl_err ..
---
>   from interval_extension2D[OF ie F
>         ivl_of_aform_err[OF e, where p=p, OF w]
>         ivl_of_aform_err[OF e, where p=p, OF x]]
>   have "f w x \<in>\<^sub>r ivl'" .
>   also have "\<dots> = aform_err e Ye" unfolding Y aform_err_ivl_err ..
1836,1842c1848,1852
<     i1 = Inf_aform_err p a1;
<     s1 = Sup_aform_err p a1;
<     i2 = Inf_aform_err p a2;
<     s2 = Sup_aform_err p a2
<   in if s1 < i2 then a1
<       else if s2 < i1 then a2
<       else ivl_err (min i1 i2) (min s1 s2))"
---
>     ivl1 = ivl_of_aform_err p a1;
>     ivl2 = ivl_of_aform_err p a2
>   in if upper ivl1 < lower ivl2 then a1
>       else if upper ivl2 < lower ivl1 then a2
>       else ivl_err (real_interval (min_interval ivl1 ivl2)))"
1846,1852c1856,1860
<     i1 = Inf_aform_err p a1;
<     s1 = Sup_aform_err p a1;
<     i2 = Inf_aform_err p a2;
<     s2 = Sup_aform_err p a2
<    in if s1 < i2 then (a2)
<         else if s2 < i1 then (a1)
<         else ivl_err (max i1 i2) (max s1 s2))"
---
>     ivl1 = ivl_of_aform_err p a1;
>     ivl2 = ivl_of_aform_err p a2
>   in if upper ivl1 < lower ivl2 then a2
>       else if upper ivl2 < lower ivl1 then a1
>       else ivl_err (real_interval (max_interval ivl1 ivl2)))"
2082c2090
< lemmas approx_emptyD = approx[OF bounded_by_None[of Nil] sym, simplified]
---
> lemmas approx_emptyD = approx[OF bounded_by_None[of Nil], simplified]
2085,2086c2093,2094
<   assumes "range_reducer p l = Some (r, r')"
<   obtains n::int where "r \<le> n * (2 * pi)" "n * (2 * pi) \<le> r'"
---
>   assumes "range_reducer p l = Some ivl"
>   obtains n::int where "n * (2 * pi) \<in>\<^sub>r ivl"
2089,2091c2097
<   with assms have
<     "r \<le> - \<lfloor>l / (2 * pi)\<rfloor> * (2 * pi)"
<     "- \<lfloor>l / (2 * pi)\<rfloor> * (2 * pi) \<le> r'"
---
>   with assms have "- \<lfloor>l / (2 * pi)\<rfloor> * (2 * pi) \<in>\<^sub>r ivl"
2096,2097c2102,2103
<   case True then have "r \<le> real_of_int 0 * (2 * pi)" "real_of_int 0 * (2 * pi) \<le> r'" using assms
<     by (auto simp: range_reducer_def zero_prod_def)
---
>   case True then have "real_of_int 0 * (2 * pi) \<in>\<^sub>r ivl" using assms
>     by (auto simp: range_reducer_def zero_in_float_intervalI)
2102,2105c2108,2109
<   let l = Inf_aform_err p X;
<   let u = Sup_aform_err p X;
<   (r, r') \<leftarrow> range_reducer p l;
<   Some (add_aform' p X (ivl_err (real_of_float r) (real_of_float r')))
---
>   r \<leftarrow> range_reducer p (lower (ivl_of_aform_err p X));
>   Some (add_aform' p X (ivl_err (real_interval r)))
2114c2118
<   from assms obtain r r'
---
>   from assms obtain r
2116,2117c2120,2121
<      and r: "range_reducer p (Inf_aform_err p X) = Some (r, r')"
<      and Y:  "Y = add_aform' p X (ivl_err (real_of_float r) (real_of_float r'))"
---
>      and r: "range_reducer p (lower (ivl_of_aform_err p X)) = Some r"
>      and Y:  "Y = add_aform' p X (ivl_err (real_interval r))"
2120c2124
<   obtain n::int where "r \<le> n * (2 * pi)" "n * (2 * pi) \<le> r'"
---
>   obtain n::int where "n * (2 * pi) \<in>\<^sub>r r"
2122,2123c2126,2127
<   then have "n * (2 * pi) \<in> aform_err e (ivl_err (real_of_float r) (real_of_float r'))"
<     by (auto simp: aform_val_def ac_simps divide_simps abs_real_def intro!: aform_errI)
---
>   then have "n * (2 * pi) \<in> aform_err e (ivl_err (real_interval r))"
>     by (auto simp: aform_val_def ac_simps divide_simps abs_real_def set_of_eq intro!: aform_errI)
2133c2137,2138
<   (a, _) \<leftarrow> approx p (Min (DF L) (DF U)) [];
---
>   aivl \<leftarrow> approx p (Min (DF L) (DF U)) [];
>   let a = lower aivl;
2138,2139c2143,2144
<   (_, d) \<leftarrow> approx p ((Half (F U - F L - A * (U - L))) + Be) [];
<   Some (affine_unop p a b (real_of_float d) X)
---
>   divl \<leftarrow> approx p ((Half (F U - F L - A * (U - L))) + Be) [];
>   Some (affine_unop p a b (real_of_float (upper divl)) X)
2153,2157c2158,2161
<   from assms obtain a bl bu du
<     where bl: "bl \<le> (f l + f u - a * (l + u)) / 2"
<       and bu: "(f l + f u - a * (l + u))/2 \<le> bu"
<       and Y: "Y = affine_unop p (a) ((bl + bu) / 2) (du) X"
<       and du: "(f u - f l - a * (u - l)) / 2 + (bu - bl) / 2 \<le> du"
---
>   from assms obtain a b be bivl divl
>     where bivl: "(f l + f u - a * (l + u))/2 \<in>\<^sub>r bivl"
>       and Y: "Y = affine_unop p a b (upper divl) X"
>       and du: "(f u - f l - a * (u - l)) / 2 + be \<in>\<^sub>r divl"
2159c2163,2166
<     by (auto simp: min_range_mono_def Let_def bind_eq_Some_conv mid_err_def
---
>       and b_def: "b = (lower bivl + upper bivl) / 2"
>       and be_def: "be = (upper bivl - lower bivl) / 2"
>     by (auto simp: min_range_mono_def Let_def bind_eq_Some_conv mid_err_def set_of_eq
>         simp del: eq_divide_eq_numeral1
2161,2162d2167
<   then obtain b be where b_def: "b = (bl + bu) / 2" and be_def: "be = (bu - bl) / 2"
<     by blast
2167c2172
<     using bl bu
---
>     using bivl
2169,2170c2174,2175
<     by (auto simp: abs_real_def divide_simps)
<   have "\<bar>f x - (a * x + b)\<bar> \<le> du"
---
>     by (auto simp: abs_real_def divide_simps set_of_eq)
>   have "\<bar>f x - (a * x + b)\<bar> \<le> upper divl"
2178c2183
<     using du bl bu
---
>     using bivl du
2180c2185
<     by auto
---
>     by (auto simp: set_of_eq)
2182c2187
<   have "f x \<in> aform_err e (affine_unop p (real_of_float a) b du X)"
---
>   have "f x \<in> aform_err e (affine_unop p (real_of_float a) b (upper divl) X)"
2191c2196,2197
<   (_, a) \<leftarrow> approx p (Max (DF L) (DF U)) [];
---
>   aivl \<leftarrow> approx p (Max (DF L) (DF U)) [];
>   let a = upper aivl;
2196,2197c2202,2203
<   (_, d) \<leftarrow> approx p (Add (Half (F L - F U + A * (U - L))) Be) [];
<   Some (affine_unop p a b (real_of_float d) X)
---
>   divl \<leftarrow> approx p (Add (Half (F L - F U + A * (U - L))) Be) [];
>   Some (affine_unop p a b (real_of_float (upper divl)) X)
2211,2217c2217,2226
<   from assms obtain a bl bu du
<     where bl: "bl \<le> (f l + f u - a * (l + u)) / 2"
<       and bu: "(f l + f u - a * (l + u))/2 \<le> bu"
<       and Y: "Y = affine_unop p (a) ((bl + bu) / 2) (du) X"
<       and du: "(f l - f u + a * (u - l)) / 2 + (bu - bl) / 2 \<le> du"
<       and a: "f' l \<le> a" "f' u \<le> a"
<     by (auto simp: min_range_antimono_def Let_def bind_eq_Some_conv mid_err_def
---
>   from assms obtain a b be aivl bivl divl
>     where bivl: "(f l + f u - real_of_float a * (l + u)) / 2 \<in>\<^sub>r bivl"
>     and Y: "Y = affine_unop p a b (real_of_float (upper divl)) X"
>     and du: "(f l - f u + a * (u - l)) / 2 + be \<in>\<^sub>r divl"
>     and a: "f' l \<le> a" "f' u \<le> a"
>     and a_def: "a = upper aivl"
>     and b_def: "b = (lower bivl + upper bivl) / 2"
>     and be_def: "be = (upper bivl - lower bivl) / 2"
>     by (auto simp: min_range_antimono_def Let_def bind_eq_Some_conv mid_err_def set_of_eq
>         simp del: eq_divide_eq_numeral1
2219,2220d2227
<   then obtain b be where b_def: "b = (bl + bu) / 2" and be_def: "be = (bu - bl) / 2"
<     by blast
2225c2232
<     using bl bu
---
>     using bivl
2227,2228c2234,2235
<     by (auto simp: abs_real_def divide_simps)
<   have "\<bar>f x - (a * x + b)\<bar> \<le> du"
---
>     by (auto simp: abs_real_def divide_simps set_of_eq)
>   have "\<bar>f x - (a * x + b)\<bar> \<le> upper divl"
2236c2243
<     using du bl bu
---
>     using du bivl
2238c2245
<     by auto
---
>     by (auto simp: set_of_eq)
2240c2247
<   have "f x \<in> aform_err e (affine_unop p (real_of_float a) b du X)"
---
>   have "f x \<in> aform_err e (affine_unop p (real_of_float a) b (upper divl) X)"
2248,2249c2255,2257
<   let l = Inf_aform_err p X;
<   let u = Sup_aform_err p X;
---
>   let ivl = ivl_of_aform_err p X;
>   let l = lower ivl;
>   let u = upper ivl;
2257,2258c2265
<     let (a, b) = (bnds_cos p l u);
<     Some (ivl_err a b)
---
>     Some (ivl_err (real_interval (cos_float_interval p ivl)))
2275c2282
<   from assms obtain X l u where
---
>   from assms obtain X ivl l u where
2277,2278c2284,2286
<     and l: "l = Inf_aform_err p X"
<     and u: "u = Sup_aform_err p X"
---
>     and ivl_def: "ivl = ivl_of_aform_err p X"
>     and l_def: "l = lower ivl"
>     and u_def: "u = upper ivl"
2285,2287c2293,2296
<   with l u have lxn: "l \<le> xn" and uxn: "xn \<le> u"
<     using Inf_Sup_aform_err[OF e, of X p]
<     by auto
---
>   from ivl_of_aform_err[OF e xn, of p, folded ivl_def]
>   have "xn \<in>\<^sub>r ivl" .
>   then have lxn: "l \<le> xn" and uxn: "xn \<le> u"
>     by (auto simp: l_def u_def set_of_eq)
2298,2299c2307,2308
<       unfolding cos_aform_err_def X l u
<       by (auto simp: X l[symmetric] u[symmetric] split: prod.splits)
---
>       unfolding cos_aform_err_def X l_def u_def
>       by (auto simp: X Let_def simp flip: l_def u_def ivl_def  split: prod.splits)
2337,2338c2346,2347
<       unfolding cos_aform_err_def X l u
<       by (auto simp: X l[symmetric] u[symmetric] split: prod.splits)
---
>       unfolding cos_aform_err_def X
>       by (auto simp: X Let_def simp flip: l_def u_def ivl_def split: prod.splits)
2375,2377c2384,2386
<     then obtain l' u' where
<       "bnds_cos p l u = (l', u')"
<       "Y = ivl_err (real_of_float l') (real_of_float u')"
---
>     then obtain ivl' where
>       "cos_float_interval p ivl = ivl'"
>       "Y = ivl_err (real_interval ivl')"
2379,2381c2388,2390
<       unfolding cos_aform_err_def X l u
<       by (auto simp: X l[symmetric] u[symmetric] split: prod.splits)
<     with bnds_cos[of l' u' p, rule_format, of l u xn] lxn uxn
---
>       unfolding cos_aform_err_def X l_def u_def
>       by (auto simp: X simp flip: l_def u_def ivl_def split: prod.splits)
>     with cos_float_intervalI[OF \<open>xn \<in>\<^sub>r ivl\<close>, of p]
2388,2389c2397,2399
<   let l = Inf_aform_err p X;
<   let u = Sup_aform_err p X;
---
>   let ivl = ivl_of_aform_err p X;
>   let l = lower ivl;
>   let u = upper ivl;
2391c2401
<   else Some (ivl_err (lb_sqrt p l) (ub_sqrt p u))
---
>   else Some (ivl_err (real_interval (sqrt_float_interval p ivl)))
2400,2405c2410,2418
<   obtain l u where l: "l = Inf_aform_err p X"
<     and u: "u = Sup_aform_err p X"
<     by auto
<   from x l u have lx: "l \<le> x" and ux: "x \<le> u"
<     using Inf_Sup_aform_err[OF e, of X p]
<     by auto
---
>   obtain l u ivl
>     where ivl_def: "ivl = ivl_of_aform_err p X"
>     and l_def: "l = lower ivl"
>     and u_def: "u = upper ivl"
>     by auto
>   from ivl_of_aform_err[OF e x, of p, folded ivl_def]
>   have ivl: "x \<in>\<^sub>r ivl" .
>   then have lx: "l \<le> x" and ux: "x \<le> u"
>     by (auto simp flip: ivl_def simp: l_def u_def set_of_eq)
2414,2415c2427,2428
<       unfolding sqrt_aform_err_def l u
<       by (auto simp: l[symmetric] u[symmetric] split: prod.splits if_splits)
---
>       unfolding sqrt_aform_err_def
>       by (auto simp: Let_def simp flip: l_def u_def ivl_def split: prod.splits)
2427c2440
<     then have "Y = ivl_err (lb_sqrt p l) (ub_sqrt p u)"
---
>     then have "Y = ivl_err (real_interval (sqrt_float_interval p ivl))"
2429,2431c2442,2444
<       unfolding sqrt_aform_err_def l u
<       by (auto simp: l[symmetric] u[symmetric] split: prod.splits)
<     with bnds_sqrt[rule_format, OF conjI[OF refl], of x l u p] lx ux
---
>       unfolding sqrt_aform_err_def
>       by (auto simp: Let_def simp flip: ivl_def l_def u_def split: prod.splits)
>     with sqrt_float_intervalI[OF ivl]
2433c2446
<       by (auto simp: )
---
>       by (auto simp: set_of_eq)
2438,2440c2451,2453
<   let l = Inf_aform_err p X;
<   let u = Sup_aform_err p X;
<   if 0 < l then min_range_mono p Ln inverse l u X
---
>   let ivl = ivl_of_aform_err p X;
>   let l = lower ivl;
>   if 0 < l then min_range_mono p Ln inverse l (upper ivl) X
2450,2455c2463,2471
<   obtain l u where l: "l = Inf_aform_err p X"
<     and u: "u = Sup_aform_err p X"
<     by auto
<   from x l u have lx: "l \<le> x" and ux: "x \<le> u"
<     using Inf_Sup_aform_err[OF e, of X p]
<     by auto
---
>   obtain ivl l u
>     where l_def: "l = lower ivl"
>       and u_def: "u = upper ivl"
>       and ivl_def: "ivl = ivl_of_aform_err p X"
>     by auto
>   from ivl_of_aform_err[OF e x, of p, folded ivl_def]
>   have "x \<in>\<^sub>r ivl" .
>   then have lx: "l \<le> x" and ux: "x \<le> u"
>     by (auto simp: set_of_eq l_def u_def)
2464,2465c2480,2481
<       unfolding ln_aform_err_def l u
<       by (auto simp: l[symmetric] u[symmetric] split: prod.splits if_splits)
---
>       unfolding ln_aform_err_def
>       by (auto simp: Let_def simp flip: ivl_def l_def u_def split: prod.splits if_splits)
2478c2494
<       by (auto simp: ln_aform_err_def Let_def l[symmetric])
---
>       by (auto simp: ln_aform_err_def Let_def l_def ivl_def)
2483,2485c2499,2500
<   let l = Inf_aform_err p X;
<   let u = Sup_aform_err p X;
<   min_range_mono p Exp Exp l u X
---
>   let ivl = ivl_of_aform_err p X;
>   min_range_mono p Exp Exp (lower ivl) (upper ivl) X
2494,2499c2509,2517
<   obtain l u where l: "l = Inf_aform_err p X"
<     and u: "u = Sup_aform_err p X"
<     by auto
<   from x l u have lx: "l \<le> x" and ux: "x \<le> u"
<     using Inf_Sup_aform_err[OF e, of X p]
<     by auto
---
>   obtain l u ivl
>     where l_def: "l = lower ivl"
>       and u_def: "u = upper ivl"
>       and ivl_def: "ivl = ivl_of_aform_err p X"
>     by auto
>   from ivl_of_aform_err[OF e x, of p, folded ivl_def]
>   have "x \<in>\<^sub>r ivl" .
>   then have lx: "l \<le> x" and ux: "x \<le> u"
>     by (auto simp: ivl_def l_def u_def set_of_eq)
2502,2503c2520,2521
<     unfolding exp_aform_err_def l u
<     by (auto simp: l[symmetric] u[symmetric] split: prod.splits if_splits)
---
>     unfolding exp_aform_err_def
>     by (auto simp: Let_def simp flip: ivl_def u_def l_def split: prod.splits if_splits)
2579c2597
<       (_, ERR) = the (approx p
---
>       err = the (approx p
2582c2600,2601
<           [2..<Suc n])) [])
---
>           [2..<Suc n])) []);
>       ERR = upper err
2590,2591c2609
<   shows "interpret_floatarith f [] \<in>
<     {real_of_float (fst (the (approx p f []))) .. real_of_float (snd (the (approx p f [])))}"
---
>   shows "interpret_floatarith f [] \<in>\<^sub>r (the (approx p f []))"
2594c2612
<   obtain l u where "Some (l, u) = approx p f []"
---
>   obtain ivl where "approx p f [] = Some ivl"
2596c2614
<   from this[symmetric] approx[OF bounded_by_Nil this]
---
>   from this approx[OF bounded_by_Nil this]
2650c2668
<   
---
> 
2655c2673
<   
---
> 
2669,2670c2687,2688
<   
<     let ?ERR = "(Num (of_nat n) * Num (float_of xe) * Abs (Num (float_of x0)) ^\<^sub>e (n - 1) + 
---
> 
>     let ?ERR = "(Num (of_nat n) * Num (float_of xe) * Abs (Num (float_of x0)) ^\<^sub>e (n - 1) +
2674c2692,2693
<     define ERR where "ERR = snd (the (approx p ?ERR []))"
---
>     define err where "err = the (approx p ?ERR [])"
>     define ERR where "ERR = upper err"
2693c2712,2713
<         by (auto simp: ERR_def sum_list_distinct_conv_sum_set rewr t x0_def algebra_simps)
---
>         by (auto simp: set_of_eq err_def ERR_def sum_list_distinct_conv_sum_set rewr t x0_def
>             algebra_simps)
2696c2716
<   
---
> 
2701,2703c2721,2723
<     have C: "x0 ^ n \<in> {fst C .. snd C}"
<       by (auto simp: C_def x0_def)
<     
---
>     have C: "x0 ^ n \<in> {lower C .. upper C}"
>       by (auto simp: C_def x0_def set_of_eq)
> 
2712c2732
<   
---
> 
2717,2719c2737,2739
<     have NX: "n * x0 ^ (n - 1) \<in> {fst NX .. snd NX}"
<       by (auto simp: NX_def x0_def)
<     
---
>     have NX: "n * x0 ^ (n - 1) \<in> {lower NX .. upper NX}"
>       by (auto simp: NX_def x0_def set_of_eq)
> 
2732c2752
<   
---
> 
2739c2759
<   
---
> 
2758c2778
<           ce_def Y_err_def Ye_def xe_def nxe_def t_def Let_def split_beta')
---
>           ce_def Y_err_def Ye_def xe_def nxe_def t_def Let_def split_beta' set_of_eq err_def)
2771c2791
<     else approx_bin p (bnds_powr p) X A)"
---
>     else approx_bin p (powr_float_interval p) X A)"
2773,2775c2793,2795
< lemma interval_extension_powr: "interval_extension2 (bnds_powr p) (powr)"
<   using bnds_powr[of _ _ p]
<   by (force simp: interval_extension2_def)
---
> lemma interval_extension_powr: "interval_extension2 (powr_float_interval p) (powr)"
>   using powr_float_interval_eqI[of p]
>   by (auto simp: interval_extension2_def)
2802c2822
<   then have "approx_bin p (bnds_powr p) (fst X, snd X) (fst A, snd A) = Some Y"
---
>   then have "approx_bin p (powr_float_interval p) (fst X, snd X) (fst A, snd A) = Some Y"
2837,2838c2857,2859
<       let i = Inf_aform_err p r;
<       let s = Sup_aform_err p r;
---
>       let ivl = ivl_of_aform_err p r;
>       let i = lower ivl;
>       let s = upper ivl;
2842c2863
<         Some (ivl_err 0 (max (- i) \<bar>s\<bar>))
---
>         Some (ivl_err (real_interval (abs_interval ivl)))
2858c2879
<     approx_un p (\<lambda>l u. Some (floor_fl l, floor_fl u)) (approx_floatarith p a vs)"
---
>     approx_un p (\<lambda>ivl. Some (floor_float_interval ivl)) (approx_floatarith p a vs)"
2864c2885
< | "approx_floatarith p Pi vs = Some (ivl_err (lb_pi p) (ub_pi p))"
---
> | "approx_floatarith p Pi vs = Some (ivl_err (real_interval (pi_float_interval p)))"
2901,2927d2921
< lemma interval_extension_cos: "interval_extension1 (\<lambda>l u. Some (bnds_cos p l u)) cos"
<   using bnds_cos
<   by (auto simp: interval_extension1_def) metis+
< 
< lemma interval_extension_power: "interval_extension1 (\<lambda>l u. Some (float_power_bnds p n l u)) (\<lambda>x. x ^ n)"
<   using bnds_power
<   by (auto simp: interval_extension1_def bind_eq_Some_conv; metis)
< 
< lemma interval_extension_ln: "interval_extension1 (\<lambda>l u. do {l' \<leftarrow> lb_ln p l; u' \<leftarrow> ub_ln p u; Some (l', u')}) ln"
<   using bnds_ln[of _ _ p]
<   by (auto simp del: lb_ln.simps ub_ln.simps simp: interval_extension1_def bind_eq_Some_conv; metis)
< 
< lemma interval_extension_arctan: "interval_extension1 (\<lambda>l u. Some (lb_arctan p l, ub_arctan p u)) arctan"
<   using bnds_arctan
<   by (auto simp del: lb_arctan.simps ub_arctan.simps simp: interval_extension1_def; metis)
< 
< lemma interval_extension_exp: "interval_extension1 (\<lambda>l u. Some (lb_exp p l, ub_exp p u)) exp"
<   using bnds_exp
<   by (auto simp: interval_extension1_def; metis)
< 
< lemma interval_extension_sqrt: "interval_extension1 (\<lambda>l u. Some (lb_sqrt p l, ub_sqrt p u)) sqrt"
<   using bnds_sqrt
<   by (auto simp: interval_extension1_def; metis)
< 
< lemma interval_extension_floor: "interval_extension1 (\<lambda>l u. Some (floor_fl l, floor_fl u)) floor"
<   by (auto simp: interval_extension1_def floor_fl.rep_eq floor_mono)
< 
2937c2931
<   using assms 
---
>   using assms
2940c2934
< lemma degree_aform_ivl_err[simp]: "degree_aform (fst (ivl_err a b)) = 0"
---
> lemma degree_aform_ivl_err[simp]: "degree_aform (fst (ivl_err a)) = 0"
3321c3315
<   
---
> 
3328,3339d3321
< lemma ivl_err_float:
<   assumes "ivl_err x y = ((a, b), ba)" "x \<in> float" "y \<in> float" 
<   shows "a \<in> float" "ba \<in> float"
< proof -
<   from assms(1) have "a = (x + y) / 2" "ba = (y - x) / 2"
<     by (auto simp: ivl_err_def)
<   moreover have "(x + y) / 2 \<in> float" "(y - x) / 2 \<in> float"
<     using assms
<     by (auto intro!: )
<   ultimately show "a \<in> float" "ba \<in> float" by blast+
< qed
< 
3346a3329,3331
> lemma interval_extension_floor: "interval_extension1 (\<lambda>ivl. Some (floor_float_interval ivl)) floor"
>   by (auto simp: interval_extension1_def floor_float_intervalI)
> 
3385,3386c3370,3374
<   let ?i = "Inf_aform_err p a"
<   let ?s = "Sup_aform_err p a"
---
>   then have mem': "-interpret_floatarith fa vs \<in> aform_err e (apfst uminus_aform a)"
>     by (auto simp: aform_err_def)
> 
>   let ?i = "lower (ivl_of_aform_err p a)"
>   let ?s = "upper (ivl_of_aform_err p a)"
3393,3394c3381,3382
<       using Abs.prems mem Inf_Sup_aform_err[OF e, of a p]
<       by (auto simp: a)
---
>       using Abs.prems mem ivl_of_aform_err[OF e mem, of p]
>       by (auto simp: a set_of_eq)
3398,3400c3386,3388
<       using Abs.prems mem Inf_Sup_aform_err[OF e, of "apfst uminus_aform a" p]
<           Inf_Sup_aform_err[OF e, of "a" p]
<       by (cases a) (auto simp: a abs_real_def intro!: aform_err_uminus_aform[OF e])
---
>       using Abs.prems mem ivl_of_aform_err[OF e mem, of p]
>           ivl_of_aform_err[OF e mem', of p]
>       by (cases a) (auto simp: a abs_real_def set_of_eq intro!: aform_err_uminus_aform[OF e])
3404,3405c3392,3393
<       using Abs.prems mem Inf_Sup_aform_err[OF e, of a p]
<       by (auto simp: a abs_real_def max_def Let_def)
---
>       using Abs.prems mem ivl_of_aform_err[OF e mem, of p]
>       by (auto simp: a abs_real_def max_def Let_def set_of_eq)
3417,3420c3405,3408
<   let ?ia = "Inf_aform_err p a"
<   let ?sa = "Sup_aform_err p a"
<   let ?ib = "Inf_aform_err p b"
<   let ?sb = "Sup_aform_err p b"
---
>   let ?ia = "lower (ivl_of_aform_err p a)"
>   let ?sa = "upper (ivl_of_aform_err p a)"
>   let ?ib = "lower (ivl_of_aform_err p b)"
>   let ?sb = "upper (ivl_of_aform_err p b)"
3424,3443c3412,3413
<   proof cases
<     case hyps: 1
<     then show ?thesis
<       using Max.prems mem Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<       by (force simp: a b max_def max_aform_err_def)
<   next
<     case hyps: 2
<     then show ?thesis
<       using Max.prems mem Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<           Inf_Sup_aform_err[OF e, of "a" p]
<       by (force simp: a b max_def max_aform_err_def)
<   next
<     case hyps: 3
<     then show ?thesis
<       using Max.prems mem
<       apply (simp add: a b max_aform_err_def)
<       apply auto
<       using Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<       by (auto simp: max_def)
<   qed
---
>     using Max.prems mem ivl_of_aform_err[OF e mem(1), of p] ivl_of_aform_err[OF e mem(2), of p]
>     by cases (auto simp: a b max_def max_aform_err_def set_of_eq)
3454,3457c3424,3427
<   let ?ia = "Inf_aform_err p a"
<   let ?sa = "Sup_aform_err p a"
<   let ?ib = "Inf_aform_err p b"
<   let ?sb = "Sup_aform_err p b"
---
>   let ?ia = "lower (ivl_of_aform_err p a)"
>   let ?sa = "upper (ivl_of_aform_err p a)"
>   let ?ib = "lower (ivl_of_aform_err p b)"
>   let ?sb = "upper (ivl_of_aform_err p b)"
3461,3480c3431,3432
<   proof cases
<     case hyps: 1
<     then show ?thesis
<       using Min.prems mem Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<       by (force simp: a b min_def min_aform_err_def)
<   next
<     case hyps: 2
<     then show ?thesis
<       using Min.prems mem Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<         Inf_Sup_aform_err[OF e, of "a" p]
<       by (force simp: a b min_def min_aform_err_def)
<   next
<     case hyps: 3
<     then show ?thesis
<       using Min.prems mem
<       apply (simp add: a b min_aform_err_def)
<       apply auto
<       using Inf_Sup_aform_err[OF e, of a p] Inf_Sup_aform_err[OF e, of b p]
<       by (auto simp: min_def)
<   qed
---
>     using Min.prems mem ivl_of_aform_err[OF e mem(1), of p] ivl_of_aform_err[OF e mem(2), of p]
>     by cases (auto simp: a b min_def min_aform_err_def set_of_eq)
3483c3435
<   then show ?case using pi_boundaries
---
>   then show ?case using pi_float_interval
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Affine_Arithmetic_Auxiliarities.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Affine_Arithmetic_Auxiliarities.thy
2c2
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Affine_Form.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Affine_Form.thy
4c4
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
1945c1945
<       e_def Let_def pdevs_val_sum field_simps
---
>       e_def Let_def pdevs_val_sum
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Counterclockwise_2D_Arbitrary.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Counterclockwise_2D_Arbitrary.thy
36c36
<   by (auto simp: psi_def lex_def det3_def' not_less sign_simps)
---
>   by (auto simp: psi_def lex_def det3_def' not_less algebra_split_simps)
78c78
<   by (auto simp: lex_def prod_eq_iff less_eq_prod_def sign_simps)
---
>   by (auto simp: lex_def prod_eq_iff less_eq_prod_def algebra_split_simps)
228c228
<   by (auto simp: ccw'_def det3_def' lex_def sign_simps)
---
>   by (auto simp: ccw'_def det3_def' lex_def algebra_split_simps)
500c500
<       by (auto simp: lex_def not_less sign_simps y ccw'_def)
---
>       by (auto simp: lex_def not_less algebra_simps algebra_split_simps y ccw'_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Counterclockwise.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Counterclockwise.thy
3c3
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Executable_Euclidean_Space.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Executable_Euclidean_Space.thy
4c4
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
875c875
<       by (auto simp add: divide_simps blinfun.bilinear_simps sign_simps  split: if_split_asm)
---
>       by (auto simp add: divide_simps blinfun.bilinear_simps algebra_simps split: if_split_asm)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Intersection.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Intersection.thy
2302,2306c2302,2313
<     by (auto simp: closed_segment_def i_def field_simps)
<   hence "u = v * (fst a - fst b) / (fst a - fst b)" using ne1 H(2,3)
<     by (auto simp: closed_segment_def field_simps i_def)
<   hence "u = v" by (simp add: ne1)
<   thus False using H uv by simp
---
>     by (auto simp add: closed_segment_def i_def field_simps)
>   then have "x + u *\<^sub>R a = a + u *\<^sub>R b" "y + v *\<^sub>R a = a + v *\<^sub>R b"
>     by simp_all
>   then have "fst (x + u *\<^sub>R a) = fst (a + u *\<^sub>R b)" "fst (y + v *\<^sub>R a) = fst (a + v *\<^sub>R b)"
>     by simp_all
>   then have "u = v * (fst a - fst b) / (fst a - fst b)"
>     using ne1 H(2,3) \<open>0 \<le> u\<close> \<open>u \<le> 1\<close> \<open>0 \<le> v\<close> \<open>v \<le> 1\<close>
>     by (simp add: closed_segment_def i_def field_simps)
>   then have "u = v"
>     by (simp add: ne1)
>   then show False using H uv
>     by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Affine_Arithmetic/Print.thy ../../AFPs/afp-2020/thys/Affine_Arithmetic/Print.thy
78c78
<     let e_fl = floor_fl (fst y_log);
---
>     let e_fl = floor_fl (lower y_log);
80c80,82
<     (ml, mu) \<leftarrow> approx p (Mult (Num (of_int x)) (Powr (Num 10) (Add(Var 0) (Minus (Num e_fl))))) [Some y_log];
---
>     m \<leftarrow> approx p (Mult (Num (of_int x)) (Powr (Num 10) (Add(Var 0) (Minus (Num e_fl))))) [Some y_log];
>     let ml = lower m;
>     let mu = upper m;
==========
Akra_Bazzi
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Akra_Bazzi/Master_Theorem.thy ../../AFPs/afp-2020/thys/Akra_Bazzi/Master_Theorem.thy
10c10
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
==========
Algebraic_Numbers
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Algebraic_Numbers/Algebraic_Numbers_Prelim.thy ../../AFPs/afp-2020/thys/Algebraic_Numbers/Algebraic_Numbers_Prelim.thy
538c538
<  degree (gcd (of_int_poly q :: 'a :: {field_char_0,euclidean_ring_gcd} poly) (of_int_poly r)) \<noteq> 0"
---
>  degree (gcd (of_int_poly q :: 'a :: {field_char_0, field_gcd} poly) (of_int_poly r)) \<noteq> 0"
601c601
<   defines "rp \<equiv> ipoly :: int poly \<Rightarrow> 'a :: {euclidean_ring_gcd,field_char_0} \<Rightarrow> 'a"
---
>   defines "rp \<equiv> ipoly :: int poly \<Rightarrow> 'a :: {field_gcd,field_char_0} \<Rightarrow> 'a"
699c699
<   fixes x :: "'a :: {field_char_0,euclidean_ring_gcd}"
---
>   fixes x :: "'a :: {field_char_0,field_gcd}"
806c806
< lemma gcd_of_int_poly: "gcd (of_int_poly f) (of_int_poly g :: 'a :: {field_char_0,euclidean_ring_gcd} poly) =
---
> lemma gcd_of_int_poly: "gcd (of_int_poly f) (of_int_poly g :: 'a :: {field_char_0,field_gcd} poly) =
820c820
<   fixes x :: "'a :: {field_char_0,euclidean_ring_gcd}"
---
>   fixes x :: "'a :: {field_char_0,field_gcd}"
855c855
<   fixes x :: "'a :: {field_char_0,euclidean_ring_gcd}"
---
>   fixes x :: "'a :: {field_char_0,field_gcd}"
1239c1239
<   fixes x :: "'a :: {field_char_0,euclidean_ring_gcd}"
---
>   fixes x :: "'a :: {field_char_0,field_gcd}"
1310c1310
<   fixes x :: "'a :: {field_char_0,euclidean_ring_gcd}"
---
>   fixes x :: "'a :: {field_char_0,field_gcd}"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Algebraic_Numbers/Complex_Algebraic_Numbers.thy ../../AFPs/afp-2020/thys/Algebraic_Numbers/Complex_Algebraic_Numbers.thy
870c870
<     unfolding pq by (simp add: c of_rat_of_int_poly map_poly_map_poly o_def hom_distribs)
---
>     unfolding pq by (simp add: c of_rat_of_int_poly hom_distribs)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Algebraic_Numbers/Real_Algebraic_Numbers.thy ../../AFPs/afp-2020/thys/Algebraic_Numbers/Real_Algebraic_Numbers.thy
1366c1366,1367
<     from True have id: "floor (?r l') = floor (?r r')" unfolding real_of_rat_floor by simp
---
>     from True have id: "floor (?r l') = floor (?r r')"
>       by simp
1371,1372c1372,1374
<     ultimately have "floor ?x = floor (?r r')" unfolding id by simp
<     thus ?thesis unfolding id1 real_of_rat_floor .
---
>     ultimately have "floor ?x = floor (?r r')"
>       unfolding id by (simp add: id)
>     then show ?thesis by (simp add: id1)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Algebraic_Numbers/Sturm_Rat.thy ../../AFPs/afp-2020/thys/Algebraic_Numbers/Sturm_Rat.thy
140c140
<   shows "square_free (of_int_poly p :: 'a :: {euclidean_ring_gcd, field_char_0} poly)" 
---
>   shows "square_free (of_int_poly p :: 'a :: {field_gcd, field_char_0} poly)" 
==========
Amortized_Complexity
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Amortized_Complexity/Splay_Tree_Analysis_Base.thy ../../AFPs/afp-2020/thys/Amortized_Complexity/Splay_Tree_Analysis_Base.thy
19d18
< 
21,26c20,24
< "t_splay a Leaf = 1" |
< "t_splay a (Node l b r) =
<   (if a=b
<    then 1
<    else if a < b
<         then case l of
---
> "t_splay x Leaf = 1" |
> "t_splay x (Node AB b CD) =
>   (case cmp x b of
>    EQ \<Rightarrow> 1 |
>    LT \<Rightarrow> (case AB of
28,32c26,30
<           Node ll c lr \<Rightarrow>
<             (if a=c then 1
<              else if a < c then if ll = Leaf then 1 else t_splay a ll + 1
<                   else if lr = Leaf then 1 else t_splay a lr + 1)
<         else case r of
---
>           Node A a B \<Rightarrow>
>             (case cmp x a of EQ \<Rightarrow> 1 |
>              LT \<Rightarrow> if A = Leaf then 1 else t_splay x A + 1 |
>              GT \<Rightarrow> if B = Leaf then 1 else t_splay x B + 1)) |
>    GT \<Rightarrow> (case CD of
34,37c32,35
<           Node rl c rr \<Rightarrow>
<             (if a=c then 1
<              else if a < c then if rl = Leaf then 1 else t_splay a rl + 1
<                   else if rr = Leaf then 1 else t_splay a rr + 1))"
---
>           Node C c D \<Rightarrow>
>             (case cmp x c of EQ \<Rightarrow> 1 |
>              LT \<Rightarrow> if C = Leaf then 1 else t_splay x C + 1 |
>              GT \<Rightarrow> if D = Leaf then 1 else t_splay x D + 1)))"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Amortized_Complexity/Splay_Tree_Analysis.thy ../../AFPs/afp-2020/thys/Amortized_Complexity/Splay_Tree_Analysis.thy
52,53c52,53
< lemma a_splay_ub: "\<lbrakk> bst t; Node lx x rx : subtrees t \<rbrakk>
<   \<Longrightarrow> a_splay x t \<le> 3 * (\<phi> t - \<phi>(Node lx x rx)) + 1"
---
> lemma a_splay_ub: "\<lbrakk> bst t; Node l x r : subtrees t \<rbrakk>
>   \<Longrightarrow> a_splay x t \<le> 3 * (\<phi> t - \<phi>(Node l x r)) + 1"
71,73c71,73
<   case (3 b a lb rb ra)
<   let ?A = "Node (Node lb b rb) a ra"
<   have "b \<notin> set_tree ra" using "3.prems"(1) by auto
---
>   case (3 x b A B C)
>   let ?A = "Node (Node A x B) b C"
>   have "x \<notin> set_tree C" using "3.prems"(1) by auto
75,76c75,76
<     log_le_cancel_iff[of 2 "size1(Node rb a ra)" "size1 ?A"]
<     log_le_cancel_iff[of 2 "size1(Node lb b rb)" "size1 ?A"]
---
>     log_le_cancel_iff[of 2 "size1(Node B b C)" "size1 ?A"]
>     log_le_cancel_iff[of 2 "size1(Node A x B)" "size1 ?A"]
79,81c79,81
<   case (9 a b la lb rb)
<   let ?A = "\<langle>la, a, \<langle>lb, b, rb\<rangle>\<rangle>"
<   have "b \<notin> set_tree la" using "9.prems"(1) by auto
---
>   case (9 a x A B C)
>   let ?A = "\<langle>A, a, \<langle>B, x, C\<rangle>\<rangle>"
>   have "x \<notin> set_tree A" using "9.prems"(1) by auto
83,84c83,84
<     log_le_cancel_iff[of 2 "size1(Node la a lb)" "size1 ?A"]
<     log_le_cancel_iff[of 2 "size1(Node lb b rb)" "size1 ?A"]
---
>     log_le_cancel_iff[of 2 "size1(Node A a B)" "size1 ?A"]
>     log_le_cancel_iff[of 2 "size1(Node B x C)" "size1 ?A"]
87,95c87,95
<   case (6 x b a lb rb ra)
<   hence 0: "x \<notin> set_tree rb \<and> x \<notin> set_tree ra" using "6.prems"(1) by auto
<   hence 1: "x \<in> set_tree lb" using "6.prems" \<open>x<b\<close> by (auto)
<   obtain lu u ru where sp: "splay x lb = Node lu u ru"
<     using splay_not_Leaf[OF \<open>lb \<noteq> Leaf\<close>] by blast
<   let ?X = "Node lx x rx" let ?B = "Node lb b rb"  let ?A = "Node ?B a ra"
<   let ?R = lb  let ?R' = "Node lu u ru"
<   let ?A' = "Node rb a ra"  let ?B' = "Node ru b ?A'"
<   have "a_splay x ?A = a_splay x ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' + 1"
---
>   case (6 x b c AB C D)
>   hence 0: "x \<notin> set_tree C \<and> x \<notin> set_tree D" using "6.prems"(1) by auto
>   hence 1: "x \<in> set_tree AB" using "6.prems" \<open>x<b\<close> by (auto)
>   obtain A a B where sp: "splay x AB = Node A a B"
>     using splay_not_Leaf[OF \<open>AB \<noteq> Leaf\<close>] by blast
>   let ?X = "Node l x r" let ?ABC = "Node AB b C"  let ?ABCD = "Node ?ABC c D"
>   let ?AB = "Node A a B"
>   let ?CD = "Node C c D"  let ?BCD = "Node B b ?CD"
>   have "a_splay x ?ABCD = a_splay x AB + \<phi> ?BCD + \<phi> ?CD - \<phi> ?ABC - \<phi> ?AB + 1"
98c98
<   also have "\<dots> \<le> 3 * \<phi> ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> \<le> 3 * \<phi> AB + \<phi> ?BCD + \<phi> ?CD - \<phi> ?ABC - \<phi> ?AB - 3 * \<phi> ?X + 2"
100c100
<   also have "\<dots> = 2 * \<phi> ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> = 2 * \<phi> AB + \<phi> ?BCD + \<phi> ?CD - \<phi> ?ABC - 3 * \<phi> ?X + 2"
102,104c102,104
<   also have "\<dots> \<le> \<phi> ?R + \<phi> ?B' + \<phi> ?A' - 3 * \<phi> ?X + 2" by(simp)
<   also have "\<dots> \<le> \<phi> ?B' + 2 * \<phi> ?A - 3 * \<phi> ?X + 1"
<     using sp ld_ld_1_less[of "size1 ?R" "size1 ?A'"]
---
>   also have "\<dots> \<le> \<phi> AB + \<phi> ?BCD + \<phi> ?CD - 3 * \<phi> ?X + 2" by(simp)
>   also have "\<dots> \<le> \<phi> ?BCD + 2 * \<phi> ?ABCD - 3 * \<phi> ?X + 1"
>     using sp ld_ld_1_less[of "size1 AB" "size1 ?CD"]
106c106
<   also have "\<dots> \<le> 3 * \<phi> ?A - 3 * \<phi> ?X + 1"
---
>   also have "\<dots> \<le> 3 * \<phi> ?ABCD - 3 * \<phi> ?X + 1"
110,119c110,119
<   case (8 b x a rb lb ra)
<   hence 0: "x \<notin> set_tree lb \<and> x \<notin> set_tree ra"
<     using "8.prems"(1) \<open>x < a\<close> by(auto)
<   hence 1: "x \<in> set_tree rb" using "8.prems" \<open>b<x\<close> \<open>x<a\<close> by (auto)
<   obtain lu u ru where sp: "splay x rb = Node lu u ru"
<      using splay_not_Leaf[OF \<open>rb \<noteq> Leaf\<close>] by blast
<   let ?X = "Node lx x rx" let ?B = "Node lb b rb"  let ?A = "Node ?B a ra"
<   let ?R = rb  let ?R' = "Node lu u ru"
<   let ?B' = "Node lb b lu"  let ?A' = "Node ru a ra"
<   have "a_splay x ?A = a_splay x ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' + 1"
---
>   case (8 a x c BC A D)
>   hence 0: "x \<notin> set_tree A \<and> x \<notin> set_tree D"
>     using "8.prems"(1) \<open>x < c\<close> by(auto)
>   hence 1: "x \<in> set_tree BC" using "8.prems" \<open>a<x\<close> \<open>x<c\<close> by (auto)
>   obtain B b C where sp: "splay x BC = Node B b C"
>      using splay_not_Leaf[OF \<open>BC \<noteq> Leaf\<close>] by blast
>   let ?X = "Node l x r" let ?ABC = "Node A a BC"  let ?ABCD = "Node ?ABC c D"
>   let ?BC = "Node B b C"
>   let ?AB = "Node A a B"  let ?CD = "Node C c D"
>   have "a_splay x ?ABCD = a_splay x BC + \<phi> ?AB + \<phi> ?CD - \<phi> ?ABC - \<phi> ?BC + 1"
122c122
<   also have "\<dots> \<le> 3 * \<phi> ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> \<le> 3 * \<phi> BC + \<phi> ?AB + \<phi> ?CD - \<phi> ?ABC - \<phi> ?BC - 3 * \<phi> ?X + 2"
124c124
<   also have "\<dots> = 2 * \<phi> rb + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> = 2 * \<phi> BC + \<phi> ?AB + \<phi> ?CD - \<phi> ?ABC - 3 * \<phi> ?X + 2"
126,128c126,128
<   also have "\<dots> \<le> \<phi> rb + \<phi> ?B' + \<phi> ?A' - 3 * \<phi> ?X + 2" by(simp)
<   also have "\<dots> \<le> \<phi> rb + 2 * \<phi> ?A - 3 * \<phi> ?X + 1"
<     using sp ld_ld_1_less[of "size1 ?B'" "size1 ?A'"]
---
>   also have "\<dots> \<le> \<phi> BC + \<phi> ?AB + \<phi> ?CD - 3 * \<phi> ?X + 2" by(simp)
>   also have "\<dots> \<le> \<phi> BC + 2 * \<phi> ?ABCD - 3 * \<phi> ?X + 1"
>     using sp ld_ld_1_less[of "size1 ?AB" "size1 ?CD"]
130c130
<   also have "\<dots> \<le> 3 * \<phi> ?A - 3 * \<phi> ?X + 1" by(simp)
---
>   also have "\<dots> \<le> 3 * \<phi> ?ABCD - 3 * \<phi> ?X + 1" by(simp)
133,134c133,134
<   case (11 a x b lb la rb)
<   hence 0: "x \<notin> set_tree rb \<and> x \<notin> set_tree la"
---
>   case (11 a x c BC A D)
>   hence 0: "x \<notin> set_tree D \<and> x \<notin> set_tree A"
136,142c136,142
<   hence 1: "x \<in> set_tree lb" using "11.prems" \<open>a<x\<close> \<open>x<b\<close> by (auto)
<   obtain lu u ru where sp: "splay x lb = Node lu u ru"
<     using splay_not_Leaf[OF \<open>lb \<noteq> Leaf\<close>] by blast
<   let ?X = "Node lx x rx" let ?B = "Node lb b rb"  let ?A = "Node la a ?B"
<   let ?R = lb  let ?R' = "Node lu u ru"
<   let ?B' = "Node ru b rb"  let ?A' = "Node la a lu"
<   have "a_splay x ?A = a_splay x ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' + 1"
---
>   hence 1: "x \<in> set_tree BC" using "11.prems" \<open>a<x\<close> \<open>x<c\<close> by (auto)
>   obtain B b C where sp: "splay x BC = Node B b C"
>     using splay_not_Leaf[OF \<open>BC \<noteq> Leaf\<close>] by blast
>   let ?X = "Node l x r" let ?BCD = "Node BC c D"  let ?ABCD = "Node A a ?BCD"
>   let ?BC = "Node B b C"
>   let ?CD = "Node C c D"  let ?AB = "Node A a B"
>   have "a_splay x ?ABCD = a_splay x BC + \<phi> ?CD + \<phi> ?AB - \<phi> ?BCD - \<phi> ?BC + 1"
145c145
<   also have "\<dots> \<le> 3 * \<phi> ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - \<phi> ?R' - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> \<le> 3 * \<phi> BC + \<phi> ?CD + \<phi> ?AB - \<phi> ?BCD - \<phi> ?BC - 3 * \<phi> ?X + 2"
147c147
<   also have "\<dots> = 2 * \<phi> ?R + \<phi> ?B' + \<phi> ?A' - \<phi> ?B - 3 * \<phi> ?X + 2"
---
>   also have "\<dots> = 2 * \<phi> BC + \<phi> ?CD + \<phi> ?AB - \<phi> ?BCD - 3 * \<phi> ?X + 2"
149,151c149,151
<   also have "\<dots> \<le> \<phi> ?R + \<phi> ?B' + \<phi> ?A' - 3 * \<phi> ?X + 2" by(simp)
<   also have "\<dots> \<le> \<phi> ?R + 2 * \<phi> ?A - 3 * \<phi> ?X + 1"
<     using sp ld_ld_1_less[of "size1 ?B'" "size1 ?A'"]
---
>   also have "\<dots> \<le> \<phi> BC + \<phi> ?CD + \<phi> ?AB - 3 * \<phi> ?X + 2" by(simp)
>   also have "\<dots> \<le> \<phi> BC + 2 * \<phi> ?ABCD - 3 * \<phi> ?X + 1"
>     using sp ld_ld_1_less[of "size1 ?CD" "size1 ?AB"]
153c153
<   also have "\<dots> \<le> 3 * \<phi> ?A - 3 * \<phi> ?X + 1" by(simp)
---
>   also have "\<dots> \<le> 3 * \<phi> ?ABCD - 3 * \<phi> ?X + 1" by(simp)
156,157c156,157
<   case (14 a x b rb la lb)
<   hence 0: "x \<notin> set_tree lb \<and> x \<notin> set_tree la"
---
>   case (14 a x b CD A B)
>   hence 0: "x \<notin> set_tree B \<and> x \<notin> set_tree A"
159,162c159,162
<   hence 1: "x \<in> set_tree rb" using "14.prems" \<open>b<x\<close> \<open>a<x\<close> by (auto)
<   obtain lu u ru where sp: "splay x rb = Node lu u ru"
<     using splay_not_Leaf[OF \<open>rb \<noteq> Leaf\<close>] by blast
<   from zig_zig[of rb x ru lu lx rx _ b lb a la] 14 sp 0
---
>   hence 1: "x \<in> set_tree CD" using "14.prems" \<open>b<x\<close> \<open>a<x\<close> by (auto)
>   obtain C c D where sp: "splay x CD = Node C c D"
>     using splay_not_Leaf[OF \<open>CD \<noteq> Leaf\<close>] by blast
>   from zig_zig[of CD x D C l r _ b B a A] 14 sp 0
==========
Applicative_Lifting
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Applicative_Lifting/Applicative_DNEList.thy ../../AFPs/afp-2020/thys/Applicative_Lifting/Applicative_DNEList.thy
55c55,56
< lift_bnf 'a dnelist via dnelist_subtype_dlist for map: map by(simp_all add: dlist_eq_iff)
---
> lift_bnf (no_warn_transfer, no_warn_wits) 'a dnelist via dnelist_subtype_dlist for map: map
>   by(auto simp: dlist_eq_iff)
127c128
<       by(simp add: ap_list_def List.bind_def del: remdups_id_iff_distinct) 
---
>       by(simp add: ap_list_def List.bind_def del: remdups_id_iff_distinct)
132c133
<   show "pure_dnelist (\<lambda>x y. x) \<diamondop> x \<diamondop> y = x" 
---
>   show "pure_dnelist (\<lambda>x y. x) \<diamondop> x \<diamondop> y = x"
139c140
< context begin 
---
> context begin
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Applicative_Lifting/applicative.ML ../../AFPs/afp-2020/thys/Applicative_Lifting/applicative.ML
968c968
<           (Variable.export_terms (Variable.auto_fixes t ctxt) ctxt) t) [] of
---
>           (Variable.export_terms (Proof_Context.augment t ctxt) ctxt) t) [] of
==========
Arith_Prog_Rel_Primes
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy ../../AFPs/afp-2020/thys/Arith_Prog_Rel_Primes/Arith_Prog_Rel_Primes.thy
89c89
<             using \<open>1 < n\<close> less_imp_add_positive linordered_field_class.sign_simps(2) by blast
---
>             using add.commute assms less_imp_add_positive by blast
==========
Auto2_HOL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Auto2_HOL/auto2_outer.ML ../../AFPs/afp-2020/thys/Auto2_HOL/auto2_outer.ML
343c343
<       val method = K (Method.CONTEXT_TACTIC (PRIMITIVE (K new_prop)))
---
>       val method = K (Context_Tactic.CONTEXT_TACTIC (PRIMITIVE (K new_prop)))
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Auto2_HOL/HOL/matcher_test.ML ../../AFPs/afp-2020/thys/Auto2_HOL/HOL/matcher_test.ML
48c48
<     Variable.auto_fixes (Syntax.read_term ctxt str) ctxt
---
>     Proof_Context.augment (Syntax.read_term ctxt str) ctxt
51c51
<     Variable.auto_fixes (Proof_Context.read_term_pattern ctxt str) ctxt
---
>     Proof_Context.augment (Proof_Context.read_term_pattern ctxt str) ctxt
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Auto2_HOL/HOL/rewrite_test.ML ../../AFPs/afp-2020/thys/Auto2_HOL/HOL/rewrite_test.ML
146c146
<     Variable.auto_fixes (Syntax.read_term ctxt str) ctxt
---
>     Proof_Context.augment (Syntax.read_term ctxt str) ctxt
==========
Auto2_Imperative_HOL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Auto2_Imperative_HOL/Imperative/list_matcher_test.ML ../../AFPs/afp-2020/thys/Auto2_Imperative_HOL/Imperative/list_matcher_test.ML
38c38
<   val ctxt' = ctxt |> fold Variable.auto_fixes ts
---
>   val ctxt' = ctxt |> fold Proof_Context.augment ts
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Auto2_Imperative_HOL/Imperative/sep_steps_test.ML ../../AFPs/afp-2020/thys/Auto2_Imperative_HOL/Imperative/sep_steps_test.ML
11c11
<   val ctxt' = ctxt |> fold Variable.auto_fixes [
---
>   val ctxt' = ctxt |> fold Proof_Context.augment [
==========
AutoFocus-Stream
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/AutoFocus-Stream/AF_Stream_Exec.thy ../../AFPs/afp-2020/thys/AutoFocus-Stream/AF_Stream_Exec.thy
683c683
<     ( "_\<^bsup>\<leftarrow>' _\<^esup> _" [1000, 10, 100] 100)
---
>     ( "_\<^bsup>\<leftarrow>'' _\<^esup> _" [1000, 10, 100] 100)
==========
Automatic_Refinement
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Automatic_Refinement/Tool/Autoref_Fix_Rel.thy ../../AFPs/afp-2020/thys/Automatic_Refinement/Tool/Autoref_Fix_Rel.thy
335c335
<         val pat2 = singleton (Variable.export_terms (Variable.auto_fixes pat1 lthy) lthy) pat1
---
>         val pat2 = singleton (Variable.export_terms (Proof_Context.augment pat1 lthy) lthy) pat1
==========
Berlekamp_Zassenhaus
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Arithmetic_Record_Based.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Arithmetic_Record_Based.thy
197c197
<   R :: "'i \<Rightarrow> 'a :: {field, normalization_euclidean_semiring, euclidean_ring, factorial_ring_gcd} \<Rightarrow> bool" +
---
>   R :: "'i \<Rightarrow> 'a :: {field_gcd} \<Rightarrow> bool" +
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Berlekamp_Type_Based.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Berlekamp_Type_Based.thy
318,319c318
<     using  associatedD2 n p0 q
<     by (metis (no_types, lifting) mult_cancel_right1 normalize_eq_0_iff normalize_mult poly_dvd_1)
---
>     using degree_eq degree_mult_eq p0 q by fastforce
326,327c325,327
< 
< lemma prod_list_normalize: "normalize (prod_list P) = prod_list (map normalize P)"
---
> lemma prod_list_normalize: 
>   fixes P :: "'b :: {idom_divide,normalization_semidom_multiplicative} poly list"
>   shows "normalize (prod_list P) = prod_list (map normalize P)"
364c364
<     for f g :: "'a :: {field,euclidean_ring_gcd} poly"
---
>     for f g :: "'a :: {field_gcd} poly"
418c418
<   for m a :: "'a :: {factorial_ring_gcd, field} poly"
---
>   for m a :: "'a :: {field_gcd} poly"
709c709
< assumes f: "finite A" and f0: "(f :: 'b :: {field,factorial_ring_gcd} poly) \<noteq> 0"
---
> assumes f: "finite A" and f0: "(f :: 'b :: {field_gcd} poly) \<noteq> 0"
757c757
<   fixes a1 :: "'b :: {field,factorial_ring_gcd} poly"
---
>   fixes a1 :: "'b :: {field_gcd} poly"
1592c1592
<     and a b p :: "'c :: {factorial_ring_gcd,field} poly"
---
>     and a b p :: "'c :: {field_gcd} poly"
2726c2726,2727
<   assumes uf: "u dvd (f :: 'b :: {field,euclidean_ring_gcd} poly)" and fin: "finite P" and fP: "f = \<Prod>P" and P: "P \<subseteq> {q. irreducible q \<and> monic q}"
---
>   assumes uf: "u dvd (f :: 'b :: {field_gcd} poly)" and fin: "finite P"
>       and fP: "f = \<Prod>P" and P: "P \<subseteq> {q. irreducible q \<and> monic q}"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Chinese_Remainder_Poly.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Chinese_Remainder_Poly.thy
19c19
<   "[(a::'b::{factorial_ring_gcd,field} poly) = b] (mod m) \<Longrightarrow> [c = d] (mod m) \<Longrightarrow> [a + c = b + d] (mod m)"
---
>   "[(a::'b::{field_gcd} poly) = b] (mod m) \<Longrightarrow> [c = d] (mod m) \<Longrightarrow> [a + c = b + d] (mod m)"
23c23
<   "[(a::'b::{field, factorial_ring_gcd} poly) = b] (mod m) \<Longrightarrow> [c = d] (mod m) \<Longrightarrow> [a * c = b * d] (mod m)"
---
>   "[(a::'b::{field_gcd} poly) = b] (mod m) \<Longrightarrow> [c = d] (mod m) \<Longrightarrow> [a * c = b * d] (mod m)"
26c26
< lemma cong_mult_self_poly: "[(a::'b::{factorial_ring_gcd,field} poly) * m = 0] (mod m)"
---
> lemma cong_mult_self_poly: "[(a::'b::{field_gcd} poly) * m = 0] (mod m)"
29c29
< lemma cong_scalar2_poly: "[(a::'b::{field, factorial_ring_gcd} poly)= b] (mod m) \<Longrightarrow> [k * a = k * b] (mod m)"
---
> lemma cong_scalar2_poly: "[(a::'b::{field_gcd} poly)= b] (mod m) \<Longrightarrow> [k * a = k * b] (mod m)"
33c33
<     "(\<And>x. x \<in> A \<Longrightarrow> [((f x)::'b::{factorial_ring_gcd,field} poly) = g x] (mod m)) \<Longrightarrow>
---
>     "(\<And>x. x \<in> A \<Longrightarrow> [((f x)::'b::{field_gcd} poly) = g x] (mod m)) \<Longrightarrow>
37c37
< lemma cong_iff_lin_poly: "([(a::'b::{factorial_ring_gcd,field} poly) = b] (mod m)) = (\<exists>k. b = a + m * k)"
---
> lemma cong_iff_lin_poly: "([(a::'b::{field_gcd} poly) = b] (mod m)) = (\<exists>k. b = a + m * k)"
40c40
< lemma cong_solve_poly: "(a::'b::{normalization_euclidean_semiring, factorial_ring_gcd,field} poly) \<noteq> 0 \<Longrightarrow> \<exists>x. [a * x = gcd a n] (mod n)"
---
> lemma cong_solve_poly: "(a::'b::{field_gcd} poly) \<noteq> 0 \<Longrightarrow> \<exists>x. [a * x = gcd a n] (mod n)"
66c66
< assumes coprime_an:"coprime (a::'b::{normalization_euclidean_semiring, factorial_ring_gcd,field} poly) n"
---
> assumes coprime_an:"coprime (a::'b::{field_gcd} poly) n"
81c81
<   "[x = y] (mod m) \<Longrightarrow> n dvd m \<Longrightarrow> [x = y] (mod n)" for x y :: "'b::{factorial_ring_gcd,field} poly"
---
>   "[x = y] (mod m) \<Longrightarrow> n dvd m \<Longrightarrow> [x = y] (mod n)" for x y :: "'b::{field_gcd} poly"
86c86
<     and m :: "'a \<Rightarrow> 'b::{normalization_euclidean_semiring,factorial_ring_gcd,field} poly"
---
>     and m :: "'a \<Rightarrow> 'b::{field_gcd} poly"
111c111
<     and m :: "'a \<Rightarrow> 'b::{normalization_euclidean_semiring,factorial_ring_gcd,field} poly"
---
>     and m :: "'a \<Rightarrow> 'b::{field_gcd} poly"
160c160
<     "[(a::'b::{factorial_ring_gcd,field} poly) = b] (mod m) \<Longrightarrow> [b = c] (mod m) \<Longrightarrow> [a = c] (mod m)"
---
>     "[(a::'b::{field_gcd} poly) = b] (mod m) \<Longrightarrow> [b = c] (mod m) \<Longrightarrow> [a = c] (mod m)"
163c163
< lemma cong_mod_poly: "(n::'b::{factorial_ring_gcd,field} poly) ~= 0 \<Longrightarrow> [a mod n = a] (mod n)"
---
> lemma cong_mod_poly: "(n::'b::{field_gcd} poly) ~= 0 \<Longrightarrow> [a mod n = a] (mod n)"
166c166
< lemma cong_sym_poly: "[(a::'b::{factorial_ring_gcd,field} poly) = b] (mod m) \<Longrightarrow> [b = a] (mod m)"
---
> lemma cong_sym_poly: "[(a::'b::{field_gcd} poly) = b] (mod m) \<Longrightarrow> [b = a] (mod m)"
169c169
< lemma cong_1_poly: "[(a::'b::{factorial_ring_gcd,field} poly) = b] (mod 1)"
---
> lemma cong_1_poly: "[(a::'b::{field_gcd} poly) = b] (mod 1)"
173c173
<   assumes "[(a::'b::{factorial_ring_gcd,field} poly) = b] (mod m)" and "[a = b] (mod n)" and "coprime m n"
---
>   assumes "[(a::'b::{field_gcd} poly) = b] (mod m)" and "[a = b] (mod n)" and "coprime m n"
180c180
<       (\<forall>i\<in>A. [(x::'b::{factorial_ring_gcd,field} poly) = y] (mod m i)) \<Longrightarrow>
---
>       (\<forall>i\<in>A. [(x::'b::{field_gcd} poly) = y] (mod m i)) \<Longrightarrow>
188c188
<     "[(x::'b::{factorial_ring_gcd,field} poly) = y] (mod m) \<Longrightarrow> degree x < degree m \<Longrightarrow> degree y < degree m \<Longrightarrow> x = y"
---
>     "[(x::'b::{field_gcd} poly) = y] (mod m) \<Longrightarrow> degree x < degree m \<Longrightarrow> degree y < degree m \<Longrightarrow> x = y"
194c194
<     and m :: "'a \<Rightarrow> 'b::{normalization_euclidean_semiring,factorial_ring_gcd,field} poly"
---
>     and m :: "'a \<Rightarrow> 'b::{field_gcd} poly"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Code_Abort_Gcd.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Code_Abort_Gcd.thy
22c22,23
< lemmas dummy_Gcd_Lcm_poly [code] = dummy_Gcd_Lcm [where ?'a = "'a :: factorial_ring_gcd poly"] 
---
> lemmas dummy_Gcd_Lcm_poly [code] = dummy_Gcd_Lcm
>   [where ?'a = "'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize} poly"] 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Factorize_Int_Poly.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Factorize_Int_Poly.thy
227c227
< lemma gcd_reflect_poly: fixes f :: "'a :: factorial_ring_gcd poly"
---
> lemma gcd_reflect_poly: fixes f :: "'a :: {factorial_ring_gcd, semiring_gcd_mult_normalize} poly"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Factorize_Rat_Poly.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Factorize_Rat_Poly.thy
17c17,18
< interpretation content_hom: monoid_mult_hom "content::'a::factorial_semiring_gcd poly \<Rightarrow> _"
---
> interpretation content_hom: monoid_mult_hom
>   "content::'a::{factorial_semiring, semiring_gcd, normalization_semidom_multiplicative} poly \<Rightarrow> _"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Finite_Field.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Finite_Field.thy
17c17
<   Containers.Set_Impl
---
>   "HOL-Library.Cardinality"
321a322,334
> 
> instantiation mod_ring :: (prime_card) unique_euclidean_ring
> begin
> 
> definition [simp]: "division_segment_mod_ring (x :: 'a mod_ring) = (1 :: 'a mod_ring)"
> 
> instance by intro_classes (auto simp: euclidean_size_mod_ring_def split: if_splits)
> 
> end
> 
> instance mod_ring :: (prime_card) field_gcd
>   by intro_classes auto
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Hensel_Lifting.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Hensel_Lifting.thy
28c28
<   fixes f g :: "'a :: factorial_ring_gcd poly"
---
>   fixes f g :: "'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
92c92
< lemma dupe_monic_unique: fixes D :: "'a :: factorial_ring_gcd poly" 
---
> lemma dupe_monic_unique: fixes D :: "'a ::  {factorial_ring_gcd,semiring_gcd_mult_normalize} poly" 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Poly_Mod.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Poly_Mod.thy
48a49,54
> definition inv_M :: "int \<Rightarrow> int" where
>   "inv_M = (\<lambda> x. if x + x \<le> m then x else x - m)" 
> 
> lemma M_inv_M_id[simp]: "M (inv_M x) = M x" 
>   unfolding inv_M_def M_def by simp
> 
249a256
> declare poly_mod.inv_M_def[code]
451a459,474
> 
> lemma inv_M_rev: assumes bnd: "2 * abs c < m" 
>   shows "inv_M (M c) = c"
> proof (cases "c \<ge> 0")
>   case True
>   with bnd show ?thesis unfolding M_def inv_M_def by auto
> next
>   case False
>   have 2: "\<And> v :: int. 2 * v = v + v" by auto
>   from False have c: "c < 0" by auto
>   from bnd c have "c + m > 0" "c + m < m" by auto
>   with c have cm: "c mod m = c + m"
>     by (metis le_less mod_add_self2 mod_pos_pos_trivial)
>   from c bnd have "2 * (c mod m) > m" unfolding cm by auto
>   with bnd c show ?thesis unfolding M_def inv_M_def cm by auto
> qed
Only in ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus: Pre_BZ
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Reconstruction.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Reconstruction.thy
39,41d38
< definition inv_M :: "int \<Rightarrow> int" where
<   "inv_M = (\<lambda> x. if x + x \<le> m then x else x - m)" 
< 
96d92
< declare poly_mod.inv_M_def[code]
113,115d108
< lemma (in poly_mod) M_inv_M_id[simp]: "M (inv_M x) = M x" 
<   unfolding inv_M_def M_def by simp
< 
175,190d167
< 
< lemma inv_M_rev: assumes bnd: "2 * abs c < m" 
<   shows "inv_M (M c) = c"
< proof (cases "c \<ge> 0")
<   case True
<   with bnd show ?thesis unfolding M_def inv_M_def by auto
< next
<   case False
<   have 2: "\<And> v :: int. 2 * v = v + v" by auto
<   from False have c: "c < 0" by auto
<   from bnd c have "c + m > 0" "c + m < m" by auto
<   with c have cm: "c mod m = c + m"
<     by (metis le_less mod_add_self2 mod_pos_pos_trivial)
<   from c bnd have "2 * (c mod m) > m" unfolding cm by auto
<   with bnd c show ?thesis unfolding M_def inv_M_def cm by auto
< qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Square_Free_Factorization_Int.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Square_Free_Factorization_Int.thy
94c94
<   shows "gcd (smult c f) g = gcd f (g :: 'b :: {field, factorial_ring_gcd} poly)"
---
>   shows "gcd (smult c f) g = gcd f (g :: 'b :: {field_gcd} poly)"
102c102
< lemma gcd_smult_right: "c \<noteq> 0 \<Longrightarrow> gcd f (smult c g) = gcd f (g :: 'b :: {field, factorial_ring_gcd} poly)"
---
> lemma gcd_smult_right: "c \<noteq> 0 \<Longrightarrow> gcd f (smult c g) = gcd f (g :: 'b :: {field_gcd} poly)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Unique_Factorization_Poly.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Unique_Factorization_Poly.thy
48a49,60
> (*field + unique_euclidean_ring + euclidean_ring_gcd + normalization_semidom_multiplicative*)
> 
> instantiation fract :: (idom) unique_euclidean_ring
> begin
> 
> definition [simp]: "division_segment_fract (x :: 'a fract) = (1 :: 'a fract)"
> 
> instance by standard (auto split: if_splits)
> end
> 
> instance fract :: (idom) field_gcd by standard auto
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Berlekamp_Zassenhaus/Unique_Factorization.thy ../../AFPs/afp-2020/thys/Berlekamp_Zassenhaus/Unique_Factorization.thy
914,915c914,917
<   obtain F where f: "\<And>f. f \<in># F \<Longrightarrow> prime_elem f" and Fx: "prod_mset F = normalize x" by auto
<   from Fx have x: "x = unit_factor x * prod_mset F" by auto
---
>   obtain F where f: "\<And>f. f \<in># F \<Longrightarrow> prime_elem f" 
>              and Fx: "normalize (prod_mset F) = normalize x" by auto
>   from associatedE2[OF Fx] obtain u where u: "is_unit u" "x = u * prod_mset F"
>     by blast
921c923,924
<   have g: "irreducible (unit_factor x * g)" by auto
---
>   have g: "irreducible (u * g)" using u(1)
>     by (subst irreducible_mult_unit_left) simp_all
924,925c927,929
<     from x show "prod_mset (add_mset (unit_factor x * g) G) = x" by (simp add: F ac_simps)
<     fix f assume "f \<in># add_mset (unit_factor x * g) G"
---
>     show "prod_mset (add_mset (u * g) G) = x"
>       using \<open>x \<noteq> 0\<close> by (simp add: F ac_simps u)
>     fix f assume "f \<in># add_mset (u * g) G"
936,946c940,954
<     have FG: "image_mset normalize F = image_mset normalize G"
<     proof (intro prime_factorization_unique')
<       from 2 have xF: "x = prod_mset F" and xG: "x = prod_mset G" by auto
<       from xF have "normalize x = prod_mset (image_mset normalize F)" by (simp add: local.normalize_prod_mset)
<       with xG have nFG: "\<dots> = prod_mset (image_mset normalize G)" by (simp_all add: local.normalize_prod_mset)
<       then show "(\<Prod>i\<in>#image_mset normalize F. i) = (\<Prod>i\<in>#image_mset normalize G. i)" by auto
<       from 2 prime_elem_iff_irreducible have "f \<in># F \<Longrightarrow> prime_elem f" "g \<in># G \<Longrightarrow> prime_elem g" for f g
<        by (auto intro: prime_elemI)
<       then show " Multiset.Ball (image_mset normalize F) prime"
<         "Multiset.Ball (image_mset normalize G) prime" by auto
<     qed
---
>   have FG: "image_mset normalize F = image_mset normalize G"
>   proof (intro prime_factorization_unique'')
>     from 2 have xF: "x = prod_mset F" and xG: "x = prod_mset G" by auto
>     from xF have "normalize x = normalize (prod_mset (image_mset normalize F))"
>       by (simp add: normalize_prod_mset_normalize)
>     with xG have nFG: "\<dots> = normalize (prod_mset (image_mset normalize G))"
>       by (simp_all add: normalize_prod_mset_normalize)
>     then show "normalize (\<Prod>i\<in>#image_mset normalize F. i) =
>                normalize (\<Prod>i\<in>#image_mset normalize G. i)" by auto
>   next
>     from 2 prime_elem_iff_irreducible have "f \<in># F \<Longrightarrow> prime_elem f" "g \<in># G \<Longrightarrow> prime_elem g" for f g
>      by (auto intro: prime_elemI)
>     then show " Multiset.Ball (image_mset normalize F) prime"
>       "Multiset.Ball (image_mset normalize G) prime" by auto
>   qed
==========
Bernoulli
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bernoulli/Bernoulli_FPS.thy ../../AFPs/afp-2020/thys/Bernoulli/Bernoulli_FPS.thy
13c13,14
<     "HOL-Computational_Algebra.Formal_Power_Series"
---
>     "HOL-Computational_Algebra.Computational_Algebra"
>     "HOL-Number_Theory.Number_Theory"
15a17,204
> 
> subsection \<open>Preliminaries\<close>
> 
> context factorial_semiring
> begin
> 
> lemma multiplicity_prime_prime:
>   "prime p \<Longrightarrow> prime q \<Longrightarrow> multiplicity p q = (if p = q then 1 else 0)"
>   by (simp add: prime_multiplicity_other)
> 
> lemma prime_prod_dvdI:
>   fixes f :: "'b \<Rightarrow> 'a"
>   assumes "finite A"
>   assumes "\<And>x. x \<in> A \<Longrightarrow> prime (f x)"
>   assumes "\<And>x. x \<in> A \<Longrightarrow> f x dvd y"
>   assumes "inj_on f A"
>   shows   "prod f A dvd y"
> proof (cases "y = 0")
>   case False
>   have nz: "f x \<noteq> 0" if "x \<in> A" for x
>     using assms(2)[of x] that by auto
>   have "prod f A \<noteq> 0"
>     using assms nz by (subst prod_zero_iff) auto
>   thus ?thesis
>   proof (rule multiplicity_le_imp_dvd)
>     fix p :: 'a assume "prime p"
>     show "multiplicity p (prod f A) \<le> multiplicity p y"
>     proof (cases "p dvd prod f A")
>       case True
>       then obtain x where x: "x \<in> A" and "p dvd f x"
>         using \<open>prime p\<close> assms by (subst (asm) prime_dvd_prod_iff) auto
>       have "multiplicity p (prod f A) = (\<Sum>x\<in>A. multiplicity p (f x))"
>         using assms \<open>prime p\<close> nz by (intro prime_elem_multiplicity_prod_distrib) auto
>       also have "\<dots> = (\<Sum>x\<in>{x}. 1 :: nat)"
>         using assms \<open>prime p\<close> \<open>p dvd f x\<close> primes_dvd_imp_eq x 
>         by (intro Groups_Big.sum.mono_neutral_cong_right)
>            (auto simp: multiplicity_prime_prime inj_on_def)
>       finally have "multiplicity p (prod f A) = 1" by simp
>       also have "1 \<le> multiplicity p y"
>         using assms nz \<open>prime p\<close> \<open>y \<noteq> 0\<close> x \<open>p dvd f x\<close>
>         by (intro multiplicity_geI) force+
>       finally show ?thesis .
>     qed (auto simp: not_dvd_imp_multiplicity_0)
>   qed
> qed auto
> 
> end
> 
> 
> (* TODO: Move? *)
> context semiring_gcd
> begin
> 
> lemma gcd_add_dvd_right1: "a dvd b \<Longrightarrow> gcd a (b + c) = gcd a c"
>   by (elim dvdE) (simp add: gcd_add_mult mult.commute[of a])
> 
> lemma gcd_add_dvd_right2: "a dvd c \<Longrightarrow> gcd a (b + c) = gcd a b"
>   using gcd_add_dvd_right1[of a c b] by (simp add: add_ac)
> 
> lemma gcd_add_dvd_left1: "a dvd b \<Longrightarrow> gcd (b + c) a = gcd c a"
>   using gcd_add_dvd_right1[of a b c] by (simp add: gcd.commute)
> 
> lemma gcd_add_dvd_left2: "a dvd c \<Longrightarrow> gcd (b + c) a = gcd b a"
>   using gcd_add_dvd_right2[of a c b] by (simp add: gcd.commute)
> 
> end
> 
> context ring_gcd
> begin
> 
> lemma gcd_diff_dvd_right1: "a dvd b \<Longrightarrow> gcd a (b - c) = gcd a c"
>   using gcd_add_dvd_right1[of a b "-c"] by simp
> 
> lemma gcd_diff_dvd_right2: "a dvd c \<Longrightarrow> gcd a (b - c) = gcd a b"
>   using gcd_add_dvd_right2[of a "-c" b] by simp
> 
> lemma gcd_diff_dvd_left1: "a dvd b \<Longrightarrow> gcd (b - c) a = gcd c a"
>   using gcd_add_dvd_left1[of a b "-c"] by simp
> 
> lemma gcd_diff_dvd_left2: "a dvd c \<Longrightarrow> gcd (b - c) a = gcd b a"
>   using gcd_add_dvd_left2[of a "-c" b] by simp
> 
> end
> 
> lemma cong_int: "[a = b] (mod m) \<Longrightarrow> [int a = int b] (mod m)"
>   by (simp add: cong_int_iff)
> 
> lemma Rats_int_div_natE:
>   assumes "(x :: 'a :: field_char_0) \<in> \<rat>"
>   obtains m :: int and n :: nat where "n > 0" and "x = of_int m / of_nat n" and "coprime m n"
> proof -
>   from assms obtain r where [simp]: "x = of_rat r"
>     by (auto simp: Rats_def)
>   obtain a b where [simp]: "r = Rat.Fract a b" and ab: "b > 0" "coprime a b"
>     by (cases r)
>   from ab show ?thesis
>     by (intro that[of "nat b" a]) (auto simp: of_rat_rat)
> qed
> 
> lemma sum_in_Ints: "(\<And>x. x \<in> A \<Longrightarrow> f x \<in> \<int>) \<Longrightarrow> sum f A \<in> \<int>"
>   by (induction A rule: infinite_finite_induct) auto
> 
> lemma Ints_real_of_nat_divide: "b dvd a \<Longrightarrow> real a / real b \<in> \<int>"
>   by auto
> 
> 
> lemma product_dvd_fact:
>   assumes "a > 1" "b > 1" "a = b \<longrightarrow> a > 2"
>   shows   "(a * b) dvd fact (a * b - 1)"
> proof (cases "a = b")
>   case False
>   have "a * 1 < a * b" and "1 * b < a * b"
>     using assms by (intro mult_strict_left_mono mult_strict_right_mono; simp)+
>   hence ineqs: "a \<le> a * b - 1" "b \<le> a * b - 1"
>     by linarith+
>   from False have "a * b = \<Prod>{a,b}" by simp
>   also have "\<dots> dvd \<Prod>{1..a * b - 1}"
>     using assms ineqs by (intro prod_dvd_prod_subset) auto
>   finally show ?thesis by (simp add: fact_prod)
> next
>   case [simp]: True
>   from assms have "a > 2" by auto
>   hence "a * 2 < a * b" using assms by (intro mult_strict_left_mono; simp)
>   hence *: "2 * a \<le> a * b - 1" by linarith
>   have "a * a dvd (2 * a) * a" by simp
>   also have "\<dots> = \<Prod>{2*a, a}" using assms by auto
>   also have "\<dots> dvd \<Prod>{1..a * b - 1}"
>     using assms * by (intro prod_dvd_prod_subset) auto
>   finally show ?thesis by (simp add: fact_prod)
> qed
> 
> lemma composite_imp_factors_nat:
>   assumes "m > 1" "\<not>prime (m::nat)"
>   shows   "\<exists>n k. m = n * k \<and> 1 < n \<and> n < m \<and> 1 < k \<and> k < m"
> proof -
>   from assms have "\<not>irreducible m"
>     by (simp flip: prime_elem_iff_irreducible )
>   then obtain a where a: "a dvd m" "\<not>m dvd a" "a \<noteq> 1"
>     using assms by (auto simp: irreducible_altdef)
>   then obtain b where [simp]: "m = a * b"
>     by auto
>   from a assms have "a \<noteq> 0" "b \<noteq> 0" "b \<noteq> 1"
>     by (auto intro!: Nat.gr0I)
>   with a have "a > 1" "b > 1" by linarith+
>   moreover from this and a have "a < m" "b < m"
>     by auto
>   ultimately show ?thesis using \<open>m = a * b\<close>
>     by blast
> qed
> 
> text \<open>
>   This lemma describes what the numerator and denominator of a finite subseries of the
>   harmonic series are when it is written as a single fraction.
> \<close>
> lemma sum_inverses_conv_fraction:
>   fixes f :: "'a \<Rightarrow> 'b :: field"
>   assumes "\<And>x. x \<in> A \<Longrightarrow> f x \<noteq> 0" "finite A"
>   shows "(\<Sum>x\<in>A. 1 / f x) = (\<Sum>x\<in>A. \<Prod>y\<in>A-{x}. f y) / (\<Prod>x\<in>A. f x)"
> proof -
>   have "(\<Sum>x\<in>A. (\<Prod>y\<in>A. f y) / f x) = (\<Sum>x\<in>A. \<Prod>y\<in>A-{x}. f y)"
>     using prod.remove[of A _ f] assms by (intro sum.cong refl) (auto simp: field_simps)
>   thus ?thesis
>     using assms by (simp add: field_simps sum_distrib_right sum_distrib_left)
> qed  
> 
> text \<open>
>   If all terms in the subseries are primes, this fraction is automatically on lowest terms.
> \<close>
> lemma sum_prime_inverses_fraction_coprime:
>   fixes f :: "'a \<Rightarrow> nat"
>   assumes "finite A" and primes: "\<And>x. x \<in> A \<Longrightarrow> prime (f x)" and inj: "inj_on f A"
>   defines "a \<equiv> (\<Sum>x\<in>A. \<Prod>y\<in>A-{x}. f y)"
>   shows   "coprime a (\<Prod>x\<in>A. f x)"
> proof (intro prod_coprime_right)
>   fix x assume x: "x \<in> A"
>   have "a = (\<Prod>y\<in>A-{x}. f y) + (\<Sum>y\<in>A-{x}. \<Prod>z\<in>A-{y}. f z)"
>     unfolding a_def using \<open>finite A\<close> and x by (rule sum.remove)
>   also have "gcd \<dots> (f x) = gcd (\<Prod>y\<in>A-{x}. f y) (f x)"
>     using \<open>finite A\<close> and x by (intro gcd_add_dvd_left2 dvd_sum dvd_prodI) auto
>   also from x primes inj have "coprime (\<Prod>y\<in>A-{x}. f y) (f x)"
>     by (intro prod_coprime_left) (auto intro!: primes_coprime simp: inj_on_def)
>   hence "gcd (\<Prod>y\<in>A-{x}. f y) (f x) = 1"
>     by simp
>   finally show "coprime a (f x)"
>     by (simp only: coprime_iff_gcd_eq_1)
> qed
> (* END TODO *)
> 
401a591,1029
> qed
> 
> corollary%important bernoulli_conv_Stirling:
>   "bernoulli n = (\<Sum>k\<le>n. (-1) ^ k * fact k / real (k + 1) * Stirling n k)"
> proof -
>   have "(\<Sum>k\<le>n. (-1) ^ k * fact k / (k + 1) * Stirling n k) =
>           (\<Sum>k\<le>n. \<Sum>i\<le>k. (-1) ^ i * (k choose i) * i ^ n / real (k + 1))"
>   proof (intro sum.cong, goal_cases)
>     case (2 k)
>     have "(-1) ^ k * fact k / (k + 1) * Stirling n k =
>             (\<Sum>j\<le>k. (-1) ^ k * (-1) ^ (k - j) *  (k choose j) * j ^ n / (k + 1))"
>       by (simp add: Stirling_closed_form sum_distrib_left sum_divide_distrib mult_ac)
>     also have "\<dots> = (\<Sum>j\<le>k. (-1) ^ j *  (k choose j) * j ^ n / (k + 1))"
>       by (intro sum.cong) (auto simp: uminus_power_if split: if_splits)
>     finally show ?case .
>   qed auto
>   also have "\<dots> = bernoulli n"
>     by (simp add: bernoulli_altdef)
>   finally show ?thesis ..
> qed
> 
> 
> subsection \<open>Von Staudt--Clausen Theorem\<close>
> 
> lemma vonStaudt_Clausen_lemma:
>   assumes "n > 0" and "prime p"
>   shows   "[(\<Sum>m<p. (-1) ^ m * ((p - 1) choose m) * m ^ (2*n)) =
>               (if (p - 1) dvd (2 * n) then -1 else 0)] (mod p)"
> proof (cases "(p - 1) dvd (2 * n)")
>   case True
>   have cong_power_2n: "[m ^ (2 * n) = 1] (mod p)" if "m > 0" "m < p" for m
>   proof -
>     from True obtain q where "2 * n = (p - 1) * q"
>       by blast
>     hence "[m ^ (2 * n) = (m ^ (p - 1)) ^ q] (mod p)"
>       by (simp add: power_mult)
>     also have "[(m ^ (p - 1)) ^ q = 1 ^ q] (mod p)"
>       using assms \<open>m > 0\<close> \<open>m < p\<close> by (intro cong_pow fermat_theorem) auto
>     finally show ?thesis by simp
>   qed
> 
>   have "(\<Sum>m<p. (-1)^m * ((p - 1) choose m) * m ^ (2*n)) =
>           (\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ (2*n))"
>     using \<open>n > 0\<close> by (intro sum.mono_neutral_right) auto
>   also have "[\<dots> = (\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * int 1)] (mod p)"
>     by (intro cong_sum cong_mult cong_power_2n cong_int) auto
>   also have "(\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * int 1) =
>                (\<Sum>m\<in>insert 0 {0<..<p}. (-1)^m * ((p - 1) choose m)) - 1"
>     by (subst sum.insert) auto
>   also have "insert 0 {0<..<p} = {..p-1}"
>     using assms prime_gt_0_nat[of p] by auto
>   also have "(\<Sum>m\<le>p-1. (-1)^m * ((p - 1) choose m)) = 0"
>     using prime_gt_1_nat[of p] assms by (subst choose_alternating_sum) auto
>   finally show ?thesis using True by simp
> next
>   case False
>   define n' where "n' = (2 * n) mod (p - 1)"
>   from assms False have "n' > 0"
>     by (auto simp: n'_def dvd_eq_mod_eq_0)
>   from False have "p \<noteq> 2" by auto
>   with assms have "odd p"
>     using prime_prime_factor two_is_prime_nat by blast
>     
>   have cong_pow_2n: "[m ^ (2*n) = m ^ n'] (mod p)" if "m > 0" "m < p" for m
>   proof -
>     from assms and that have "coprime p m"
>       by (intro prime_imp_coprime) auto
>     have "[2 * n = n'] (mod (p - 1))"
>       by (simp add: n'_def)
>     moreover have "ord p m dvd (p - 1)"
>       using order_divides_totient[of p m] \<open>coprime p m\<close> assms by (auto simp: totient_prime)
>     ultimately have "[2 * n = n'] (mod ord p m)"
>       by (rule cong_dvd_modulus_nat)
>     thus ?thesis
>       using \<open>coprime p m\<close> by (subst order_divides_expdiff) auto
>   qed
> 
>   have "(\<Sum>m<p. (-1)^m * ((p - 1) choose m) * m ^ (2*n)) =
>           (\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ (2*n))"
>     using \<open>n > 0\<close> by (intro sum.mono_neutral_right) auto
>   also have "[\<dots> = (\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ n')] (mod p)"
>     by (intro cong_sum cong_mult cong_pow_2n cong_int) auto
>   also have "(\<Sum>m\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ n') =
>                (\<Sum>m\<le>p-1. (-1)^m * ((p - 1) choose m) * m ^ n')"
>     using \<open>n' > 0\<close> by (intro sum.mono_neutral_left) auto
>   also have "\<dots> = (\<Sum>m\<le>p-1. (-1)^(p - Suc m) * ((p - 1) choose m) * m ^ n')"
>     using \<open>n' > 0\<close> assms \<open>odd p\<close> by (intro sum.cong) (auto simp: uminus_power_if)
>   also have "\<dots> = 0"
>   proof -
>     have "of_int (\<Sum>m\<le>p-1. (-1)^(p - Suc m) * ((p - 1) choose m) * m ^ n') =
>             real (Stirling n' (p - 1)) * fact (p - 1)"
>       by (simp add: Stirling_closed_form)
>     also have "n' < p - 1"
>       using assms prime_gt_1_nat[of p] by (auto simp: n'_def)
>     hence "Stirling n' (p - 1) = 0"
>       by simp
>     finally show ?thesis by linarith
>   qed
>   finally show ?thesis using False by simp
> qed
>  
> text \<open>
>   The Von Staudt--Clausen theorem states that for \<open>n > 0\<close>,
>     \[B_{2n} + \sum\limits_{p - 1\mid 2n} \frac{1}{p}\]
>   is an integer.
> \<close>
> theorem vonStaudt_Clausen:
>   assumes "n > 0"
>   shows   "bernoulli (2 * n) + (\<Sum>p | prime p \<and> (p - 1) dvd (2 * n). 1 / real p) \<in> \<int>"
>     (is "_ + ?P \<in> \<int>")
> proof -
>   define P :: "nat \<Rightarrow> real"
>     where "P = (\<lambda>m. if prime (m + 1) \<and> m dvd (2 * n) then 1 / (m + 1) else 0)"  
>   define P' :: "nat \<Rightarrow> int"
>     where "P' = (\<lambda>m. if prime (m + 1) \<and> m dvd (2 * n) then 1 else 0)"
> 
>   have "?P = (\<Sum>p | prime (p + 1) \<and> p dvd (2 * n). 1 / real (p + 1))"
>     by (rule sum.reindex_bij_witness[of _ "\<lambda>p. p + 1" "\<lambda>p. p - 1"])
>        (use prime_gt_0_nat in auto)
>   also have "\<dots> = (\<Sum>m\<le>2*n. P m)"
>     using \<open>n > 0\<close> by (intro sum.mono_neutral_cong_left) (auto simp: P_def dest!: dvd_imp_le)
>   finally have "bernoulli (2 * n) + ?P =
>                   (\<Sum>m\<le>2*n. (-1)^m * (of_int (fact m * Stirling (2*n) m) / (m + 1)) + P m)"
>     by (simp add: sum.distrib bernoulli_conv_Stirling sum_divide_distrib algebra_simps)
>   also have "\<dots> = (\<Sum>m\<le>2*n. of_int ((-1)^m * fact m * Stirling (2*n) m + P' m) / (m + 1))"
>     by (intro sum.cong) (auto simp: P'_def P_def field_simps)
>   also have "\<dots> \<in> \<int>"
>   proof (rule sum_in_Ints, goal_cases)
>     case (1 m)
>     have "m = 0 \<or> m = 3 \<or> prime (m + 1) \<or> (\<not>prime (m + 1) \<and> m > 3)"
>       by (cases "m = 1"; cases "m = 2") (auto simp flip: numeral_2_eq_2)
>     then consider "m = 0" | "m = 3" | "prime (m + 1)" | "\<not>prime (m + 1)" "m > 3"
>       by blast
>     thus ?case
>     proof cases
>       assume "m = 0"
>       thus ?case by auto
>     next
>       assume [simp]: "m = 3"
>       have "real_of_int (fact m * Stirling (2 * n) m) =
>               real_of_int (9 ^ n + 3 - 3 * 4 ^ n)"
>         using \<open>n > 0\<close> by (auto simp: P'_def fact_numeral Stirling_closed_form power_mult
>                                      atMost_nat_numeral binomial_fact zero_power)
>       hence "int (fact m * Stirling (2 * n) m) = 9 ^ n + 3 - 3 * 4 ^ n"
>         by linarith
>       also have "[\<dots> = 1 ^ n + (-1) - 3 * 0 ^ n] (mod 4)"
>         by (intro cong_add cong_diff cong_mult cong_pow) (auto simp: cong_def)
>       finally have dvd: "4 dvd int (fact m * Stirling (2 * n) m)"
>         using \<open>n > 0\<close> by (simp add: cong_0_iff zero_power)
> 
>       have "real_of_int ((- 1) ^ m * fact m * Stirling (2 * n) m + P' m) / (m + 1) =
>               -(real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)"
>         using \<open>n > 0\<close> by (auto simp: P'_def)
>       also have "\<dots> \<in> \<int>"
>         by (intro Ints_minus of_int_divide_in_Ints dvd)
>       finally show ?case . 
>     next
>       assume composite: "\<not>prime (m + 1)" and "m > 3"
>       obtain a b where ab: "a * b = m + 1" "a > 1" "b > 1"
>         using \<open>m > 3\<close> composite composite_imp_factors_nat[of "m + 1"] by auto
>       have "a = b \<longrightarrow> a > 2"
>       proof
>         assume "a = b"
>         hence "a ^ 2 > 2 ^ 2"
>           using \<open>m > 3\<close> and ab by (auto simp: power2_eq_square)
>         thus "a > 2" 
>           using power_less_imp_less_base by blast
>       qed
>       hence dvd: "(m + 1) dvd fact m"
>         using product_dvd_fact[of a b] ab by auto
> 
>       have "real_of_int ((- 1) ^ m * fact m * Stirling (2 * n) m + P' m) / real (m + 1) =
>               real_of_int ((- 1) ^ m * Stirling (2 * n) m) * (real (fact m) / (m + 1))"
>         using composite by (auto simp: P'_def)
>       also have "\<dots> \<in> \<int>"
>         by (intro Ints_mult Ints_real_of_nat_divide dvd) auto
>       finally show ?case .
>     next
>       assume prime: "prime (m + 1)"
>       have "real_of_int ((-1) ^ m * fact m * int (Stirling (2 * n) m)) =
>               (\<Sum>j\<le>m. (-1) ^ m * (-1) ^ (m - j) * (m choose j) * real_of_int j ^ (2 * n))"
>         by (simp add: Stirling_closed_form sum_divide_distrib sum_distrib_left mult_ac)
>       also have "\<dots> = real_of_int (\<Sum>j\<le>m. (-1) ^ j * (m choose j) * j ^ (2 * n))"
>         unfolding of_int_sum by (intro sum.cong) (auto simp: uminus_power_if)
>       finally have "(-1) ^ m * fact m * int (Stirling (2 * n) m) =
>                       (\<Sum>j\<le>m. (-1) ^ j * (m choose j) * j ^ (2 * n))" by linarith
>       also have "\<dots> = (\<Sum>j<m+1. (-1) ^ j * (m choose j) * j ^ (2 * n))"
>         by (intro sum.cong) auto
>       also have "[\<dots> = (if m dvd 2 * n then - 1 else 0)] (mod (m + 1))"
>         using vonStaudt_Clausen_lemma[of n "m + 1"] prime \<open>n > 0\<close> by simp
>       also have "(if m dvd 2 * n then - 1 else 0) = - P' m"
>         using prime by (simp add: P'_def)
>       finally have "int (m + 1) dvd ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m)"
>         by (simp add: cong_iff_dvd_diff)
>       hence "real_of_int ((-1)^m * fact m * int (Stirling (2*n) m) + P' m) / of_int (int (m+1)) \<in> \<int>"
>         by (intro of_int_divide_in_Ints)
>       thus ?case by simp
>     qed
>   qed
>   finally show ?thesis .
> qed
> 
> 
> subsection \<open>Denominators of Bernoulli numbers\<close>
> 
> text \<open>
>   A consequence of the Von Staudt--Clausen theorem is that the denominator of $B_{2n}$ for $n > 0$
>   is precisely the product of all prime numbers \<open>p\<close> such that \<open>p - 1\<close> divides $2n$.
>   Since the denominator is obvious in all other cases, this fully characterises the denominator
>   of Bernoulli numbers.
> \<close>
> definition bernoulli_denom :: "nat \<Rightarrow> nat" where
>   "bernoulli_denom n =
>      (if n = 1 then 2 else if n = 0 \<or> odd n then 1 else \<Prod>{p. prime p \<and> (p - 1) dvd n})"
> 
> definition bernoulli_num :: "nat \<Rightarrow> int" where
>   "bernoulli_num n = \<lfloor>bernoulli n * bernoulli_denom n\<rfloor>"
> 
> lemma finite_bernoulli_denom_set: "n > (0 :: nat) \<Longrightarrow> finite {p. prime p \<and> (p - 1) dvd n}"
>   by (rule finite_subset[of _ "{..2*n+1}"]) (auto dest!: dvd_imp_le)
> 
> lemma bernoulli_denom_0 [simp]:   "bernoulli_denom 0 = 1"
>   and bernoulli_denom_1 [simp]:   "bernoulli_denom 1 = 2"
>   and bernoulli_denom_Suc_0 [simp]:   "bernoulli_denom (Suc 0) = 2"
>   and bernoulli_denom_odd [simp]: "n \<noteq> 1 \<Longrightarrow> odd n \<Longrightarrow> bernoulli_denom n = 1"
>   and bernoulli_denom_even:
>     "n > 0 \<Longrightarrow> even n \<Longrightarrow> bernoulli_denom n = \<Prod>{p. prime p \<and> (p - 1) dvd n}"
>   by (auto simp: bernoulli_denom_def)
> 
> lemma bernoulli_denom_pos: "bernoulli_denom n > 0"
>   by (auto simp: bernoulli_denom_def intro!: prod_pos)
> 
> lemma bernoulli_denom_nonzero [simp]: "bernoulli_denom n \<noteq> 0"
>   using bernoulli_denom_pos[of n] by simp
> 
> lemma bernoulli_denom_code [code]:
>   "bernoulli_denom n =
>      (if n = 1 then 2 else if n = 0 \<or> odd n then 1
>         else prod_list (filter (\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1))))" (is "_ = ?rhs")
> proof (cases "even n \<and> n > 0")
>   case True
>   hence "?rhs = prod_list (filter (\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1)))"
>     by auto
>   also have "\<dots> = \<Prod>(set (filter (\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1))))"
>     by (subst prod.distinct_set_conv_list) auto
>   also have "(set (filter (\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1)))) =
>                {p\<in>{..n+1}. prime p \<and> (p - 1) dvd n}"
>     by (auto simp: set_primes_upto)
>   also have "\<dots> = {p. prime p \<and> (p - 1) dvd n}"
>     using True by (auto dest: dvd_imp_le)
>   also have "\<Prod>\<dots> = bernoulli_denom n"
>     using True by (simp add: bernoulli_denom_even)
>   finally show ?thesis ..
> qed auto
> 
> corollary%important bernoulli_denom_correct:
>   obtains a :: int
>     where "coprime a (bernoulli_denom m)"
>           "bernoulli m = of_int a / of_nat (bernoulli_denom m)"
> proof -
>   consider "m = 0" | "m = 1" | "odd m" "m \<noteq> 1" | "even m" "m > 0"
>     by auto
>   thus ?thesis
>   proof cases
>     assume "m = 0"
>     thus ?thesis by (intro that[of 1]) (auto simp: bernoulli_denom_def)
>   next
>     assume "m = 1"
>     thus ?thesis by (intro that[of "-1"]) (auto simp: bernoulli_denom_def)
>   next
>     assume "odd m" "m \<noteq> 1"
>     thus ?thesis by (intro that[of 0]) (auto simp: bernoulli_denom_def bernoulli_odd_eq_0)
>   next
>     assume "even m" "m > 0"
>     define n where "n = m div 2"
>     have [simp]: "m = 2 * n" and n: "n > 0"
>       using \<open>even m\<close> \<open>m > 0\<close> by (auto simp: n_def intro!: Nat.gr0I)
>   
>     obtain a b where ab: "bernoulli (2 * n) = a / b" "coprime a (int b)" "b > 0"
>       using Rats_int_div_natE[OF bernoulli_in_Rats] by metis
>     define P where "P = {p. prime p \<and> (p - 1) dvd (2 * n)}"
>     have "finite P" unfolding P_def
>       using n by (intro finite_bernoulli_denom_set) auto
>     from vonStaudt_Clausen[of n] obtain k where k: "bernoulli (2 * n) + (\<Sum>p\<in>P. 1/p) = of_int k"
>       using \<open>n > 0\<close> by (auto simp: P_def Ints_def)
>   
>     define c where "c = (\<Sum>p\<in>P. \<Prod>(P-{p}))"
>     from \<open>finite P\<close> have "(\<Sum>p\<in>P. 1 / p) = c / \<Prod>P"
>       by (subst sum_inverses_conv_fraction) (auto simp: P_def prime_gt_0_nat c_def)
>     moreover have P_nz: "prod real P > 0"
>       using prime_gt_0_nat by (auto simp: P_def intro!: prod_pos)
>     ultimately have eq: "bernoulli (2 * n) = (k * \<Prod>P - c) / \<Prod>P"
>       using ab P_nz by (simp add: field_simps k [symmetric])
>   
>     have "gcd (k * \<Prod>P - int c) (\<Prod>P) = gcd (int c) (\<Prod>P)"
>       by (simp add: gcd_diff_dvd_left1)
>     also have "\<dots> = int (gcd c (\<Prod>P))"
>       by (simp flip: gcd_int_int_eq)
>     also have "coprime c (\<Prod>P)"
>       unfolding c_def using \<open>finite P\<close>
>       by (intro sum_prime_inverses_fraction_coprime) (auto simp: P_def)
>     hence "gcd c (\<Prod>P) = 1"
>       by simp
>     finally have coprime: "coprime (k * \<Prod>P - int c) (\<Prod>P)"
>       by (simp only: coprime_iff_gcd_eq_1)
>   
>     have eq': "\<Prod>P = bernoulli_denom (2 * n)"
>       using n by (simp add: bernoulli_denom_def P_def)
>     show ?thesis
>       by (rule that[of "k * \<Prod>P - int c"]) (use eq eq' coprime in simp_all)
>   qed
> qed
> 
> lemma bernoulli_conv_num_denom: "bernoulli n = bernoulli_num n / bernoulli_denom n" (is ?th1)
>   and coprime_bernoulli_num_denom: "coprime (bernoulli_num n) (bernoulli_denom n)" (is ?th2)
> proof -
>   obtain a :: int where a: "coprime a (bernoulli_denom n)" "bernoulli n = a / bernoulli_denom n"
>     using bernoulli_denom_correct[of n] by blast
>   thus ?th1 by (simp add: bernoulli_num_def)
>   with a show ?th2 by auto
> qed
> 
> text \<open>
>   Two obvious consequences from this are that the denominators of all odd Bernoulli numbers
>   except for the first one are squarefree and multiples of 6:
> \<close>
> lemma six_divides_bernoulli_denom:
>   assumes "even n" "n > 0"
>   shows   "6 dvd bernoulli_denom n"
> proof -
>   from assms have "\<Prod>{2, 3} dvd \<Prod>{p. prime p \<and> (p - 1) dvd n}"
>     by (intro prod_dvd_prod_subset finite_bernoulli_denom_set) auto
>   with assms show ?thesis by (simp add: bernoulli_denom_even)
> qed
> 
> lemma squarefree_bernoulli_denom: "squarefree (bernoulli_denom n)"
>   by (auto intro!: squarefree_prod_coprime primes_coprime
>            simp: bernoulli_denom_def squarefree_prime)
> 
> text \<open>
>   Furthermore, the denominator of $B_n$ divides $2(2^n - 1)$. This also gives us an
>   upper bound on the denominators.
> \<close>
> lemma bernoulli_denom_dvd: "bernoulli_denom n dvd (2 * (2 ^ n - 1))"
> proof (cases "even n \<and> n > 0")
>   case True
>   hence "bernoulli_denom n = \<Prod>{p. prime p \<and> (p - 1) dvd n}"
>     by (auto simp: bernoulli_denom_def)
>   also have "\<dots> dvd (2 * (2 ^ n - 1))"
>   proof (rule prime_prod_dvdI; clarify?)
>     from True show "finite {p. prime p \<and> (p - 1) dvd n}"
>       by (intro finite_bernoulli_denom_set) auto
>   next
>     fix p assume p: "prime p" "(p - 1) dvd n"
>     show "p dvd (2 * (2 ^ n - 1))"
>     proof (cases "p = 2")
>       case False
>       with p have "p > 2"
>         using prime_gt_1_nat[of p] by force
>       have "[2 ^ n - 1 = 1 - 1] (mod p)"
>         using p \<open>p > 2\<close> prime_odd_nat
>         by (intro cong_diff_nat Carmichael_divides) (auto simp: Carmichael_prime)
>       hence "p dvd (2 ^ n - 1)"
>         by (simp add: cong_0_iff)
>       thus ?thesis by simp
>     qed auto
>   qed auto
>   finally show ?thesis .
> qed (auto simp: bernoulli_denom_def)
> 
> corollary bernoulli_bound:
>   assumes "n > 0"
>   shows   "bernoulli_denom n \<le> 2 * (2 ^ n - 1)"
> proof -
>   from assms have "2 ^ n > (1 :: nat)"
>     by (intro one_less_power) auto
>   thus ?thesis
>     by (intro dvd_imp_le[OF bernoulli_denom_dvd]) auto
> qed
> 
> text \<open>
>   It can also be shown fairly easily from the von Staudt--Clausen theorem that if \<open>p\<close> is prime
>   and \<open>2p + 1\<close> is not, then $B_{2p} \equiv \frac{1}{6}\ (\text{mod}\ 1)$ or, equivalently,
>   the denominator of $B_{2p}$ is 6 and the numerator is of the form $6k+1$.
> 
>   This is the case e.\,g.\ for any primes of the form $3k+1$ or $5k+2$.
> \<close>
> lemma bernoulli_denom_prime_nonprime:
>   assumes "prime p" "\<not>prime (2 * p + 1)"
>   shows   "bernoulli (2 * p) - 1 / 6 \<in> \<int>"
>           "[bernoulli_num (2 * p) = 1] (mod 6)"
>           "bernoulli_denom (2 * p) = 6"
> proof -
>   from assms have "p > 0"
>     using prime_gt_0_nat by auto
>   define P where "P = {q. prime q \<and> (q - 1) dvd (2 * p)}"
>   have P_eq: "P = {2, 3}"
>   proof (intro equalityI subsetI)
>     fix q assume "q \<in> P"
>     hence q: "prime q" "(q - 1) dvd (2 * p)"
>       by (simp_all add: P_def)
>     have "q - 1 \<in> {1, 2, p, 2 * p}"
>     proof -
>       obtain b c where bc: "b dvd 2" "c dvd p" "q - 1 = b * c"
>         using division_decomp[OF q(2)] by auto
>       from bc have "b \<in> {1, 2}" and "c \<in> {1, p}"
>         using prime_nat_iff two_is_prime_nat \<open>prime p\<close> by blast+
>       with bc show ?thesis by auto
>     qed
>     hence "q \<in> {2, 3, p + 1, 2 * p + 1}"
>       using prime_gt_0_nat[OF \<open>prime q\<close>] by force
>     moreover have "q \<noteq> p + 1"
>     proof
>       assume [simp]: "q = p + 1"
>       have "even q \<or> even p" by auto
>       with \<open>prime q\<close> and \<open>prime p\<close> have "p = 2"
>         using prime_odd_nat[of p] prime_odd_nat[of q] prime_gt_1_nat[of p] prime_gt_1_nat[of q]
>         by force
>       with assms show False by (simp add: cong_def)
>     qed
>     ultimately show "q \<in> {2, 3}"
>       using assms \<open>prime q\<close> by auto
>   qed (auto simp: P_def)
> 
>   show [simp]: "bernoulli_denom (2 * p) = 6"
>     using \<open>p > 0\<close> P_eq by (subst bernoulli_denom_even) (auto simp: P_def)
>   have "bernoulli (2 * p) + 5 / 6 \<in> \<int>"
>     using \<open>p > 0\<close> P_eq vonStaudt_Clausen[of p] by (auto simp: P_def)
>   hence "bernoulli (2 * p) + 5 / 6 - 1 \<in> \<int>"
>     by (intro Ints_diff) auto
>   thus "bernoulli (2 * p) - 1 / 6 \<in> \<int>" by simp
>   then obtain a where "of_int a = bernoulli (2 * p) - 1 / 6"
>     by (elim Ints_cases) auto
>   hence "real_of_int a = real_of_int (bernoulli_num (2 * p) - 1) / 6"
>     by (auto simp: bernoulli_conv_num_denom)
>   hence "bernoulli_num (2 * p) - 1 = 6 * a"
>     by simp
>   thus "[bernoulli_num (2 * p) = 1] (mod 6)"
>     by (auto simp: cong_iff_dvd_diff)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bernoulli/Bernoulli_Zeta.thy ../../AFPs/afp-2020/thys/Bernoulli/Bernoulli_Zeta.thy
4c4
<   "HOL-Analysis.Analysis"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bernoulli/Periodic_Bernpoly.thy ../../AFPs/afp-2020/thys/Bernoulli/Periodic_Bernpoly.thy
100c100
<   ultimately show ?thesis by (rule Lim_transform_eventually)
---
>   ultimately show ?thesis by (blast intro: Lim_transform_eventually)
110c110
<   ultimately show ?thesis by (rule Lim_transform_eventually)
---
>   ultimately show ?thesis by (blast intro: Lim_transform_eventually)
167c167
<         by (rule Lim_transform_eventually)
---
>         by (blast intro: Lim_transform_eventually)
==========
Bertrands_Postulate
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bertrands_Postulate/Bertrand.thy ../../AFPs/afp-2020/thys/Bertrands_Postulate/Bertrand.thy
403c403
<     by (simp add: abs_if split: if_splits)
---
>     by (simp)
==========
Bicategory
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/BicategoryOfSpans.thy ../../AFPs/afp-2020/thys/Bicategory/BicategoryOfSpans.thy
9c9
< imports CanonicalIsos SpanBicategory ConcreteCategory IsomorphismClass Tabulation
---
> imports CanonicalIsos SpanBicategory Category3.ConcreteCategory IsomorphismClass Tabulation
98,99c98,99
<           by (metis C.ideD(1) C.in_hhomE C.isomorphic_implies_hpar(4)
<                     C.isomorphic_implies_ide(2) D.ideD(1) G.G_props(1))
---
>           by (metis C.ideD(1) C.isomorphic_implies_hpar(4) C.isomorphic_implies_ide(2)
>               C.trg_hcomp D.ideD(1) G.G_props(1) C.in_hhomE)
102,103c102,103
<           by (metis C.ideD(1) C.in_hhomE C.isomorphic_implies_hpar(3) C.isomorphic_implies_ide(2)
<               C.right_adjoint_simps(2) D.ideD(1) G.G_props(1))
---
>           by (metis C.ideD(1) C.isomorphic_implies_hpar(2-3) C.src_hcomp D.ideD(1) G.G_props(1)
>               C.right_adjoint_simps(2) C.in_hhomE)
197c197
<                     D.src_hcomp' D.hseqI' D.assoc_in_hom [of "F g" "F f\<^sup>*\<^sup>C" "G.e (src\<^sub>D r')"]
---
>                     D.src_hcomp D.assoc_in_hom [of "F g" "F f\<^sup>*\<^sup>C" "G.e (src\<^sub>D r')"]
204,210c204,212
<               using fg r' f' trg_g 2 C.left_adjoint_is_ide D.hseqE D.ideD(1)
<                     D.isomorphic_implies_ide D.src_hcomp' D.hseqI'
<                     D.assoc'_in_hom [of "G.d (trg\<^sub>D r')" "F g" "F f\<^sup>*\<^sup>C \<star>\<^sub>D G.e (src\<^sub>D r')"]
<               apply auto
<               by (metis (no_types, lifting) C.hseqE C.ideD(1) C.isomorphic_implies_ide(2)
<                   C.right_adjoint_simps(3) D.assoc'_eq_inv_assoc D.ideD(1) D.trg_hcomp'
<                   F.preserves_ide e_trg.ide_right)
---
>             proof -
>               have "D.ide (F f\<^sup>*\<^sup>C \<star>\<^sub>D G.e (src\<^sub>D r'))"
>                 using f' D.isomorphic_implies_ide by auto
>               moreover have "src\<^sub>D (F g) = trg\<^sub>D (F f\<^sup>*\<^sup>C \<star>\<^sub>D G.e (src\<^sub>D r'))"
>                 using fg r' f' 2 D.hseqE D.ideD(1) D.isomorphic_implies_ide D.trg_hcomp
>                 by metis
>               ultimately show ?thesis
>                 using fg r' trg_g C.left_adjoint_is_ide D.assoc'_in_hom(2) by simp
>             qed
216c218
<                 D.isomorphic_implies_ide(1) D.isomorphic_implies_ide(2) D.trg_hcomp'
---
>                 D.isomorphic_implies_ide(1) D.isomorphic_implies_ide(2) D.trg_hcomp
289c291
<             using f g r' \<phi> C.hseqI' G.\<Phi>_in_hom [of r' f] D.left_adjoint_is_ide \<rho>.ide_base
---
>             using f g r' \<phi> G.\<Phi>_in_hom [of r' f] D.left_adjoint_is_ide \<rho>.ide_base
388c390
<         using hseq_rf hseq_char by (unfold_locales, auto)
---
>         using hseq_rf hseq_char by unfold_locales auto
402c404
<         by (unfold_locales, auto)
---
>         by unfold_locales auto
413c415
<         by (unfold_locales, auto)
---
>         by unfold_locales auto
427c429
<           using ide_f \<rho> by (unfold_locales, auto)
---
>           using ide_f \<rho> by unfold_locales auto
452c454
<                 using hseq_ru hseq_char by (unfold_locales, auto)
---
>                 using hseq_ru hseq_char by unfold_locales auto
505c507
<                 using w_def hseq_fw hseq_char by (unfold_locales, auto)
---
>                 using w_def hseq_fw hseq_char by unfold_locales auto
511c513
<                 using hseq_gw hseq_char by (unfold_locales, auto)
---
>                 using hseq_gw hseq_char by unfold_locales auto
885c887
<               by (unfold_locales, auto)
---
>               by unfold_locales auto
910c912
<                 using hseq_char by (unfold_locales, auto)
---
>                 using hseq_char by unfold_locales auto
912c914
<                 using hseq_char by (unfold_locales, auto)
---
>                 using hseq_char by unfold_locales auto
917c919
<                 using hseq_gw hseq_char by (unfold_locales, auto)
---
>                 using hseq_gw hseq_char by unfold_locales auto
922c924
<                 using hseq_gw' hseq_char by (unfold_locales, auto)
---
>                 using hseq_gw' hseq_char by unfold_locales auto
935c937
<                 using \<rho>w by (unfold_locales, auto)
---
>                 using \<rho>w by unfold_locales auto
939c941
<                 using \<rho>w' by (unfold_locales, auto)
---
>                 using \<rho>w' by unfold_locales auto
956c958
<                 using r\<theta> by (unfold_locales, auto)
---
>                 using r\<theta> by unfold_locales auto
968c970
<                 using r\<theta>' by (unfold_locales, auto)
---
>                 using r\<theta>' by unfold_locales auto
976c978
<                 using hseq_char by (unfold_locales, auto)
---
>                 using hseq_char by unfold_locales auto
1672c1674
<                 using \<gamma> src_def trg_def arrI fw.composable hseqI' rf.are_arrows(2) by auto
---
>                 using \<gamma> src_def trg_def arrI fw.composable rf.are_arrows(2) by auto
1674c1676
<                 using \<gamma> src_def trg_def fw.composable gw.are_arrows(1) hseqI' src_f by auto
---
>                 using \<gamma> src_def trg_def fw.composable gw.are_arrows(1) src_f by auto
1744c1746
<                   using hseq_g\<gamma>' hseq_char by (unfold_locales, auto)
---
>                   using hseq_g\<gamma>' hseq_char by unfold_locales auto
1905c1907
<             using ide_char [of f] by (unfold_locales, auto)
---
>             using ide_char [of f] by unfold_locales auto
1914c1916
<             using ide_char [of g] by (unfold_locales, auto)
---
>             using ide_char [of g] by unfold_locales auto
1927c1929
<             using f' ide_char by (unfold_locales, auto)
---
>             using f' ide_char by unfold_locales auto
1940c1942
<             using g' ide_char by (unfold_locales, auto)
---
>             using g' ide_char by unfold_locales auto
1953c1955
<             using r ide_char by (unfold_locales, auto)
---
>             using r ide_char by unfold_locales auto
2174,2175c2176,2177
<           by (metis assms(3) ideD(1) iso_runit isomorphic_def left_adjoint_is_ide
<               runit_in_hom(2) hcomp_simps(1))
---
>           by (metis assms(3) iso_runit ideD(1) isomorphic_def left_adjoint_is_ide
>               runit_in_hom(2) src_hcomp)
2183c2185
<               using assms obj_is_self_adjoint by (unfold_locales, auto)
---
>               using assms obj_is_self_adjoint by unfold_locales auto
2223c2225
<           using mn by (metis assms(2) ideD(1) trg.preserves_reflects_arr trg_hcomp')
---
>           using mn by (metis assms(2) ideD(1) trg.preserves_reflects_arr trg_hcomp)
2451c2453
<             right_adjoint_simps(2) src_hcomp')
---
>             right_adjoint_simps(2) src_hcomp)
2474c2476
<         by (metis ideD(1) isomorphic_implies_hpar(1) isomorphic_implies_hpar(4) trg_hcomp')
---
>         by (metis ideD(1) isomorphic_implies_hpar(1) isomorphic_implies_hpar(4) trg_hcomp)
2531c2533
<       using is_ide rep_props by (unfold_locales, auto)
---
>       using is_ide rep_props by unfold_locales auto
2533c2535
<       using is_ide rep_props by (unfold_locales, auto)
---
>       using is_ide rep_props by unfold_locales auto
2575c2577
<         unfolding 1 using comp_assoc by simp
---
>         unfolding 1 using comp_assoc by presburger
2645c2647
<       using is_ide rep_props by (unfold_locales, auto)
---
>       using is_ide rep_props by unfold_locales auto
2647c2649
<       using is_ide rep_props by (unfold_locales, auto)
---
>       using is_ide rep_props by unfold_locales auto
2886c2888
<     using \<sigma>.tab_in_hom is_ide the_\<theta>_props by (unfold_locales, auto)
---
>     using \<sigma>.tab_in_hom is_ide the_\<theta>_props by unfold_locales auto
2910c2912
<     using is_ide rep_props by (unfold_locales, auto)
---
>     using is_ide rep_props by unfold_locales auto
2929c2931
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
2937c2939
<       using h_is_map by (unfold_locales, auto)
---
>       using h_is_map by unfold_locales auto
2939c2941
<       using k_is_map by (unfold_locales, auto)
---
>       using k_is_map by unfold_locales auto
2993,2994c2995
<       have "\<a>\<^sup>-\<^sup>1[k\<^sup>*, h, p\<^sub>0] \<cdot> k.trnl\<^sub>\<eta> p\<^sub>1 \<phi> =
<             \<a>\<^sup>-\<^sup>1[k\<^sup>*, h, p\<^sub>0] \<cdot> \<a>[k\<^sup>*, h, p\<^sub>0] \<cdot> tab"
---
>       have "\<a>\<^sup>-\<^sup>1[k\<^sup>*, h, p\<^sub>0] \<cdot> k.trnl\<^sub>\<eta> p\<^sub>1 \<phi> = \<a>\<^sup>-\<^sup>1[k\<^sup>*, h, p\<^sub>0] \<cdot> \<a>[k\<^sup>*, h, p\<^sub>0] \<cdot> tab"
3001c3002
<         using comp_assoc by simp
---
>         using comp_assoc by presburger
3020c3021
<         using assms(1-2) 0 trg_dom trg_cod hseqI' vconn_implies_hpar(4) by auto
---
>         using assms(1-2) 0 trg_dom trg_cod vconn_implies_hpar(4) by auto
3023c3024
<         by (metis ideD(1) leg1_simps(2) leg1_simps(3) p\<^sub>1_simps trg_hcomp' vconn_implies_hpar(4))
---
>         by (metis ideD(1) leg1_simps(2) leg1_simps(3) p\<^sub>1_simps trg_hcomp vconn_implies_hpar(4))
3026c3027
<         by (metis ideD(1) leg0_simps(2) leg1_simps(2) leg1_simps(3) src_hcomp'
---
>         by (metis ideD(1) leg0_simps(2) leg1_simps(2) leg1_simps(3) src_hcomp
3044c3045
<           using assms 1 k.antipar cospan \<chi> seqI' hseqI'
---
>           using assms 1 k.antipar cospan \<chi> seqI'
3051,3052c3052,3053
<              by (metis "4" cospan hcomp_simps(2-3) h.ide_left hseqI' ide_char in_homE k.antipar(2)
<                  k.ide_right)
---
>              by (metis "4" cospan hcomp_simps(2-3) h.ide_left hseqI' ide_char in_homE
>                  k.antipar(2) k.ide_right) 
3075c3076,3077
<           using assms 4 k.antipar cospan assoc'_naturality [of k "k\<^sup>*" "h \<star> \<theta>"] hseqI' by auto
---
>           using assms 4 k.antipar cospan assoc'_naturality [of k "k\<^sup>*" "h \<star> \<theta>"]
>           by fastforce
3077c3079
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3082,3083c3084
<             using assms 1 k.antipar cospan hseqI' interchange comp_arr_dom comp_cod_arr
<                   k.counit_in_hom
---
>             using assms 1 k.antipar cospan interchange comp_arr_dom comp_cod_arr
3090c3091
<             using assms 4 k.antipar cospan whisker_left comp_arr_dom comp_cod_arr hseqI'
---
>             using assms 4 k.antipar cospan whisker_left comp_arr_dom comp_cod_arr
3096c3097
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3102c3103
<             by (metis hcomp_simps(3-4) h.ide_left hseqI' ide_char in_homE trg_hcomp')
---
>             by (metis hcomp_simps(3-4) h.ide_left hseqI' ide_char in_homE trg_hcomp)
3104c3105
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3111c3112
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3135c3136
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
3143c3144
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3163c3164
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3187c3188
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3199c3200
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
3203,3204c3204
<                using assms k.antipar 0 comp_cod_arr
<                by (simp add: hseqI')
---
>                using assms k.antipar 0 comp_cod_arr by simp
3212c3212
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3240c3240
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3246c3246
<           using assms 0 k.antipar cospan comp_assoc hseqI' whisker_right by auto
---
>           using assms 0 k.antipar cospan comp_assoc whisker_right by auto
3291c3291
<         by auto
---
>         by force
3295c3295
<         using assms k.antipar cospan k.adjoint_transpose_left(4) assoc_in_hom by simp
---
>         using assms k.antipar cospan k.adjoint_transpose_left(4) assoc_in_hom by auto
3297c3297
<         using comp_assoc by simp
---
>         using comp_assoc by presburger
3348c3348
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3428,3430c3428
<               apply (intro comp_in_homI)
<                   apply auto
<               by auto
---
>               apply (intro comp_in_homI) by auto
3438,3440c3436
<               apply (intro comp_in_homI)
<                   apply auto
<               by auto
---
>               apply (intro comp_in_homI) by auto
3449,3450c3445
<           using assms k.antipar cospan tab_in_hom hseqI'
<           apply (intro seqI hseqI) by auto
---
>           using assms k.antipar cospan tab_in_hom by fastforce
3452,3453c3447
<           using assms \<beta> k.antipar cospan tab_in_hom hseqI'
<           apply (intro seqI hseqI) by auto
---
>           using assms \<beta> k.antipar cospan tab_in_hom by fastforce
3478c3472
<         using assms(1) by (unfold_locales, auto)
---
>         using assms(1) by unfold_locales auto
3480c3474
<         using assms(2) by (unfold_locales, auto)
---
>         using assms(2) by unfold_locales auto
3529c3523
<           by (unfold_locales, auto)
---
>           by unfold_locales auto
3533c3527
<           by (unfold_locales, auto)
---
>           by unfold_locales auto
3595c3589
<       interpret w': arrow_of_spans_of_maps V H \<a> \<i> src trg r\<^sub>0 "dom \<omega>" s\<^sub>0 s\<^sub>1 w'
---
>       interpret w': arrow_of_spans_of_maps V H \<a> \<i> src trg r\<^sub>0 \<open>dom \<omega>\<close> s\<^sub>0 s\<^sub>1 w'
3606c3600
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3612c3606
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3672c3666
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
3733c3727
<       using \<rho>.leg0_is_map \<sigma>.leg1_is_map composable by (unfold_locales, auto)
---
>       using \<rho>.leg0_is_map \<sigma>.leg1_is_map composable by unfold_locales auto
3781,3782c3775,3776
<             hseqI' composable
<       by (unfold tab_def, intro comp_in_homI, auto)
---
>             composable tab_def
>       by auto
3786c3780
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
3820c3814
<         by (unfold_locales, auto)
---
>         by unfold_locales auto
3825c3819
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3833c3827
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
3838c3832
<           using composable \<rho>.T0.antipar(1) hseqI' comp_assoc whisker_right by auto
---
>           using composable \<rho>.T0.antipar(1) comp_assoc whisker_right by auto
3844c3838
<                 composable hseqI' comp_assoc
---
>                 composable comp_assoc
3865c3859
<               by (intro seqI hseqI, auto simp add: hseqI')
---
>               by (intro seqI hseqI, auto)
3878c3872
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
3880,3881c3874
<               using \<rho>.T0.antipar(1) iso_inv_iso 1 hseqI'
<               by (intro seqI hseqI, auto)
---
>               using \<rho>.T0.antipar(1) iso_inv_iso 1 by fastforce
3890c3883
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3900c3893
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3912c3905
<             by (simp add: composable hseqI')
---
>             by (simp add: composable)
3914c3907
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3940c3933
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
3946c3939
<           using assms(3) arrI \<rho>.T0.antipar(1) hseqI' whisker_left by auto
---
>           using assms(3) arrI \<rho>.T0.antipar(1) whisker_left by auto
3951c3944
<           using \<rho>.T0.antipar(1) hseqI' comp_assoc whisker_left by auto
---
>           using \<rho>.T0.antipar(1) comp_assoc whisker_left by auto
3986,3987c3979
<             using u \<omega> hseqI'
<             by (intro comp_in_homI, auto)
---
>             using u \<omega> by fastforce
4013,4014c4005,4006
<            using w\<^sub>r\<theta>\<^sub>r\<nu>\<^sub>r
<            by (metis \<omega> 1 comp_arr_dom in_homE seqE hcomp_simps(1) vseq_implies_hpar(1))
---
>            using w\<^sub>r\<theta>\<^sub>r\<nu>\<^sub>r \<omega> 1 comp_arr_dom in_homE seqE hcomp_simps(1) vseq_implies_hpar(1)
>            by (metis src_hcomp)
4022c4014,4015
<           by (metis arr_cod in_hhom_def in_homE hcomp_simps(1-2))
---
>           by (metis \<open>src w\<^sub>r = src u\<close> \<sigma>.leg1_simps(4) arr_dom in_hhomI in_homE r\<^sub>0s\<^sub>1.cospan
>               src_hcomp trg_hcomp vconn_implies_hpar(1) vconn_implies_hpar(2))
4030,4031c4023,4024
<           by (metis \<rho>.leg1_simps(4) arr_cod arr_dom_iff_arr cod_trg in_hhomI in_homE
<               src_cod src_dom src_hcomp' trg.preserves_cod hcomp_simps(2) w\<^sub>r\<theta>\<^sub>r\<nu>\<^sub>r)
---
>           by (metis \<open>src w\<^sub>r = src u\<close> \<rho>.leg1_simps(4) arr_cod in_hhomI in_homE
>               src_hcomp trg_hcomp vconn_implies_hpar(3) vconn_implies_hpar(4))
4059c4052,4053
<           by (metis arr_dom in_homE src_dom hcomp_simps(1))
---
>           by (metis \<sigma>.leg0_simps(2) \<sigma>.tab_simps(2) \<theta>\<^sub>r_in_hom arrI hseqI' ideD(1) seqE
>               seq_if_composable src_hcomp vconn_implies_hpar(3))
4067c4061,4062
<           by (metis \<sigma>.leg0_simps(3) arr_dom in_hhom_def in_homE trg_dom hcomp_simps(2))
---
>           by (metis \<theta>\<^sub>r_in_hom arrI hseqE in_hhom_def seqE vconn_implies_hpar(1)
>               vconn_implies_hpar(3) w\<^sub>s\<theta>\<^sub>s\<nu>\<^sub>s)
4104,4105c4099
<           by (metis \<nu>\<^sub>s_in_hom \<open>src \<nu>\<^sub>s = src u\<close> in_homE seqE hcomp_simps(1) src_vcomp
<               vseq_implies_hpar(1))
---
>           by (metis \<nu>\<^sub>s_in_hom \<open>src \<nu>\<^sub>s = src u\<close> arrI seqE src_hcomp src_vcomp vseq_implies_hpar(1))
4156c4150
<             using w\<^sub>r\<theta>\<^sub>r\<nu>\<^sub>r hseqI' \<rho>.base_simps(2) composable by fastforce
---
>             using w\<^sub>r\<theta>\<^sub>r\<nu>\<^sub>r \<rho>.base_simps(2) composable by fastforce
4171c4165
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
4185c4179
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4222c4216
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4232,4235c4226
<               apply (intro seqI' comp_in_homI)
<                    apply auto
<                apply auto
<               by (intro hcomp_in_vhom, auto)
---
>               apply (intro seqI' comp_in_homI) by auto
4252c4243
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4266c4257
<                   trg_hcomp')
---
>                   trg_hcomp)
4269c4260
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4301c4292,4293
<                 using \<theta>_def \<theta> whisker_left by force
---
>                 using \<theta>_def \<theta> whisker_left
>                 by (metis (full_types) arrI cod_comp ide_base seqE seqI)
4305c4297
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4315c4307
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4322c4314
<             using r\<^sub>0s\<^sub>1.p\<^sub>1_simps w\<theta>\<^sub>t\<nu>\<^sub>t hseqI' whisker_left comp_assoc by force
---
>             using r\<^sub>0s\<^sub>1.p\<^sub>1_simps w\<theta>\<^sub>t\<nu>\<^sub>t whisker_left comp_assoc by force
4353c4345
<                 using \<open>trg w = src p\<^sub>0\<close> hseqI' by simp
---
>                 using \<open>trg w = src p\<^sub>0\<close> by simp
4355c4347
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
4358c4350
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4369c4361
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4380c4372
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4393c4385
<                 using ide_char w by presburger
---
>                 using ide_char w by blast
4395c4387
<                 using hseqI' assoc_naturality [of r "\<sigma> \<star> p\<^sub>0" w] composable by auto
---
>                 using assoc_naturality [of r "\<sigma> \<star> p\<^sub>0" w] composable by auto
4398c4390
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4408c4400
<               using w \<rho>.T0.antipar(1) composable hseqI' whisker_right by auto
---
>               using w \<rho>.T0.antipar(1) composable whisker_right by auto
4422c4414
<                   using comp_cod_arr by (simp add: composable hseqI')
---
>                   using comp_cod_arr by (simp add: composable)
4430c4422
<                   by (simp add: composable hseqI')
---
>                   by (simp add: composable)
4438c4430
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4442,4443c4434
<               using w \<rho>.T0.antipar(1) composable tab_in_hom hseqI' comp_assoc whisker_right
<               by auto
---
>               using w \<rho>.T0.antipar(1) composable comp_assoc whisker_right by auto
4449c4440
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4481c4472
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4508c4499
<           by (unfold_locales, auto)
---
>           by unfold_locales auto
4558,4559c4549
<           using \<rho>.T0.antipar(1) hseqI'
<           by (intro comp_in_homI hcomp_in_vhom, auto)
---
>           using \<rho>.T0.antipar(1) by fastforce
4564,4565c4554
<           using \<rho>.T0.antipar(1) hseqI'
<           by (intro comp_in_homI hcomp_in_vhom, auto)
---
>           using \<rho>.T0.antipar(1) by fastforce
4569,4570c4558
<           using \<rho>.T0.antipar(1)
<           by (intro comp_in_homI hcomp_in_vhom, auto)
---
>           using \<rho>.T0.antipar(1) by force
4609c4597
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4618c4606,4610
<                 using comp_cod_arr \<rho>.T0.antipar(1) \<beta> comp_assoc_assoc' by simp
---
>               proof -
>                 have "(\<a>\<^sup>-\<^sup>1[r\<^sub>1, p\<^sub>1, w'] \<cdot> \<a>[r\<^sub>1, p\<^sub>1, w']) \<cdot> \<beta> = \<beta>"
>                   using comp_cod_arr \<rho>.T0.antipar(1) \<beta> comp_assoc_assoc' by simp
>                 thus ?thesis by argo
>               qed
4621c4613
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
4634c4626
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
4707c4699
<                 using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) \<rho>.T0.antipar(1) hseqI' comp_assoc_assoc' by simp
---
>                 using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) \<rho>.T0.antipar(1) comp_assoc_assoc' by simp
4779,4780c4771
<                   using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) comp_assoc_assoc' comp_cod_arr
<                   by (simp add: hseqI')
---
>                   using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) comp_assoc_assoc' comp_cod_arr by simp
4800c4791
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
4860c4851
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
4887c4878
<                   by (metis hseqE hseqI' in_hhom_def uw\<theta>w'\<theta>'\<beta>.\<beta>_simps(1) src_hcomp'
---
>                   by (metis hseqE hseqI' in_hhom_def uw\<theta>w'\<theta>'\<beta>.\<beta>_simps(1) src_hcomp
4917c4908
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
4924c4915
<                         r\<^sub>0s\<^sub>1.base_simps(2) hcomp_in_vhomE in_homE trg_hcomp')
---
>                         r\<^sub>0s\<^sub>1.base_simps(2) hcomp_in_vhomE in_homE trg_hcomp)
4940c4931
<                       using comp_assoc by simp
---
>                       using comp_assoc by presburger
4956c4947,4948
<                       by auto
---
>                       by (metis \<sigma>.tab_simps(1) \<sigma>.tab_simps(4) hcomp_simps(4) in_homE
>                           r\<^sub>0s\<^sub>1.leg0_simps(5))
4960c4952,4953
<                       by auto
---
>                       by (metis \<sigma>.tab_simps(1) \<sigma>.tab_simps(5) hcomp_simps(3) in_homE
>                           r\<^sub>0s\<^sub>1.leg0_simps(4))
4965c4958
<                       using comp_assoc by simp
---
>                       using comp_assoc by presburger
4970c4963
<                     using \<gamma>' assoc_naturality [of s s\<^sub>0 "p\<^sub>0 \<star> \<gamma>'"] \<open>hseq p\<^sub>0 \<gamma>'\<close> by auto
---
>                     using \<gamma>' assoc_naturality [of s s\<^sub>0 "p\<^sub>0 \<star> \<gamma>'"] \<open>hseq p\<^sub>0 \<gamma>'\<close> by force
4974c4967
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
5017c5010
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
5034c5027
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
5069c5062
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
5086c5079
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
5094c5087
<                     using comp_assoc by simp
---
>                     using comp_assoc by presburger
5099c5092
<                     using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) \<rho>.T0.antipar(1) hseqI' comp_assoc_assoc'
---
>                     using r\<^sub>0s\<^sub>1.\<phi>_uniqueness(2) \<rho>.T0.antipar(1) comp_assoc_assoc'
5112c5105,5106
<                     by auto
---
>                     by (metis \<sigma>.ide_leg1 assoc'_simps(1) hseqE ideD(1) in_homE r\<^sub>0s\<^sub>1.ide_leg0
>                         r\<^sub>0s\<^sub>1.p\<^sub>0_simps w w\<^sub>s)
5550c5544
<                    B.trg_hcomp' calculation)
---
>                    B.trg_hcomp calculation)
5579c5573
<                    B.seq_if_composable B.src_dom B.src_hcomp' B.vseq_implies_hpar(1))
---
>                    B.seq_if_composable B.src_dom B.src_hcomp B.vseq_implies_hpar(1))
5612c5606,5607
<      notation comp  (infixr "\<odot>" 55)
---
>      abbreviation comp  (infixr "\<odot>" 55)
>      where "comp \<equiv> COMP"
5891c5886
<        by (simp add: assms)
---
>        by (simp add: assms B.obj_simps)
6059c6054
<          using assms comp_def seq_char null_char Comp_def
---
>          using assms seq_char null_char
6139c6134
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6141c6136
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6143c6138
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6255c6250
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6257c6252
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6259c6254
<            using 1 by (unfold_locales, auto)
---
>            using 1 by unfold_locales auto
6331,6335c6326,6327
<            apply (intro conjI B.in_hhomI)
<               apply auto
<             apply (metis B.ideD(1) B.isomorphic_implies_hpar(3) B.isomorphic_implies_ide(1)
<                          B.hcomp_simps(1))
<            by (metis B.hseqE B.ideD(1) B.isomorphic_implies_hpar(1))
---
>            by (metis B.hseqE B.ideD(1) B.in_hhom_def B.isomorphic_implies_hpar(3)
>                B.isomorphic_implies_ide(1) B.src_hcomp)
6456c6448
<       using \<rho>.leg0_is_map \<sigma>.leg1_is_map composable by (unfold_locales, auto)
---
>       using \<rho>.leg0_is_map \<sigma>.leg1_is_map composable by unfold_locales auto
6462c6454
<       have "Maps.arr (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
---
>       have "Maps.arr (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
6464c6456
<       moreover have "Maps.arr (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>)"
---
>       moreover have "Maps.arr (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>)"
6466,6467c6458,6459
<       moreover have "Maps.cod (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>) =
<                      Maps.cod (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
---
>       moreover have "Maps.cod (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>) =
>                      Maps.cod (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
6472,6473c6464,6465
<                        \<lbrakk>\<lbrakk>tab\<^sub>0 ((Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
<                               Maps.REP (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>))\<rbrakk>\<rbrakk> \<and>
---
>                        \<lbrakk>\<lbrakk>tab\<^sub>0 ((Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
>                               Maps.REP (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>))\<rbrakk>\<rbrakk> \<and>
6475,6476c6467,6468
<                        \<lbrakk>\<lbrakk>tab\<^sub>1 ((Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
<                               Maps.REP (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>))\<rbrakk>\<rbrakk>"
---
>                        \<lbrakk>\<lbrakk>tab\<^sub>1 ((Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
>                               Maps.REP (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>))\<rbrakk>\<rbrakk>"
6479,6480c6471,6472
<       moreover have "r\<^sub>0\<^sup>* \<star> s\<^sub>1 \<cong> (Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
<                                 Maps.REP (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
---
>       moreover have "r\<^sub>0\<^sup>* \<star> s\<^sub>1 \<cong> (Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* \<star>
>                                 Maps.REP (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
6482c6474
<         have "r\<^sub>0 \<cong> Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>)"
---
>         have "r\<^sub>0 \<cong> Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>)"
6484c6476
<         hence 3: "isomorphic r\<^sub>0\<^sup>* (Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>*"
---
>         hence 3: "isomorphic r\<^sub>0\<^sup>* (Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>*"
6487c6479
<         moreover have 4: "s\<^sub>1 \<cong> Maps.REP (MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
---
>         moreover have 4: "s\<^sub>1 \<cong> Maps.REP (Maps.MkArr (src s\<^sub>0) (trg s) \<lbrakk>s\<^sub>1\<rbrakk>)"
6492c6484
<             using \<rho>.T0.antipar(2) r\<^sub>0s\<^sub>1.cospan by presburger
---
>             using \<rho>.T0.antipar(2) r\<^sub>0s\<^sub>1.cospan by argo
6495c6487
<           have "src (Maps.REP (MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* = trg s\<^sub>1"
---
>           have "src (Maps.REP (Maps.MkArr (src r\<^sub>0) (trg s) \<lbrakk>r\<^sub>0\<rbrakk>))\<^sup>* = trg s\<^sub>1"
6675c6667
<         using in_hom hseqI' \<rho>.leg0_in_hom(2) \<rho>.tab_in_vhom' by auto
---
>         using in_hom \<rho>.leg0_in_hom(2) \<rho>.tab_in_vhom' by auto
6739c6731
<           using w in_hom hseqI' by auto
---
>           using w in_hom by auto
6799c6791
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
6822c6814
<         using assms in_hom hseqI' by auto
---
>         using assms in_hom by auto
6837,6843c6829,6831
<           proof -
<             have "\<guillemotleft>w.the_\<theta> \<cdot> (s\<^sub>0 \<star> inv \<phi>) : s\<^sub>0 \<star> w' \<Rightarrow> r\<^sub>0\<guillemotright>"
<               using \<phi> w.the_\<theta>_props \<sigma>.leg0_in_hom(2) assms(2) comp_in_hom_simp' hcomp_in_vhom
<                     inv_in_hom isomorphic_implies_hpar(4) w.the_\<theta>_simps(4) w.w_simps(4)
<               by presburger
<             thus ?thesis by auto
<           qed
---
>             using \<phi> w.the_\<theta>_props \<sigma>.leg0_in_hom(2) assms(2) comp_in_homI hcomp_in_vhom
>                   inv_in_hom isomorphic_implies_hpar(4) w.the_\<theta>_simps(4) w.w_simps(4)
>             by metis
6856c6844
<             using in_hom hseqI' by auto
---
>             by auto
6862c6850
<           using w'.arrow_of_spans_of_maps_axioms in_hom hseqI' by auto
---
>           using w'.arrow_of_spans_of_maps_axioms by auto
6891c6879
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
7020c7008
<       using in_hom by (unfold_locales, auto)
---
>       using in_hom by unfold_locales auto
7044c7032
<           unfolding r.T0.trnr\<^sub>\<epsilon>_def using comp_assoc by simp
---
>           unfolding r.T0.trnr\<^sub>\<epsilon>_def using comp_assoc by presburger
7063c7051
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
7070c7058
<             using \<mu> assoc_naturality [of \<mu> "tab\<^sub>0 r" "(tab\<^sub>0 r)\<^sup>*"] hseqI'
---
>             using \<mu> assoc_naturality [of \<mu> "tab\<^sub>0 r" "(tab\<^sub>0 r)\<^sup>*"]
7074c7062
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
7078c7066
<           using \<mu> whisker_right hseqI' \<Delta>_simps(1) by auto
---
>           using \<mu> whisker_right \<Delta>_simps(1) by auto
7168c7156
<             using \<theta> by auto
---
>             using \<theta> by blast
7170,7171c7158,7162
<             using \<nu> \<mu>.the_\<nu>_props \<mu>.the_\<theta>_props \<pi>.the_\<nu>_props \<pi>.the_\<theta>_props hseqI' isos_compose
<             by auto
---
>             using \<nu> \<mu>.the_\<nu>_props \<mu>.the_\<theta>_props \<pi>.the_\<nu>_props \<pi>.the_\<theta>_props
>                   isos_compose [of "\<mu>.the_\<nu>" "\<pi>.the_\<nu>"] \<mu>.is_ide \<nu> \<open>ide (\<pi>.chine \<star> \<mu>.chine)\<close>
>                   \<pi>.uw\<theta> \<pi>.w_simps(4) \<tau>.ide_leg1 \<tau>.leg1_simps(3) arrI hseq_char ideD(1)
>                   ide_is_iso iso_assoc iso_hcomp isos_compose seqE
>             by metis
7195c7186
<                 by auto
---
>                 by (metis in_homE)
7199c7190
<                 by auto
---
>                 by (metis in_homE)
7203c7194
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
7210c7201
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
7225c7216
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7251c7242
<                   using A f g pentagon hseqI' invert_side_of_triangle(1)
---
>                   using A f g pentagon invert_side_of_triangle(1)
7255c7246
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
7276c7267
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7357,7358c7348,7349
<       using \<rho>\<sigma>.composable \<omega>.in_hom \<chi>.in_hom hseqI'
<       by (unfold_locales, auto)
---
>       using \<rho>\<sigma>.composable \<omega>.in_hom \<chi>.in_hom
>       by unfold_locales auto
7432,7433c7423
<         apply (intro comp_in_homI, auto)
<         by (intro hcomp_in_vhom, auto)
---
>         by (intro comp_in_homI, auto)
7491c7481
<                   trg_hcomp' \<tau>.base_in_hom(2) hcomp_in_vhom
---
>                   trg_hcomp \<tau>.base_in_hom(2) hcomp_in_vhom
7512c7502
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
7526c7516
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7540c7530
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7565c7555
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7578c7568
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7593c7583
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7601c7591
<               using hseqI' \<chi>.in_hom whisker_left by auto
---
>               using \<chi>.in_hom whisker_left by auto
7607c7597
<                 using hseqI' \<chi>.in_hom
---
>                 using \<chi>.in_hom
7621c7611
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7645c7635
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7651c7641
<             using whisker_left \<rho>.T0.antipar(1) \<rho>\<sigma>.composable \<chi>.in_hom hseqI' comp_assoc by auto
---
>             using whisker_left \<rho>.T0.antipar(1) \<rho>\<sigma>.composable \<chi>.in_hom comp_assoc by auto
7660,7662c7650
<                 using \<omega>.in_hom \<chi>.in_hom hseqI'
<                 apply (intro comp_in_homI hcomp_in_vhom, auto)
<                 by auto
---
>                 using \<omega>.in_hom \<chi>.in_hom by force
7668c7656
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7678,7685c7666
<                 using \<chi>.in_hom hseqI'
<                 apply (intro seqI hseqI, auto)
<               proof - 
<                 show "\<guillemotleft>\<chi> : src u \<rightarrow> trg \<chi>\<guillemotright>"
<                   using \<chi>.in_hom by auto
<                 show "dom (\<chi> \<star> s\<^sub>0 \<star> \<rho>\<sigma>.p\<^sub>0) = s \<star> s\<^sub>0 \<star> \<rho>\<sigma>.p\<^sub>0"
<                   using \<chi>.in_hom hseqI' in_hom by fastforce
<               qed
---
>                 using \<chi>.in_hom by force
7687c7668
<                using comp_arr_dom comp_cod_arr \<omega>.in_hom \<chi>.in_hom hseqI' interchange
---
>                using comp_arr_dom comp_cod_arr \<omega>.in_hom \<chi>.in_hom interchange
7691c7672
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7703c7684
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7706c7687
<             using whisker_left hseqI' \<rho>\<sigma>.tab_def comp_assoc by simp
---
>             using whisker_left \<rho>\<sigma>.tab_def comp_assoc by simp
7735c7716
<               using comp_cod_arr hseqI' \<rho>.T0.antipar(1) by simp
---
>               using comp_cod_arr \<rho>.T0.antipar(1) by simp
7775c7756
<               using \<theta>\<^sub>\<tau>' whisker_left hseqI' \<rho>.T0.antipar(1) seqE \<tau>.ide_base by presburger
---
>               using whisker_left \<rho>.T0.antipar(1) \<tau>.ide_base by presburger
7777c7758
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7797c7778
<                   \<tau>\<mu>.leg1_simps(2) hseqE src_hcomp' t\<^sub>0u\<^sub>1.leg1_simps(3,5-6) w_simps(2)
---
>                   \<tau>\<mu>.leg1_simps(2) hseqE src_hcomp t\<^sub>0u\<^sub>1.leg1_simps(3,5-6) w_simps(2)
7800c7781
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7811c7792
<               using pentagon t\<^sub>0u\<^sub>1.p\<^sub>1_simps uw\<theta> \<tau>.T0.antipar(1) hseqI' iso_hcomp
---
>               using pentagon t\<^sub>0u\<^sub>1.p\<^sub>1_simps uw\<theta> \<tau>.T0.antipar(1) iso_hcomp
7819c7800
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7831c7812
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7842c7823
<               by (simp add: \<tau>\<mu>.composable hseqI')
---
>               by (simp add: \<tau>\<mu>.composable)
7844c7825
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7857c7838
<                     \<tau>\<mu>.composable hseqI' comp_assoc_assoc'
---
>                     \<tau>\<mu>.composable comp_assoc_assoc'
7860c7841
<               using comp_cod_arr \<tau>\<mu>.composable hseqI' by simp
---
>               using comp_cod_arr \<tau>\<mu>.composable by simp
7879c7860
<               using comp_inv_arr' comp_cod_arr \<tau>\<mu>.composable hseqI' comp_assoc_assoc'
---
>               using comp_inv_arr' comp_cod_arr \<tau>\<mu>.composable comp_assoc_assoc'
7892c7873
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
7904c7885
<               using uw\<theta> whisker_right [of chine] hseqI'
---
>               using uw\<theta> whisker_right [of chine]
7907c7888
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
7940c7921
<                 monoE hseqI' \<tau>\<mu>.composable comp_assoc
---
>                 monoE \<tau>\<mu>.composable comp_assoc
7946c7927
<           using epiE LHS RHS iso_is_retraction retraction_is_epi hseqI' \<tau>\<mu>.composable
---
>           using epiE LHS RHS iso_is_retraction retraction_is_epi \<tau>\<mu>.composable
7998c7979
<           using LHS_def RHS_def eq by presburger
---
>           using LHS_def RHS_def eq by argo
8034c8015
<                     trg_hcomp' ide_in_hom(2) \<tau>.T2
---
>                     trg_hcomp ide_in_hom(2) \<tau>.T2
8070c8051
<                 using LHS_def RHS_def \<gamma>\<^sub>\<tau> \<gamma>\<^sub>\<tau>' eq eq' by presburger
---
>                 using LHS_def RHS_def \<gamma>\<^sub>\<tau> \<gamma>\<^sub>\<tau>' eq eq' by argo
8077c8058
<                     trg_hcomp' ide_in_hom(2) \<tau>.T2 \<tau>.T0.antipar(1) t\<^sub>0u\<^sub>1.base_simps(2)
---
>                     trg_hcomp ide_in_hom(2) \<tau>.T2 \<tau>.T0.antipar(1) t\<^sub>0u\<^sub>1.base_simps(2)
8153c8134
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
8165c8146
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
8177,8178c8158
<               using hseqI'
<               by (intro seqI hseqI, auto)
---
>               by auto
8182c8162
<               using hseqI' by simp
---
>               by simp
8200c8180
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
8214c8194
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
8228c8208
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
8247c8227
<               using comp_inv_arr' comp_cod_arr hseqI' by auto
---
>               using comp_inv_arr' comp_cod_arr by auto
8257,8258c8237
<               using hseqI' \<chi>.\<theta>_simps(3)
<               by (intro seqI hseqI, auto)
---
>               using \<chi>.\<theta>_simps(3) by simp
8262c8241
<               using whisker_right hseqI' by simp
---
>               using whisker_right by simp
8270c8249
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
8275c8254
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
8295c8274
<                 using comp_inv_arr' hseqI' \<tau>.T0.antipar(1) by auto
---
>                 using comp_inv_arr' \<tau>.T0.antipar(1) by auto
8297c8276
<                 using comp_cod_arr hseqI' t\<^sub>0u\<^sub>1.\<phi>_uniqueness by simp
---
>                 using comp_cod_arr t\<^sub>0u\<^sub>1.\<phi>_uniqueness by simp
8301c8280
<                 using comp_arr_inv' \<tau>.T0.antipar(1) hseqI' t\<^sub>0u\<^sub>1.\<phi>_uniqueness by simp
---
>                 using comp_arr_inv' \<tau>.T0.antipar(1) t\<^sub>0u\<^sub>1.\<phi>_uniqueness by simp
8303c8282
<                 using comp_cod_arr \<tau>.T0.antipar(1) hseqI' by simp
---
>                 using comp_cod_arr \<tau>.T0.antipar(1) by simp
8319c8298
<                   ide_hcomp hseqI' hcomp_simps(1) t\<^sub>0u\<^sub>1.ide_u
---
>                   ide_hcomp hcomp_simps(1) t\<^sub>0u\<^sub>1.ide_u
8337c8316
<          MkArr (src (\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1)) (src t) (Maps.Comp \<lbrakk>t\<^sub>0\<rbrakk> \<lbrakk>\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1\<rbrakk>)"
---
>          Maps.MkArr (src (\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1)) (src t) (Maps.Comp \<lbrakk>t\<^sub>0\<rbrakk> \<lbrakk>\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1\<rbrakk>)"
8350c8329
<             MkArr (src (\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1)) (src t) (Maps.Comp \<lbrakk>t\<^sub>0\<rbrakk> \<lbrakk>\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1\<rbrakk>)"
---
>             Maps.MkArr (src (\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1)) (src t) (Maps.Comp \<lbrakk>t\<^sub>0\<rbrakk> \<lbrakk>\<omega>.chine \<star> \<rho>\<sigma>.p\<^sub>1\<rbrakk>)"
8357c8336
<          MkArr (src r\<^sub>0s\<^sub>1.p\<^sub>0) (trg u) (Maps.Comp \<lbrakk>u\<^sub>1\<rbrakk> \<lbrakk>\<chi>.chine \<star> r\<^sub>0s\<^sub>1.p\<^sub>0\<rbrakk>)"
---
>          Maps.MkArr (src r\<^sub>0s\<^sub>1.p\<^sub>0) (trg u) (Maps.Comp \<lbrakk>u\<^sub>1\<rbrakk> \<lbrakk>\<chi>.chine \<star> r\<^sub>0s\<^sub>1.p\<^sub>0\<rbrakk>)"
8370c8349
<             MkArr (src r\<^sub>0s\<^sub>1.p\<^sub>0) (trg u) (Maps.Comp \<lbrakk>u\<^sub>1\<rbrakk> \<lbrakk>\<chi>.chine \<star> r\<^sub>0s\<^sub>1.p\<^sub>0\<rbrakk>)"
---
>             Maps.MkArr (src r\<^sub>0s\<^sub>1.p\<^sub>0) (trg u) (Maps.Comp \<lbrakk>u\<^sub>1\<rbrakk> \<lbrakk>\<chi>.chine \<star> r\<^sub>0s\<^sub>1.p\<^sub>0\<rbrakk>)"
8527c8506
<         using assms by (unfold_locales, auto)
---
>         using assms by unfold_locales auto
8546c8525
<         using assms by (unfold_locales, auto)
---
>         using assms by unfold_locales auto
8592c8571
<         using assms by (unfold_locales, auto)
---
>         using assms by unfold_locales auto
8619c8598
<         using assms by (unfold_locales, auto)
---
>         using assms by unfold_locales auto
8687c8666
<           using assms by (unfold_locales, auto)
---
>           using assms by unfold_locales auto
8697c8676
<       interpret Cod: span_in_category Maps.comp "Cod (SPN \<mu>)"
---
>       interpret Cod: span_in_category Maps.comp \<open>Cod (SPN \<mu>)\<close>
8700c8679
<           using assms by (unfold_locales, auto)
---
>           using assms by unfold_locales auto
8741c8720
<         have 1: "Maps.arr (MkArr (src (tab\<^sub>0 (dom \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (dom \<mu>)\<rbrakk>)"
---
>         have 1: "Maps.arr (Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (dom \<mu>)\<rbrakk>)"
8769c8748
<         have 1: "Maps.arr (MkArr (src (tab\<^sub>0 (cod \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (cod \<mu>)\<rbrakk>)"
---
>         have 1: "Maps.arr (Maps.MkArr (src (tab\<^sub>0 (cod \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (cod \<mu>)\<rbrakk>)"
8858,8859c8837,8838
<                 MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk> \<odot>
<                   MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>"
---
>                 Maps.MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk> \<odot>
>                   Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>"
8864,8865c8843,8844
<           also have "... = MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<nu>)))
<                                  (Maps.Comp \<lbrakk>spn \<nu>\<rbrakk> \<lbrakk>spn \<mu>\<rbrakk>)"
---
>           also have "... = Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<nu>)))
>                                       (Maps.Comp \<lbrakk>spn \<nu>\<rbrakk> \<lbrakk>spn \<mu>\<rbrakk>)"
8867,8868c8846,8847
<             have "Maps.seq (MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>)
<                            (MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>)"
---
>             have "Maps.seq (Maps.MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>)
>                            (Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>)"
8870c8849
<               show "Maps.in_hom (MkArr (src (tab\<^sub>0 (local.dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>)
---
>               show "Maps.in_hom (Maps.MkArr (src (tab\<^sub>0 (local.dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>)
8884c8863
<               show "Maps.in_hom (MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>)
---
>               show "Maps.in_hom (Maps.MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>)
8901,8902c8880,8881
<                      [of "MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>"
<                          "MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>"]
---
>                      [of "Maps.MkArr (src (tab\<^sub>0 (cod \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn \<nu>\<rbrakk>"
>                          "Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<mu>))) \<lbrakk>spn \<mu>\<rbrakk>"]
8905c8884
<           also have "... = MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn (\<nu> \<cdot> \<mu>)\<rbrakk>"
---
>           also have "... = Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src (tab\<^sub>0 (cod \<nu>))) \<lbrakk>spn (\<nu> \<cdot> \<mu>)\<rbrakk>"
8930c8909
<           using \<mu> by (unfold_locales, auto)
---
>           using \<mu> by unfold_locales auto
8939c8918
<         let ?tab\<^sub>0 = "MkArr (src (tab\<^sub>0 (src \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (src \<mu>)\<rbrakk>"
---
>         let ?tab\<^sub>0 = "Maps.MkArr (src (tab\<^sub>0 (src \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (src \<mu>)\<rbrakk>"
8945c8924
<         let ?tab\<^sub>1 = "MkArr (src (tab\<^sub>0 (src \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>1 (src \<mu>)\<rbrakk>"
---
>         let ?tab\<^sub>1 = "Maps.MkArr (src (tab\<^sub>0 (src \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>1 (src \<mu>)\<rbrakk>"
8972c8951
<                        \<lparr>Chn = MkArr (src (tab\<^sub>0 (src \<mu>))) (src (tab\<^sub>0 (src \<mu>))) \<lbrakk>spn (src \<mu>)\<rbrakk>,
---
>                        \<lparr>Chn = Maps.MkArr (src (tab\<^sub>0 (src \<mu>))) (src (tab\<^sub>0 (src \<mu>))) \<lbrakk>spn (src \<mu>)\<rbrakk>,
8984c8963
<           let ?tab\<^sub>0_dom = "MkArr (src (tab\<^sub>0 (dom \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (dom \<mu>)\<rbrakk>"
---
>           let ?tab\<^sub>0_dom = "Maps.MkArr (src (tab\<^sub>0 (dom \<mu>))) (src \<mu>) \<lbrakk>tab\<^sub>0 (dom \<mu>)\<rbrakk>"
9074c9053
<           using \<mu> by (unfold_locales, auto)
---
>           using \<mu> by unfold_locales auto
9078c9057
<         let ?tab\<^sub>0 = "MkArr (src (tab\<^sub>0 (trg \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>0 (trg \<mu>)\<rbrakk>"
---
>         let ?tab\<^sub>0 = "Maps.MkArr (src (tab\<^sub>0 (trg \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>0 (trg \<mu>)\<rbrakk>"
9084c9063
<         let ?tab\<^sub>1 = "MkArr (src (tab\<^sub>0 (trg \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>1 (trg \<mu>)\<rbrakk>"
---
>         let ?tab\<^sub>1 = "Maps.MkArr (src (tab\<^sub>0 (trg \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>1 (trg \<mu>)\<rbrakk>"
9125c9104
<                        \<lparr>Chn = MkArr (src (tab\<^sub>1 (trg \<mu>))) (src (tab\<^sub>1 (trg \<mu>))) \<lbrakk>spn (trg \<mu>)\<rbrakk>,
---
>                        \<lparr>Chn = Maps.MkArr (src (tab\<^sub>1 (trg \<mu>))) (src (tab\<^sub>1 (trg \<mu>))) \<lbrakk>spn (trg \<mu>)\<rbrakk>,
9136c9115
<           let ?tab\<^sub>1_dom = "MkArr (src (tab\<^sub>1 (dom \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>1 (dom \<mu>)\<rbrakk>"
---
>           let ?tab\<^sub>1_dom = "Maps.MkArr (src (tab\<^sub>1 (dom \<mu>))) (trg \<mu>) \<lbrakk>tab\<^sub>1 (dom \<mu>)\<rbrakk>"
9269c9248
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
9276c9255
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
9289c9268
<       using composable by (unfold_locales, auto)
---
>       using composable by unfold_locales auto
9306c9285
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
9431c9410
<       moreover have "SPN_r_SPN_s.leg0 \<noteq> Null"
---
>       moreover have "SPN_r_SPN_s.leg0 \<noteq> Maps.Null"
9494,9497c9473,9474
<             using Maps.PRJ\<^sub>0_def Maps.CLS_in_hom Maps.dom_char composable Span.hcomp_def
<                   \<rho>\<sigma>.tab_in_hom s.leg0_is_map s.leg1_is_map Maps.span_prj
<                   r.satisfies_T0 s.satisfies_T0
<                   Maps.Dom.simps(1) RS_simps(1) RS_simps(16) RS_simps(18) RS_simps(3)
---
>             using Maps.PRJ\<^sub>0_def composable Maps.Dom.simps(1) RS_simps(1) RS_simps(16)
>                   RS_simps(18) RS_simps(3)
9561c9538
<     shows "Maps.in_hom (MkArr (src \<rho>\<sigma>.tab) (src tab) \<lbrakk>cmp\<rbrakk>)
---
>     shows "Maps.in_hom (Maps.MkArr (src \<rho>\<sigma>.tab) (src tab) \<lbrakk>cmp\<rbrakk>)
9565c9542
<       show "Maps.in_hom (MkArr (src \<rho>\<sigma>.tab) (src tab) \<lbrakk>cmp\<rbrakk>)
---
>       show "Maps.in_hom (Maps.MkArr (src \<rho>\<sigma>.tab) (src tab) \<lbrakk>cmp\<rbrakk>)
9695,9701d9671
< (*
<       interpret rs: identity_arrow_of_tabulations_in_maps V H \<a> \<i> src trg
<                       \<open>r \<star> s\<close> \<open>tab_of_ide (r \<star> s)\<close> \<open>tab\<^sub>0 (r \<star> s)\<close> \<open>tab\<^sub>1 (r \<star> s)\<close>
<                       \<open>r \<star> s\<close> \<open>tab_of_ide (r \<star> s)\<close> \<open>tab\<^sub>0 (r \<star> s)\<close> \<open>tab\<^sub>1 (r \<star> s)\<close>
<                       \<open>r \<star> s\<close>
<         apply unfold_locales by auto
< *)
9706c9676
<         by (unfold_locales, auto)
---
>         by unfold_locales auto
9733c9703
<           by (metis rs.base_simps(2) rs.leg1_in_hom(1) rs.leg1_is_map trg_hcomp')
---
>           by (metis rs.base_simps(2) rs.leg1_in_hom(1) rs.leg1_is_map trg_hcomp)
9736c9706
<           by (unfold_locales, auto)
---
>           by unfold_locales auto
9909c9879
<         using assms by (unfold_locales, auto)
---
>         using assms by unfold_locales auto
9980c9950
<               using \<mu>\<nu> VV.ide_char VV.arr_char by (unfold_locales, auto)
---
>               using \<mu>\<nu> VV.ide_char VV.arr_char by unfold_locales auto
9983c9953
<               using \<mu>\<nu> VV.ide_char VV.arr_char by (unfold_locales, auto)
---
>               using \<mu>\<nu> VV.ide_char VV.arr_char by unfold_locales auto
9991c9961
<               using \<mu>\<nu> VV.arr_char by (unfold_locales, auto)
---
>               using \<mu>\<nu> VV.arr_char by unfold_locales auto
10002c9972
<               using \<mu>\<nu> by (unfold_locales, auto)
---
>               using \<mu>\<nu> by unfold_locales auto
10018,10021c9988,9991
<                "Chn ?RHS = MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>))) (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
<                                  \<lbrakk>\<mu>\<nu>.chine\<rbrakk> \<odot>
<                            MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
<                                  \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"
---
>                "Chn ?RHS = Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>))) (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
>                                       \<lbrakk>\<mu>\<nu>.chine\<rbrakk> \<odot>
>                            Maps.MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
>                                       \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"
10024,10025c9994,9995
<                                MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
<                                      \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"
---
>                                Maps.MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
>                                           \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"
10029,10031c9999,10001
<                              MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
<                                    (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
<                                    \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
---
>                              Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
>                                         (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
>                                         \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
10034,10036c10004,10006
<                       MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
<                             (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
<                             \<lbrakk>spn ?\<mu>\<nu>\<rbrakk>"
---
>                       Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
>                                  (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
>                                  \<lbrakk>spn ?\<mu>\<nu>\<rbrakk>"
10038,10040c10008,10010
<                 also have "... = MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
<                                        (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
<                                        \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
---
>                 also have "... = Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
>                                             (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
>                                             \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
10048c10018
<                 "MkArr (src cod_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (cod ?\<mu> \<star> cod ?\<nu>)))
---
>                 "Maps.MkArr (src cod_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (cod ?\<mu> \<star> cod ?\<nu>)))
10052c10022
<                 "MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>))) (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
---
>                 "Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>))) (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
10054c10024
<                  MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
---
>                  Maps.MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0) (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
10078c10048
<                 have 3: "Maps.Dom ?Chn_LHS = Maps.Dom (Maps.dom ?Chn_LHS)"
---
>                 have "Maps.Dom ?Chn_LHS = Maps.Dom (Maps.dom ?Chn_LHS)"
10139,10144c10109,10114
<                             [of "MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
<                                        (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
<                                        \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
<                                 "MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0)
<                                        (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
<                                        \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"]
---
>                             [of "Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu> \<star> dom ?\<nu>)))
>                                             (src (tab\<^sub>0 (cod ?\<mu> \<star> cod ?\<nu>)))
>                                             \<lbrakk>\<mu>\<nu>.chine\<rbrakk>"
>                                 "Maps.MkArr (src dom_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0)
>                                             (src (tab_of_ide (dom ?\<mu> \<star> dom ?\<nu>)))
>                                             \<lbrakk>dom_\<mu>_\<nu>.cmp\<rbrakk>"]
10201,10203c10171,10173
<                               [of "MkArr (src cod_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0)
<                                          (src (tab_of_ide (cod ?\<mu> \<star> cod ?\<nu>)))
<                                          \<lbrakk>cod_\<mu>_\<nu>.cmp\<rbrakk>"
---
>                               [of "Maps.MkArr (src cod_\<mu>_\<nu>.\<rho>\<sigma>.p\<^sub>0)
>                                               (src (tab_of_ide (cod ?\<mu> \<star> cod ?\<nu>)))
>                                               \<lbrakk>cod_\<mu>_\<nu>.cmp\<rbrakk>"
10214,10215c10184,10185
<                               (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
<                               (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
---
>                               (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
>                               (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
10218,10219c10188,10189
<                               (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
<                               (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
---
>                               (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
>                               (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
10227,10232c10197,10202
<                                 (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
<                                 (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
<                               \<lbrakk>\<lbrakk>tab\<^sub>0 ((Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
<                                                        \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
<                                       Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
<                                                       \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>))\<rbrakk>\<rbrakk>"
---
>                                 (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
>                                 (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
>                               \<lbrakk>\<lbrakk>tab\<^sub>0 ((Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
>                                                            \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
>                                       Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
>                                                            \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>))\<rbrakk>\<rbrakk>"
10240,10245c10210,10215
<                                 (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
<                                 (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
<                               \<lbrakk>\<lbrakk>tab\<^sub>1 ((Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
<                                                       \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
<                                      Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
<                                                      \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>))\<rbrakk>\<rbrakk>"
---
>                                 (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>)
>                                 (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>) \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) =
>                               \<lbrakk>\<lbrakk>tab\<^sub>1 ((Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
>                                                            \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
>                                      Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
>                                                           \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>))\<rbrakk>\<rbrakk>"
10252,10255c10222,10225
<                         have "(Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
<                                                \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
<                               Maps.REP (MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
<                                               \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) \<cong>
---
>                         have "(Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<mu>))) (trg (snd \<mu>\<nu>))
>                                                     \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk>))\<^sup>* \<star>
>                               Maps.REP (Maps.MkArr (src (tab\<^sub>0 (dom ?\<nu>))) (trg ?\<nu>)
>                                                    \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk>) \<cong>
10257,10270c10227,10230
<                         proof -
<                           have "MkArr (src (tab\<^sub>0 (dom (fst \<mu>\<nu>)))) (trg (snd \<mu>\<nu>)) \<lbrakk>tab\<^sub>0 (dom ?\<mu>)\<rbrakk> =
<                                 dom_\<mu>_\<nu>.R\<^sub>0"
<                             using VV.arr_char \<mu>\<nu> dom_\<mu>_\<nu>.R\<^sub>0_def by simp
<                           moreover have "MkArr (src (tab\<^sub>0 (dom (snd \<mu>\<nu>)))) (trg (snd \<mu>\<nu>))
<                                                \<lbrakk>tab\<^sub>1 (dom ?\<nu>)\<rbrakk> =
<                                 dom_\<mu>_\<nu>.S\<^sub>1"
<                             using VV.arr_char \<mu>\<nu> dom_\<mu>_\<nu>.S\<^sub>1_def dom_\<mu>_\<nu>.s.leg1_simps(3)
<                                   dom_\<mu>_\<nu>.s.leg1_simps(4) trg_dom
<                             by presburger
<                           ultimately show ?thesis
<                             using dom_\<mu>_\<nu>.prj_tab_agreement(1) isomorphic_symmetric
<                             by presburger
<                         qed
---
>                           using VV.arr_char \<mu>\<nu> dom_\<mu>_\<nu>.S\<^sub>1_def dom_\<mu>_\<nu>.s.leg1_simps(3)
>                                 dom_\<mu>_\<nu>.s.leg1_simps(4) trg_dom dom_\<mu>_\<nu>.R\<^sub>0_def
>                                 dom_\<mu>_\<nu>.prj_tab_agreement(1) isomorphic_symmetric
>                           by simp
10382c10342
<                       by (unfold_locales, auto)
---
>                       by unfold_locales auto
10400c10360
<                        by (unfold_locales, auto)
---
>                        by unfold_locales auto
10499c10459
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10501c10461
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10503c10463
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10505c10465
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10508c10468
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10514c10474
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10523c10483
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
10528c10488
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
10534c10494
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10540c10500
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10544c10504
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10556c10516
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10584c10544
<       using fg gh by (unfold_locales, auto)
---
>       using fg gh by unfold_locales auto
10604c10564
<         using fg gh by (unfold_locales, auto)
---
>         using fg gh by unfold_locales auto
11043c11003
<               TfTgh_TfTgh.u_in_hom 1 in_hhomE prj_char(4) src_hcomp')
---
>               TfTgh_TfTgh.u_in_hom 1 in_hhomE prj_char(4) src_hcomp)
11089,11090c11049,11050
<                          \<open>\<lparr>Leg0 = MkArr (src (tab\<^sub>0 f)) (trg g) \<lbrakk>tab\<^sub>0 f\<rbrakk>,
<                            Leg1 = MkArr (src (tab\<^sub>0 f)) (trg f) \<lbrakk>tab\<^sub>1 f\<rbrakk>\<rparr>\<close>
---
>                          \<open>\<lparr>Leg0 = Maps.MkArr (src (tab\<^sub>0 f)) (trg g) \<lbrakk>tab\<^sub>0 f\<rbrakk>,
>                            Leg1 = Maps.MkArr (src (tab\<^sub>0 f)) (trg f) \<lbrakk>tab\<^sub>1 f\<rbrakk>\<rparr>\<close>
11148c11108
<       using gh by (unfold_locales, auto)
---
>       using gh by unfold_locales auto
11150c11110
<       using fg by (unfold_locales, auto)
---
>       using fg by unfold_locales auto
11154c11114
<       by (unfold_locales, auto)
---
>       by unfold_locales auto
11174c11134,11135
<         using invert_side_of_triangle(1)
---
>         using TTfgh_TfTgh.\<Delta>_simps(1)
>               invert_side_of_triangle(1)
11177,11178c11138
<               TTfgh_TfTgh.\<Delta>_simps(1) (* TODO: Must go last? Why? *)
<         by presburger
---
>         by argo
11397c11357
<             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps Tgh.composable hseqI' whisker_left comp_assoc
---
>             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps Tgh.composable whisker_left comp_assoc
11417c11377
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_cod_arr comp_assoc_assoc' by simp
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_cod_arr comp_assoc_assoc' by simp
11434c11394
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
11448c11408
<             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_assoc
---
>             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_assoc
11464c11424
<             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_assoc
---
>             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_assoc
11480c11440
<             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_assoc
---
>             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_assoc
11505c11465
<                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11512c11472
<                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11516c11476
<                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11522c11482
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
11541c11501
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom
11545c11505
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
11564c11524
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom
11568c11528
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
11607c11567
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_cod_arr whisker_right comp_assoc_assoc'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_cod_arr whisker_right comp_assoc_assoc'
11629c11589
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
11653c11613
<               using fg fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_cod_arr comp_assoc_assoc'
---
>               using fg fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_cod_arr comp_assoc_assoc'
11678c11638
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
11698c11658
<             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>             using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11728c11688
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11732c11692
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11735c11695
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11739c11699
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
11762c11722
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
11783c11743
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
11847c11807
<               using fg gh hseqI' whisker_right whisker_left by simp
---
>               using fg gh whisker_right whisker_left by simp
11849c11809
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
11906,11907c11866,11867
<                 using fg gh hseqI'
<                 by (intro seqI' comp_in_homI, auto)
---
>                 using fg gh
>                 by (intro seqI' comp_in_homI) auto
11988c11948
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12016c11976
<              using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>              using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12069c12029
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12073c12033
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12103c12063
<               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>               using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12171c12131
<                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12179c12139
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12252c12212
<                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                 using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12270,12271c12230,12231
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
<                           assoc'_naturality [of f "(g.tab \<star> Tgh.p\<^sub>1) \<star> TfTgh.p\<^sub>0" TTfgh_TfTgh.chine]
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
>                         assoc'_naturality [of f "(g.tab \<star> Tgh.p\<^sub>1) \<star> TfTgh.p\<^sub>0" TTfgh_TfTgh.chine]
12274c12234
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
12291c12251
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12296c12256
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
12313c12273
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12317c12277
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
12334c12294
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12339c12299
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
12365c12325
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12377c12337
<                     using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                     using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12384c12344
<                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps hseqI'
---
>                   using fg gh fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.p\<^sub>0_simps f\<^sub>0g\<^sub>1.p\<^sub>1_simps
12388c12348
<                   using comp_assoc by simp
---
>                   using comp_assoc by presburger
12391c12351
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
12394c12354
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12438,12439c12398,12399
<                 using fg gh hseqI'
<                 apply (intro seqI hseqI) by auto
---
>                 using fg gh
>                 apply (intro seqI) by auto
12463c12423
<                 using whisker_left by simp
---
>                 using whisker_left f.ide_base by presburger
12466c12426
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12513c12473
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
12527c12487
<               using fg gh hseqI' assoc_naturality [of f g "h \<star> TTfgh_TfTgh.the_\<theta>"] comp_assoc
---
>               using fg gh assoc_naturality [of f g "h \<star> TTfgh_TfTgh.the_\<theta>"] comp_assoc
12530c12490
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12607c12567
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12661c12621
<                 using fg gh hseqI'
---
>                 using fg gh
12676c12636
<                 using whisker_left 1 2 f.is_ide by simp (* 20 sec *)
---
>                 using whisker_left f.ide_base by presburger
12679c12639
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
12683c12643
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
12747,12750c12707
<           apply (intro comp_in_homI)
<               apply auto
<             apply auto
<           by fastforce+
---
>           apply (intro comp_in_homI) by auto
12763c12720,12721
<           using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom f\<^sub>0g\<^sub>1.\<phi>_uniqueness(2) by auto
---
>           using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_in_hom f\<^sub>0g\<^sub>1.\<phi>_uniqueness(2)
>           by (intro hcomp_in_vhom) auto
12775c12733,12734
<           using f\<^sub>0gh\<^sub>1.\<phi>_in_hom by auto
---
>           using f\<^sub>0gh\<^sub>1.\<phi>_in_hom
>           by (intro hcomp_in_vhom) auto
12801c12760
<           using fg gh f\<^sub>0g\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' whisker_left
---
>           using fg gh f\<^sub>0g\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps whisker_left
12818c12777
<             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_cod_arr hseqI' comp_assoc_assoc' by simp
---
>             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_cod_arr comp_assoc_assoc' by simp
12831c12790
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
12840c12799
<           using fg gh f\<^sub>0g\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_assoc
---
>           using fg gh f\<^sub>0g\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>0_simps fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_assoc
12879c12838
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
12888c12847
<             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_uniqueness hseqI' comp_cod_arr by simp
---
>             using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0g\<^sub>1.\<phi>_uniqueness comp_cod_arr by simp
12905c12864
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
12911c12870
<           unfolding \<theta>\<^sub>f_def using comp_assoc by simp
---
>           unfolding \<theta>\<^sub>f_def using comp_assoc by presburger
12932c12891
<           unfolding \<theta>\<^sub>f'_def using comp_assoc by simp
---
>           unfolding \<theta>\<^sub>f'_def using comp_assoc by presburger
12959c12918
<             using f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' comp_cod_arr comp_arr_dom comp_assoc_assoc' by simp
---
>             using f\<^sub>0gh\<^sub>1.p\<^sub>0_simps comp_cod_arr comp_arr_dom comp_assoc_assoc' by simp
12993c12952
<             using f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>             using f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
12997c12956
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
13016c12975
<             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13020c12979
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
13041c13000
<             using hseqI' comp_cod_arr comp_assoc_assoc' by simp
---
>             using comp_cod_arr comp_assoc_assoc' by simp
13073c13032
<             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' comp_assoc comp_assoc_assoc' by simp
---
>             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps comp_assoc comp_assoc_assoc' by simp
13077c13036
<             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' comp_cod_arr comp_assoc_assoc' by simp
---
>             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps comp_cod_arr comp_assoc_assoc' by simp
13080c13039
<             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' whisker_right comp_assoc_assoc' by simp
---
>             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps whisker_right comp_assoc_assoc' by simp
13082,13083c13041,13042
<             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' comp_cod_arr by simp
<           finally show ?thesis by simp
---
>             using g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps comp_cod_arr by simp
>           finally show ?thesis by presburger
13140c13099
<               using comp_assoc by simp
---
>               using comp_assoc by presburger
13150c13109
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13154c13113
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
13165c13124
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13169c13128
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
13180c13139
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13184c13143
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
13195c13154
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13199c13158
<                 using comp_assoc by simp
---
>                 using comp_assoc by presburger
13204c13163
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
13231c13190
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' canI_associator_0 \<a>'_def \<alpha>_def by simp
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps canI_associator_0 \<a>'_def \<alpha>_def by simp
13248c13207
<                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' canI_associator_0 \<a>'_def \<alpha>_def by simp
---
>                 using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps canI_associator_0 \<a>'_def \<alpha>_def by simp
13281c13240
<               using gh g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' \<a>'_def \<alpha>_def by simp
---
>               using gh g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps \<a>'_def \<alpha>_def by simp
13285c13244
<               using gh g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI' \<a>'_def \<alpha>_def by simp
---
>               using gh g\<^sub>0h\<^sub>1.p\<^sub>1_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps \<a>'_def \<alpha>_def by simp
13289c13248
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
13310c13269
<             using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
---
>             using gh f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
13347c13306
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
13393,13394c13352,13353
<         using g\<^sub>0h\<^sub>1.p\<^sub>0_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps hseqI'
<         by (intro comp_in_homI, auto)
---
>         using g\<^sub>0h\<^sub>1.p\<^sub>0_simps f\<^sub>0gh\<^sub>1.p\<^sub>0_simps
>         by (intro comp_in_homI) auto
13445c13404
<            using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' comp_assoc_assoc' by simp
---
>            using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps comp_assoc_assoc' by simp
13447c13406
<            using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps hseqI' fg\<^sub>0h\<^sub>1.\<phi>_uniqueness comp_cod_arr by simp
---
>            using fg\<^sub>0h\<^sub>1.p\<^sub>1_simps fg\<^sub>0h\<^sub>1.\<phi>_uniqueness comp_cod_arr by simp
13451c13410
<            using comp_arr_dom fg\<^sub>0h\<^sub>1.p\<^sub>0_simps hseqI' by simp
---
>            using comp_arr_dom fg\<^sub>0h\<^sub>1.p\<^sub>0_simps by simp
13473c13432
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
13490c13449
<             using comp_cod_arr hseqI' comp_assoc_assoc' by simp
---
>             using comp_cod_arr comp_assoc_assoc' by simp
13537c13496
<             using comp_cod_arr hseqI' comp_assoc_assoc' by simp
---
>             using comp_cod_arr comp_assoc_assoc' by simp
13603c13562
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
13647c13606
<           using comp_assoc by simp
---
>           using comp_assoc by presburger
14011c13970
<             using fg gh by (unfold_locales, auto)
---
>             using fg gh by unfold_locales auto
14017c13976
<             using fg gh by (unfold_locales, auto)
---
>             using fg gh by unfold_locales auto
14023c13982
<             using fg gh by (unfold_locales, auto)
---
>             using fg gh by unfold_locales auto
14221c14180
<                 using a a' SPN_def Span.src_def Maps.cod_char by simp
---
>                 using a a' SPN_def Span.src_def Maps.cod_char obj_simps by simp
14261c14220
<             by (unfold_locales, auto)
---
>             by unfold_locales auto
14264c14223
<             by (unfold_locales, auto)
---
>             by unfold_locales auto
14287c14246
<                   using b by auto
---
>                   using b obj_simps by auto
14305c14264
<                   using a by auto
---
>                   using a obj_simps by auto
14320c14279
<               using calculation(1) SPN_def [of ?f] REP_leg0.antipar hseqI' by auto
---
>               using calculation(1) SPN_def [of ?f] REP_leg0.antipar by auto
14393c14352
<                     by (metis f.base_simps(2) f.satisfies_T0 f.u_in_hom src_hcomp')
---
>                     by (metis f.base_simps(2) f.satisfies_T0 f.u_in_hom src_hcomp)
14424c14383
<                           trg_hcomp')
---
>                           trg_hcomp)
14485c14444
<                       using w\<theta>\<nu> isomorphic_reflexive Maps.REP_in_hhom hseqI'
---
>                       using w\<theta>\<nu> isomorphic_reflexive Maps.REP_in_hhom
14497c14456
<                         using w\<theta>\<nu> equivalence_is_adjoint Maps.REP_in_hhom hseqI'
---
>                         using w\<theta>\<nu> equivalence_is_adjoint Maps.REP_in_hhom
14505c14464
<                       using w\<theta>\<nu> Maps.CLS_eqI equivalence_is_adjoint hseqI'
---
>                       using w\<theta>\<nu> Maps.CLS_eqI equivalence_is_adjoint
14523c14482
<                       using w\<theta>\<nu> isomorphic_reflexive Maps.REP_in_hhom hseqI'
---
>                       using w\<theta>\<nu> isomorphic_reflexive Maps.REP_in_hhom
14537c14496
<                       using w\<theta>\<nu> equivalence_is_adjoint hseqI' f.leg1_is_map
---
>                       using w\<theta>\<nu> equivalence_is_adjoint f.leg1_is_map
14548,14556c14507,14514
<               interpret Dom_W: span_in_category Maps.comp
<                                  \<open>\<lparr>Leg0 = MkArr (src (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))
<                                                 (src (Maps.REP g.leg0)\<^sup>*)
<                                                 (iso_class
<                                                   (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*))),
<                                    Leg1 = MkArr (src (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))
<                                                 (Maps.Cod g.leg1)
<                                                 (iso_class
<                                                   (tab\<^sub>1 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))\<rparr>\<close>
---
>               interpret Dom_W:
>                 span_in_category Maps.comp
>                   \<open>\<lparr>Leg0 = Maps.MkArr (src (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))
>                                       (src (Maps.REP g.leg0)\<^sup>*)
>                                       (iso_class (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*))),
>                     Leg1 = Maps.MkArr (src (tab\<^sub>0 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))
>                                       (Maps.Cod g.leg1)
>                                       (iso_class (tab\<^sub>1 (Maps.REP g.leg1 \<star> (Maps.REP g.leg0)\<^sup>*)))\<rparr>\<close>
14617c14575
<           using r by (unfold_locales, auto)
---
>           using r by unfold_locales auto
14619c14577
<           using s by (unfold_locales, auto)
---
>           using s by unfold_locales auto
14718c14676
<             using s hseqI' assoc_in_hom [of s "tab\<^sub>0 s" "Maps.REP \<tau>.chine"]
---
>             using s assoc_in_hom [of s "tab\<^sub>0 s" "Maps.REP \<tau>.chine"]
14733c14691
<           using \<mu> by (unfold_locales, auto)
---
>           using \<mu> by unfold_locales auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Bicategory.thy ../../AFPs/afp-2020/thys/Bicategory/Bicategory.thy
381c381
<         using src_hcomp trg_hcomp composable_char\<^sub>P\<^sub>B\<^sub>H not_arr_null
---
>         using src_hcomp' trg_hcomp' composable_char\<^sub>P\<^sub>B\<^sub>H not_arr_null
1351c1351,1352
<               using assms 0 1 \<phi> ide_in_hom(2) targetsD(1) hseqI' by auto
---
>               using assms 0 1 \<phi> ide_in_hom(2) targetsD(1)
>               apply (intro conjI hcomp_in_vhom) by auto
2080c2081
<             using assms interchange [of g g "(\<i>[?b] \<star> f) \<cdot> \<a>\<^sup>-\<^sup>1[?b, ?b, f]" "\<a>[?b, ?b, f]"] hseqI'
---
>             using assms interchange [of g g "(\<i>[?b] \<star> f) \<cdot> \<a>\<^sup>-\<^sup>1[?b, ?b, f]" "\<a>[?b, ?b, f]"]
2083c2084
<             using assms comp_arr_dom comp_assoc_assoc' hseqI' comp_assoc by auto
---
>             using assms comp_arr_dom comp_assoc_assoc' comp_assoc by auto
2087c2088
<             using assms interchange [of "g \<star> \<i>[?b]" "\<a>[g, ?b, ?b]" f f] comp_assoc hseqI' by simp
---
>             using assms interchange [of "g \<star> \<i>[?b]" "\<a>[g, ?b, ?b]" f f] comp_assoc by simp
2099c2100
<             using assms 1 hseqI' by auto
---
>             using assms 1 by auto
2108c2109
<             using assms comp_cod_arr hseqI' by simp
---
>             using assms comp_cod_arr by simp
2111c2112
<                   whisker_left [of ?b "\<l>[f]" "\<l>\<^sup>-\<^sup>1[f]"] hseqI'
---
>                   whisker_left [of ?b "\<l>[f]" "\<l>\<^sup>-\<^sup>1[f]"]
2125d2125
<                     hseqI'
2130c2130
<             using assms comp_arr_dom hseqI' by auto
---
>             using assms comp_arr_dom by auto
2140c2140
<               interchange [of ?b ?b "\<l>\<^sup>-\<^sup>1[f]" "\<l>[f]"] hseqI' comp_assoc
---
>               interchange [of ?b ?b "\<l>\<^sup>-\<^sup>1[f]" "\<l>[f]"] comp_assoc
2182c2182
<           using assms triangle interchange [of "f \<star> \<l>[g]" "\<a>[f, trg g, g]" h h] comp_assoc hseqI'
---
>           using assms triangle interchange [of "f \<star> \<l>[g]" "\<a>[f, trg g, g]" h h] comp_assoc
2189c2189
<         using assms iso_assoc isos_compose hseqI' by simp
---
>         using assms iso_assoc isos_compose by simp
2191c2191
<         using assms iso_is_retraction retraction_is_epi hseqI'
---
>         using assms iso_is_retraction retraction_is_epi
2210c2210
<           using assms L.is_faithful [of "\<l>[f \<star> g] \<cdot> \<a>[trg f, f, g]" "\<l>[f] \<star> g"] hseqI' by force
---
>           using assms L.is_faithful [of "\<l>[f \<star> g] \<cdot> \<a>[trg f, f, g]" "\<l>[f] \<star> g"] by force
2223,2225c2223
<         using assms 1 invert_side_of_triangle(2) [of "\<l>[f] \<star> g" "\<l>[f \<star> g]" "\<a>[trg f, f, g]"]
<               hseqI'
<         by auto
---
>         using assms 1 invert_side_of_triangle(2) by auto
2231,2232c2229
<           using assms inv_comp iso_inv_iso
<           by (simp add: hseqI')
---
>           using assms inv_comp iso_inv_iso by simp
2247c2244
<         using assms assoc_naturality [of f g "\<l>[h]"] invert_side_of_triangle(1) hseqI'
---
>         using assms assoc_naturality [of f g "\<l>[h]"] invert_side_of_triangle(1)
2253c2250
<         using assms interchange [of f f] triangle comp_assoc hseqI'
---
>         using assms interchange [of f f] triangle comp_assoc
2260,2266c2257,2263
<             using assms pentagon [of f g "src g" h] iso_assoc inv_hcomp
<                   invert_side_of_triangle(1)
<                     [of "\<a>[f, g, src g \<star> h] \<cdot> \<a>[f \<star> g, src g, h]" "f \<star> \<a>[g, src g, h]"
<                         "\<a>[f, g \<star> src g, h] \<cdot> (\<a>[f, g, src g] \<star> h)"]
<                   invert_side_of_triangle(1)
<                     [of "(f \<star> \<a>\<^sup>-\<^sup>1[g, src g, h]) \<cdot> \<a>[f, g, src g \<star> h] \<cdot> \<a>[f \<star> g, src g, h]"
<                         "\<a>[f, g \<star> src g, h]" "\<a>[f, g, src g] \<star> h"]
---
>         using assms pentagon [of f g "src g" h] iso_assoc inv_hcomp
>               invert_side_of_triangle(1)
>                 [of "\<a>[f, g, src g \<star> h] \<cdot> \<a>[f \<star> g, src g, h]" "f \<star> \<a>[g, src g, h]"
>                     "\<a>[f, g \<star> src g, h] \<cdot> (\<a>[f, g, src g] \<star> h)"]
>               invert_side_of_triangle(1)
>                 [of "(f \<star> \<a>\<^sup>-\<^sup>1[g, src g, h]) \<cdot> \<a>[f, g, src g \<star> h] \<cdot> \<a>[f \<star> g, src g, h]"
>                     "\<a>[f, g \<star> src g, h]" "\<a>[f, g, src g] \<star> h"]
2279c2276
<         using assms interchange [of "f \<star> \<r>[g]" "\<a>[f, g, src g]" "src g" "src g"] hseqI'
---
>         using assms interchange [of "f \<star> \<r>[g]" "\<a>[f, g, src g]" "src g" "src g"]
2284,2296c2281
<       proof -
<         have "\<r>\<^sup>-\<^sup>1[f \<star> g] = inv ((f \<star> \<r>[g]) \<cdot> \<a>[f, g, src g])"
<           using 1 by simp
<         also have "... = \<a>\<^sup>-\<^sup>1[f, g, src g] \<cdot> (f \<star> \<r>\<^sup>-\<^sup>1[g])"
<         proof -
<           have "src f = trg \<r>[g]"
<             using assms by simp
<           thus ?thesis
<             using assms 1 inv_comp inv_hcomp hseqI' by simp
<         qed
<         finally show ?thesis
<           using assms by simp
<       qed
---
>         using assms 1 inv_comp inv_hcomp by auto
2298,2304c2283
<       proof -
<         have "f \<star> \<r>[g] = ((f \<star> \<r>[g]) \<cdot> \<a>[f, g, src g]) \<cdot> \<a>\<^sup>-\<^sup>1[f, g, src g]"
<           using assms comp_arr_dom comp_cod_arr comp_assoc hseqI' comp_assoc_assoc' by simp
<         also have "... = \<r>[f \<star> g] \<cdot> \<a>\<^sup>-\<^sup>1[f, g, src g]"
<           using assms 1 by auto
<         finally show ?thesis by auto
<       qed
---
>         using assms 1 comp_arr_dom comp_cod_arr comp_assoc hseqI' comp_assoc_assoc' by auto
2308c2287
<           using assms inv_comp iso_inv_iso hseqI' by simp
---
>           using assms inv_comp iso_inv_iso by simp
2332c2311
<             using assms comp_arr_dom comp_assoc hseqI' comp_assoc_assoc'
---
>             using assms comp_arr_dom comp_assoc comp_assoc_assoc'
2397c2376
<           using assms comp_assoc_assoc'(2) comp_cod_arr hseqI' by simp
---
>           using assms comp_assoc_assoc'(2) comp_cod_arr by simp
2407c2386
<           using assms comp_assoc_assoc'(1) comp_arr_dom hseqI' by simp
---
>           using assms comp_assoc_assoc'(1) comp_arr_dom by simp
2423c2402
<           using assms triangle by auto
---
>         using assms triangle by auto
2425c2404
<         using assms comp_arr_dom comp_assoc hseqI' comp_assoc_assoc' by auto
---
>         using assms comp_arr_dom comp_assoc comp_assoc_assoc' by auto
2440,2450c2419,2420
<         proof -
<           have "iso (\<a>[f, g \<star> h, k] \<cdot> (\<a>[f, g, h] \<star> k))"
<             using assms isos_compose hseqI' by simp
<           moreover have "iso (f \<star> \<a>[g, h, k])"
<             using assms by simp
<           moreover have "seq (f \<star> \<a>[g, h, k]) (\<a>[f, g \<star> h, k] \<cdot> (\<a>[f, g, h] \<star> k))"
<             using assms hseqI' by simp
<           ultimately show ?thesis
<             using inv_comp [of "\<a>[f, g \<star> h, k] \<cdot> (\<a>[f, g, h] \<star> k)" "f \<star> \<a>[g, h, k]"]
<             by simp
<         qed
---
>           using assms inv_comp [of "\<a>[f, g \<star> h, k] \<cdot> (\<a>[f, g, h] \<star> k)" "f \<star> \<a>[g, h, k]"]
>           by force
2452c2422
<           using assms iso_assoc inv_comp hseqI' by simp
---
>           using assms iso_assoc inv_comp by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/CanonicalIsos.thy ../../AFPs/afp-2020/thys/Bicategory/CanonicalIsos.thy
348c348
<           using assms comp_arr_dom comp_cod_arr comp_assoc hseqI' by simp
---
>           using assms comp_arr_dom comp_cod_arr comp_assoc by simp
351c351
<                 assoc_simps(1) assoc_simps(4) assoc_simps(5) ideD(1) iso_assoc preserves_ide seqI
---
>                 assoc_simps(1,4-5) ideD(1) iso_assoc preserves_ide seqI
363c363
<           using assms comp_arr_dom comp_cod_arr comp_assoc hseqI' by simp
---
>           using assms comp_arr_dom comp_cod_arr comp_assoc by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/CategoryWithPullbacks.thy ../../AFPs/afp-2020/thys/Bicategory/CategoryWithPullbacks.thy
583,590d582
< 
<   subsection "Properties"
< 
<   text \<open>
<     Next, we go on to develop the properties of an elementary category with pullbacks.
<   \<close>
< 
<   context elementary_category_with_pullbacks
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Coherence.thy ../../AFPs/afp-2020/thys/Bicategory/Coherence.thy
1943c1943
<               by (cases w, simp_all)
---
>               apply (cases w) by simp_all
2306c2306,2317
<             using t u v tuv VVV.hom_char by fastforce
---
>           proof -
>             have "(\<lbrace>t\<rbrace>, \<lbrace>u\<rbrace>, \<lbrace>v\<rbrace>) \<in>
>                     VxVxV.hom (\<lbrace>Dom t\<rbrace>, \<lbrace>Dom u\<rbrace>, \<lbrace>Dom v\<rbrace>) (\<lbrace>Cod t\<rbrace>, \<lbrace>Cod u\<rbrace>, \<lbrace>Cod v\<rbrace>)"
>               using t u v tuv by simp
>             moreover have "(\<lbrace>t\<rbrace>, \<lbrace>u\<rbrace>, \<lbrace>v\<rbrace>) \<in>
>                              {\<tau>\<mu>\<nu>. arr (fst \<tau>\<mu>\<nu>) \<and> VV.arr (snd \<tau>\<mu>\<nu>) \<and> 
>                                    src (fst \<tau>\<mu>\<nu>) = trg (fst (snd \<tau>\<mu>\<nu>))}"
>               using t u v tuv by fastforce
>             ultimately show ?thesis
>               using VVV.hom_char [of "(\<lbrace>Dom t\<rbrace>, \<lbrace>Dom u\<rbrace>, \<lbrace>Dom v\<rbrace>)" "(\<lbrace>Cod t\<rbrace>, \<lbrace>Cod u\<rbrace>, \<lbrace>Cod v\<rbrace>)"]
>               by blast
>           qed
2326c2337
<                 using 4 VVV.arr_char VV.arr_char hseqI' by simp
---
>                 using 4 VVV.arr_char VV.arr_char by simp
2338c2349
<                 using 4 VVV.arr_char VV.arr_char hseqI' by simp
---
>                 using 4 VVV.arr_char VV.arr_char by simp
2391c2402
<                 using 4 VVV.arr_char VV.arr_char hseqI' by simp
---
>                 using 4 VVV.arr_char VV.arr_char by simp
2712c2723
<           using tuv iso_eval_Can Can_implies_Arr eval_simps'(2) eval_simps'(3) \<alpha>_def hseqI'
---
>           using tuv iso_eval_Can Can_implies_Arr eval_simps'(2) eval_simps'(3) \<alpha>_def
2734c2745
<           by (simp add: eval_simps'(2) eval_simps'(3) hseqI' iso_eval_Can)
---
>           by (simp add: eval_simps'(2) eval_simps'(3) iso_eval_Can)
2994c3005
<          using t 1 lunit_in_hom Nmlize_in_Hom ide_eval_Ide red_in_Hom comp_cod_arr hseqI'
---
>          using t 1 lunit_in_hom Nmlize_in_Hom ide_eval_Ide red_in_Hom comp_cod_arr
3040,3041c3051,3052
<              using t red_in_Hom red_Src Obj_Src hseqI'
<              by (auto simp add: eval_simps')
---
>              using t red_in_Hom red_Src Obj_Src eval_simps'
>              by (simp add: ide_eval_Ide ide_in_hom(2))
3133,3134c3144,3146
<             using assms runit_naturality
<             by (metis (no_types, lifting) arr_dom in_homE src_dom hcomp_simps(1))
---
>             using assms runit_naturality [of "\<lbrace>a \<^bold>\<Down> b\<rbrace>"] arr_dom in_homE src_dom src_hcomp
>                   hcomp_simps(1)
>             by (elim in_homE, metis)
3325c3337
<                   by (auto simp add: eval_simps' hseqI')
---
>                   by (auto simp add: eval_simps')
3338c3350
<                     by (simp add: eval_simps' hseqI')
---
>                     by (simp add: eval_simps')
3350c3362
<                 by (simp add: eval_simps' hseqI')
---
>                 by (simp add: eval_simps')
3360c3372
<                 by (auto simp add: eval_simps' hseqI')
---
>                 by (auto simp add: eval_simps')
3378c3390
<                 by (simp add: eval_simps' hseqI')
---
>                 by (simp add: eval_simps')
3441c3453
<         by (simp add: eval_simps' hseqI')
---
>         by (simp add: eval_simps')
3453c3465
<         apply (simp add: eval_simps' hseqI')
---
>         apply (simp add: eval_simps')
3458c3470
<           by (simp_all add: eval_simps' hseqI')
---
>           by (simp_all add: eval_simps')
3464c3476
<           by (simp add: eval_simps' hseqI')
---
>           by (simp add: eval_simps')
3519c3531
<           moreover have "E f \<star> \<lbrace>u\<rbrace> \<in> hom (E (C.dom f) \<star> \<lbrace>Dom u\<rbrace>) (E (C.cod f) \<star> \<lbrace>Cod u\<rbrace>)"
---
>           moreover have "\<guillemotleft>E f \<star> \<lbrace>u\<rbrace> : E (C.dom f) \<star> \<lbrace>Dom u\<rbrace> \<Rightarrow> E (C.cod f) \<star> \<lbrace>Cod u\<rbrace>\<guillemotright>"
3521c3533,3535
<             by (auto simp add: eval_simps' hseqI')
---
>             apply (intro hcomp_in_vhom)
>               apply auto
>             by (metis C.src_dom eval_simps(4) preserves_src trg_dom u)
3524c3538
<             by (simp add: fu hseqI')
---
>             by (simp add: fu)
3593c3607
<            by (simp add: eval_simps' hseqI')
---
>            by (simp add: eval_simps')
Only in ../../AFPs/afp-2019/thys/Bicategory: ConcreteCategory.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/InternalAdjunction.thy ../../AFPs/afp-2020/thys/Bicategory/InternalAdjunction.thy
67c67
<         using E.antipar whisker_left hseqI' by simp
---
>         using E.antipar whisker_left by simp
133c133
<             using E.antipar hseqI' inv_comp by simp
---
>             using E.antipar inv_comp by simp
139c139
<         using E.antipar whisker_right hseqI' by simp
---
>         using E.antipar whisker_right by simp
190c190
<           using assms \<mu> antipar whisker_left comp_assoc hseqI' by auto
---
>           using assms \<mu> antipar whisker_left comp_assoc by auto
246c246
<               using assms \<mu> antipar whisker_right hseqI' by simp
---
>               using assms \<mu> antipar whisker_right by simp
277c277
<           using assms \<nu> antipar interchange [of g "g \<cdot> g \<cdot> g"] comp_assoc hseqI' by auto
---
>           using assms \<nu> antipar interchange [of g "g \<cdot> g \<cdot> g"] comp_assoc by auto
318c318
<                 using assms antipar comp_arr_dom comp_assoc hseqI' comp_assoc_assoc'(1) by simp
---
>                 using assms antipar comp_arr_dom comp_assoc comp_assoc_assoc'(1) by simp
331c331
<                   using assms antipar comp_cod_arr hseqI' comp_assoc_assoc'(1) by simp
---
>                   using assms antipar comp_cod_arr comp_assoc_assoc'(1) by simp
356c356
<                   using assms antipar whisker_right hseqI' by simp
---
>                   using assms antipar whisker_right by simp
425c425
<           using assms \<mu> antipar whisker_right comp_assoc hseqI' by auto
---
>           using assms \<mu> antipar whisker_right comp_assoc by auto
456c456,464
<               using assms antipar comp_cod_arr hseqI' comp_assoc_assoc'(2) by simp
---
>             proof -
>               have "arr v \<and> dom v = v \<and> cod v = v"
>                 using assms(2) ide_char by blast
>               moreover have "arr g \<and> dom g = g \<and> cod g = g"
>                 using ide_right ide_char by blast
>               ultimately show ?thesis
>                 by (metis (no_types) antipar(2) assms(3-4) assoc_naturality
>                     counit_simps(1,3,5) hcomp_reassoc(1) comp_assoc)
>             qed
467c475
<                 using assms antipar comp_cod_arr hseqI' comp_assoc_assoc'(2) by simp
---
>                 using assms antipar comp_cod_arr comp_assoc_assoc'(2) by simp
493c501
<               using assms antipar whisker_left hseqI' by simp
---
>               using assms antipar whisker_left by simp
542c550
<           using assms \<nu> antipar whisker_right [of f] comp_assoc hseqI' by auto
---
>           using assms \<nu> antipar whisker_right comp_assoc by auto
584c592
<           using assms antipar whisker_left hseqI' by auto
---
>           using assms antipar whisker_left by auto
645c653
<       using assms antipar strict_runit' comp_arr_ide [of "\<r>\<^sup>-\<^sup>1[v]" "v \<star> \<eta>"] hcomp_arr_obj hseqI'
---
>       using assms antipar strict_runit' comp_arr_ide [of "\<r>\<^sup>-\<^sup>1[v]" "v \<star> \<eta>"] hcomp_arr_obj
654c662
<       using assms antipar strict_runit comp_ide_arr hcomp_arr_obj hseqI' by auto
---
>       using assms antipar strict_runit comp_ide_arr hcomp_arr_obj by auto
661c669
<       using assms trnl\<^sub>\<eta>_def antipar strict_lunit comp_arr_dom hcomp_obj_arr hseqI' by auto
---
>       using assms trnl\<^sub>\<eta>_def antipar strict_lunit comp_arr_dom hcomp_obj_arr by auto
668c676
<       using assms trnl\<^sub>\<epsilon>_def antipar strict_lunit comp_cod_arr hcomp_obj_arr hseqI' by auto
---
>       using assms trnl\<^sub>\<epsilon>_def antipar strict_lunit comp_cod_arr hcomp_obj_arr by auto
702c710
<             using assms antipar hseqI' by simp
---
>             using assms antipar by simp
746,747c754
<           using assms antipar unit_in_hom hseqI'
<           apply (intro seqI hseqI) by auto
---
>           using assms antipar unit_in_hom by simp
768,769c775
<           using assms antipar unit_in_hom hseqI'
<           apply (intro seqI hseqI) by auto
---
>           using assms antipar unit_in_hom by simp
849c855
<           using assms A.antipar whisker_right whisker_left hseqI' comp_assoc by auto
---
>           using assms A.antipar whisker_right whisker_left comp_assoc by auto
855c861
<           using assms A.antipar comp_inv_arr inv_is_inverse hseqI' whisker_left
---
>           using assms A.antipar comp_inv_arr inv_is_inverse whisker_left
859c865
<           using assms A.antipar comp_cod_arr hseqI' by simp
---
>           using assms A.antipar comp_cod_arr by simp
868c874
<             using assms hseqI' A.antipar whisker_left whisker_right comp_assoc by auto
---
>             using assms A.antipar whisker_left whisker_right comp_assoc by auto
876c882
<             using assms A.antipar comp_arr_dom comp_cod_arr hseqI'
---
>             using assms A.antipar comp_arr_dom comp_cod_arr
881c887
<                   interchange [of "\<phi> \<star> f" "g \<star> f" g "inv \<phi>"] hseqI'
---
>                   interchange [of "\<phi> \<star> f" "g \<star> f" g "inv \<phi>"]
945c951
<           using assms A.antipar whisker_left whisker_right hseqI' comp_assoc by auto
---
>           using assms A.antipar whisker_left whisker_right comp_assoc by auto
951c957
<           using assms A.antipar comp_inv_arr inv_is_inverse hseqI' whisker_right
---
>           using assms A.antipar comp_inv_arr inv_is_inverse whisker_right
955c961
<           using assms A.antipar comp_cod_arr hseqI' by simp
---
>           using assms A.antipar comp_cod_arr by simp
964c970
<           using assms hseqI' A.antipar whisker_right whisker_left comp_assoc
---
>           using assms A.antipar whisker_right whisker_left comp_assoc
972,973c978,979
<           have "(inv \<phi> \<star> g \<star> f') \<cdot> (f' \<star> g \<star> \<phi>) = inv \<phi> \<star> g \<star> \<phi>"
<             using assms A.antipar comp_arr_dom comp_cod_arr hseqI'
---
>           have "(inv \<phi> \<star> g \<star> f') \<cdot> (f' \<star> g \<star> \<phi>) = (f \<star> g \<star> \<phi>) \<cdot> (inv \<phi> \<star> g \<star> f)"
>             using assms(2-3) A.antipar comp_arr_dom comp_cod_arr
975,977d980
<             by auto
<           also have "... = (f \<star> g \<star> \<phi>) \<cdot> (inv \<phi> \<star> g \<star> f)"
<             using assms A.antipar comp_arr_dom comp_cod_arr hseqI'
980c983
<           finally show ?thesis
---
>           thus ?thesis
997c1000
<             by auto
---
>           by (metis A.counit_simps(1) A.counit_simps(2) A.counit_simps(3) in_homE)
1079c1082
<               whisker_can_right_1 whisker_can_left_1 can_Ide_self
---
>               whisker_can_right_1 whisker_can_left_1 can_Ide_self obj_simps
1154c1157
<                 using antipar D.isos_compose C.VV.ide_char C.VV.arr_char \<Phi>_simps(4) D.hseqI'
---
>                 using antipar D.isos_compose C.VV.ide_char C.VV.arr_char \<Phi>_simps(4)
1166,1168c1169,1171
<                   using antipar D.isos_compose C.VV.ide_char C.VV.arr_char \<Phi>_simps(4) D.hseqI'
<                         preserves_inv D.inv_comp D.iso_is_arr
<                     by simp
---
>                   using antipar D.isos_compose C.VV.arr_char \<Phi>_simps(4)
>                         preserves_inv D.inv_comp
>                   by simp
1171c1174
<                   using antipar D.inv_comp C.VV.ide_char C.VV.arr_char \<Phi>_simps(4) D.hseqI'
---
>                   using antipar D.inv_comp C.VV.ide_char C.VV.arr_char \<Phi>_simps(4)
1263c1266
<               using antipar \<Phi>.naturality [of "(\<epsilon>, f)"] C.VV.arr_char FF_def C.hseqI'
---
>               using antipar \<Phi>.naturality [of "(\<epsilon>, f)"] C.VV.arr_char FF_def
1267c1270
<               using antipar \<Phi>.naturality [of "(f, \<eta>)"] C.VV.arr_char FF_def C.hseqI'
---
>               using antipar \<Phi>.naturality [of "(f, \<eta>)"] C.VV.arr_char FF_def
1276c1279
<             using antipar D.comp_arr_inv' D.comp_cod_arr C.hseqI' D.comp_assoc by simp
---
>             using antipar D.comp_arr_inv' D.comp_cod_arr D.comp_assoc by simp
1296c1299
<               using antipar C.hseqI' by simp
---
>               using antipar by simp
1309c1312
<                 using \<Psi>_char(2) D.hseqI'
---
>                 using \<Psi>_char(2)
1349c1352,1354
<               by (intro D.isos_compose D.seqI, auto)
---
>               apply (intro D.isos_compose, auto)
>               by (metis C.iso_assoc D.comp_assoc D.seqE ide_left ide_right
>                   preserves_assoc(1) preserves_iso)
1356c1361
<                 using antipar C.VV.arr_char D.hseqI' by simp
---
>                 using antipar C.VV.arr_char by simp
1366,1368c1371,1374
<                   using ide_left ide_right A.ide_right antipar D.iso_is_arr D.ide_char
<                         C.ide_hcomp C.ideD(1) C.src_hcomp' D.hcomp_simps(4) \<Phi>_simps(4-5)
<                   by metis
---
>                   by (metis C.iso_assoc D.comp_assoc D.iso_is_arr D.seqE
>                       \<open>F \<a>\<^sub>C[g, f, g] \<cdot>\<^sub>D \<Phi> (g \<star>\<^sub>C f, g) \<cdot>\<^sub>D (\<Phi> (g, f) \<star>\<^sub>D F g) =
>                        \<Phi> (g, f \<star>\<^sub>C g) \<cdot>\<^sub>D (F g \<star>\<^sub>D \<Phi> (f, g)) \<cdot>\<^sub>D \<a>\<^sub>D[F g, F f, F g]\<close>
>                       antipar(1) antipar(2) ide_left ide_right preserves_assoc(1) preserves_iso)
1377c1383,1384
<                   using antipar D.iso_is_arr by (intro D.seqI, auto)
---
>                   using antipar D.iso_is_arr
>                   apply (intro D.seqI) by auto
1451c1458
<                 using antipar D.comp_cod_arr D.whisker_right D.hseqI' by simp
---
>                 using antipar D.comp_cod_arr D.whisker_right by simp
1472c1479
<               using antipar C.VV.arr_char \<Phi>.naturality [of "(g, \<epsilon>)"] FF_def C.hseqI'
---
>               using antipar C.VV.arr_char \<Phi>.naturality [of "(g, \<epsilon>)"] FF_def 
1505,1506c1512,1513
<                     using preserves_iso \<Psi>_char(2) D.arrI D.seqE ide_right runit_coherence D.hseqI'
<                     by (intro D.isos_compose D.seqI D.hseqI, auto)
---
>                     using preserves_iso \<Psi>_char(2) D.arrI D.seqE ide_right runit_coherence
>                     by (intro D.isos_compose D.seqI, auto)
1579c1586
<             using assms A.antipar C.hseqI' by simp
---
>             using assms A.antipar by simp
1605c1612
<                         FF_def D.hseqI'
---
>                         FF_def
1663c1670
<             using assms A.antipar C.hseqI' by auto
---
>             using assms A.antipar by auto
1686c1693
<                   using assms A.antipar \<Phi>_components_are_iso C.VV.arr_char FF_def D.hseqI'
---
>                   using assms A.antipar \<Phi>_components_are_iso C.VV.arr_char FF_def
1874c1881
<             by (simp add: ide_in_hom(2))
---
>             apply (intro hcomp_in_vhom) by auto
1909c1916
<           by (simp add: hseqI')
---
>           by simp
1913c1920,1921
<           by auto
---
>           by (metis fg.counit_simps(1) fg.counit_simps(2) fg.counit_simps(3)
>               hk.unit_simps(1) hk.unit_simps(2) hk.unit_simps(3))
1920c1928
<           by (simp add: hseqI')
---
>           by simp
1923c1931
<           by (simp add: hseqI')
---
>           by simp
1944c1952
<             by (simp add: hseqI')
---
>             by simp
1948c1956,1957
<           by simp
---
>           by (metis fg.counit_simps(1) fg.counit_simps(2) fg.counit_simps(3)
>               hk.unit_simps(1) hk.unit_simps(2) hk.unit_simps(3))
1955c1964
<           by (simp add: hseqI')
---
>           by simp
1958c1967
<           by (simp add: hseqI')
---
>           by simp
2193,2195c2202
<             using antipar inv_comp counit_is_iso iso_inv_iso isos_compose unit_is_iso
<                   comp_assoc hseqI'
<             by simp
---
>             using antipar inv_comp iso_inv_iso isos_compose comp_assoc by simp
2199c2206
<             using iso_lunit iso_runit iso_inv_iso inv_comp by simp
---
>             using iso_inv_iso inv_comp by simp
2207,2209c2214
<             using antipar inv_comp counit_is_iso iso_inv_iso isos_compose unit_is_iso
<                   comp_assoc hseqI'
<             by simp
---
>             using antipar inv_comp iso_inv_iso isos_compose comp_assoc by simp
2213c2218
<             using iso_lunit iso_runit iso_inv_iso inv_comp by simp
---
>             using iso_inv_iso inv_comp by simp
2320c2325
<             using f_in_hhom g_in_hhom b hcomp_obj_arr [of ?b "f \<star> g"] hseqI' by fastforce
---
>             using f_in_hhom g_in_hhom b hcomp_obj_arr [of ?b "f \<star> g"] by fastforce
2328,2356c2333,2334
<               iso_inv_iso hseqI'
<         apply (intro isos_compose)
<             apply auto
<            apply fastforce
<           apply fastforce
<       proof -
<         have 1: "\<guillemotleft>(f \<star> inv \<eta> \<star> g) \<cdot> (inv \<xi> \<star> f \<star> g) : ?b \<star> f \<star> g \<Rightarrow> f \<star> ?a \<star> g\<guillemotright>"
<         proof
<           have "\<guillemotleft>inv \<xi> \<star> f \<star> g : ?b \<star> f \<star> g \<Rightarrow> (f \<star> g) \<star> f \<star> g\<guillemotright>"
<             using f_in_hhom g_in_hhom ide_f ide_g \<xi>_in_hhom \<xi>_in_hom iso_\<xi>
<             by (intro hcomp_in_vhom, auto)
<           thus "\<guillemotleft>inv \<xi> \<star> f \<star> g : ?b \<star> f \<star> g \<Rightarrow> f \<star> g \<star> f \<star> g\<guillemotright>"
<             using hcomp_assoc by simp
<           have "\<guillemotleft>f \<star> inv \<eta> \<star> g : f \<star> (g \<star> f) \<star> g \<Rightarrow> f \<star> ?a \<star> g\<guillemotright>"
<             using f_in_hhom g_in_hhom ide_f ide_g \<eta>_in_hhom \<eta>_in_hom iso_\<eta>
<             by (intro hcomp_in_vhom, auto)
<           thus "\<guillemotleft>f \<star> inv \<eta> \<star> g : f \<star> g \<star> f \<star> g \<Rightarrow> f \<star> ?a \<star> g\<guillemotright>"
<             using hcomp_assoc by simp
<         qed
<         show "seq (f \<star> inv \<eta> \<star> g) (inv \<xi> \<star> f \<star> g)"
<           using 1 by auto
<         show "seq \<xi> ((f \<star> inv \<eta> \<star> g) \<cdot> (inv \<xi> \<star> f \<star> g))"
<         proof -
<           have "f \<star> ?a \<star> g = f \<star> g"
<             using a f_in_hhom g_in_hhom hcomp_obj_arr by fastforce
<           thus ?thesis
<             using 1 \<xi>_in_hom by auto
<         qed
<       qed
---
>               iso_inv_iso isos_compose
>         by (metis \<epsilon>_in_hom arrI hseqE ide_is_iso iso_hcomp seqE)
2373c2351
<             using b \<eta>_in_hhom hcomp_obj_arr [of ?b "f \<star> \<eta>"] hseqI' by fastforce
---
>             using b \<eta>_in_hhom hcomp_obj_arr [of ?b "f \<star> \<eta>"] by fastforce
2440c2418
<                 using f_in_hhom ide_f g_in_hhom ide_g \<eta>_in_hhom \<eta>_in_hom iso_\<eta> hseqI'
---
>                 using f_in_hhom ide_f g_in_hhom ide_g \<eta>_in_hhom \<eta>_in_hom iso_\<eta>
2519c2497
<               using \<xi>_in_hhom iso_\<xi> hcomp_assoc hseqI' calculation by auto
---
>               using \<xi>_in_hhom iso_\<xi> hcomp_assoc calculation by auto
2562,2563c2540,2541
<                 using E.antipar hseqI'
<                 by (intro seqI hseqI, auto)
---
>                 using E.antipar
>                 by (intro seqI, auto)
2565c2543
<                 using ide_f ide_g E.antipar triangle_right strict_assoc' comp_ide_arr hseqI'
---
>                 using ide_f ide_g E.antipar triangle_right strict_assoc' comp_ide_arr
2580,2581c2558,2559
<                 using E.antipar hseqI'
<                 by (intro seqI hseqI, auto)
---
>                 using E.antipar
>                 by (intro seqI, auto)
2583c2561
<                 using ide_f ide_g E.antipar triangle_right strict_assoc comp_ide_arr hseqI'
---
>                 using ide_f ide_g E.antipar triangle_right strict_assoc comp_ide_arr
2682c2660
<         using assms S.UP_map\<^sub>0_obj apply (intro S.in_homI) by auto
---
>         using assms(2-3) S.UP_map\<^sub>0_obj apply (intro S.in_homI) by auto
2694,2695c2672,2675
<           thus ?thesis
<             using assms(2-3) b \<epsilon>' UP.locally_full by auto
---
>           moreover have "ide (f \<star> g)"
>             using assms(2-3) by auto
>           ultimately show ?thesis
>             using \<epsilon>' UP.locally_full by auto
2733c2713,2719
<         using assms \<epsilon> iso_\<epsilon>' UP.reflects_iso apply unfold_locales by auto
---
>         using assms(1,3-5)
>         apply unfold_locales
>              apply simp_all
>         using assms(2) \<epsilon>
>          apply auto[1]
>         using \<epsilon> iso_\<epsilon>' UP.reflects_iso [of \<epsilon>]
>         by auto
2801c2787
<                     by simp
---
>                     by (metis (no_types, lifting) E'.ide_left E'.ide_right)
2827c2813,2815
<                         using assms UP.\<Psi>_char UP.\<Phi>_components_are_iso by auto
---
>                         using assms UP.\<Psi>_char UP.\<Phi>_components_are_iso
>                               E'.unit_simps(1) S.comp_assoc
>                         by presburger 
2837c2825
<                       by simp
---
>                       by argo
2849c2837,2839
<                     have "S.iso (S.UP f \<star>\<^sub>S UP.\<Psi> ?a)"
---
>                     have "S.arr (S.UP f)"
>                       using assms by simp
>                     moreover have "S.iso (S.UP f \<star>\<^sub>S UP.\<Psi> ?a)"
2859c2849
<                       by simp  (* 45 sec *)
---
>                       by presburger
2892,2895c2882
<                  using UP.\<Psi>_char S.comp_arr_dom UP.preserves_iso UP.preserves_inv
<                        S.invert_side_of_triangle(1)
<                          [of "S.UP f" "S.UP \<l>[f]" "S.\<Phi> (trg f, f) \<cdot>\<^sub>S (UP.\<Psi> (trg f) \<star>\<^sub>S S.UP f)"]
<                  by auto
---
>                  using UP.image_of_unitor(3) ide_f by presburger
2902,2904c2889,2892
<                moreover have 1: "S.iso (S.\<Phi> (f, src f) \<cdot>\<^sub>S (S.UP f \<star>\<^sub>S UP.\<Psi> (src f)))"
<                  using UP.\<Psi>_char UP.\<Phi>_components_are_iso VV.arr_char S.hseqI' S.UP_map\<^sub>0_obj
<                  by (intro S.isos_compose S.seqI, auto)
---
>                moreover have "S.iso (S.\<Phi> (f, src f) \<cdot>\<^sub>S (S.UP f \<star>\<^sub>S UP.\<Psi> (src f)))"
>                  using UP.\<Psi>_char UP.\<Phi>_components_are_iso VV.arr_char S.UP_map\<^sub>0_obj
>                  apply (intro S.isos_compose S.seqI)
>                  by simp_all
2909,2930c2897,2899
<                  by simp
<                also have
<                  "... = (S.UP f \<cdot>\<^sub>S (S.UP f \<star>\<^sub>S S.inv (UP.\<Psi> (src f)))) \<cdot>\<^sub>S S.inv (S.\<Phi> (f, src f))"
<                proof -
<                  have "S.iso (S.UP f \<star>\<^sub>S UP.\<Psi> (src f))"
<                    using 1 UP.\<Psi>_char UP.\<Phi>_components_are_iso S.UP_map\<^sub>0_obj by simp
<                  moreover have
<                    "S.inv (S.UP f \<star>\<^sub>S UP.\<Psi> (src f)) = S.UP f \<star>\<^sub>S S.inv (UP.\<Psi> (src f))"
<                    using 1 UP.\<Psi>_char UP.\<Phi>_components_are_iso S.UP_map\<^sub>0_obj by simp
<                  moreover have "S.seq (S.\<Phi> (f, src f)) (S.UP f \<star>\<^sub>S UP.\<Psi> (src f))"
<                    using 1 S.hseqI' S.UP_map\<^sub>0_obj
<                    by (intro S.seqI S.hseqI, auto)
<                  ultimately have "S.inv (S.\<Phi> (f, src f) \<cdot>\<^sub>S (S.UP f \<star>\<^sub>S UP.\<Psi> (src f))) =
<                        (S.UP f \<star>\<^sub>S S.inv (UP.\<Psi> (src f))) \<cdot>\<^sub>S S.inv (S.\<Phi> (f, src f))"
<                    using 1 UP.\<Psi>_char UP.\<Phi>_components_are_iso S.inv_comp by auto
<                  thus ?thesis
<                    using S.comp_assoc by simp
<                qed
<                also have
<                  "... = (S.UP f \<star>\<^sub>S S.inv (UP.\<Psi> (src f))) \<cdot>\<^sub>S S.inv (S.\<Phi> (f, src f))"
<                  using UP.\<Psi>_char S.comp_cod_arr S.hcomp_arr_obj S.hseqI' S.UP_map\<^sub>0_obj by simp
<                finally show ?thesis by simp
---
>                        ideD(1) ide_f by blast
>                thus ?thesis
>                  using ide_f UP.image_of_unitor(2) [of f] by argo
3002c2971
<               hcomp_arr_obj hseqI'
---
>               hcomp_arr_obj
3023c2992
<                     obj_trg trg_hcomp')
---
>                     obj_trg trg_hcomp)
3026c2995
<                       whisker_left comp_arr_dom comp_cod_arr hseqI'
---
>                       whisker_left comp_arr_dom comp_cod_arr
3050c3019
<                     by (simp add: hcomp_assoc hseqI')
---
>                     by (simp add: hcomp_assoc)
3077c3046
<                     by (simp add: hcomp_assoc hseqI')
---
>                     by (simp add: hcomp_assoc)
3107c3076
<                   by (simp add: A.triangle_left hseqI')
---
>                   by (simp add: A.triangle_left)
3117,3118c3086,3087
<               by (metis A'.triangle_in_hom(4) A'.triangle_right' hcomp_simps(4) comp_null(2)
<                   hseq_char' in_homE)
---
>               by (metis A'.ide_right A'.triangle_in_hom(2) A.ide_left arrI assoc_is_natural_2
>                   ide_char seqE strict_assoc)
3163c3132
<                     by (simp add: hcomp_assoc hseqI')
---
>                     by (simp add: hcomp_assoc)
3189c3158
<                     by (simp add: hcomp_assoc hseqI')
---
>                     by (simp add: hcomp_assoc)
3214c3183
<                   by (simp add: A'.triangle_left hseqI')
---
>                   by (simp add: A'.triangle_left)
3224,3225c3193,3194
<               by (metis A.triangle_in_hom(4) A.triangle_right' hcomp_simps(4) comp_null(2)
<                   hseq_char' in_homE)
---
>               by (metis A.ide_left A.ide_right A.triangle_in_hom(2) arrI assoc_is_natural_2
>                   ide_char seqE strict_assoc)
3344c3313
<       interpret gf: adjoint_equivalence_in_bicategory V H \<a> \<i> src trg g f "inv \<epsilon>" "inv \<eta>"
---
>       interpret gf: adjoint_equivalence_in_bicategory V H \<a> \<i> src trg g f \<open>inv \<epsilon>\<close> \<open>inv \<eta>\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/InternalEquivalence.thy ../../AFPs/afp-2020/thys/Bicategory/InternalEquivalence.thy
89c89
<       using antipar hseqI' by auto
---
>       using antipar by auto
235,236c235,236
<           using assms f' g' E.unit_in_hom E.antipar(2) vconn_implies_hpar(3) hseqI'
<           apply (intro comp_in_homI, auto)
---
>           using assms f' g' E.unit_in_hom E.antipar(2) vconn_implies_hpar(3)
>          apply (intro comp_in_homI, auto)
279,282c279
<         using assms
<         apply (intro comp_in_homI)
<          apply auto[1]
<         using E.antipar(2) E.ide_left by blast
---
>         using assms E.antipar(2) E.ide_left by blast
287c284
<         using assms E.antipar hseqI' isos_compose by auto
---
>         using assms E.antipar isos_compose by auto
289c286
<         using assms E.antipar hseqI' isos_compose iso_inv_iso by auto
---
>         using assms E.antipar isos_compose iso_inv_iso by auto
304,306c301
<         using assms E.unit_in_hom E.antipar hseqI'
<         apply (intro comp_in_homI, auto)
<         by (intro hcomp_in_vhom, auto)
---
>         using assms E.unit_in_hom E.antipar by auto
308,309c303
<         using assms E.counit_in_hom E.antipar ide_in_hom(2) vconn_implies_hpar(3) 
<         by (intro comp_in_homI, auto)
---
>         using assms E.counit_in_hom E.antipar ide_in_hom(2) vconn_implies_hpar(3) by auto
311c305
<         using assms E.antipar hseqI' isos_compose by auto
---
>         using assms E.antipar isos_compose by auto
313c307
<         using assms E.antipar hseqI' isos_compose iso_inv_iso by auto
---
>         using assms E.antipar isos_compose iso_inv_iso by auto
507,508c501
<         using hom.arr_char hom'.arr_char hseqI' in_hhom_def e\<^sub>0.antipar(1) e\<^sub>0.antipar(2)
<         by simp
---
>         using hom.arr_char hom'.arr_char in_hhom_def e\<^sub>0.antipar(1-2) by simp
513c506
<         using hom.arr_char hom.dom_char hom'.arr_char hom'.dom_char hseqI'
---
>         using hom.arr_char hom.dom_char hom'.arr_char hom'.dom_char
516c509
<         using hom.arr_char hom.cod_char hom'.arr_char hom'.cod_char hseqI'
---
>         using hom.arr_char hom.cod_char hom'.arr_char hom'.cod_char
520c513
<         using 1 hom.seq_char hom.arr_char hom.comp_char hom'.arr_char hom'.comp_char hseqI'
---
>         using 1 hom.seq_char hom.arr_char hom.comp_char hom'.arr_char hom'.comp_char
533c526
<         using hom.arr_char hom'.arr_char hseqI' in_hhom_def e\<^sub>1.antipar(1) e\<^sub>1.antipar(2)
---
>         using hom.arr_char hom'.arr_char in_hhom_def e\<^sub>1.antipar(1) e\<^sub>1.antipar(2)
539c532
<         using 1 hom.arr_char hom.dom_char hom'.arr_char hom'.dom_char hseqI'
---
>         using 1 hom.arr_char hom.dom_char hom'.arr_char hom'.dom_char
542c535
<         using 1 hom.arr_char hom.cod_char hom'.arr_char hom'.cod_char hseqI'
---
>         using 1 hom.arr_char hom.cod_char hom'.arr_char hom'.cod_char
546c539
<         using 1 hom'.seq_char hom'.arr_char hom'.comp_char hom.arr_char hom.comp_char hseqI'
---
>         using 1 hom'.seq_char hom'.arr_char hom'.comp_char hom.arr_char hom.comp_char
566,567c559
<         using assms e\<^sub>0.antipar e\<^sub>1.antipar
<         by (intro comp_in_homI, fastforce+)
---
>         using assms e\<^sub>0.antipar e\<^sub>1.antipar by fastforce
576c568
<       using assms iso_lunit' iso_runit' e\<^sub>0.antipar e\<^sub>1.antipar hseqI'
---
>       using assms iso_lunit' iso_runit' e\<^sub>0.antipar e\<^sub>1.antipar
579,582c571
<        apply (metis assoc'_simps(3) e\<^sub>0.ide_left e\<^sub>0.ide_right e\<^sub>1.ide_left e\<^sub>1.ide_right
<           iso_hcomp ideD(1) ide_is_iso in_hhomE iso_assoc' hcomp_simps(1))
<       by (metis assoc'_simps(3) e\<^sub>0.ide_left e\<^sub>0.ide_right e\<^sub>1.ide_left e\<^sub>1.ide_right iso_hcomp
<           ide_hcomp ideD(1) ide_is_iso in_hhomE iso_assoc' hcomp_simps(1-2))
---
>       by fastforce+
662c651
<               using \<mu> hom.arr_char comp_arr_dom comp_cod_arr hseqI'
---
>               using \<mu> hom.arr_char comp_arr_dom comp_cod_arr
678c667
<           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar hseqI' assoc'_naturality [of \<mu> d\<^sub>0 e\<^sub>0]
---
>           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar assoc'_naturality [of \<mu> d\<^sub>0 e\<^sub>0]
689c678
<           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar hseqI'
---
>           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar
699c688
<           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar hseqI'
---
>           using \<mu> hom.arr_char e\<^sub>0.antipar e\<^sub>1.antipar
797,799c786,813
<         using \<phi>\<^sub>0_in_hom(2) arr_iff_in_hom assms comp_in_hom_simp hom.cod_closed hom.inclusion
<               ide_cod
<         by presburger
---
>         using assms apply simp
>         apply (intro comp_in_homI)
>               apply auto
>       proof -
>         show "\<guillemotleft>\<r>\<^sup>-\<^sup>1[cod \<mu>] : cod \<mu> \<Rightarrow> cod \<mu> \<star> src e\<^sub>0\<guillemotright>"
>           using assms by auto
>         show "\<guillemotleft>\<l>\<^sup>-\<^sup>1[cod \<mu> \<star> src e\<^sub>0] : cod \<mu> \<star> src e\<^sub>0 \<Rightarrow> src e\<^sub>1 \<star> cod \<mu> \<star> src e\<^sub>0\<guillemotright>"
>           using assms by auto
>         show "\<guillemotleft>\<eta>\<^sub>1 \<star> cod \<mu> \<star> \<eta>\<^sub>0 : src e\<^sub>1 \<star> cod \<mu> \<star> src e\<^sub>0 \<Rightarrow> (d\<^sub>1 \<star> e\<^sub>1) \<star> cod \<mu> \<star> (d\<^sub>0 \<star> e\<^sub>0)\<guillemotright>"
>           using assms e\<^sub>0.unit_in_hom(2) e\<^sub>1.unit_in_hom(2)
>           apply (intro hcomp_in_vhom)
>               apply auto
>           by fastforce
>         show "\<guillemotleft>(d\<^sub>1 \<star> e\<^sub>1) \<star> \<a>\<^sup>-\<^sup>1[cod \<mu>, d\<^sub>0, e\<^sub>0] :
>                  (d\<^sub>1 \<star> e\<^sub>1) \<star> cod \<mu> \<star> d\<^sub>0 \<star> e\<^sub>0 \<Rightarrow> (d\<^sub>1 \<star> e\<^sub>1) \<star> (cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0\<guillemotright>"
>           using assms assoc'_in_hom e\<^sub>0.antipar(1-2) e\<^sub>1.antipar(2)
>           apply (intro hcomp_in_vhom) by auto
>         show "\<guillemotleft>\<a>[d\<^sub>1, e\<^sub>1, (cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0] :
>                 (d\<^sub>1 \<star> e\<^sub>1) \<star> (cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0 \<Rightarrow> d\<^sub>1 \<star> e\<^sub>1 \<star> (cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0\<guillemotright>"
>           using assms assoc_in_hom e\<^sub>0.antipar(1-2) e\<^sub>1.antipar(2) by auto
>         show "\<guillemotleft>d\<^sub>1 \<star> \<a>\<^sup>-\<^sup>1[e\<^sub>1, cod \<mu> \<star> d\<^sub>0, e\<^sub>0] :
>                  d\<^sub>1 \<star> e\<^sub>1 \<star> (cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0 \<Rightarrow> d\<^sub>1 \<star> (e\<^sub>1 \<star> cod \<mu> \<star> d\<^sub>0) \<star> e\<^sub>0\<guillemotright>"
>           using assms assoc'_in_hom [of "d\<^sub>1" "e\<^sub>1 \<star> cod \<mu> \<star> d\<^sub>0" "e\<^sub>0"]
>                 e\<^sub>0.antipar(1-2) e\<^sub>1.antipar(1-2)
>           apply (intro hcomp_in_vhom)
>             apply auto
>           by fastforce
>       qed
859c873
<           using assms e\<^sub>0.antipar(2) e\<^sub>1.antipar(2) hseqI' in_hhom_def by simp
---
>           using assms e\<^sub>0.antipar(2) e\<^sub>1.antipar(2) in_hhom_def by simp
895c909
<             using assms(2) e\<^sub>0.counit_is_iso e\<^sub>1.counit_is_iso hseqI' by simp
---
>             using assms(2) e\<^sub>0.counit_is_iso e\<^sub>1.counit_is_iso by simp
897,904c911,912
<         moreover have "inv ((e\<^sub>1 \<star> d\<^sub>1) \<star> \<a>\<^sup>-\<^sup>1[f', e\<^sub>0, d\<^sub>0]) = (e\<^sub>1 \<star> d\<^sub>1) \<star> \<a>[f', e\<^sub>0, d\<^sub>0]"
<           using assms e\<^sub>0.antipar e\<^sub>1.antipar hseqI' iso_inv_iso by auto
<         moreover have "inv \<a>[e\<^sub>1, d\<^sub>1, (f' \<star> e\<^sub>0) \<star> d\<^sub>0] = \<a>\<^sup>-\<^sup>1[e\<^sub>1, d\<^sub>1, (f' \<star> e\<^sub>0) \<star> d\<^sub>0]"
<           using assms e\<^sub>0.antipar e\<^sub>1.antipar hseqI' by auto
<         moreover have "inv (e\<^sub>1 \<star> \<a>\<^sup>-\<^sup>1[d\<^sub>1, f' \<star> e\<^sub>0, d\<^sub>0]) = e\<^sub>1 \<star> \<a>[d\<^sub>1, f' \<star> e\<^sub>0, d\<^sub>0]"
<           using assms e\<^sub>0.antipar e\<^sub>1.antipar iso_assoc hseqI' iso_inv_iso
<           by auto
<         ultimately show ?thesis by simp
---
>         ultimately show ?thesis
>           using assms e\<^sub>0.antipar e\<^sub>1.antipar iso_inv_iso by auto
969c977
<         using assms 0 1 \<psi>.preserves_hom hom'.in_hom_char hom'.arr_char hseqI'
---
>         using assms 0 1 \<psi>.preserves_hom hom'.in_hom_char hom'.arr_char
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Prebicategory.thy ../../AFPs/afp-2020/thys/Bicategory/Prebicategory.thy
952,963c952,963
<             have "H\<^sub>L a' (L.comp \<nu> \<mu>) = a' \<star> (\<nu> \<cdot> \<mu>)"
<               using \<mu> \<nu> H\<^sub>L_def L.comp_def by fastforce
<             also have "... = (a' \<star> \<nu>) \<cdot> (a' \<star> \<mu>)"
<             proof -
<               have "seq \<nu> \<mu>"
<                 using \<mu> \<nu> \<mu>\<nu> by (elim L.seqE, auto)
<               thus ?thesis
<                 using a' \<nu> whisker_left right_def by blast
<             qed
<             also have "... = L.comp (H\<^sub>L a' \<nu>) (H\<^sub>L a' \<mu>)"
<               using assms \<mu> 1 2 preserves_arr L.comp_char L.inclusion H\<^sub>L_def by auto
<             finally show ?thesis by blast
---
>           have "H\<^sub>L a' (L.comp \<nu> \<mu>) = a' \<star> (\<nu> \<cdot> \<mu>)"
>             using \<mu> \<nu> H\<^sub>L_def L.comp_def by fastforce
>           also have "... = (a' \<star> \<nu>) \<cdot> (a' \<star> \<mu>)"
>           proof -
>             have "seq \<nu> \<mu>"
>               using \<mu> \<nu> \<mu>\<nu> by (elim L.seqE, auto)
>             thus ?thesis
>               using a' \<nu> whisker_left right_def by blast
>           qed
>           also have "... = L.comp (H\<^sub>L a' \<nu>) (H\<^sub>L a' \<mu>)"
>             using assms \<mu> 1 2 preserves_arr L.comp_char L.inclusion H\<^sub>L_def by auto
>           finally show ?thesis by blast
2327c2327
<     lemma obj_simps [simp]:
---
>     lemma obj_simps (* [simp] *):
2516,2517c2516,2517
<   and src_hcomp: "\<nu> \<star> \<mu> \<noteq> null \<Longrightarrow> src (\<nu> \<star> \<mu>) = src \<mu>"
<   and trg_hcomp: "\<nu> \<star> \<mu> \<noteq> null \<Longrightarrow> trg (\<nu> \<star> \<mu>) = trg \<nu>"
---
>   and src_hcomp': "\<nu> \<star> \<mu> \<noteq> null \<Longrightarrow> src (\<nu> \<star> \<mu>) = src \<mu>"
>   and trg_hcomp': "\<nu> \<star> \<mu> \<noteq> null \<Longrightarrow> trg (\<nu> \<star> \<mu>) = trg \<nu>"
2971,2972c2971,2972
<   assumes src_hcomp': "arr (\<mu> \<star> \<nu>) \<Longrightarrow> src (\<mu> \<star> \<nu>) = src \<nu>"
<   and trg_hcomp': "arr (\<mu> \<star> \<nu>) \<Longrightarrow> trg (\<mu> \<star> \<nu>) = trg \<mu>"
---
>   assumes src_hcomp: "arr (\<mu> \<star> \<nu>) \<Longrightarrow> src (\<mu> \<star> \<nu>) = src \<nu>"
>   and trg_hcomp: "arr (\<mu> \<star> \<nu>) \<Longrightarrow> trg (\<mu> \<star> \<nu>) = trg \<mu>"
3026,3030c3026
<     (*
<      * The following is pretty useful as a simp, but it really slows things down,
<      * so it is not one by default.
<      *)
<     lemma hseqI' (* [simp] *):
---
>     lemma hseqI' [simp]:
3050,3051c3046,3047
<       using assms VV.arr_char src_hcomp' apply force
<       using assms VV.arr_char trg_hcomp' apply force
---
>       using assms VV.arr_char src_hcomp apply blast
>       using assms VV.arr_char trg_hcomp apply blast
3060c3056
<     lemma hcomp_in_hhom [intro, simp]:
---
>     lemma hcomp_in_hhom [intro]:
3064a3061,3065
>     lemma hcomp_in_hhom' (* [simp] *):
>     assumes "arr \<mu>" and "arr \<nu>" and "src \<mu> = a" and "trg \<nu> = c" and "src \<nu> = trg \<mu>"
>     shows "\<guillemotleft>\<nu> \<star> \<mu> : a \<rightarrow> c\<guillemotright>"
>       using assms hseq_char by fastforce
> 
3071c3072
<     lemma hcomp_in_vhom [intro, simp]:
---
>     lemma hcomp_in_vhom [intro]:
3074c3075,3082
<       using assms hseqI' by fastforce
---
>       using assms by fastforce
> 
>     lemma hcomp_in_vhom' [simp]:
>     assumes "hseq \<nu> \<mu>"
>     and "dom \<mu> = f" and "dom \<nu> = h" and "cod \<mu> = g" and "cod \<nu> = k"
>     assumes "\<guillemotleft>\<mu> : f \<Rightarrow> g\<guillemotright>" and "\<guillemotleft>\<nu> : h \<Rightarrow> k\<guillemotright>" and "src h = trg f"
>     shows "\<guillemotleft>\<nu> \<star> \<mu> : h \<star> f \<Rightarrow> k \<star> g\<guillemotright>"
>       using assms by fastforce
3082c3090
<       by (metis in_homE hseqE src_cod src_dom src_hcomp' trg_cod trg_dom trg_hcomp')
---
>       by (metis in_homE hseqE src_cod src_dom src_hcomp trg_cod trg_dom trg_hcomp)
3251,3252c3259
<       using VVV.arr_char VV.arr_char VVV.dom_char VVV.cod_char VVV.comp_char
<             HoHV_def hseqI'
---
>       using VVV.arr_char VV.arr_char VVV.dom_char VVV.cod_char VVV.comp_char HoHV_def
3280c3287
<             HoHV_def HoVH_def hseqI'
---
>             HoHV_def HoVH_def
3318c3325
<       using hseqI' vseq_implies_hpar(2) whisker_left
---
>       using vseq_implies_hpar(2) whisker_left
3323c3330
<       using hseqI' vseq_implies_hpar(1) whisker_right
---
>       using vseq_implies_hpar(1) whisker_right
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Pseudofunctor.thy ../../AFPs/afp-2020/thys/Bicategory/Pseudofunctor.thy
290c290
<           by (metis C.src_hcomp' C.trg_hcomp' D.in_hhom_def D.in_homE D.src_cod D.trg_cod
---
>           by (metis C.src_hcomp C.trg_hcomp D.in_hhom_def D.in_homE D.src_cod D.trg_cod
313c313
<         using assms \<Phi>.components_are_iso C.VV.ide_char C.VV.arr_char by simp
---
>         using assms C.VV.ide_char C.VV.arr_char by simp
319c319
<       using assms C.VV.ide_char C.VV.arr_char \<Phi>.components_are_iso by simp
---
>       using assms C.VV.ide_char C.VV.arr_char by simp
324c324
<       using assms \<Phi>_in_hom \<Phi>_components_are_iso D.isomorphic_def by auto
---
>       using assms D.isomorphic_def by auto
376c376
<         using assms \<Phi>_components_are_iso by auto
---
>         using assms by auto
380,381c380
<         using assms \<Phi>_in_hom C.unit_in_hom(2) C.obj_self_composable(1) C.seq_if_composable
<         by blast
---
>         using assms C.obj_self_composable(1) C.seq_if_composable by blast
571,572c570
<           using assms 1 D.lunit_in_hom \<Psi>_char(1-2) lF_char(1) D.ideD(1) D.hseqI'
<           by auto
---
>           using assms 1 D.lunit_in_hom \<Psi>_char(1-2) lF_char(1) D.ideD(1) by auto
577c575
<             using assms D.objE [of "map\<^sub>0 (trg\<^sub>C f)"] D.hseqI'
---
>             using assms D.objE [of "map\<^sub>0 (trg\<^sub>C f)"]
585c583
<               using assms \<Psi>_char(1-2) D.hseqI'
---
>               using assms \<Psi>_char(1-2)
679c677
<               using assms \<Phi>_in_hom by fastforce
---
>               using assms by fastforce
688c686
<                     C.ideD(1) C.ide_hcomp C.trg_hcomp' C.trg_trg C.src_trg C.trg.preserves_ide
---
>                     C.ideD(1) C.ide_hcomp C.trg_hcomp C.trg_trg C.src_trg C.trg.preserves_ide
697,699c695
<                 using assms 1 \<Phi>_in_hom \<Phi>_components_are_iso preserves_hseq preserves_inv
<                       preserves_iso D.hseq_char
<                 by auto
---
>                 using assms 1 D.hseq_char by auto
704c700
<                 using assms 2 \<Phi>_in_hom by simp
---
>                 using assms 2 by simp
706c702
<                 using assms \<Phi>_components_are_iso D.iso_assoc
---
>                 using assms
711c707
<                 by simp    
---
>                 by fastforce
722c718
<               using assms C.lunit_char(1-2) C.unit_in_hom preserves_inv C.hseqI' by auto
---
>               using assms C.lunit_char(1-2) C.unit_in_hom preserves_inv by auto
728c724
<                 by (simp add: C.hseqI' C.iso_unit D.inv_comp)
---
>                 by (simp add: C.iso_unit D.inv_comp)
770,776c766,768
<             proof -
<               have "D.inv (\<Phi> (?b, ?b \<star>\<^sub>C f)) \<cdot>\<^sub>D \<Phi> (?b, ?b \<star>\<^sub>C f) = F ?b \<star>\<^sub>D F (?b \<star>\<^sub>C f)"
<                 using assms D.comp_inv_arr \<Phi>_components_are_iso D.comp_inv_arr' \<Phi>_simps(4)
<                 by auto
<               thus ?thesis
<                 using assms D.comp_arr_dom D.comp_assoc D.hseqI' by simp
<             qed
---
>               using assms D.comp_inv_arr D.comp_inv_arr' \<Phi>_simps(4)
>                     D.comp_arr_dom D.comp_assoc
>               by simp
787c779
<                   using assms \<Phi>_in_hom(2) [of ?b f] D.hseqI' by auto
---
>                   using assms \<Phi>_in_hom(2) [of ?b f] by auto
789c781
<                   using assms \<Phi>_components_are_iso by simp
---
>                   using assms by simp
791,793c783
<                 using 1 D.invert_opposite_sides_of_square
<                           [of "\<Phi> (?b, f)" "F ?b \<star>\<^sub>D F \<l>\<^sub>C[f]" "F (?b \<star>\<^sub>C \<l>\<^sub>C[f])" "\<Phi> (?b, ?b \<star>\<^sub>C f)"]
<                   by simp
---
>                 using 1 D.invert_opposite_sides_of_square by simp
801,803c791
<                 using assms \<Phi>_components_are_iso D.isos_compose C.VV.arr_char C.iso_lunit
<                       C.hseqI'
<                 by simp
---
>                 using assms D.isos_compose C.VV.arr_char C.iso_lunit by simp
807,808c795
<                 using assms \<Phi>_in_hom(2) [of ?b f] \<Phi>_components_are_iso C.VV.arr_char C.hseqI'
<                 by simp
---
>                 using assms C.VV.arr_char by simp
810c797
<                 using assms \<Phi>_components_are_iso D.inv_comp by simp
---
>                 using assms D.inv_comp by simp
816,818c803
<                 using assms \<Phi>_components_are_iso D.isos_compose C.VV.arr_char C.iso_lunit
<                       D.inv_comp C.hseqI'
<                 by simp
---
>                 using assms D.isos_compose C.VV.arr_char C.iso_lunit D.inv_comp by simp
829,831c814
<             using assms D.comp_arr_inv' [of "F ?b \<star>\<^sub>D F \<l>\<^sub>C[f]"] D.comp_cod_arr preserves_iso
<                   D.hseqI'
<             by simp
---
>             using assms D.comp_arr_inv' [of "F ?b \<star>\<^sub>D F \<l>\<^sub>C[f]"] D.comp_cod_arr by simp
910c893
<       using VV.arr_char B.hseqI'
---
>       using VV.arr_char
918c901
<       by (unfold_locales, simp_all)
---
>       by (unfold_locales, auto)
1192c1175
<             \<Phi>.is_extensional \<Phi>.is_natural_1 \<Phi>.is_natural_2 \<Phi>.components_are_iso
---
>             \<Phi>.is_extensional \<Phi>.is_natural_1 \<Phi>.is_natural_2
1212c1195
<             using f g h fg gh preserves_hom \<Phi>.preserves_hom by auto
---
>             using f g h fg gh by auto
1214,1216c1197
<             using f g h fg gh preserves_hom \<Phi>.preserves_hom C.VV.in_hom_char
<                   FF_def C.VV.arr_char D.hseqI'
<             by auto
---
>             using f g h fg gh C.VV.in_hom_char FF_def C.VV.arr_char by auto
1295c1276
<           using assms \<Phi>_components_are_iso \<Psi>_char D.iso_hcomp FF_def D.hseqI'
---
>           using assms \<Psi>_char D.iso_hcomp FF_def
1305,1307c1286
<         using assms \<Phi>_in_hom \<Phi>_components_are_iso C.VV.arr_char \<Psi>_char
<               D.iso_hcomp FF_def D.hseqI' D.inv_comp
<         by simp
---
>         using assms C.VV.arr_char \<Psi>_char FF_def D.inv_comp by simp
1313c1292
<         using assms preserves_inv C.iso_lunit by simp
---
>         using assms preserves_inv by simp
1317c1296
<           using assms D.iso_lunit by simp
---
>           using assms by simp
1331c1310,1311
<           by (elim conjE D.in_homE, auto simp add: D.inv_comp)
---
>           apply (elim conjE D.in_homE)
>           by (auto simp add: D.inv_comp)
1347c1327
<           using assms \<Phi>_components_are_iso \<Psi>_char D.iso_hcomp FF_def D.hseqI'
---
>           using assms \<Psi>_char D.iso_hcomp FF_def
1358,1360c1338
<         using assms \<Phi>_in_hom \<Phi>_components_are_iso C.VV.arr_char \<Psi>_char
<               D.iso_hcomp FF_def D.hseqI' D.inv_comp
<         by simp
---
>         using assms C.VV.arr_char \<Psi>_char D.iso_hcomp FF_def D.inv_comp by simp
1379c1357
<           using assms \<Phi>_in_hom \<Phi>_components_are_iso D.iso_inv_iso by simp
---
>           using assms \<Phi>_in_hom D.iso_inv_iso by simp
1403c1381
<         using assms \<Phi>_components_are_iso C.VV.arr_char FF_def D.hseqI' by auto
---
>         using assms C.VV.arr_char FF_def by auto
1405c1383
<         using assms \<Phi>_components_are_iso C.VV.arr_char FF_def D.hseqI' by auto
---
>         using assms C.VV.arr_char FF_def by auto
1408,1409c1386
<         using assms 1 \<Phi>_components_are_iso C.VV.arr_char FF_def D.inv_comp D.hseqI'
<         by simp
---
>         using assms 1 C.VV.arr_char FF_def D.inv_comp by simp
1426c1403
<           using assms \<Phi>_components_are_iso by auto
---
>           using assms by auto
1429c1406
<           using assms \<Phi>_components_are_iso
---
>           using assms
1437,1438c1414
<           using assms \<Phi>_components_are_iso D.iso_inv_iso
<           by (intro conjI D.hcomp_in_vhom, auto)
---
>           using assms D.iso_inv_iso by auto
1442c1418
<           using assms \<Phi>_components_are_iso D.iso_inv_iso by auto
---
>           using assms D.iso_inv_iso by auto
1444,1446c1420,1422
<           using assms \<Phi>_components_are_iso D.isos_compose D.inv_comp
<                 D.comp_assoc D.iso_inv_iso
<           apply (elim conjE D.in_homE) by (auto simp add: D.inv_comp)
---
>           using assms D.isos_compose D.comp_assoc D.iso_inv_iso
>           apply (elim conjE D.in_homE)
>           by (auto simp add: D.inv_comp)
1503c1479
<           using antipar \<Psi>_in_hom \<Phi>_components_are_iso D.iso_inv_iso FF_def unit_is_iso
---
>           using antipar D.iso_inv_iso FF_def unit_is_iso
1507,1509c1483,1484
<           using antipar \<Psi>_in_hom(2) \<Psi>_char(2) C.VV.ide_char C.VV.arr_char FF_def
<                 \<Phi>_in_hom(2) D.iso_inv_iso counit_is_iso preserves_iso \<Phi>_components_are_iso
<                 D.isos_compose
---
>           using antipar \<Psi>_char(2) C.VV.ide_char C.VV.arr_char FF_def
>                 D.iso_inv_iso D.isos_compose
1704,1705c1679
<               using 0 `C.ide f` `C.ide g` \<Phi>_in_hom \<Phi>_components_are_iso
<               by simp
---
>               using 0 `C.ide f` `C.ide g` \<Phi>_in_hom by simp
1743c1717
<                     \<Phi>_components_are_iso D.inv_in_hom D.iso_inv_iso
---
>                     D.inv_in_hom D.iso_inv_iso
1814c1788
<           using assms g \<Phi>_components_are_iso by auto
---
>           using assms g by auto
1818,1823c1792
<           apply (intro D.isos_compose)
<                   apply simp_all
<              apply (meson D.iso_hcomp D.hseqE D.seqE E''.unit_simps(1) components_are_iso)
<             apply (meson D.arrI D.seqE)
<            apply (meson D.arrI D.seqE)
<           by (meson D.arrI D.seqE)
---
>           apply (intro D.isos_compose) by auto
2211,2215c2180,2182
<         using assms \<phi>_props D.hseqI' d_simps e_simps D.src_cod D.trg_cod
<         apply (intro D.in_hhomI)
<           apply auto[1]
<          apply (metis D.arr_cod D.hseqI' D.ideD(1) D.in_homE D.obj_src D.hcomp_simps(1))
<         by (metis D.arr_cod D.ideD(1) D.in_homE D.obj_trg D.hcomp_simps(2))
---
>         using assms \<phi>_props d_simps e_simps
>               D.src_cod [of "\<phi> f'"] D.trg_cod [of "\<phi> f'"]
>         by fastforce
2229c2196
<       show "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.arr (G \<mu>')"
---
>       show A: "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.arr (G \<mu>')"
2231c2198
<       show "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.dom (G \<mu>') = G (D.dom \<mu>')"
---
>       show D: "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.dom (G \<mu>') = G (D.dom \<mu>')"
2250c2217
<       show "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.cod (G \<mu>') = G (D.cod \<mu>')"
---
>       show C: "\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.cod (G \<mu>') = G (D.cod \<mu>')"
2295,2297c2262
<             using \<mu> \<nu> \<mu>\<nu> D.obj_src G\<^sub>0_props(4)
<             apply (intro D.seqI D.hseqI, auto)
<             using D.hseqI' by fastforce
---
>             using \<mu> \<nu> \<mu>\<nu> D.obj_src G\<^sub>0_props(4) by fastforce
2314c2279
<             using \<mu> \<nu> G\<^sub>0_props(3-4) D.obj_src D.obj_trg D.hseqI' \<mu>\<nu> \<phi>_props
---
>             using \<mu> \<nu> G\<^sub>0_props(3-4) D.obj_src D.obj_trg \<mu>\<nu> \<phi>_props
2328,2331c2293
<           using \<mu>\<nu> G_props D.seqE \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.arr (G \<mu>')\<close>
<             \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.cod (G \<mu>') = G (D.cod \<mu>')\<close>
<             \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.dom (G \<mu>') = G (D.dom \<mu>')\<close>
<           by auto
---
>           using \<mu>\<nu> A D C G_props D.seqE by auto
2334,2344c2296,2300
<         thus "G (\<mu> \<cdot>\<^sub>D \<nu>) = G \<mu> \<cdot>\<^sub>C G \<nu>"
<           using \<mu>\<nu> G_props F.is_faithful [of "G (\<mu> \<cdot>\<^sub>D \<nu>)" "G \<mu> \<cdot>\<^sub>C G \<nu>"]
<           (*
<            * TODO: Here supposedly weak_arrow_of_homs_def is not used, but the proof does not
<            * succeed without it.
<            *)
<           by (metis D.seqE \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.arr (G \<mu>')\<close>
<               \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.cod (G \<mu>') = G (D.cod \<mu>')\<close>
<               \<open>\<And>\<mu>'. D.arr \<mu>' \<Longrightarrow> C.dom (G \<mu>') = G (D.dom \<mu>')\<close>
<               C.dom_comp D.dom_comp C.cod_comp D.cod_comp F.preserves_reflects_arr
<               weak_arrow_of_homs_def)
---
>         moreover have "C.par (G (\<mu> \<cdot>\<^sub>D \<nu>)) (G \<mu> \<cdot>\<^sub>C G \<nu>)"
>           using \<mu>\<nu> A D C G_props
>           apply (intro conjI C.seqI) by auto
>         ultimately show "G (\<mu> \<cdot>\<^sub>D \<nu>) = G \<mu> \<cdot>\<^sub>C G \<nu>"
>           using F.is_faithful [of "G (\<mu> \<cdot>\<^sub>D \<nu>)" "G \<mu> \<cdot>\<^sub>C G \<nu>"] by blast
2492c2448
<                   using \<mu>'\<nu>' by auto
---
>                   using \<mu>'\<nu>' by fastforce
2603c2559
<         using assms e_trg_f.unit_is_iso D.hseqI' by auto
---
>         using assms e_trg_f.unit_is_iso by auto
2606c2562
<         using assms e_trg_f.unit_is_iso D.hseqI' by auto
---
>         using assms e_trg_f.unit_is_iso by auto
2627c2583
<         using assms e_src_f.unit_is_iso D.hseqI' by auto
---
>         using assms e_src_f.unit_is_iso by auto
2630c2586
<         using assms e_src_f.unit_is_iso D.hseqI' by auto
---
>         using assms e_src_f.unit_is_iso by auto
2754,2756c2710
<         using assms D.whisker_left [of f "\<r>\<^sub>D[g]" "g \<star>\<^sub>D D.inv (\<eta> (src\<^sub>D g))"] e_src_g.unit_is_iso
<               D.hseqI' D.comp_assoc
<         by simp
---
>         using assms D.whisker_left e_src_g.unit_is_iso D.comp_assoc by simp
2819,2820c2773
<         using assms D.src_cod [of "CMP f g"] D.trg_cod [of "CMP f g"] D.hseqI'
<         by fastforce
---
>         using assms D.src_cod D.trg_cod by fastforce
2881c2834
<             using assms G\<^sub>0_props D.hseqI' by auto
---
>             using assms G\<^sub>0_props by auto
2883c2836
<             using assms G\<^sub>0_props D.hseqI' by auto
---
>             using assms G\<^sub>0_props by auto
2885c2838
<             using assms G\<^sub>0_props by (simp add: D.hseqI')
---
>             using assms G\<^sub>0_props by simp
2887,2891c2840
<              using assms G\<^sub>0_props
<                   D.interchange
<                     [of "(e (trg\<^sub>D \<mu>) \<star>\<^sub>D \<mu>) \<star>\<^sub>D d (src\<^sub>D \<mu>)" "\<a>\<^sub>D\<^sup>-\<^sup>1[e (trg\<^sub>D \<mu>), D.dom \<mu>, d (src\<^sub>D \<mu>)]"
<                         "XLT \<nu>" "XLT (D.dom \<nu>)"]
<              by simp
---
>              using assms G\<^sub>0_props D.interchange by simp
2916c2865
<           by (simp add: D.hseqI')
---
>           by simp
2934c2883
<           using assms D.hseqI' D.assoc_naturality [of "e (trg\<^sub>D \<mu>)" \<mu> "d (src\<^sub>D \<mu>) \<star>\<^sub>D XLT \<nu>"]
---
>           using assms D.assoc_naturality [of "e (trg\<^sub>D \<mu>)" \<mu> "d (src\<^sub>D \<mu>) \<star>\<^sub>D XLT \<nu>"]
2961c2910
<             using assms D.hseqI' G\<^sub>0_props D.whisker_left by simp
---
>             using assms G\<^sub>0_props D.whisker_left by simp
2965c2914
<             using assms D.hseqI' D.comp_cod_arr
---
>             using assms D.comp_cod_arr
2972c2921
<             using assms D.hseqI' G\<^sub>0_props
---
>             using assms G\<^sub>0_props
2977c2926
<             using assms D.hseqI' G\<^sub>0_props D.comp_arr_dom
---
>             using assms G\<^sub>0_props D.comp_arr_dom
2981c2930
<             by simp
---
>             by fastforce
2986c2935
<             using assms D.hseqI' G\<^sub>0_props D.whisker_left by simp
---
>             using assms G\<^sub>0_props D.whisker_left by simp
3007c2956
<           using assms D.hseqI' D.comp_arr_dom D.comp_cod_arr D.whisker_left
---
>           using assms D.comp_arr_dom D.comp_cod_arr D.whisker_left
3013c2962
<           using assms D.hseqI' LUNIT_naturality [of "\<nu> \<star>\<^sub>D d (src\<^sub>D \<nu>)"] by simp
---
>           using assms LUNIT_naturality [of "\<nu> \<star>\<^sub>D d (src\<^sub>D \<nu>)"] by simp
3016c2965
<           using assms D.hseqI' D.comp_arr_dom D.comp_cod_arr D.whisker_left
---
>           using assms D.comp_arr_dom D.comp_cod_arr D.whisker_left
3045,3047c2994
<             using assms D.hseqI'
<                   D.whisker_left [of "e (trg\<^sub>D \<mu>)" "\<a>\<^sub>D\<^sup>-\<^sup>1[D.cod \<mu>, D.cod \<nu>, d (src\<^sub>D \<nu>)]"]
<             by simp
---
>             using assms D.whisker_left by simp
3050c2997
<             using assms D.hseqI' D.assoc'_naturality [of \<mu> \<nu> "d (src\<^sub>D \<nu>)"] by simp
---
>             using assms D.assoc'_naturality [of \<mu> \<nu> "d (src\<^sub>D \<nu>)"] by simp
3052c2999
<             using assms D.hseqI' D.whisker_left by simp
---
>             using assms D.whisker_left by simp
3142c3089
<           using assms D.hseqI' D.whisker_right by simp (* 15 sec *)
---
>           using assms D.whisker_right by simp (* 15 sec *)
3165c3112
<           using assms LUNIT_hcomp [of h "d (src\<^sub>D h)"] D.hseqI' D.invert_side_of_triangle
---
>           using assms LUNIT_hcomp [of h "d (src\<^sub>D h)"] D.invert_side_of_triangle
3169c3116
<           using assms D.whisker_left D.hseqI' by simp
---
>           using assms D.whisker_left by simp
3197c3144
<           using assms D.whisker_left D.hseqI' by simp
---
>           using assms D.whisker_left by simp
3204c3151
<           using assms D.whisker_left D.hseqI' by simp
---
>           using assms D.whisker_left by simp
3232c3179
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3235c3182
<           using assms D.hseqI' D.assoc_naturality [of f g "LUNIT h"] by simp
---
>           using assms D.assoc_naturality [of f g "LUNIT h"] by simp
3239c3186
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3268c3215
<           using assms TRIANGLE [of f "g \<star>\<^sub>D d (src\<^sub>D g)"] D.invert_side_of_triangle D.hseqI'
---
>           using assms TRIANGLE [of f "g \<star>\<^sub>D d (src\<^sub>D g)"] D.invert_side_of_triangle
3272c3219
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3302c3249
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3308c3255
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3339c3286
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3342c3289
<           using assms D.hseqI' D.assoc'_naturality [of "e (trg\<^sub>D f)" "RUNIT f \<star>\<^sub>D g" "d (src\<^sub>D g)"]
---
>           using assms D.assoc'_naturality [of "e (trg\<^sub>D f)" "RUNIT f \<star>\<^sub>D g" "d (src\<^sub>D g)"]
3346c3293
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
3377c3324
<           using assms D.hseqI'  
---
>           using assms  
3405c3352
<           using assms D.hseqI'
---
>           using assms
3432c3379
<           using assms D.hseqI' D.comp_cod_arr D.whisker_left [of "e (trg\<^sub>D f)"]
---
>           using assms D.comp_cod_arr D.whisker_left
3437c3384
<           using assms D.hseqI' D.comp_arr_dom by simp
---
>           using assms D.comp_arr_dom by simp
3471c3418
<           using assms D.hseqI' D.comp_arr_dom D.comp_cod_arr D.whisker_left
---
>           using assms D.comp_arr_dom D.comp_cod_arr D.whisker_left
3480c3427
<           using assms D.hseqI' D.comp_arr_dom D.whisker_left
---
>           using assms D.comp_arr_dom D.whisker_left
3518c3465
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3533c3480
<             using assms D.hseqI' D.iso_inv_iso by simp
---
>             using assms D.iso_inv_iso by simp
3535c3482
<             using assms D.hseqI' D.iso_inv_iso D.comp_assoc
---
>             using assms D.iso_inv_iso D.comp_assoc
3547c3494
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3581c3528
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3590c3537
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3624c3571
<           using assms D.hseqI' D.whisker_left D.comp_arr_dom D.comp_cod_arr
---
>           using assms D.whisker_left D.comp_arr_dom D.comp_cod_arr
3633,3634c3580
<           using assms D.hseqI' TRIANGLE [of f "g \<star>\<^sub>D (TRG h \<star>\<^sub>D h) \<star>\<^sub>D d (src\<^sub>D h)"]
<           by simp
---
>           using assms TRIANGLE [of f "g \<star>\<^sub>D (TRG h \<star>\<^sub>D h) \<star>\<^sub>D d (src\<^sub>D h)"] by simp
3641c3587
<           using assms D.hseqI' D.whisker_left D.comp_assoc by simp
---
>           using assms D.whisker_left D.comp_assoc by simp
3677c3623
<           using assms D.hseqI' LUNIT_hcomp [of g "(TRG h \<star>\<^sub>D h) \<star>\<^sub>D d (src\<^sub>D h)"]
---
>           using assms LUNIT_hcomp [of g "(TRG h \<star>\<^sub>D h) \<star>\<^sub>D d (src\<^sub>D h)"]
3682c3628
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3717c3663
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3721,3722c3667
<           using assms D.hseqI'
<                 D.assoc'_naturality [of "LUNIT g" "TRG h \<star>\<^sub>D h" "d (src\<^sub>D h)"]
---
>           using assms D.assoc'_naturality [of "LUNIT g" "TRG h \<star>\<^sub>D h" "d (src\<^sub>D h)"]
3726c3671
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3762c3707
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3766,3767c3711
<           using assms D.hseqI'
<                 D.assoc'_naturality [of f "LUNIT g \<star>\<^sub>D TRG h \<star>\<^sub>D h" "d (src\<^sub>D h)"]
---
>           using assms D.assoc'_naturality [of f "LUNIT g \<star>\<^sub>D TRG h \<star>\<^sub>D h" "d (src\<^sub>D h)"]
3771c3715
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3804c3748
<           using assms D.hseqI' D.whisker_left D.whisker_right D.comp_arr_dom D.comp_cod_arr
---
>           using assms D.whisker_left D.whisker_right D.comp_arr_dom D.comp_cod_arr
3877c3821
<           using assms D.hseqI' D.whisker_left by auto (* 15 sec *)
---
>           using assms D.whisker_left by auto (* 15 sec *)
3901c3845
<           using assms D.hseqI' LUNIT_hcomp [of "g \<star>\<^sub>D h" "d (src\<^sub>D h)"]
---
>           using assms LUNIT_hcomp [of "g \<star>\<^sub>D h" "d (src\<^sub>D h)"]
3906c3850
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3934c3878
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3938c3882
<           using assms D.hseqI' D.assoc'_naturality [of f "LUNIT (g \<star>\<^sub>D h)" "d (src\<^sub>D h)"]
---
>           using assms D.assoc'_naturality [of f "LUNIT (g \<star>\<^sub>D h)" "d (src\<^sub>D h)"]
3943c3887
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
3973c3917
<           using assms D.hseqI' TRIANGLE [of g "h \<star>\<^sub>D d (src\<^sub>D h)"] D.invert_side_of_triangle
---
>           using assms TRIANGLE [of g "h \<star>\<^sub>D d (src\<^sub>D h)"] D.invert_side_of_triangle
3977c3921
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4005c3949
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4009c3953
<           using assms D.hseqI' D.assoc'_naturality [of "RUNIT g" h "d (src\<^sub>D h)"] by auto
---
>           using assms D.assoc'_naturality [of "RUNIT g" h "d (src\<^sub>D h)"] by auto
4012c3956
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4044c3988
<           using assms D.hseqI' D.comp_arr_dom D.comp_cod_arr
---
>           using assms D.comp_arr_dom D.comp_cod_arr
4053c3997
<           using assms D.hseqI' D.comp_arr_dom D.comp_cod_arr
---
>           using assms D.comp_arr_dom D.comp_cod_arr
4095c4039
<           using assms D.hseqI'
---
>           using assms
4127c4071
<           using assms D.hseqI'
---
>           using assms
4161c4105
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4165c4109
<           using assms D.hseqI'
---
>           using assms
4172c4116
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4207c4151
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4211,4212c4155
<           using assms D.hseqI'
<                 D.assoc'_naturality [of "TRG g" "RUNIT g \<star>\<^sub>D h" "d (src\<^sub>D h)"]
---
>           using assms D.assoc'_naturality [of "TRG g" "RUNIT g \<star>\<^sub>D h" "d (src\<^sub>D h)"]
4217c4160
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4251c4194
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4255c4198
<           using assms D.hseqI'
---
>           using assms
4261c4204
<           using assms D.hseqI' D.whisker_left by simp
---
>           using assms D.whisker_left by simp
4293c4236
<           using assms D.hseqI' TRIANGLE [of g h] by simp
---
>           using assms TRIANGLE [of g h] by simp
4296c4239
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
4328c4271
<           using assms D.hseqI' LUNIT_hcomp [of g h] D.invert_side_of_triangle by simp
---
>           using assms LUNIT_hcomp [of g h] D.invert_side_of_triangle by simp
4331c4274
<           using assms D.hseqI' D.whisker_left D.whisker_right by simp
---
>           using assms D.whisker_left D.whisker_right by simp
4365c4308
<           using assms D.hseqI' D.whisker_left D.whisker_right by auto
---
>           using assms D.whisker_left D.whisker_right by auto
4369c4312
<           using assms D.hseqI' D.assoc'_naturality [of "TRG g" g "LUNIT h"] by auto
---
>           using assms D.assoc'_naturality [of "TRG g" g "LUNIT h"] by auto
4372c4315
<           using assms D.hseqI' D.whisker_left D.whisker_right by auto
---
>           using assms D.whisker_left D.whisker_right by auto
4406c4349
<           using assms D.hseqI' D.whisker_left D.whisker_right D.comp_arr_dom D.comp_cod_arr
---
>           using assms D.whisker_left D.whisker_right D.comp_arr_dom D.comp_cod_arr
4637,4638c4580
<             using assms C.hseqI' D.hseqI' F.preserves_hcomp C.VV.arr_char F.FF_def
<             by (intro D.seqI D.hseqI, auto)
---
>             using assms F.preserves_hcomp C.VV.arr_char F.FF_def by auto
4640c4582
<             using assms F.\<Phi>_components_are_iso D.invert_opposite_sides_of_square by simp
---
>             using assms D.invert_opposite_sides_of_square by simp
4660c4602
<             using assms D.interchange D.hseqI' by simp
---
>             using assms D.interchange by simp
4679c4621
<           using assms D.hseqI' \<phi>.naturality [of "\<mu> \<star>\<^sub>D \<nu>"] \<phi>_props(2)
---
>           using assms \<phi>.naturality [of "\<mu> \<star>\<^sub>D \<nu>"] \<phi>_props(2)
4712c4654
<           using 1 \<mu>_def \<nu>_def \<mu> \<nu> \<mu>\<nu> \<Phi>\<^sub>0_props D.VV.arr_char C.hseqI' FF_def by simp
---
>           using 1 \<mu>_def \<nu>_def \<mu> \<nu> \<mu>\<nu> \<Phi>\<^sub>0_props D.VV.arr_char FF_def by simp
4724,4725c4666,4667
<           using \<mu>_def \<nu>_def \<mu> \<nu> \<mu>\<nu> C.hseqI'
<                 \<Phi>\<^sub>0_props D.VV.arr_char D.VV.dom_char D.VV.cod_char D.VV.ide_char FF_def
---
>           using \<mu>_def \<nu>_def \<mu> \<nu> \<mu>\<nu> \<Phi>\<^sub>0_props D.VV.arr_char D.VV.dom_char D.VV.cod_char
>                 D.VV.ide_char FF_def
4742,4745c4684
<         using assms D.VV.arr_char D.VV.dom_char D.VV.cod_char \<Phi>.map_def FF_def
<         apply auto
<         apply (intro C.comp_in_homI, auto)
<         by (intro C.hcomp_in_vhom, auto)
---
>         using assms D.VV.arr_char D.VV.dom_char D.VV.cod_char \<Phi>.map_def FF_def by simp
4747,4752c4686
<         apply (intro C.in_hhomI)
<           apply auto
<          apply (metis (no_types, lifting) C.arr_dom C.in_homE C.hcomp_simps(1)
<                 C.src_dom [of "\<Phi> (\<mu>', \<nu>')"])
<         by (metis (no_types, lifting) C.in_homE C.trg_cod D.arr_cod D.hseqI'
<             D.src_cod D.trg_cod D.trg_hcomp' assms(1-3) preserves_trg)
---
>         using assms C.src_dom [of "\<Phi> (\<mu>', \<nu>')"] C.trg_dom [of "\<Phi> (\<mu>', \<nu>')"] by auto
4794,4796c4728,4729
<           using f g fg D.VV.arr_char D.iso_inv_iso F.\<Phi>_components_are_iso \<phi>_props D.hseqI'
<                 e_trg_g.unit_is_iso iso_LUNIT
<           apply (intro D.isos_compose) by simp_all (* 17 subgoals, 40 sec. *)
---
>           using f g fg D.VV.arr_char D.iso_inv_iso \<phi>_props e_trg_g.unit_is_iso iso_LUNIT
>           apply (intro D.isos_compose) by simp_all (* 17 subgoals, 30 sec. *)
4934,4946c4867
<           proof -
<             have "D.inv (\<phi> (f \<star>\<^sub>D g)) \<cdot>\<^sub>D CMP f g \<cdot>\<^sub>D (\<phi> f \<star>\<^sub>D \<phi> g) \<cdot>\<^sub>D D.inv (\<Phi>\<^sub>F (G f, G g))
<                      \<star>\<^sub>D F (G h) =
<                   (D.inv (\<phi> (f \<star>\<^sub>D g)) \<star>\<^sub>D F (G h)) \<cdot>\<^sub>D
<                     (CMP f g \<star>\<^sub>D F (G h)) \<cdot>\<^sub>D 
<                     ((\<phi> f \<star>\<^sub>D \<phi> g) \<star>\<^sub>D F (G h)) \<cdot>\<^sub>D
<                     (D.inv (\<Phi>\<^sub>F (G f, G g)) \<star>\<^sub>D F (G h))"
<               using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                     D.whisker_right
<               by auto
<             thus ?thesis
<               using D.comp_assoc by simp
<           qed
---
>             using f g h fg gh \<phi>_props(2) D.whisker_right D.comp_assoc by simp
4958,4960c4879
<               using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                     D.comp_arr_inv' D.comp_cod_arr
<               by simp
---
>               using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_cod_arr by simp
4965,4967c4884,4885
<               using f g h fg gh F.\<Phi>_in_hom [of "G (f \<star>\<^sub>D g)" "G h"]
<                     F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                     D.comp_arr_inv' D.comp_inv_arr' D.comp_arr_dom D.comp_cod_arr
---
>               using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_inv_arr'
>                     D.comp_arr_dom D.comp_cod_arr
4996c4914
<               using f g h fg gh D.comp_arr_dom D.comp_cod_arr D.hseqI'
---
>               using f g h fg gh D.comp_arr_dom D.comp_cod_arr
5065,5066c4983
<             using f g h fg gh F.preserves_hcomp D.comp_assoc
<             by (simp add: C.hseqI')
---
>             using f g h fg gh F.preserves_hcomp D.comp_assoc by simp
5097,5108c5014,5015
<           proof -
<             have "F (G f) \<star>\<^sub>D
<                     D.inv (\<phi> (g \<star>\<^sub>D h)) \<cdot>\<^sub>D CMP g h \<cdot>\<^sub>D (\<phi> g \<star>\<^sub>D \<phi> h) \<cdot>\<^sub>D D.inv (\<Phi>\<^sub>F (G g, G h)) =
<                   (F (G f) \<star>\<^sub>D D.inv (\<phi> (g \<star>\<^sub>D h))) \<cdot>\<^sub>D
<                     (F (G f) \<star>\<^sub>D CMP g h \<cdot>\<^sub>D (\<phi> g \<star>\<^sub>D \<phi> h)) \<cdot>\<^sub>D
<                     (F (G f) \<star>\<^sub>D D.inv (\<Phi>\<^sub>F (G g, G h)))"
<               using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                     D.whisker_left
<               by (simp add: D.comp_assoc)
<             thus ?thesis
<               using D.comp_assoc by simp
<           qed
---
>             using f g h fg gh \<phi>_props(2) D.whisker_left
>             by (simp add: D.comp_assoc)
5137,5138c5044
<                 using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                       D.comp_arr_inv' D.comp_inv_arr' D.comp_cod_arr
---
>                 using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_inv_arr' D.comp_cod_arr
5141,5142c5047,5048
<                 using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                       D.comp_arr_inv' D.comp_inv_arr' D.comp_arr_dom D.comp_cod_arr
---
>                 using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_inv_arr'
>                       D.comp_arr_dom D.comp_cod_arr
5146,5147c5052
<                 using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                       D.comp_arr_dom D.comp_cod_arr
---
>                 using f g h fg gh \<phi>_props(2) D.comp_arr_dom D.comp_cod_arr
5149c5054
<                 by simp (* 15 sec *)
---
>                 by simp
5174,5175c5079,5080
<                 using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                       D.comp_arr_inv' D.comp_inv_arr' D.comp_arr_dom D.comp_cod_arr
---
>                 using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_inv_arr'
>                       D.comp_arr_dom D.comp_cod_arr
5180c5085
<               proof -
---
>                proof -
5182,5183c5087
<                   using f g h fg gh
<                   apply (intro D.seqI) by auto
---
>                   using f g h fg gh by force
5185,5186c5089
<                   using f g h fg gh F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI' D.comp_cod_arr
<                   by auto
---
>                   using f g h fg gh \<phi>_props(2) D.comp_cod_arr by auto
5189,5190c5092,5093
<                 using f g h fg gh F.\<Phi>_in_hom F.\<Phi>_components_are_iso \<phi>_props(2) D.hseqI'
<                       D.comp_arr_inv' D.comp_inv_arr' D.comp_arr_dom D.comp_cod_arr
---
>                 using f g h fg gh \<phi>_props(2) D.comp_arr_inv' D.comp_inv_arr'
>                       D.comp_arr_dom D.comp_cod_arr
5208c5111
<               using f g h fg gh D.hseqI' D.comp_cod_arr
---
>               using f g h fg gh D.comp_cod_arr
5295c5198
<             using 2 par \<phi>_props D.iso_is_retraction D.retraction_is_epi
---
>             using 2 par \<phi>_props D.iso_is_retraction D.retraction_is_epi D.ide_dom
5298c5201
<             by auto
---
>             by metis
5363,5366c5266,5269
<           using \<phi> F.reflects_iso
<           by (metis C.arrI C.isomorphic_def D.ide_hcomp D.hseqE F.locally_full
<               F.preserves_ide d_simps(1) e_simps(1) f g_in_hhom horizontal_homs.in_hhomE
<               ide_g preserves_ide preserves_src preserves_trg weak_arrow_of_homs_axioms
---
>           using f ide_g \<phi> F.reflects_iso F.locally_full
>           by (metis C.arrI C.isomorphic_def D.ide_hcomp D.hseqE
>               F.preserves_ide d_simps(1) e_simps(1) g_in_hhom horizontal_homs.in_hhomE
>               preserves_ide preserves_src preserves_trg weak_arrow_of_homs_axioms
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/SpanBicategory.thy ../../AFPs/afp-2020/thys/Bicategory/SpanBicategory.thy
1587c1587
<             using \<mu> 0 [of "dom \<mu>"] 0 [of "cod \<mu>"] hseqI' by fastforce
---
>             using \<mu> 0 [of "dom \<mu>"] 0 [of "cod \<mu>"] by fastforce
1810c1810
<             using \<mu> 0 [of "dom \<mu>"] 0 [of "cod \<mu>"] hseqI' by force
---
>             using \<mu> 0 [of "dom \<mu>"] 0 [of "cod \<mu>"] by force
2082c2082
<       by auto
---
>       by (simp_all add: composable)
2266c2266
<       by auto
---
>       by (auto simp add: \<mu>\<nu>.composable \<nu>\<pi>.composable)
3637c3637
<         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable hseqI' by auto
---
>         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable by auto
3641c3641
<         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable hseqI' by auto
---
>         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable by auto
3878c3878
<         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable hseqI' by auto
---
>         using \<mu>\<nu>.composable \<nu>\<pi>.composable \<pi>\<rho>.composable by auto
3883c3883
<         using arr_char assoc_in_homs(1) assoc_in_homs(2) assoc_in_homs(3) by blast
---
>         using arr_char assoc_in_homs(1-3) by blast
4486d4485
<               hseqI'
4496c4495
<       by (unfold_locales, auto)
---
>       apply unfold_locales by auto
4613,4614c4612
<             thus ?thesis
<               using hseqI' by auto
---
>             thus ?thesis by auto
4759,4760c4757
<             thus ?thesis
<               using hseqI' by auto
---
>             thus ?thesis by auto
5065c5062
<           using antipar Chn_vcomp hseqI' by auto
---
>           using antipar Chn_vcomp by auto
5188c5185
<           using antipar Chn_vcomp hseqI' by auto
---
>           using antipar Chn_vcomp by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Strictness.thy ../../AFPs/afp-2020/thys/Bicategory/Strictness.thy
9c9
< imports ConcreteCategory Pseudofunctor CanonicalIsos
---
> imports Category3.ConcreteCategory Pseudofunctor CanonicalIsos
110c110
<           using 2 assoc_in_hom [of "dom \<mu>" "dom \<nu>" "dom \<tau>"] strict_assoc comp_arr_dom hseqI'
---
>           using 2 assoc_in_hom [of "dom \<mu>" "dom \<nu>" "dom \<tau>"] strict_assoc comp_arr_dom
261,262c261,262
<     notation comp  (infixr "\<cdot>" 55)
<     abbreviation vcomp where "vcomp \<equiv> comp"
---
>     abbreviation vcomp     (infixr "\<cdot>" 55)
>     where "vcomp \<equiv> COMP"
375c375
<         have "trg (g \<cdot> f) = MkIde (E.Trg (Dom (comp g f)))"
---
>         have "trg (g \<cdot> f) = MkIde (E.Trg (Dom (g \<cdot> f)))"
415c415
<           by simp
---
>           by auto
421c421,422
<           using assms 1 arr_char B.can_in_hom src_def trg_def E.Ide.simps(3) by auto
---
>           using assms 1 arr_char src_def trg_def
>           apply (intro conjI B.in_homI) by auto
815,822c816,824
<         unfolding hcomp_def
<         using assms \<mu>\<nu> \<nu>\<tau> E.HcompNml_assoc src_def trg_def arr_char
<               E.Src_HcompNml E.Trg_HcompNml E.Nml_HcompNml E.Ide_HcompNml
<               B.can_in_hom [of "Dom \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<nu>" "Dom \<mu> \<^bold>\<star> Dom \<nu>"]
<               B.can_in_hom [of "Cod \<mu> \<^bold>\<star> Cod \<nu>" "Cod \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<nu>"]
<               B.can_in_hom [of "Dom \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<tau>" "Dom \<nu> \<^bold>\<star> Dom \<tau>"]
<               B.can_in_hom [of "Cod \<nu> \<^bold>\<star> Cod \<tau>" "Cod \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<tau>"]
<         by simp
---
>       proof -
>         have "E.Nml (Dom \<mu>) \<and> E.Nml (Dom \<nu>) \<and> E.Nml (Dom \<tau>)"
>           using assms by blast
>         moreover have "E.Src (Dom \<mu>) = E.Trg (Dom \<nu>) \<and> E.Src (Dom \<nu>) = E.Trg (Dom \<tau>)"
>           using assms \<mu>\<nu> \<nu>\<tau>
>           by (metis (no_types, lifting) src_simps(2) trg_simps(2))
>         ultimately show ?thesis
>           using assms \<mu>\<nu> \<nu>\<tau> E.HcompNml_assoc by simp
>       qed
824,831c826,834
<         unfolding hcomp_def
<         using assms \<mu>\<nu> \<nu>\<tau> E.HcompNml_assoc src_def trg_def arr_char
<               E.Src_HcompNml E.Trg_HcompNml E.Nml_HcompNml E.Ide_HcompNml
<               B.can_in_hom [of "Dom \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<nu>" "Dom \<mu> \<^bold>\<star> Dom \<nu>"]
<               B.can_in_hom [of "Cod \<mu> \<^bold>\<star> Cod \<nu>" "Cod \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<nu>"]
<               B.can_in_hom [of "Dom \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<tau>" "Dom \<nu> \<^bold>\<star> Dom \<tau>"]
<               B.can_in_hom [of "Cod \<nu> \<^bold>\<star> Cod \<tau>" "Cod \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<tau>"]
<         by simp
---
>       proof -
>         have "E.Nml (Cod \<mu>) \<and> E.Nml (Cod \<nu>) \<and> E.Nml (Cod \<tau>)"
>           using assms by blast
>         moreover have "E.Src (Cod \<mu>) = E.Trg (Cod \<nu>) \<and> E.Src (Cod \<nu>) = E.Trg (Cod \<tau>)"
>           using assms \<mu>\<nu> \<nu>\<tau>
>           by (metis (no_types, lifting) arrE src_simps(2) trg_simps(2))
>         ultimately show ?thesis
>           using assms \<mu>\<nu> \<nu>\<tau> E.HcompNml_assoc by simp
>       qed
845,852c848,850
<             unfolding hcomp_def
<             using assms \<mu>\<nu> \<nu>\<tau> E.HcompNml_assoc src_def trg_def arr_char
<                   E.Src_HcompNml E.Trg_HcompNml E.Nml_HcompNml E.Ide_HcompNml
<                   B.can_in_hom [of "Dom \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<nu>" "Dom \<mu> \<^bold>\<star> Dom \<nu>"]
<                   B.can_in_hom [of "Cod \<mu> \<^bold>\<star> Cod \<nu>" "Cod \<mu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<nu>"]
<                   B.can_in_hom [of "Dom \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Dom \<tau>" "Dom \<nu> \<^bold>\<star> Dom \<tau>"]
<                   B.can_in_hom [of "Cod \<nu> \<^bold>\<star> Cod \<tau>" "Cod \<nu> \<^bold>\<lfloor>\<^bold>\<star>\<^bold>\<rfloor> Cod \<tau>"]
<             by simp
---
>             using assms \<mu>\<nu> \<nu>\<tau> hcomp_def E.HcompNml_assoc src_def trg_def arr_char
>                   E.Nml_HcompNml E.Ide_HcompNml
>             by auto (* 5 sec *)
1054c1052
<             using assms H.hseqI' Map_hcomp [of \<mu> "\<nu> \<star> \<tau>"] Map_hcomp [of \<nu> \<tau>] by simp
---
>             using assms Map_hcomp [of \<mu> "\<nu> \<star> \<tau>"] Map_hcomp [of \<nu> \<tau>] by simp
1820c1818
<         using VVV.arr_char VV.arr_char \<a>_def H.hseqI' hcomp_assoc H.HoHV_def by force
---
>         using VVV.arr_char VV.arr_char \<a>_def hcomp_assoc H.HoHV_def by force
1823c1821
<         using VVV.arr_char VV.arr_char \<a>_def H.hseqI' H.HoVH_def by force
---
>         using VVV.arr_char VV.arr_char \<a>_def H.HoVH_def by force
1854c1852
<     sublocale bicategory comp hcomp \<a> \<i> src trg
---
>     sublocale bicategory vcomp hcomp \<a> \<i> src trg
1860c1858
<     shows "bicategory comp hcomp \<a> \<i> src trg"
---
>     shows "bicategory vcomp hcomp \<a> \<i> src trg"
2029c2027
<       using assms obj_UP\<^sub>0
---
>       using assms obj_UP\<^sub>0 obj_simps
2159a2158,2162
>                                  ((B.cod (fst \<mu>\<nu>) \<star>\<^sub>B B.cod (snd \<mu>\<nu>)) \<cdot>\<^sub>B (fst \<mu>\<nu> \<star>\<^sub>B snd \<mu>\<nu>))"
>             using \<mu>\<nu> B.VV.arr_char
>             by (intro comp_MkArr arr_MkArr, auto)
>           also have "... = MkArr (\<^bold>\<langle>B.dom (fst \<mu>\<nu>)\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>B.dom (snd \<mu>\<nu>)\<^bold>\<rangle>)
>                                  (\<^bold>\<langle>B.cod (fst \<mu>\<nu>) \<star>\<^sub>B B.cod (snd \<mu>\<nu>)\<^bold>\<rangle>)
2161,2162c2164
<             using \<mu>\<nu> B.VV.arr_char arr_char comp_def B.comp_cod_arr
<             apply (intro arr_eqI) by auto
---
>             using \<mu>\<nu> B.VV.arr_char B.comp_cod_arr by auto
2178a2181,2185
>                                  ((fst \<mu>\<nu> \<star>\<^sub>B snd \<mu>\<nu>) \<cdot>\<^sub>B (B.dom (fst \<mu>\<nu>) \<star>\<^sub>B B.dom (snd \<mu>\<nu>)))"
>             using \<mu>\<nu> B.VV.arr_char arr_MkArr
>             apply (intro comp_MkArr arr_MkArr) by auto
>           also have "... = MkArr (\<^bold>\<langle>B.dom (fst \<mu>\<nu>)\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>B.dom (snd \<mu>\<nu>)\<^bold>\<rangle>)
>                                  (\<^bold>\<langle>B.cod (fst \<mu>\<nu>) \<star>\<^sub>B B.cod (snd \<mu>\<nu>)\<^bold>\<rangle>)
2180,2181c2187
<             using \<mu>\<nu> B.VV.arr_char arr_char comp_def B.comp_arr_dom
<             by (intro arr_eqI, auto)
---
>             using \<mu>\<nu> B.VV.arr_char B.comp_arr_dom by auto
2209c2215
<             using assms UP.FF_def by auto
---
>             using assms UP.FF_def by fastforce
2274c2280,2289
<               using f g fg comp_def by auto
---
>             proof -
>               have "MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> (f \<star>\<^sub>B g) \<cdot> MkIde (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) =
>                     MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> (f \<star>\<^sub>B g) \<cdot> MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) (f \<star>\<^sub>B g)"
>                 using f g fg by simp
>               also have "... = MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> ((f \<star>\<^sub>B g) \<cdot>\<^sub>B (f \<star>\<^sub>B g))"
>                 using f g fg by (intro comp_MkArr arr_MkArr, auto)
>               also have "... = MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> (f \<star>\<^sub>B g)"
>                 using f g fg by simp
>               finally show ?thesis by blast
>             qed
2299c2314,2322
<               using f g fg comp_def by auto
---
>             proof -
>               have "MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> (f \<star>\<^sub>B g) \<cdot>
>                       MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) (f \<star>\<^sub>B g) =
>                     MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> ((f \<star>\<^sub>B g) \<cdot>\<^sub>B (f \<star>\<^sub>B g))"
>                 using f g fg arr_MkArr by (intro comp_MkArr arr_MkArr) auto
>               also have "... = MkArr (\<^bold>\<langle>f\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>g\<^bold>\<rangle>) \<^bold>\<langle>f \<star>\<^sub>B g\<^bold>\<rangle> (f \<star>\<^sub>B g)"
>                 using f g fg by simp
>               finally show ?thesis by blast
>             qed
2305c2328
<               by (simp del: B.hcomp_in_vhom)
---
>               by simp
2312c2335
<             using comp_assoc by simp
---
>             using comp_assoc by presburger
2861,2863c2884
<               using \<mu>\<nu> VV.arr_char arr_char src_def trg_def E.Ide_HcompNml E.Nml_HcompNml
<                     E.Src_HcompNml E.Trg_HcompNml \<mu>\<nu> A B C DN_def hcomp_def B.comp_assoc
<               by auto
---
>               using \<mu>\<nu> DN_def VV.arr_char B.comp_assoc by simp
3463c3484,3485
<                 using a Map_preserves_objects DN.map\<^sub>0_def DN_def B.src_src by auto
---
>                 using a Map_preserves_objects DN.map\<^sub>0_def DN_def B.src_src B.obj_simps
>                 by auto
3483c3505,3506
<                 using b Map_preserves_objects DN.map\<^sub>0_def DN_def B.src_src by auto
---
>                 using b Map_preserves_objects DN.map\<^sub>0_def DN_def B.src_src B.obj_simps
>                 by auto
3555,3562c3578,3579
<           proof -
<             have "\<i> (UP.map\<^sub>0 a) = MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 a"
<               unfolding \<i>_def UP.map\<^sub>0_def UP_def
<               using assms 2 src_def by auto
<             moreover have "MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<cdot> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 a = MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a"
<               using assms 0 1 2 comp_def by auto
<             ultimately show ?thesis by simp
<           qed
---
>             unfolding \<i>_def UP.map\<^sub>0_def UP_def
>             using assms 0 1 2 src_def by auto
3565,3573c3582,3591
<             have "UP \<i>\<^sub>B[a] = MkArr \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a]"
<               using assms UP_def by simp
<             moreover have "\<Phi> (a, a) = MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> (a \<star>\<^sub>B a)"
<               using assms \<Phi>_ide_simp by auto
<             ultimately have "UP \<i>\<^sub>B[a] \<cdot> \<Phi> (a, a) = MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a]"
<               using assms comp_def B.comp_arr_dom
<               by (elim B.objE, auto)
<             moreover have "MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<star> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a =
<                            MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (B.runit' a)"
---
>             have "(UP \<i>\<^sub>B[a] \<cdot> \<Phi> (a, a)) \<cdot> (MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<star> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a) =
>                   (MkArr \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a] \<cdot> MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> (a \<star>\<^sub>B a))
>                      \<cdot> (MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<star> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a)"
>               using assms UP_def \<Phi>_ide_simp by auto
>             also have "... = (MkArr \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a] \<cdot> MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> (a \<star>\<^sub>B a))
>                                \<cdot> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (B.runit' a)"
>               using assms 0 1 2 3 hcomp_def B.comp_cod_arr src_def trg_def
>                     B.can_Ide_self B.canE_unitor [of "\<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0"] B.comp_cod_arr
>               by auto
>             also have "... = MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> ((\<i>\<^sub>B[a] \<cdot>\<^sub>B (a \<star>\<^sub>B a)) \<cdot>\<^sub>B B.runit' a)"
3575,3589c3593,3602
<               have "MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<star> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a =
<                     MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>)
<                           (B.can (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<cdot>\<^sub>B B.can (\<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0) \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0)"
<                 using assms 0 1 2 3 hcomp_def B.comp_cod_arr src_def trg_def by auto
<               moreover have
<                 "B.can (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<cdot>\<^sub>B B.can (\<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0) \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 = B.runit' a"
<               proof -
<                 have "B.can (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<cdot>\<^sub>B B.can (\<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0) \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 =
<                       (a \<star>\<^sub>B a) \<cdot>\<^sub>B B.inv (B.runit a)"
<                   using assms B.can_Ide_self B.canE_unitor [of "\<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0"] by auto
<                 also have "... = B.runit' a"
<                   using assms B.comp_cod_arr by auto
<                 finally show ?thesis by simp
<               qed
<               ultimately show ?thesis by simp
---
>               have "MkArr \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a] \<cdot> MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a \<star>\<^sub>B a\<^bold>\<rangle> (a \<star>\<^sub>B a) =
>                     MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a\<^bold>\<rangle> (\<i>\<^sub>B[a] \<cdot>\<^sub>B (a \<star>\<^sub>B a))"
>                 using assms
>                 by (intro comp_MkArr arr_MkArr) auto
>               moreover have "MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a\<^bold>\<rangle> (\<i>\<^sub>B[a] \<cdot>\<^sub>B (a \<star>\<^sub>B a))
>                                \<cdot> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (B.runit' a) =
>                              MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> ((\<i>\<^sub>B[a] \<cdot>\<^sub>B (a \<star>\<^sub>B a)) \<cdot>\<^sub>B B.runit' a)"
>                 using assms 0 B.comp_arr_dom
>                 by (intro comp_MkArr arr_MkArr, auto)
>               ultimately show ?thesis by argo
3591,3593d3603
<             ultimately have "(UP \<i>\<^sub>B[a] \<cdot> \<Phi> (a, a)) \<cdot> (MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a \<star> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 \<^bold>\<langle>a\<^bold>\<rangle> a) =
<                              MkArr (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) \<^bold>\<langle>a\<^bold>\<rangle> \<i>\<^sub>B[a] \<cdot> MkArr \<^bold>\<langle>a\<^bold>\<rangle>\<^sub>0 (\<^bold>\<langle>a\<^bold>\<rangle> \<^bold>\<star> \<^bold>\<langle>a\<^bold>\<rangle>) (B.runit' a)"
<               by simp
3595,3598c3605,3607
<               using assms comp_def B.unitor_coincidence B.iso_unit B.comp_arr_inv
<                     B.inv_is_inverse
<               by auto
<             finally show ?thesis by simp
---
>               using assms B.comp_arr_dom B.comp_arr_inv' B.iso_unit B.unitor_coincidence(2)
>               by simp
>             finally show ?thesis by argo
3635c3644
<             using assms \<Psi>_char by (auto simp add: D.hcomp_obj_arr D.hseqI')
---
>             using assms \<Psi>_char by (auto simp add: D.hcomp_obj_arr)
3637c3646
<             using assms \<Phi>_components_are_iso \<Phi>_in_hom(2) D.inv_is_inverse by simp
---
>             using assms \<Phi>_in_hom(2) D.inv_is_inverse by simp
3656c3665
<             using assms \<Phi>_components_are_iso D.comp_arr_inv D.inv_is_inverse by simp
---
>             using assms D.comp_arr_inv D.inv_is_inverse by simp
3658c3667
<             using assms D.comp_arr_dom D.comp_cod_arr \<Psi>_char \<Phi>_in_hom(2) by auto
---
>             using assms D.comp_arr_dom D.comp_cod_arr \<Psi>_char by auto
3668c3677
<             using assms \<Psi>_char by (auto simp add: D.hcomp_arr_obj D.hseqI')
---
>             using assms \<Psi>_char by (auto simp add: D.hcomp_arr_obj)
3670c3679
<             using assms \<Phi>_components_are_iso \<Phi>_in_hom(2) D.inv_is_inverse by simp
---
>             using assms \<Phi>_in_hom(2) by simp
3688c3697
<             using assms \<Phi>_components_are_iso D.comp_arr_inv D.inv_is_inverse by simp
---
>             using assms D.comp_arr_inv D.inv_is_inverse by simp
3704c3713
<             using assms \<Phi>_components_are_iso D.iso_inv_iso by simp
---
>             using assms D.iso_inv_iso by simp
3724c3733
<             using assms \<Phi>_components_are_iso D.iso_inv_iso by simp
---
>             using assms D.iso_inv_iso by simp
3754c3763
<             using assms \<open>D.hseq (F f) (\<Phi> (g, h))\<close> by simp
---
>             using assms \<open>D.hseq (F f) (\<Phi> (g, h))\<close> \<Phi>_simps(1) \<Phi>_simps(4) by auto
3758c3767
<             using assms \<open>D.hseq (F f) (\<Phi> (g, h))\<close> by simp
---
>             using assms \<open>D.hseq (F f) (\<Phi> (g, h))\<close> \<Phi>_simps(1) \<Phi>_simps(4) by auto
3766c3775
<             using assms \<Phi>_components_are_iso by simp
---
>             using assms by simp
3770c3779
<               using assms C.VV.arr_char D.hseqI' by simp
---
>               using assms C.VV.arr_char by simp
3793c3802
<               using assms \<Phi>_components_are_iso D.iso_inv_iso by simp
---
>               using assms D.iso_inv_iso by simp
3796c3805
<               using assms \<Phi>_components_are_iso D.iso_inv_iso by simp
---
>               using assms D.iso_inv_iso by simp
3822,3823c3831
<           using assms \<Phi>_components_are_iso C.VV.arr_char D.iso_inv_iso FF_def D.hcomp_assoc
<                 D.comp_assoc
---
>           using assms C.VV.arr_char D.iso_inv_iso FF_def D.hcomp_assoc D.comp_assoc
3825c3833
<           by (simp add: D.inv_comp D.isos_compose D.hseqI')
---
>           by (simp add: D.inv_comp D.isos_compose)
3865,3866c3873
<           using antipar unit_is_iso counit_is_iso inv_comp hcomp_assoc hseqI'
<           by simp
---
>           using antipar inv_comp hcomp_assoc by simp
3906,3907c3913,3914
<         using ide_left ide_right antipar counit_is_iso comp_assoc whisker_right comp_cod_arr
<         by (metis "2" comp_arr_dom counit_simps(1) counit_simps(2))
---
>         using ide_left ide_right antipar comp_assoc whisker_right comp_cod_arr
>         by (metis "2" comp_arr_dom counit_simps(1-2))
3913c3920
<           using 2 antipar counit_is_iso by auto
---
>           using 2 antipar by auto
3915c3922
<           using antipar unit_is_iso counit_is_iso hseqI' hcomp_assoc by auto
---
>           using antipar hcomp_assoc by auto
3921c3928
<         using comp_assoc by simp
---
>         using comp_assoc by presburger
3930c3937
<             using antipar by (simp add: "2")
---
>             using 2 antipar by simp
3932c3939
<             using antipar unit_is_iso counit_is_iso hcomp_assoc hcomp_obj_arr hseqI' by auto
---
>             using antipar hcomp_assoc hcomp_obj_arr by auto
3934c3941
<             using antipar counit_is_iso comp_assoc comp_arr_dom hcomp_obj_arr hseqI'
---
>             using comp_assoc comp_arr_dom hcomp_obj_arr
3943c3950
<             using antipar comp_assoc hcomp_assoc whisker_left hcomp_arr_obj hseqI' by simp
---
>             using antipar comp_assoc hcomp_assoc whisker_left hcomp_arr_obj by simp
3945c3952
<             using antipar comp_arr_dom whisker_left hcomp_arr_obj hseqI' by simp
---
>             using antipar comp_arr_dom whisker_left hcomp_arr_obj by simp
3951c3958
<             using antipar comp_arr_dom comp_cod_arr whisker_left hseqI'
---
>             using antipar comp_arr_dom comp_cod_arr whisker_left
3957c3964
<             using antipar comp_assoc whisker_left whisker_right hcomp_assoc hseqI' by simp
---
>             using antipar comp_assoc whisker_left whisker_right hcomp_assoc by simp
3977c3984
<           using antipar comp_cod_arr hseqI' by simp
---
>           using antipar comp_cod_arr by simp
3985,3990c3992
<         proof -
<           have "seq (f \<star> inv \<eta>) (inv \<epsilon> \<star> f)"
<             using antipar unit_is_iso counit_is_iso hseqI' hcomp_arr_obj hcomp_assoc by auto
<           thus ?thesis
<             using unit_is_iso counit_is_iso counit_in_hom interchange by auto
<         qed
---
>           using antipar hcomp_arr_obj hcomp_assoc interchange by auto
3994c3996
<             using counit_is_iso hseqI' by (simp add: hcomp_obj_arr)
---
>             using hseqI' by (simp add: hcomp_obj_arr)
3996c3998
<             using antipar counit_is_iso hseqI' comp_arr_dom comp_cod_arr
---
>             using antipar comp_arr_dom comp_cod_arr
4001,4002c4003
<             using unit_is_iso hcomp_obj_arr [of "trg f" "f \<star> inv \<eta>"] hseqI'
<             by (simp add: antipar(1) hseq_char')
---
>             using hcomp_obj_arr [of "trg f" "f \<star> inv \<eta>"] by fastforce
4021c4022
<         using antipar unit_is_iso by (simp add: comp_inv_arr')
---
>         using antipar by (simp add: comp_inv_arr')
4088c4089
<           using antipar assoc_in_hom unit_in_hom counit_in_hom hseqI' by simp
---
>           using antipar by simp
4102c4103
<               using antipar UP.FF_def S.hseqI' UP.\<Phi>_in_hom [of g "src g"]
---
>               using antipar UP.FF_def UP.\<Phi>_in_hom [of g "src g"]
4108c4109
<               using antipar UP.\<Phi>_components_are_iso by simp
---
>               using antipar by simp
4121c4122
<               using antipar UP.\<Phi>_in_hom(2) S.hseqI' by (intro S.seqI, auto)
---
>               using antipar UP.\<Phi>_in_hom(2) by (intro S.seqI, auto)
4135c4136
<             using antipar S.comp_inv_arr' UP.\<Phi>_in_hom S.comp_cod_arr S.hseqI' by auto
---
>             using antipar S.comp_inv_arr' S.comp_cod_arr by auto
4142c4143
<               using antipar VV.arr_char S.comp_cod_arr S.hseqI' UP.\<Phi>_in_hom by simp
---
>               using antipar VV.arr_char S.comp_cod_arr by simp
4162c4163
<           using antipar hseqI' by simp
---
>           using antipar by simp
4176c4177
<               using antipar UP.FF_def VV.ide_char VV.arr_char UP.\<Phi>_in_hom [of "trg f" f] S.hseqI'
---
>               using antipar UP.FF_def VV.ide_char VV.arr_char UP.\<Phi>_in_hom [of "trg f" f]
4182c4183
<               using antipar UP.\<Phi>_components_are_iso by simp
---
>               using antipar by simp
4195c4196
<               using antipar S.hseqI' by (intro S.seqI, auto)
---
>               using antipar by (intro S.seqI, auto)
4209c4210
<             using antipar S.comp_cod_arr VV.arr_char S.hseqI' S.comp_inv_arr' by auto
---
>             using antipar S.comp_cod_arr VV.arr_char S.comp_inv_arr' by auto
4212c4213
<             using antipar S.comp_inv_arr' S.comp_cod_arr S.hseqI' by auto
---
>             using antipar S.comp_inv_arr' S.comp_cod_arr by auto
4249c4250
<                 using antipar VV.arr_char S.hseqI' S.hcomp_assoc
---
>                 using antipar VV.arr_char S.hcomp_assoc
4270,4271c4271
<                   using antipar S.iso_is_retraction S.retraction_is_epi
<                         UP.\<Phi>_components_are_iso S.iso_inv_iso
---
>                   using antipar S.iso_is_retraction S.retraction_is_epi S.iso_inv_iso
4286c4286
<                 using antipar VV.arr_char S.hseqI' S.hcomp_assoc by auto
---
>                 using antipar VV.arr_char S.hcomp_assoc by auto
4359c4359
<                   using UP.\<Phi>_components_are_iso UP.\<Psi>_char S.whisker_right by simp
---
>                   using UP.\<Psi>_char S.whisker_right by simp
4363,4364c4363
<                   using antipar UP.\<Phi>_components_are_iso UP.\<Psi>_char S.whisker_left S.comp_assoc
<                   by simp
---
>                   using antipar UP.\<Psi>_char S.whisker_left S.comp_assoc by simp
4378c4377
<                   by (simp add: S.hcomp_obj_arr S.hseqI')
---
>                   by (simp add: S.hcomp_obj_arr)
4382c4381
<                   using UP.\<Phi>_components_are_iso S.iso_inv_iso S.UP_map\<^sub>0_obj
---
>                   using S.iso_inv_iso S.UP_map\<^sub>0_obj
4395c4394
<                 using UP.\<Psi>_char S.hseqI' S.UP_map\<^sub>0_obj by simp
---
>                 using UP.\<Psi>_char S.UP_map\<^sub>0_obj by simp
4421c4420
<         using antipar hseqI' by simp
---
>         using antipar by simp
4439c4438
<       using antipar unit_is_iso counit_is_iso unit_in_hom counit_in_hom iso_inv_iso
---
>       using antipar unit_in_hom counit_in_hom iso_inv_iso
4472c4471
<           using antipar strict_assoc assoc'_in_hom(2) [of f g f] comp_cod_arr hseqI'
---
>           using antipar strict_assoc assoc'_in_hom(2) [of f g f] comp_cod_arr
4483c4482
<           using antipar strict_assoc assoc_in_hom(2) [of g f g] comp_cod_arr hseqI'
---
>           using antipar strict_assoc assoc_in_hom(2) [of g f g] comp_cod_arr
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Subbicategory.thy ../../AFPs/afp-2020/thys/Bicategory/Subbicategory.thy
180,181c180,181
<         have "\<alpha>\<^sub>S\<^sub>B \<mu>\<nu>\<tau> =
<              (fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>)) \<cdot>\<^sub>B \<alpha>\<^sub>S\<^sub>B (B.VVV.dom \<mu>\<nu>\<tau>)"
---
>         have "Arr (\<alpha>\<^sub>S\<^sub>B \<mu>\<nu>\<tau>) =
>               Arr ((fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>)) \<cdot>\<^sub>B \<alpha>\<^sub>S\<^sub>B (B.VVV.dom \<mu>\<nu>\<tau>))"
186,195c186,195
<         moreover have "Arr (fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>))"
<           using assms 1 B.VVV.arr_char B.VV.arr_char hcomp_closed
<           by (metis (no_types, lifting) B.H.preserves_arr B.hcomp_simps(2)
<               VV.arr_char VVV.arrE arrE)
<         moreover have "Arr (\<alpha>\<^sub>S\<^sub>B (B.VVV.dom \<mu>\<nu>\<tau>))"
<         proof -
<           have "\<alpha>\<^sub>S\<^sub>B (B.VVV.dom \<mu>\<nu>\<tau>) =
<                 \<a>\<^sub>B (B.dom (fst \<mu>\<nu>\<tau>)) (B.dom (fst (snd \<mu>\<nu>\<tau>))) (B.dom (snd (snd \<mu>\<nu>\<tau>)))"
<             using assms 1 B.\<alpha>_def B.VVV.dom_char B.VV.dom_char VVV.arr_char VV.arr_char
<                   B.VxVxV.dom_char inclusion
---
>         also have "..."
>         proof (intro comp_closed)
>           show "Arr (fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>))"
>             using assms 1 B.VVV.arr_char B.VV.arr_char hcomp_closed
>             by (metis (no_types, lifting) B.H.preserves_reflects_arr B.trg_hcomp
>                 VV.arr_char VVV.arrE arr_char)
>           show "B.cod (\<a> (fst (B.VVV.dom \<mu>\<nu>\<tau>)) (fst (snd (B.VVV.dom \<mu>\<nu>\<tau>)))
>                       (snd (snd (B.VVV.dom \<mu>\<nu>\<tau>)))) =
>                 B.dom (fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>))"
>             using assms 1 VVV.arr_char VV.arr_char B.VxVxV.dom_char
197,199c197,200
<             by (metis (no_types, lifting) B.hseqE arr_dom calculation(2) dom_char src_dom trg_dom)
<           moreover have "Arr (\<a>\<^sub>B (B.dom (fst \<mu>\<nu>\<tau>)) (B.dom (fst (snd \<mu>\<nu>\<tau>)))
<                              (B.dom (snd (snd \<mu>\<nu>\<tau>))))"
---
>             by (metis (no_types, lifting) B.VV.arr_char B.VVV.arrE B.\<alpha>.preserves_reflects_arr
>                 B.assoc_is_natural_1 B.seqE arr_dom dom_char src_dom trg_dom)
>           show "Arr (\<a> (fst (B.VVV.dom \<mu>\<nu>\<tau>)) (fst (snd (B.VVV.dom \<mu>\<nu>\<tau>)))
>                     (snd (snd (B.VVV.dom \<mu>\<nu>\<tau>))))"
201,207c202,221
<             have "B.VVV.ide (B.VVV.dom \<mu>\<nu>\<tau>)"
<               using 1 B.VVV.ide_dom by blast
<             thus ?thesis
<               using assms B.\<alpha>_def B.VVV.arr_char B.VV.arr_char B.VVV.ide_char B.VV.ide_char
<                     dom_closed assoc_closed
<               by (metis (no_types, lifting) "1" B.ide_dom B.src_dom B.trg_dom VV.arr_char VVV.arrE
<                   arr_char)
---
>             have "VVV.arr (B.VVV.dom \<mu>\<nu>\<tau>)"
>               using 1 B.VVV.dom_char B.VVV.arr_char B.VV.arr_char VVV.arr_char VV.arr_char
>               apply simp
>               by (metis (no_types, lifting) VVV.arrE arr_dom assms dom_simp src_dom trg_dom)
>             moreover have "Arr (\<a>\<^sub>B (B.dom (fst \<mu>\<nu>\<tau>)) (B.dom (fst (snd \<mu>\<nu>\<tau>)))
>                                (B.dom (snd (snd \<mu>\<nu>\<tau>))))"
>             proof -
>               have "B.VVV.ide (B.VVV.dom \<mu>\<nu>\<tau>)"
>                 using 1 B.VVV.ide_dom by blast
>               thus ?thesis
>                 using assms B.\<alpha>_def B.VVV.arr_char B.VV.arr_char B.VVV.ide_char B.VV.ide_char
>                       dom_closed assoc_closed
>                 by (metis (no_types, lifting) "1" B.ide_dom B.src_dom B.trg_dom VV.arr_char
>                     VVV.arrE arr_char)
>             qed
>             ultimately show ?thesis
>               using 1 B.VVV.ide_dom assoc_closed B.VVV.dom_char
>               apply simp
>               by (metis (no_types, lifting) B.VV.arr_char B.VVV.arrE B.VVV.inclusion
>                   B.VxV.dom_char B.VxVxV.arrE B.VxVxV.dom_char prod.sel(1) prod.sel(2))
209d222
<           ultimately show ?thesis by argo
211,218c224
<         moreover have "B.seq (fst \<mu>\<nu>\<tau> \<star>\<^sub>B fst (snd \<mu>\<nu>\<tau>) \<star>\<^sub>B snd (snd \<mu>\<nu>\<tau>))
<                              (\<alpha>\<^sub>S\<^sub>B (B.VVV.dom \<mu>\<nu>\<tau>))"
<           using assms 1 VVV.arr_char VV.arr_char B.VxVxV.dom_char
<           apply simp
<           by (metis (no_types, lifting) B.VV.arrE B.VVV.arrE B.assoc_is_natural_1
<               B.\<alpha>.preserves_reflects_arr arr_dom dom_simp src_dom trg_dom)
<         ultimately show ?thesis
<           using comp_closed by auto
---
>         finally show ?thesis by blast
443c449
<               using f \<mu> \<mu>_eq ide_char arr_char B.trg_dom [of ?\<mu>] B.hseqI' by fastforce
---
>               using f \<mu> \<mu>_eq ide_char arr_char B.trg_dom [of ?\<mu>] by fastforce
445c451
<               using \<mu> \<mu>_eq B.comp_arr_dom in_hom_char B.hseqI' by auto
---
>               using \<mu> \<mu>_eq B.comp_arr_dom in_hom_char by auto
529c535
<               using f \<mu> \<mu>_eq ide_char arr_char B.src_dom [of ?\<mu>] B.hseqI' by fastforce
---
>               using f \<mu> \<mu>_eq ide_char arr_char B.src_dom [of ?\<mu>] by fastforce
531c537
<               using \<mu> \<mu>_eq B.comp_arr_dom in_hom_char B.hseqI' by auto
---
>               using \<mu> \<mu>_eq B.comp_arr_dom in_hom_char by auto
752,754c758,760
<             using 1 2 3 5 VVV.comp_char VV.comp_char VVV.arr_char VV.arr_char arr_char
<                   src_def trg_def
<             by simp
---
>             using 1 VVV.comp_char VVV.arr_char VV.arr_char
>             apply simp
>             using 2 3 5 arrI arr_simps(1) arr_simps(2) by presburger
796c802
<         using f arr_char hcomp_def B.hseqI' by simp
---
>         using f arr_char hcomp_def by simp
798c804
<         using f arr_char hcomp_def B.hseqI' by simp
---
>         using f arr_char hcomp_def by simp
825,831c831,834
<         have 1: "hseq \<phi> (dom \<mu>)"
<         proof (intro hseqI)
<           show "in_hhom (dom \<mu>) a a"
<             using \<mu> arr_char src_dom trg_dom src_def trg_def by simp
<           show "in_hhom \<phi> a a"
<             using \<phi> arr_char src_dom trg_dom src_def trg_def by auto
<         qed
---
>         have 0: "in_hhom (dom \<mu>) a a"
>           using \<mu> arr_char src_dom trg_dom src_def trg_def by simp
>         have 1: "in_hhom \<phi> a a"
>           using \<phi> arr_char src_dom trg_dom src_def trg_def by auto
833,838c836
<         proof (intro hseqI)
<           show "in_hhom (B.dom \<mu>) a a"
<             using \<mu> arr_char src_dom trg_dom src_def trg_def by simp
<           show "in_hhom \<phi> a a"
<             using \<phi> arr_char src_dom trg_dom src_def trg_def by auto
<         qed
---
>           using \<mu> 0 1 by auto
840,849c838,843
<           using \<mu> \<phi> 1 2
<             apply (intro seqI hseqI')
<               apply auto
<         proof -
<           have "B.dom (\<ll> \<mu>) = a \<star> dom \<mu>"
<             using \<mu> 2 \<ll>.preserves_dom arr_simps(2) by auto
<           also have "... = B.cod (\<phi> \<star> B.dom \<mu>)"
<             using \<mu> \<phi> 2 hcomp_simps(4) cod_dom in_homE by auto
<           finally show "B.dom (\<ll> \<mu>) = B.cod (\<phi> \<star> B.dom \<mu>)"
<             by blast
---
>         proof (intro seqI')
>           show "\<guillemotleft>\<phi> \<star> dom \<mu> : w \<star> dom \<mu> \<Rightarrow> a \<star> dom \<mu>\<guillemotright>"
>             by (metis (no_types, lifting) 0 \<mu> \<phi> hcomp_in_vhom ide_dom ide_in_hom(2)
>                 in_hhom_def w_simps(3))
>           show "\<guillemotleft>\<ll> \<mu> : a \<star> dom \<mu> \<Rightarrow> cod \<mu>\<guillemotright>"
>             using \<mu> 2 \<ll>.preserves_hom [of \<mu> "dom \<mu>" "cod \<mu>"] arr_simps(2) arr_cod by fastforce
854,855c848,849
<             using \<mu> 3 hcomp_simps(3) dom_comp
<             by (metis (no_types, lifting) dom_dom seqE)
---
>             using \<mu> 3 hcomp_simps(3) dom_comp dom_dom
>             apply (elim seqE) by auto
898,899c892,893
<               using \<mu> \<phi> 1 2
<               by (metis (no_types, lifting) hseqE trg_dom vseq_implies_hpar(2))
---
>               using \<mu> \<phi> 2
>               by (metis (no_types, lifting) arr_simps(2) seqE vconn_implies_hpar(1) w_simps(3))
974c968
<         using f arr_char dom_char cod_char hcomp_def \<omega>_in_vhom B.hseqI' by simp
---
>         using f arr_char dom_char cod_char hcomp_def \<omega>_in_vhom by simp
976c970
<         using f arr_char dom_char cod_char hcomp_def \<omega>_in_vhom B.hseqI' by simp
---
>         using f arr_char dom_char cod_char hcomp_def \<omega>_in_vhom by simp
1005,1011c999,1002
<         have 1: "hseq \<phi> (dom \<mu>)"
<         proof (intro hseqI)
<           show "in_hhom (dom \<mu>) a a"
<             using \<mu> arr_char src_dom trg_dom src_def trg_def by simp
<           show "in_hhom \<phi> a a"
<             using \<phi> arr_char src_dom trg_dom src_def trg_def by auto
<         qed
---
>         have 0: "in_hhom (dom \<mu>) a a"
>           using \<mu> arr_char src_dom trg_dom src_def trg_def by simp
>         have 1: "in_hhom \<phi> a a"
>           using \<phi> arr_char src_dom trg_dom src_def trg_def by auto
1013,1015c1004
<           using \<mu> \<phi> 1 src_dom [of \<mu>]
<           apply (intro hseqI')
<           by (auto simp add: arr_simps(1) vconn_implies_hpar(2))
---
>           using \<mu> 0 1 by auto
1017,1026c1006,1011
<           using \<mu> \<phi> 1 2
<           apply (intro seqI hseqI')
<               apply auto
<         proof -
<           have "B.dom (\<rr> \<mu>) = dom \<mu> \<star> a"
<             using \<mu> 2 \<rr>.preserves_dom arr_simps(1) by auto
<           also have "... = B.cod (B.dom \<mu> \<star> \<phi>)"
<             using \<mu> \<phi> 2 hcomp_simps(4) cod_dom in_homE by auto
<           finally show "B.dom (\<rr> \<mu>) = B.cod (B.dom \<mu> \<star> \<phi>)"
<             by blast
---
>         proof (intro seqI')
>           show "\<guillemotleft>dom \<mu> \<star> \<phi> : dom \<mu> \<star> w \<Rightarrow> dom \<mu> \<star> a\<guillemotright>"
>             by (metis (no_types, lifting) "0" "1" \<mu> \<phi> hcomp_in_vhom hseqI hseq_char
>                 ide_dom ide_in_hom(2) vconn_implies_hpar(2))
>           show "\<guillemotleft>\<rr> \<mu> : dom \<mu> \<star> a \<Rightarrow> cod \<mu>\<guillemotright>"
>             using \<mu> 2 \<rr>.preserves_hom [of \<mu> "dom \<mu>" "cod \<mu>"] arr_simps(2) arr_cod by fastforce
1031,1032c1016,1017
<             using \<mu> 3 hcomp_simps(3) dom_comp
<             by (metis (no_types, lifting) dom_dom seqE)
---
>             using \<mu> 3 hcomp_simps(3) dom_comp dom_dom
>             apply (elim seqE) by auto
1167c1152
<                 VxV.arrI VxVxV.arrI VxVxV_comp_eq_VVV_comp hseqI' H.preserves_reflects_arr
---
>                 VxV.arrI VxVxV.arrI VxVxV_comp_eq_VVV_comp H.preserves_reflects_arr hseqI'
1198c1183
<               using f g h k ide_char arr_char B.hseqI' B.HoHV_def B.HoVH_def
---
>               using f g h k ide_char arr_char B.HoHV_def B.HoVH_def
1271c1256
<       using assms iso_unit in_homE isoE isomorphicE VVV.arr_char VV.arr_char hseqI'
---
>       using assms iso_unit in_homE isoE isomorphicE VVV.arr_char VV.arr_char
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Bicategory/Tabulation.thy ../../AFPs/afp-2020/thys/Bicategory/Tabulation.thy
9c9
< imports CanonicalIsos InternalAdjunction ConcreteCategory
---
> imports CanonicalIsos InternalAdjunction
69,70c69,71
<       by (metis arr_cod comp_cod_arr hcomp_simps(1-2) in_hhom_def in_homE src_cod
<           vseq_implies_hpar(2))
---
>       by (metis arrI hcomp_simps(1) hcomp_simps(2) in_hhomI not_arr_null
>           src.is_extensional src.preserves_hom vconn_implies_hpar(1)
>           vconn_implies_hpar(2) vconn_implies_hpar(3) vconn_implies_hpar(4))
125,127c126
<         using assms ide_base ide_leg0 tab_in_hom hseqI'
<         apply (elim conjE in_hhomE in_homE)
<         by (intro hcomp_in_vhom, auto)
---
>         using assms ide_base ide_leg0 tab_in_hom by fastforce
261c260
<         using tab_in_hom T0.antipar(1) hseqI' by auto
---
>         using tab_in_hom T0.antipar(1) by auto
263c262
<         using T0.antipar(1) T0.antipar(2) by auto
---
>         using T0.antipar(1-2) by auto
265c264
<         using T0.antipar by (intro hcomp_in_vhom, auto)
---
>         using T0.antipar by auto
477c476
<       by (metis arr_dom leg0_simps(3) in_homE trg_cod trg_dom hcomp_simps(2))
---
>       by (metis arr_dom in_homE leg0_simps(3) trg_hcomp vconn_implies_hpar(4))
732,733c731,732
<         by (metis arr_inv leg0_simps(3) ide_base in_homE iso_runit seqE src_dom
<             hcomp_simps(1) vseq_implies_hpar(1))
---
>         by (metis ide_base leg0_simps(3) runit'_simps(1) seqE src_hcomp vconn_implies_hpar(1)
>             vseq_implies_hpar(1))
811c810
<                   using f\<^sub>a 1 2 \<epsilon> hseqI' whisker_left comp_assoc by auto
---
>                   using f\<^sub>a 1 2 \<epsilon> whisker_left comp_assoc by auto
873c872
<                     by (simp add: \<nu> comp_cod_arr hseqI')
---
>                     by (simp add: \<nu> comp_cod_arr)
964c963
<                   using 1 2 \<open>ide f\<^sub>a\<close> ide_leg0 iso_inv_iso iso_assoc hseqI'
---
>                   using 1 2 \<open>ide f\<^sub>a\<close> ide_leg0 iso_inv_iso iso_assoc
1041c1040
<             using 1 2 \<open>ide f\<^sub>a\<close> \<eta>_in_hom \<epsilon> hseqI' by fastforce
---
>             using 1 2 \<open>ide f\<^sub>a\<close> \<eta>_in_hom \<epsilon> by fastforce
1043c1042
<             using f\<^sub>a 1 2 \<epsilon> assoc'_in_hom(2) hseqI' by auto
---
>             using f\<^sub>a 1 2 \<epsilon> by auto
1070c1069
<                         using interchange comp_arr_dom comp_cod_arr 1 2 \<open>ide f\<^sub>a\<close> hseqI'
---
>                         using interchange comp_arr_dom comp_cod_arr 1 2 \<open>ide f\<^sub>a\<close>
1190c1189
<                 using 1 2 comp_cod_arr \<open>ide f\<^sub>a\<close> comp_assoc_assoc' hseqI' triangle' by simp
---
>                 using 1 2 comp_cod_arr \<open>ide f\<^sub>a\<close> comp_assoc_assoc' triangle' by simp
1359c1358,1359
<         using ide_base T0.antipar hseq_char T0.trnr\<^sub>\<epsilon>_def rep_in_hom w\<theta>'\<nu> by auto
---
>         using ide_base T0.antipar hseq_char T0.trnr\<^sub>\<epsilon>_def rep_in_hom w\<theta>'\<nu>
>         apply (intro comp_in_homI') by auto
1417c1417
<               using \<gamma> whisker_left trg_\<gamma>_eq hseqI' T0.antipar comp_assoc by auto
---
>               using \<gamma> whisker_left trg_\<gamma>_eq T0.antipar comp_assoc by auto
1426c1426
<                   hseqI' T0.antipar
---
>                   T0.antipar
1436,1437c1436
<           using \<gamma> T0.antipar hseq_char
<           by (intro comp_in_hom_simp, auto)
---
>           using \<gamma> T0.antipar hseq_char by force
1479c1478
<                   using comp_arr_dom comp_cod_arr hseqI' T0.antipar
---
>                   using comp_arr_dom comp_cod_arr T0.antipar
1483c1482
<                   using comp_arr_dom comp_cod_arr hseqI' T0.antipar
---
>                   using comp_arr_dom comp_cod_arr T0.antipar
1514c1513
<                     using assoc_naturality [of r f "f\<^sup>* \<star> \<theta>'"] T0.antipar by force
---
>                     using assoc_naturality [of r f "f\<^sup>* \<star> \<theta>'"] T0.antipar by fastforce
1522c1521
<                         using whisker_left hseqI' T0.antipar by simp
---
>                         using whisker_left T0.antipar by simp
1528c1527
<                                 hseqI' runit_naturality comp_assoc
---
>                                 runit_naturality comp_assoc
1531c1530
<                           using whisker_left hseqI' T0.antipar by simp
---
>                           using whisker_left T0.antipar by simp
1551c1550
<                         using whisker_left hseqI' T0.antipar by simp
---
>                         using whisker_left T0.antipar by simp
1555c1554
<                         using whisker_left hseqI' T0.antipar by auto
---
>                         using whisker_left T0.antipar by auto
1575c1574
<                         using whisker_left hseqI' T0.antipar by simp
---
>                         using whisker_left T0.antipar by simp
1585c1584
<                         using whisker_left hseqI' T0.antipar by simp
---
>                         using whisker_left T0.antipar by simp
1637c1636
<                               comp_arr_dom comp_cod_arr T0.unit_in_hom hseqI'
---
>                               comp_arr_dom comp_cod_arr T0.unit_in_hom
1665c1664
<                           comp_cod_arr hseqI' comp_assoc_assoc'
---
>                           comp_cod_arr comp_assoc_assoc'
1671c1670
<                           whisker_left comp_assoc hseqI' T0.antipar
---
>                           whisker_left comp_assoc T0.antipar
1689c1688
<                       using T0.antipar comp_cod_arr hseqI' ide_base by simp
---
>                       using T0.antipar comp_cod_arr ide_base by simp
1694c1693
<                       using T0.antipar comp_cod_arr hseqI' comp_assoc_assoc' by simp
---
>                       using T0.antipar comp_cod_arr comp_assoc_assoc' by simp
1701c1700
<                     using assoc_naturality [of r f "\<eta> \<star> w"] hseqI' comp_assoc by fastforce
---
>                     using assoc_naturality [of r f "\<eta> \<star> w"] comp_assoc by fastforce
1707c1706
<                     using assoc'_naturality [of f \<eta> w] hseqI' T0.antipar comp_assoc
---
>                     using assoc'_naturality [of f \<eta> w] T0.antipar comp_assoc
1766c1765
<                     using whisker_left whisker_right hseqI' T0.antipar by simp
---
>                     using whisker_left whisker_right T0.antipar by simp
1795c1794
<                   using whisker_left hseqI' by simp
---
>                   using whisker_left by simp
1859c1858,1860
<                     using comp_cod_arr by auto
---
>                     using comp_cod_arr
>                     by (metis assoc_is_natural_1 base_simps(2-3) leg0_simps(2-4)
>                         w_simps(2) w_simps(4) w_simps(5))
1889c1890
<           using 1 w\<theta>'\<nu> \<gamma> trg_\<gamma>_eq isos_compose iso_inv_iso hseqI'
---
>           using 1 w\<theta>'\<nu> \<gamma> trg_\<gamma>_eq isos_compose iso_inv_iso
1965,1967c1966
<             using \<omega> 1 u ide_right antipar(1)
<             by (metis horizontal_homs.trg_cod horizontal_homs.trg_dom horizontal_homs_axioms
<                 hseqI' ideD(1) in_homE hcomp_simps(2))
---
>             using \<omega> 1 u ide_right antipar(1) vconn_implies_hpar(4) by force
2050c2049
<                     using comp_arr_dom by (simp add: comp_inv_arr' hseqI')
---
>                     using comp_arr_dom by (simp add: comp_inv_arr')
2088c2087
<               using \<gamma> 3 hcomp_obj_arr by auto
---
>               using \<gamma> 3 hcomp_obj_arr by blast
2267c2266
<                   apply (intro seqI hseqI')
---
>                   apply (intro seqI)
2475c2474,2475
<             using \<theta> ide_base ide_dom [of \<theta>] trg_dom [of \<theta>] by fastforce
---
>             using \<theta> ide_base ide_dom [of \<theta>] trg_dom [of \<theta>]
>             using arrI fw vconn_implies_hpar(2) by auto
2727,2728c2727
<           using whisker_left comp_assoc
<           by (simp add: hseqI')
---
>           using whisker_left comp_assoc by simp
2806c2805
<         using \<nu>'\<nu> iso_\<nu>'\<nu>_r by simp
---
>         using \<nu>'\<nu> iso_\<nu>'\<nu>_r by auto
2825c2824,2826
<           using inv_\<nu>'\<nu>_r \<theta>\<theta>' eq' T2 comp_assoc by simp
---
>           using inv_\<nu>'\<nu>_r \<theta>\<theta>' eq'
>                 T2 [of "w' \<star> w" "src f" "\<theta> \<cdot> (\<theta>' \<star> w) \<cdot> \<a>\<^sup>-\<^sup>1[f, w', w]" f] comp_assoc
>           by simp
2841,2842c2842,2847
<             using comp_arr_dom hcomp_simps(3) [of \<rho> "src f"]
<             by (metis (full_types) R.preserves_arr tab_simps(1) tab_simps(2) dom_src)
---
>           proof -
>             have "(\<rho> \<star> src \<rho>) \<cdot> (dom \<rho> \<star> src (dom \<rho>)) = \<rho> \<star> src \<rho>"
>               using R.is_natural_1 arr_dom tab_simps(1) by presburger
>             thus ?thesis
>               by simp
>           qed
2897c2902
<             using T2 by auto
---
>             using T2 by presburger
2966c2971
<         by (metis arr_cod leg0_simps(2) in_homE src_cod src_src)
---
>         by (metis arr_cod in_homE leg0_simps(2) src_hcomp src_src vconn_implies_hpar(3))
2969c2974
<         by (metis arr_cod T'.leg0_simps(2) in_homE src_cod src_src)
---
>         by (metis T'.leg0_simps(2) arr_cod in_homE src_hcomp src_src vconn_implies_hpar(3))
3043c3048
<                 D.src_hcomp' v')
---
>                 D.src_hcomp v')
3051,3053c3056
<             using v'_def
<             by (metis D.cod_trg D.hseqI' D.ideD(1) D.in_homE D.trg.preserves_hom D.trg_dom
<                 D.hcomp_simps(2) T'.base_simps(2) \<omega>' \<open>trg\<^sub>D u' = src\<^sub>D (F r)\<close> u')
---
>             using v'_def D.vconn_implies_hpar(4) \<omega>' u' by force
3113c3116
<                 D.trg.preserves_cod D.trg_hcomp' e' u u'_in_hhom)
---
>                 D.trg.preserves_cod D.trg_hcomp e' u u'_in_hhom)
3141c3144
<             by (metis C.ide_hcomp C.hseqI C.in_hhomE C.src_hcomp' C.trg_hcomp'
---
>             by (metis C.ide_hcomp C.hseqI C.in_hhomE C.src_hcomp C.trg_hcomp
3145c3148
<             by (metis C.hseqI C.in_homE C.src_cod C.src_hcomp' T.base_in_hom(1) u)
---
>             by (metis C.hseqI C.in_homE C.src_cod C.src_hcomp T.base_in_hom(1) u)
3203c3206
<             by (metis C.arrI C.seqE C.src_hcomp' C.src_vcomp C.vseq_implies_hpar(1)
---
>             by (metis C.arrI C.seqE C.src_hcomp C.src_vcomp C.vseq_implies_hpar(1)
3317,3321c3320
<                     using \<omega> w\<theta>\<nu> \<Phi>_in_hom(2) [of "r \<star>\<^sub>C f" w] C.VV.arr_char FF_def
<                     apply (intro D.seqI D.hseqI')
<                         apply auto
<                     using \<omega> w\<theta>\<nu> T.tab_in_hom preserves_cod [of "\<rho> \<star>\<^sub>C w"] D.hseqI'
<                     by force
---
>                     using \<omega> w\<theta>\<nu> \<Phi>_in_hom(2) [of "r \<star>\<^sub>C f" w] C.VV.arr_char FF_def by auto
3328,3329c3327,3328
<                     by (metis C.arrI C.ide_hcomp C.hseqE C.hseqI' C.seqE C.src_hcomp'
<                         T.tab_simps(2) T.ide_leg0 T.ide_base T.leg0_simps(2) T.leg0_simps(3) \<omega>)
---
>                     by (metis C.arrI C.ide_hcomp C.hseqE C.hseqI' C.seqE C.src_hcomp
>                         T.tab_simps(2) T.ide_leg0 T.ide_base T.leg0_simps(2-3) \<omega>)
3336c3335
<                     by simp
---
>                     by presburger
3522c3521
<                   using 1 w\<theta>\<nu> D.assoc_naturality [of "F r" "\<Phi> (f, w)" d'] D.hseqI'
---
>                   using 1 w\<theta>\<nu> D.assoc_naturality [of "F r" "\<Phi> (f, w)" d']
3537,3539c3536
<                   using w\<theta>\<nu>
<                   by (metis C.arrI C.seqE C.hcomp_simps(1) C.src_vcomp \<omega> \<open>src\<^sub>C \<omega> = src\<^sub>C u\<close>
<                       \<open>src\<^sub>C u = a\<close> \<open>trg\<^sub>D d' = map\<^sub>0 a\<close> preserves_src)
---
>                   using w\<theta>\<nu> C.arrI C.vconn_implies_hpar(1) by auto
3785c3782
<                 using F\<omega> F\<omega>_def \<omega>' D.comp_assoc D.hseqI' D.hcomp_reassoc(1) [of \<omega>' e' d']
---
>                 using F\<omega> F\<omega>_def \<omega>' D.comp_assoc D.hcomp_reassoc(1) [of \<omega>' e' d']
3793c3790
<                    using u' by (simp add: D.hseqI')
---
>                    using u' by simp
3805c3802
<                    using u' D.comp_assoc D.hseqI'
---
>                    using u' D.comp_assoc
3858c3855
<                   using u u' \<phi> 1 2 D.src_dom e'.antipar D.hseqI' D.whisker_left D.whisker_right
---
>                   using u u' \<phi> 1 2 D.src_dom e'.antipar D.whisker_left D.whisker_right
4016c4013
<               D.src_hcomp')
---
>               D.src_hcomp)
4019,4020c4016
<             by (metis D.dom_trg D.hseq_char' D.ideD(1) D.ide_trg D.in_homE D.trg.is_extensional
<               D.trg.preserves_dom D.hcomp_simps(2))
---
>             by (metis D.arr_dom D.in_homE D.trg_hcomp D.vconn_implies_hpar(2))
4026,4027c4022
<             by (metis D.dom_trg D.hseq_char' D.ideD(1) D.ide_trg D.in_homE D.trg.is_extensional
<               D.trg.preserves_dom D.hcomp_simps(2))
---
>             by (metis D.vconn_implies_hpar(2) D.vconn_implies_hpar(4) \<open>trg\<^sub>D \<theta> = trg\<^sub>D (F f)\<close> \<theta>)
4035,4036c4030,4032
<             by (metis D.dom_src D.hseq_char' D.ideD(1) D.in_homE D.src.is_extensional
<                 D.src.preserves_dom D.src.preserves_ide \<open>src\<^sub>D \<theta>' = a\<close> \<theta>' D.hcomp_simps(1) w)
---
>             by (metis D.ideD(1) D.in_homE D.src_hcomp D.vconn_implies_hpar(1) \<open>src\<^sub>D \<theta>' = a\<close>
>                 \<theta>' category.ide_dom horizontal_homs_def weak_arrow_of_homs_axioms
>                 weak_arrow_of_homs_def)
4234c4230
<                         D.comp_cod_arr D.hseqI'
---
>                         D.comp_cod_arr
4239,4240c4235
<                   using w\<^sub>C \<Phi>_in_hom \<Phi>_components_are_iso D.comp_cod_arr
<                         D.comp_inv_arr' D.hseqI' \<Phi>_simps(1) \<Phi>_simps(4) by auto
---
>                   using w\<^sub>C D.comp_cod_arr D.comp_inv_arr'  \<Phi>_simps(1,4) by auto
4312,4314c4307,4308
<                   by (metis D.comp_arr_dom D.hcomp_simps(3) D.ide_char D.in_hhomE D.in_homE
<                       D.seqI T'.tab_in_hom(2) T.tab_simps(2) T.leg0_simps(2) e.ide_left
<                       preserves_src w we)
---
>                   by (metis D.comp_arr_ide D.comp_cod_arr D.in_homE D.seqI' T'.ide_leg1
>                       T'.leg1_in_hom(2) T'.tab_in_vhom')
4330,4331c4324
<                   using w D.hseqI'
<                   by (intro D.seqI D.hseqI, auto)
---
>                   using w by simp
4399c4392
<                   using w\<^sub>C' \<theta>\<^sub>C' \<beta>\<^sub>C F\<beta>\<^sub>C_def preserves_assoc [of r f w\<^sub>C'] preserves_hcomp C.hseqI'
---
>                   using w\<^sub>C' \<theta>\<^sub>C' \<beta>\<^sub>C F\<beta>\<^sub>C_def preserves_assoc [of r f w\<^sub>C'] preserves_hcomp
4425c4418
<                     using C.ide_hcomp C.ideD(1) C.trg_hcomp' D.invert_side_of_triangle(1)
---
>                     using C.ide_hcomp C.ideD(1) C.trg_hcomp D.invert_side_of_triangle(1)
4454,4455c4447,4449
<                     by (metis D.hcomp_simps(4) D.cod_inv D.comp_null(2) D.hseq_char' D.in_homE
<                         T'.leg1_simps(6) \<phi>')
---
>                     by (metis D.cod_inv D.comp_null(2) D.hseq_char' D.in_homE
>                         D.is_weak_composition T'.leg1_simps(6) \<phi>'
>                         weak_composition.hcomp_simps\<^sub>W\<^sub>C(3))
4560,4561c4554
<                   using w' D.hseqI'
<                   by (intro D.seqI D.hseqI, auto)
---
>                   using w' by simp
4592c4585
<                   using w' w'e D.assoc'_naturality [of ?\<rho>' w' e] D.hseqI' by simp
---
>                   using w' w'e D.assoc'_naturality [of ?\<rho>' w' e] by simp
4611,4613c4604,4607
<                   by (metis (no_types, lifting) D.hcomp_simps(4) D.comp_assoc_assoc'(2) D.ide_char
<                       D.in_homE D.seqE T'.ide_leg1 T'.leg1_simps(3) T.leg0_simps(2) T.tab_simps(2)
<                       \<open>trg\<^sub>D w' = map\<^sub>0 (src\<^sub>C \<rho>)\<close> preserves_src)
---
>                   by (metis (no_types, lifting) D.comp_assoc_assoc'(2) D.hcomp_simps(1)
>                       D.hcomp_simps(4) D.hseqI' D.ide_char D.in_homE D.vconn_implies_hpar(1)
>                       D.vconn_implies_hpar(3) T'.ide_leg1 T.leg1_simps(2) T.leg1_simps(3)
>                       T.tab_simps(2) \<open>trg\<^sub>D w' = map\<^sub>0 (src\<^sub>C \<rho>)\<close> preserves_src)
4731c4725
<                   using 2 \<phi> \<phi>' D.hseqI'
---
>                   using 2 \<phi> \<phi>'
4866,4868c4860,4871
<                 thus ?thesis using is_faithful
<                   by (metis C.hcomp_simps(3-4) C.in_homE D.arrI D.not_arr_null
<                       F\<beta>\<^sub>C T.leg1_simps(5) T.leg1_simps(6) \<beta>\<^sub>C \<gamma>\<^sub>C' is_extensional)
---
>                 moreover have "C.par \<beta>\<^sub>C (g \<star>\<^sub>C \<gamma>\<^sub>C')"
>                 proof (intro conjI)
>                   show "C.arr \<beta>\<^sub>C"
>                     using \<beta>\<^sub>C by blast
>                   show 2: "C.hseq g \<gamma>\<^sub>C'"
>                     using F\<beta>\<^sub>C \<beta>\<^sub>C calculation by fastforce
>                   show "C.dom \<beta>\<^sub>C = C.dom (g \<star>\<^sub>C \<gamma>\<^sub>C')"
>                     using 2 \<beta>\<^sub>C \<gamma>\<^sub>C' by fastforce
>                   show "C.cod \<beta>\<^sub>C = C.cod (g \<star>\<^sub>C \<gamma>\<^sub>C')"
>                     using 2 \<beta>\<^sub>C \<gamma>\<^sub>C' by fastforce
>                 qed
>                 ultimately show ?thesis using is_faithful by blast
4905c4908
<                       by auto
---
>                       by fastforce
4927,4929c4930,4943
<                 thus ?thesis using is_faithful [of \<theta>\<^sub>C "\<theta>\<^sub>C' \<cdot>\<^sub>C (f \<star>\<^sub>C \<gamma>\<^sub>C')"]
<                   by (metis C.cod_comp C.dom_comp C.hcomp_simps(3) C.in_homE C.seqE
<                       D.not_arr_null T.leg0_simps(4) \<gamma>\<^sub>C' \<theta>\<^sub>C \<theta>\<^sub>C' is_extensional preserves_arr)
---
>                 moreover have "C.par \<theta>\<^sub>C (\<theta>\<^sub>C' \<cdot>\<^sub>C (f \<star>\<^sub>C \<gamma>\<^sub>C'))"
>                 proof (intro conjI)
>                   show "C.arr \<theta>\<^sub>C"
>                     using \<theta>\<^sub>C by auto
>                   show 1: "C.seq \<theta>\<^sub>C' (f \<star>\<^sub>C \<gamma>\<^sub>C')"
>                     using \<theta>\<^sub>C' \<gamma>\<^sub>C'
>                     by (metis C.arrI \<theta>\<^sub>C calculation preserves_reflects_arr)
>                   show "C.dom \<theta>\<^sub>C = C.dom (\<theta>\<^sub>C' \<cdot>\<^sub>C (f \<star>\<^sub>C \<gamma>\<^sub>C'))"
>                     using 1 \<theta>\<^sub>C \<gamma>\<^sub>C' by fastforce
>                   show "C.cod \<theta>\<^sub>C = C.cod (\<theta>\<^sub>C' \<cdot>\<^sub>C (f \<star>\<^sub>C \<gamma>\<^sub>C'))"
>                     using 1 \<theta>\<^sub>C \<gamma>\<^sub>C' \<gamma>\<^sub>C by auto
>                 qed
>                 ultimately show ?thesis
>                   using is_faithful by blast
4951,4953c4965,4970
<               apply (intro D.comp_in_homI, auto)
<                 apply (intro D.hcomp_in_vhom, auto simp add: D.vconn_implies_hpar(4))
<               by (intro D.hcomp_in_vhom, auto)
---
>               apply (intro D.comp_in_homI)
>                     apply auto[2]
>                    apply fastforce
>                   apply auto[3]
>                 apply fastforce
>               by auto
4980,4981c4997,4998
<                     using D.isomorphic_implies_ide(2) w\<^sub>C' D.comp_assoc_assoc' by auto
<                  also have "... = F g \<star>\<^sub>D \<gamma>e \<star>\<^sub>D d"
---
>                     using w'e D.isomorphic_implies_ide(2) w\<^sub>C' D.comp_assoc_assoc'(1) by auto
>                   also have "... = F g \<star>\<^sub>D \<gamma>e \<star>\<^sub>D d"
4984,4985c5001
<                       using we e.ide_right e.antipar P\<gamma>e D.hseqI'
<                       by (intro D.hcomp_in_vhom, auto)
---
>                       using we e.ide_right e.antipar P\<gamma>e by fastforce
5036c5052
<                     by (metis D.dom_trg D.hseq_char' D.in_homE D.src_dom D.src_hcomp'
---
>                     by (metis D.dom_trg D.hseq_char' D.in_homE D.src_dom D.src_hcomp
5083,5084c5099
<                     using w w' e e.antipar D.hseqI'
<                     by (intro D.seqI D.hseqI, auto)
---
>                     using w w' e e.antipar by simp
5100,5101c5115
<                     using w w' e e.antipar D.hseqI'
<                     by (intro D.seqI D.hseqI, auto)
---
>                     using w w' e e.antipar by simp
5108c5122
<                         D.iso_assoc' D.not_arr_null D.seq_if_composable D.src_hcomp' T'.ide_leg1
---
>                         D.iso_assoc' D.not_arr_null D.seq_if_composable D.src_hcomp T'.ide_leg1
5154,5155c5168,5171
<                     by (metis D.hcomp_simps(4) D.comp_null(2) D.hseq_char' D.in_homE
<                         D.src.preserves_cod D.src_cod e.counit_in_hom(2) e.counit_simps(4))
---
>                     by (metis D.cod_cod D.hcomp_simps(1) D.hcomp_simps(4)
>                         D.in_homE D.trg.preserves_reflects_arr D.vconn_implies_hpar(1)
>                         D.vconn_implies_hpar(2) D.vconn_implies_hpar(3) D.vconn_implies_hpar(4)
>                         \<open>src\<^sub>D w' = a\<close> \<open>trg\<^sub>D e = a\<close> e.counit_in_hom(2) e.counit_simps(5))
5166c5182
<                   D.src_dom D.src_hcomp' \<open>src\<^sub>D w' = a\<close> \<open>trg\<^sub>D e = a\<close>)
---
>                   D.src_dom D.src_hcomp \<open>src\<^sub>D w' = a\<close> \<open>trg\<^sub>D e = a\<close>)
5199,5200c5215,5216
<                     using 1 2 e.antipar D.isomorphic_implies_ide(2) w\<^sub>C' D.comp_assoc_assoc'
<                     by force
---
>                     using 1 2 e.antipar D.isomorphic_implies_ide(2) w\<^sub>C' w'e D.comp_assoc_assoc'
>                     by auto
5204,5205c5220
<                       using we 1 2 e.antipar P\<gamma>e D.hseqI'
<                       by (intro D.hcomp_in_vhom, auto)
---
>                       using we 1 2 e.antipar P\<gamma>e by fastforce
5276c5291
<                   using w D.comp_cod_arr D.comp_assoc_assoc' by (simp add: D.hseqI')
---
>                   using w D.comp_cod_arr D.comp_assoc_assoc' by simp
5302c5317
<                     using D.isomorphic_implies_ide(2) w\<^sub>C' D.comp_assoc_assoc' by auto
---
>                     using w'e D.isomorphic_implies_ide(2) w\<^sub>C' D.comp_assoc_assoc' by auto
5452c5467
<                     using w D.comp_cod_arr D.assoc'_in_hom(2) [of "F f" w "trg\<^sub>D e"] D.hseqI'
---
>                     using w D.comp_cod_arr D.assoc'_in_hom(2) [of "F f" w "trg\<^sub>D e"]
5632c5647
<               by (metis "1" C.arrI D.arrI D.hseqI' D.ideD(1) D.in_hhom_def D.src_hcomp'
---
>               by (metis "1" C.arrI D.arrI D.hseqI' D.ideD(1) D.in_hhom_def D.src_hcomp
5642,5643c5657,5658
<             by (metis C.cod_src C.hseqI' C.ideD(1) C.in_hhom_def C.in_homE C.src.preserves_cod
<                 C.hcomp_simps(1) \<rho>.leg0_in_hom(1) \<rho>.base_simps(2) hseq_ru)
---
>             by (metis C.hseqI' C.ideD(1) C.in_hhomE C.src_hcomp C.vconn_implies_hpar(1)
>                 C.vconn_implies_hpar(3) \<rho>.base_simps(2) \<rho>.leg0_in_hom(1) hseq_ru)
5649c5664
<               using \<phi> \<rho>'.leg0_in_hom(2) w' by auto
---
>               using \<phi> \<rho>'.leg0_in_hom(2) w' by fastforce
5743c5758
<                           C.in_hhom_def C.trg_hcomp' D.comp_inv_arr' C.ide_hcomp
---
>                           C.in_hhom_def C.trg_hcomp D.comp_inv_arr' C.ide_hcomp
5749,5750c5764
<                     using w' D.comp_inv_arr' \<Phi>_components_are_iso D.hseqI' hseq_Fg_w D.comp_cod_arr
<                     by auto
---
>                     using w' D.comp_inv_arr' hseq_Fg_w D.comp_cod_arr by auto
5790c5804
<                     by (metis C.in_hhom_def D.hcomp_simps(3) D.in_homE D.seqE \<rho>'.leg0_simps(4))
---
>                     by (metis C.in_hhom_def D.arrI D.cod_inv D.seqE)
5876,5877c5890,5891
<             by (metis C.horizontal_homs_axioms C.ideD(1) C.in_homE C.hcomp_simps(2)
<                 C.vconn_implies_hpar(4) \<rho>.leg0_simps(3) category.ide_dom horizontal_homs_def)
---
>             by (metis C.hseq_char' C.in_homE C.trg.is_extensional C.trg.preserves_hom
>                 C.trg_hcomp C.vconn_implies_hpar(2) C.vconn_implies_hpar(4) \<rho>.leg0_simps(3))
5897c5911
<                 by force
---
>                 by fastforce
5923c5937
<                           C.in_hhom_def C.trg_hcomp' D.comp_inv_arr' C.ide_hcomp
---
>                           C.in_hhom_def C.trg_hcomp D.comp_inv_arr' C.ide_hcomp
5929,5931c5943
<                     using w' D.comp_inv_arr' \<Phi>_in_hom \<Phi>_components_are_iso D.hseqI'
<                           D.comp_cod_arr hseq_fw
<                     by auto
---
>                     using w' D.comp_inv_arr' D.comp_cod_arr hseq_fw by auto
5944,5946c5956
<                     using assms(1) \<theta>' \<Phi>_components_are_iso D.comp_cod_arr D.hseqI' hseq_ru
<                           D.comp_inv_arr'
<                     by auto
---
>                     using assms(1) \<theta>' D.comp_cod_arr hseq_ru D.comp_inv_arr' by auto
5955c5965
<                     using w' \<theta>' preserves_hcomp C.hseqI' hseq_ru by auto
---
>                     using w' \<theta>' preserves_hcomp hseq_ru by auto
5962c5972
<                     using w' preserves_hcomp C.hseqI' hseq_fw by fastforce
---
>                     using w' preserves_hcomp hseq_fw by fastforce
5967c5977
<                   using w' \<theta>' C.comp_assoc hseq_ru hseq_fw C.hseqI' by auto
---
>                   using w' \<theta>' C.comp_assoc hseq_ru hseq_fw by auto
5976c5986
<                         D.ext D.seqE \<rho>.tab_in_hom(2) is_extensional preserves_reflects_arr)
---
>                         D.ext D.seqE \<rho>.tab_simps(4) is_extensional preserves_reflects_arr)
5983c5993
<                   using w \<theta> C.comp_assoc hseq_ru hseq_fw C.hseqI' D.comp_assoc by auto
---
>                   using w \<theta> C.comp_assoc hseq_ru hseq_fw D.comp_assoc by auto
5992c6002
<                     using w \<theta> preserves_hcomp C.hseqI' hseq_ru by auto
---
>                     using w \<theta> preserves_hcomp hseq_ru by auto
5999c6009
<                     using w preserves_hcomp C.hseqI' hseq_fw by fastforce
---
>                     using w preserves_hcomp hseq_fw by fastforce
6007,6009c6017
<                     using \<theta> \<Phi>_in_hom \<Phi>_components_are_iso D.comp_cod_arr hseq_ru D.hseqI'
<                           D.comp_inv_arr'
<                     by auto
---
>                     using \<theta> D.comp_cod_arr hseq_ru D.comp_inv_arr' by auto
6014c6022
<                           C.in_hhom_def C.trg_hcomp' D.comp_inv_arr' C.ide_hcomp
---
>                           C.in_hhom_def C.trg_hcomp D.comp_inv_arr' C.ide_hcomp
6020,6021c6028
<                     using w D.comp_inv_arr' \<Phi>_components_are_iso D.hseqI' D.comp_cod_arr hseq_fw
<                     by simp
---
>                     using w D.comp_inv_arr' D.comp_cod_arr hseq_fw by simp
6023,6025c6030
<                     using w \<theta> \<Phi>_components_are_iso D.comp_arr_dom D.comp_inv_arr'
<                           hseq_gw D.hseqI'
<                     by simp
---
>                     using w \<theta> D.comp_arr_dom D.comp_inv_arr' hseq_gw by simp
6046c6051
<               by (metis C.hseqI' C.ideD(1) C.src_hcomp' C.vconn_implies_hpar(3)
---
>               by (metis C.hseqI' C.ideD(1) C.src_hcomp C.vconn_implies_hpar(3)
6061,6063c6066
<                   using \<gamma> \<theta>' hseq_fw C.hseqI' preserves_comp
<                   by (metis C.hcomp_simps(4) C.in_homE C.seqI D.seqE \<rho>.leg0_simps(5) \<theta>
<                       calculation preserves_reflects_arr)
---
>                   using \<gamma> \<theta> \<theta>' hseq_fw C.hseqI' preserves_comp by force
6066,6069c6069,6072
<               thus ?thesis
<                 using \<gamma> \<theta> \<theta>' is_faithful
<                 by (metis (mono_tags, lifting) C.cod_comp C.dom_comp C.hcomp_simps(3)
<                     C.in_homE C.seqE \<rho>.leg0_simps(4) preserves_reflects_arr)
---
>               moreover have "C.par \<theta> (\<theta>' \<cdot>\<^sub>C (f \<star>\<^sub>C \<gamma>))"
>                 using \<gamma> \<theta> \<theta>' hseq_fw by fastforce
>               ultimately show ?thesis
>                 using is_faithful by blast
6085,6087c6088,6100
<               thus ?thesis
<                 using \<gamma> \<beta> is_faithful
<                 by (metis C.hcomp_simps(3-4) C.in_homE \<rho>.leg1_simps(5-6) preserves_reflects_arr)
---
>               moreover have "C.par \<beta> (g \<star>\<^sub>C \<gamma>)"
>               proof (intro conjI)
>                 show "C.arr \<beta>"
>                   using \<beta> by blast
>                 show 1: "C.hseq g \<gamma>"
>                   using \<gamma> hseq_gw by fastforce
>                 show "C.dom \<beta> = C.dom (g \<star>\<^sub>C \<gamma>)"
>                   using \<gamma> \<beta> 1 by fastforce
>                 show "C.cod \<beta> = C.cod (g \<star>\<^sub>C \<gamma>)"
>                   using \<gamma> \<beta> 1 by fastforce
>               qed
>               ultimately show ?thesis
>                 using is_faithful by blast
6133c6146
<                   using C.hseqI' \<gamma>\<^sub>1 hseq_fw preserves_hcomp by auto
---
>                   using \<gamma>\<^sub>1 hseq_fw preserves_hcomp by auto
6152c6165
<                   using C.hseqI' \<gamma>\<^sub>2 hseq_fw preserves_hcomp by auto
---
>                   using \<gamma>\<^sub>2 hseq_fw preserves_hcomp by auto
==========
BNF_Operations
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/BNF_Operations/LFP.thy ../../AFPs/afp-2020/thys/BNF_Operations/LFP.thy
363c363
< lemma F1set1_bd': "|F1set1 x| \<le>o F1bd' +c F2bd'"
---
> lemma F1set1_bd: "|F1set1 x| \<le>o bd_F1 +c bd_F2"
365c365
<    apply (rule F1set1_bd_incr)
---
>    apply (rule F1.set_bd(1))
367c367
<   apply (rule F1bd'_Card_order)
---
>   apply (rule F1.bd_Card_order)
370c370
< lemma F1set2_bd': "|F1set2 x| \<le>o F1bd' +c F2bd'"
---
> lemma F1set2_bd: "|F1set2 x| \<le>o bd_F1 +c bd_F2"
372c372
<    apply (rule F1set2_bd_incr)
---
>    apply (rule F1.set_bd(2))
374c374
<   apply (rule F1bd'_Card_order)
---
>   apply (rule F1.bd_Card_order)
377c377
< lemma F1set3_bd': "|F1set3 x| \<le>o F1bd' +c F2bd'"
---
> lemma F1set3_bd: "|F1set3 x| \<le>o bd_F1 +c bd_F2"
379c379
<    apply (rule F1set3_bd_incr)
---
>    apply (rule F1.set_bd(3))
381c381
<   apply (rule F1bd'_Card_order)
---
>   apply (rule F1.bd_Card_order)
384c384
< lemma F2set1_bd': "|F2set1 x| \<le>o F1bd' +c F2bd'"
---
> lemma F2set1_bd: "|F2set1 x| \<le>o bd_F1 +c bd_F2"
386c386
<    apply (rule F2set1_bd_incr)
---
>    apply (rule F2.set_bd(1))
388c388
<   apply (rule F2bd'_Card_order)
---
>   apply (rule F2.bd_Card_order)
391c391
< lemma F2set2_bd': "|F2set2 x| \<le>o F1bd' +c F2bd'"
---
> lemma F2set2_bd: "|F2set2 x| \<le>o bd_F1 +c bd_F2"
393c393
<    apply (rule F2set2_bd_incr)
---
>    apply (rule F2.set_bd(2))
395c395
<   apply (rule F2bd'_Card_order)
---
>   apply (rule F2.bd_Card_order)
398c398
< lemma F2set3_bd': "|F2set3 x| \<le>o F1bd' +c F2bd'"
---
> lemma F2set3_bd: "|F2set3 x| \<le>o bd_F1 +c bd_F2"
400c400
<    apply (rule F2set3_bd_incr)
---
>    apply (rule F2.set_bd(3))
402c402
<   apply (rule F2bd'_Card_order)
---
>   apply (rule F2.bd_Card_order)
2311c2311
< abbreviation IFbd where "IFbd \<equiv> F1bd' +c F2bd'"
---
> abbreviation IFbd where "IFbd \<equiv> bd_F1 +c bd_F2"
2315,2316c2315,2316
<    apply (rule F1bd'_card_order)
<   apply (rule F2bd'_card_order)
---
>    apply (rule F1.bd_card_order)
>   apply (rule F2.bd_card_order)
2321c2321
<   apply (rule F1bd'_Cinfinite)
---
>   apply (rule F1.bd_Cinfinite)
2577c2577
<      apply (rule F1set1_bd')
---
>      apply (rule F1set1_bd)
2580c2580
<         apply (rule F1set2_bd')
---
>         apply (rule F1set2_bd)
2585c2585
<        apply (rule F1set3_bd')
---
>        apply (rule F1set3_bd)
2596c2596
<     apply (rule F2set1_bd')
---
>     apply (rule F2set1_bd)
2599c2599
<        apply (rule F2set2_bd')
---
>        apply (rule F2set2_bd)
2604c2604
<       apply (rule F2set3_bd')
---
>       apply (rule F2set3_bd)
==========
Buchi_Complementation
Only in ../../AFPs/afp-2019/thys/Buchi_Complementation/code: Automaton.sml
Only in ../../AFPs/afp-2020/thys/Buchi_Complementation/code: Autool.mlb
Only in ../../AFPs/afp-2020/thys/Buchi_Complementation/code: Autool.sml
Only in ../../AFPs/afp-2020/thys/Buchi_Complementation/code: benchmark.py
Only in ../../AFPs/afp-2019/thys/Buchi_Complementation/code: Complementation.mlb
Only in ../../AFPs/afp-2019/thys/Buchi_Complementation/code: Complementation.sml
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Complementation_Build.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Complementation_Build.thy
4c4
<   imports Complementation_Final
---
> imports Complementation_Final
7c7
< external_file \<open>code/Complementation.mlb\<close>
---
> external_file \<open>code/Autool.mlb\<close>
9,10c9
< external_file \<open>code/Automaton.sml\<close>
< external_file \<open>code/Complementation.sml\<close>
---
> external_file \<open>code/Autool.sml\<close>
13c12
<   \<open>code/Complementation_Export.ML\<close> (in Complementation_Final)
---
>   \<open>code/Complementation.ML\<close> (in Complementation_Final)
15c14
<     \<open>code/Complementation.mlb\<close>
---
>     \<open>code/Autool.mlb\<close>
17,22c16,17
<     \<open>code/Automaton.sml\<close>
<     \<open>code/Complementation.sml\<close>
<   export_files \<open>code/Complementation\<close> (exe) and
<     \<open>code/Complementation_Export.sml\<close>
<     \<open>code/Complementation.out\<close>
<     \<open>code/mlmon.out\<close>
---
>     \<open>code/Autool.sml\<close>
>   export_files \<open>code/Complementation.sml\<close> and \<open>code/Autool\<close> (exe)
26,31c21,24
<       val _ =
<         exec \<open>Compilation\<close>
<           ("mv Complementation_Export.ML Complementation_Export.sml && " ^
<             File.bash_path \<^path>\<open>$ISABELLE_MLTON\<close> ^
<             " -profile time -default-type intinf Complementation.mlb");
<       val _ = exec \<open>Test\<close> "./Complementation Complementation.out";
---
>       val _ = exec \<open>Prepare\<close> "mv Complementation.ML Complementation.sml";
>       val _ = exec \<open>Compilation\<close> (File.bash_path \<^path>\<open>$ISABELLE_MLTON\<close> ^
>             " -profile time -default-type intinf Autool.mlb");
>       val _ = exec \<open>Test\<close> "./Autool help";
34c27
< end
---
> end
\ No newline at end of file
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Complementation_Final.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Complementation_Final.thy
1c1
< section \<open>Complementation to Explicit Bchi Automaton\<close>
---
> section \<open>Final Instantiation of Algorithms Related to Complementation\<close>
5a6
>   "Formula"
6a8
>   "Transition_Systems_and_Automata.NGBA_Algorithms"
9a12,20
>   subsection \<open>Syntax\<close>
> 
>   (* TODO: this syntax has unnecessarily high inner binding strength, requiring extra parentheses
>     the regular let syntax correctly uses inner binding strength 0: ("(2_ =/ _)" 10) *)
>   no_syntax "_do_let" :: "[pttrn, 'a] \<Rightarrow> do_bind" ("(2let _ =/ _)" [1000, 13] 13)
>   syntax "_do_let" :: "[pttrn, 'a] \<Rightarrow> do_bind" ("(2let _ =/ _)" 13)
> 
>   subsection \<open>Hashcodes on Complement States\<close>
> 
55a67,68
>   subsection \<open>Complementation\<close>
> 
57c70
<     assumes [simp]: "finite (nodes A)"
---
>     assumes [simp]: "finite (NBA.nodes A)"
59c72
<     shows "(?f :: ?'c, RETURN (to_nbaei (complement_4 A))) \<in> ?R"
---
>     shows "(?f :: ?'c, op_translate (complement_4 A)) \<in> ?R"
61c74
<   concrete_definition complement_impl uses complement_impl[unfolded autoref_tag_defs]
---
>   concrete_definition complement_impl uses complement_impl
64c77,106
<     assumes "finite (nodes A)"
---
>     assumes "finite (NBA.nodes A)"
>     assumes "(Ai, A) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =
>       streams (nba.alphabet A) - NBA.language A"
>     using op_translate_language[OF complement_impl.refine[OF assms]]
>     using complement_4_correct[OF assms(1)]
>     by simp
> 
>   subsection \<open>Language Subset\<close>
> 
>   definition [simp]: "op_language_subset A B \<equiv> NBA.language A \<subseteq> NBA.language B"
> 
>   lemmas [autoref_op_pat] = op_language_subset_def[symmetric]
> 
>   (* TODO: maybe we can implement emptiness check on NGBAs and skip degeneralization step *)
>   schematic_goal language_subset_impl:
>     assumes [simp]: "finite (NBA.nodes B)"
>     assumes [autoref_rules]: "(Ai, A) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     assumes [autoref_rules]: "(Bi, B) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "(?f :: ?'c, do {
>       let AB' = intersect A (complement_4 B);
>       ASSERT (finite (NBA.nodes AB'));
>       RETURN (NBA.language AB' = {})
>     }) \<in> ?R"
> 		by (autoref_monadic (plain))
>   concrete_definition language_subset_impl uses language_subset_impl
>   lemma language_subset_impl_refine[autoref_rules]:
>     assumes "SIDE_PRECOND (finite (NBA.nodes A))"
>     assumes "SIDE_PRECOND (finite (NBA.nodes B))"
>     assumes "SIDE_PRECOND (nba.alphabet A \<subseteq> nba.alphabet B)"
66c108,110
<     shows "language (nbae_nba (nbaei_nbae (complement_impl Ai))) = streams (alphabet A) - language A"
---
>     assumes "(Bi, B) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "(language_subset_impl Ai Bi, (OP op_language_subset :::
>       \<langle>Id, nat_rel\<rangle> nbai_nba_rel \<rightarrow> \<langle>Id, nat_rel\<rangle> nbai_nba_rel \<rightarrow> bool_rel) $ A $ B) \<in> bool_rel"
68,74c112,132
<     have "(language ((nbae_nba \<circ> nbaei_nbae) (complement_impl Ai)), language (id (complement_4 A))) \<in>
<       \<langle>\<langle>Id_on (alphabet (complement_4 A))\<rangle> stream_rel\<rangle> set_rel"
<       using complement_impl.refine[OF assms, unfolded to_nbaei_def id_apply, THEN RETURN_nres_relD]
<       by parametricity
<     also have "language (id (complement_4 A)) = streams (alphabet A) - language A"
<       using assms(1) complement_4_correct by simp
<     finally show ?thesis by simp
---
>     have "(RETURN (language_subset_impl Ai Bi), do {
>       let AB' = intersect A (complement_4 B);
>       ASSERT (finite (NBA.nodes AB'));
>       RETURN (NBA.language AB' = {})
>     }) \<in> \<langle>bool_rel\<rangle> nres_rel"
>       using language_subset_impl.refine assms(2, 4, 5) unfolding autoref_tag_defs by this
>     also have "(do {
>       let AB' = intersect A (complement_4 B);
>       ASSERT (finite (NBA.nodes AB'));
>       RETURN (NBA.language AB' = {})
>     }, RETURN (NBA.language A \<subseteq> NBA.language B)) \<in> \<langle>bool_rel\<rangle> nres_rel"
>     proof refine_vcg
>       show "finite (NBA.nodes (intersect A (complement_4 B)))" using assms(1, 2) by auto
>       have 1: "NBA.language A \<subseteq> streams (nba.alphabet B)"
>         using nba.language_alphabet streams_mono2 assms(3) unfolding autoref_tag_defs by blast
>       have 2: "NBA.language (complement_4 B) = streams (nba.alphabet B) - NBA.language B"
>         using complement_4_correct assms(2) by auto
>       show "(NBA.language (intersect A (complement_4 B)) = {},
>         NBA.language A \<subseteq> NBA.language B) \<in> bool_rel" using 1 2 by auto
>     qed
>     finally show ?thesis using RETURN_nres_relD unfolding nres_rel_comp by force
77,78c135,170
<   definition nbaei_nbai :: "(String.literal, nat) nbaei \<Rightarrow> (String.literal, nat) nbai" where
<     "nbaei_nbai \<equiv> nbae_nba_impl"
---
>   subsection \<open>Language Equality\<close>
> 
>   definition [simp]: "op_language_equal A B \<equiv> NBA.language A = NBA.language B"
> 
>   lemmas [autoref_op_pat] = op_language_equal_def[symmetric]
> 
>   schematic_goal language_equal_impl:
>     assumes [simp]: "finite (NBA.nodes A)"
>     assumes [simp]: "finite (NBA.nodes B)"
>     assumes [simp]: "nba.alphabet A = nba.alphabet B"
>     assumes [autoref_rules]: "(Ai, A) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     assumes [autoref_rules]: "(Bi, B) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "(?f :: ?'c, NBA.language A \<subseteq> NBA.language B \<and> NBA.language B \<subseteq> NBA.language A) \<in> ?R"
>     by autoref
>   concrete_definition language_equal_impl uses language_equal_impl
>   lemma language_equal_impl_refine[autoref_rules]:
>     assumes "SIDE_PRECOND (finite (NBA.nodes A))"
>     assumes "SIDE_PRECOND (finite (NBA.nodes B))"
>     assumes "SIDE_PRECOND (nba.alphabet A = nba.alphabet B)"
>     assumes "(Ai, A) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     assumes "(Bi, B) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "(language_equal_impl Ai Bi, (OP op_language_equal :::
>       \<langle>Id, nat_rel\<rangle> nbai_nba_rel \<rightarrow> \<langle>Id, nat_rel\<rangle> nbai_nba_rel \<rightarrow> bool_rel) $ A $ B) \<in> bool_rel"
>     using language_equal_impl.refine[OF assms[unfolded autoref_tag_defs]] by auto
> 
>   schematic_goal product_impl:
>     assumes [simp]: "finite (NBA.nodes B)"
>     assumes [autoref_rules]: "(Ai, A) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     assumes [autoref_rules]: "(Bi, B) \<in> \<langle>Id, nat_rel\<rangle> nbai_nba_rel"
>     shows "(?f :: ?'c, do {
>       let AB' = intersect A (complement_4 B);
>       ASSERT (finite (NBA.nodes AB'));
>       op_translate AB'
>     }) \<in> ?R"
> 		by (autoref_monadic (plain))
>   concrete_definition product_impl uses product_impl
83a176,177
>     Set.empty Set.insert Set.member
>     "Inf :: 'a set set \<Rightarrow> 'a set" "Sup :: 'a set set \<Rightarrow> 'a set" image Pow set
85,87c179,182
<     nbaei alphabetei initialei transei acceptingei
<     nbaei_nbai complement_impl
<     in SML module_name Complementation file_prefix Complementation_Export
---
>     Variable Negation Conjunction Disjunction satisfies
>     nbaei alphabetei initialei transitionei acceptingei
>     nbae_nba_impl complement_impl language_equal_impl product_impl
>     in SML module_name Complementation file_prefix Complementation
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Complementation_Implement.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Complementation_Implement.thy
17c17
<   abbreviation "pred A a q \<equiv> {p. q \<in> succ A a p}"
---
>   abbreviation "pred A a q \<equiv> {p. q \<in> transition A a p}"
66,67c66,67
<       dom g = \<Union>((succ A a) ` (dom f)) \<and>
<       (\<forall> p \<in> dom f. \<forall> q \<in> succ A a p. fst (the (g q)) \<le> fst (the (f p))) \<and>
---
>       dom g = \<Union>((transition A a) ` (dom f)) \<and>
>       (\<forall> p \<in> dom f. \<forall> q \<in> transition A a p. fst (the (g q)) \<le> fst (the (f p))) \<and>
69c69
<       cs_st g = {q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))}}"
---
>       cs_st g = {q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))}}"
92,93c92,93
<       "dom g = \<Union>((succ A a) ` (dom f))"
<       "\<forall> p \<in> dom f. \<forall> q \<in> succ A a p. fst (the (g q)) \<le> fst (the (f p))"
---
>       "dom g = \<Union>((transition A a) ` (dom f))"
>       "\<forall> p \<in> dom f. \<forall> q \<in> transition A a p. fst (the (g q)) \<le> fst (the (f p))"
99c99
<       show "dom (cs_lr g) = \<Union> (succ A a ` dom (cs_lr f))" using 1 by simp
---
>       show "dom (cs_lr g) = \<Union> (transition A a ` dom (cs_lr f))" using 1 by simp
102c102
<       assume 2: "p \<in> dom (cs_lr f)" "q \<in> succ A a p"
---
>       assume 2: "p \<in> dom (cs_lr f)" "q \<in> transition A a p"
110c110
<     have 2: "cs_st g = {q \<in> \<Union> (succ A a ` cs_st (refresh_1 f)). even (fst (the (g q)))}"
---
>     have 2: "cs_st g = {q \<in> \<Union> (transition A a ` cs_st (refresh_1 f)). even (fst (the (g q)))}"
115c115
<       have 3: "the (cs_lr g q) = fst (the (g q))" if "q \<in> \<Union>((succ A a) ` (dom f))" for q
---
>       have 3: "the (cs_lr g q) = fst (the (g q))" if "q \<in> \<Union>((transition A a) ` (dom f))" for q
120c120
<       have 3: "the (cs_lr g q) = fst (the (g q))" if "q \<in> \<Union>((succ A a) ` (cs_st f))" for q
---
>       have 3: "the (cs_lr g q) = fst (the (g q))" if "q \<in> \<Union>((transition A a) ` (cs_st f))" for q
124c124
<       have "cs_st g = {q \<in> \<Union> (succ A a ` cs_st (refresh_1 f)). even (fst (the (g q)))}"
---
>       have "cs_st g = {q \<in> \<Union> (transition A a ` cs_st (refresh_1 f)). even (fst (the (g q)))}"
127,128c127,128
<       also have "{q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))} =
<         {q \<in> \<Union>((succ A a) ` (cs_st f)). even (the (cs_lr g q))}" using 3 by metis
---
>       also have "{q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))} =
>         {q \<in> \<Union>((transition A a) ` (cs_st f)). even (the (cs_lr g q))}" using 3 by metis
139,140c139,140
<       "dom g = \<Union>((succ A a) ` (dom f))"
<       "\<forall> p \<in> dom f. \<forall> q \<in> succ A a p. the (g q) \<le> the (f p)"
---
>       "dom g = \<Union>((transition A a) ` (dom f))"
>       "\<forall> p \<in> dom f. \<forall> q \<in> transition A a p. the (g q) \<le> the (f p)"
143c143
<     have 2: "Q = {q \<in> if P = {} then dom g else \<Union>((succ A a) ` P). even (the (g q))}"
---
>     have 2: "Q = {q \<in> if P = {} then dom g else \<Union>((transition A a) ` P). even (the (g q))}"
146,147c146,147
<     show "dom (cs_rep (g, Q)) = \<Union> (succ A a ` dom (refresh_1 (cs_rep (f, P))))" using 1 by simp
<     show "\<And> p q. p \<in> dom (refresh_1 (cs_rep (f, P))) \<Longrightarrow> q \<in> succ A a p \<Longrightarrow>
---
>     show "dom (cs_rep (g, Q)) = \<Union> (transition A a ` dom (refresh_1 (cs_rep (f, P))))" using 1 by simp
>     show "\<And> p q. p \<in> dom (refresh_1 (cs_rep (f, P))) \<Longrightarrow> q \<in> transition A a p \<Longrightarrow>
152c152
<     show "cs_st (cs_rep (g, Q)) = {q \<in> \<Union> (succ A a ` cs_st (refresh_1 (cs_rep (f, P)))).
---
>     show "cs_st (cs_rep (g, Q)) = {q \<in> \<Union> (transition A a ` cs_st (refresh_1 (cs_rep (f, P)))).
159c159
<       also have "dom g = \<Union>((succ A a) ` (dom f))" using 1(1) by this
---
>       also have "dom g = \<Union>((transition A a) ` (dom f))" using 1(1) by this
164c164
<       have 4: "fst (the (cs_rep (g, Q) q)) = the (g q)" if "q \<in> \<Union>((succ A a) ` P)" for q
---
>       have 4: "fst (the (cs_rep (g, Q) q)) = the (g q)" if "q \<in> \<Union>((transition A a) ` P)" for q
167,168c167,168
<       also have "\<dots> = {q \<in> \<Union>((succ A a) ` P). even (the (g q))}" unfolding 2 using False by auto
<       also have "\<dots> = {q \<in> \<Union>((succ A a) ` P). even (fst (the (cs_rep (g, Q) q)))}" using 4 by force
---
>       also have "\<dots> = {q \<in> \<Union>((transition A a) ` P). even (the (g q))}" unfolding 2 using False by auto
>       also have "\<dots> = {q \<in> \<Union>((transition A a) ` P). even (fst (the (cs_rep (g, Q) q)))}" using 4 by force
221c221
<       dom g = \<Union>((succ A a) ` (dom f)) \<and>
---
>       dom g = \<Union>((transition A a) ` (dom f)) \<and>
243c243
<       have 2: "dom g = \<Union>((succ A a) ` (dom f))" using 1 unfolding ranks_2_def by auto
---
>       have 2: "dom g = \<Union>((transition A a) ` (dom f))" using 1 unfolding ranks_2_def by auto
253c253
<         show "dom g = \<Union>((succ A a) ` (dom f))" using 2 by this
---
>         show "dom g = \<Union>((transition A a) ` (dom f))" using 2 by this
256c256
<         assume 10: "p \<in> dom f" "q \<in> succ A a p"
---
>         assume 10: "p \<in> dom f" "q \<in> transition A a p"
274c274
<         show "cs_st g = {q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))}"
---
>         show "cs_st g = {q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))}"
276c276
<           show "cs_st g \<subseteq> {q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))}"
---
>           show "cs_st g \<subseteq> {q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))}"
278c278
<           show "{q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))} \<subseteq> cs_st g"
---
>           show "{q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))} \<subseteq> cs_st g"
281c281
<             assume 10: "even (fst (the (g q)))" "p \<in> cs_st f" "q \<in> succ A a p"
---
>             assume 10: "even (fst (the (g q)))" "p \<in> cs_st f" "q \<in> transition A a p"
290,291c290,291
<       have 2: "dom g = \<Union>((succ A a) ` (dom f))" using 1 unfolding ranks_1_def by auto
<       have 3: "\<And> p q. p \<in> dom f \<Longrightarrow> q \<in> succ A a p \<Longrightarrow> fst (the (g q)) \<le> fst (the (f p))"
---
>       have 2: "dom g = \<Union>((transition A a) ` (dom f))" using 1 unfolding ranks_1_def by auto
>       have 3: "\<And> p q. p \<in> dom f \<Longrightarrow> q \<in> transition A a p \<Longrightarrow> fst (the (g q)) \<le> fst (the (f p))"
295c295
<       have 5: "cs_st g = {q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))}"
---
>       have 5: "cs_st g = {q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))}"
300c300
<         show "dom g = \<Union>((succ A a) ` (dom f))" using 2 by this
---
>         show "dom g = \<Union>((transition A a) ` (dom f))" using 2 by this
312,313c312,313
<         also have "cs_st g = {q \<in> \<Union>((succ A a) ` (cs_st f)). even (fst (the (g q)))}" using 5 by this
<         also have "q \<in> \<dots> \<longleftrightarrow> (\<exists> x \<in> cs_st f. q \<in> succ A a x) \<and> even l"
---
>         also have "cs_st g = {q \<in> \<Union>((transition A a) ` (cs_st f)). even (fst (the (g q)))}" using 5 by this
>         also have "q \<in> \<dots> \<longleftrightarrow> (\<exists> x \<in> cs_st f. q \<in> transition A a x) \<and> even l"
346c346
<   lemma bounds_3_dom[simp]: "dom (bounds_3 A a f) = \<Union>((succ A a) ` (dom f))"
---
>   lemma bounds_3_dom[simp]: "dom (bounds_3 A a f) = \<Union>((transition A a) ` (dom f))"
368c368
<       if 3: "dom g = \<Union>((succ A a) ` (dom f))" for q l d
---
>       if 3: "dom g = \<Union>((transition A a) ` (dom f))" for q l d
514,515c514,515
<     show "\<exists> g' \<in> succ (complement_4 A) a g. (f', g') \<in> R"
<       if "f' \<in> succ (complement_3 A) a f" "(f, g) \<in> R"
---
>     show "\<exists> g' \<in> transition (complement_4 A) a g. (f', g') \<in> R"
>       if "f' \<in> transition (complement_3 A) a f" "(f, g) \<in> R"
662c662
<       ASSUME (\<forall> p. finite (succ A a p));
---
>       ASSUME (\<forall> p. finite (transition A a p));
664c664
<         FOREACH (succ A a p) (\<lambda> q f.
---
>         FOREACH (transition A a p) (\<lambda> q f.
697c697
<     override_on (bounds_3 A a f) (Some \<circ> merge_5 s \<circ> bounds_3 A a (f (p := None))) (succ A a p)"
---
>     override_on (bounds_3 A a f) (Some \<circ> merge_5 s \<circ> bounds_3 A a (f (p := None))) (transition A a p)"
702,703c702,703
<       override_on (bounds_3 A a f) (Some \<circ> merge_5 s \<circ> bounds_3 A a (f (p := None))) (succ A a p) q"
<     proof (cases "q \<in> succ A a p")
---
>       override_on (bounds_3 A a f) (Some \<circ> merge_5 s \<circ> bounds_3 A a (f (p := None))) (transition A a p) q"
>     proof (cases "q \<in> transition A a p")
713c713
<         (succ A a p) q" using True by simp
---
>         (transition A a p) q" using True by simp
801c801
<     assumes succi[autoref_rules]: "(succi, succ A a) \<in> nat_rel \<rightarrow> \<langle>nat_rel\<rangle> list_set_rel"
---
>     assumes succi[autoref_rules]: "(succi, transition A a) \<in> nat_rel \<rightarrow> \<langle>nat_rel\<rangle> list_set_rel"
805c805
<     private lemma [simp]: "finite (succ A a p)"
---
>     private lemma [simp]: "finite (transition A a p)"
809c809
<     private lemma [autoref_op_pat]: "succ A a \<equiv> OP (succ A a)" by simp
---
>     private lemma [autoref_op_pat]: "transition A a \<equiv> OP (transition A a)" by simp
822c822
<   lemma bounds_7_refine: "(si, succ A a) \<in> nat_rel \<rightarrow> \<langle>nat_rel\<rangle> list_set_rel \<Longrightarrow>
---
>   lemma bounds_7_refine: "(si, transition A a) \<in> nat_rel \<rightarrow> \<langle>nat_rel\<rangle> list_set_rel \<Longrightarrow>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Complementation.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Complementation.thy
15,16c15,16
<       dom g = \<Union>((succ A a) ` (dom f)) \<and>
<       (\<forall> p \<in> dom f. \<forall> q \<in> succ A a p. the (g q) \<le> the (f p)) \<and>
---
>       dom g = \<Union> (transition A a ` dom f) \<and>
>       (\<forall> p \<in> dom f. \<forall> q \<in> transition A a p. the (g q) \<le> the (f p)) \<and>
22c22
<     "st_succ A a g P \<equiv> {q \<in> if P = {} then dom g else \<Union>((succ A a) ` P). even (the (g q))}"
---
>     "st_succ A a g P \<equiv> {q \<in> if P = {} then dom g else \<Union> (transition A a ` P). even (the (g q))}"
53c53
<     have 4: "p \<in> dom f \<Longrightarrow> q \<in> succ A a p \<Longrightarrow> the (g q) \<le> the (f p)" for p q
---
>     have 4: "p \<in> dom f \<Longrightarrow> q \<in> transition A a p \<Longrightarrow> the (g q) \<le> the (f p)" for p q
57c57
<     have 8: "dom g = \<Union>((succ A a) ` (dom f))"
---
>     have 8: "dom g = \<Union>((transition A a) ` (dom f))"
67c67
<       obtain p where 7: "p \<in> dom f" "q \<in> succ A a p" using 6 unfolding 8 by auto
---
>       obtain p where 7: "p \<in> dom f" "q \<in> transition A a p" using 6 unfolding 8 by auto
89c89
<     have 5: "\<Union>((succ A a) ` P) \<subseteq> nodes A" using 2 11 by auto
---
>     have 5: "\<Union> (transition A a ` P) \<subseteq> nodes A" using 2 11 by auto
118c118
<     have 1: "r !! k \<in> succ (complement A) (w !! k) (m !! k)" using nba.run_snth assms by force
---
>     have 1: "r !! k \<in> transition (complement A) (w !! k) (m !! k)" using nba.run_snth assms by force
120c120
<       using assms(2) 1 unfolding complement_def complement_succ_def trace_alt_def by auto
---
>       using assms(2) 1 unfolding complement_def complement_succ_def nba.trace_alt_def by auto
122c122
<       using assms(2) 1 unfolding complement_def complement_succ_def trace_alt_def by auto
---
>       using assms(2) 1 unfolding complement_def complement_succ_def nba.trace_alt_def by auto
135c135
<       "infs (accepting (complement A)) (trace (w ||| r) p)"
---
>       "infs (accepting (complement A)) (p ## r)"
137c137
<     let ?m = "p ## trace (w ||| r) p"
---
>     let ?m = "p ## r"
141c141
<       for k using complement_trace_snth 1(1) by metis
---
>       for k using complement_trace_snth 1(1) unfolding nba.trace_alt_def szip_smap_snd by metis
151c151
<       have "snd u \<in> \<Union> ((succ A (w !! fst v)) ` (dom (fst (?m !! fst v))))"
---
>       have "snd u \<in> \<Union> ((transition A (w !! fst v)) ` (dom (fst (?m !! fst v))))"
160c160
<       have 15: "snd u \<in> succ A (w !! fst v) (snd v)" using 11 by auto
---
>       have 15: "snd u \<in> transition A (w !! fst v) (snd v)" using 11 by auto
247c247
<             using 21 22 23 by (metis (no_types, lifting) mem_Collect_eq prod.collapse)
---
>             using 21 22 23 by (metis (mono_tags, lifting) mem_Collect_eq prod.collapse)
263c263
<               succ A (w !! (Suc l + i)) (snd (gtarget (stake (Suc (l + i)) (t @- s)) u))"
---
>               transition A (w !! (Suc l + i)) (snd (gtarget (stake (Suc (l + i)) (t @- s)) u))"
266c266
<             \<Union> (succ A (w !! (Suc l + i)) ` P (Suc l + i))" using 220 Suc by auto
---
>             \<Union> (transition A (w !! (Suc l + i)) ` P (Suc l + i))" using 220 Suc by auto
276c276
<             {p \<in> \<Union> (succ A (w !! (Suc l + i)) ` P (Suc l + i)). even (f (Suc (Suc l + i), p))}"
---
>             {p \<in> \<Union> (transition A (w !! (Suc l + i)) ` P (Suc l + i)). even (f (Suc (Suc l + i), p))}"
308c308
<         length_map length_stake lessI nba.target_alt_def states_alt_def zero_less_Suc)
---
>         length_map length_stake lessI nba.target_alt_def nba.states_alt_def zero_less_Suc)
317c317
<     shows "reach A w (Suc n) = \<Union>((succ A (w !! n) ` (reach A w n)))"
---
>     shows "reach A w (Suc n) = \<Union>((transition A (w !! n) ` (reach A w n)))"
328c328
<         length_map length_stake lessI nba.target_alt_def states_alt_def zero_less_Suc)
---
>         length_map length_stake lessI nba.target_alt_def nba.states_alt_def zero_less_Suc)
333c333
<     show "q \<in> \<Union>((succ A (w !! n) ` (reach A w n)))"
---
>     show "q \<in> \<Union>((transition A (w !! n) ` (reach A w n)))"
341c341
<       show "q \<in> succ A (w !! n) (target (take n r) p)" using 3 unfolding 6 by auto
---
>       show "q \<in> transition A (w !! n) (target (take n r) p)" using 3 unfolding 6 by auto
345c345
<     assume 1: "p \<in> reach A w n" "q \<in> succ A (w !! n) p"
---
>     assume 1: "p \<in> reach A w n" "q \<in> transition A (w !! n) p"
359c359
<     then \<Union>((succ A (w !! n) ` (reach A w n))) else {})"
---
>     then \<Union>((transition A (w !! n) ` (reach A w n))) else {})"
420c420
<       show "dom (g (Suc n)) = \<Union> (succ A (w !! n) ` dom (g n))" using snth_in assms(2) by auto
---
>       show "dom (g (Suc n)) = \<Union> (transition A (w !! n) ` dom (g n))" using snth_in assms(2) by auto
423c423
<       assume 100: "p \<in> dom (g n)" "q \<in> succ A (w !! n) p"
---
>       assume 100: "p \<in> dom (g n)" "q \<in> transition A (w !! n) p"
468,469c468,469
<           unfolding sscan_scons_snth[symmetric] trace_alt_def by simp
<         also have "\<dots> = succ (complement A) (w !! k) (target (stake k (w ||| stl s)) (shd s))"
---
>           unfolding sscan_scons_snth[symmetric] nba.trace_alt_def by simp
>         also have "\<dots> = transition (complement A) (w !! k) (target (stake k (w ||| stl s)) (shd s))"
472c472
<           succ (complement A) (w !! k) (target (stake k (w ||| stl s)) (shd s))" by this
---
>           transition (complement A) (w !! k) (target (stake k (w ||| stl s)) (shd s))" by this
475c475
<       show "infs (accepting (complement A)) (trace (w ||| stl s) (shd s))"
---
>       show "infs (accepting (complement A)) (shd s ## stl s)"
481c481
<           define m where "m n S \<equiv> {p \<in> \<Union>((succ A (w !! n) ` S)). even (the (g (Suc n) p))}" for n S
---
>           define m where "m n S \<equiv> {p \<in> \<Union>((transition A (w !! n) ` S)). even (the (g (Suc n) p))}" for n S
517c517
<           have 5: "\<exists> q \<in> succ A (w !! (k + n)) p. Q (Suc n) q" if "Q n p" for n p
---
>           have 5: "\<exists> q \<in> transition A (w !! (k + n)) p. Q (Suc n) q" if "Q n p" for n p
536c536
<               show "q \<in> succ A (w !! (k + n)) p" using 14(1) unfolding m_def by simp
---
>               show "q \<in> transition A (w !! (k + n)) p" using 14(1) unfolding m_def by simp
543c543
<             show "\<exists> a. (fst a \<in> alphabet A \<and> snd a \<in> succ A (fst a) p) \<and>
---
>             show "\<exists> a. (fst a \<in> alphabet A \<and> snd a \<in> transition A (fst a) p) \<and>
549c549
<             using 23(2) unfolding Q_def unfolding trace_alt_def by simp
---
>             using 23(2) unfolding Q_def unfolding nba.trace_alt_def by simp
568c568
<           also have "\<dots> = {p \<in> \<Union> (succ A (w !! (k + l)) ` P (k + l)).
---
>           also have "\<dots> = {p \<in> \<Union> (transition A (w !! (k + l)) ` P (k + l)).
586,587c586
<         then have "infs (\<lambda> (f, P). P = {}) (trace (w ||| stl s) (shd s))"
<           unfolding trace_alt_def s_def by this
---
>         then have "infs (\<lambda> (f, P). P = {}) (stl s)" unfolding s_def by simp
601c600
<       using language_alphabet that 1 by force
---
>       using nba.language_alphabet that 1 by force
Only in ../../AFPs/afp-2020/thys/Buchi_Complementation: Formula.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Graph.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Graph.thy
14c14
<     "\<lambda> u (k, p). w !! k \<in> alphabet A \<and> u \<in> {Suc k} \<times> succ A (w !! k) p \<inter> V"
---
>     "\<lambda> u (k, p). w !! k \<in> alphabet A \<and> u \<in> {Suc k} \<times> transition A (w !! k) p \<inter> V"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buchi_Complementation/Ranking.thy ../../AFPs/afp-2020/thys/Buchi_Complementation/Ranking.thy
83,84c83
<     obtain r p where 2: "run A (w ||| r) p" "p \<in> initial A" "infs (accepting A) (trace (w ||| r) p)"
<       using 1 by rule
---
>     obtain r p where 2: "run A (w ||| r) p" "p \<in> initial A" "infs (accepting A) (p ## r)" using 1 by rule
106,107c105,106
<     have 19: "infs (accepting A) (smap snd ?r)" using 2(3) unfolding trace_alt_def by simp
<     have 18: "infs (gaccepting A) ?r" using 19 by force
---
>     have 19: "infs (accepting A) (smap snd ?r)" using 2(3) by simp
>     have 18: "infs (gaccepting A) ?r" using 19 by simp
112c111
<     have 12: "infs even (smap f (gtrace ?t ?u))" using 13 by simp
---
>     have 12: "infs even (smap f (gtrace ?t ?u))" using 13 by (simp add: comp_def)
203,204c202
<     have 3: "\<And> r v. v \<in> initial A \<Longrightarrow> run A (w ||| r) v \<Longrightarrow> \<not> infs (accepting A) (trace (w ||| r) v)"
<       using assms(1) by auto
---
>     have 3: "\<And> r v. v \<in> initial A \<Longrightarrow> run A (w ||| r) v \<Longrightarrow> fins (accepting A) r" using assms(1) by auto
239,240c237
<     have 10: "\<not> infs (accepting A) (trace (w ||| s) q)" using 3 9 8 by this
<     have 11: "\<not> infs (accepting A) s" using 10 unfolding trace_alt_def by simp
---
>     have 10: "fins (accepting A) s" using 3 9 8 by this
243c240
<     also have "infs (accepting A) \<dots>" using 12 by simp
---
>     also have "infs (accepting A) \<dots>" using 12 by (simp add: comp_def)
245c242
<     show False using 11 13 by simp
---
>     show False using 10 13 by simp
==========
Budan_Fourier
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Budan_Fourier/BF_Misc.thy ../../AFPs/afp-2020/thys/Budan_Fourier/BF_Misc.thy
72c72
<   fixes p q::"'a::{field,semidom_divide_unit_factor,factorial_ring_gcd} poly"
---
>   fixes p q::"'a::field_gcd poly"
366c366
<   fixes s::"'a::factorial_ring_gcd set"
---
>   fixes s::"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize} set"
==========
Buffons_Needle
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Buffons_Needle/Buffons_Needle.thy ../../AFPs/afp-2020/thys/Buffons_Needle/Buffons_Needle.thy
17,69d16
< lemma emeasure_Un':
<   assumes "A \<in> sets M" "B \<in> sets M" "A \<inter> B \<in> null_sets M"
<   shows   "emeasure M (A \<union> B) = emeasure M A + emeasure M B"
< proof -
<   have "A \<union> B = A \<union> (B - A \<inter> B)" by blast
<   also have "emeasure M \<dots> = emeasure M A + emeasure M (B - A \<inter> B)"
<     using assms by (subst plus_emeasure) auto
<   also have "emeasure M (B - A \<inter> B) = emeasure M B"
<     using assms by (intro emeasure_Diff_null_set) auto
<   finally show ?thesis .
< qed
< 
< lemma singleton_null_set_lborel [simp,intro]: "{x} \<in> null_sets lborel"
<   by (simp add: null_sets_def)
< 
< lemma continuous_on_min [continuous_intros]:
<   fixes f g :: "'a::topological_space \<Rightarrow> 'b::linorder_topology"
<   shows "continuous_on A f \<Longrightarrow> continuous_on A g \<Longrightarrow> continuous_on A (\<lambda>x. min (f x) (g x))"
<   by (auto simp: continuous_on_def intro!: tendsto_min)
<     
< lemma integral_shift:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes cont: "continuous_on {a + c..b + c} f"
<   shows "integral {a..b} (f \<circ> (\<lambda>x. x + c)) = integral {a + c..b + c} f"
< proof (cases "a \<le> b")
<   case True
<   have "((\<lambda>x. 1 *\<^sub>R f (x + c)) has_integral integral {a+c..b+c} f) {a..b}"
<     using True cont
<     by (intro has_integral_substitution[where c = "a + c" and d = "b + c"])
<        (auto intro!: derivative_eq_intros)
<   thus ?thesis by (simp add: has_integral_iff o_def)
< qed auto
< 
< lemma arcsin_le_iff:
<   assumes "x \<ge> -1" "x \<le> 1" "y \<ge> -pi/2" "y \<le> pi/2"
<   shows   "arcsin x \<le> y \<longleftrightarrow> x \<le> sin y"
< proof -
<   have "arcsin x \<le> y \<longleftrightarrow> sin (arcsin x) \<le> sin y"
<     using arcsin_bounded[of x] assms by (subst sin_mono_le_eq) auto
<   also from assms have "sin (arcsin x) = x" by simp
<   finally show ?thesis .
< qed
< 
< lemma le_arcsin_iff:
<   assumes "x \<ge> -1" "x \<le> 1" "y \<ge> -pi/2" "y \<le> pi/2"
<   shows   "arcsin x \<ge> y \<longleftrightarrow> x \<ge> sin y"
< proof -
<   have "arcsin x \<ge> y \<longleftrightarrow> sin (arcsin x) \<ge> sin y"
<     using arcsin_bounded[of x] assms by (subst sin_mono_le_eq) auto
<   also from assms have "sin (arcsin x) = x" by simp
<   finally show ?thesis .
< qed
< 
305c252
<     AC: "A \<inter> C \<in> null_sets lborel" and BD: "B \<inter> D \<in> null_sets lborel" by simp_all
---
>     AC: "A \<inter> C \<in> null_sets lborel" and BD: "B \<inter> D \<in> null_sets lborel" by auto
438c385
<     by (rule integral_combine [symmetric]) (auto intro!: integrable_continuous_real continuous_intros)
---
>     by (rule Henstock_Kurzweil_Integration.integral_combine [symmetric]) (auto intro!: integrable_continuous_real continuous_intros)
442c389
<   also have "\<dots> = integral {0..pi/2} ?f" (is "_ = ?I") by (subst integral_reflect_real) simp_all
---
>   also have "\<dots> = integral {0..pi/2} ?f" (is "_ = ?I") by (subst Henstock_Kurzweil_Integration.integral_reflect_real) simp_all
446c393
<     by (intro integral_combine [symmetric]) (auto intro!: integrable_continuous_real continuous_intros)
---
>     by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric]) (auto intro!: integrable_continuous_real continuous_intros)
==========
CakeML
Only in ../../AFPs/afp-2019/thys/CakeML/doc: Doc_Ported.thy
Only in ../../AFPs/afp-2019/thys/CakeML: Semantics.thy
==========
CakeML_Codegen
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CakeML_Codegen/Compiler/Composition.thy ../../AFPs/afp-2020/thys/CakeML_Codegen/Compiler/Composition.thy
4,6c4
< imports
<   "../Backend/CakeML_Correctness"
<   CakeML.Semantics
---
> imports "../Backend/CakeML_Correctness"
605,608d602
< 
< lemma semantics_prog: "semantics_prog empty_state env (compile rs) (Terminate Success [])"
< unfolding semantics_prog_def evaluate_prog_with_clock_def
< by (auto split: prod.split option.split simp: compile_prog' empty_state_def empty_ffi_state_def initial_ffi_state_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CakeML_Codegen/Preproc/embed.ML ../../AFPs/afp-2020/thys/CakeML_Codegen/Preproc/embed.ML
292c292
<   Method.Basic (fn ctxt => fn _ => Method.CONTEXT_TACTIC (tac ctxt))
---
>   Method.Basic (fn ctxt => fn _ => Context_Tactic.CONTEXT_TACTIC (tac ctxt))
362c362
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CakeML_Codegen/Test/Test_Embed_Data.thy ../../AFPs/afp-2020/thys/CakeML_Codegen/Test/Test_Embed_Data.thy
26c26
<   Tree2.tree
---
>   Tree.tree
38a39
> (* Fails now, probably because of type ('a * 'b) tree
43a45
> *)
==========
Cartan_FP
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Cartan_FP/Cartan.thy ../../AFPs/afp-2020/thys/Cartan_FP/Cartan.thy
2c2
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Complex_Analysis.Complex_Analysis"
25c25
<     by (metis analytic_on_imp_differentiable_at analytic_on_open complex_derivative_chain image_subset_iff)
---
>     by (metis analytic_on_imp_differentiable_at analytic_on_open deriv_chain image_subset_iff)
106c106
<     apply (rule complex_derivative_chain)
---
>     apply (rule deriv_chain)
194c194
<     apply (subst complex_derivative_chain)
---
>     apply (subst deriv_chain)
216c216
<       by (metis comp_funpow complex_derivative_chain f_cd_mw f_cd_w fms_sb funpow_swap1 image_subset_iff o_id)
---
>       by (metis comp_funpow deriv_chain f_cd_mw f_cd_w fms_sb funpow_swap1 image_subset_iff o_id)
463c463
<       apply (subst complex_derivative_chain [where g=f and f = "\<lambda>a. (u * g a)", unfolded o_def])
---
>       apply (subst deriv_chain [where g=f and f = "\<lambda>a. (u * g a)", unfolded o_def])
==========
Catalan_Numbers
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy ../../AFPs/afp-2020/thys/Catalan_Numbers/Catalan_Auxiliary_Integral.thy
4c4
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
77c77
<     by (rule Lim_transform_eventually [rotated]) (auto intro!: eventually_at_rightI[of 0 1])  
---
>     by (rule Lim_transform_eventually) (auto intro!: eventually_at_rightI[of 0 1])  
89c89
<     by (rule Lim_transform_eventually [rotated]) (auto intro!: eventually_at_leftI[of 1])
---
>     by (rule Lim_transform_eventually) (auto intro!: eventually_at_leftI[of 1])
==========
Category2
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category2/Functors.thy ../../AFPs/afp-2020/thys/Category2/Functors.thy
241c241
<   IdentityFunctor' :: "('o,'m,'a) Category_scheme \<Rightarrow> ('o,'o,'m,'m,'a,'a) Functor" ("FId' _" [70]) where
---
>   IdentityFunctor' :: "('o,'m,'a) Category_scheme \<Rightarrow> ('o,'o,'m,'m,'a,'a) Functor" ("FId'' _" [70]) where
==========
Category3
Only in ../../AFPs/afp-2019/thys/Category3: AbstractedCategory.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/Adjunction.thy ../../AFPs/afp-2020/thys/Category3/Adjunction.thy
359,368c359,368
<     FGF: composite_functor D C C F "F o G" +
<     GFG: composite_functor C D D G "G o F" +
<     \<eta>: natural_transformation D D D.map "G o F" \<eta> +
<     \<epsilon>: natural_transformation C C "F o G" C.map \<epsilon> +
<     F\<eta>: horizontal_composite D D C D.map "G o F" F F \<eta> F +
<     \<eta>G: horizontal_composite C D D G G D.map "G o F" G \<eta> +
<     \<epsilon>F: horizontal_composite D C C F F "F o G" C.map F \<epsilon> +
<     G\<epsilon>: horizontal_composite C C D "F o G" C.map G G \<epsilon> G +
<     \<epsilon>FoF\<eta>: vertical_composite D C F "F o G o F" F "F o \<eta>" "\<epsilon> o F" +
<     G\<epsilon>o\<eta>G: vertical_composite C D G "G o F o G" G "\<eta> o G" "G o \<epsilon>"
---
>     FGF: composite_functor D C C F \<open>F o G\<close> +
>     GFG: composite_functor C D D G \<open>G o F\<close> +
>     \<eta>: natural_transformation D D D.map \<open>G o F\<close> \<eta> +
>     \<epsilon>: natural_transformation C C \<open>F o G\<close> C.map \<epsilon> +
>     F\<eta>: natural_transformation D C F \<open>F o G o F\<close> \<open>F o \<eta>\<close> +
>     \<eta>G: natural_transformation C D G \<open>G o F o G\<close> \<open>\<eta> o G\<close> +
>     \<epsilon>F: natural_transformation D C \<open>F o G o F\<close> F \<open>\<epsilon> o F\<close> +
>     G\<epsilon>: natural_transformation C D \<open>G o F o G\<close> G \<open>G o \<epsilon>\<close> +
>     \<epsilon>FoF\<eta>: vertical_composite D C F \<open>F o G o F\<close> F \<open>F o \<eta>\<close> \<open>\<epsilon> o F\<close> +
>     G\<epsilon>o\<eta>G: vertical_composite C D G \<open>G o F o G\<close> G \<open>\<eta> o G\<close> \<open>G o \<epsilon>\<close>
392,402c392,408
<     interpret FGFG: composite_functor C D C G "F o G o F" ..
<     interpret FG\<epsilon>: horizontal_composite C D C "G o F o G" G F F "G o \<epsilon>" F ..
<     interpret \<epsilon>'FG: horizontal_composite C D C G G "F o G o F" F G "\<epsilon>' o F" ..
<     interpret F\<eta>G: horizontal_composite C D C G G F "F o G o F" G "F o \<eta>" ..
<     interpret \<epsilon>'\<epsilon>: natural_transformation C C "F o G o F o G" Adj.C.map "\<epsilon>' o \<epsilon>"
<     proof -
<       interpret \<epsilon>'\<epsilon>: horizontal_composite C C C "F o G" Adj.C.map "F o G" Adj.C.map \<epsilon> \<epsilon>' ..
<       have "Adj.C.map = Adj.C.map o Adj.C.map" using Adj.C.map_def by auto
<       moreover have "F o G o F o G = (F o G) o (F o G)" by auto
<       ultimately show "natural_transformation C C (F o G o F o G) Adj.C.map (\<epsilon>' o \<epsilon>)"
<         using \<epsilon>'\<epsilon>.natural_transformation_axioms by simp
---
>     interpret FGFG: composite_functor C D C G \<open>F o G o F\<close> ..
>     interpret FG\<epsilon>: natural_transformation C C \<open>(F o G) o (F o G)\<close> \<open>F o G\<close> \<open>(F o G) o \<epsilon>\<close>
>       using Adj.\<epsilon>.natural_transformation_axioms Adj.FG.natural_transformation_axioms
>             horizontal_composite Adj.FG.functor_axioms
>       by fastforce
>     interpret F\<eta>G: natural_transformation C C \<open>F o G\<close> \<open>F o G o F o G\<close> \<open>F o \<eta> o G\<close>
>       using Adj.\<eta>.natural_transformation_axioms Adj.F\<eta>.natural_transformation_axioms
>             Adj.G.natural_transformation_axioms horizontal_composite
>       by blast
>     interpret \<epsilon>'\<epsilon>: natural_transformation C C \<open>F o G o F o G\<close> Adj.C.map \<open>\<epsilon>' o \<epsilon>\<close>
>     proof -
>       have "natural_transformation C C ((F o G) o (F o G)) Adj.C.map (\<epsilon>' o \<epsilon>)"
>         using Adj.\<epsilon>.natural_transformation_axioms Adj'.\<epsilon>.natural_transformation_axioms
>               horizontal_composite Adj.C.is_functor comp_functor_identity
>         by (metis (no_types, lifting))
>       thus "natural_transformation C C (F o G o F o G) Adj.C.map (\<epsilon>' o \<epsilon>)"
>         using o_assoc by metis
405c411
<                          C C "F o G" "F o G o F o G" Adj.C.map "F o \<eta> o G" "\<epsilon>' o \<epsilon>" ..
---
>                          C C \<open>F o G\<close> \<open>F o G o F o G\<close> Adj.C.map \<open>F o \<eta> o G\<close> \<open>\<epsilon>' o \<epsilon>\<close> ..
411,417c417,419
<     proof -
<       have "F o (\<eta> o G) = F o \<eta> o G \<and> F o (G o \<epsilon>) = F o G o \<epsilon>" by auto
<       thus ?thesis
<         using hcomp_vcomp_functor [of D C F C G "G o F o G" "\<eta> o G" G "G o \<epsilon>"]
<         by (simp add: Adj.F.functor_axioms Adj.G\<epsilon>o\<eta>G.\<sigma>.natural_transformation_axioms
<                       Adj.G\<epsilon>o\<eta>G.\<tau>.natural_transformation_axioms)
<     qed
---
>       using whisker_left Adj.F.functor_axioms Adj.G\<epsilon>.natural_transformation_axioms
>             Adj.\<eta>G.natural_transformation_axioms o_assoc
>       by (metis (no_types, lifting))
425,432c427,429
<       proof -
<         have "F \<circ> (G o F o G) = F o G o F o G \<and> F o (G o \<epsilon>) = F o G o \<epsilon>" by auto
<         thus ?thesis
<           using F\<eta>G.natural_transformation_axioms FG\<epsilon>.natural_transformation_axioms
<                 Adj'.\<epsilon>.natural_transformation_axioms vcomp_assoc comp_identity_functor
<                 comp_functor_identity
<           by simp
<       qed
---
>         using vcomp_assoc
>         by (metis (no_types, lifting) Adj'.\<epsilon>.natural_transformation_axioms
>             FG\<epsilon>.natural_transformation_axioms F\<eta>G.natural_transformation_axioms o_assoc)
443c440
<                 interchange [of C C "F o G" Adj.C.map \<epsilon> C "F o G" Adj.C.map \<epsilon>']
---
>                 interchange_spc [of C C "F o G" Adj.C.map \<epsilon> C "F o G" Adj.C.map \<epsilon>']
448,450c445,448
<         using vcomp_assoc Adj.\<epsilon>.natural_transformation_axioms
<               F\<eta>G.natural_transformation_axioms \<epsilon>'FG.natural_transformation_axioms
<         by simp
---
>         using vcomp_assoc
>         by (metis Adj'.\<epsilon>F.natural_transformation_axioms Adj.G.natural_transformation_axioms
>             Adj.\<epsilon>.natural_transformation_axioms F\<eta>G.natural_transformation_axioms
>             horizontal_composite)
455,459c453,455
<       using hcomp_functor_vcomp [of C D G C F "F o G o F" "F o \<eta>" F "\<epsilon>' o F"]
<             Adj.F\<eta>.natural_transformation_axioms Adj'.\<epsilon>F.natural_transformation_axioms
<             comp_functor_identity comp_identity_functor Adj.G.functor_axioms
<             Adj'.\<epsilon>FoF\<eta>.\<tau>.natural_transformation_axioms Adj.\<epsilon>FoF\<eta>.\<sigma>.natural_transformation_axioms
<       by simp
---
>       using whisker_right Adj'.\<epsilon>F.natural_transformation_axioms
>             Adj.F\<eta>.natural_transformation_axioms Adj.G.functor_axioms
>       by metis
474,484c470,490
<     interpret GFGF: composite_functor D C D F "G o F o G" ..
<     interpret GF\<eta>: horizontal_composite D C D F "F o G o F" G G "F o \<eta>" G ..
<     interpret \<eta>'GF: horizontal_composite D C D F F G "G o F o G" F "\<eta>' o G" ..
<     interpret G\<epsilon>F: horizontal_composite D C D F F "G o F o G" G F "G o \<epsilon>" ..
<     interpret \<eta>'\<eta>: natural_transformation D D Adj.D.map "G o F o G o F" "\<eta>' o \<eta>"
<     proof -
<       interpret \<eta>'\<eta>: horizontal_composite D D D Adj.D.map "G o F" Adj.D.map "G o F" \<eta> \<eta>' ..
<       have "Adj.D.map = Adj.D.map o Adj.D.map" using Adj.D.map_def by auto
<       moreover have "G o F o G o F = (G o F) o (G o F)" by auto
<       ultimately show "natural_transformation D D Adj.D.map (G o F o G o F) (\<eta>' o \<eta>)"
<         using \<eta>'\<eta>.natural_transformation_axioms by simp
---
>     interpret GFGF: composite_functor D C D F \<open>G o F o G\<close> ..
>     interpret GF\<eta>: natural_transformation D D \<open>G o F\<close> \<open>(G o F) o (G o F)\<close> \<open>(G o F) o \<eta>\<close>
>       using Adj.\<eta>.natural_transformation_axioms Adj.GF.functor_axioms
>             Adj.GF.natural_transformation_axioms comp_functor_identity horizontal_composite
>       by (metis (no_types, lifting))
>     interpret \<eta>'GF: natural_transformation D D \<open>G o F\<close> \<open>(G o F) o (G o F)\<close> \<open>\<eta>' o (G o F)\<close>
>       using Adj'.\<eta>.natural_transformation_axioms Adj.GF.functor_axioms
>             Adj.GF.natural_transformation_axioms comp_identity_functor horizontal_composite
>       by (metis (no_types, lifting))
>     interpret G\<epsilon>F: natural_transformation D D \<open>G o F o G o F\<close> \<open>G o F\<close> \<open>G o \<epsilon> o F\<close>
>       using Adj.\<epsilon>.natural_transformation_axioms Adj.F.natural_transformation_axioms
>             Adj.G\<epsilon>.natural_transformation_axioms horizontal_composite
>       by blast
>     interpret \<eta>'\<eta>: natural_transformation D D Adj.D.map \<open>G o F o G o F\<close> \<open>\<eta>' o \<eta>\<close>
>     proof -
>       have "natural_transformation D D Adj.D.map ((G o F) o (G o F)) (\<eta>' o \<eta>)"
>         using Adj.\<eta>.natural_transformation_axioms Adj'.\<eta>.natural_transformation_axioms
>               horizontal_composite Adj.D.natural_transformation_axioms hcomp_ide_cod
>         by (metis (no_types, lifting))
>       thus "natural_transformation D D Adj.D.map (G o F o G o F) (\<eta>' o \<eta>)"
>         using o_assoc by metis
487c493
<                          D D Adj.D.map "G o F o G o F" "G o F" "\<eta>' o \<eta>" "G o \<epsilon> o F" ..
---
>                          D D Adj.D.map \<open>G o F o G o F\<close> \<open>G o F\<close> \<open>\<eta>' o \<eta>\<close> \<open>G o \<epsilon> o F\<close> ..
493,496c499,501
<       using hcomp_vcomp_functor [of C D G D F "F o G o F" "F o \<eta>" F "\<epsilon> o F"]
<             Adj.G.functor_axioms Adj.\<epsilon>FoF\<eta>.\<sigma>.natural_transformation_axioms
<             Adj.\<epsilon>FoF\<eta>.\<tau>.natural_transformation_axioms
<       by simp
---
>       using whisker_left Adj.F\<eta>.natural_transformation_axioms Adj.G.functor_axioms
>             Adj.\<epsilon>F.natural_transformation_axioms
>       by fastforce
499,507c504,506
<     proof -
<       have "G o (F o G o F) = G o F o G o F \<and> G o (\<epsilon> o F) = G o \<epsilon> o F" by auto
<       thus ?thesis
<         using vcomp_assoc
<                 [of D D Adj.D.map "G o F" \<eta>' "G o F o G o F" "G o (F o \<eta>)" "G o F" "G o \<epsilon> o F"]
<               Adj'.\<eta>.natural_transformation_axioms G\<epsilon>F.natural_transformation_axioms
<               GF\<eta>.natural_transformation_axioms
<         by simp
<     qed
---
>       using vcomp_assoc Adj'.\<eta>.natural_transformation_axioms
>             GF\<eta>.natural_transformation_axioms G\<epsilon>F.natural_transformation_axioms o_assoc
>       by (metis (no_types, lifting))
515c514
<         using interchange [of D D Adj.D.map "G o F" \<eta> D Adj.D.map "G o F" \<eta>']
---
>         using interchange_spc [of D D Adj.D.map "G o F" \<eta> D Adj.D.map "G o F" \<eta>']
521,529c520,522
<     proof -
<       have "G o (F o G o F) = G o F o G o F \<and> G o (F o \<eta>) = G o F o \<eta>" by auto
<       thus ?thesis
<         using vcomp_assoc
<                 [of D D Adj.D.map "G o F" \<eta> "G o F o G o F" "\<eta>' o G o F" "G o F" "G o \<epsilon> o F"]
<               Adj.\<eta>.natural_transformation_axioms \<eta>'GF.natural_transformation_axioms
<               G\<epsilon>F.natural_transformation_axioms
<         by simp
<     qed
---
>       using vcomp_assoc
>       by (metis (no_types, lifting) Adj.\<eta>.natural_transformation_axioms
>           G\<epsilon>F.natural_transformation_axioms \<eta>'GF.natural_transformation_axioms o_assoc)
532,542c525,527
<     proof -
<       have "G o (F o G) = G o F o G" by auto
<       moreover have "G \<circ> Adj.C.map = G"
<         using Functor.comp_functor_identity Adj.G.functor_axioms by simp
<       ultimately show ?thesis
<         using hcomp_functor_vcomp [of D C F D "Adj.D.map \<circ> G" "G o F o G" "\<eta>' o G"
<                                       G "G o \<epsilon>"]
<               Adj'.\<eta>G.natural_transformation_axioms Adj.G\<epsilon>.natural_transformation_axioms
<               Adj.F.functor_axioms
<         by simp
<     qed
---
>       using whisker_right Adj'.\<eta>G.natural_transformation_axioms Adj.F.functor_axioms
>             Adj.G\<epsilon>.natural_transformation_axioms
>       by fastforce
583,588c568,573
<     F\<eta>: horizontal_composite D D C D.map "G o F" F F \<eta> F +
<     \<eta>G: horizontal_composite C D D G G D.map "G o F" G \<eta> +
<     \<epsilon>F: horizontal_composite D C C F F "F o G" C.map F \<epsilon> +
<     G\<epsilon>: horizontal_composite C C D "F o G" C.map G G \<epsilon> G +
<     \<epsilon>FoF\<eta>: vertical_composite D C F FGF.map F F\<eta>.map \<epsilon>F.map +
<     G\<epsilon>o\<eta>G: vertical_composite C D G GFG.map G \<eta>G.map G\<epsilon>.map +
---
>     F\<eta>: natural_transformation D C F \<open>F o G o F\<close> \<open>F o \<eta>\<close> +
>     \<eta>G: natural_transformation C D G \<open>G o F o G\<close> \<open>\<eta> o G\<close> +
>     \<epsilon>F: natural_transformation D C \<open>F o G o F\<close> F \<open>\<epsilon> o F\<close> +
>     G\<epsilon>: natural_transformation C D \<open>G o F o G\<close> G \<open>G o \<epsilon>\<close> +
>     \<epsilon>FoF\<eta>: vertical_composite D C F FGF.map F \<open>F o \<eta>\<close> \<open>\<epsilon> o F\<close> +
>     G\<epsilon>o\<eta>G: vertical_composite C D G GFG.map G \<open>\<eta> o G\<close> \<open>G o \<epsilon>\<close> +
728,742c713,741
<     interpretation F\<eta>: horizontal_composite D D C D.map "G o F" F F \<eta>.map F ..
<     interpretation F\<eta>: natural_transformation D C F "F o G o F" "F o \<eta>.map"
<       apply unfold_locales using F\<eta>.is_extensional F\<eta>.is_natural_1 F\<eta>.is_natural_2 by auto
< 
<     interpretation \<epsilon>F: horizontal_composite D C C F F "F o G" C.map F \<epsilon>.map ..
<     interpretation \<epsilon>F: natural_transformation D C "F o G o F" F "\<epsilon>.map o F"
<       apply unfold_locales using \<epsilon>F.is_extensional \<epsilon>F.is_natural_1 \<epsilon>F.is_natural_2 by auto
< 
<     interpretation \<eta>G: horizontal_composite C D D G G D.map "G o F" G \<eta>.map ..
<     interpretation \<eta>G: natural_transformation C D G "G o F o G" "\<eta>.map o G"
<       apply unfold_locales using \<eta>G.is_extensional \<eta>G.is_natural_1 \<eta>G.is_natural_2 by auto
< 
<     interpretation G\<epsilon>: horizontal_composite C C D "F o G" C.map G G \<epsilon>.map G ..
<     interpretation G\<epsilon>: natural_transformation C D "G o F o G" G "G o \<epsilon>.map"
<       apply unfold_locales using G\<epsilon>.is_extensional G\<epsilon>.is_natural_1 G\<epsilon>.is_natural_2 by auto
---
>     interpretation F\<eta>: natural_transformation D C F \<open>F o G o F\<close> \<open>F o \<eta>.map\<close>
>     proof -
>       have "natural_transformation D C F (F o (G o F)) (F o \<eta>.map)"
>         using \<eta>.natural_transformation_axioms F.natural_transformation_axioms
>               horizontal_composite
>         by fastforce
>       thus "natural_transformation D C F (F o G o F) (F o \<eta>.map)"
>         using o_assoc by metis
>     qed
> 
>     interpretation \<epsilon>F: natural_transformation D C \<open>F o G o F\<close> F \<open>\<epsilon>.map o F\<close>
>       using \<epsilon>.natural_transformation_axioms F.natural_transformation_axioms
>             horizontal_composite
>       by fastforce
> 
>     interpretation \<eta>G: natural_transformation C D G \<open>G o F o G\<close> \<open>\<eta>.map o G\<close>
>       using \<eta>.natural_transformation_axioms G.natural_transformation_axioms
>             horizontal_composite
>       by fastforce
> 
>     interpretation G\<epsilon>: natural_transformation C D \<open>G o F o G\<close> G \<open>G o \<epsilon>.map\<close>
>     proof - 
>       have "natural_transformation C D (G o (F o G)) G (G o \<epsilon>.map)"
>         using \<epsilon>.natural_transformation_axioms G.natural_transformation_axioms
>             horizontal_composite
>         by fastforce
>       thus "natural_transformation C D (G o F o G) G (G o \<epsilon>.map)"
>         using o_assoc by metis
>     qed
744,745c743,744
<     interpretation \<epsilon>FoF\<eta>: vertical_composite D C F "F o G o F" F "F o \<eta>.map" "\<epsilon>.map o F" ..
<     interpretation G\<epsilon>o\<eta>G: vertical_composite C D G "G o F o G" G "\<eta>.map o G" "G o \<epsilon>.map" ..
---
>     interpretation \<epsilon>FoF\<eta>: vertical_composite D C F \<open>F o G o F\<close> F \<open>F o \<eta>.map\<close> \<open>\<epsilon>.map o F\<close> ..
>     interpretation G\<epsilon>o\<eta>G: vertical_composite C D G \<open>G o F o G\<close> G \<open>\<eta>.map o G\<close> \<open>G o \<epsilon>.map\<close> ..
761,767c760,762
<       proof (intro NaturalTransformation.eqI)
<         show "natural_transformation D C F F \<epsilon>FoF\<eta>.map"
<           using \<epsilon>FoF\<eta>.is_natural_transformation by auto
<         show "natural_transformation D C F F F" ..
<         show "\<And>y. D.ide y \<Longrightarrow> \<epsilon>FoF\<eta>.map y = F y"
<           using \<epsilon>FoF\<eta>.map_simp_ide unit_counit_F by auto
<       qed
---
>         using \<epsilon>FoF\<eta>.is_natural_transformation \<epsilon>FoF\<eta>.map_simp_ide unit_counit_F
>               F.natural_transformation_axioms
>         by (intro NaturalTransformation.eqI, auto)
769,775c764,766
<       proof (intro NaturalTransformation.eqI)
<         show "natural_transformation C D G G G\<epsilon>o\<eta>G.map"
<           using G\<epsilon>o\<eta>G.is_natural_transformation by auto
<         show "natural_transformation C D G G G" ..
<         show "\<And>x. C.ide x \<Longrightarrow> G\<epsilon>o\<eta>G.map x = G x"
<           using G\<epsilon>o\<eta>G.map_simp_ide unit_counit_G by auto
<       qed
---
>         using G\<epsilon>o\<eta>G.is_natural_transformation G\<epsilon>o\<eta>G.map_simp_ide unit_counit_G
>               G.natural_transformation_axioms
>         by (intro NaturalTransformation.eqI, auto)
792,793c783,784
<     abbreviation \<eta> :: "'d \<Rightarrow> 'd" where "\<eta> \<equiv> \<eta>.map"
<     abbreviation \<epsilon> :: "'c \<Rightarrow> 'c" where "\<epsilon> \<equiv> \<epsilon>.map"
---
>     definition \<eta> :: "'d \<Rightarrow> 'd" where "\<eta> \<equiv> \<eta>.map"
>     definition \<epsilon> :: "'c \<Rightarrow> 'c" where "\<epsilon> \<equiv> \<epsilon>.map"
796c787,788
<     shows "natural_transformation D D D.map GF.map \<eta>" ..
---
>     shows "natural_transformation D D D.map GF.map \<eta>"
>       unfolding \<eta>_def ..
799c791,792
<     shows "natural_transformation C C FG.map C.map \<epsilon>" ..
---
>     shows "natural_transformation C C FG.map C.map \<epsilon>"
>       unfolding \<epsilon>_def ..
809c802
<       using induces_unit_counit_adjunction by auto
---
>       using induces_unit_counit_adjunction \<eta>_def \<epsilon>_def by auto
817c810
<       interpret \<epsilon>x: arrow_from_functor D C F "G x" x "\<epsilon> x"
---
>       interpret \<epsilon>x: arrow_from_functor D C F \<open>G x\<close> x \<open>\<epsilon> x\<close>
826c819
<           using f x \<phi>_in_hom \<psi>_\<phi> \<psi>_in_terms_of_\<epsilon> \<epsilon>x.is_coext_def arrow_from_functor.arrow
---
>           using f x \<epsilon>_def \<phi>_in_hom \<psi>_\<phi> \<psi>_in_terms_of_\<epsilon> \<epsilon>x.is_coext_def arrow_from_functor.arrow
829c822
<           using \<epsilon>o_def \<psi>_in_terms_of_\<epsilon>o x \<epsilon>_map_simp \<phi>_\<psi> \<epsilon>x.is_coext_def by simp
---
>           using \<epsilon>o_def \<psi>_in_terms_of_\<epsilon>o x \<epsilon>_map_simp \<phi>_\<psi> \<epsilon>x.is_coext_def \<epsilon>_def by simp
831c824
<       interpret \<epsilon>x: terminal_arrow_from_functor D C F "G x" x "\<epsilon> x"
---
>       interpret \<epsilon>x: terminal_arrow_from_functor D C F \<open>G x\<close> x \<open>\<epsilon> x\<close>
848c841
<       using induces_unit_counit_adjunction by auto
---
>       using induces_unit_counit_adjunction \<eta>_def \<epsilon>_def by auto
856c849
<       interpret \<eta>y: arrow_to_functor C D G y "F y" "\<eta> y"
---
>       interpret \<eta>y: arrow_to_functor C D G y \<open>F y\<close> \<open>\<eta> y\<close>
864c857
<           using g y \<psi>_in_hom \<phi>_\<psi> \<phi>_in_terms_of_\<eta> \<eta>y.is_ext_def arrow_to_functor.arrow
---
>           using g y \<psi>_in_hom \<phi>_\<psi> \<phi>_in_terms_of_\<eta> \<eta>y.is_ext_def arrow_to_functor.arrow \<eta>_def
867c860
<           using y \<eta>o_def \<phi>_in_terms_of_\<eta>o \<eta>_map_simp \<psi>_\<phi> \<eta>y.is_ext_def by simp
---
>           using y \<eta>o_def \<phi>_in_terms_of_\<eta>o \<eta>_map_simp \<psi>_\<phi> \<eta>y.is_ext_def \<eta>_def by simp
869c862
<       interpret \<eta>y: initial_arrow_to_functor C D G y "F y" "\<eta> y"
---
>       interpret \<eta>y: initial_arrow_to_functor C D G y \<open>F y\<close> \<open>\<eta> y\<close>
989c982
<       interpret terminal_arrow_from_functor D C F "Go x" x "\<epsilon>o x"
---
>       interpret terminal_arrow_from_functor D C F \<open>Go x\<close> x \<open>\<epsilon>o x\<close>
1011c1004
<       interpret x\<epsilon>: terminal_arrow_from_functor D C F "Go ?x" "?x" "\<epsilon>o ?x"
---
>       interpret x\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x\<close> \<open>?x\<close> \<open>\<epsilon>o ?x\<close>
1013c1006
<       interpret x'\<epsilon>: terminal_arrow_from_functor D C F "Go ?x'" "?x'" "\<epsilon>o ?x'"
---
>       interpret x'\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x'\<close> \<open>?x'\<close> \<open>\<epsilon>o ?x'\<close>
1030c1023
<       interpret x\<epsilon>: terminal_arrow_from_functor D C F "Go ?x" "?x" "\<epsilon>o ?x"
---
>       interpret x\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x\<close> \<open>?x\<close> \<open>\<epsilon>o ?x\<close>
1032c1025
<       interpret x'\<epsilon>: terminal_arrow_from_functor D C F "Go ?x'" "?x'" "\<epsilon>o ?x'"
---
>       interpret x'\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x'\<close> \<open>?x'\<close> \<open>\<epsilon>o ?x'\<close>
1034c1027
<       interpret x''\<epsilon>: terminal_arrow_from_functor D C F "Go ?x''" "?x''" "\<epsilon>o ?x''"
---
>       interpret x''\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x''\<close> \<open>?x''\<close> \<open>\<epsilon>o ?x''\<close>
1089c1082
<         interpret terminal_arrow_from_functor D C F "Go x" x "\<epsilon>o x"
---
>         interpret terminal_arrow_from_functor D C F \<open>Go x\<close> x \<open>\<epsilon>o x\<close>
1100c1093
<         interpret x\<epsilon>: terminal_arrow_from_functor D C F "Go ?x" ?x "\<epsilon>o ?x"
---
>         interpret x\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x\<close> ?x \<open>\<epsilon>o ?x\<close>
1102c1095
<         interpret x'\<epsilon>: terminal_arrow_from_functor D C F "Go ?x'" ?x' "\<epsilon>o ?x'"
---
>         interpret x'\<epsilon>: terminal_arrow_from_functor D C F \<open>Go ?x'\<close> ?x' \<open>\<epsilon>o ?x'\<close>
1146c1139
<       interpret x\<epsilon>: arrow_from_functor D C F "G x" x "\<epsilon>.map x"
---
>       interpret x\<epsilon>: arrow_from_functor D C F \<open>G x\<close> x \<open>\<epsilon>.map x\<close>
1157c1150
<       interpret x\<epsilon>: terminal_arrow_from_functor D C F "Go x" x "\<epsilon>o x"
---
>       interpret x\<epsilon>: terminal_arrow_from_functor D C F \<open>Go x\<close> x \<open>\<epsilon>o x\<close>
1256c1249
<       interpret initial_arrow_to_functor C D G y "Fo y" "\<eta>o y"
---
>       interpret initial_arrow_to_functor C D G y \<open>Fo y\<close> \<open>\<eta>o y\<close>
1279c1272
<       interpret y\<eta>: initial_arrow_to_functor C D G ?y "Fo ?y" "\<eta>o ?y"
---
>       interpret y\<eta>: initial_arrow_to_functor C D G ?y \<open>Fo ?y\<close> \<open>\<eta>o ?y\<close>
1281c1274
<       interpret y'\<eta>: initial_arrow_to_functor C D G ?y' "Fo ?y'" "\<eta>o ?y'"
---
>       interpret y'\<eta>: initial_arrow_to_functor C D G ?y' \<open>Fo ?y'\<close> \<open>\<eta>o ?y'\<close>
1300c1293
<       interpret y\<eta>: initial_arrow_to_functor C D G ?y "Fo ?y" "\<eta>o ?y"
---
>       interpret y\<eta>: initial_arrow_to_functor C D G ?y \<open>Fo ?y\<close> \<open>\<eta>o ?y\<close>
1302c1295
<       interpret y'\<eta>: initial_arrow_to_functor C D G ?y' "Fo ?y'" "\<eta>o ?y'"
---
>       interpret y'\<eta>: initial_arrow_to_functor C D G ?y' \<open>Fo ?y'\<close> \<open>\<eta>o ?y'\<close>
1304c1297
<       interpret y''\<eta>: initial_arrow_to_functor C D G ?y'' "Fo ?y''" "\<eta>o ?y''"
---
>       interpret y''\<eta>: initial_arrow_to_functor C D G ?y'' \<open>Fo ?y''\<close> \<open>\<eta>o ?y''\<close>
1358c1351
<         interpret initial_arrow_to_functor C D G y "Fo y" "\<eta>o y"
---
>         interpret initial_arrow_to_functor C D G y \<open>Fo y\<close> \<open>\<eta>o y\<close>
1369c1362
<         interpret y\<eta>: initial_arrow_to_functor C D G ?y "Fo ?y" "\<eta>o ?y"
---
>         interpret y\<eta>: initial_arrow_to_functor C D G ?y \<open>Fo ?y\<close> \<open>\<eta>o ?y\<close>
1371c1364
<         interpret y'\<eta>: initial_arrow_to_functor C D G ?y' "Fo ?y'" "\<eta>o ?y'"
---
>         interpret y'\<eta>: initial_arrow_to_functor C D G ?y' \<open>Fo ?y'\<close> \<open>\<eta>o ?y'\<close>
1415c1408
<       interpret y\<eta>: arrow_to_functor C D G y "F y" "\<eta>.map y"
---
>       interpret y\<eta>: arrow_to_functor C D G y \<open>F y\<close> \<open>\<eta>.map y\<close>
1426c1419
<       interpret y\<eta>: initial_arrow_to_functor C D G y "Fo y" "\<eta>o y"
---
>       interpret y\<eta>: initial_arrow_to_functor C D G y \<open>Fo y\<close> \<open>\<eta>o y\<close>
1487,1488c1480,1481
<     definition inC :: "'c \<Rightarrow> ('c+'d) SetCat.arr"
<     where "inC \<equiv> UP o Inl"
---
>     definition inC :: "'c \<Rightarrow> ('c+'d) setcat.arr"
>     where "inC \<equiv> SetCat.UP o Inl"
1490,1491c1483,1484
<     definition inD :: "'d \<Rightarrow> ('c+'d) SetCat.arr"
<     where "inD \<equiv> UP o Inr"
---
>     definition inD :: "'d \<Rightarrow> ('c+'d) setcat.arr"
>     where "inD \<equiv> SetCat.UP o Inr"
1493c1486
<     interpretation S: set_category "SetCat.comp :: ('c+'d) SetCat.arr comp"
---
>     interpretation S: set_category \<open>SetCat.comp :: ('c+'d) setcat.arr comp\<close>
1500c1493
<     interpretation HomC: hom_functor C "SetCat.comp :: ('c+'d) SetCat.arr comp" "\<lambda>_. inC"
---
>     interpretation HomC: hom_functor C \<open>SetCat.comp :: ('c+'d) setcat.arr comp\<close> \<open>\<lambda>_. inC\<close>
1505,1506c1498,1499
<       by (metis (no_types, lifting) injD inj_Inl inj_compose inj_onI)
<     interpretation HomD: hom_functor D "SetCat.comp :: ('c+'d) SetCat.arr comp" "\<lambda>_. inD"
---
>       by (metis injD inj_Inl inj_compose inj_on_def)
>     interpretation HomD: hom_functor D \<open>SetCat.comp :: ('c+'d) setcat.arr comp\<close> \<open>\<lambda>_. inD\<close>
1511c1504
<       by (metis (no_types, lifting) injD inj_Inr inj_compose inj_onI)
---
>       by (metis injD inj_Inr inj_compose inj_on_def)
2571c2564
<       using induces_unit_counit_adjunction by auto
---
>       using induces_unit_counit_adjunction \<eta>_def \<epsilon>_def by auto
2580c2573
<             \<psi>_in_terms_of_\<Psi>' \<Phi>_simp \<Psi>_simp
---
>             \<psi>_in_terms_of_\<Psi>' \<Phi>_simp \<Psi>_simp \<eta>_def \<epsilon>_def
2635c2628
<       using \<phi>\<psi>.induces_unit_counit_adjunction by auto
---
>       using \<phi>\<psi>.induces_unit_counit_adjunction \<phi>\<psi>.\<eta>_def \<phi>\<psi>.\<epsilon>_def by auto
2642c2635
<       thus "\<epsilon> x = \<psi> x (G x)" using \<phi>\<psi>.\<epsilon>_map_simp by blast
---
>       thus "\<epsilon> x = \<psi> x (G x)" using \<phi>\<psi>.\<epsilon>_map_simp \<phi>\<psi>.\<epsilon>_def by simp
2646c2639
<       thus "\<eta> y = \<phi> y (F y)" using \<phi>\<psi>.\<eta>_map_simp by blast
---
>       thus "\<eta> y = \<phi> y (F y)" using \<phi>\<psi>.\<eta>_map_simp \<phi>\<psi>.\<eta>_def by simp
2649c2642
<       show "\<phi> y f = G f \<cdot>\<^sub>D \<eta> y" using y f \<phi>\<psi>.\<phi>_in_terms_of_\<eta> by blast
---
>       show "\<phi> y f = G f \<cdot>\<^sub>D \<eta> y" using y f \<phi>\<psi>.\<phi>_in_terms_of_\<eta> \<phi>\<psi>.\<eta>_def by simp
2654c2647
<       show "\<psi> x g = \<epsilon> x \<cdot>\<^sub>C F g" using x g \<phi>\<psi>.\<psi>_in_terms_of_\<epsilon> by blast
---
>       show "\<psi> x g = \<epsilon> x \<cdot>\<^sub>C F g" using x g \<phi>\<psi>.\<psi>_in_terms_of_\<epsilon> \<phi>\<psi>.\<epsilon>_def by simp
2790,2816c2783
<   end
< 
<   sublocale composite_adjunction \<subseteq> meta_adjunction A C "F o F'" "G' o G"
<                                      "\<lambda>z. \<phi>' z o \<phi> (F' z)" "\<lambda>x. \<psi> x o \<psi>' (G x)"
<     using is_meta_adjunction by auto
< 
<   context composite_adjunction
<   begin
< 
<     interpretation K\<eta>H: natural_transformation C C "G' o F'" "G' o G o F o F'" "G' o FG.\<eta> o F'"
<     proof -
<       interpret \<eta>F': horizontal_composite C B B F' F' B.map "G o F" F' FG.\<eta> ..
<       interpret G'\<eta>F': horizontal_composite C B C "B.map o F'" "G o F o F'" G' G' \<eta>F'.map G' ..
<       have "natural_transformation
<               C C (G' o (B.map o F')) (G' o (G o F o F')) (G' o (FG.\<eta> o F'))" ..
<       moreover have "G' o (B.map o F') = G' o F'"
<         using F'.functor_axioms by auto
<       moreover have "G' o (G o F o F') = G' o G o F o F'" by auto
<       moreover have "G' o (FG.\<eta> o F') = G' o FG.\<eta> o F'" by auto
<       ultimately show
<           "natural_transformation C C (G' o F') (G' o G o F o F') (G' o FG.\<eta> o F')"
<         by auto
<     qed
<     interpretation G'\<eta>F'o\<eta>': vertical_composite C C C.map "G' o F'" "G' o G o F o F'"
<                              F'G'.\<eta> "G' o FG.\<eta> o F'" ..
< 
<     interpretation F\<epsilon>G: natural_transformation A A "F o F' o G' o G" "F o G" "F o F'G'.\<epsilon> o G"
---
>     interpretation K\<eta>H: natural_transformation C C \<open>G' o F'\<close> \<open>G' o G o F o F'\<close> \<open>G' o FG.\<eta> o F'\<close>
2818,2833c2785,2818
<       interpret F\<epsilon>': horizontal_composite B B A "F' o G'" B.map F F F'G'.\<epsilon> F ..
<       interpret F\<epsilon>'G: horizontal_composite A B A G G "F o (F' o G')" "F o B.map" G F\<epsilon>'.map ..
<       have "natural_transformation A A (F o (F' o G') o G) (F o B.map o G) F\<epsilon>'G.map" ..
<       moreover have "F o B.map o G = F o G"
<       proof -
<         (* Here F.functor_axioms does not refer to functor F, why? *)
<         have "functor B A F" ..
<         thus ?thesis using comp_functor_identity by auto
<       qed
<       moreover have "F o (F' o G') o G = F o F' o G' o G" by auto
<       ultimately show
<           "natural_transformation A A (F o F' o G' o G) (F o G) (F o F'G'.\<epsilon> o G)"
<         by auto
<     qed
<     interpretation \<epsilon>oF\<epsilon>'G: vertical_composite A A "F \<circ> F' \<circ> G' \<circ> G" "F o G" A.map
<                              "F o F'G'.\<epsilon> o G" FG.\<epsilon> ..
---
>       interpret \<eta>F': natural_transformation C B F' \<open>(G o F) o F'\<close> \<open>FG.\<eta> o F'\<close>
>         using FG.\<eta>_is_natural_transformation F'.natural_transformation_axioms
>               horizontal_composite
>         by fastforce
>       interpret G'\<eta>F': natural_transformation C C \<open>G' o F'\<close> \<open>G' o (G o F o F')\<close>
>                          \<open>G' o (FG.\<eta> o F')\<close>
>         using \<eta>F'.natural_transformation_axioms G'.natural_transformation_axioms
>               horizontal_composite
>         by blast
>       show "natural_transformation C C (G' o F') (G' o G o F o F') (G' o FG.\<eta> o F')"
>         using G'\<eta>F'.natural_transformation_axioms o_assoc by metis
>     qed
>     interpretation G'\<eta>F'o\<eta>': vertical_composite C C C.map \<open>G' o F'\<close> \<open>G' o G o F o F'\<close>
>                              F'G'.\<eta> \<open>G' o FG.\<eta> o F'\<close> ..
> 
>     interpretation F\<epsilon>G: natural_transformation A A \<open>F o F' o G' o G\<close> \<open>F o G\<close> \<open>F o F'G'.\<epsilon> o G\<close>
>     proof -
>       interpret F\<epsilon>': natural_transformation B A \<open>F o (F' o G')\<close> F \<open>F o F'G'.\<epsilon>\<close>
>         using F'G'.\<epsilon>.natural_transformation_axioms F.natural_transformation_axioms
>               horizontal_composite
>         by fastforce
>       interpret F\<epsilon>'G: natural_transformation A A \<open>F o (F' o G') o G\<close> \<open>F o G\<close> \<open>F o F'G'.\<epsilon> o G\<close>
>         using F\<epsilon>'.natural_transformation_axioms G.natural_transformation_axioms
>               horizontal_composite
>         by blast
>       show "natural_transformation A A (F o F' o G' o G) (F o G) (F o F'G'.\<epsilon> o G)"
>         using F\<epsilon>'G.natural_transformation_axioms o_assoc by metis
>     qed
>     interpretation \<epsilon>oF\<epsilon>'G: vertical_composite A A \<open>F \<circ> F' \<circ> G' \<circ> G\<close> \<open>F o G\<close> A.map
>                              \<open>F o F'G'.\<epsilon> o G\<close> FG.\<epsilon> ..
> 
>     interpretation meta_adjunction A C \<open>F o F'\<close> \<open>G' o G\<close>
>                                    \<open>\<lambda>z. \<phi>' z o \<phi> (F' z)\<close> \<open>\<lambda>x. \<psi> x o \<psi>' (G x)\<close>
>       using is_meta_adjunction by auto
2847a2833
>         unfolding \<eta>_def
2849c2835,2836
<               F'G'.\<phi>_in_terms_of_\<eta> FG.\<eta>_map_simp \<eta>_map_simp C.ide_in_hom
---
>               F'G'.\<phi>_in_terms_of_\<eta> FG.\<eta>_map_simp \<eta>_map_simp [of a] C.ide_in_hom
>               F'G'.\<eta>_def FG.\<eta>_def
2869a2857
>           unfolding \<epsilon>_def
2872a2861
>                 F'G'.\<epsilon>_def FG.\<epsilon>_def
2980c2969,2970
<                 by auto
---
>                       Adj.\<epsilon>_def Adj.\<eta>_def
>                 by simp
3027c3017
<                       Adj.C.ide_in_hom Adj.D.comp_assoc
---
>                       Adj.C.ide_in_hom Adj.D.comp_assoc Adj.\<eta>_def
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/BinaryFunctor.thy ../../AFPs/afp-2020/thys/Category3/BinaryFunctor.thy
218,219c218,219
<       interpret \<tau>: natural_transformation A2 B "\<lambda>f2. F (A1.dom f1, f2)" "\<lambda>f2. F (A1.cod f1, f2)"
<                                                "\<lambda>f2. F (f1, f2)"
---
>       interpret \<tau>: natural_transformation A2 B \<open>\<lambda>f2. F (A1.dom f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1, f2)\<close>
>                                                \<open>\<lambda>f2. F (f1, f2)\<close>
221,222c221,222
<       interpret \<tau>': natural_transformation A2 B "\<lambda>f2. F (A1.cod f1, f2)" "\<lambda>f2. F (A1.cod f1', f2)"
<                                                 "\<lambda>f2. F (f1', f2)"
---
>       interpret \<tau>': natural_transformation A2 B \<open>\<lambda>f2. F (A1.cod f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1', f2)\<close>
>                                                 \<open>\<lambda>f2. F (f1', f2)\<close>
225,226c225,226
<                         "\<lambda>f2. F (A1.dom f1, f2)" "\<lambda>f2. F (A1.cod f1, f2)" "\<lambda>f2. F (A1.cod f1', f2)"
<                         "\<lambda>f2. F (f1, f2)" "\<lambda>f2. F (f1', f2)" ..
---
>                         \<open>\<lambda>f2. F (A1.dom f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1', f2)\<close>
>                         \<open>\<lambda>f2. F (f1, f2)\<close> \<open>\<lambda>f2. F (f1', f2)\<close> ..
290c290
<       interpret Fa1: "functor" A2 B "\<lambda>f2. F (a1, f2)"
---
>       interpret Fa1: "functor" A2 B \<open>\<lambda>f2. F (a1, f2)\<close>
292c292
<       interpret Ga1: "functor" A2 B "\<lambda>f2. G (a1, f2)"
---
>       interpret Ga1: "functor" A2 B \<open>\<lambda>f2. G (a1, f2)\<close>
305c305
<       interpret Fa2: "functor" A1 B "\<lambda>f1. F (f1, a2)"
---
>       interpret Fa2: "functor" A1 B \<open>\<lambda>f1. F (f1, a2)\<close>
307c307
<       interpret Ga2: "functor" A1 B "\<lambda>f1. G (f1, a2)"
---
>       interpret Ga2: "functor" A1 B \<open>\<lambda>f1. G (f1, a2)\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/Category.thy ../../AFPs/afp-2020/thys/Category3/Category.thy
253,259c253
<     proof -
<       have "seq g f \<and> seq h g \<Longrightarrow> ?thesis"
<         using comp_assoc' by simp
<       moreover have "\<not> (seq g f \<and> seq h g) \<Longrightarrow> ?thesis"
<         using ext by (metis comp_null match_1 match_2)
<       ultimately show ?thesis by blast
<     qed
---
>       by (metis comp_assoc' ex_un_null ext match_1 match_2)
311c305
<       then show ?thesis
---
>       thus ?thesis
409c403
<         using assms(2) assms(3) domains_def domains_char ext by fastforce
---
>         using assms(2-3) domains_def domains_char ext by fastforce
413a408,415
>     text \<open>
>       This version of \<open>seqI\<close> is useful as an introduction rule, but not as useful
>       as a simplification, because it requires finding the intermediary term \<open>b\<close>.
>       Sometimes \emph{auto} is able to do this, but other times it is more expedient
>       just to invoke this rule and fill in the missing terms manually, especially
>       when dealing with a chain of compositions.
>     \<close>
> 
463a466,470
>     lemma comp_in_homI' [simp]:
>     assumes "arr f" and "arr g" and "dom f = a" and "cod g = c" and "dom g = cod f"
>     shows "\<guillemotleft>g \<cdot> f : a \<rightarrow> c\<guillemotright>"
>       using assms by auto
> 
470,478c477,481
<     lemma comp_in_hom_simp [simp]:
<     assumes "\<guillemotleft>f : a \<rightarrow> cod f\<guillemotright>" and "\<guillemotleft>g : cod f \<rightarrow> c\<guillemotright>"
<     shows "\<guillemotleft>g \<cdot> f : a \<rightarrow> c\<guillemotright>"
<       using assms by auto
< 
<     lemma comp_in_hom_simp' [simp]:
<     assumes "\<guillemotleft>f : a \<rightarrow> dom g\<guillemotright>" and "\<guillemotleft>g : dom g \<rightarrow> c\<guillemotright>"
<     shows "\<guillemotleft>g \<cdot> f : a \<rightarrow> c\<guillemotright>"
<       using assms by auto
---
>     text \<open>
>       The next two rules are useful as simplifications, but they slow down the
>       simplifier too much to use them by default.  So it is necessary to guess when
>       they are needed and cite them explicitly.  This is usually not too difficult.
>     \<close>
493a497,503
>     text \<open>
>       In some contexts, this rule causes the simplifier to loop, but it is too useful
>       not to have as a default simplification.  In cases where it is a problem, usually
>       a method like \emph{blast} or \emph{force} will succeed if this rule is cited
>       explicitly.
>     \<close>
> 
523,529c533
<     proof -
<       have "arr a \<and> dom a = a \<Longrightarrow> ide a"
<         using ide_dom [of a] by simp
<       moreover have "arr a \<and> cod a = a \<Longrightarrow> ide a"
<         using ide_cod [of a] by simp
<       ultimately show ?thesis by fastforce
<     qed
---
>       using ide_dom ide_cod ide_char by metis
531c535
<     lemma dom_dom [simp]:
---
>     lemma dom_dom:
534,537c538
<     proof -
<       have "ide (dom f)" using assms by simp
<       thus ?thesis by auto
<     qed
---
>       using assms by simp
539c540
<     lemma cod_cod [simp]:
---
>     lemma cod_cod:
542,545c543
<     proof -
<       have "ide (cod f)" using assms by simp
<       thus ?thesis by auto
<     qed
---
>       using assms by simp
547c545
<     lemma dom_cod [simp]:
---
>     lemma dom_cod:
550,553c548
<     proof -
<       have "ide (cod f)" using assms by simp
<       thus ?thesis by auto
<     qed
---
>       using assms by simp
555c550
<     lemma cod_dom [simp]:
---
>     lemma cod_dom:
558,561c553
<     proof -
<       have "ide (dom f)" using assms by simp
<       thus ?thesis by auto
<     qed
---
>       using assms by simp
582,587c574,575
<     proof -
<       have "g \<cdot> f = dom f \<and> g \<cdot> f = cod g"
<         using assms by (metis dom_comp cod_comp ide_char)
<       thus ?thesis
<         using assms ide_in_hom using seqI' by blast
<     qed
---
>       using assms dom_comp cod_comp ide_char ide_in_hom
>       by (metis seqE seqI)
630,889d617
< 
<   end
< 
<   section "Classical Categories"
< 
<   text\<open>
<     In this section we define a secondary axiomatization of categories, \<open>classical_category\<close>,
<     which is a more traditional one, except that in view of the totality of functions in HOL
<     we need to introduce predicates \<open>Obj\<close> and \<open>Arr\<close> that characterize the bona fide
<     objects and arrows among the elements of their respective types.
<     A category defined this way is not ``extensional'', in the sense that there
<     will in general be categories with the same sets of objects and arrows,
<     such that \<open>Dom\<close>, \<open>Cod\<close>, \<open>Id\<close>, and \<open>Comp\<close> agree on these
<     objects and arrows, but they do not necessarily agree on other values of the corresponding
<     types.
< 
<     We show below that an interpretation of the \<open>category\<close> induces an interpretation
<     of the \<open>classical_category\<close> locale.
<     Conversely, we show that if \<open>Obj\<close>, \<open>Arr\<close>, \<open>Dom\<close>, \<open>Cod\<close>,
<     \<open>Id\<close>, and \<open>Comp\<close> comprise an interpretation of \<open>classical_category\<close>,
<     then we can define from them a partial composition that interprets the \<open>category\<close> locale.
<     Moreover, the predicate derived \<open>arr\<close> derived from this partial composition agrees
<     with the originally given predicate \<open>Arr\<close>, the notions \<open>dom\<close>, \<open>cod\<close>,
<     and \<open>comp\<close> derived from the partial composition agree with the originally given
<     \<open>Dom\<close>, \<open>Cod\<close>, and \<open>Comp\<close> on arguments that satisfy \<open>arr\<close>,
<     and the identities derived from the partial composition are in bijective correspondence with
<     the elements that satisfy the originally given predicate \<open>Obj\<close>.
< 
<     In some cases, rather than defining a construction on categories directly
<     in terms of the partial-composition-based axioms, it can be simpler to
<     define the construction in classical terms in a convenient way, and then
<     extract a partial composition via the construction given here.
< \<close>
< 
<   locale classical_category =
<   fixes Obj :: "'obj \<Rightarrow> bool"
<   and Arr :: "'arr \<Rightarrow> bool"
<   and Dom :: "'arr \<Rightarrow> 'obj"
<   and Cod :: "'arr \<Rightarrow> 'obj"
<   and Id :: "'obj \<Rightarrow> 'arr"
<   and Comp :: "'arr \<Rightarrow> 'arr \<Rightarrow> 'arr"
<   assumes Obj_Dom: "Arr f \<Longrightarrow> Obj (Dom f)"
<   and Obj_Cod: "Arr f \<Longrightarrow> Obj (Cod f)"
<   and Arr_Id [simp]: "Obj a \<Longrightarrow> Arr (Id a)"
<   and Dom_Id [simp]: "Obj a \<Longrightarrow> Dom (Id a) = a"
<   and Cod_Id [simp]: "Obj a \<Longrightarrow> Cod (Id a) = a"
<   and Arr_Comp [simp]: "\<lbrakk> Arr f; Arr g; Cod f = Dom g \<rbrakk> \<Longrightarrow> Arr (Comp g f)"
<   and Comp_assoc [simp]: "\<lbrakk> Arr f; Arr g; Arr h; Cod f = Dom g; Cod g = Dom h \<rbrakk>
<                                               \<Longrightarrow> Comp (Comp h g) f = Comp h (Comp g f)"
<   and Dom_Comp [simp]: "\<lbrakk> Arr f; Arr g; Cod f = Dom g \<rbrakk> \<Longrightarrow> Dom (Comp g f) = Dom f"
<   and Cod_Comp [simp]: "\<lbrakk> Arr f; Arr g; Cod f = Dom g \<rbrakk> \<Longrightarrow> Cod (Comp g f) = Cod g"
<   and Comp_Arr_Id_Dom [simp]: "Arr f \<Longrightarrow> Comp f (Id (Dom f)) = f"
<   and Comp_Id_Cod_Arr [simp]: "Arr f \<Longrightarrow> Comp (Id (Cod f)) f = f"
<   begin
< 
<     abbreviation Seq
<     where "Seq g f \<equiv> (Arr f \<and> Arr g \<and> Cod f = Dom g)"
< 
<     text\<open>
<       Because @{term Arr} might be the universal predicate for type @{typ 'arr},
<       it is necessary to pass to type @{typ "'arr option"} in order to have a value
<       available to serve as \<open>null\<close>.
< \<close>
< 
<     definition comp :: "'arr option \<Rightarrow> 'arr option \<Rightarrow> 'arr option"
<     where "comp g f = (if f \<noteq> None \<and> g \<noteq> None \<and> Seq (the g) (the f)
<                        then Some (Comp (the g) (the f)) else None)"
< 
<     interpretation C: partial_magma comp
<     proof
<       show "\<exists>!n. \<forall>f. comp n f = n \<and> comp f n = n"
<       proof
<         show "\<forall>f. comp None f = None \<and> comp f None = None"
<           using comp_def by auto
<         show "\<And>n. \<forall>f. comp n f = n \<and> comp f n = n \<Longrightarrow> n = None"
<           by (metis comp_def)
<       qed
<     qed
< 
<     lemma null_char:
<     shows "C.null = None"
<     proof -
<       let ?P = "\<lambda>n. \<forall>f. comp n f = n \<and> comp f n = n"
<       have "?P None" using comp_def by auto
<       hence "(THE n. ?P n) = None"
<         using C.ex_un_null the1_equality [of ?P] by simp
<       thus ?thesis using C.null_def by auto
<     qed
< 
<     lemma ide_Some_Id:
<     assumes "Obj A"
<     shows "C.ide (Some (Id A))"
<     proof -
<       have "\<And>f. comp f (Some (Id A)) \<noteq> C.null \<Longrightarrow> comp f (Some (Id A)) = f"
<         using assms comp_def null_char by auto
<       moreover have "\<And>f. comp (Some (Id A)) f \<noteq> C.null \<Longrightarrow> comp (Some (Id A)) f = f"
<         using assms comp_def null_char by auto
<       ultimately show ?thesis
<         using assms C.ide_def comp_def null_char by auto
<     qed
< 
<     lemma has_domain_char:
<     shows "C.domains f \<noteq> {} \<longleftrightarrow> f \<noteq> None \<and> Arr (the f)"
<     proof
<       assume f: "C.domains f \<noteq> {}"
<       show "f \<noteq> None \<and> Arr (the f)"
<         using f Collect_empty_eq comp_def null_char C.domains_def by fastforce
<       next
<       assume f: "f \<noteq> None \<and> Arr (the f)"
<       have "Some (Id (Dom (the f))) \<in> C.domains f"
<         using f C.domains_def Obj_Dom comp_def null_char ide_Some_Id by auto
<       thus "C.domains f \<noteq> {}" by blast
<     qed
< 
<     lemma has_codomain_char:
<     shows "C.codomains f \<noteq> {} \<longleftrightarrow> f \<noteq> None \<and> Arr (the f)"
<     proof
<       assume f: "C.codomains f \<noteq> {}"
<       show "f \<noteq> None \<and> Arr (the f)"
<          using f Collect_empty_eq comp_def null_char C.codomains_def by fastforce
<       next
<       assume f: "f \<noteq> None \<and> Arr (the f)"
<       have "Some (Id (Cod (the f))) \<in> C.codomains f"
<         using f C.codomains_def Obj_Cod comp_def null_char ide_Some_Id by auto
<       thus "C.codomains f \<noteq> {}" by blast
<     qed
< 
<     lemma arr_char:
<     shows "C.arr f \<longleftrightarrow> f \<noteq> None \<and> Arr (the f)"
<       using has_domain_char has_codomain_char
<       by (simp add: C.arr_def)
< 
<     lemma comp_simp:
<     assumes "comp g f \<noteq> C.null"
<     shows "comp g f = Some (Comp (the g) (the f))"
<       using assms by (metis comp_def null_char)
< 
<     interpretation C: category comp
<     proof
<       fix f g h
<       show 1: "C.domains f \<noteq> {} \<longleftrightarrow> C.codomains f \<noteq> {}"
<       proof
<         assume f: "C.domains f \<noteq> {}"
<         obtain a where a: "a \<in> C.domains f" using f by blast
<         have "Some (Id (Cod (the f))) \<in> C.codomains f"
<           using a f C.codomains_def Obj_Cod has_domain_char comp_def null_char ide_Some_Id
<           by auto
<         thus "C.codomains f \<noteq> {}" by blast
<         next
<         assume f: "C.codomains f \<noteq> {}"
<         obtain b where b: "b \<in> C.codomains f" using f by blast
<         have "Some (Id (Dom (the f))) \<in> C.domains f"
<           using b f C.domains_def Obj_Dom has_codomain_char comp_def null_char ide_Some_Id
<           by auto
<         thus "C.domains f \<noteq> {}" by blast
<       qed
<       show "comp g f \<noteq> C.null \<Longrightarrow> C.seq g f"
<         using has_codomain_char null_char comp_def C.arr_def C.not_arr_null by auto
<       show "C.seq h g \<Longrightarrow> C.seq (comp h g) f \<Longrightarrow> C.seq g f"
<         by (metis Arr_Comp C.arr_def Dom_Comp has_codomain_char comp_def option.sel
<                   option.simps(3))
<       show "C.seq h (comp g f) \<Longrightarrow> C.seq g f \<Longrightarrow> C.seq h g"
<         by (metis Arr_Comp C.arr_def Cod_Comp has_domain_char comp_def option.sel
<                   option.simps(3))
<       show "C.seq g f \<Longrightarrow> C.seq h g \<Longrightarrow> C.seq (comp h g) f"
<         by (metis Arr_Comp C.arr_def Dom_Comp has_codomain_char comp_def option.sel
<                   option.simps(3))
<       thus "C.seq g f \<Longrightarrow> C.seq h g \<Longrightarrow> comp (comp h g) f = comp h (comp g f)"
<         by (metis (no_types, lifting) C.arr_def Cod_Comp Comp_assoc has_domain_char
<             has_codomain_char comp_def option.sel)
<     qed
< 
<     theorem induces_category:
<     shows "category comp" ..
< 
<     text\<open>
<       The arrows of the classical category are in bijective correspondence with the
<       arrows of the category defined by @{term comp}, and the originally given
<       @{term Dom}, @{term Cod}, and @{term Comp} coincide along this bijection with
<       @{term C.dom}, @{term C.cod}, and @{term comp}.
< \<close>
< 
<     lemma bij_betw_Arr_arr:
<     shows "bij_betw Some (Collect Arr) (Collect C.arr)"
<       using C.has_codomain_iff_arr has_codomain_char C.not_arr_null null_char
<       apply (intro bij_betwI) apply auto
<        apply fastforce
<       by (metis option.collapse)
< 
<     lemma dom_char:
<     shows "C.dom f = (if C.arr f then Some (Id (Dom (the f))) else None)"
<     proof (cases "C.arr f")
<       assume f: "C.arr f"
<       hence "C.dom f = Some (Id (Dom (the f)))"
<         using Obj_Dom arr_char ide_Some_Id arr_char comp_def
<         by (intro C.dom_eqI, auto)
<       thus ?thesis using f by auto
<       next
<       assume "\<not>C.arr f"
<       thus ?thesis
<         using C.dom_def null_char C.has_domain_iff_arr by metis
<     qed
< 
<     lemma cod_char:
<     shows "C.cod f = (if C.arr f then Some (Id (Cod (the f))) else None)"
<     proof (cases "C.arr f")
<       assume f: "C.arr f"
<       hence "C.cod f = Some (Id (Cod (the f)))"
<         using dom_char C.has_domain_iff_arr has_domain_char comp_def
<         by (metis C.comp_cod_arr C.dom_cod)
<       thus ?thesis using f by auto
<       next
<       assume "\<not>C.arr f"
<       thus ?thesis
<         using C.cod_def null_char C.has_codomain_iff_arr by metis
<     qed
< 
<     lemma comp_char:
<     shows "comp g f = (if f \<noteq> None \<and> g \<noteq> None \<and> Seq (the g) (the f)
<                        then Some (Comp (the g) (the f)) else None)"
<       using comp_def by simp
< 
<     lemma ide_char:
<     shows "C.ide a \<longleftrightarrow> Arr (the a) \<and> a = Some (Id (Dom (the a)))"
<       using C.ide_dom arr_char dom_char C.ide_in_hom by fastforce
< 
<     text\<open>
<       The objects of the classical category are in bijective correspondence with
<       the identities of the category defined by comp.
< \<close>
< 
<     lemma bij_betw_Obj_ide:
<     shows "bij_betw (Some o Id) (Collect Obj) (Collect C.ide)"
<       using ide_char Obj_Dom by (intro bij_betwI, auto)
< 
<   end
< 
<   sublocale classical_category \<subseteq> category comp
<     using induces_category by auto
< 
<   text\<open>
<     A category defined using the nonstandard, partial-composition-based axiomatization
<     admits an interpretation of the classical axioms, and the composition derived
<     from this interpretation coincides with the originally given one.
< \<close>
< 
<   context category
<   begin
< 
<     theorem is_classical_category:
<     shows "classical_category ide arr dom cod dom C"
<       using comp_arr_dom comp_cod_arr comp_assoc by (unfold_locales, auto)
< 
<     interpretation CC: classical_category ide arr dom cod dom C
<       using is_classical_category by auto
< 
<     lemma comp_agreement:
<     assumes "seq g f"
<     shows "g \<cdot> f = the (CC.comp (Some g) (Some f))"
<       using assms CC.comp_def seqE by fastforce
Only in ../../AFPs/afp-2020/thys/Category3: ConcreteCategory.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/DiscreteCategory.thy ../../AFPs/afp-2020/thys/Category3/DiscreteCategory.thy
46,53c46,47
<     proof
<       show "{x. x \<in> Obj \<and> x = f} \<subseteq> domains f"
<         unfolding domains_def
<         using ide_char ide_def by fastforce
<       show "domains f \<subseteq> {x. x \<in> Obj \<and> x = f}"
<         unfolding domains_def
<         using ide_char by (simp add: Collect_mono comp_def null_char)
<     qed
---
>       unfolding domains_def
>       using ide_char ide_def comp_def null_char by metis
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/EpiMonoIso.thy ../../AFPs/afp-2020/thys/Category3/EpiMonoIso.thy
160c160
<        from assms(1) assms(2) obtain m m'
---
>        from assms(1-2) obtain m m'
186,187c186
<          using assms
<          by (metis CollectD seqI seqE cod_comp epiE comp_assoc')
---
>          using assms by (metis CollectD epiE match_2 comp_assoc)
234,246c233,234
<         proof
<           show "ide (f \<cdot> g)" by fact
<           show "ide (g \<cdot> f)"
<           proof -
<             have "f \<cdot> g \<cdot> f = f \<cdot> dom f"
<               using f g comp_arr_dom comp_cod_arr
<               by (metis comp_assoc ide_compE mono_implies_arr)
<             hence "g \<cdot> f = dom f"
<               using f g monoE
<               by (metis (full_types) comp_arr_dom ide_compE seqE)
<             thus ?thesis using f by force
<           qed
<         qed
---
>           using f g comp_arr_dom comp_cod_arr comp_assoc inverse_arrowsI
>           by (metis ide_char' ide_compE monoE mono_implies_arr)
261,272c249,251
<         proof
<           show "ide (g \<cdot> f)" by fact
<           show "ide (f \<cdot> g)"
<           proof -
<             have "f \<cdot> g \<cdot> f = cod f \<cdot> f"
<               using f g comp_arr_dom comp_cod_arr epi_implies_arr by auto
<             hence "f \<cdot> g = cod f"
<               using f g epiE
<               by (metis comp_assoc comp_cod_arr epi_implies_arr ide_compE)
<             thus ?thesis using f by force
<           qed
<         qed
---
>           using f g comp_arr_dom comp_cod_arr epi_implies_arr
>                 comp_assoc ide_compE inverse_arrowsI epiE ide_char'
>           by metis
279,284c258,259
<     proof
<       show "iso f \<Longrightarrow> section f \<and> retraction f"
<          by (simp add: iso_is_retraction iso_is_section)
<       show "section f \<and> retraction f \<Longrightarrow> iso f"
<         using iso_iff_mono_and_retraction section_is_mono by simp
<     qed
---
>       using iso_is_retraction iso_is_section iso_iff_mono_and_retraction section_is_mono
>       by auto
293,299c268,269
<       proof
<         show "ide ((f' \<cdot> f) \<cdot> (g \<cdot> g'))"
<           using assms g g'
<           by (meson seqE ide_compE inverse_arrows_def section_retraction_compose)
<         show "ide ((g \<cdot> g') \<cdot> (f' \<cdot> f))"
<           using assms g g' inverse_arrows_def section_retraction_compose by simp
<       qed
---
>         using assms g g inverse_arrowsI inverse_arrowsE section_retraction_compose
>         by (simp add: g' inverse_arrows_compose)
402c372
<     lemma isomorphic_transitive:
---
>     lemma isomorphic_transitive [trans]:
405,410c375
<     proof -
<       obtain \<phi> where \<phi>: "iso \<phi> \<and> \<guillemotleft>\<phi> : f \<rightarrow> g\<guillemotright>" using assms isomorphic_def by blast
<       obtain \<psi> where \<psi>: "iso \<psi> \<and> \<guillemotleft>\<psi> : g \<rightarrow> h\<guillemotright>" using assms isomorphic_def by blast
<       have "iso (\<psi> \<cdot> \<phi>) \<and> \<guillemotleft>\<psi> \<cdot> \<phi> : f \<rightarrow> h\<guillemotright>" using \<phi> \<psi> isos_compose by blast
<       thus "isomorphic f h" using isomorphic_def by auto
<     qed
---
>       using assms isomorphic_def isos_compose by auto
422,424c387,388
<         using assms iso_is_retraction retraction_is_epi epiE inv_is_inverse inverse_arrowsE
<               ide_compE
<         by metis
---
>         using assms
>         by (metis comp_inv_arr' epiE ide_compE inv_is_inverse iso_iff_section_and_epi)
426,427c390,391
<         using assms iso_is_section section_is_mono monoE inv_is_inverse inverse_arrowsE ide_compE
<         by metis
---
>         using assms
>         by (metis ide_compE comp_arr_inv' inv_is_inverse iso_iff_mono_and_retraction monoE)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/EquivalenceOfCategories.thy ../../AFPs/afp-2020/thys/Category3/EquivalenceOfCategories.thy
100,101c100,101
<     interpretation \<epsilon>_inv: inverse_transformation C C "F o G" C.map \<epsilon> ..
<     interpretation \<eta>_inv: inverse_transformation D D D.map "G o F" \<eta> ..
---
>     interpretation \<epsilon>_inv: inverse_transformation C C \<open>F o G\<close> C.map \<epsilon> ..
>     interpretation \<eta>_inv: inverse_transformation D D D.map \<open>G o F\<close> \<eta> ..
158,159c158,159
<     interpretation \<epsilon>_inv: inverse_transformation C C "F o G" C.map \<epsilon> ..
<     interpretation \<eta>_inv: inverse_transformation D D D.map "G o F" \<eta> ..
---
>     interpretation \<epsilon>_inv: inverse_transformation C C \<open>F o G\<close> C.map \<epsilon> ..
>     interpretation \<eta>_inv: inverse_transformation D D D.map \<open>G o F\<close> \<eta> ..
232c232
<       interpret F\<phi>': natural_isomorphism A A F "F o F" "F o \<phi>'.map"
---
>       interpret F\<phi>': natural_isomorphism A A F \<open>F o F\<close> \<open>F o \<phi>'.map\<close>
234,236c234,237
<         interpret \<tau>: horizontal_composite A A A A.map F F F \<phi>'.map F ..
<         interpret F\<phi>': natural_transformation A A F "F o F" "F o \<phi>'.map"
<           using comp_identity_functor functor_axioms \<tau>.natural_transformation_axioms by simp
---
>         interpret F\<phi>': natural_transformation A A F \<open>F o F\<close> \<open>F o \<phi>'.map\<close>
>           using \<phi>'.natural_transformation_axioms functor_axioms
>                 horizontal_composite [of A A A.map F \<phi>'.map A F F F]
>           by simp
241,242c242,243
<       interpret F\<phi>'o\<phi>': vertical_composite A A A.map F "F o F" \<phi>'.map "F o \<phi>'.map" ..
<       interpret F\<phi>'o\<phi>': natural_isomorphism A A A.map "F o F" F\<phi>'o\<phi>'.map
---
>       interpret F\<phi>'o\<phi>': vertical_composite A A A.map F \<open>F o F\<close> \<phi>'.map \<open>F o \<phi>'.map\<close> ..
>       interpret F\<phi>'o\<phi>': natural_isomorphism A A A.map \<open>F o F\<close> F\<phi>'o\<phi>'.map
246c247
<       interpret inv_F\<phi>'o\<phi>': inverse_transformation A A A.map "F o F" F\<phi>'o\<phi>'.map ..
---
>       interpret inv_F\<phi>'o\<phi>': inverse_transformation A A A.map \<open>F o F\<close> F\<phi>'o\<phi>'.map ..
314,317c315,317
<       interpret \<epsilon>': inverse_transformation C C "F o G" C.map \<epsilon> ..
<       interpret \<eta>': inverse_transformation D D D.map "G o F" \<eta> ..
<       have 1: "G o (F o G) = (G o F) o G \<and> F o (G o F) = (F o G) o F" by auto
<       interpret G\<epsilon>': natural_transformation C D G "(G o F) o G" "G o \<epsilon>'.map"
---
>       interpret \<epsilon>': inverse_transformation C C \<open>F o G\<close> C.map \<epsilon> ..
>       interpret \<eta>': inverse_transformation D D D.map \<open>G o F\<close> \<eta> ..
>       interpret G\<epsilon>': natural_transformation C D G \<open>G o F o G\<close> \<open>G o \<epsilon>'.map\<close>
319,333c319,324
<         interpret G\<epsilon>': horizontal_composite C C D C.map "F o G" G G \<epsilon>'.map G ..
<         show "natural_transformation C D G ((G o F) o G) (G o \<epsilon>'.map)"
<           using 1 G\<epsilon>'.natural_transformation_axioms G.natural_transformation_axioms by auto
<       qed
<       interpret \<eta>'G: natural_transformation C D "(G o F) o G" G "\<eta>'.map o G"
<       proof -
<         interpret \<eta>'G: horizontal_composite C D D G G "G o F" D.map G \<eta>'.map ..
<         show "natural_transformation C D ((G o F) o G) G (\<eta>'.map o G)"
<           using 1 \<eta>'G.natural_transformation_axioms G.natural_transformation_axioms by auto
<       qed
<       interpret \<epsilon>'F: natural_transformation D C F "((F o G) o F)" "\<epsilon>'.map o F"
<       proof -
<         interpret \<epsilon>'F: horizontal_composite D C C F F C.map "F o G" F \<epsilon>'.map ..
<         show "natural_transformation D C F ((F o G) o F) (\<epsilon>'.map o F)"
<           using 1 \<epsilon>'F.natural_transformation_axioms F.natural_transformation_axioms by auto
---
>         have "natural_transformation C D G (G o (F o G)) (G o \<epsilon>'.map)"
>           using G.natural_transformation_axioms \<epsilon>'.natural_transformation_axioms
>                 horizontal_composite
>           by fastforce
>         thus "natural_transformation C D G (G o F o G) (G o \<epsilon>'.map)"
>           using o_assoc by metis
335c326,334
<       interpret F\<eta>': natural_transformation D C "(F o G) o F" F "F o \<eta>'.map"
---
>       interpret \<eta>'G: natural_transformation C D \<open>G o F o G\<close> G \<open>\<eta>'.map o G\<close>
>         using \<eta>'.natural_transformation_axioms G.natural_transformation_axioms
>               horizontal_composite
>         by fastforce
>       interpret \<epsilon>'F: natural_transformation D C F \<open>F o G o F\<close> \<open>\<epsilon>'.map o F\<close>
>         using \<epsilon>'.natural_transformation_axioms F.natural_transformation_axioms
>               horizontal_composite
>         by fastforce
>       interpret F\<eta>': natural_transformation D C \<open>F o G o F\<close> F \<open>F o \<eta>'.map\<close>
337,339c336,341
<         interpret F\<eta>': horizontal_composite D D C "G o F" D.map F F \<eta>'.map F ..
<         show "natural_transformation D C ((F o G) o F) F (F o \<eta>'.map)"
<           using 1 F\<eta>'.natural_transformation_axioms F.natural_transformation_axioms by auto
---
>         have "natural_transformation D C (F o (G o F)) F (F o \<eta>'.map)"
>           using \<eta>'.natural_transformation_axioms F.natural_transformation_axioms
>                 horizontal_composite
>           by fastforce
>         thus "natural_transformation D C (F o G o F) F (F o \<eta>'.map)"
>           using o_assoc by metis
341,342c343,344
<       interpret F\<eta>'o\<epsilon>'F: vertical_composite D C F "(F o G) o F" F "\<epsilon>'.map o F" "F o \<eta>'.map" ..
<       interpret \<eta>'GoG\<epsilon>': vertical_composite C D G "G o F o G" G "G o \<epsilon>'.map" "\<eta>'.map o G" ..
---
>       interpret F\<eta>'o\<epsilon>'F: vertical_composite D C F \<open>(F o G) o F\<close> F \<open>\<epsilon>'.map o F\<close> \<open>F o \<eta>'.map\<close> ..
>       interpret \<eta>'GoG\<epsilon>': vertical_composite C D G \<open>G o F o G\<close> G \<open>G o \<epsilon>'.map\<close> \<open>\<eta>'.map o G\<close> ..
510c512
<           interpret \<epsilon>a: terminal_arrow_from_functor D C F "G a" a "\<epsilon> a"
---
>           interpret \<epsilon>a: terminal_arrow_from_functor D C F \<open>G a\<close> a \<open>\<epsilon> a\<close>
576c578
<               interpret f\<phi>: arrow_from_functor D C F b' a "\<epsilon> a \<cdot>\<^sub>C f \<cdot>\<^sub>C \<phi>"
---
>               interpret f\<phi>: arrow_from_functor D C F b' a \<open>\<epsilon> a \<cdot>\<^sub>C f \<cdot>\<^sub>C \<phi>\<close>
579c581
<               interpret f'\<phi>: arrow_from_functor D C F b' a "\<epsilon> a \<cdot>\<^sub>C f' \<cdot>\<^sub>C \<phi>"
---
>               interpret f'\<phi>: arrow_from_functor D C F b' a \<open>\<epsilon> a \<cdot>\<^sub>C f' \<cdot>\<^sub>C \<phi>\<close>
602c604
<         interpret \<epsilon>: natural_isomorphism C C "F o G" C.map \<epsilon>
---
>         interpret \<epsilon>: natural_isomorphism C C \<open>F o G\<close> C.map \<epsilon>
604c606
<         interpret \<epsilon>F: natural_isomorphism D C "F o G o F" F "\<epsilon>F.map"
---
>         interpret \<epsilon>F: natural_isomorphism D C \<open>F o G o F\<close> F \<open>\<epsilon> o F\<close>
610c612
<           have 1: "C.iso (\<epsilon>F.map a)"
---
>           have 1: "C.iso ((\<epsilon> o F) a)"
612c614
<           moreover have "\<epsilon>F.map a \<cdot>\<^sub>C F\<eta>.map a = F a"
---
>           moreover have "(\<epsilon> o F) a \<cdot>\<^sub>C (F o \<eta>) a = F a"
614c616
<           ultimately have "C.inverse_arrows (\<epsilon>F.map a) (F\<eta>.map a)"
---
>           ultimately have "C.inverse_arrows ((\<epsilon> o F) a) ((F o \<eta>) a)"
616c618
<           hence "C.iso (F\<eta>.map a)"
---
>           hence "C.iso ((F o \<eta>) a)"
628,629c630,631
<       interpret \<epsilon>': inverse_transformation C C "F o G" C.map \<epsilon> ..
<       interpret \<eta>': inverse_transformation D D D.map "G o F" \<eta> ..
---
>       interpret \<epsilon>': inverse_transformation C C \<open>F o G\<close> C.map \<epsilon> ..
>       interpret \<eta>': inverse_transformation D D D.map \<open>G o F\<close> \<eta> ..
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/FreeCategory.thy ../../AFPs/afp-2020/thys/Category3/FreeCategory.thy
9c9
< imports Category AbstractedCategory
---
> imports Category ConcreteCategory
18,23d17
<     The development looks more complicated that it really is, for two reasons:
<     first, for each particular construction once the desired category is obtained it is
<     necessary to establish facts that completely characterize its structure and allow it to be
<     used in applications; and second, for each construction we define an opaque arrow type
<     to ensure that client theories depend only on the explicit characterizing facts and
<     not on any properties implicit in the particular construction.
131c125
<     The free category generated by a graph has as its arrows all triples @{term "(x, y, p)"},
---
>     The free category generated by a graph has as its arrows all triples @{term "MkArr x y p"},
133c127,128
<     We use an option type to provide a value to be used for @{term null}.
---
>     We construct it here an instance of the general construction given by the
>     @{locale concrete_category} locale.
144c139
<     typedef ('o, 'a) arr = "UNIV :: ('o * 'o * 'a list) option set" ..
---
>     type_synonym ('o, 'a) arr = "('o, 'a list) concrete_category.arr"
146,217c141,144
<     definition Null
<     where "Null = Abs_arr None"
< 
<     definition Dom
<     where "Dom f = fst (the (Rep_arr f))"
< 
<     definition Cod
<     where "Cod f = fst (snd (the (Rep_arr f)))"
< 
<     definition Path
<     where "Path f = snd (snd (the (Rep_arr f)))"
< 
<     definition mkArr
<     where "mkArr x y p \<equiv> if G.path x y p then Abs_arr (Some (x, y, p)) else Null"
< 
<     abbreviation isArr
<     where "isArr f \<equiv> f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"
< 
<     lemma mkArr_not_Null:
<     shows "mkArr x y p \<noteq> Null \<longleftrightarrow> G.path x y p"
<       using mkArr_def
<       by (metis Abs_arr_inverse Null_def UNIV_I option.distinct(1))
< 
<     lemma Dom_mkArr [simp]:
<     assumes "mkArr x y p \<noteq> Null"
<     shows "Dom (mkArr x y p) = x"
<       using assms mkArr_def Dom_def
<       by (metis Abs_arr_inverse UNIV_I fst_conv option.sel)
< 
<     lemma Cod_mkArr [simp]:
<     assumes "mkArr x y p \<noteq> Null"
<     shows "Cod (mkArr x y p) = y"
<       using assms mkArr_def Cod_def
<       by (metis Abs_arr_inverse UNIV_I fst_conv snd_conv option.sel)
< 
<     lemma Path_mkArr [simp]:
<     assumes "mkArr x y p \<noteq> Null"
<     shows "Path (mkArr x y p) = p"
<       using assms mkArr_def Path_def
<       by (metis Abs_arr_inverse UNIV_I snd_conv option.sel)
< 
<     lemma mkArr_Path [simp]:
<     assumes "isArr f"
<     shows "mkArr (Dom f) (Cod f) (Path f) = f"
<       by (metis Cod_def Dom_def Null_def Path_def Rep_arr_inverse assms mkArr_def
<                 option.exhaust_sel surjective_pairing)
< 
<     lemma Dom_in_Obj:
<     assumes "isArr f"
<     shows "Dom f \<in> Obj"
<       using assms G.path_def G.dom_is_obj hd_conv_nth leI length_greater_0_conv
<             less_numeral_extra(3)
<       by fastforce
< 
<     lemma Cod_in_Obj:
<     assumes "isArr f"
<     shows "Cod f \<in> Obj"
<       using assms G.path_def G.cod_is_obj
<       by (metis diff_less last_conv_nth leI length_greater_0_conv less_imp_le_nat neq0_conv
<                 not_one_le_zero)
< 
<     text\<open>
<       Composition is concatenation of paths.
< \<close>
< 
<     definition comp     (infixr "\<cdot>" 55)
<     where "g \<cdot> f \<equiv> if isArr g \<and> isArr f \<and> Dom g = Cod f
<                    then mkArr (Dom f) (Cod g) (Path f @ Path g)
<                    else Null"
< 
<     interpretation partial_magma comp
<       using comp_def by (unfold_locales, metis)
---
>     sublocale concrete_category \<open>Obj :: 'obj set\<close> \<open>\<lambda>x y. Collect (G.path x y)\<close>
>       \<open>\<lambda>_. []\<close> \<open>\<lambda>_ _ _ g f. f @ g\<close>
>       using G.path_Obj G.path_concat
>       by (unfold_locales, simp_all)
218a146,147
>     abbreviation comp      (infixr "\<cdot>" 55)
>     where "comp \<equiv> COMP"
221,365c150,151
<     lemma null_char:
<     shows "null = Null"
<       by (metis comp_null(1) comp_def)
< 
<     lemma in_Obj_implies_ide:
<     assumes "x \<in> Obj"
<     shows "ide (mkArr x x [])"
<       unfolding ide_def
<       using assms comp_def null_char Cod_mkArr Dom_mkArr Path_mkArr append_Nil append_Nil2
<             mkArr_Path G.path_Obj mkArr_not_Null
<       by fastforce
< 
<     lemma has_domain_char:
<     shows "domains f \<noteq> {} \<longleftrightarrow> isArr f"
<     proof
<       show "domains f \<noteq> {} \<Longrightarrow> isArr f"
<         unfolding domains_def
<         using Collect_empty_eq comp_def null_char by fastforce
<       show "isArr f \<Longrightarrow> domains f \<noteq> {}"
<       proof (unfold domains_def)
<         assume 1: "f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"
<         hence 2: "Dom f \<in> Obj"
<           using Dom_in_Obj by force
<         hence "comp f (mkArr (Dom f) (Dom f) []) \<noteq> null"
<           using 1 by (simp add: G.path_Obj comp_def mkArr_not_Null null_char)
<         thus "{a. ide a \<and> comp f a \<noteq> null} \<noteq> {}"
<           using 2 in_Obj_implies_ide by auto
<       qed
<     qed
< 
<     lemma has_codomain_char:
<     shows "codomains f \<noteq> {} \<longleftrightarrow> isArr f"
<     proof
<       show "codomains f \<noteq> {} \<Longrightarrow> isArr f"
<         unfolding codomains_def
<         using Collect_empty_eq comp_def null_char by fastforce
<       show "isArr f \<Longrightarrow> codomains f \<noteq> {}"
<       proof (unfold codomains_def)
<         assume 1: "f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"
<         hence 2: "Cod f \<in> Obj"
<           using Cod_in_Obj by force
<         hence "comp (mkArr (Cod f) (Cod f) []) f \<noteq> null"
<           using 1 G.path_Obj comp_def mkArr_not_Null null_char by auto
<         thus "{b. ide b \<and> comp b f \<noteq> null} \<noteq> {}"
<           using 2 in_Obj_implies_ide by auto
<       qed
<     qed
< 
<     interpretation category comp
<     proof
<       fix f g h
<       show "g \<cdot> f \<noteq> null \<Longrightarrow> seq g f"
<         using comp_def arr_def G.path_concat Path_mkArr has_codomain_char null_char
<         by auto
<       show "(domains f \<noteq> {}) = (codomains f \<noteq> {})"
<         by (simp add: has_domain_char has_codomain_char)
<       assume gf: "seq g f" and hgf: "seq h (g \<cdot> f)"
<       have isArr: "isArr h \<and> isArr g"
<         using gf hgf by (metis comp_def not_arr_null null_char)
<       then have "Dom h = Cod g"
<         using gf hgf Cod_mkArr [of "Dom g" "Cod g" "Path g"]
<         by (metis Cod_mkArr comp_null(2) comp_def not_arr_null)
<       with isArr show "seq h g"
<         using comp_def null_char mkArr_not_Null G.path_concat
<         using arr_def has_domain_char by auto
<       next
<       fix f g h
<       assume hg: "seq h g" and hgf: "seq (h \<cdot> g) f"
<       have isArr: "isArr g \<and> isArr f"
<         using hg hgf by (metis comp_def not_arr_null null_char)
<       then have "Dom g = Cod f"
<         using hg hgf Dom_mkArr [of "Dom g" "Cod g" "Path g"]
<         by (metis Dom_mkArr comp_null(2) comp_def not_arr_null)
<       with isArr show "seq g f"
<         using comp_def null_char mkArr_not_Null G.path_concat
<         using arr_def has_domain_char by auto
<       next
<       fix f g h
<       assume gf: "seq g f" and hg: "seq h g"
<       have 1: "isArr h \<and> isArr g \<and> isArr f \<and> Dom h = Cod g \<and> Dom g = Cod f"
<         using gf hg comp_def null_char by (metis not_arr_null)
<       show "seq (h \<cdot> g) f"
<         using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
<               arr_def has_codomain_char
<         by fastforce
<       show "(h \<cdot> g) \<cdot> f = h \<cdot> g \<cdot> f"
<         using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
<               append_assoc
<         by force
<     qed
< 
<     lemma is_category:
<     shows "category comp" ..
< 
<   end
< 
<   sublocale free_category \<subseteq> category comp
<     using is_category by auto
< 
<   context free_category
<   begin
< 
<     lemma arr_char:
<     shows "arr f \<longleftrightarrow> isArr f"
<       using has_codomain_char has_codomain_iff_arr by auto
< 
<     lemma dom_char:
<     shows "dom f = (if arr f then mkArr (Dom f) (Dom f) [] else null)"
<     proof -
<       have "\<not>arr f \<Longrightarrow> dom f = null"
<         by (simp add: has_domain_iff_arr dom_def)
<       moreover have "arr f \<Longrightarrow> dom f = mkArr (Dom f) (Dom f) []"
<         apply (intro dom_eqI)
<         using Dom_in_Obj arr_char in_Obj_implies_ide
<          apply auto[1]
<         by (simp add: Dom_in_Obj G.path_Obj arr_char mkArr_not_Null comp_def)
<       ultimately show ?thesis by auto
<     qed
< 
<     lemma cod_char:
<     shows "cod f = (if arr f then mkArr (Cod f) (Cod f) [] else null)"
<     proof -
<       have "\<not>arr f \<Longrightarrow> cod f = null"
<         by (simp add: has_codomain_iff_arr cod_def)
<       moreover have "arr f \<Longrightarrow> cod f = mkArr (Cod f) (Cod f) []"
<         apply (intro cod_eqI)
<         using Cod_in_Obj arr_char in_Obj_implies_ide
<          apply auto[1]
<         by (simp add: Cod_in_Obj G.path_Obj arr_char mkArr_not_Null comp_def)
<       ultimately show ?thesis by auto
<     qed
< 
<     lemma ide_char:
<     shows "ide f \<longleftrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
<     proof
<       show "ide f \<Longrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
<         by (metis (no_types, lifting) Dom_in_Obj ide_in_hom arr_char dom_char in_homE image_iff)
<       show "f \<in> (\<lambda>x. mkArr x x []) ` Obj \<Longrightarrow> ide f"
<         using in_Obj_implies_ide by auto
<     qed
< 
<     lemma arr_empty [simp]:
<     assumes "x \<in> Obj"
<     shows "arr (mkArr x x [])"
<       using assms by (simp add: G.path_Obj arr_char mkArr_not_Null)
---
>     abbreviation Path
>     where "Path \<equiv> Map"
369,390c155,157
<     shows "arr (mkArr (D x) (C x) [x])"
<       using assms by (simp add: G.path_single_Arr arr_char mkArr_not_Null)
< 
<     lemma dom_mkArr [simp]:
<     assumes "arr (mkArr x y p)"
<     shows "dom (mkArr x y p) = mkArr x x []"
<       using assms dom_char arr_char by auto
< 
<     lemma cod_mkArr [simp]:
<     assumes "arr (mkArr x y p)"
<     shows "cod (mkArr x y p) = mkArr y y []"
<       using assms cod_char arr_char by auto
< 
<     lemma comp_mkArr [simp]:
<     assumes "seq (mkArr y z q) (mkArr x y p)"
<     shows "comp (mkArr y z q) (mkArr x y p) = mkArr x z (p @ q)"
<       using assms arr_char comp_def by auto
< 
<     lemma mkArr_eqI:
<     assumes "arr (mkArr a b p)"
<     shows "mkArr a b p = mkArr a b p' \<longleftrightarrow> p = p'"
<       using assms arr_char Path_mkArr by metis
---
>     shows "arr (MkArr (D x) (C x) [x])"
>       using assms
>       by (simp add: G.cod_is_obj G.dom_is_obj G.path_single_Arr)
397c164,167
<     A discrete category is a free category generated by a graph with no arrows.
---
>     A discrete category is a category in which every arrow is an identity.
>     We could construct it as the free category generated by a graph with no
>     arrows, but it is simpler just to apply the @{locale concrete_category}
>     construction directly.
401,402c171
<     FC: free_category Obj "{} :: unit set" "\<lambda>_. undefined" "\<lambda>_. undefined"
<   for Obj :: "'obj set"
---
>   fixes Obj :: "'obj set"
405,422c174
<     lemma FC_arr_char:
<     shows "FC.arr f \<longleftrightarrow> f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj"
<     proof
<       show "FC.arr f \<Longrightarrow> f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj"
<         using FC.arr_char FC.ide_char FC.mkArr_Path FC.G.path_def length_greater_0_conv
<         by (metis (no_types, lifting) FC.cod_char FC.ide_cod empty_iff le_eq_less_or_eq)
<       show "f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj \<Longrightarrow> FC.arr f"
<         using FC.ide_char by auto
<     qed
< 
<     lemma FC_in_hom_char:
<     shows "FC.in_hom f a b \<longleftrightarrow> FC.arr f \<and> f = a \<and> f = b"
<       using FC.ide_char FC_arr_char by auto
< 
<     typedef 'a arr = "UNIV :: ('a, unit) free_category.arr set" ..
< 
<     interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
<       using Rep_arr_inverse Abs_arr_inverse by (unfold_locales, auto)
---
>     type_synonym 'o arr = "('o, unit) concrete_category.arr"
424,425c176,186
<     definition comp     (infixr "\<cdot>" 55)
<     where "comp \<equiv> AC.comp"
---
>     sublocale concrete_category \<open>Obj :: 'obj set\<close> \<open>\<lambda>x y. if x = y then {x} else {}\<close>
>       \<open>\<lambda>x. x\<close> \<open>\<lambda>_ _ x _ _. x\<close>
>       apply unfold_locales
>           apply simp_all
>         apply (metis empty_iff)
>        apply (metis empty_iff singletonD)
>       by (metis empty_iff singletonD)
> 
>     abbreviation comp      (infixr "\<cdot>" 55)
>     where "comp \<equiv> COMP"
>     notation in_hom        ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
427,440c188,190
<     lemma is_category:
<     shows "category comp"
<       using AC.category_axioms comp_def by auto
< 
<     interpretation category comp
<       using is_category by auto
< 
<     notation in_hom     ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
< 
<     definition mkIde
<     where "mkIde x \<equiv> if x \<in> Obj then Abs_arr (FC.mkArr x x []) else null"
< 
<     definition toObj
<     where "toObj f \<equiv> FC.Dom (Rep_arr f)"
---
>     lemma is_discrete:
>     shows "arr f \<longleftrightarrow> ide f"
>       using ide_char arr_char by simp
443,460c193,199
<     shows "arr f \<longleftrightarrow> f \<in> mkIde ` Obj"
<     proof
<       show "arr f \<Longrightarrow> f \<in> mkIde ` Obj"
<       proof -
<         assume f: "arr f"
<         obtain A where A: "A \<in> Obj \<and> Rep_arr f = FC.mkArr A A []"
<           using f AC.arr_char FC_arr_char FC.ide_char FC_in_hom_char FC.Dom_in_Obj
<                 FC.arr_char FC.dom_char comp_def
<           by auto
<         then have "f = mkIde A"
<           by (metis Rep_arr_inverse mkIde_def)
<         with A show ?thesis by auto
<       qed
<       show "f \<in> mkIde ` Obj \<Longrightarrow> arr f"
<         using FC_arr_char mkIde_def AC.arr_char AC.domain_closed AC.rep_abs FC.arr_empty
<               f_inv_into_f inv_into_into comp_def
<         by auto
<     qed
---
>     shows "arr f \<longleftrightarrow> Dom f \<in> Obj \<and> f = MkIde (Dom f)"
>       using is_discrete
>       by (metis (no_types, lifting) cod_char dom_char ide_MkIde ide_char ide_char')
> 
>     lemma arr_char':
>     shows "arr f \<longleftrightarrow> f \<in> MkIde ` Obj"
>       using arr_char image_iff by auto
464,465c203
<       using AC.dom_char arr_char comp_def AC.arr_char FC.ide_char FC_arr_char
<       by (simp add: Rep_arr_inverse)
---
>       using dom_char is_discrete by simp
469,480c207
<       using AC.cod_char comp_def Rep_arr_inverse cod_dom dom_char
<       by auto
< 
<     lemma dom_simp [simp]:
<     assumes "arr f"
<     shows "dom f = f"
<       using assms dom_char by simp
< 
<     lemma cod_simp [simp]:
<     assumes "arr f"
<     shows "cod f = f"
<       using assms cod_char by simp
---
>       using cod_char is_discrete by simp
484c211
<       by auto
---
>       using is_discrete by auto
485a213,217
>     lemma seq_char:
>     shows "seq g f \<longleftrightarrow> arr f \<and> f = g"
>       using is_discrete
>       by (metis (no_types, lifting) comp_arr_dom seqE dom_char)
>     
488,521c220,227
<       using AC.comp_char comp_def comp_cod_arr in_hom_char dom_char
<       by (metis (no_types, lifting) seqE)
< 
<     lemma comp_simp [simp]:
<     assumes "seq g f"
<     shows "g \<cdot> f = f"
<       using assms comp_char by meson
< 
<     lemma is_discrete:
<     shows "ide f \<longleftrightarrow> arr f"
<       using arr_char dom_char in_hom_char ide_in_hom by metis
< 
<     lemma ide_mkIde:
<     assumes "x \<in> Obj"
<     shows "ide (mkIde x)"
<       using assms mkIde_def arr_char image_iff is_discrete by auto
< 
<     lemma toObj_in_Obj:
<     assumes "arr a"
<     shows "toObj a \<in> Obj"
<       using assms toObj_def
<       by (metis AC.arr_char FC.Dom_in_Obj FC.arr_char comp_def)
< 
<     lemma toObj_mkIde [simp]:
<     assumes "x \<in> Obj"
<     shows "toObj (mkIde x) = x"
<       using assms toObj_def mkIde_def Abs_arr_inverse
<       by (metis FC.Dom_mkArr FC.arr_empty FC.not_arr_null FC.null_char UNIV_I)
< 
<     lemma mkIde_toObj [simp]:
<     assumes "arr a"
<     shows "mkIde (toObj a) = a"
<       using assms mkIde_def
<       by (metis (no_types, lifting) arr_char imageE toObj_mkIde)
---
>     proof -
>       have "\<not> seq g f \<Longrightarrow> ?thesis"
>         using comp_char by presburger
>       moreover have "seq g f \<Longrightarrow> ?thesis"
>         using seq_char comp_char comp_arr_ide is_discrete
>         by (metis (no_types, lifting))
>       ultimately show ?thesis by blast
>     qed
525,527d230
<   sublocale discrete_category \<subseteq> category comp
<     using is_category by auto
< 
550,551c253
<     FC: free_category "{False, True}" Arr "\<lambda>_. False" "\<lambda>_. True"
<   for Arr :: "'arr set"
---
>   fixes Arr :: "'arr set"
554,560c256,287
<     lemma FC_ide_char:
<     shows "FC.ide f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True []"
<       by (simp add: FC.ide_char)
< 
<     lemma FC_arr_char:
<     shows "FC.arr f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
<                         f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
---
>     type_synonym 'a arr = "(unit, 'a) concrete_category.arr"
> 
>     sublocale free_category "{False, True}" Arr "\<lambda>_. False" "\<lambda>_. True"
>       by (unfold_locales, simp_all)
> 
>     notation comp                  (infixr "\<cdot>" 55)
>     notation in_hom                ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
> 
>     definition Zero
>     where "Zero \<equiv> MkIde False"
> 
>     definition One
>     where "One \<equiv> MkIde True"
> 
>     definition fromArr
>     where "fromArr x \<equiv> if x \<in> Arr then MkArr False True [x] else null"
> 
>     definition toArr
>     where "toArr f \<equiv> hd (Path f)"
> 
>     lemma ide_char:
>     shows "ide f \<longleftrightarrow> f = Zero \<or> f = One"
>     proof -
>       have "ide f \<longleftrightarrow> f = MkIde False \<or> f = MkIde True"
>         using ide_char concrete_category.MkIde_Dom' concrete_category_axioms by fastforce
>       thus ?thesis
>         using comp_def Zero_def One_def by simp
>     qed
> 
>     lemma arr_char':
>     shows "arr f \<longleftrightarrow> f =
>            MkIde False \<or> f = MkIde True \<or> f \<in> (\<lambda>x. MkArr False True [x]) ` Arr"
562,564c289,290
<       assume f: "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
<                  f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
<       show "FC.arr f" using f by auto
---
>       assume f: "f = MkIde False \<or> f = MkIde True \<or> f \<in> (\<lambda>x. MkArr False True [x]) ` Arr"
>       show "arr f" using f by auto
566,568c292,293
<       assume f: "FC.arr f"
<       have "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])
<                      \<Longrightarrow> f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
---
>       assume f: "arr f"
>       have "\<not>(f = MkIde False \<or> f = MkIde True) \<Longrightarrow> f \<in> (\<lambda>x. MkArr False True [x]) ` Arr"
570,571c295,300
<         assume f': "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])"
<         have 0: "FC.Dom f = False \<and> FC.Cod f = True"
---
>         assume f': "\<not>(f = MkIde False \<or> f = MkIde True)"
>         have 0: "Dom f = False \<and> Cod f = True"
>           using f f' arr_char G.path_def MkArr_Map by fastforce
>         have 1: "f = MkArr False True (Path f)"
>           using f 0 arr_char MkArr_Map by force
>         moreover have "length (Path f) = 1"
573,592c302,308
<           have "f \<noteq> FC.Null \<and> FC.G.path (FC.Dom f) (FC.Cod f) (FC.Path f)"
<             using FC.arr_char f by blast
<           then show ?thesis
<             by (metis (full_types) FC.G.path_def FC.mkArr_Path f')
<         qed
<         hence 1: "f = FC.mkArr False True (FC.Path f)"
<         proof -
<           have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
<             using FC.arr_char FC.mkArr_Path f by meson
<           then show ?thesis
<             by (simp add: 0)
<         qed
<         moreover have "length (FC.Path f) = 1"
<         proof -
<           have 2: "length (FC.Path f) \<noteq> 0"
<             using f f' FC_ide_char FC.arr_char FC.mkArr_Path FC.G.path_def length_0_conv
<             by (metis (full_types))
<           moreover have "\<And>x y p. length p > 1 \<Longrightarrow> \<not>FC.G.path x y p"
<             using FC.G.path_def less_diff_conv by auto
<           thus ?thesis by (metis FC.arr_char 2 f less_one linorder_neqE_nat)
---
>           have "length (Path f) \<noteq> 0"
>             using f f' 0 arr_char G.path_def by simp
>           moreover have "\<And>x y p. length p > 1 \<Longrightarrow> \<not> G.path x y p"
>             using G.path_def less_diff_conv by fastforce
>           ultimately show ?thesis
>             using f arr_char
>             by (metis less_one linorder_neqE_nat mem_Collect_eq)
595,599c311,316
<           by(auto simp: length_Suc_conv)
<         ultimately have "\<exists>x. x \<in> Arr \<and> FC.Path f = [x]"
<           by (metis FC.G.path_def FC.arr_char f FC.mkArr_def less_or_eq_imp_le nth_Cons_0
<                     zero_less_one)
<         thus "f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
---
>           by (auto simp: length_Suc_conv)
>         ultimately have "\<exists>x. x \<in> Arr \<and> Path f = [x]"
>           using f G.path_def arr_char
>           by (metis (no_types, lifting) Cod.simps(1) Dom.simps(1) le_eq_less_or_eq
>               less_numeral_extra(1) mem_Collect_eq nth_Cons_0)
>         thus "f \<in> (\<lambda>x. MkArr False True [x]) ` Arr"
602,603c319
<       thus "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
<             f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
---
>       thus "f = MkIde False \<or> f = MkIde True \<or> f \<in> (\<lambda>x. MkArr False True [x]) ` Arr"
607,620c323,334
<     lemma FC_seq_char:
<     shows "FC.seq g f \<longleftrightarrow> FC.arr g \<and> FC.arr f \<and>
<                           ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
<                            (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
<     proof
<       assume gf: "FC.arr g \<and> FC.arr f \<and>
<                   ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
<                    (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
<       show "FC.seq g f"
<         using gf FC_arr_char FC_ide_char by (intro FC.seqI; fastforce)
<       next
<       assume gf: "FC.seq g f"
<       hence 1: "FC.arr f \<and> FC.arr g \<and> FC.dom g = FC.cod f" by auto
<       have "FC.Cod f = False \<Longrightarrow> f = FC.mkArr False False []"
---
>     lemma arr_char:
>     shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f \<in> fromArr ` Arr"
>       using arr_char' Zero_def One_def fromArr_def by simp
> 
>     lemma dom_char:
>     shows "dom f = (if arr f then
>                       if f = One then One else Zero
>                     else null)"
>     proof -
>       have "\<not> arr f \<Longrightarrow> ?thesis"
>         using dom_char by simp
>       moreover have "arr f \<Longrightarrow> ?thesis"
622,624c336,344
<         assume "FC.Cod f = False"
<         moreover have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
<           using gf FC.arr_char [of f] by auto
---
>         assume f: "arr f"
>         have 1: "dom f = MkIde (Dom f)"
>           using f dom_char by simp
>         have "f = One \<Longrightarrow> ?thesis"
>           using f 1 One_def by (metis (full_types) Dom.simps(1))
>         moreover have "f = Zero \<Longrightarrow> ?thesis"
>           using f 1 Zero_def by (metis (full_types) Dom.simps(1))
>         moreover have "f \<in> fromArr ` Arr \<Longrightarrow> ?thesis"
>           using f fromArr_def G.path_def Zero_def calculation(1) by auto
626c346
<           using FC.G.path_def FC.arr_char [of f] gf by auto
---
>           using f arr_char by blast
628c348,358
<       moreover have "FC.Cod f = True \<Longrightarrow> g = FC.mkArr True True []"
---
>       ultimately show ?thesis by blast
>     qed
> 
>     lemma cod_char:
>     shows "cod f = (if arr f then
>                       if f = Zero then Zero else One
>                     else null)"
>     proof -
>       have "\<not> arr f \<Longrightarrow> ?thesis"
>         using cod_char by simp
>       moreover have "arr f \<Longrightarrow> ?thesis"
630,641c360,368
<         assume f: "FC.Cod f = True"
<         have "FC.Null \<noteq> g"
<           using FC.arr_char gf by blast
<         moreover have "FC.Cod f = FC.Dom g"
<         proof -
<           have "\<not> FC.Dom (FC.mkArr False False [])"
<             using FC.not_arr_null FC.null_char FC_arr_char by force
<           moreover have "FC.Dom (FC.mkArr True True [])"
<             using FC.not_arr_null FC.null_char FC_arr_char by auto
<           ultimately show ?thesis
<             by (metis FC.arr_char FC.comp_def gf)
<         qed
---
>         assume f: "arr f"
>         have 1: "cod f = MkIde (Cod f)"
>           using f cod_char by simp
>         have "f = One \<Longrightarrow> ?thesis"
>           using f 1 One_def by (metis (full_types) Cod.simps(1) f)
>         moreover have "f = Zero \<Longrightarrow> ?thesis"
>           using f 1 Zero_def by (metis (full_types) Cod.simps(1) f)
>         moreover have "f \<in> fromArr ` Arr \<Longrightarrow> ?thesis"
>           using f fromArr_def G.path_def One_def calculation(2) by auto
643c370
<           using f FC_arr_char [of g] gf by auto
---
>           using f arr_char by blast
645,652c372
<       ultimately have "f = FC.mkArr False False [] \<or> g = FC.mkArr True True []"
<         using gf FC_arr_char by auto
<       moreover have "\<not>(f = FC.mkArr False False [] \<and> g = FC.mkArr True True [])"
<         using 1 by (metis FC.arr_char FC.dom_mkArr FC.Dom_mkArr FC.cod_mkArr)
<       ultimately show "FC.arr g \<and> FC.arr f \<and>
<                        ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
<                         (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
<         using 1 by metis
---
>       ultimately show ?thesis by blast
655,667c375,393
<     typedef 'a arr = "UNIV :: (bool, 'a) free_category.arr set" ..
< 
<     interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
<       using Rep_arr_inverse Abs_arr_inverse by (unfold_locales, auto)
< 
<     definition comp     (infixr "\<cdot>" 55)
<     where "comp \<equiv> AC.comp"
< 
<     lemma is_category:
<     shows "category comp"
<     proof -
<       have "category AC.comp" ..
<       thus "category comp" using comp_def by auto
---
>     lemma seq_char:
>     shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
>     proof
>       assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
>       show "seq g f"
>         using gf dom_char cod_char by auto
>       next
>       assume gf: "seq g f"
>       hence 1: "arr f \<and> arr g \<and> dom g = cod f" by auto
>       have "Cod f = False \<Longrightarrow> f = Zero"
>         using gf 1 arr_char [of f] G.path_def Zero_def One_def cod_char Dom_cod
>         by (metis (no_types, lifting) Dom.simps(1))
>       moreover have "Cod f = True \<Longrightarrow> g = One"
>         using gf 1 arr_char [of f] G.path_def Zero_def One_def dom_char Dom_cod
>         by (metis (no_types, lifting) Dom.simps(1))
>       moreover have "\<not>(f = MkIde False \<and> g = MkIde True)"
>         using 1 by auto
>       ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
>         using gf arr_char One_def Zero_def by blast
670,730c396,399
<     interpretation category comp
<       using is_category by auto
< 
<     notation in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
< 
<     definition Zero
<     where "Zero \<equiv> Abs_arr (FC.mkArr False False [])"
< 
<     definition One
<     where "One \<equiv> Abs_arr (FC.mkArr True True [])"
< 
<     definition mkArr
<     where "mkArr x \<equiv> if x \<in> Arr then Abs_arr (FC.mkArr False True [x]) else null"
< 
<     definition toArr
<     where "toArr f \<equiv> hd (FC.Path (Rep_arr f))"
< 
<     lemma ide_char:
<     shows "ide f \<longleftrightarrow> f = Zero \<or> f = One"
<       using comp_def Zero_def One_def
<       by (metis AC.ide_char Abs_arr_inverse FC_ide_char Rep_arr_inject UNIV_I)
< 
<     lemma not_ide_mkArr:
<     shows "\<not>ide (mkArr x)"
<       using mkArr_def ide_char ide_def Zero_def One_def
<       by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Cod_mkArr FC.Dom_mkArr
<                 FC.mkArr_not_Null)
< 
<     lemma arr_char:
<     shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
<     proof -
<       obtain G :: "'arr set \<Rightarrow> ('arr \<Rightarrow> (bool, 'arr) FC.arr) \<Rightarrow> (bool, 'arr) FC.arr \<Rightarrow> 'arr"
<         where "\<forall>A F h. (\<exists>h'. h' \<in> A \<and> h = F h') \<longleftrightarrow> (G A F h \<in> A \<and> h = F (G A F h))"
<         by moura
<       hence 1: "\<forall>a f A. (a \<in> f ` A \<longrightarrow> G A f a \<in> A \<and> a = f (G A f a)) \<and>
<                         (a \<notin> f ` A \<longrightarrow> (\<forall>a'. a' \<in> A \<longrightarrow> a \<noteq> f a'))"
<         by auto
<       have 2: "Rep_arr f = FC.mkArr False False [] \<longrightarrow> f = Zero"
<         by (metis (no_types) Rep_arr_inverse Zero_def)
<       have 3: "Rep_arr f = FC.mkArr True True [] \<longrightarrow> f = One"
<         by (metis One_def Rep_arr_inverse)
<       have "(Rep_arr f \<in> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
<                G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<in> Arr \<and>
<                Rep_arr f =
<                FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)])
<             \<and> (Rep_arr f \<notin> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
<                  (\<forall>a. a \<notin> Arr \<or> Rep_arr f \<noteq> FC.mkArr False True [a]))"
<         using 1 by meson
<       moreover have
<           "f \<noteq> mkArr (G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f))
<              \<Longrightarrow> G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<notin> Arr \<or>
<                  Rep_arr f \<noteq>
<                  FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)]"
<         by (metis Rep_arr_inverse mkArr_def)
<       ultimately have "arr f \<Longrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
<         using 2 3 AC.arr_char FC_arr_char comp_def by force
<       thus "arr f \<longleftrightarrow> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)"
<         using AC.arr_char Abs_arr_inverse FC_arr_char One_def UNIV_I Zero_def comp_def
<               mkArr_def
<         by auto
<     qed
---
>     lemma not_ide_fromArr:
>     shows "\<not> ide (fromArr x)"
>       using fromArr_def ide_char ide_def Zero_def One_def
>       by (metis Cod.simps(1) Dom.simps(1))
735c404
<                             (a = Zero \<and> b = One \<and> f \<in> mkArr ` Arr)"
---
>                             (a = Zero \<and> b = One \<and> f \<in> fromArr ` Arr)"
738,739c407,409
<         using arr_char [of f]
<         by (metis ide_char ide_in_hom image_iff in_homE not_ide_mkArr)
---
>         using arr_char' [of f] ide_char'
>         by (metis (no_types, lifting) Zero_def category.in_homE category.in_homI
>             cod_MkArr dom_MkArr imageE is_category not_ide_fromArr)
741,743c411,414
<         using arr_char [of f]
<         by (metis ide_char ide_in_hom image_iff in_homE not_ide_mkArr)
<       moreover have "f \<in> mkArr ` Arr \<Longrightarrow> ?thesis"
---
>         using arr_char' [of f] ide_char'
>         by (metis (no_types, lifting) One_def category.in_homE category.in_homI
>             cod_MkArr dom_MkArr image_iff is_category not_ide_fromArr)
>       moreover have "f \<in> fromArr ` Arr \<Longrightarrow> ?thesis"
745,746c416,417
<         assume f: "f \<in> mkArr ` Arr"
<         have 1: "arr f" using f by (simp add: arr_char)
---
>         assume f: "f \<in> fromArr ` Arr"
>         have 1: "arr f" using f arr_char by simp
748,749c419,420
<           using f 1 AC.dom_char AC.cod_char AC.rep_abs comp_def mkArr_def Zero_def One_def
<           by auto
---
>           using f 1 arr_char dom_char cod_char fromArr_def
>           by (metis (no_types, lifting) ide_char imageE not_ide_fromArr)
753,754c424,425
<                                            a = Zero \<and> b = One \<and> f \<in> mkArr ` Arr)"
<           by (metis f in_homE ide_char ide_in_hom)
---
>                                            a = Zero \<and> b = One \<and> f \<in> fromArr ` Arr)"
>           using f ide_char by auto
762,763c433
<       using Zero_def One_def
<       by (metis Abs_arr_inverse FC.not_arr_null FC.null_char FC_arr_char UNIV_I FC.Dom_mkArr)
---
>       by (simp add: One_def Zero_def)
765,812c435,443
<     lemma Zero_not_in_mkArr_Arr [simp]:
<     shows "Zero \<notin> mkArr ` Arr"
<       by (metis ide_char imageE not_ide_mkArr)
< 
<     lemma One_not_in_mkArr_Arr [simp]:
<     shows "One \<notin> mkArr ` Arr"
<       by (metis ide_char imageE not_ide_mkArr)
< 
<     lemma dom_char:
<     shows "dom f = (if ide f then f else if arr f then Zero else null)"
<       using ide_char arr_char in_hom_char
<       by (metis has_domain_iff_arr in_homE dom_def)
< 
<     lemma dom_simp [simp]:
<     shows "dom One = One"
<     and "\<lbrakk>arr f; f \<noteq> One\<rbrakk> \<Longrightarrow> dom f = Zero"
<       using dom_char ide_char by auto
< 
<     lemma cod_char:
<     shows "cod f = (if ide f then f else if arr f then One else null)"
<       using ide_char arr_char in_hom_char
<       by (metis has_codomain_iff_arr in_homE cod_def)
< 
<     lemma cod_simp [simp]:
<     shows "cod Zero = Zero"
<     and "\<lbrakk>arr f; f \<noteq> Zero\<rbrakk> \<Longrightarrow> cod f = One"
<       using cod_char ide_char by auto
< 
<     lemma seq_char:
<     shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<     proof
<       assume gf: "seq g f"
<       hence 1: "arr f \<and> arr g \<and> cod f = dom g" by auto
<       have f: "arr f \<and> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)" using gf arr_char by auto
<       have g: "arr g \<and> (g = Zero \<or> g = One \<or> g \<in> mkArr ` Arr)" using gf arr_char by auto
<       have "f = Zero \<Longrightarrow> g \<noteq> One"
<         using f g 1 by force
<       moreover have "f = One \<Longrightarrow> g = One"
<         using f g 1 by (metis Zero_not_eq_One cod_simp(2) dom_simp(2))
<       moreover have "f \<in> mkArr ` Arr \<Longrightarrow> f \<noteq> Zero \<and> g = One"
<         using f 1 arr_char [of f]
<         by (metis Zero_not_eq_One Zero_not_in_mkArr_Arr cod_simp(2) dom_simp(2))
<       ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<         using f g arr_char [of f] arr_char [of g] by blast
<       next
<       assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<       thus "seq g f" using in_hom_char by auto
<     qed
---
>     lemma Zero_not_eq_fromArr [simp]:
>     shows "Zero \<notin> fromArr ` Arr"
>       using ide_char not_ide_fromArr
>       by (metis (no_types, lifting) image_iff)
> 
>     lemma One_not_eq_fromArr [simp]:
>     shows "One \<notin> fromArr ` Arr"
>       using ide_char not_ide_fromArr
>       by (metis (no_types, lifting) image_iff)
820,821c451,452
<         using comp_def seq_char [of g f] AC.comp_char [of g f] Zero_def cod_simp(1)
<         by (metis comp_arr_dom dom_simp(2))
---
>         using seq_char comp_char [of g f] Zero_def dom_char cod_char comp_arr_dom
>         by auto
823,824c454,455
<         using comp_def seq_char [of g f] AC.comp_char [of g f] One_def dom_simp(1)
<         by (metis comp_cod_arr cod_simp(2))
---
>         using seq_char comp_char [of g f] One_def dom_char cod_char comp_cod_arr
>         by simp
826c457
<         using seq_char by blast
---
>         using seq_char Zero_def One_def by simp
828c459
<         using comp_def AC.comp_char ext by fastforce
---
>         using comp_char ext by fastforce
836,841c467
<     proof -
<       show "f = Zero \<Longrightarrow> g \<cdot> f = g"
<         using assms seq_char comp_char by metis
<       show "g = One \<Longrightarrow> g \<cdot> f = f"
<         using assms seq_char comp_char by metis
<     qed
---
>       using assms seq_char comp_char by metis+
843c469
<     lemma arr_mkArr:
---
>     lemma arr_fromArr:
845,846c471,472
<     shows "arr (mkArr x)"
<       using assms mkArr_def arr_char image_eqI by blast
---
>     shows "arr (fromArr x)"
>       using assms fromArr_def arr_char image_eqI by simp
852,856c478,481
<       have "\<And>a. a \<in> Arr \<Longrightarrow> FC.Path (Rep_arr (mkArr a)) = [a]"
<         by (metis AC.domain_closed Abs_arr_inverse FC.Path_mkArr FC.arr_char FC.arr_single
<                   mkArr_def)
<       hence "hd (FC.Path (Rep_arr f)) \<in> Arr"
<         using arr_char assms(1) assms(2) ide_char by auto
---
>       have "\<And>a. a \<in> Arr \<Longrightarrow> Path (fromArr a) = [a]"
>         using fromArr_def arr_char by simp
>       hence "hd (Path f) \<in> Arr"
>         using assms arr_char ide_char by auto
861c486
<     lemma toArr_mkArr [simp]:
---
>     lemma toArr_fromArr [simp]:
863,866c488,490
<     shows "toArr (mkArr x) = x"
<       using assms mkArr_def toArr_def
<       by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Path_mkArr FC.mkArr_not_Null
<                 list.sel(1))
---
>     shows "toArr (fromArr x) = x"
>       using assms fromArr_def toArr_def
>       by (simp add: toArr_def)
868c492
<     lemma mkArr_toArr [simp]:
---
>     lemma fromArr_toArr [simp]:
870,871c494,495
<     shows "mkArr (toArr f) = f"
<       using assms arr_char ide_char imageE toArr_mkArr by auto
---
>     shows "fromArr (toArr f) = f"
>       using assms fromArr_def toArr_def arr_char ide_char toArr_fromArr by auto
875,877d498
<   sublocale quiver \<subseteq> category comp
<     using is_category by auto
< 
886c507
<     Q: quiver "{False, True} :: bool set"
---
>     quiver "{False, True} :: bool set"
891,914d511
<     interpretation AC: abstracted_category Q.comp Abs_arr Rep_arr UNIV
<       using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto
< 
<     definition comp     (infixr "\<cdot>" 55)
<     where "comp \<equiv> AC.comp"
< 
<     lemma is_category:
<     shows "category comp"
<     proof -
<       have "category AC.comp" ..
<       thus "category comp" using comp_def by metis
<     qed
< 
<     interpretation category comp
<       using is_category by auto
< 
<     notation in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
< 
<     definition Zero
<     where "Zero \<equiv> Abs_arr Q.Zero"
< 
<     definition One
<     where "One \<equiv> Abs_arr Q.One"
< 
916c513
<     where "j0 \<equiv> Abs_arr (Q.mkArr False)"
---
>     where "j0 \<equiv> fromArr False"
919c516
<     where "j1 \<equiv> Abs_arr (Q.mkArr True)"
---
>     where "j1 \<equiv> fromArr True"
923,939c520
<     proof -
<       have 1: "Rep_arr f = Q.Zero \<or> Rep_arr f = Q.One \<or> Rep_arr f \<in> Q.mkArr ` {False, True}
<                  \<longrightarrow> arr f"
<         by (simp add: AC.arr_char Q.arr_char comp_def)
<       have 2: "\<forall>a. a \<in> UNIV \<longrightarrow> Rep_arr (Abs_arr a) = a"
<         by (simp add: Abs_arr_inverse)
<       hence 3: "Rep_arr (Abs_arr (Q.mkArr True)) = Q.mkArr True"
<         by blast
<       hence 4: "f = j1 \<longrightarrow> arr f"
<         using 1 j1_def by auto
<       have "f = j0 \<or> f = Zero \<or> f = One \<longrightarrow> arr f"
<         using 1 2 Zero_def One_def by (metis (no_types) UNIV_I insertI1 j0_def rev_image_eqI)
<       thus ?thesis
<         using 2 3 4
<         by (metis (full_types) AC.arr_char One_def Q.ide_char Q.mkArr_toArr Rep_arr_inject
<             UNIV_I Zero_def j0_def j1_def comp_def)
<     qed
---
>       using arr_char j0_def j1_def by simp
943,945c524,525
<       using comp_def
<       by (metis (full_types) AC.arr_char AC.dom_char Abs_arr_inverse One_def Q.dom_char
<           Q.ide_char Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)
---
>       using arr_char dom_char j0_def j1_def
>       by (metis ide_char not_ide_fromArr)
949,962c529,530
<       using comp_def
<       by (metis (full_types) AC.arr_char AC.cod_char Abs_arr_inverse One_def Q.cod_char
<           Q.ide_char Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)
< 
<     lemma ide_char:
<     shows "ide a \<longleftrightarrow> a = Zero \<or> a = One"
<       using ide_in_hom arr_char
<       by (metis (no_types, lifting) AC.ide_char Q.ide_char UNIV_I Zero_def in_homE j0_def j1_def
<           comp_def Abs_arr_inverse One_def)
< 
<     lemma Zero_not_eq_One [simp]:
<     shows "Zero \<noteq> One"
<       using Zero_def One_def Q.Zero_def Q.One_def
<       by (metis AC.rep_abs Q.Zero_not_eq_One UNIV_I)
---
>       using arr_char cod_char j0_def j1_def
>       by (metis ide_char not_ide_fromArr)
966c534,535
<       by (metis (full_types) Abs_arr_inverse Q.toArr_mkArr UNIV_I UNIV_bool j0_def j1_def)
---
>       using j0_def j1_def
>       by (metis insert_iff toArr_fromArr)
970c539
<       using Zero_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)
---
>       using Zero_def j0_def Zero_not_eq_fromArr by auto
974c543
<       using Zero_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)
---
>       using Zero_def j1_def Zero_not_eq_fromArr by auto
978c547
<       using One_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)
---
>       using One_def j0_def One_not_eq_fromArr by auto
982c551
<       using One_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)
---
>       using One_def j1_def One_not_eq_fromArr by auto
998,1043d566
<     lemma seq_char:
<     shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<     proof
<       assume gf: "seq g f"
<       have f: "arr f \<and> (f = Zero \<or> f = One \<or> f = j0 \<or> f = j1)" using gf arr_char by blast
<       have g: "arr g \<and> (g = Zero \<or> g = One \<or> g = j0 \<or> g = j1)" using gf arr_char by blast
<       have "f = Zero \<Longrightarrow> g \<noteq> One"
<         using f g gf
<         by (metis Zero_not_eq_One seqE cod_simp(1) dom_simp(2))
<       moreover have "f \<noteq> Zero \<Longrightarrow> g = One"
<         using f g gf by auto
<       ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<         using f g by blast
<       next
<       assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
<       have "f = Zero \<Longrightarrow> seq g f" using gf arr_char [of g] by auto
<       moreover have "g = One \<Longrightarrow> seq g f" using gf arr_char [of f] by auto
<       ultimately show "seq g f" using gf by blast
<     qed
< 
<     lemma comp_char:
<     shows "g \<cdot> f = (if seq g f then
<                       if f = Zero then g else if g = One then f else null
<                     else null)"
<     proof -
<       have "\<not>seq g f \<Longrightarrow> g \<cdot> f = null"
<         using comp_def AC.comp_char Q.comp_char seq_char ext by blast
<       moreover have "seq g f \<Longrightarrow> f = Zero \<Longrightarrow> g \<cdot> f = g"
<         using comp_arr_dom by auto
<       moreover have "seq g f \<Longrightarrow> g = One \<Longrightarrow> g \<cdot> f = f"
<         using comp_cod_arr by auto
<       ultimately show ?thesis
<         by (metis seqE seq_char)
<     qed
< 
<     lemma comp_simp [simp]:
<     assumes "seq g f"
<     shows "f = Zero \<Longrightarrow> g \<cdot> f = g"
<     and "g = One \<Longrightarrow> g \<cdot> f = f"
<     proof -
<       show "f = Zero \<Longrightarrow> g \<cdot> f = g"
<         using assms comp_char by metis
<       show "g = One \<Longrightarrow> g \<cdot> f = f"
<         using assms comp_char seq_char by metis
<     qed
< 
1045,1047d567
< 
<   sublocale parallel_pair \<subseteq> category comp
<     using is_category by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/FunctorCategory.thy ../../AFPs/afp-2020/thys/Category3/FunctorCategory.thy
9c9
< imports Category AbstractedCategory BinaryFunctor
---
> imports ConcreteCategory BinaryFunctor
16,35d15
<     Since the arrows of a functor category cannot (in the context of the present development)
<     be directly identified with natural transformations, but rather only with natural
<     transformations that have been equipped with their domain and codomain functors,
<     and since there is no natural value to serve as @{term null},
<     the construction here is a bit more involved than most of the other constructions
<     on categories we have defined so far.
<     What we do first is to construct a ``classical category'' whose objects are
<     functors and whose arrows are natural transformations.  Then, we extract from this
<     construction a partial composition using the standard result proved in the
<     \<open>classical_category\<close> locale.  The effect of this standard result is to define
<     arrows of the resulting category to be triples that consist of natural transformations
<     equipped with their domain and codomain functors, injected into an option type
<     in order to provide a value to be used as @{term null}.
<     We then use the \<open>abstracted_category\<close> locale to lift the resulting category to an
<     opaque arrow type, to avoid the possibility of a client of this theory inadvertently
<     depending on the details of the concrete construction.
<     Finally, we define a set of constructors for the opaque arrow type and characterize the
<     resulting category in terms of these constructors so that the details of the concrete
<     construction are no longer required and only the constructors and associated facts need
<     be used.
41,48c21,26
<     In this section a construction for functor categories is given.
<     For convenience, we proceed indirectly, by way of the \<open>classical_category\<close> locale,
<     though the construction could also have been done directly.
<     Some auxiliary definitions are involved, but these are declared ``private'' and in
<     the end what is exported is an opaque arrow type, a partial composition operation on
<     this arrow type defining the category, functions for constructing and destructing arrows,
<     and facts that characterize the basic notions (domain, codomain, \emph{etc.}) in terms
<     of these functions.
---
>     Since the arrows of a functor category cannot (in the context of the present development)
>     be directly identified with natural transformations, but rather only with natural
>     transformations that have been equipped with their domain and codomain functors,
>     and since there is no natural value to serve as @{term null},
>     we use the general-purpose construction given by @{locale concrete_category} to define
>     this category.
61,197c39
<     context begin
< 
<       text\<open>
<         First, we construct a ``classical category'' whose objects are functors and
<         whose arrows are triples \<open>(\<tau>, (F, G))\<close>, where \<open>F\<close> and \<open>G\<close>
<         are functors and \<open>\<tau>\<close> is a natural transformation from \<open>F\<close> to \<open>G\<close>.
< \<close>
< 
<       private abbreviation Dom'
<       where "Dom' t \<equiv> fst (snd t)"
< 
<       private abbreviation Cod'
<       where "Cod' t \<equiv> snd (snd t)"
< 
<       private abbreviation Fun'
<       where "Fun' t \<equiv> fst t"
< 
<       private definition Obj'
<       where "Obj' F \<equiv> functor A B F"
< 
<       private definition Arr'
<       where "Arr' t \<equiv> natural_transformation A B (Dom' t) (Cod' t) (Fun' t)"
< 
<       private abbreviation Id'
<       where "Id' F \<equiv> (F, (F, F))"
< 
<       private definition Comp'
<       where "Comp' t s \<equiv> (vertical_composite.map A B (Fun' s) (Fun' t), (Dom' s, Cod' t))"
< 
<       interpretation CC: classical_category Obj' Arr' Dom' Cod' Id' Comp'
<       proof
<         fix F
<         assume F: "Obj' F"
<         show "Arr' (Id' F)"
<           using F Arr'_def Obj'_def functor_is_transformation by simp
<         show "Dom' (Id' F) = F" using F by (metis fst_conv snd_conv)
<         show "Cod' (Id' F) = F" using F by (metis snd_conv)
<         next
<         fix t
<         assume t: "Arr' t"
<         interpret \<tau>: natural_transformation A B "Dom' t" "Cod' t" "Fun' t"
<           using t Arr'_def by blast
<         show "Obj' (Dom' t)" unfolding Obj'_def ..
<         show "Obj' (Cod' t)" unfolding Obj'_def ..
<         show "Comp' t (Id' (Dom' t)) = t"
<           by (metis Comp'_def \<tau>.natural_transformation_axioms fst_conv prod.collapse snd_conv
<                     vcomp_ide_dom)
<         show "Comp' (Id' (Cod' t)) t = t"
<           by (metis (no_types, lifting) Comp'_def \<tau>.natural_transformation_axioms fst_conv
<                     prod.collapse snd_conv vcomp_ide_cod)
<         fix s
<         assume s: "Arr' s"
<         and st: "Cod' s = Dom' t"
<         show "Arr' (Comp' t s)"
<         proof -
<           interpret \<sigma>: natural_transformation A B "Dom' s" "Cod' s" "Fun' s"
<             using s Arr'_def by blast
<           interpret VC: vertical_composite A B "Dom' s" "Cod' s" "Cod' t" "Fun' s" "Fun' t"
<             using s t st Arr'_def Obj'_def
<             by (simp add: natural_transformation_def vertical_composite.intro)
<           have "natural_transformation A B (Dom' s) (Cod' t) (Fun' (Comp' t s))"
<             using VC.is_natural_transformation Comp'_def by (metis fst_conv)
<           thus ?thesis using s t st Arr'_def Comp'_def by (metis fst_conv snd_conv)
<         qed
<         show "Dom' (Comp' t s) = Dom' s"
<           using Comp'_def fst_conv snd_conv by metis
<         show "Cod' (Comp' t s) = Cod' t"
<           using Comp'_def snd_conv by metis
<         fix r
<         assume r: "Arr' r"
<         and rs: "Cod' r = Dom' s"
<         show "Comp' (Comp' t s) r = Comp' t (Comp' s r)"
<           unfolding Comp'_def
<           using r s t rs st Arr'_def by auto
<       qed
< 
<       private lemma CC_is_classical_category:
<       shows "classical_category Obj' Arr' Dom' Cod' Id' Comp'" ..
< 
<       text\<open>
<         At this point, @{term CC.comp} is a partial composition that defines a category.
<         The arrow type for this category is @{typ "(('a \<Rightarrow> 'b) \<times> ('a \<Rightarrow> 'b) \<times> ('a \<Rightarrow> 'b)) option"},
<         because the definition of @{term CC.comp} introduces an option type to provide
<         a value to be used as @{term null}.  We next define a corresponding opaque arrow type.
< \<close>
< 
<       typedef ('c, 'd) arr = "UNIV :: (('c \<Rightarrow> 'd) * ('c \<Rightarrow> 'd) * ('c \<Rightarrow> 'd)) option set" ..
< 
<       text\<open>
<         The category defined by @{term CC.comp} is then lifted to the opaque arrow type.
< \<close>
< 
<       interpretation AC: abstracted_category CC.comp Abs_arr Rep_arr UNIV
<         using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto
< 
<       text\<open>
<         The function @{term AC.comp} is now the partial composition that defines the
<         desired category.
< \<close>
< 
<       definition comp :: "('a, 'b) arr comp"     (infixr "\<cdot>" 55)
<       where "comp \<equiv> AC.comp"
< 
<       lemma is_category:
<       shows "category comp"
<         using AC.category_axioms comp_def by auto
< 
<       interpretation category comp
<         using is_category by auto
< 
<       notation in_hom                            ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
< 
<       text\<open>
<         We introduce a constructor \<open>mkArr\<close> for building an arrow from two
<         functors and a natural transformation.
< \<close>
< 
<       definition mkArr :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a, 'b) arr"
<       where "mkArr F G \<tau> \<equiv> (if natural_transformation A B F G \<tau>
<                             then Abs_arr (Some (\<tau>, (F, G))) else null)"
< 
<       abbreviation mkIde
<       where "mkIde F \<equiv> mkArr F F F"
< 
<       text\<open>
<         Destructors @{term Dom}, @{term Cod}, and @{term Fun} extract the components
<         of an arrow.
< \<close>
< 
<       definition Dom :: "('a, 'b) arr \<Rightarrow> 'a \<Rightarrow> 'b"
<       where "Dom t \<equiv> Dom' (the (Rep_arr t))"
< 
<       definition Cod :: "('a, 'b) arr \<Rightarrow> 'a \<Rightarrow> 'b"
<       where "Cod t \<equiv> Cod' (the (Rep_arr t))"
< 
<       definition Fun :: "('a, 'b) arr \<Rightarrow> 'a \<Rightarrow> 'b"
<       where "Fun t \<equiv> Fun' (the (Rep_arr t))"
---
>     type_synonym ('aa, 'bb) arr = "('aa \<Rightarrow> 'bb, 'aa \<Rightarrow> 'bb) concrete_category.arr"
199,327c41,64
<       text\<open>
<         Finally, we prove a set of facts that characterize the basic categorical notions
<         in terms of the constructors and destructors.  These are the facts that will
<         be exported.
< \<close>
< 
<       lemma null_char:
<       shows "null = Abs_arr None"
<         using comp_def AC.null_char CC.null_char by simp
< 
<       lemma arr_char:
<       shows "arr f \<longleftrightarrow> f \<noteq> null \<and> natural_transformation A B (Dom f) (Cod f) (Fun f)"
<         using comp_def not_arr_null Dom_def Cod_def Fun_def null_char AC.arr_char CC.arr_char
<               Arr'_def Rep_arr_inverse
<         by metis
< 
<       lemma arrI [intro]:
<       assumes "f \<noteq> null" and "natural_transformation A B (Dom f) (Cod f) (Fun f)"
<       shows "arr f"
<         using assms arr_char by blast
< 
<       lemma arrE [elim]:
<       assumes "arr f"
<       and "f \<noteq> null \<Longrightarrow> natural_transformation A B (Dom f) (Cod f) (Fun f) \<Longrightarrow> T"
<       shows T
<         using assms arr_char by simp
< 
<       lemma dom_char:
<       shows "dom f = (if arr f then mkIde (Dom f) else null)"
<         using comp_def mkArr_def Dom_def arr_char null_char AC.arr_char AC.dom_char CC.dom_char
<               functor_is_transformation natural_transformation_def
<         by (metis (no_types, lifting))
< 
<       lemma dom_simp:
<       assumes "arr t"
<       shows "dom t = mkIde (Dom t)"
<        using assms dom_char by auto
< 
<       lemma cod_char:
<       shows "cod f = (if arr f then mkIde (Cod f) else null)"
<         using comp_def mkArr_def Cod_def arr_char null_char AC.arr_char AC.cod_char CC.cod_char
<               functor_is_transformation natural_transformation_def
<         by (metis (no_types, lifting))
< 
<       lemma cod_simp:
<       assumes "arr t"
<       shows "cod t = mkIde (Cod t)"
<         using assms cod_char by auto
< 
<       lemma arr_mkArr [iff]:
<       shows "arr (mkArr F G \<tau>) \<longleftrightarrow> natural_transformation A B F G \<tau>"
<         using mkArr_def arr_char null_char Dom_def Cod_def Fun_def Abs_arr_inverse
<               UNIV_I fst_conv snd_conv option.sel
<         by (metis option.distinct(1))
< 
<       lemma Dom_mkArr [simp]:
<       assumes "arr (mkArr F G \<tau>)"
<       shows "Dom (mkArr F G \<tau>) = F"
<         using assms arr_char mkArr_def Dom_def Abs_arr_inverse
<         by (metis UNIV_I fst_conv option.sel snd_conv)
< 
<       lemma Cod_mkArr [simp]:
<       assumes "arr (mkArr F G \<tau>)"
<       shows "Cod (mkArr F G \<tau>) = G"
<         using assms arr_char mkArr_def Cod_def Abs_arr_inverse
<         by (metis UNIV_I option.sel snd_conv)
< 
<       lemma Fun_mkArr [simp]:
<       assumes "arr (mkArr F G \<tau>)"
<       shows "Fun (mkArr F G \<tau>) = \<tau>"
<         using assms arr_char mkArr_def Fun_def Abs_arr_inverse
<         by (metis UNIV_I fst_conv option.sel)
< 
<       lemma mkArr_Fun:
<       assumes "arr t"
<       shows "mkArr (Dom t) (Cod t) (Fun t) = t"
<         using assms arr_char mkArr_def
<         by (metis Cod_def Dom_def Fun_def Rep_arr_inverse null_char option.collapse prod.collapse)
< 
<       lemma seq_char:
<       shows "seq g f \<longleftrightarrow> arr f \<and> arr g \<and> Cod f = Dom g"
<       proof
<         assume gf: "seq g f"
<         have f: "arr f" using gf by auto
<         moreover have g: "arr g" using gf by auto
<         moreover have "Cod f = Dom g"
<         proof -
<           have "Cod f = Cod (dom g)"
<             using f gf cod_char arr_cod_iff_arr [of f] by auto
<           also have "... = Dom g"
<             using g dom_char ide_dom Cod_mkArr by (metis arr_dom)
<           finally show ?thesis by simp
<         qed
<         ultimately show "arr f \<and> arr g \<and> Cod f = Dom g" by blast
<         next
<         assume fg: "arr f \<and> arr g \<and> Cod f = Dom g"
<         show "seq g f"
<           using fg dom_char cod_char by auto
<       qed
< 
<       lemma comp_char:
<       shows "g \<cdot> f = (if seq g f then
<                         mkArr (Dom f) (Cod g) (vertical_composite.map A B (Fun f) (Fun g))
<                       else null)"
<       proof -
<         have "\<not>seq g f \<Longrightarrow> g \<cdot> f = null"
<           using comp_def AC.comp_char ext by fastforce
<         moreover have
<           "seq g f \<Longrightarrow>
<            g \<cdot> f = mkArr (Dom f) (Cod g) (vertical_composite.map A B (Fun f) (Fun g))"
<         proof -
<           assume gf: "seq g f"
<           interpret Fun_f: natural_transformation A B "Dom f" "Cod f" "Fun f"
<             using gf arr_char by blast
<           interpret Fun_g: natural_transformation A B "Cod f" "Cod g" "Fun g"
<             using gf arr_char seq_char by simp
<           interpret Fun_goFun_f: vertical_composite A B "Dom f" "Cod f" "Cod g" "Fun f" "Fun g" ..
<           show ?thesis
<             using gf comp_def AC.comp_char seqI' CC.comp_def arr_char null_char
<                   Dom_def Cod_def Fun_def mkArr_def Fun_goFun_f.natural_transformation_axioms
<             by (metis (no_types, lifting) Comp'_def)
<         qed
<         ultimately show ?thesis by auto
<       qed
< 
<       lemma comp_simp:
<       assumes "seq t s"
<       shows "t \<cdot> s = mkArr (Dom s) (Cod t) (vertical_composite.map A B (Fun s) (Fun t))"
<         using assms comp_char seq_char by auto
---
>     sublocale concrete_category \<open>Collect (functor A B)\<close>
>       \<open>\<lambda>F G. Collect (natural_transformation A B F G)\<close> \<open>\<lambda>F. F\<close>
>       \<open>\<lambda>F G H \<tau> \<sigma>. vertical_composite.map A B \<sigma> \<tau>\<close>
>       using vcomp_assoc
>       apply (unfold_locales, simp_all)
>     proof -
>       fix F G H \<sigma> \<tau>
>       assume F: "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F"
>       assume G: "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) G"
>       assume H: "functor (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) H"
>       assume \<sigma>: "natural_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F G \<sigma>"
>       assume \<tau>: "natural_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) G H \<tau>"
>       interpret F: "functor" A B F using F by simp
>       interpret G: "functor" A B G using G by simp
>       interpret H: "functor" A B H using H by simp
>       interpret \<sigma>: natural_transformation A B F G \<sigma>
>         using \<sigma> by simp
>       interpret \<tau>: natural_transformation A B G H \<tau>
>         using \<tau> by simp
>       interpret \<tau>\<sigma>: vertical_composite A B F G H \<sigma> \<tau>
>         ..
>       show "natural_transformation (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) F H (vertical_composite.map (\<cdot>\<^sub>A) (\<cdot>\<^sub>B) \<sigma> \<tau>)"
>         using \<tau>\<sigma>.map_def \<tau>\<sigma>.is_natural_transformation by simp
>     qed
329,348c66,74
<       lemma ide_char [iff]:
<       shows "ide t \<longleftrightarrow> t \<noteq> null \<and> functor A B (Fun t) \<and> Dom t = Fun t \<and> Cod t = Fun t"
<       proof
<         show "ide t \<Longrightarrow> t \<noteq> null \<and> functor A B (Fun t) \<and> Dom t = Fun t \<and> Cod t = Fun t"
<         proof -
<           assume t: "ide t"
<           have 1: "t = mkIde (Dom t) \<and> t = mkIde (Cod t)"
<             using t mkArr_Fun Cod_mkArr dom_simp cod_simp
<             by (metis ideD(1) ideD(2))
<           hence 2: "Dom t = Fun t \<and> Cod t = Fun t"
<             using t 1 Fun_mkArr [of "Dom t" "Dom t" "Dom t"] Fun_mkArr [of "Cod t" "Cod t" "Cod t"]
<             by auto
<           have 3: "functor A B (Fun t)"
<             using t 2 arr_char [of t] natural_transformation_def by force
<           show "t \<noteq> null \<and> functor A B (Fun t) \<and> Dom t = Fun t \<and> Cod t = Fun t"
<             using t 1 2 3 ideD(1) not_arr_null by blast
<         qed
<         show "t \<noteq> null \<and> functor A B (Fun t) \<and> Dom t = Fun t \<and> Cod t = Fun t \<Longrightarrow> ide t"
<           using arr_char dom_simp mkArr_Fun [of t] ide_dom [of t] by simp
<       qed
---
>     abbreviation comp      (infixr "\<cdot>" 55)
>     where "comp \<equiv> COMP"
>     notation in_hom        ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
> 
>     lemma arrI [intro]:
>     assumes "f \<noteq> null" and "natural_transformation A B (Dom f) (Cod f) (Map f)"
>     shows "arr f"
>       using assms arr_char null_char
>       by (simp add: natural_transformation_def)
350c76,88
<     end
---
>     lemma arrE [elim]:
>     assumes "arr f"
>     and "f \<noteq> null \<Longrightarrow> natural_transformation A B (Dom f) (Cod f) (Map f) \<Longrightarrow> T"
>     shows T
>       using assms arr_char null_char by simp
> 
>     lemma arr_MkArr [iff]:
>     shows "arr (MkArr F G \<tau>) \<longleftrightarrow> natural_transformation A B F G \<tau>"
>       using arr_char null_char arr_MkArr natural_transformation_def by fastforce
> 
>     lemma ide_char [iff]:
>     shows "ide t \<longleftrightarrow> t \<noteq> null \<and> functor A B (Map t) \<and> Dom t = Map t \<and> Cod t = Map t"
>       using ide_char null_char by fastforce
354,356d91
<   sublocale functor_category \<subseteq> category comp
<     using is_category by auto
< 
367,414c102
<     lemma ide_mkIde [simp]:
<     assumes "functor A B F"
<     shows "ide (mkIde F)"
<       using assms
<       by (metis Cod_mkArr Dom_mkArr Fun_mkArr arr_mkArr functor_is_transformation
<                 ide_char not_arr_null)
< 
<     lemma Dom_ide:
<     assumes "ide a"
<     shows "Dom a = Fun a"
<       using assms Dom_def Fun_def ide_char by blast
< 
<     lemma Cod_ide:
<     assumes "ide a"
<     shows "Cod a = Fun a"
<       using assms Cod_def Fun_def ide_char by blast
< 
<     lemma Dom_dom [simp]:
<     assumes "arr f"
<     shows "Dom (dom f) = Dom f"
<       using assms dom_simp Dom_mkArr arr_dom_iff_arr by metis
< 
<     lemma Cod_dom [simp]:
<     assumes "arr f"
<     shows "Cod (dom f) = Dom f"
<       using assms dom_simp Cod_mkArr arr_dom_iff_arr by metis
< 
<     lemma Dom_cod [simp]:
<     assumes "arr f"
<     shows "Dom (cod f) = Cod f"
<       using assms cod_simp Dom_mkArr arr_cod_iff_arr by metis
< 
<     lemma Cod_cod [simp]:
<     assumes "arr f"
<     shows "Cod (cod f) = Cod f"
<       using assms cod_simp Cod_mkArr arr_cod_iff_arr by metis
< 
<     lemma Fun_dom [simp]:
<     assumes "arr t"
<     shows "Fun (dom t) = Dom t"
<       using assms ide_dom by auto
< 
<     lemma Fun_cod [simp]:
<     assumes "arr t"
<     shows "Fun (cod t) = Cod t"
<       using assms ide_cod by auto
< 
<     lemma Fun_comp [simp]:
---
>     lemma Map_comp [simp]:
416c104
<     shows "Fun (t' \<cdot> t) (a' \<cdot>\<^sub>A a) = Fun t' a' \<cdot>\<^sub>B Fun t a"
---
>     shows "Map (t' \<cdot> t) (a' \<cdot>\<^sub>A a) = Map t' a' \<cdot>\<^sub>B Map t a"
418c106
<       interpret t: natural_transformation A B "Dom t" "Cod t" "Fun t"
---
>       interpret t: natural_transformation A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t\<close>
420,422c108,110
<       interpret t': natural_transformation A B "Cod t" "Cod t'" "Fun t'"
<         using assms(1) arr_char seq_char by auto
<       interpret t'ot: vertical_composite A B "Dom t" "Cod t" "Cod t'" "Fun t" "Fun t'" ..
---
>       interpret t': natural_transformation A B \<open>Cod t\<close> \<open>Cod t'\<close> \<open>Map t'\<close>
>         using assms(1) arr_char seq_char by force 
>       interpret t'ot: vertical_composite A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Cod t'\<close> \<open>Map t\<close> \<open>Map t'\<close> ..
425,426c113,114
<         have "Fun (t' \<cdot> t) = t'ot.map"
<           using assms(1) seq_char comp_simp t'ot.natural_transformation_axioms by simp
---
>         have "Map (t' \<cdot> t) = t'ot.map"
>           using assms(1) seq_char t'ot.natural_transformation_axioms by simp
432,435c120,131
<     lemma arr_eqI:
<     assumes "arr t" and "arr t'" and "Dom t = Dom t'" and "Cod t = Cod t'" and "Fun t = Fun t'"
<     shows "t = t'"
<       using assms mkArr_Fun by metis
---
>     lemma Map_comp':
>     assumes "seq t' t"
>     shows "Map (t' \<cdot> t) = vertical_composite.map A B (Map t) (Map t')"
>     proof -
>       interpret t: natural_transformation A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t\<close>
>         using assms(1) arr_char seq_char by blast
>       interpret t': natural_transformation A B \<open>Cod t\<close> \<open>Cod t'\<close> \<open>Map t'\<close>
>         using assms(1) arr_char seq_char by force 
>       interpret t'ot: vertical_composite A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Cod t'\<close> \<open>Map t\<close> \<open>Map t'\<close> ..
>       show ?thesis
>         using assms(1) seq_char t'ot.natural_transformation_axioms by simp
>     qed
437,438c133,134
<     lemma mkArr_eqI [intro]:
<     assumes "arr (mkArr F G \<tau>)"
---
>     lemma MkArr_eqI [intro]:
>     assumes "arr (MkArr F G \<tau>)"
440c136
<     shows "mkArr F G \<tau> = mkArr F' G' \<tau>'"
---
>     shows "MkArr F G \<tau> = MkArr F' G' \<tau>'"
443,445c139,141
<     lemma mkArr_eqI' [intro]:
<     assumes "arr (mkArr F G \<tau>)" and "\<tau> = \<tau>'"
<     shows "mkArr F G \<tau> = mkArr F G \<tau>'"
---
>     lemma MkArr_eqI' [intro]:
>     assumes "arr (MkArr F G \<tau>)" and "\<tau> = \<tau>'"
>     shows "MkArr F G \<tau> = MkArr F G \<tau>'"
448,457d143
<     lemma comp_mkArr [simp]:
<     assumes "arr (mkArr F G \<sigma>)" and "arr (mkArr G H \<tau>)"
<     shows "mkArr G H \<tau> \<cdot> mkArr F G \<sigma> = mkArr F H (vertical_composite.map A B \<sigma> \<tau>)"
<       using assms mkArr_Fun dom_simp cod_simp comp_char seq_char by simp
< 
<     lemma mkArr_in_hom:
<     assumes "natural_transformation A B F G \<tau>"
<     shows "\<guillemotleft>mkArr F G \<tau> : mkIde F \<rightarrow> mkIde G\<guillemotright>"
<       using assms dom_simp cod_simp by fastforce
< 
459c145
<     shows "iso t \<longleftrightarrow> t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Fun t)"
---
>     shows "iso t \<longleftrightarrow> t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Map t)"
462c148
<       show "t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Fun t)"
---
>       show "t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Map t)"
466c152
<         interpret \<tau>: natural_transformation A B "Dom t" "Cod t" "Fun t"
---
>         interpret \<tau>: natural_transformation A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t\<close>
468c154
<         interpret \<tau>': natural_transformation A B "Cod t" "Dom t" "Fun t'"
---
>         interpret \<tau>': natural_transformation A B \<open>Cod t\<close> \<open>Dom t\<close> \<open>Map t'\<close>
470,473c156,159
<           by (metis (no_types, lifting) comp_char ide_char inverse_arrowsE)
<         interpret \<tau>'o\<tau>: vertical_composite A B "Dom t" "Cod t" "Dom t" "Fun t" "Fun t'" ..
<         interpret \<tau>o\<tau>': vertical_composite A B "Cod t" "Dom t" "Cod t" "Fun t'" "Fun t" ..
<         show "natural_isomorphism A B (Dom t) (Cod t) (Fun t)"
---
>           by (metis arrE ide_compE inverse_arrowsE)
>         interpret \<tau>'o\<tau>: vertical_composite A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Dom t\<close> \<open>Map t\<close> \<open>Map t'\<close> ..
>         interpret \<tau>o\<tau>': vertical_composite A B \<open>Cod t\<close> \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t'\<close> \<open>Map t\<close> ..
>         show "natural_isomorphism A B (Dom t) (Cod t) (Map t)"
477c163
<           show "B.iso (Fun t a)"
---
>           show "B.iso (Map t a)"
481,482c167,169
<               by (metis Fun_cod Fun_mkArr comp_simp seq_char ide_compE inverse_arrowsE)
<             show "B.inverse_arrows (Fun t a) (Fun t' a)"
---
>               by (metis (no_types, lifting) Map_dom concrete_category.Map_comp
>                   concrete_category_axioms ide_compE inverse_arrowsE seq_char)
>             show "B.inverse_arrows (Map t a) (Map t' a)"
489c176
<       assume t: "t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Fun t)"
---
>       assume t: "t \<noteq> null \<and> natural_isomorphism A B (Dom t) (Cod t) (Map t)"
492c179
<         interpret \<tau>: natural_isomorphism A B "Dom t" "Cod t" "Fun t"
---
>         interpret \<tau>: natural_isomorphism A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t\<close>
494,496c181,183
<         interpret \<tau>': inverse_transformation A B "Dom t" "Cod t" "Fun t" ..
<         have 1: "vertical_composite.map A B (Fun t) \<tau>'.map = Dom t \<and>
<                  vertical_composite.map A B \<tau>'.map (Fun t) = Cod t"
---
>         interpret \<tau>': inverse_transformation A B \<open>Dom t\<close> \<open>Cod t\<close> \<open>Map t\<close> ..
>         have 1: "vertical_composite.map A B (Map t) \<tau>'.map = Dom t \<and>
>                  vertical_composite.map A B \<tau>'.map (Map t) = Cod t"
500c187
<         show "inverse_arrows t (mkArr (Cod t) (Dom t) (\<tau>'.map))"
---
>         show "inverse_arrows t (MkArr (Cod t) (Dom t) (\<tau>'.map))"
502,507c189
<           show "ide (mkArr (Cod t) (Dom t) \<tau>'.map \<cdot> t)"
<             using t 1
<             by (metis \<tau>'.natural_transformation_axioms \<tau>.F.functor_axioms
<                       \<tau>.natural_transformation_axioms arr_mkArr arrI
<                       comp_mkArr ide_mkIde mkArr_Fun)
<           show "ide (t \<cdot> mkArr (Cod t) (Dom t) \<tau>'.map)"
---
>           show 2: "ide (MkArr (Cod t) (Dom t) \<tau>'.map \<cdot> t)"
509,511c191,196
<             by (metis \<tau>'.natural_transformation_axioms \<tau>.G.functor_axioms
<                       \<tau>.natural_transformation_axioms arr_mkArr arrI
<                       comp_mkArr ide_mkIde mkArr_Fun)
---
>             by (metis (no_types, lifting) MkArr_Map MkIde_Dom \<tau>'.natural_transformation_axioms
>                 \<tau>.natural_transformation_axioms arrI arr_MkArr comp_MkArr ide_dom)
>           show "ide (t \<cdot> MkArr (Cod t) (Dom t) \<tau>'.map)"
>             using t 1 2
>             by (metis Map.simps(1) \<tau>'.natural_transformation_axioms arr_MkArr comp_char
>                 dom_MkArr dom_comp ide_char' ide_compE)
541c226
<     where "map Fg \<equiv> if A_BxA.arr Fg then A_B.Fun (fst Fg) (snd Fg) else B.null"
---
>     where "map Fg \<equiv> if A_BxA.arr Fg then A_B.Map (fst Fg) (snd Fg) else B.null"
545c230
<     shows "map Fg = A_B.Fun (fst Fg) (snd Fg)"
---
>     shows "map Fg = A_B.Map(fst Fg) (snd Fg)"
558,560c243,245
<       have DomF: "A_B.Dom ?F = A_B.Fun (A_B.dom ?F)" using F A_B.Fun_dom by simp
<       have CodF: "A_B.Cod ?F = A_B.Fun (A_B.cod ?F)" using F A_B.Fun_cod by simp
<       interpret F: natural_transformation A B "A_B.Dom ?F" "A_B.Cod ?F" "A_B.Fun ?F"
---
>       have DomF: "A_B.Dom ?F = A_B.Map (A_B.dom ?F)" using F by simp
>       have CodF: "A_B.Cod ?F = A_B.Map (A_B.cod ?F)" using F by simp
>       interpret F: natural_transformation A B \<open>A_B.Dom ?F\<close> \<open>A_B.Cod ?F\<close> \<open>A_B.Map ?F\<close>
564,565c249,251
<         using Fg map_def DomF
<         by (metis A_BxA.arr_dom_iff_arr A_BxA.dom_simp F.preserves_dom fst_conv g snd_conv)
---
>         using g Fg map_def DomF
>         by (metis (no_types, lifting) A_BxA.arr_dom A_BxA.dom_simp F.preserves_dom
>             fst_conv snd_conv)
567,568c253,255
<         using Fg map_def CodF
<        by (metis A_BxA.arr_cod_iff_arr A_BxA.cod_simp F.preserves_cod fst_conv g snd_conv)
---
>         using g Fg map_def CodF
>         by (metis (no_types, lifting) A_BxA.arr_cod A_BxA.cod_simp F.preserves_cod
>             fst_conv snd_conv)
575,578c262,265
<       have CodF: "A_B.Cod ?F = A_B.Fun (A_B.cod ?F)"
<         using 1 A_B.Fun_cod by fastforce
<       have DomF': "A_B.Dom ?F' = A_B.Fun (A_B.dom ?F')"
<         using F' A_B.Fun_dom by simp
---
>       have CodF: "A_B.Cod ?F = A_B.Map (A_B.cod ?F)"
>         using 1 by (metis A_B.Map_cod A_B.seqE A_BxA.seqE)
>       have DomF': "A_B.Dom ?F' = A_B.Map (A_B.dom ?F')"
>         using F' by simp
581c268
<       interpret F: natural_transformation A B "A_B.Dom ?F" "A_B.Cod ?F" "A_B.Fun ?F"
---
>       interpret F: natural_transformation A B \<open>A_B.Dom ?F\<close> \<open>A_B.Cod ?F\<close> \<open>A_B.Map ?F\<close>
583,586c270,274
<       interpret F': natural_transformation A B "A_B.Cod ?F" "A_B.Cod ?F'" "A_B.Fun ?F'"
<         using 1 seq_F'F CodF DomF' A_B.arr_char A_B.seqE by metis
<       interpret F'oF: vertical_composite A B "A_B.Dom ?F" "A_B.Cod ?F" "A_B.Cod ?F'"
<                                              "A_B.Fun ?F" "A_B.Fun ?F'" ..
---
>       interpret F': natural_transformation A B \<open>A_B.Cod ?F\<close> \<open>A_B.Cod ?F'\<close> \<open>A_B.Map ?F'\<close>
>         using 1 A_B.arr_char seq_F'F CodF DomF' A_B.seqE
>         by (metis mem_Collect_eq)
>       interpret F'oF: vertical_composite A B \<open>A_B.Dom ?F\<close> \<open>A_B.Cod ?F\<close> \<open>A_B.Cod ?F'\<close>
>                                              \<open>A_B.Map ?F\<close> \<open>A_B.Map ?F'\<close> ..
588,590c276,277
<         unfolding map_def A_B.Fun_def
<         using 1 seq_F'F seq_g'g A_B.Fun_comp A_B.Fun_def A_BxA.comp_def
<         by (elim A_B.seqE, auto)
---
>         unfolding map_def
>         using 1 seq_F'F seq_g'g by auto
642c329
<                                A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>                                A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
651c338
<     shows "curry F G \<tau> f1 = A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>     shows "curry F G \<tau> f1 = A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
668c355
<         interpret F_dom_f1: "functor" A2 B "\<lambda>f2. F (A1.dom f1, f2)"
---
>         interpret F_dom_f1: "functor" A2 B \<open>\<lambda>f2. F (A1.dom f1, f2)\<close>
672c359
<         interpret G_cod_f1: "functor" A2 B "\<lambda>f2. G (A1.cod f1, f2)"
---
>         interpret G_cod_f1: "functor" A2 B \<open>\<lambda>f2. G (A1.cod f1, f2)\<close>
693,695c380
<           using f1 A2_B.arr_mkArr A2_B.dom_simp A2_B.cod_simp curry_simp
<                 A1.arr_dom_iff_arr A1.arr_cod_iff_arr
<           by auto
---
>           using f1 curry_simp by auto
706,708c391,392
<         using curry_def F.fixing_arr_gives_natural_transformation_1 A2_B.dom_simp A2_B.cod_simp
<               A2_B.comp_char F.preserves_comp_1 curry_simp A2_B.comp_simp A2_B.seq_char
<               A1.arr_cod_iff_arr
---
>         using curry_def F.fixing_arr_gives_natural_transformation_1
>               A2_B.comp_char F.preserves_comp_1 curry_simp A2_B.seq_char
718c402
<       interpret curry_F: "functor" A1 A2_B.comp "curry F F F"
---
>       interpret curry_F: "functor" A1 A2_B.comp \<open>curry F F F\<close>
720c404
<       interpret curry_G: "functor" A1 A2_B.comp "curry G G G"
---
>       interpret curry_G: "functor" A1 A2_B.comp \<open>curry G G G\<close>
734,737c418,420
<           interpret \<tau>_dom_f1: natural_transformation A2 B "\<lambda>f2. F (A1.dom f1, f2)"
<                                 "\<lambda>f2. G (A1.dom f1, f2)" "\<lambda>f2. \<tau> (A1.dom f1, f2)"
<             using assms f1 curry_in_hom A2_B.arr_mkArr A1.ide_dom
<                   \<tau>.fixing_ide_gives_natural_transformation_1
---
>           interpret \<tau>_dom_f1: natural_transformation A2 B \<open>\<lambda>f2. F (A1.dom f1, f2)\<close>
>                                 \<open>\<lambda>f2. G (A1.dom f1, f2)\<close> \<open>\<lambda>f2. \<tau> (A1.dom f1, f2)\<close>
>             using assms f1 curry_in_hom A1.ide_dom \<tau>.fixing_ide_gives_natural_transformation_1
740c423
<                                 "\<lambda>f2. G (A1.dom f1, f2)" "\<lambda>f2. G (A1.cod f1, f2)" "\<lambda>f2. G (f1, f2)"
---
>                                 \<open>\<lambda>f2. G (A1.dom f1, f2)\<close> \<open>\<lambda>f2. G (A1.cod f1, f2)\<close> \<open>\<lambda>f2. G (f1, f2)\<close>
743,745c426,428
<                                      "\<lambda>f2. F (A1.dom f1, f2)" "\<lambda>f2. G (A1.dom f1, f2)"
<                                      "\<lambda>f2. G (A1.cod f1, f2)"
<                                      "\<lambda>f2. \<tau> (A1.dom f1, f2)" "\<lambda>f2. G (f1, f2)" ..
---
>                                      \<open>\<lambda>f2. F (A1.dom f1, f2)\<close> \<open>\<lambda>f2. G (A1.dom f1, f2)\<close>
>                                      \<open>\<lambda>f2. G (A1.cod f1, f2)\<close>
>                                      \<open>\<lambda>f2. \<tau> (A1.dom f1, f2)\<close> \<open>\<lambda>f2. G (f1, f2)\<close> ..
747c430
<                   = A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2)) G_f1o\<tau>_dom_f1.map"
---
>                   = A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2)) G_f1o\<tau>_dom_f1.map"
752,754c435,436
<               using curry_simp A2_B.comp_simp [of "curry G G G f1" "curry F G \<tau> (A1.dom f1)"]
<               by (metis A1.arr_dom_iff_arr A1.dom_dom A2_B.Cod_mkArr A2_B.Dom_mkArr
<                         A2_B.Fun_mkArr A2_B.seqE f1)
---
>               using f1 curry_simp A2_B.comp_char [of "curry G G G f1" "curry F G \<tau> (A1.dom f1)"]
>               by simp
756c438
<           also have "... = A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>           also have "... = A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
758c440
<           proof (intro A2_B.mkArr_eqI)
---
>           proof (intro A2_B.MkArr_eqI)
761c443
<             show "A2_B.arr (A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>             show "A2_B.arr (A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
763c445
<               using A2_B.arr_mkArr G_f1o\<tau>_dom_f1.natural_transformation_axioms by blast
---
>               using G_f1o\<tau>_dom_f1.natural_transformation_axioms by blast
771,773c453,455
<                 interpret \<tau>_f1: natural_transformation A2 B "\<lambda>f2. F (A1.dom f1, f2)"
<                                   "\<lambda>f2. G (A1.cod f1, f2)" "\<lambda>f2. \<tau> (f1, f2)"
<                   using assms f1 curry_in_hom [of f1] A2_B.arr_mkArr curry_simp by auto
---
>                 interpret \<tau>_f1: natural_transformation A2 B \<open>\<lambda>f2. F (A1.dom f1, f2)\<close>
>                                   \<open>\<lambda>f2. G (A1.cod f1, f2)\<close> \<open>\<lambda>f2. \<tau> (f1, f2)\<close>
>                   using assms f1 curry_in_hom [of f1] curry_simp by auto
788,791c470,472
<           interpret \<tau>_cod_f1: natural_transformation A2 B "\<lambda>f2. F (A1.cod f1, f2)"
<                                 "\<lambda>f2. G (A1.cod f1, f2)" "\<lambda>f2. \<tau> (A1.cod f1, f2)"
<             using assms f1 curry_in_hom A2_B.arr_mkArr A1.ide_cod
<                   \<tau>.fixing_ide_gives_natural_transformation_1
---
>           interpret \<tau>_cod_f1: natural_transformation A2 B \<open>\<lambda>f2. F (A1.cod f1, f2)\<close>
>                                 \<open>\<lambda>f2. G (A1.cod f1, f2)\<close> \<open>\<lambda>f2. \<tau> (A1.cod f1, f2)\<close>
>             using assms f1 curry_in_hom A1.ide_cod \<tau>.fixing_ide_gives_natural_transformation_1
794c475
<                                 "\<lambda>f2. F (A1.dom f1, f2)" "\<lambda>f2. F (A1.cod f1, f2)" "\<lambda>f2. F (f1, f2)"
---
>                                 \<open>\<lambda>f2. F (A1.dom f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1, f2)\<close> \<open>\<lambda>f2. F (f1, f2)\<close>
797,799c478,480
<                                      "\<lambda>f2. F (A1.dom f1, f2)" "\<lambda>f2. F (A1.cod f1, f2)"
<                                      "\<lambda>f2. G (A1.cod f1, f2)"
<                                      "\<lambda>f2. F (f1, f2)" "\<lambda>f2. \<tau> (A1.cod f1, f2)" ..
---
>                                      \<open>\<lambda>f2. F (A1.dom f1, f2)\<close> \<open>\<lambda>f2. F (A1.cod f1, f2)\<close>
>                                      \<open>\<lambda>f2. G (A1.cod f1, f2)\<close>
>                                      \<open>\<lambda>f2. F (f1, f2)\<close> \<open>\<lambda>f2. \<tau> (A1.cod f1, f2)\<close> ..
801c482
<                   = A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2)) \<tau>_cod_f1oF_f1.map"
---
>                   = A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2)) \<tau>_cod_f1oF_f1.map"
805,806c486,487
<                     A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. F (A1.cod f1, f2))
<                                        (\<lambda>f2. F (f1, f2)) \<and>
---
>                     A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. F (A1.cod f1, f2))
>                                (\<lambda>f2. F (f1, f2)) \<and>
811c492
<                     A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.dom f1, f2))
---
>                     A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.dom f1, f2))
817c498
<               using f1 curry_def A2_B.comp_mkArr by fastforce
---
>               using f1 curry_def by fastforce
819c500
<           also have "... = A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>           also have "... = A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
821c502
<           proof (intro A2_B.mkArr_eqI)
---
>           proof (intro A2_B.MkArr_eqI)
824c505
<             show "A2_B.arr (A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
---
>             show "A2_B.arr (A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. G (A1.cod f1, f2))
826c507
<               using A2_B.arr_mkArr \<tau>_cod_f1oF_f1.natural_transformation_axioms by blast
---
>               using \<tau>_cod_f1oF_f1.natural_transformation_axioms by blast
834,836c515,517
<                 interpret \<tau>_f1: natural_transformation A2 B "\<lambda>f2. F (A1.dom f1, f2)"
<                                   "\<lambda>f2. G (A1.cod f1, f2)" "\<lambda>f2. \<tau> (f1, f2)"
<                   using assms f1 curry_in_hom [of f1] A2_B.arr_mkArr curry_simp by auto
---
>                 interpret \<tau>_f1: natural_transformation A2 B \<open>\<lambda>f2. F (A1.dom f1, f2)\<close>
>                                   \<open>\<lambda>f2. G (A1.cod f1, f2)\<close> \<open>\<lambda>f2. \<tau> (f1, f2)\<close>
>                   using assms f1 curry_in_hom [of f1] curry_simp by auto
880,881c561,562
<         interpret Ff1: natural_transformation A2 B "A2_B.Dom (F ?f1)" "A2_B.Cod (F ?f1)"
<                                                    "A2_B.Fun (F ?f1)"
---
>         interpret Ff1: natural_transformation A2 B \<open>A2_B.Dom (F ?f1)\<close> \<open>A2_B.Cod (F ?f1)\<close>
>                                                    \<open>A2_B.Map (F ?f1)\<close>
883,884c564,565
<         interpret Fg1: natural_transformation A2 B "A2_B.Cod (F ?f1)" "A2_B.Cod (F ?g1)"
<                                                     "A2_B.Fun (F ?g1)"
---
>         interpret Fg1: natural_transformation A2 B \<open>A2_B.Cod (F ?f1)\<close> \<open>A2_B.Cod (F ?g1)\<close>
>                                                    \<open>A2_B.Map (F ?g1)\<close>
886c567
<                 A2_B.Fun_dom [of "F ?g1"] A2_B.Fun_cod [of "F ?f1"]
---
>                 A2_B.Map_dom [of "F ?g1"] A2_B.Map_cod [of "F ?f1"]
889,890c570,571
<                               "A2_B.Dom (F ?f1)" "A2_B.Cod (F ?f1)" "A2_B.Cod (F ?g1)"
<                               "A2_B.Fun (F ?f1)" "A2_B.Fun (F ?g1)" ..
---
>                               \<open>A2_B.Dom (F ?f1)\<close> \<open>A2_B.Cod (F ?f1)\<close> \<open>A2_B.Cod (F ?g1)\<close>
>                               \<open>A2_B.Map (F ?f1)\<close> \<open>A2_B.Map (F ?g1)\<close> ..
901c582
<       interpret "functor" A1xA2.comp B "uncurry F"
---
>       interpret "functor" A1xA2.comp B \<open>uncurry F\<close>
903c584
<       interpret "functor" A1xA2.comp B "uncurry G"
---
>       interpret "functor" A1xA2.comp B \<open>uncurry G\<close>
932,934c613,617
<             using f 1 2 uncurry_def \<tau>.is_natural_2 [of ?f1] A1xA2.cod_simp A2.seqE
<                   A1xA2.arr_cod_iff_arr A2_BxA2.comp_char
<             by (metis (no_types) A2_BxA2.seqI E.preserves_comp fst_conv)
---
>             unfolding uncurry_def E.map_def
>             using f 1 2
>             apply simp
>             by (metis (no_types, lifting) A2_B.Map_comp \<open>A2_B.arr (\<tau> (fst f))\<close> \<tau>.is_natural_2)
> 
944,945c627,628
<       interpret curry_\<tau>: natural_transformation A1 A2_B.comp "curry F F F" "curry G G G"
<                                                              "curry F G \<tau>"
---
>       interpret curry_\<tau>: natural_transformation A1 A2_B.comp \<open>curry F F F\<close> \<open>curry G G G\<close>
>                                                              \<open>curry F G \<tau>\<close>
951,953c634,641
<         unfolding uncurry_def using A1xA2.arr_char E.map_simp
<         by (metis A2_B.Fun_mkArr A2_BxA2.arr_char curry_\<tau>.preserves_reflects_arr fst_conv
<             curry_def prod.collapse snd_conv)
---
>       proof -
>         assume f: "A1xA2.arr f"
>         have 1: "A2_B.Map (curry F G \<tau> (fst f)) (snd f) = \<tau> (fst f, snd f)"
>           using f A1xA2.arr_char curry_def by simp
>         thus "uncurry (curry F G \<tau>) f = \<tau> f"
>           unfolding uncurry_def E.map_def
>           using f 1 A1xA2.arr_char [of f] by simp
>       qed
965c653
<       interpret uncurry_F: "functor" A1xA2.comp B "uncurry F"
---
>       interpret uncurry_F: "functor" A1xA2.comp B \<open>uncurry F\<close>
967c655
<       interpret uncurry_G: "functor" A1xA2.comp B "uncurry G"
---
>       interpret uncurry_G: "functor" A1xA2.comp B \<open>uncurry G\<close>
976c664
<             natural_transformation A1xA2.comp B "uncurry F" "uncurry G" "uncurry \<tau>"
---
>             natural_transformation A1xA2.comp B \<open>uncurry F\<close> \<open>uncurry G\<close> \<open>uncurry \<tau>\<close>
980c668
<                 A2_B.mkArr (\<lambda>f2. uncurry F (A1.dom f1, f2)) (\<lambda>f2. uncurry G (A1.cod f1, f2))
---
>                 A2_B.MkArr (\<lambda>f2. uncurry F (A1.dom f1, f2)) (\<lambda>f2. uncurry G (A1.cod f1, f2))
983c671
<         also have "... = A2_B.mkArr (\<lambda>f2. uncurry F (A1.dom f1, f2))
---
>         also have "... = A2_B.MkArr (\<lambda>f2. uncurry F (A1.dom f1, f2))
995,997c683,685
<             have "A2_B.Dom (\<tau> f1) = A2_B.Fun (A2_B.dom (\<tau> f1))"
<               using f1 A2_B.ide_char A2_B.Fun_dom A2_B.dom_simp by auto
<             also have "... = A2_B.Fun (F (A1.dom f1))"
---
>             have "A2_B.Dom (\<tau> f1) = A2_B.Map (A2_B.dom (\<tau> f1))"
>               using f1 A2_B.ide_char A2_B.Map_dom A2_B.dom_char by auto
>             also have "... = A2_B.Map (F (A1.dom f1))"
1002c690
<               interpret F_dom_f1: "functor" A2 B "A2_B.Fun (F (A1.dom f1))"
---
>               interpret F_dom_f1: "functor" A2 B \<open>A2_B.Map (F (A1.dom f1))\<close>
1004c692
<               show "A2_B.Fun (F (A1.dom f1)) f2 = uncurry F (A1.dom f1, f2)"
---
>               show "A2_B.Map (F (A1.dom f1)) f2 = uncurry F (A1.dom f1, f2)"
1011,1013c699,701
<             have "A2_B.Cod (\<tau> f1) = A2_B.Fun (A2_B.cod (\<tau> f1))"
<               using f1 A2_B.ide_char A2_B.Fun_cod A2_B.cod_simp by auto
<             also have "... = A2_B.Fun (G (A1.cod f1))"
---
>             have "A2_B.Cod (\<tau> f1) = A2_B.Map (A2_B.cod (\<tau> f1))"
>               using f1 A2_B.ide_char A2_B.Map_cod A2_B.cod_char by auto
>             also have "... = A2_B.Map (G (A1.cod f1))"
1018c706
<               interpret G_cod_f1: "functor" A2 B "A2_B.Fun (G (A1.cod f1))"
---
>               interpret G_cod_f1: "functor" A2 B \<open>A2_B.Map (G (A1.cod f1))\<close>
1020c708
<               show "A2_B.Fun (G (A1.cod f1)) f2 = uncurry G (A1.cod f1, f2)"
---
>               show "A2_B.Map (G (A1.cod f1)) f2 = uncurry G (A1.cod f1, f2)"
1025c713
<           moreover have "A2_B.Fun (\<tau> f1) = (\<lambda>f2. E.map (\<tau> f1, f2))"
---
>           moreover have "A2_B.Map (\<tau> f1) = (\<lambda>f2. E.map (\<tau> f1, f2))"
1028,1032c716,719
<             have "\<not>A2.arr f2 \<Longrightarrow> A2_B.Fun (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2"
<               using f1 E.is_extensional A2_B.arr_char \<tau>.preserves_reflects_arr
<                     natural_transformation.is_extensional E.map_def
<               by (metis (no_types, lifting) prod.sel(1) prod.sel(2))
<             moreover have "A2.arr f2 \<Longrightarrow> A2_B.Fun (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2"
---
>             have "\<not>A2.arr f2 \<Longrightarrow> A2_B.Map (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2"
>               using f1 A2_B.arrE \<tau>.preserves_reflects_arr natural_transformation.is_extensional
>               by (metis (no_types, lifting) E.fixing_arr_gives_natural_transformation_1)
>             moreover have "A2.arr f2 \<Longrightarrow> A2_B.Map (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2"
1034c721
<             ultimately show "A2_B.Fun (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2" by blast
---
>             ultimately show "A2_B.Map (\<tau> f1) f2 = (\<lambda>f2. E.map (\<tau> f1, f2)) f2" by blast
1037c724
<             using A2_B.mkArr_Fun f1 \<tau>.preserves_reflects_arr by metis
---
>             using f1 A2_B.MkArr_Map \<tau>.preserves_reflects_arr by metis
1068c755
<            A2_B.mkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. F (A1.cod f1, f2)) (\<lambda>f2. F (f1, f2))"
---
>            A2_B.MkArr (\<lambda>f2. F (A1.dom f1, f2)) (\<lambda>f2. F (A1.cod f1, f2)) (\<lambda>f2. F (f1, f2))"
1104c791
<            A1_B.mkArr (\<lambda>f1. F (f1, A2.dom f2)) (\<lambda>f1. F (f1, A2.cod f2)) (\<lambda>f1. F (f1, f2))"
---
>            A1_B.MkArr (\<lambda>f1. F (f1, A2.dom f2)) (\<lambda>f1. F (f1, A2.cod f2)) (\<lambda>f1. F (f1, f2))"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/Functor.thy ../../AFPs/afp-2020/thys/Category3/Functor.thy
9c9
< imports Category DualCategory InitialTerminal
---
> imports Category ConcreteCategory DualCategory InitialTerminal
147,152c147,149
<         using assms 1 g g'
<         apply (elim B.inverse_arrowsE, intro A.inverse_arrowsI, auto)
<         using B.ide_dom B.iso_is_arr locally_reflects_ide preserves_comp
<          apply (metis A.in_homI A.seqI' A.dom_comp A.cod_comp A.in_homE)
<         using B.ide_dom B.iso_is_arr locally_reflects_ide preserves_comp
<         by (metis A.in_homI A.seqI' A.dom_comp A.cod_comp A.in_homE)
---
>         using assms 1 g g' A.inverse_arrowsI
>         by (metis A.arr_iff_in_hom A.dom_comp A.in_homE A.seqI' B.inverse_arrowsE
>             A.cod_comp locally_reflects_ide preserves_comp)
328a326,329
>   text \<open>
>     Inverse functors uniquely determine each other.
> \<close>
> 
411,412c412,415
<     Inverse functors uniquely determine each other.
< \<close>
---
>     We now prove the result, advertised earlier in theory \<open>ConcreteCategory\<close>,
>     that any category is in fact isomorphic to the concrete category formed from it in
>     the obvious way.
>   \<close>
414,424c417,418
<   lemma inverse_functor_eq:
<   assumes "inverse_functors C D F G" and "inverse_functors C D F G'"
<   shows "G = G'"
<   proof -
<     interpret FG: inverse_functors C D F G using assms(1) by auto
<     interpret FG': inverse_functors C D F G' using assms(2) by auto
<     show "G = G'"
<       using FG.G.is_extensional FG'.G.is_extensional FG'.inv FG'.inverse_functors_axioms
<             FG.inverse_functors_axioms inverse_functor_unique
<       by metis
<   qed
---
>   context category
>   begin
426,429c420,454
<   lemma inverse_functor_eq':
<   assumes "inverse_functors C D F G" and "inverse_functors C D F' G"
<   shows "F = F'"
<     using assms inverse_functors_sym inverse_functor_eq by blast
---
>     interpretation CC: concrete_category \<open>Collect ide\<close> hom id \<open>\<lambda>C B A g f. g \<cdot> f\<close>
>       using comp_arr_dom comp_cod_arr comp_assoc
>       by (unfold_locales, auto)
> 
>     interpretation F: "functor" C CC.COMP
>                        \<open>\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null\<close>
>       by (unfold_locales, auto simp add: in_homI)
> 
>     interpretation G: "functor" CC.COMP C \<open>\<lambda>F. if CC.arr F then CC.Map F else null\<close>
>       using CC.Map_in_Hom CC.seq_char
>       by (unfold_locales, auto)
> 
>     interpretation FG: inverse_functors C CC.COMP
>                        \<open>\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null\<close>
>                        \<open>\<lambda>F. if CC.arr F then CC.Map F else null\<close>
>     proof
>       show "(\<lambda>F. if CC.arr F then CC.Map F else null) \<circ>
>               (\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null) =
>             map"
>         using CC.arr_char map_def by fastforce
>       show "(\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null) \<circ>
>               (\<lambda>F. if CC.arr F then CC.Map F else null) =
>             CC.map"
>         using CC.MkArr_Map G.preserves_arr G.preserves_cod G.preserves_dom
>               CC.is_extensional
>         by auto
>     qed
> 
>     interpretation isomorphic_categories C CC.COMP ..
> 
>     theorem is_isomorphic_to_concrete_category:
>     shows "isomorphic_categories C CC.COMP"
>       ..
> 
>   end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/InitialTerminal.thy ../../AFPs/afp-2020/thys/Category3/InitialTerminal.thy
76,77c76,77
<         by (metis (no_types, lifting) iso_iff_section_and_retraction retractionI sectionI
<             terminal_def comp_in_homI ide_in_hom)
---
>         by (metis arr_iff_in_hom cod_comp retractionI sectionI seqI' terminal_def
>             dom_comp in_homE iso_iff_section_and_retraction ide_in_hom)
89,90c89,90
<         by (metis iso_iff_section_and_retraction retractionI sectionI
<             initial_def comp_in_homI ide_in_hom)
---
>         by (metis (no_types, lifting) arr_iff_in_hom cod_comp in_homE initial_def
>             retractionI sectionI dom_comp iso_iff_section_and_retraction ide_in_hom seqI')
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/Limit.thy ../../AFPs/afp-2020/thys/Category3/Limit.thy
51c51
<     natural_isomorphism Cop.comp S "Ya.Y a" F \<Phi>
---
>     natural_isomorphism Cop.comp S \<open>Ya.Y a\<close> F \<Phi>
89,92c89,92
<     interpretation \<Psi>: inverse_transformation Cop.comp S "Y a" F \<Phi> ..
<     interpretation \<Psi>': inverse_transformation Cop.comp S "Y a'" F \<Phi>' ..
<     interpretation \<Phi>\<Psi>': vertical_composite Cop.comp S "Y a" F "Y a'" \<Phi> \<Psi>'.map ..
<     interpretation \<Phi>'\<Psi>: vertical_composite Cop.comp S "Y a'" F "Y a" \<Phi>' \<Psi>.map ..
---
>     interpretation \<Psi>: inverse_transformation Cop.comp S \<open>Y a\<close> F \<Phi> ..
>     interpretation \<Psi>': inverse_transformation Cop.comp S \<open>Y a'\<close> F \<Phi>' ..
>     interpretation \<Phi>\<Psi>': vertical_composite Cop.comp S \<open>Y a\<close> F \<open>Y a'\<close> \<Phi> \<Psi>'.map ..
>     interpretation \<Phi>'\<Psi>: vertical_composite Cop.comp S \<open>Y a'\<close> F \<open>Y a\<close> \<Phi>' \<Psi>.map ..
95c95
<       shows "\<exists>!\<phi>. \<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> C.iso \<phi> \<and> map \<phi> = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
---
>       shows "\<exists>!\<phi>. \<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> C.iso \<phi> \<and> map \<phi> = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
101c101
<       interpret \<Phi>\<Psi>': natural_isomorphism Cop.comp S "Y a" "Y a'" \<Phi>\<Psi>'.map
---
>       interpret \<Phi>\<Psi>': natural_isomorphism Cop.comp S \<open>Y a\<close> \<open>Y a'\<close> \<Phi>\<Psi>'.map
108c108
<       interpret \<Phi>'\<Psi>: natural_isomorphism Cop.comp S "Y a'" "Y a" \<Phi>'\<Psi>.map
---
>       interpret \<Phi>'\<Psi>: natural_isomorphism Cop.comp S \<open>Y a'\<close> \<open>Y a\<close> \<Phi>'\<Psi>.map
111c111
<       interpret \<Phi>\<Psi>'_\<Phi>'\<Psi>: inverse_transformations Cop.comp S "Y a" "Y a'" \<Phi>\<Psi>'.map \<Phi>'\<Psi>.map
---
>       interpret \<Phi>\<Psi>'_\<Phi>'\<Psi>: inverse_transformations Cop.comp S \<open>Y a\<close> \<open>Y a'\<close> \<Phi>\<Psi>'.map \<Phi>'\<Psi>.map
132,133c132,133
<       have "Cop_S.inverse_arrows (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
<                                  (Cop_S.mkArr (Y a') (Y a) \<Phi>'\<Psi>.map)"
---
>       have "Cop_S.inverse_arrows (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
>                                  (Cop_S.MkArr (Y a') (Y a) \<Phi>'\<Psi>.map)"
142,145c142,145
<           have 1: "Cop_S.antipar (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
<                                  (Cop_S.mkArr (Y a') (Y a) \<Phi>'\<Psi>.map)"
<             using Ya Ya' \<Phi>\<Psi>' \<Phi>'\<Psi> Cop_S.dom_simp Cop_S.cod_simp Cop_S.seqI
<                   Cop_S.Cod_mkArr Cop_S.Dom_mkArr Cop_S.arr_mkArr
---
>           have 1: "Cop_S.antipar (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
>                                  (Cop_S.MkArr (Y a') (Y a) \<Phi>'\<Psi>.map)"
>             using Ya Ya' \<Phi>\<Psi>' \<Phi>'\<Psi> Cop_S.dom_char Cop_S.cod_char Cop_S.seqI
>                   Cop_S.arr_MkArr Cop_S.cod_MkArr Cop_S.dom_MkArr
147,154c147,154
<           show "Cop_S.ide (Cop_S.comp (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
<                                       (Cop_S.mkArr (Y a') (Y a) \<Phi>'\<Psi>.map))"
<             using 0 1 NaturalTransformation.inverse_transformations_inverse(2) Cop_S.comp_mkArr
<             by (metis Cop_S.ide_mkIde Cop_S.seqE Ya'.functor_axioms)
<           show "Cop_S.ide (Cop_S.comp (Cop_S.mkArr (Y a') (Y a) \<Phi>'\<Psi>.map)
<                                       (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map))"
<             using 0 1 NaturalTransformation.inverse_transformations_inverse(1) Cop_S.comp_mkArr
<             by (metis Cop_S.ide_mkIde Cop_S.seqE Ya.functor_axioms)
---
>           show "Cop_S.ide (Cop_S.comp (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map)
>                                       (Cop_S.MkArr (Y a') (Y a) \<Phi>'\<Psi>.map))"
>             using 0 1 NaturalTransformation.inverse_transformations_inverse(2) Cop_S.comp_MkArr
>             by (metis Cop_S.cod_MkArr Cop_S.ide_char' Cop_S.seqE)
>           show "Cop_S.ide (Cop_S.comp (Cop_S.MkArr (Y a') (Y a) \<Phi>'\<Psi>.map)
>                                       (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map))"
>             using 0 1 NaturalTransformation.inverse_transformations_inverse(1) Cop_S.comp_MkArr
>             by (metis Cop_S.cod_MkArr Cop_S.ide_char' Cop_S.seqE)
157,161c157,161
<       hence 3: "Cop_S.iso (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map)" using Cop_S.isoI by blast
<       hence "Cop_S.arr (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map)" using Cop_S.iso_is_arr by blast
<       hence "Cop_S.in_hom (Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map) (map a) (map a')"
<         using Ya.ide_a Ya'.ide_a Cop_S.dom_simp Cop_S.cod_simp by auto
<       hence "\<exists>f. \<guillemotleft>f : a \<rightarrow> a'\<guillemotright> \<and> map f = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
---
>       hence 3: "Cop_S.iso (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map)" using Cop_S.isoI by blast
>       hence "Cop_S.arr (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map)" using Cop_S.iso_is_arr by blast
>       hence "Cop_S.in_hom (Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map) (map a) (map a')"
>         using Ya.ide_a Ya'.ide_a Cop_S.dom_char Cop_S.cod_char by auto
>       hence "\<exists>f. \<guillemotleft>f : a \<rightarrow> a'\<guillemotright> \<and> map f = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
165c165
<         where \<phi>: "\<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> map \<phi> = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
---
>         where \<phi>: "\<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> map \<phi> = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
169c169
<       hence EX: "\<exists>\<phi>. \<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> C.iso \<phi> \<and> map \<phi> = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
---
>       hence EX: "\<exists>\<phi>. \<guillemotleft>\<phi> : a \<rightarrow> a'\<guillemotright> \<and> C.iso \<phi> \<and> map \<phi> = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
172c172
<         UN: "\<And>\<phi>'. \<guillemotleft>\<phi>' : a \<rightarrow> a'\<guillemotright> \<and> map \<phi>' = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map \<Longrightarrow> \<phi>' = \<phi>"
---
>         UN: "\<And>\<phi>'. \<guillemotleft>\<phi>' : a \<rightarrow> a'\<guillemotright> \<and> map \<phi>' = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map \<Longrightarrow> \<phi>' = \<phi>"
175c175
<         assume \<phi>': "\<guillemotleft>\<phi>' : a \<rightarrow> a'\<guillemotright> \<and> map \<phi>' = Cop_S.mkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
---
>         assume \<phi>': "\<guillemotleft>\<phi>' : a \<rightarrow> a'\<guillemotright> \<and> map \<phi>' = Cop_S.MkArr (Y a) (Y a') \<Phi>\<Psi>'.map"
265,267c265,268
<     interpret \<chi>': horizontal_composite J' J C F F \<chi>.A.map D F \<chi> ..
<     interpret \<chi>': natural_transformation J' C A'.map "D o F" "\<chi> o F"
<       using 1 \<chi>'.natural_transformation_axioms by auto
---
>     interpret \<chi>': natural_transformation J' C A'.map \<open>D o F\<close> \<open>\<chi> o F\<close>
>       using 1 horizontal_composite F.natural_transformation_axioms
>             \<chi>.natural_transformation_axioms
>       by fastforce
307c308
<       interpret Fa: constant_functor J B "F a"
---
>       interpret Fa: constant_functor J B \<open>F a\<close>
309d309
<       interpret \<chi>': horizontal_composite J A B \<chi>.A.map D F F \<chi> F ..
317,318c317,320
<       interpret \<chi>': natural_transformation J B Fa.map "F o D" "F o \<chi>"
<         using 1 \<chi>'.natural_transformation_axioms by auto      
---
>       interpret \<chi>': natural_transformation J B Fa.map \<open>F o D\<close> \<open>F o \<chi>\<close>
>         using 1 horizontal_composite \<chi>.natural_transformation_axioms
>               natural_transformation_axioms
>         by fastforce
353,354c355,356
<         interpret \<chi>: cone J C D "C.cod f" \<chi> using \<chi> by auto
<         interpret B: constant_functor J C "C.dom f"
---
>         interpret \<chi>: cone J C D \<open>C.cod f\<close> \<chi> using \<chi> by auto
>         interpret B: constant_functor J C \<open>C.dom f\<close>
409c411
<               interpret \<chi>: cone J C D "C.cod f" \<chi> using assms \<chi> by auto
---
>               interpret \<chi>: cone J C D \<open>C.cod f\<close> \<chi> using assms \<chi> by auto
443c445
<     interpret \<chi>f: cone J C D a' "D.cones_map f \<chi>"
---
>     interpret \<chi>f: cone J C D a' \<open>D.cones_map f \<chi>\<close>
445,446c447,448
<     interpret \<tau>o\<chi>f: vertical_composite J C \<chi>f.A.map D D' "D.cones_map f \<chi>" \<tau> ..
<     interpret \<tau>o\<chi>_f: cone J C D' a' "D'.cones_map f \<tau>o\<chi>.map"
---
>     interpret \<tau>o\<chi>f: vertical_composite J C \<chi>f.A.map D D' \<open>D.cones_map f \<chi>\<close> \<tau> ..
>     interpret \<tau>o\<chi>_f: cone J C D' a' \<open>D'.cones_map f \<tau>o\<chi>.map\<close>
506,507c508,509
<     shows
<         "map f = S.mkArr (\<iota> ` D.cones (C.cod f)) (\<iota> ` D.cones (C.dom f)) (\<iota> o D.cones_map f o \<o>)"
---
>     shows "map f = S.mkArr (\<iota> ` D.cones (C.cod f)) (\<iota> ` D.cones (C.dom f))
>                            (\<iota> o D.cones_map f o \<o>)"
807c809
<     interpretation S: set_category "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
---
>     interpretation S: set_category \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
810,811c812,813
<     interpretation S: concrete_set_category "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
<                                             UNIV "UP o Inr"
---
>     interpretation S: concrete_set_category \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
>                                             UNIV \<open>UP o Inr\<close>
820,821c822,823
<     interpretation Cones: cones_functor J C D "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
<                                         "UP o Inr" ..
---
>     interpretation Cones: cones_functor J C D \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
>                                         \<open>UP o Inr\<close> ..
823,824c825,826
<     interpretation Hom: hom_functor C "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
<                                       "\<lambda>_. UP o Inl"
---
>     interpretation Hom: hom_functor C \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
>                                       \<open>\<lambda>_. UP o Inl\<close>
831,832c833,834
<     interpretation Y: yoneda_functor C "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
<                                      "\<lambda>_. UP o Inl" ..
---
>     interpretation Y: yoneda_functor C \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
>                                      \<open>\<lambda>_. UP o Inl\<close> ..
834,835c836,837
<                          C "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
<                          "\<lambda>_. UP o Inl" a
---
>                          C \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
>                          \<open>\<lambda>_. UP o Inl\<close> a
866c868
<       universe of @{term S}.  The corresponding arrows of @{term S} are the
---
>       universe of @{term S}).  The corresponding arrows of @{term S} are the
870c872
<     definition \<Phi>o :: "'c \<Rightarrow> ('c + ('j \<Rightarrow> 'c)) SetCat.arr"
---
>     definition \<Phi>o :: "'c \<Rightarrow> ('c + ('j \<Rightarrow> 'c)) setcat.arr"
901c903
<                         Cop.comp SetCat.comp "Y a" Cones.map \<Phi>o
---
>                         Cop.comp SetCat.comp \<open>Y a\<close> Cones.map \<Phi>o
987c989
<                         Cop.comp SetCat.comp "Y a" Cones.map \<Phi>.map ..
---
>                         Cop.comp SetCat.comp \<open>Y a\<close> Cones.map \<Phi>.map ..
989c991
<     interpretation \<Phi>: natural_isomorphism Cop.comp SetCat.comp "Y a" Cones.map \<Phi>.map
---
>     interpretation \<Phi>: natural_isomorphism Cop.comp SetCat.comp \<open>Y a\<close> Cones.map \<Phi>.map
1125c1127
<                          C "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
---
>                          C \<open>SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp\<close>
1165c1167
<     shows "limit_situation J C D (SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp) \<phi> \<iota> a \<Phi> \<chi>"
---
>     shows "limit_situation J C D (SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp) \<phi> \<iota> a \<Phi> \<chi>"
1178c1180
<   sublocale limit_cone \<subseteq> limit_situation J C D "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) SetCat.arr comp"
---
>   sublocale limit_cone \<subseteq> limit_situation J C D "SetCat.comp :: ('c + ('j \<Rightarrow> 'c)) setcat.arr comp"
1187,1189c1189,1191
<     interpretation \<Phi>: set_valued_transformation Cop.comp S "Y a" Cones.map \<Phi> ..
<     interpretation \<Psi>: inverse_transformation Cop.comp S "Y a" Cones.map \<Phi> ..
<     interpretation \<Psi>: set_valued_transformation Cop.comp S Cones.map "Y a" \<Psi>.map ..
---
>     interpretation \<Phi>: set_valued_transformation Cop.comp S \<open>Y a\<close> Cones.map \<Phi> ..
>     interpretation \<Psi>: inverse_transformation Cop.comp S \<open>Y a\<close> Cones.map \<Phi> ..
>     interpretation \<Psi>: set_valued_transformation Cop.comp S Cones.map \<open>Y a\<close> \<Psi>.map ..
1457c1459
<         interpret D: diagram J C "D' o \<phi>" ..
---
>         interpret D: diagram J C \<open>D' o \<phi>\<close> ..
1461c1463
<         interpret \<chi>: limit_cone J C "D' o \<phi>" a \<chi> using \<chi> by auto
---
>         interpret \<chi>: limit_cone J C \<open>D' o \<phi>\<close> a \<chi> using \<chi> by auto
1468,1469c1470,1471
<         interpret \<chi>o\<psi>: cone J' C D' a "\<chi> o \<psi>" using \<chi>o\<psi> by auto
<         interpret \<chi>o\<psi>: limit_cone J' C D' a "\<chi> o \<psi>"
---
>         interpret \<chi>o\<psi>: cone J' C D' a \<open>\<chi> o \<psi>\<close> using \<chi>o\<psi> by auto
>         interpret \<chi>o\<psi>: limit_cone J' C D' a \<open>\<chi> o \<psi>\<close>
1476c1478
<           interpret \<chi>'o\<phi>: cone J C "D' o \<phi>" a' "\<chi>' o \<phi>" using \<chi>'o\<phi> by auto
---
>           interpret \<chi>'o\<phi>: cone J C \<open>D' o \<phi>\<close> a' \<open>\<chi>' o \<phi>\<close> using \<chi>'o\<phi> by auto
1570c1572
<     where "map f = (if C.arr f then J_C.mkArr (constant_functor.map J C (C.dom f))
---
>     where "map f = (if C.arr f then J_C.MkArr (constant_functor.map J C (C.dom f))
1582c1584
<       interpret Dom_f: constant_functor J C "C.dom f"
---
>       interpret Dom_f: constant_functor J C \<open>C.dom f\<close>
1584c1586
<       interpret Cod_f: constant_functor J C "C.cod f"
---
>       interpret Cod_f: constant_functor J C \<open>C.cod f\<close>
1596c1598
<         thus ?thesis using f 1 by (simp add: map_def J_C.dom_simp)
---
>         thus ?thesis using f 1 by (simp add: map_def J_C.dom_char)
1604c1606
<         thus ?thesis using f 1 by (simp add: map_def J_C.cod_simp)
---
>         thus ?thesis using f 1 by (simp add: map_def J_C.cod_char)
1610c1612
<       interpret Dom_f: constant_functor J C "C.dom f"
---
>       interpret Dom_f: constant_functor J C \<open>C.dom f\<close>
1612c1614
<       interpret Cod_f: constant_functor J C "C.cod f"
---
>       interpret Cod_f: constant_functor J C \<open>C.cod f\<close>
1616c1618
<       interpret Cod_g: constant_functor J C "C.cod g"
---
>       interpret Cod_g: constant_functor J C \<open>C.cod g\<close>
1629,1630c1631,1632
<         have "map (C g f) = J_C.mkArr Dom_f.map Cod_g.map
<                                        (constant_transformation.map J C (C g f))"
---
>         have "map (C g f) = J_C.MkArr Dom_f.map Cod_g.map
>                                       (constant_transformation.map J C (C g f))"
1632c1634
<         also have "... = J_C.mkArr Dom_f.map Cod_g.map (\<lambda>j. if J.arr j then C g f else C.null)"
---
>         also have "... = J_C.MkArr Dom_f.map Cod_g.map (\<lambda>j. if J.arr j then C g f else C.null)"
1638,1639c1640,1641
<         also have "... = J_C.comp (J_C.mkArr Cod_f.map Cod_g.map Fun_g.map)
<                                   (J_C.mkArr Dom_f.map Cod_f.map Fun_f.map)"
---
>         also have "... = J_C.comp (J_C.MkArr Cod_f.map Cod_g.map Fun_g.map)
>                                   (J_C.MkArr Dom_f.map Cod_f.map Fun_f.map)"
1641,1644c1643,1646
<           have "J_C.mkArr Cod_f.map Cod_g.map Fun_g.map \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>]
<                 J_C.mkArr Dom_f.map Cod_f.map Fun_f.map
<                   = J_C.mkArr Dom_f.map Cod_g.map Fun_fg.map"
<             using J_C.comp_char J_C.comp_mkArr Fun_f.natural_transformation_axioms
---
>           have "J_C.MkArr Cod_f.map Cod_g.map Fun_g.map \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>]
>                 J_C.MkArr Dom_f.map Cod_f.map Fun_f.map
>                   = J_C.MkArr Dom_f.map Cod_g.map Fun_fg.map"
>             using J_C.comp_char J_C.comp_MkArr Fun_f.natural_transformation_axioms
1647c1649
<           also have "... = J_C.mkArr Dom_f.map Cod_g.map
---
>           also have "... = J_C.MkArr Dom_f.map Cod_g.map
1677c1679
<     shows "diagram J C (J_C.Fun d)" and "J_C.mkIde (J_C.Fun d) = d"
---
>     shows "diagram J C (J_C.Map d)" and "J_C.MkIde (J_C.Map d) = d"
1679,1684c1681,1686
<       interpret \<delta>: natural_transformation J C "J_C.Fun d" "J_C.Fun d" "J_C.Fun d"
<         using assms J_C.ide_char J_C.arr_mkArr J_C.mkArr_def by fastforce
<       interpret D: "functor" J C "J_C.Fun d" ..
<       show "diagram J C (J_C.Fun d)" ..
<       show "J_C.mkIde (J_C.Fun d) = d"
<         using assms J_C.ide_char by (metis J_C.ideD(1) J_C.mkArr_Fun)
---
>       interpret \<delta>: natural_transformation J C \<open>J_C.Map d\<close> \<open>J_C.Map d\<close> \<open>J_C.Map d\<close>
>         using assms J_C.ide_char J_C.arr_MkArr by fastforce
>       interpret D: "functor" J C \<open>J_C.Map d\<close> ..
>       show "diagram J C (J_C.Map d)" ..
>       show "J_C.MkIde (J_C.Map d) = d"
>         using assms J_C.ide_char by (metis J_C.ideD(1) J_C.MkArr_Map)
1689c1691
<     shows "J_C.ide (J_C.mkIde D)" and "J_C.Fun (J_C.mkIde D) = D"
---
>     shows "J_C.ide (J_C.MkIde D)" and "J_C.Map (J_C.MkIde D) = D"
1692,1696c1694,1697
<       show "J_C.ide (J_C.mkIde D)" using J_C.ide_char
<         by (metis D.functor_axioms J_C.Cod_mkArr J_C.Dom_mkArr J_C.Fun_mkArr J_C.arr_mkArr
<                   J_C.not_arr_null functor_is_transformation)
<       thus "J_C.Fun (J_C.mkIde D) = D"
<         using J_C.Fun_mkArr J_C.in_homE by (metis J_C.ideD(1))
---
>       show "J_C.ide (J_C.MkIde D)" using J_C.ide_char
>         using D.functor_axioms J_C.ide_MkIde by auto
>       thus "J_C.Map (J_C.MkIde D) = D"
>         using J_C.in_homE by simp
1700c1701
<     shows "bij_betw J_C.Fun (Collect J_C.ide) (Collect (diagram J C))"
---
>     shows "bij_betw J_C.Map (Collect J_C.ide) (Collect (diagram J C))"
1702c1703
<       show "J_C.Fun \<in> Collect J_C.ide \<rightarrow> Collect (diagram J C)"
---
>       show "J_C.Map \<in> Collect J_C.ide \<rightarrow> Collect (diagram J C)"
1704c1705
<       show "J_C.mkIde \<in> Collect (diagram J C) \<rightarrow> Collect J_C.ide"
---
>       show "J_C.MkIde \<in> Collect (diagram J C) \<rightarrow> Collect J_C.ide"
1706c1707
<       show "\<And>d. d \<in> Collect J_C.ide \<Longrightarrow> J_C.mkIde (J_C.Fun d) = d"
---
>       show "\<And>d. d \<in> Collect J_C.ide \<Longrightarrow> J_C.MkIde (J_C.Map d) = d"
1708c1709
<       show "\<And>D. D \<in> Collect (diagram J C) \<Longrightarrow> J_C.Fun (J_C.mkIde D) = D"
---
>       show "\<And>D. D \<in> Collect (diagram J C) \<Longrightarrow> J_C.Map (J_C.MkIde D) = D"
1718,1719c1719,1720
<     shows "cone J C (J_C.Fun d) a (J_C.Fun x)"
<     and "J_C.mkArr (constant_functor.map J C a) (J_C.Fun d) (J_C.Fun x) = x"
---
>     shows "cone J C (J_C.Map d) a (J_C.Map x)"
>     and "J_C.MkArr (constant_functor.map J C a) (J_C.Map d) (J_C.Map x) = x"
1721c1722
<       interpret D: diagram J C "J_C.Fun d"
---
>       interpret D: diagram J C \<open>J_C.Map d\<close>
1732,1737c1733,1737
<         hence "J_C.Fun (J_C.dom x) = J_C.Fun (map a)" by simp
<         hence "J_C.Dom x = J_C.Fun (map a)"
<           using A.value_is_ide x.arrow J_C.in_homE by (metis J_C.Fun_dom)
<         moreover have "J_C.Fun (map a) = \<alpha>.map"
<           using A.value_is_ide preserves_ide map_def J_C.Fun_mkArr
<           by (metis J_C.arr_char J_C.ideD(1))
---
>         hence "J_C.Map (J_C.dom x) = J_C.Map (map a)" by simp
>         hence "J_C.Dom x = J_C.Map (map a)"
>           using A.value_is_ide x.arrow J_C.in_homE by (metis J_C.Map_dom)
>         moreover have "J_C.Map (map a) = \<alpha>.map"
>           using A.value_is_ide preserves_ide map_def by simp
1740c1740
<       have Cod_x: "J_C.Cod x = J_C.Fun d"
---
>       have Cod_x: "J_C.Cod x = J_C.Map d"
1742c1742
<       interpret \<chi>: natural_transformation J C A.map "J_C.Fun d" "J_C.Fun x"
---
>       interpret \<chi>: natural_transformation J C A.map \<open>J_C.Map d\<close> \<open>J_C.Map x\<close>
1744,1745c1744,1745
<       show "D.cone a (J_C.Fun x)" ..
<       show "J_C.mkArr A.map (J_C.Fun d) (J_C.Fun x) = x"
---
>       show "D.cone a (J_C.Map x)" ..
>       show "J_C.MkArr A.map (J_C.Map d) (J_C.Map x) = x"
1751c1751
<     assumes "J_C.ide d" and "cone J C (J_C.Fun d) a \<chi>"
---
>     assumes "J_C.ide d" and "cone J C (J_C.Map d) a \<chi>"
1753,1754c1753,1754
<              (J_C.mkArr (constant_functor.map J C a) (J_C.Fun d) \<chi>)"
<     and "J_C.Fun (J_C.mkArr (constant_functor.map J C a) (J_C.Fun d) \<chi>) = \<chi>"
---
>              (J_C.MkArr (constant_functor.map J C a) (J_C.Map d) \<chi>)"
>     and "J_C.Map (J_C.MkArr (constant_functor.map J C a) (J_C.Map d) \<chi>) = \<chi>"
1756,1757c1756,1757
<        interpret \<chi>: cone J C "J_C.Fun d" a \<chi> using assms(2) by auto
<        let ?x = "J_C.mkArr \<chi>.A.map (J_C.Fun d) \<chi>"
---
>        interpret \<chi>: cone J C \<open>J_C.Map d\<close> a \<chi> using assms(2) by auto
>        let ?x = "J_C.MkArr \<chi>.A.map (J_C.Map d) \<chi>"
1760,1767c1760,1766
<          have "\<guillemotleft>J_C.mkArr \<chi>.A.map (J_C.Fun d) \<chi> :
<                   J_C.mkIde \<chi>.A.map \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.mkIde (J_C.Fun d)\<guillemotright>"
<            using J_C.mkArr_in_hom \<chi>.natural_transformation_axioms by simp
<          moreover have "J_C.mkIde \<chi>.A.map = map a"
<            using \<chi>.A.value_is_ide map_def \<chi>.A.map_def
<            by (metis C.ide_char J_C.Fun_dom J_C.Fun_mkArr J_C.Dom_mkArr
<                      preserves_arr preserves_dom)
<          moreover have "J_C.mkIde (J_C.Fun d) = d"
---
>          have "\<guillemotleft>J_C.MkArr \<chi>.A.map (J_C.Map d) \<chi> :
>                   J_C.MkIde \<chi>.A.map \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.MkIde (J_C.Map d)\<guillemotright>"
>            using \<chi>.natural_transformation_axioms by auto
>          moreover have "J_C.MkIde \<chi>.A.map = map a"
>            using \<chi>.A.value_is_ide map_def \<chi>.A.map_def C.ide_char
>            by (metis (no_types, lifting) J_C.dom_MkArr preserves_arr preserves_dom)
>          moreover have "J_C.MkIde (J_C.Map d) = d"
1769c1768
<          ultimately show "C.ide a \<and> \<guillemotleft>J_C.mkArr \<chi>.A.map (J_C.Fun d) \<chi> : map a \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] d\<guillemotright>"
---
>          ultimately show "C.ide a \<and> \<guillemotleft>J_C.MkArr \<chi>.A.map (J_C.Map d) \<chi> : map a \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] d\<guillemotright>"
1773c1772
<        show "J_C.Fun (J_C.mkArr (constant_functor.map J C a) (J_C.Fun d) \<chi>) = \<chi>"
---
>        show "J_C.Map (J_C.MkArr (constant_functor.map J C a) (J_C.Map d) \<chi>) = \<chi>"
1785,1786c1784,1785
<     shows "J_C.mkArr (constant_functor.map J C a') D (diagram.cones_map J C D g \<chi>)
<              = J_C.mkArr (constant_functor.map J C a) D \<chi> \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g"
---
>     shows "J_C.MkArr (constant_functor.map J C a') D (diagram.cones_map J C D g \<chi>)
>              = J_C.MkArr (constant_functor.map J C a) D \<chi> \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g"
1797,1798c1796,1797
<       let ?x = "J_C.mkArr \<chi>.A.map D \<chi>"
<       let ?x' = "J_C.mkArr \<chi>'.A.map D ?\<chi>'"
---
>       let ?x = "J_C.MkArr \<chi>.A.map D \<chi>"
>       let ?x' = "J_C.MkArr \<chi>'.A.map D ?\<chi>'"
1805c1804
<         have 3: "\<guillemotleft>?x : map a \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.mkIde D\<guillemotright>"
---
>         have 3: "\<guillemotleft>?x : map a \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.MkIde D\<guillemotright>"
1807c1806
<           have 1: "map a = J_C.mkIde A.map"
---
>           have 1: "map a = J_C.MkIde A.map"
1812c1811
<             using x J_C.dom_simp 1 x \<chi>.ide_apex A.equals_dom_if_value_is_ide \<chi>.D.functor_axioms
---
>             using x J_C.dom_char 1 x \<chi>.ide_apex A.equals_dom_if_value_is_ide \<chi>.D.functor_axioms
1815c1814
<           moreover have "J_C.cod ?x = J_C.mkIde D" using x J_C.cod_simp by auto
---
>           moreover have "J_C.cod ?x = J_C.MkIde D" using x J_C.cod_char by auto
1818c1817
<         have 4: "\<guillemotleft>?x' : map a' \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.mkIde D\<guillemotright>"
---
>         have 4: "\<guillemotleft>?x' : map a' \<rightarrow>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] J_C.MkIde D\<guillemotright>"
1820c1819
<           have 1: "map a' = J_C.mkIde A'.map"
---
>           have 1: "map a' = J_C.MkIde A'.map"
1825c1824
<             using x' J_C.dom_simp 1 x' \<chi>'.ide_apex A'.equals_dom_if_value_is_ide \<chi>.D.functor_axioms
---
>             using x' J_C.dom_char 1 x' \<chi>'.ide_apex A'.equals_dom_if_value_is_ide \<chi>.D.functor_axioms
1828c1827
<           moreover have "J_C.cod ?x' = J_C.mkIde D" using x' J_C.cod_simp by auto
---
>           moreover have "J_C.cod ?x' = J_C.MkIde D" using x' J_C.cod_char by auto
1851c1850
<           also have "... = J_C.Cod (J_C.mkIde D)"
---
>           also have "... = J_C.Cod (J_C.MkIde D)"
1859c1858
<         show "J_C.Fun ?x' = J_C.Fun (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g)"
---
>         show "J_C.Map ?x' = J_C.Map (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g)"
1867,1871c1866,1868
<           have "J_C.Fun (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g) = \<chi>og.map"
<             using assms(1) 2 J_C.comp_char
<             by (metis C.arrI J_C.Fun_mkArr J_C.arr_mkArr g.natural_transformation_axioms
<                 map_def x)
<           also have "... = J_C.Fun ?x'"
---
>           have "J_C.Map (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g) = \<chi>og.map"
>             using assms(1) 2 J_C.comp_char map_def by auto
>           also have "... = J_C.Map ?x'"
1889c1886
<               \<longleftrightarrow> J_C.Fun x' = diagram.cones_map J C (J_C.Fun d) g (J_C.Fun x)"
---
>               \<longleftrightarrow> J_C.Map x' = diagram.cones_map J C (J_C.Map d) g (J_C.Map x)"
1898,1900c1895,1897
<       let ?D = "J_C.Fun d"
<       let ?\<chi> = "J_C.Fun x"
<       let ?\<chi>' = "J_C.Fun x'"
---
>       let ?D = "J_C.Map d"
>       let ?\<chi> = "J_C.Map x"
>       let ?\<chi>' = "J_C.Map x'"
1916c1913
<           hence "?\<chi>' = J_C.Fun x'"
---
>           hence "?\<chi>' = J_C.Map x'"
1920c1917
<             have "J_C.mkArr A'.map (J_C.Fun d) (D.cones_map g (J_C.Fun x)) = x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g"
---
>             have "J_C.MkArr A'.map (J_C.Map d) (D.cones_map g (J_C.Map x)) = x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] map g"
1924c1921
<             hence f1: "J_C.mkArr A'.map (J_C.Fun d) (D.cones_map g (J_C.Fun x)) = x'"
---
>             hence f1: "J_C.MkArr A'.map (J_C.Map d) (D.cones_map g (J_C.Map x)) = x'"
1926c1923
<             have "J_C.arr (J_C.mkArr A'.map (J_C.Fun d) (D.cones_map g (J_C.Fun x)))"
---
>             have "J_C.arr (J_C.MkArr A'.map (J_C.Map d) (D.cones_map g (J_C.Map x)))"
1931c1928
<               using f1 J_C.Fun_mkArr by blast
---
>               using f1 by auto
1943,1944c1940,1941
<                    J_C.mkArr (J_C.Dom (map g)) (J_C.Cod x)
<                              (vertical_composite.map J C (J_C.Fun (map g)) ?\<chi>)"
---
>                    J_C.MkArr (J_C.Dom (map g)) (J_C.Cod x)
>                              (vertical_composite.map J C (J_C.Map (map g)) ?\<chi>)"
1946c1943
<           have 2: "vertical_composite.map J C (J_C.Fun (map g)) ?\<chi> = \<chi>og.map"
---
>           have 2: "vertical_composite.map J C (J_C.Map (map g)) ?\<chi> = \<chi>og.map"
1950c1947
<           have "J_C.mkArr A'.map ?D ?\<chi>' = J_C.comp x (map g)"
---
>           have "J_C.MkArr A'.map ?D ?\<chi>' = J_C.comp x (map g)"
1954,1956c1951,1952
<             have "J_C.Fun d = J_C.Cod x"
<               by (metis J_C.Cod_mkArr J_C.arr_mkArr \<chi>.natural_transformation_axioms
<                         arrow_determines_cone(2) d x.arrow_from_functor_axioms)
---
>             have "J_C.Map d = J_C.Cod x"
>               using x.arrow by auto
1959c1955
<           moreover have "J_C.mkArr A'.map ?D ?\<chi>' = x'"
---
>           moreover have "J_C.MkArr A'.map ?D ?\<chi>' = x'"
1993c1989
<     shows "limit_cone J C D (G (J_C.mkIde D)) (J_C.Fun (Adj.\<epsilon> (J_C.mkIde D)))"
---
>     shows "limit_cone J C D (G (J_C.MkIde D)) (J_C.Map (Adj.\<epsilon> (J_C.MkIde D)))"
1996c1992
<       let ?d = "J_C.mkIde D"
---
>       let ?d = "J_C.MkIde D"
1999c1995
<       let ?\<chi> = "J_C.Fun ?x"
---
>       let ?\<chi> = "J_C.Map ?x"
2002,2003c1998,1999
<       hence 2: "J_C.Fun (J_C.mkIde D) = D"
<         using assms 1 J_C.Fun_mkArr J_C.in_homE \<Delta>.diagram_determines_ide(2) by simp
---
>       hence 2: "J_C.Map (J_C.MkIde D) = D"
>         using assms 1 J_C.in_homE \<Delta>.diagram_determines_ide(2) by simp
2019c2015
<         let ?x' = "J_C.mkArr \<chi>'.A.map D \<chi>'"
---
>         let ?x' = "J_C.MkArr \<chi>'.A.map D \<chi>'"
2053c2049
<     shows "diagram.has_as_limit J C D (G (J_C.mkIde D))"
---
>     shows "diagram.has_as_limit J C D (G (J_C.MkIde D))"
2096c2092
<         interpret D: diagram J C "J_C.Fun d"
---
>         interpret D: diagram J C \<open>J_C.Map d\<close>
2098,2099c2094,2095
<         let ?D = "J_C.Fun d"
<         have "diagram J C (J_C.Fun d)" ..
---
>         let ?D = "J_C.Map d"
>         have "diagram J C (J_C.Map d)" ..
2101a2098,2099
>         interpret A: constant_functor J C a
>           using limit by (simp add: Limit.cone_def limit_cone_def)
2104c2102
<         let ?x = "J_C.mkArr \<chi>.A.map ?D \<chi>"
---
>         let ?x = "J_C.MkArr A.map ?D \<chi>"
2110c2108
<           proof
---
>           proof -
2116c2114
<             let ?\<chi>' = "J_C.Fun x'"
---
>             let ?\<chi>' = "J_C.Map x'"
2121,2151c2119,2127
<             show "x.is_coext a' x' ?g"
<             proof (unfold x.is_coext_def)
<               have 1: "\<guillemotleft>?g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map ?g \<chi> = ?\<chi>'"
<                 using \<chi>.induced_arrow_def \<chi>.is_universal cone_\<chi>'
<                       theI' [of "\<lambda>f. \<guillemotleft>f : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map f \<chi> = ?\<chi>'"]
<                 by presburger
<               hence 2: "x' = ?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map ?g"
<               proof -
<                 have "x' = J_C.mkArr A'.map ?D ?\<chi>'"
<                   using D \<Delta>.arrow_determines_cone(2) x'.arrow_from_functor_axioms by auto
<                 thus ?thesis
<                   using 1 cone_\<chi> \<Delta>.cones_map_is_composition [of ?g a' a ?D \<chi>] by simp
<               qed
<               show "\<guillemotleft>?g : a' \<rightarrow> a\<guillemotright> \<and> x' = ?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map ?g"
<                 using 1 2 by auto
<             qed
<             next
<             fix a' x' g
<             assume A: "arrow_from_functor C J_C.comp \<Delta>.map a' d x'"
<             and X: "x.is_coext a' x' g"
<             let ?\<chi>' = "J_C.Fun x'"
<             interpret \<chi>': cone J C "J_C.Fun d" a' ?\<chi>' 
<               using D A \<Delta>.arrow_determines_cone by auto
<             have cone_\<chi>': "cone J C (J_C.Fun d) a' ?\<chi>'" ..
<             let ?g = "\<chi>.induced_arrow a' ?\<chi>'"
<             show "g = ?g"
<             proof -
<               have "\<guillemotleft>g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map g \<chi> = ?\<chi>'"
<               proof
<                 show G: "\<guillemotleft>g : a' \<rightarrow> a\<guillemotright>" using X x.is_coext_def by blast
<                 show "D.cones_map g \<chi> = ?\<chi>'"
---
>             show "\<exists>!g. x.is_coext a' x' g"
>             proof
>               show "x.is_coext a' x' ?g"
>               proof (unfold x.is_coext_def)
>                 have 1: "\<guillemotleft>?g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map ?g \<chi> = ?\<chi>'"
>                   using \<chi>.induced_arrow_def \<chi>.is_universal cone_\<chi>'
>                         theI' [of "\<lambda>f. \<guillemotleft>f : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map f \<chi> = ?\<chi>'"]
>                   by presburger
>                 hence 2: "x' = ?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map ?g"
2153,2161c2129,2132
<                   have 1: "x' = ?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map g"
<                     using X x.is_coext_def by blast
<                   hence "?\<chi>' = J_C.Fun (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map g)"
<                     using X x.is_coext_def by fast
<                   also have "... = D.cones_map g \<chi>"
<                     using 1 G cone_\<chi> \<Delta>.cones_map_is_composition
<                     by (metis (no_types, lifting) A D J_C.Fun_mkArr J_C.arr_mkArr
<                         \<Delta>.arrow_determines_cone(2) \<chi>'.natural_transformation_axioms)  
<                   finally show ?thesis by auto
---
>                   have "x' = J_C.MkArr A'.map ?D ?\<chi>'"
>                     using D \<Delta>.arrow_determines_cone(2) x'.arrow_from_functor_axioms by auto
>                   thus ?thesis
>                     using 1 cone_\<chi> \<Delta>.cones_map_is_composition [of ?g a' a ?D \<chi>] by simp
2162a2134,2181
>                 show "\<guillemotleft>?g : a' \<rightarrow> a\<guillemotright> \<and> x' = ?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map ?g"
>                   using 1 2 by auto
>               qed
>               next
>               fix g
>               assume X: "x.is_coext a' x' g"
>               show "g = ?g"
>               proof -
>                 have "\<guillemotleft>g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map g \<chi> = ?\<chi>'"
>                 proof
>                   show G: "\<guillemotleft>g : a' \<rightarrow> a\<guillemotright>" using X x.is_coext_def by blast
>                   show "D.cones_map g \<chi> = ?\<chi>'"
>                   proof -
>                     have "?\<chi>' = J_C.Map (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map g)"
>                       using X x.is_coext_def [of a' x' g] by fast
>                     also have "... = D.cones_map g \<chi>"
>                     proof -
>                       interpret map_g: constant_transformation J C g
>                         using G by (unfold_locales, auto)
>                       interpret \<chi>': vertical_composite J C
>                                       map_g.F.map A.map \<open>\<chi>.\<Phi>.Ya.Cop_S.Map d\<close>
>                                       map_g.map \<chi>
>                       proof (intro_locales)
>                         have "map_g.G.map = A.map"
>                           using G by blast
>                         thus "natural_transformation_axioms J (\<cdot>) map_g.F.map A.map map_g.map"
>                           using map_g.natural_transformation_axioms
>                           by (simp add: natural_transformation_def)
>                       qed
>                       have "J_C.Map (?x \<cdot>\<^sub>[\<^sub>J\<^sub>,\<^sub>C\<^sub>] \<Delta>.map g) = vertical_composite.map J C map_g.map \<chi>"
>                       proof -
>                         have "J_C.seq ?x (\<Delta>.map g)"
>                           using G x.arrow by auto
>                         thus ?thesis
>                           using G \<Delta>.map_def J_C.Map_comp' [of ?x "\<Delta>.map g"] by auto
>                       qed
>                       also have "... = D.cones_map g \<chi>"
>                         using G cone_\<chi> \<chi>'.map_def map_g.map_def \<chi>.is_natural_2 \<chi>'.map_simp_2
>                         by auto
>                       finally show ?thesis by blast
>                     qed
>                     finally show ?thesis by auto
>                   qed
>                 qed
>                 thus ?thesis
>                   using cone_\<chi>' \<chi>.is_universal \<chi>.induced_arrow_def
>                         theI_unique [of "\<lambda>g. \<guillemotleft>g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map g \<chi> = ?\<chi>'" g]
>                   by presburger
2164,2167d2182
<               thus ?thesis
<                 using cone_\<chi>' \<chi>.is_universal \<chi>.induced_arrow_def
<                       theI_unique [of "\<lambda>g. \<guillemotleft>g : a' \<rightarrow> a\<guillemotright> \<and> D.cones_map g \<chi> = ?\<chi>'" g]
<                 by presburger
2202c2217
<       interpret G\<chi>: cone J D GE.map "G a" ?G\<chi>
---
>       interpret G\<chi>: cone J D GE.map \<open>G a\<close> ?G\<chi>
2207c2222
<       interpret G\<chi>: limit_cone J D GE.map "G a" ?G\<chi>
---
>       interpret G\<chi>: limit_cone J D GE.map \<open>G a\<close> ?G\<chi>
2215c2230
<         interpret Fb: constant_functor J C "F b"
---
>         interpret Fb: constant_functor J C \<open>F b\<close>
2349c2364
<                 using j a g' Adj.\<psi>_in_terms_of_\<epsilon> C.comp_assoc by force
---
>                 using j a g' Adj.\<psi>_in_terms_of_\<epsilon> C.comp_assoc Adj.\<epsilon>_def by auto
2372c2387
<           moreover have "?g = \<phi> b f" using f Adj.\<phi>_in_terms_of_\<eta> \<kappa>.ide_apex by auto
---
>           moreover have "?g = \<phi> b f" using f Adj.\<phi>_in_terms_of_\<eta> \<kappa>.ide_apex Adj.\<eta>_def by auto
2613c2628
<       interpret \<chi>: cone J C D b "D.mkCone F"
---
>       interpret \<chi>: cone J C D b \<open>D.mkCone F\<close>
2801c2816
<       interpret E: constant_functor J.comp C "C.dom e"
---
>       interpret E: constant_functor J.comp C \<open>C.dom e\<close>
2806,2807c2821,2822
<         using C.dom_comp
<           apply (metis C.seqE C.cod_comp J.Zero_not_eq_One J.arr_char J.cod_simp map_def)
---
>         using C.dom_comp C.seqE C.cod_comp J.Zero_not_eq_One J.arr_char' J.cod_char map_def
>           apply (metis (no_types, lifting) C.not_arr_null parallel_pair.cod_simp(1) preserves_arr)
2820,2821c2835,2836
<             using j by (meson J.arr_char)
<           have "j = J.Zero \<or> C (map j) (mkCone e (J.dom j)) = mkCone e j"
---
>             using j parallel_pair.arr_char by meson
>           have "j = J.Zero \<or> map j \<cdot> mkCone e (J.dom j) = mkCone e j"
2826c2841
<             by (metis C.seqE C.comp_cod_arr J.dom_simp(1) mkCone_def)
---
>             by (metis (no_types, lifting) C.comp_cod_arr C.seqE mkCone_def J.dom_simp(1))
2830,2831c2845,2856
<           by (metis C.arr_dom_iff_arr C.comp_arr_dom E.map_simp J.Zero_not_eq_One J.arr_char
<                     J.cod_char J.cod_simp(1) C.dom_comp assms mkCone_def)
---
>         proof -
>           fix j
>           assume j: "J.arr j"
>           have "J.cod j = J.Zero \<Longrightarrow> mkCone e (J.cod j) \<cdot> E.map j = mkCone e j"
>             unfolding mkCone_def
>             using assms j J.arr_char J.cod_char C.comp_arr_dom mkCone_def J.Zero_not_eq_One
>             by (metis (no_types, lifting) C.seqE E.map_simp)
>           moreover have "J.cod j \<noteq> J.Zero \<Longrightarrow> mkCone e (J.cod j) \<cdot> E.map j = mkCone e j"
>             unfolding mkCone_def
>             using assms j C.comp_arr_dom by auto
>           ultimately show "mkCone e (J.cod j) \<cdot> E.map j = mkCone e j" by blast
>         qed
2842,2845c2867,2870
<         by (metis J.One_not_eq_j0 J.One_not_eq_j1 J.Zero_not_eq_j0 J.Zero_not_eq_j1 J.arr_char
<                   J.cod_simp(3-4) J.dom_simp(3-4) J.j0_not_eq_j1
<                   Limit.cone_def \<chi>.is_natural_2 \<chi>.naturality \<chi>.preserves_reflects_arr assms
<                   constant_functor.map_simp map_def)
---
>         using assms J.arr_char J.dom_char J.cod_char
>               J.One_not_eq_j0 J.One_not_eq_j1 J.Zero_not_eq_j0 J.Zero_not_eq_j1 J.j0_not_eq_j1
>         by (metis (no_types, lifting) Limit.cone_def \<chi>.is_natural_1 \<chi>.naturality
>             \<chi>.preserves_reflects_arr constant_functor.map_simp map_simp(3) map_simp(4))
2952c2977
<                 by metis
---
>                 by auto
2972c2997
<       interpret A': constant_functor J.comp C "C.dom e'"
---
>       interpret A': constant_functor J.comp C \<open>C.dom e'\<close>
3044c3069
<         interpret Obj: discrete_category "Collect J.ide" J.null
---
>         interpret Obj: discrete_category \<open>Collect J.ide\<close> J.null
3046c3071
<         interpret \<Delta>o: discrete_diagram_from_map "Collect J.ide" C D J.null
---
>         interpret \<Delta>o: discrete_diagram_from_map \<open>Collect J.ide\<close> C D J.null
3057c3082
<         interpret Arr: discrete_category "Collect J.arr" J.null
---
>         interpret Arr: discrete_category \<open>Collect J.arr\<close> J.null
3059c3084
<         interpret \<Delta>a: discrete_diagram_from_map "Collect J.arr" C "D o J.cod" J.null
---
>         interpret \<Delta>a: discrete_diagram_from_map \<open>Collect J.arr\<close> C \<open>D o J.cod\<close> J.null
3124c3149
<         interpret EQU: limit_cone PP.J.comp C PP.map "dom e" "PP.mkCone e"
---
>         interpret EQU: limit_cone PP.J.comp C PP.map \<open>dom e\<close> \<open>PP.mkCone e\<close>
3249c3274
<         interpret domE: constant_functor J C "dom e"
---
>         interpret domE: constant_functor J C \<open>dom e\<close>
3259c3284
<         interpret \<mu>: cone J C D "dom e" ?\<mu>
---
>         interpret \<mu>: cone J C D \<open>dom e\<close> ?\<mu>
3287c3312
<           interpret \<tau>o: cone Obj.comp C \<Delta>o.map a "\<Delta>o.mkCone \<tau>"
---
>           interpret \<tau>o: cone Obj.comp C \<Delta>o.map a \<open>\<Delta>o.mkCone \<tau>\<close>
3342c3367
<         interpret \<mu>: limit_cone J C D "dom e" ?\<mu>
---
>         interpret \<mu>: limit_cone J C D \<open>dom e\<close> ?\<mu>
3436,3437c3461
<                       using 2 e_in_hom h'_in_hom \<pi>o.cone_axioms
<                       by (auto simp del: comp_in_hom_simp')
---
>                       using 2 e_in_hom h'_in_hom \<pi>o.cone_axioms by auto
3546c3570
<           interpret \<chi>: cone J S D S.unity "\<phi> (S f y)"
---
>           interpret \<chi>: cone J S D S.unity \<open>\<phi> (S f y)\<close>
3563c3587
<           interpret B: constant_functor J S "S.dom f"
---
>           interpret B: constant_functor J S \<open>S.dom f\<close>
3580c3604
<           interpret B: constant_functor J S "S.dom f"
---
>           interpret B: constant_functor J S \<open>S.dom f\<close>
3607c3631
<                 interpret \<chi>: cone J S D S.unity "\<phi> (f \<cdot> y)"
---
>                 interpret \<chi>: cone J S D S.unity \<open>\<phi> (f \<cdot> y)\<close>
3642c3666
<         interpret \<chi>a: cone J S D a "?\<chi> a" using a cone [of a] by fastforce
---
>         interpret \<chi>a: cone J S D a \<open>?\<chi> a\<close> using a cone [of a] by fastforce
3646c3670
<         interpret \<chi>a: limit_cone J S D a "?\<chi> a"
---
>         interpret \<chi>a: limit_cone J S D a \<open>?\<chi> a\<close>
3688c3712
<               interpret f\<chi>a: cone J S D a' "cones_map ?f (?\<chi> a)"
---
>               interpret f\<chi>a: cone J S D a' \<open>cones_map ?f (?\<chi> a)\<close>
3765c3789
<                     interpret \<chi>'': cone J S D S.unity "\<phi> (f' \<cdot> y')" using 2 by auto
---
>                     interpret \<chi>'': cone J S D S.unity \<open>\<phi> (f' \<cdot> y')\<close> using 2 by auto
3825,3826c3849
<         interpret J: parallel_pair
<           apply unfold_locales by auto
---
>         interpret J: parallel_pair .
4194c4217
<       interpret J: discrete_category I "SOME x. x \<notin> I"
---
>       interpret J: discrete_category I \<open>SOME x. x \<notin> I\<close>
4197c4220
<       interpret D: discrete_diagram_from_map I S ?D "SOME j. j \<notin> I"
---
>       interpret D: discrete_diagram_from_map I S ?D \<open>SOME j. j \<notin> I\<close>
4514c4537
<       interpret \<chi>_dom_a: limit_cone J B "\<lambda>j. D (j, A.dom a)" "l (A.dom a)" "\<chi> (A.dom a)"
---
>       interpret \<chi>_dom_a: limit_cone J B \<open>\<lambda>j. D (j, A.dom a)\<close> \<open>l (A.dom a)\<close> \<open>\<chi> (A.dom a)\<close>
4516c4539
<       interpret \<chi>_cod_a: limit_cone J B "\<lambda>j. D (j, A.cod a)" "l (A.cod a)" "\<chi> (A.cod a)"
---
>       interpret \<chi>_cod_a: limit_cone J B \<open>\<lambda>j. D (j, A.cod a)\<close> \<open>l (A.cod a)\<close> \<open>\<chi> (A.cod a)\<close>
4518,4519c4541,4542
<       interpret Da: natural_transformation J B "\<lambda>j. D (j, A.dom a)" "\<lambda>j. D (j, A.cod a)"
<                                                "\<lambda>j. D (j, a)"
---
>       interpret Da: natural_transformation J B \<open>\<lambda>j. D (j, A.dom a)\<close> \<open>\<lambda>j. D (j, A.cod a)\<close>
>                                                \<open>\<lambda>j. D (j, a)\<close>
4522,4524c4545,4547
<                               \<chi>_dom_a.A.map "\<lambda>j. D (j, A.dom a)" "\<lambda>j. D (j, A.cod a)"
<                               "\<chi> (A.dom a)" "\<lambda>j. D (j, a)" ..
<       interpret Dao\<chi>_dom_a: cone J B "\<lambda>j. D (j, A.cod a)" "l (A.dom a)" Dao\<chi>_dom_a.map ..
---
>                               \<chi>_dom_a.A.map \<open>\<lambda>j. D (j, A.dom a)\<close> \<open>\<lambda>j. D (j, A.cod a)\<close>
>                               \<open>\<chi> (A.dom a)\<close> \<open>\<lambda>j. D (j, a)\<close> ..
>       interpret Dao\<chi>_dom_a: cone J B \<open>\<lambda>j. D (j, A.cod a)\<close> \<open>l (A.dom a)\<close> Dao\<chi>_dom_a.map ..
4541c4564
<       interpret \<chi>a: limit_cone J B "\<lambda>j. D (j, a)" "l a" "\<chi> a" using a assms by auto
---
>       interpret \<chi>a: limit_cone J B \<open>\<lambda>j. D (j, a)\<close> \<open>l a\<close> \<open>\<chi> a\<close> using a assms by auto
4576c4599
<         interpret \<chi>_dom_a: limit_cone J B "\<lambda>j. D (j, A.dom a)" "l (A.dom a)" "\<chi> (A.dom a)"
---
>         interpret \<chi>_dom_a: limit_cone J B \<open>\<lambda>j. D (j, A.dom a)\<close> \<open>l (A.dom a)\<close> \<open>\<chi> (A.dom a)\<close>
4578c4601
<         interpret \<chi>_cod_a: limit_cone J B "\<lambda>j. D (j, A.cod a)" "l (A.cod a)" "\<chi> (A.cod a)"
---
>         interpret \<chi>_cod_a: limit_cone J B \<open>\<lambda>j. D (j, A.cod a)\<close> \<open>l (A.cod a)\<close> \<open>\<chi> (A.cod a)\<close>
4580,4581c4603,4604
<         interpret \<chi>_dom_a'a: limit_cone J B "\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))" "l (A.dom (a' \<cdot>\<^sub>A a))"
<                                             "\<chi> (A.dom (a' \<cdot>\<^sub>A a))"
---
>         interpret \<chi>_dom_a'a: limit_cone J B \<open>\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))\<close> \<open>l (A.dom (a' \<cdot>\<^sub>A a))\<close>
>                                             \<open>\<chi> (A.dom (a' \<cdot>\<^sub>A a))\<close>
4583,4584c4606,4607
<         interpret \<chi>_cod_a'a: limit_cone J B "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))" "l (A.cod (a' \<cdot>\<^sub>A a))"
<                                             "\<chi> (A.cod (a' \<cdot>\<^sub>A a))"
---
>         interpret \<chi>_cod_a'a: limit_cone J B \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close> \<open>l (A.cod (a' \<cdot>\<^sub>A a))\<close>
>                                             \<open>\<chi> (A.cod (a' \<cdot>\<^sub>A a))\<close>
4586,4587c4609,4610
<         interpret Da: natural_transformation J B "\<lambda>j. D (j, A.dom a)" "\<lambda>j. D (j, A.cod a)"
<                                                  "\<lambda>j. D (j, a)"
---
>         interpret Da: natural_transformation J B \<open>\<lambda>j. D (j, A.dom a)\<close> \<open>\<lambda>j. D (j, A.cod a)\<close>
>                                                  \<open>\<lambda>j. D (j, a)\<close>
4589,4590c4612,4613
<         interpret Da': natural_transformation J B "\<lambda>j. D (j, A.cod a)" "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))"
<                                                   "\<lambda>j. D (j, a')"
---
>         interpret Da': natural_transformation J B \<open>\<lambda>j. D (j, A.cod a)\<close> \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close>
>                                                   \<open>\<lambda>j. D (j, a')\<close>
4593,4595c4616,4618
<                                  \<chi>_cod_a.A.map "\<lambda>j. D (j, A.cod a)" "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))"
<                                  "\<chi> (A.cod a)" "\<lambda>j. D (j, a')" ..
<         interpret Da'o\<chi>_cod_a: cone J B "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))" "l (A.cod a)" Da'o\<chi>_cod_a.map ..
---
>                                  \<chi>_cod_a.A.map \<open>\<lambda>j. D (j, A.cod a)\<close> \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close>
>                                  \<open>\<chi> (A.cod a)\<close> \<open>\<lambda>j. D (j, a')\<close>..
>         interpret Da'o\<chi>_cod_a: cone J B \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close> \<open>l (A.cod a)\<close> Da'o\<chi>_cod_a.map ..
4597,4598c4620,4621
<                           "\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))" "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))"
<                           "\<lambda>j. D (j, a' \<cdot>\<^sub>A a)"
---
>                           \<open>\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))\<close> \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close>
>                           \<open>\<lambda>j. D (j, a' \<cdot>\<^sub>A a)\<close>
4601,4605c4624,4628
<             vertical_composite J B \<chi>_dom_a'a.A.map "\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))"
<                                    "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))" "\<chi> (A.dom (a' \<cdot>\<^sub>A a))"
<                                    "\<lambda>j. D (j, a' \<cdot>\<^sub>A a)" ..
<         interpret Da'ao\<chi>_dom_a'a: cone J B "\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))"
<                                        "l (A.dom (a' \<cdot>\<^sub>A a))" Da'ao\<chi>_dom_a'a.map ..
---
>             vertical_composite J B \<chi>_dom_a'a.A.map \<open>\<lambda>j. D (j, A.dom (a' \<cdot>\<^sub>A a))\<close>
>                                    \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close> \<open>\<chi> (A.dom (a' \<cdot>\<^sub>A a))\<close>
>                                    \<open>\<lambda>j. D (j, a' \<cdot>\<^sub>A a)\<close> ..
>         interpret Da'ao\<chi>_dom_a'a: cone J B \<open>\<lambda>j. D (j, A.cod (a' \<cdot>\<^sub>A a))\<close>
>                                        \<open>l (A.dom (a' \<cdot>\<^sub>A a))\<close> Da'ao\<chi>_dom_a'a.map ..
4725c4748
<     shows "at a \<tau> j = A_B.Fun (\<tau> j) a"
---
>     shows "at a \<tau> j = A_B.Map (\<tau> j) a"
4732c4755
<       interpret uncurry_F: "functor" JxA.comp B "Curry.uncurry F"
---
>       interpret uncurry_F: "functor" JxA.comp B \<open>Curry.uncurry F\<close>
4734c4757
<       interpret uncurry_F: binary_functor J A B "Curry.uncurry F" ..
---
>       interpret uncurry_F: binary_functor J A B \<open>Curry.uncurry F\<close> ..
4742c4765
<       interpret uncurry_F: "functor" JxA.comp B "Curry.uncurry F"
---
>       interpret uncurry_F: "functor" JxA.comp B \<open>Curry.uncurry F\<close>
4744c4767
<       interpret uncurry_F: binary_functor J A B "Curry.uncurry F" ..
---
>       interpret uncurry_F: binary_functor J A B \<open>Curry.uncurry F\<close> ..
4754c4777
<       interpret uncurry_F: "functor" JxA.comp B "Curry.uncurry F"
---
>       interpret uncurry_F: "functor" JxA.comp B \<open>Curry.uncurry F\<close>
4756,4757c4779,4780
<       interpret uncurry_f: binary_functor J A B "Curry.uncurry F" ..
<       interpret uncurry_G: "functor" JxA.comp B "Curry.uncurry G"
---
>       interpret uncurry_f: binary_functor J A B \<open>Curry.uncurry F\<close> ..
>       interpret uncurry_G: "functor" JxA.comp B \<open>Curry.uncurry G\<close>
4759c4782
<       interpret uncurry_G: binary_functor J A B "Curry.uncurry G" ..
---
>       interpret uncurry_G: binary_functor J A B \<open>Curry.uncurry G\<close> ..
4761c4784
<                              JxA.comp B "Curry.uncurry F" "Curry.uncurry G" "Curry.uncurry \<tau>"
---
>                              JxA.comp B \<open>Curry.uncurry F\<close> \<open>Curry.uncurry G\<close> \<open>Curry.uncurry \<tau>\<close>
4765c4788
<                             "Curry.uncurry F" "Curry.uncurry G" "Curry.uncurry \<tau>" ..
---
>                             \<open>Curry.uncurry F\<close> \<open>Curry.uncurry G\<close> \<open>Curry.uncurry \<tau>\<close> ..
4773c4796
<            constant_functor.map J B (A_B.Fun x a)"
---
>            constant_functor.map J B (A_B.Map x a)"
4777c4800
<       interpret Fun_x: "functor" A B "A_B.Fun x"
---
>       interpret Fun_x: "functor" A B \<open>A_B.Map x\<close>
4779c4802
<       interpret Da: "functor" J B "at a D"
---
>       interpret Da: "functor" J B \<open>at a D\<close>
4781,4782c4804,4805
<       interpret Da: diagram J B "at a D" ..
<       interpret Xa: constant_functor J B "A_B.Fun x a"
---
>       interpret Da: diagram J B \<open>at a D\<close> ..
>       interpret Xa: constant_functor J B \<open>A_B.Map x a\<close>
4799c4822
<     shows "diagram.cone J B (at a D) (A_B.Fun x a) (at a \<chi>)"
---
>     shows "diagram.cone J B (at a D) (A_B.Map x a) (at a \<chi>)"
4803c4826
<       interpret Fun_x: "functor" A B "A_B.Fun x"
---
>       interpret Fun_x: "functor" A B \<open>A_B.Map x\<close>
4805,4806c4828,4829
<       interpret Da: diagram J B "at a D" using a at_ide_is_diagram by auto
<       interpret Xa: constant_functor J B "A_B.Fun x a"
---
>       interpret Da: diagram J B \<open>at a D\<close> using a at_ide_is_diagram by auto
>       interpret Xa: constant_functor J B \<open>A_B.Map x a\<close>
4808c4831
<       interpret \<chi>a: natural_transformation J B Xa.map "at a D" "at a \<chi>"
---
>       interpret \<chi>a: natural_transformation J B Xa.map \<open>at a D\<close> \<open>at a \<chi>\<close>
4812,4813c4835,4836
<       interpret \<chi>a: cone J B "at a D" "A_B.Fun x a" "at a \<chi>" ..
<       show cone_\<chi>a: "Da.cone (A_B.Fun x a) (at a \<chi>)" ..
---
>       interpret \<chi>a: cone J B \<open>at a D\<close> \<open>A_B.Map x a\<close> \<open>at a \<chi>\<close> ..
>       show cone_\<chi>a: "Da.cone (A_B.Map x a) (at a \<chi>)" ..
4820c4843
<       interpret Da: natural_transformation J B "at (A.dom a) D" "at (A.cod a) D" "at a D"
---
>       interpret Da: natural_transformation J B \<open>at (A.dom a) D\<close> \<open>at (A.cod a) D\<close> \<open>at a D\<close>
4822c4845
<       interpret Da': natural_transformation J B "at (A.cod a) D" "at (A.cod a') D" "at a' D"
---
>       interpret Da': natural_transformation J B \<open>at (A.cod a) D\<close> \<open>at (A.cod a') D\<close> \<open>at a' D\<close>
4824,4826c4847,4849
<       interpret Da'oDa: vertical_composite J B "at (A.dom a) D" "at (A.cod a) D" "at (A.cod a') D"
<                                                "at a D" "at a' D" ..
<       interpret Da'a: natural_transformation J B "at (A.dom a) D" "at (A.cod a') D" "at (a' \<cdot>\<^sub>A a) D"
---
>       interpret Da'oDa: vertical_composite J B \<open>at (A.dom a) D\<close> \<open>at (A.cod a) D\<close> \<open>at (A.cod a') D\<close>
>                                                \<open>at a D\<close> \<open>at a' D\<close> ..
>       interpret Da'a: natural_transformation J B \<open>at (A.dom a) D\<close> \<open>at (A.cod a') D\<close> \<open>at (a' \<cdot>\<^sub>A a) D\<close>
4836c4859
<           interpret Dj: "functor" A B "A_B.Fun (D j)"
---
>           interpret Dj: "functor" A B \<open>A_B.Map (D j)\<close>
4848c4871
<              (\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>')"
---
>              (\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>')"
4854c4877
<       interpret \<chi>f: cone J A_B.comp D x' "cones_map f \<chi>"
---
>       interpret \<chi>f: cone J A_B.comp D x' \<open>cones_map f \<chi>\<close>
4856,4857c4879,4880
<       interpret Fun_x: "functor" A B "A_B.Fun x" using x A_B.ide_char by simp
<       interpret Fun_x': "functor" A B "A_B.Fun x'" using x' A_B.ide_char by simp
---
>       interpret Fun_x: "functor" A B \<open>A_B.Map x\<close> using x A_B.ide_char by simp
>       interpret Fun_x': "functor" A B \<open>A_B.Map x'\<close> using x' A_B.ide_char by simp
4859c4882
<               (\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>')"
---
>               (\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>')"
4862c4885
<         have "\<And>a. A.ide a \<Longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>'"
---
>         have "\<And>a. A.ide a \<Longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>'"
4866,4867c4889,4890
<           interpret Da: diagram J B "at a D" using a at_ide_is_diagram by auto
<           interpret \<chi>a: cone J B "at a D" "A_B.Fun x a" "at a \<chi>"
---
>           interpret Da: diagram J B \<open>at a D\<close> using a at_ide_is_diagram by auto
>           interpret \<chi>a: cone J B \<open>at a D\<close> \<open>A_B.Map x a\<close> \<open>at a \<chi>\<close>
4869c4892
<           interpret \<chi>'a: cone J B "at a D" "A_B.Fun x' a" "at a \<chi>'"
---
>           interpret \<chi>'a: cone J B \<open>at a D\<close> \<open>A_B.Map x' a\<close> \<open>at a \<chi>'\<close>
4871,4872c4894,4895
<           have 1: "\<guillemotleft>A_B.Fun f a : A_B.Fun x' a \<rightarrow>\<^sub>B A_B.Fun x a\<guillemotright>"
<             using f a A_B.arr_char A_B.Fun_cod A_B.Fun_dom mem_Collect_eq
---
>           have 1: "\<guillemotleft>A_B.Map f a : A_B.Map x' a \<rightarrow>\<^sub>B A_B.Map x a\<guillemotright>"
>             using f a A_B.arr_char A_B.Map_cod A_B.Map_dom mem_Collect_eq
4874,4875c4897,4898
<             by (metis A_B.in_homE)
<           interpret \<chi>fa: cone J B "at a D" "A_B.Fun x' a" "Da.cones_map (A_B.Fun f a) (at a \<chi>)"
---
>             by (metis (no_types, lifting) A_B.in_homE)
>           interpret \<chi>fa: cone J B \<open>at a D\<close> \<open>A_B.Map x' a\<close> \<open>Da.cones_map (A_B.Map f a) (at a \<chi>)\<close>
4877c4900
<           show "Da.cones_map (A_B.Fun f a) (at a \<chi>) = at a \<chi>'"
---
>           show "Da.cones_map (A_B.Map f a) (at a \<chi>) = at a \<chi>'"
4880c4903
<             have "\<not>J.arr j \<Longrightarrow> Da.cones_map (A_B.Fun f a) (at a \<chi>) j = at a \<chi>' j"
---
>             have "\<not>J.arr j \<Longrightarrow> Da.cones_map (A_B.Map f a) (at a \<chi>) j = at a \<chi>' j"
4882c4905
<             moreover have "J.arr j \<Longrightarrow> Da.cones_map (A_B.Fun f a) (at a \<chi>) j = at a \<chi>' j"
---
>             moreover have "J.arr j \<Longrightarrow> Da.cones_map (A_B.Map f a) (at a \<chi>) j = at a \<chi>' j"
4885,4886c4908,4909
<               using \<chi>' \<chi>.A.map_simp A_B.Fun_comp [of "\<chi> j" f a a] by auto
<             ultimately show "Da.cones_map (A_B.Fun f a) (at a \<chi>) j = at a \<chi>' j" by blast
---
>               using \<chi>' \<chi>.A.map_simp A_B.Map_comp [of "\<chi> j" f a a] by auto
>             ultimately show "Da.cones_map (A_B.Map f a) (at a \<chi>) j = at a \<chi>' j" by blast
4889c4912
<         thus "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>'"
---
>         thus "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>'"
4892c4915
<       show "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>'
---
>       show "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>'
4896c4919
<             "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Fun f a) (at a \<chi>) = at a \<chi>'"
---
>             "\<forall>a. A.ide a \<longrightarrow> diagram.cones_map J B (at a D) (A_B.Map f a) (at a \<chi>) = at a \<chi>'"
4908,4910c4931,4933
<             have Dom_\<chi>f_j: "A_B.Dom (cones_map f \<chi> j) = A_B.Fun x'"
<               using x' j 1 A_B.Fun_dom \<chi>'.A.map_simp [of "J.dom j"] \<chi>f.preserves_dom J.ide_in_hom
<               by (metis (no_types, lifting) J.in_homE)
---
>             have Dom_\<chi>f_j: "A_B.Dom (cones_map f \<chi> j) = A_B.Map x'"
>               using x' j 1 A_B.Map_dom \<chi>'.A.map_simp [of "J.dom j"] \<chi>f.preserves_dom J.ide_in_hom
>               by (metis (no_types, lifting) J.ideD(2) \<chi>f.preserves_reflects_arr)
4912c4935
<               using x' j A_B.Fun_dom [of "\<chi>' j"] \<chi>'.preserves_hom \<chi>'.A.map_simp by simp
---
>               using x' j A_B.Map_dom [of "\<chi>' j"] \<chi>'.preserves_hom \<chi>'.A.map_simp by simp
4914,4915c4937,4938
<             have Cod_\<chi>f_j: "A_B.Cod (cones_map f \<chi> j) = A_B.Fun (D (J.cod j))"
<               using j A_B.Fun_cod [of "cones_map f \<chi> j"] A_B.cod_simp J.ide_in_hom
---
>             have Cod_\<chi>f_j: "A_B.Cod (cones_map f \<chi> j) = A_B.Map (D (J.cod j))"
>               using j A_B.Map_cod [of "cones_map f \<chi> j"] A_B.cod_char J.ide_in_hom
4917c4940
<               by auto
---
>               by (metis (no_types, lifting) "1" J.ideD(1) \<chi>f.preserves_cod)
4919c4942
<               using j A_B.Fun_cod [of "\<chi>' j"] \<chi>'.preserves_hom by simp
---
>               using j A_B.Map_cod [of "\<chi>' j"] \<chi>'.preserves_hom by simp
4921c4944
<             show "A_B.Fun (cones_map f \<chi> j) = A_B.Fun (\<chi>' j)"
---
>             show "A_B.Map (cones_map f \<chi> j) = A_B.Map (\<chi>' j)"
4923,4924c4946,4947
<               interpret \<chi>fj: natural_transformation A B "A_B.Fun x'" "A_B.Fun (D (J.cod j))"
<                                                     "A_B.Fun (cones_map f \<chi> j)"
---
>               interpret \<chi>fj: natural_transformation A B \<open>A_B.Map x'\<close> \<open>A_B.Map (D (J.cod j))\<close>
>                                                     \<open>A_B.Map (cones_map f \<chi> j)\<close>
4928,4931c4951,4954
<               show "natural_transformation A B (A_B.Fun x') (A_B.Fun (D (J.cod j)))
<                                            (A_B.Fun (cones_map f \<chi> j))" ..
<               interpret \<chi>'j: natural_transformation A B "A_B.Fun x'" "A_B.Fun (D (J.cod j))"
<                                                    "A_B.Fun (\<chi>' j)"
---
>               show "natural_transformation A B (A_B.Map x') (A_B.Map (D (J.cod j)))
>                                            (A_B.Map (cones_map f \<chi> j))" ..
>               interpret \<chi>'j: natural_transformation A B \<open>A_B.Map x'\<close> \<open>A_B.Map (D (J.cod j))\<close>
>                                                    \<open>A_B.Map (\<chi>' j)\<close>
4933,4935c4956,4958
<               show "natural_transformation A B (A_B.Fun x') (A_B.Fun (D (J.cod j)))
<                                            (A_B.Fun (\<chi>' j))" ..
<               show "\<And>a. A.ide a \<Longrightarrow> A_B.Fun (cones_map f \<chi> j) a = A_B.Fun (\<chi>' j) a"
---
>               show "natural_transformation A B (A_B.Map x') (A_B.Map (D (J.cod j)))
>                                            (A_B.Map (\<chi>' j))" ..
>               show "\<And>a. A.ide a \<Longrightarrow> A_B.Map (cones_map f \<chi> j) a = A_B.Map (\<chi>' j) a"
4939,4940c4962,4963
<                 interpret Da: diagram J B "at a D" using a at_ide_is_diagram by auto
<                 have cone_\<chi>a: "Da.cone (A_B.Fun x a) (at a \<chi>)"
---
>                 interpret Da: diagram J B \<open>at a D\<close> using a at_ide_is_diagram by auto
>                 have cone_\<chi>a: "Da.cone (A_B.Map x a) (at a \<chi>)"
4942c4965
<                 interpret \<chi>a: cone J B "at a D" "A_B.Fun x a" "at a \<chi>"
---
>                 interpret \<chi>a: cone J B \<open>at a D\<close> \<open>A_B.Map x a\<close> \<open>at a \<chi>\<close>
4944c4967
<                 interpret Fun_f: natural_transformation A B "A_B.Dom f" "A_B.Cod f" "A_B.Fun f"
---
>                 interpret Fun_f: natural_transformation A B \<open>A_B.Dom f\<close> \<open>A_B.Cod f\<close> \<open>A_B.Map f\<close>
4946c4969
<                 have fa: "A_B.Fun f a \<in> B.hom (A_B.Fun x' a) (A_B.Fun x a)"
---
>                 have fa: "A_B.Map f a \<in> B.hom (A_B.Map x' a) (A_B.Map x a)"
4948c4971
<                 have "A_B.Fun (cones_map f \<chi> j) a = Da.cones_map (A_B.Fun f a) (at a \<chi>) j"
---
>                 have "A_B.Map (cones_map f \<chi> j) a = Da.cones_map (A_B.Map f a) (at a \<chi>) j"
4950c4973
<                   have "A_B.Fun (cones_map f \<chi> j) a = A_B.Fun (A_B.comp (\<chi> j) f) a"
---
>                   have "A_B.Map (cones_map f \<chi> j) a = A_B.Map (A_B.comp (\<chi> j) f) a"
4952,4953c4975,4976
<                   also have "... = B (A_B.Fun (\<chi> j) a) (A_B.Fun f a)"
<                     using f j a \<chi>.preserves_hom A.ide_in_hom J.ide_in_hom A_B.Fun_comp
---
>                   also have "... = B (A_B.Map (\<chi> j) a) (A_B.Map f a)"
>                     using f j a \<chi>.preserves_hom A.ide_in_hom J.ide_in_hom A_B.Map_comp
4955,4957c4978,4980
<                     by (metis A.in_homE A.comp_ide_self A_B.Fun_comp A_B.seqI'
<                               J.in_homE mem_Collect_eq)
<                   also have "... = Da.cones_map (A_B.Fun f a) (at a \<chi>) j"
---
>                     by (metis (no_types, lifting) A.comp_ide_self A.ideD(1) A_B.seqI'
>                         J.ideD(1) mem_Collect_eq)
>                   also have "... = Da.cones_map (A_B.Map f a) (at a \<chi>) j"
4962c4985
<                 also have "... = A_B.Fun (\<chi>' j) a"
---
>                 also have "... = A_B.Map (\<chi>' j) a"
4964c4987
<                 finally show "A_B.Fun (cones_map f \<chi> j) a = A_B.Fun (\<chi>' j) a" by auto
---
>                 finally show "A_B.Map (cones_map f \<chi> j) a = A_B.Map (\<chi>' j) a" by auto
4975c4998
<       by evaluating @{term \<chi>} at @{term x} is a limit cone with apex @{term "A_B.Fun a x"}
---
>       by evaluating @{term \<chi>} at @{term x} is a limit cone with apex @{term "A_B.Map a x"}
4981c5004
<     and "\<forall>a. A.ide a \<longrightarrow> diagram.limit_cone J B (at a D) (A_B.Fun x a) (at a \<chi>)"
---
>     and "\<forall>a. A.ide a \<longrightarrow> diagram.limit_cone J B (at a D) (A_B.Map x a) (at a \<chi>)"
4998c5021
<                         \<exists>!fa. fa \<in> B.hom (A_B.Fun x' a) (A_B.Fun x a) \<and>
---
>                         \<exists>!fa. fa \<in> B.hom (A_B.Map x' a) (A_B.Map x a) \<and>
5003,5004c5026,5027
<           interpret Da: diagram J B "at a D" using a at_ide_is_diagram by auto
<           interpret \<chi>a: limit_cone J B "at a D" "A_B.Fun x a" "at a \<chi>"
---
>           interpret Da: diagram J B \<open>at a D\<close> using a at_ide_is_diagram by auto
>           interpret \<chi>a: limit_cone J B \<open>at a D\<close> \<open>A_B.Map x a\<close> \<open>at a \<chi>\<close>
5006c5029
<           interpret \<chi>'a: cone J B "at a D" "A_B.Fun x' a" "at a \<chi>'"
---
>           interpret \<chi>'a: cone J B \<open>at a D\<close> \<open>A_B.Map x' a\<close> \<open>at a \<chi>'\<close>
5008,5009c5031,5032
<           have "Da.cone (A_B.Fun x' a) (at a \<chi>')" ..
<           thus "\<exists>!fa. fa \<in> B.hom (A_B.Fun x' a) (A_B.Fun x a) \<and>
---
>           have "Da.cone (A_B.Map x' a) (at a \<chi>')" ..
>           thus "\<exists>!fa. fa \<in> B.hom (A_B.Map x' a) (A_B.Map x a) \<and>
5021c5044
<           let ?P = "\<lambda>a fa. \<guillemotleft>fa : A_B.Fun x' a \<rightarrow>\<^sub>B A_B.Fun x a\<guillemotright> \<and>
---
>           let ?P = "\<lambda>a fa. \<guillemotleft>fa : A_B.Map x' a \<rightarrow>\<^sub>B A_B.Map x a\<guillemotright> \<and>
5031c5054
<               "\<And>a. A.ide a \<Longrightarrow> \<guillemotleft>THE fa. ?P a fa : A_B.Fun x' a \<rightarrow>\<^sub>B A_B.Fun x a\<guillemotright>"
---
>               "\<And>a. A.ide a \<Longrightarrow> \<guillemotleft>THE fa. ?P a fa : A_B.Map x' a \<rightarrow>\<^sub>B A_B.Map x a\<guillemotright>"
5038c5061
<           interpret Fun_x: "functor" A B "\<lambda>a. A_B.Fun x a"
---
>           interpret Fun_x: "functor" A B \<open>\<lambda>a. A_B.Map x a\<close>
5040c5063
<           interpret Fun_x': "functor" A B "\<lambda>a. A_B.Fun x' a"
---
>           interpret Fun_x': "functor" A B \<open>\<lambda>a. A_B.Map x' a\<close>
5047c5070
<                          "\<lambda>a. A_B.Fun x' a" "\<lambda>a. A_B.Fun x a" ?Fun_f
---
>                          \<open>\<lambda>a. A_B.Map x' a\<close> \<open>\<lambda>a. A_B.Map x a\<close> ?Fun_f
5051c5074
<             show "\<guillemotleft>?Fun_f a : A_B.Fun x' a \<rightarrow>\<^sub>B A_B.Fun x a\<guillemotright>" using a AaPa by simp
---
>             show "\<guillemotleft>?Fun_f a : A_B.Map x' a \<rightarrow>\<^sub>B A_B.Map x a\<guillemotright>" using a AaPa by simp
5066,5068c5089,5091
<             let ?x_dom_a = "A_B.Fun x (A.dom a)"
<             let ?x_cod_a = "A_B.Fun x (A.cod a)"
<             let ?x_a = "A_B.Fun x a"
---
>             let ?x_dom_a = "A_B.Map x (A.dom a)"
>             let ?x_cod_a = "A_B.Map x (A.cod a)"
>             let ?x_a = "A_B.Map x a"
5073,5075c5096,5098
<             let ?x'_dom_a = "A_B.Fun x' (A.dom a)"
<             let ?x'_cod_a = "A_B.Fun x' (A.cod a)"
<             let ?x'_a = "A_B.Fun x' a"
---
>             let ?x'_dom_a = "A_B.Map x' (A.dom a)"
>             let ?x'_cod_a = "A_B.Map x' (A.cod a)"
>             let ?x'_a = "A_B.Map x' a"
5084,5086c5107,5109
<             interpret D_dom_a: diagram J B "at (A.dom a) D" using a at_ide_is_diagram by simp
<             interpret D_cod_a: diagram J B "at (A.cod a) D" using a at_ide_is_diagram by simp
<             interpret Da: natural_transformation J B "at (A.dom a) D" "at (A.cod a) D" "at a D"
---
>             interpret D_dom_a: diagram J B \<open>at (A.dom a) D\<close> using a at_ide_is_diagram by simp
>             interpret D_cod_a: diagram J B \<open>at (A.cod a) D\<close> using a at_ide_is_diagram by simp
>             interpret Da: natural_transformation J B \<open>at (A.dom a) D\<close> \<open>at (A.cod a) D\<close> \<open>at a D\<close>
5088,5089c5111,5112
<             interpret \<chi>_dom_a: limit_cone J B "at (A.dom a) D" "A_B.Fun x (A.dom a)"
<                                               "at (A.dom a) \<chi>"
---
>             interpret \<chi>_dom_a: limit_cone J B \<open>at (A.dom a) D\<close> \<open>A_B.Map x (A.dom a)\<close>
>                                               \<open>at (A.dom a) \<chi>\<close>
5091,5092c5114,5115
<             interpret \<chi>_cod_a: limit_cone J B "at (A.cod a) D" "A_B.Fun x (A.cod a)"
<                                               "at (A.cod a) \<chi>"
---
>             interpret \<chi>_cod_a: limit_cone J B \<open>at (A.cod a) D\<close> \<open>A_B.Map x (A.cod a)\<close>
>                                               \<open>at (A.cod a) \<chi>\<close>
5094c5117
<             interpret \<chi>'_dom_a: cone J B "at (A.dom a) D" "A_B.Fun x' (A.dom a)" "at (A.dom a) \<chi>'"
---
>             interpret \<chi>'_dom_a: cone J B \<open>at (A.dom a) D\<close> \<open>A_B.Map x' (A.dom a)\<close> \<open>at (A.dom a) \<chi>'\<close>
5096c5119
<             interpret \<chi>'_cod_a: cone J B "at (A.cod a) D" "A_B.Fun x' (A.cod a)" "at (A.cod a) \<chi>'"
---
>             interpret \<chi>'_cod_a: cone J B \<open>at (A.cod a) D\<close> \<open>A_B.Map x' (A.cod a)\<close> \<open>at (A.cod a) \<chi>'\<close>
5105,5107c5128,5130
<                                     \<chi>_dom_a.A.map "at (A.dom a) D" "at (A.cod a) D"
<                                     "at (A.dom a) \<chi>" "at a D" ..
<             interpret Dao\<chi>_dom_a: cone J B "at (A.cod a) D" ?x_dom_a Dao\<chi>_dom_a.map
---
>                                     \<chi>_dom_a.A.map \<open>at (A.dom a) D\<close> \<open>at (A.cod a) D\<close>
>                                     \<open>at (A.dom a) \<chi>\<close> \<open>at a D\<close> ..
>             interpret Dao\<chi>_dom_a: cone J B \<open>at (A.cod a) D\<close> ?x_dom_a Dao\<chi>_dom_a.map
5111,5113c5134,5136
<                                      \<chi>'_dom_a.A.map "at (A.dom a) D" "at (A.cod a) D"
<                                      "at (A.dom a) \<chi>'" "at a D" ..
<             interpret Dao\<chi>'_dom_a: cone J B "at (A.cod a) D" ?x'_dom_a Dao\<chi>'_dom_a.map
---
>                                      \<chi>'_dom_a.A.map \<open>at (A.dom a) D\<close> \<open>at (A.cod a) D\<close>
>                                      \<open>at (A.dom a) \<chi>'\<close> \<open>at a D\<close> ..
>             interpret Dao\<chi>'_dom_a: cone J B \<open>at (A.cod a) D\<close> ?x'_dom_a Dao\<chi>'_dom_a.map
5133c5156
<                 also have "... = A_B.Fun (D j) a \<cdot>\<^sub>B A_B.Fun (\<chi> (J.dom j)) (A.dom a)"
---
>                 also have "... = A_B.Map (D j) a \<cdot>\<^sub>B A_B.Map (\<chi> (J.dom j)) (A.dom a)"
5135,5138c5158,5162
<                 also have "... = A_B.Fun (A_B.comp (D j) (\<chi> (J.dom j))) a"
<                   using a j A_B.Fun_comp
<                   by (metis A.comp_arr_dom A_B.Fun_comp \<chi>.is_natural_1 \<chi>.preserves_reflects_arr)
<                 also have "... = A_B.Fun (A_B.comp (\<chi> (J.cod j)) (\<chi>.A.map j)) a"
---
>                 also have "... = A_B.Map (A_B.comp (D j) (\<chi> (J.dom j))) a"
>                   using a j A_B.Map_comp
>                   by (metis (no_types, lifting) A.comp_arr_dom \<chi>.is_natural_1
>                       \<chi>.preserves_reflects_arr)
>                 also have "... = A_B.Map (A_B.comp (\<chi> (J.cod j)) (\<chi>.A.map j)) a"
5140,5142c5164,5166
<                 also have "... = A_B.Fun (\<chi> (J.cod j)) (A.cod a) \<cdot>\<^sub>B A_B.Fun x a"
<                   using a j x A_B.Fun_comp
<                   by (metis A.comp_cod_arr A_B.Fun_comp \<chi>.A.map_simp \<chi>.is_natural_2
---
>                 also have "... = A_B.Map (\<chi> (J.cod j)) (A.cod a) \<cdot>\<^sub>B A_B.Map x a"
>                   using a j x A_B.Map_comp
>                   by (metis (no_types, lifting) A.comp_cod_arr \<chi>.A.map_simp \<chi>.is_natural_2
5144c5168
<                 also have "... = at (A.cod a) \<chi> (J.cod j) \<cdot>\<^sub>B A_B.Fun x a"
---
>                 also have "... = at (A.cod a) \<chi> (J.cod j) \<cdot>\<^sub>B A_B.Map x a"
5146c5170
<                 also have "... = at (A.cod a) \<chi> j \<cdot>\<^sub>B A_B.Fun x a"
---
>                 also have "... = at (A.cod a) \<chi> j \<cdot>\<^sub>B A_B.Map x a"
5168c5192
<                 also have "... = A_B.Fun (D j) a \<cdot>\<^sub>B A_B.Fun (\<chi>' (J.dom j)) (A.dom a)"
---
>                 also have "... = A_B.Map (D j) a \<cdot>\<^sub>B A_B.Map (\<chi>' (J.dom j)) (A.dom a)"
5170,5173c5194,5198
<                 also have "... = A_B.Fun (A_B.comp (D j) (\<chi>' (J.dom j))) a"
<                   using a j A_B.Fun_comp
<                   by (metis A.comp_arr_dom A_B.Fun_comp \<chi>'.is_natural_1 \<chi>'.preserves_reflects_arr)
<                 also have "... = A_B.Fun (A_B.comp (\<chi>' (J.cod j)) (\<chi>'.A.map j)) a"
---
>                 also have "... = A_B.Map (A_B.comp (D j) (\<chi>' (J.dom j))) a"
>                   using a j A_B.Map_comp
>                   by (metis (no_types, lifting) A.comp_arr_dom \<chi>'.is_natural_1
>                       \<chi>'.preserves_reflects_arr)
>                 also have "... = A_B.Map (A_B.comp (\<chi>' (J.cod j)) (\<chi>'.A.map j)) a"
5175,5177c5200,5202
<                 also have "... = A_B.Fun (\<chi>' (J.cod j)) (A.cod a) \<cdot>\<^sub>B A_B.Fun x' a"
<                   using a j x' A_B.Fun_comp
<                   by (metis A.comp_cod_arr A_B.Fun_comp \<chi>'.A.map_simp \<chi>'.is_natural_2
---
>                 also have "... = A_B.Map (\<chi>' (J.cod j)) (A.cod a) \<cdot>\<^sub>B A_B.Map x' a"
>                   using a j x' A_B.Map_comp
>                   by (metis (no_types, lifting) A.comp_cod_arr \<chi>'.A.map_simp \<chi>'.is_natural_2
5179c5204
<                 also have "... = at (A.cod a) \<chi>' (J.cod j) \<cdot>\<^sub>B A_B.Fun x' a"
---
>                 also have "... = at (A.cod a) \<chi>' (J.cod j) \<cdot>\<^sub>B A_B.Map x' a"
5181c5206
<                 also have "... = at (A.cod a) \<chi>' j \<cdot>\<^sub>B A_B.Fun x' a"
---
>                 also have "... = at (A.cod a) \<chi>' j \<cdot>\<^sub>B A_B.Map x' a"
5204,5205c5229,5230
<                 interpret \<kappa>: cone J B "at (A.cod a) D" ?x'_dom_a
<                                   "D_cod_a.cones_map ?f_dom_a Dao\<chi>_dom_a.map"
---
>                 interpret \<kappa>: cone J B \<open>at (A.cod a) D\<close> ?x'_dom_a
>                                   \<open>D_cod_a.cones_map ?f_dom_a Dao\<chi>_dom_a.map\<close>
5284c5309
<                     "D_cod_a.cones (B.cod (A_B.Fun x a)) = D_cod_a.cones (A_B.Fun x (A.cod a))"
---
>                     "D_cod_a.cones (B.cod (A_B.Map x a)) = D_cod_a.cones (A_B.Map x (A.cod a))"
5311c5336
<           let ?f = "A_B.mkArr (\<lambda>a. A_B.Fun x' a) (\<lambda>a. A_B.Fun x a) \<phi>.map"
---
>           let ?f = "A_B.MkArr (\<lambda>a. A_B.Map x' a) (\<lambda>a. A_B.Map x a) \<phi>.map"
5315,5319c5340,5344
<               using x' x A_B.arr_mkArr \<phi>.natural_transformation_axioms by simp
<             moreover have "A_B.mkIde (\<lambda>a. A_B.Fun x a) = x"
<               using x A_B.ide_char A_B.mkArr_Fun A_B.in_homE A_B.ide_in_hom by metis
<             moreover have "A_B.mkIde (\<lambda>a. A_B.Fun x' a) = x'"
<               using x' A_B.ide_char A_B.mkArr_Fun A_B.in_homE A_B.ide_in_hom by metis
---
>               using x' x A_B.arr_MkArr \<phi>.natural_transformation_axioms by simp
>             moreover have "A_B.MkIde (\<lambda>a. A_B.Map x a) = x"
>               using x A_B.ide_char A_B.MkArr_Map A_B.in_homE A_B.ide_in_hom by metis
>             moreover have "A_B.MkIde (\<lambda>a. A_B.Map x' a) = x'"
>               using x' A_B.ide_char A_B.MkArr_Map A_B.in_homE A_B.ide_in_hom by metis
5323,5324c5348,5349
<           have Fun_f: "\<And>a. A.ide a \<Longrightarrow> A_B.Fun ?f a = (THE fa. ?P a fa)"
<             using f_in_hom \<phi>.map_simp_ide A_B.Fun_mkArr by fastforce
---
>           have Fun_f: "\<And>a. A.ide a \<Longrightarrow> A_B.Map ?f a = (THE fa. ?P a fa)"
>             using f_in_hom \<phi>.map_simp_ide by fastforce
5335c5360
<                            diagram.cones_map J B (at a D) (A_B.Fun f' a) (at a \<chi>) = at a \<chi>'"
---
>                            diagram.cones_map J B (at a D) (A_B.Map f' a) (at a \<chi>) = at a \<chi>'"
5337,5338c5362,5363
<             have "f' = A_B.mkArr (A_B.Dom f') (A_B.Cod f') (A_B.Fun f')"
<               using f' A_B.mkArr_Fun by auto
---
>             have "f' = A_B.MkArr (A_B.Dom f') (A_B.Cod f') (A_B.Map f')"
>               using f' A_B.MkArr_Map by auto
5340,5341c5365,5366
<             proof
<               show "A_B.arr (A_B.mkArr (A_B.Dom f') (A_B.Cod f') (A_B.Fun f'))"
---
>             proof (intro A_B.MkArr_eqI)
>               show "A_B.arr (A_B.MkArr (A_B.Dom f') (A_B.Cod f') (A_B.Map f'))"
5343,5345c5368,5370
<               show 1: "A_B.Dom f' = A_B.Fun x'" using f' A_B.Fun_dom by auto
<               show 2: "A_B.Cod f' = A_B.Fun x" using f' A_B.Fun_cod by auto
<               show "A_B.Fun f' = \<phi>.map"
---
>               show 1: "A_B.Dom f' = A_B.Map x'" using f' A_B.Map_dom by auto
>               show 2: "A_B.Cod f' = A_B.Map x" using f' A_B.Map_cod by auto
>               show "A_B.Map f' = \<phi>.map"
5347,5348c5372,5373
<                 show "natural_transformation A B (A_B.Fun x') (A_B.Fun x) \<phi>.map" ..
<                 show "natural_transformation A B (A_B.Fun x') (A_B.Fun x) (A_B.Fun f')"
---
>                 show "natural_transformation A B (A_B.Map x') (A_B.Map x) \<phi>.map" ..
>                 show "natural_transformation A B (A_B.Map x') (A_B.Map x) (A_B.Map f')"
5350c5375
<                 show "\<And>a. A.ide a \<Longrightarrow> A_B.Fun f' a = \<phi>.map a"
---
>                 show "\<And>a. A.ide a \<Longrightarrow> A_B.Map f' a = \<phi>.map a"
5354,5356c5379,5381
<                   interpret Da: diagram J B "at a D" using a at_ide_is_diagram by auto
<                   interpret Fun_f': natural_transformation A B "A_B.Dom f'" "A_B.Cod f'"
<                                                            "A_B.Fun f'"
---
>                   interpret Da: diagram J B \<open>at a D\<close> using a at_ide_is_diagram by auto
>                   interpret Fun_f': natural_transformation A B \<open>A_B.Dom f'\<close> \<open>A_B.Cod f'\<close>
>                                                            \<open>A_B.Map f'\<close>
5358c5383
<                   have "A_B.Fun f' a \<in> B.hom (A_B.Fun x' a) (A_B.Fun x a)"
---
>                   have "A_B.Map f' a \<in> B.hom (A_B.Map x' a) (A_B.Map x a)"
5360c5385
<                   hence "?P a (A_B.Fun f' a)" using a 0 [of a] by simp
---
>                   hence "?P a (A_B.Map f' a)" using a 0 [of a] by simp
5363c5388
<                   ultimately show "A_B.Fun f' a = \<phi>.map a" using a EU by blast
---
>                   ultimately show "A_B.Map f' a = \<phi>.map a" using a EU by blast
5407c5432
<           interpret Da: diagram J B "D.at a D"
---
>           interpret Da: diagram J B \<open>D.at a D\<close>
5419c5444
<           interpret "functor" JxA.comp B "Curry.uncurry D"
---
>           interpret "functor" JxA.comp B \<open>Curry.uncurry D\<close>
5421c5446
<           interpret binary_functor J A B "Curry.uncurry D" ..
---
>           interpret binary_functor J A B \<open>Curry.uncurry D\<close> ..
5424c5449
<         interpret uncurry_D: parametrized_diagram J A B "Curry.uncurry D" ..
---
>         interpret uncurry_D: parametrized_diagram J A B \<open>Curry.uncurry D\<close> ..
5471c5496
<         interpret \<chi>': transformation_by_components JxA.comp B ?L' "Curry.uncurry D" ?\<chi>'
---
>         interpret \<chi>': transformation_by_components JxA.comp B ?L' \<open>Curry.uncurry D\<close> ?\<chi>'
5477c5502
<           interpret \<chi>a: limit_cone J B "D.at ?a D" "?l ?a" "?\<chi> ?a"
---
>           interpret \<chi>a: limit_cone J B \<open>D.at ?a D\<close> \<open>?l ?a\<close> \<open>?\<chi> ?a\<close>
5488c5513
<           interpret D_dom_a: diagram J B "D.at (A.dom ?a) D"
---
>           interpret D_dom_a: diagram J B \<open>D.at (A.dom ?a) D\<close>
5490c5515
<           interpret D_cod_a: diagram J B "D.at (A.cod ?a) D"
---
>           interpret D_cod_a: diagram J B \<open>D.at (A.cod ?a) D\<close>
5492,5493c5517,5518
<           interpret Da: natural_transformation J B "D.at (A.dom ?a) D" "D.at (A.cod ?a) D"
<                                                    "D.at ?a D"
---
>           interpret Da: natural_transformation J B \<open>D.at (A.dom ?a) D\<close> \<open>D.at (A.cod ?a) D\<close>
>                                                    \<open>D.at ?a D\<close>
5495c5520
<           interpret \<chi>_dom_a: limit_cone J B "D.at (A.dom ?a) D" "?l (A.dom ?a)" "?\<chi> (A.dom ?a)"
---
>           interpret \<chi>_dom_a: limit_cone J B \<open>D.at (A.dom ?a) D\<close> \<open>?l (A.dom ?a)\<close> \<open>?\<chi> (A.dom ?a)\<close>
5497c5522
<           interpret \<chi>_cod_a: limit_cone J B "D.at (A.cod ?a) D" "?l (A.cod ?a)" "?\<chi> (A.cod ?a)"
---
>           interpret \<chi>_cod_a: limit_cone J B \<open>D.at (A.cod ?a) D\<close> \<open>?l (A.cod ?a)\<close> \<open>?\<chi> (A.cod ?a)\<close>
5500,5502c5525,5527
<                                   \<chi>_dom_a.A.map "D.at (A.dom ?a) D" "D.at (A.cod ?a) D"
<                                   "?\<chi> (A.dom ?a)" "D.at ?a D" ..
<           interpret Dao\<chi>_dom_a: cone J B "D.at (A.cod ?a) D" "?l (A.dom ?a)" Dao\<chi>_dom_a.map ..
---
>                                   \<chi>_dom_a.A.map \<open>D.at (A.dom ?a) D\<close> \<open>D.at (A.cod ?a) D\<close>
>                                   \<open>?\<chi> (A.dom ?a)\<close> \<open>D.at ?a D\<close> ..
>           interpret Dao\<chi>_dom_a: cone J B \<open>D.at (A.cod ?a) D\<close> \<open>?l (A.dom ?a)\<close> Dao\<chi>_dom_a.map ..
5527c5552
<                       Fun (D (J.cod ?j)) ?a \<cdot>\<^sub>B Fun (D ?j) (A.dom ?a)"
---
>                       Map (D (J.cod ?j)) ?a \<cdot>\<^sub>B Map (D ?j) (A.dom ?a)"
5529,5531c5554,5557
<               also have "... = Fun (D (J.cod ?j) \<cdot> D ?j) (?a \<cdot>\<^sub>A A.dom ?a)"
<                 using ja Fun_comp D.preserves_hom
<                 by (metis A.comp_arr_dom D.is_natural_2 D.preserves_arr Fun_comp a j)
---
>               also have "... = Map (comp (D (J.cod ?j)) (D ?j)) (?a \<cdot>\<^sub>A A.dom ?a)"
>                 using ja Map_comp D.preserves_hom
>                 by (metis (mono_tags, lifting) A.comp_arr_dom D.natural_transformation_axioms
>                     D.preserves_arr a j natural_transformation.is_natural_2)
5533c5559
<                 using ja D.at_simp dom_simp A.comp_arr_dom by force
---
>                 using ja D.at_simp dom_char A.comp_arr_dom by force
5544c5570
<        interpret constL: constant_functor J comp "mkIde ?L"
---
>        interpret constL: constant_functor J comp \<open>MkIde ?L\<close>
5546,5547c5572,5574
<          show "ide (mkIde ?L)"
<            using L.natural_transformation_axioms mkArr_in_hom ide_in_hom by blast
---
>          show "ide (MkIde ?L)"
>            using L.natural_transformation_axioms MkArr_in_hom ide_in_hom L.functor_axioms
>            by blast
5560,5562c5587,5589
<              have "constL.map j = mkIde ?L" using j constL.map_simp by simp
<              moreover have "... = mkArr ?L ?L ?L" by simp
<              moreover have "... = mkArr (\<lambda>a. ?L' (J.dom j, a)) (\<lambda>a. ?L' (J.cod j, a))
---
>              have "constL.map j = MkIde ?L" using j constL.map_simp by simp
>              moreover have "... = MkArr ?L ?L ?L" by simp
>              moreover have "... = MkArr (\<lambda>a. ?L' (J.dom j, a)) (\<lambda>a. ?L' (J.cod j, a))
5564c5591
<                using j constL.value_is_ide in_homE ide_in_hom by (intro mkArr_eqI, auto)
---
>                using j constL.value_is_ide in_homE ide_in_hom by (intro MkArr_eqI, auto)
5575c5602
<                              "Curry.curry ?L' (Curry.uncurry D) \<chi>'.map"
---
>                              \<open>Curry.curry ?L' (Curry.uncurry D) \<chi>'.map\<close>
5585c5612
<        interpret curry_\<chi>': cone J comp D "mkIde ?L" "Curry.curry ?L' (Curry.uncurry D) \<chi>'.map" ..
---
>        interpret curry_\<chi>': cone J comp D \<open>MkIde ?L\<close> \<open>Curry.curry ?L' (Curry.uncurry D) \<chi>'.map\<close> ..
5601,5602c5628,5629
<            interpret \<chi>a: limit_cone J B "D.at a D" "?l a" "?\<chi> a" using a l\<chi> by simp
<            interpret \<chi>': binary_functor_transformation J A B ?L' "Curry.uncurry D" \<chi>'.map ..
---
>            interpret \<chi>a: limit_cone J B \<open>D.at a D\<close> \<open>?l a\<close> \<open>?\<chi> a\<close> using a l\<chi> by simp
>            interpret \<chi>': binary_functor_transformation J A B ?L' \<open>Curry.uncurry D\<close> \<chi>'.map ..
5621c5648
<        hence "limit_cone J comp D (mkIde ?L) (Curry.curry ?L' (Curry.uncurry D) \<chi>'.map)"
---
>        hence "limit_cone J comp D (MkIde ?L) (Curry.curry ?L' (Curry.uncurry D) \<chi>'.map)"
5623c5650
<          have "\<And>a. A.ide a \<Longrightarrow> Fun (mkIde ?L) a = ?l a"
---
>          have "\<And>a. A.ide a \<Longrightarrow> Map (MkIde ?L) a = ?l a"
5667c5694
<       interpret YoD: diagram J Cop_S.comp "map o D"
---
>       interpret YoD: diagram J Cop_S.comp \<open>map o D\<close>
5669,5670c5696,5697
<       interpret YoD: diagram_in_functor_category Cop.comp S J "map o D" ..
<       interpret Yo\<chi>: cone J Cop_S.comp "map o D" "map a" "map o \<chi>"
---
>       interpret YoD: diagram_in_functor_category Cop.comp S J \<open>map o D\<close> ..
>       interpret Yo\<chi>: cone J Cop_S.comp \<open>map o D\<close> \<open>map a\<close> \<open>map o \<chi>\<close>
5674c5701
<                                   (Cop_S.Fun (map a) a') (YoD.at a' (map o \<chi>))"
---
>                                   (Cop_S.Map (map a) a') (YoD.at a' (map o \<chi>))"
5680c5707
<         interpret YoD_a': diagram J S "YoD.at a' (map o D)"
---
>         interpret YoD_a': diagram J S \<open>YoD.at a' (map o D)\<close>
5682,5683c5709,5710
<         interpret Yo\<chi>_a': cone J S "YoD.at a' (map o D)"
<                                    "Cop_S.Fun (map a) a'" "YoD.at a' (map o \<chi>)"
---
>         interpret Yo\<chi>_a': cone J S \<open>YoD.at a' (map o D)\<close>
>                                    \<open>Cop_S.Map (map a) a'\<close> \<open>YoD.at a' (map o \<chi>)\<close>
5689c5716
<           have "YoD.at a' (map \<circ> D) j = Cop_S.Fun (map (D j)) a'"
---
>           have "YoD.at a' (map \<circ> D) j = Cop_S.Map (map (D j)) a'"
5699c5726
<           have "YoD.at a' (map \<circ> \<chi>) j = Cop_S.Fun ((map o \<chi>) j) a'"
---
>           have "YoD.at a' (map \<circ> \<chi>) j = Cop_S.Map ((map o \<chi>) j) a'"
5705,5706c5732,5733
<         have Fun_map_a_a': "Cop_S.Fun (map a) a' = Hom.map (a', a)"
<           using a a' map_simp preserves_arr [of a] Cop_S.Fun_mkArr by simp
---
>         have Fun_map_a_a': "Cop_S.Map (map a) a' = Hom.map (a', a)"
>           using a a' map_simp preserves_arr [of a] by simp
5708c5735
<                              (Cop_S.Fun (map a) a') (YoD.at a' (map o \<chi>))"
---
>                              (Cop_S.Map (map a) a') (YoD.at a' (map o \<chi>))"
5712c5739
<           interpret \<sigma>: cone J S "YoD.at a' (map o D)" x \<sigma> using \<sigma> by auto
---
>           interpret \<sigma>: cone J S \<open>YoD.at a' (map o D)\<close> x \<sigma> using \<sigma> by auto
5828c5855
<                             "\<lambda>j. \<psi> (a', D j) (S.Fun (\<sigma> j) e)"
---
>                             \<open>\<lambda>j. \<psi> (a', D j) (S.Fun (\<sigma> j) e)\<close>
5851c5878
<             interpret \<kappa>e: cone J C D a' "?\<kappa> e" using e cone_\<kappa>e by simp
---
>             interpret \<kappa>e: cone J C D a' \<open>?\<kappa> e\<close> using e cone_\<kappa>e by simp
5865c5892
<             have 1: "S.cod ?f = Cop_S.Fun (map a) a'"
---
>             have 1: "S.cod ?f = Cop_S.Map (map a) a'"
5867,5868c5894,5895
<             interpret YoD_a'of: cone J S "YoD.at a' (map o D)" x
<                                      "YoD_a'.cones_map ?f (YoD.at a' (map o \<chi>))"
---
>             interpret YoD_a'of: cone J S \<open>YoD.at a' (map o D)\<close> x
>                                      \<open>YoD_a'.cones_map ?f (YoD.at a' (map o \<chi>))\<close>
5871c5898
<                 using a a' f Yo\<chi>_a'.cone_axioms Cop_S.Fun_mkArr preserves_arr [of a] by auto
---
>                 using a a' f Yo\<chi>_a'.cone_axioms preserves_arr [of a] by auto
5911c5938
<                                   "\<lambda>j. \<psi> (a', D j) (S.Fun (\<sigma> j) e)"
---
>                                   \<open>\<lambda>j. \<psi> (a', D j) (S.Fun (\<sigma> j) e)\<close>
5913c5940
<                   interpret \<kappa>e: cone J C D a' "?\<kappa> e" using e cone_\<kappa>e by simp
---
>                   interpret \<kappa>e: cone J C D a' \<open>?\<kappa> e\<close> using e cone_\<kappa>e by simp
5994c6021
<                   interpret \<chi>ofe: cone J C D a' "D.cones_map (\<psi> (a', a) (S.Fun ?f e)) \<chi>"
---
>                   interpret \<chi>ofe: cone J C D a' \<open>D.cones_map (\<psi> (a', a) (S.Fun ?f e)) \<chi>\<close>
6132c6159
<           thus "\<exists>!f. \<guillemotleft>f : x \<rightarrow>\<^sub>S Cop_S.Fun (map a) a'\<guillemotright> \<and>
---
>           thus "\<exists>!f. \<guillemotleft>f : x \<rightarrow>\<^sub>S Cop_S.Map (map a) a'\<guillemotright> \<and>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/NaturalTransformation.thy ../../AFPs/afp-2020/thys/Category3/NaturalTransformation.thy
209c209,210
<       using is_extensional B.comp_arr_dom B.comp_cod_arr by (unfold_locales, simp_all)
---
>       using is_extensional B.comp_arr_dom B.comp_cod_arr
>       by (unfold_locales, simp_all)
355,357c356,357
<       by (meson assms functor_is_transformation natural_transformation.axioms(1)
<                 natural_transformation.axioms(2) natural_transformation.axioms(3)
<                 natural_transformation.axioms(4) vertical_composite.intro)
---
>       by (meson assms functor_is_transformation natural_transformation.axioms(1-4)
>                 vertical_composite.intro)
375,377c375,376
<       by (meson assms functor_is_transformation natural_transformation.axioms(1)
<                 natural_transformation.axioms(2) natural_transformation.axioms(3)
<                 natural_transformation.axioms(4) vertical_composite.intro)
---
>       by (meson assms functor_is_transformation natural_transformation.axioms(1-4)
>                 vertical_composite.intro)
380c379
<             Go\<tau>.map_simp_ide [of a] Go\<tau>.B.comp_cod_arr
---
>             Go\<tau>.map_simp_ide Go\<tau>.B.comp_cod_arr
408,410c407,408
<       apply (intro eqI, simp_all)
<       using \<rho>\<sigma>.map_simp_ide \<rho>\<sigma>_\<tau>.map_simp_ide \<rho>_\<sigma>\<tau>.map_simp_ide \<sigma>\<tau>.map_simp_ide B.comp_assoc
<       by force
---
>             \<rho>\<sigma>.map_simp_ide \<rho>\<sigma>_\<tau>.map_simp_ide \<rho>_\<sigma>\<tau>.map_simp_ide \<sigma>\<tau>.map_simp_ide B.comp_assoc
>       by (intro eqI, auto)
490,498c488,490
<           proof -
<             have "\<phi>.B.seq (\<phi> a) (F f')"
<               using a f' by (metis \<phi>.A.in_homE \<phi>.is_natural_2 \<phi>.preserves_reflects_arr)
<             moreover have "G f' \<cdot>\<^sub>B \<phi> a' = \<phi> a \<cdot>\<^sub>B F f'"
<               using a a' f' \<phi>.naturality [of f'] by force
<             ultimately show ?thesis
<               using a a' f' \<phi>.components_are_iso \<phi>.B.invert_side_of_triangle(2)
<               by (metis \<phi>.B.comp_assoc)
<           qed
---
>             using a a' f' \<phi>.naturality [of f'] \<phi>.components_are_iso \<phi>.is_natural_2
>             by (metis \<phi>.A.in_homE \<phi>.B.comp_assoc \<phi>.B.invert_side_of_triangle(2)
>                 \<phi>.preserves_reflects_arr)
502c494
<             using a a' g \<phi>.B.comp_arr_dom \<phi>.B.comp_cod_arr \<phi>.B.comp_arr_inv \<phi>.B.comp_inv_arr
---
>             using a a' g \<phi>.B.comp_arr_dom \<phi>.B.comp_cod_arr \<phi>.B.comp_arr_inv
523,526d514
<     write A (infixr "\<cdot>\<^sub>A" 55)
<     write B (infixr "\<cdot>\<^sub>B" 55)
<     write \<phi>.A.in_hom ("\<guillemotleft>_ : _ \<rightarrow>\<^sub>A _\<guillemotright>")
<     write \<phi>.B.in_hom ("\<guillemotleft>_ : _ \<rightarrow>\<^sub>B _\<guillemotright>")
528,542c516,519
<     proof
<       fix \<mu> \<mu>'
<       assume par: "\<phi>.A.par \<mu> \<mu>'" and eq: "G \<mu> = G \<mu>'"
<       show "\<mu> = \<mu>'"
<       proof -
<         have "\<phi> (\<phi>.A.cod \<mu>) \<cdot>\<^sub>B F \<mu> = \<phi> (\<phi>.A.cod \<mu>) \<cdot>\<^sub>B F \<mu>'"
<           using par eq \<phi>.naturality by metis
<         moreover have "\<phi>.B.mono (\<phi> (\<phi>.A.cod \<mu>))"
<           using par \<phi>.components_are_iso \<phi>.B.iso_is_section \<phi>.B.section_is_mono by auto
<         ultimately have "F \<mu> = F \<mu>'"
<           using par \<phi>.B.monoE [of "\<phi> (\<phi>.A.cod \<mu>)" "F \<mu>" "F \<mu>'"] by auto
<         thus "\<mu> = \<mu>'"
<           using par \<phi>.F.is_faithful by blast
<       qed
<     qed
---
>       using \<phi>.naturality \<phi>.components_are_iso \<phi>.B.iso_is_section \<phi>.B.section_is_mono
>             \<phi>.B.monoE \<phi>.F.is_faithful \<phi>.is_natural_1 \<phi>.natural_transformation_axioms
>             \<phi>.preserves_reflects_arr \<phi>.A.ide_cod
>       by (unfold_locales, metis)
558c535
<     interpretation \<tau>': transformation_by_components A B G F "\<lambda>a. B.inv (\<tau> a)"
---
>     interpretation \<tau>': transformation_by_components A B G F \<open>\<lambda>a. B.inv (\<tau> a)\<close>
597,599c574,575
<     by (meson B.category_axioms B.iso_def category.inverse_arrows_sym inverts_components
<               natural_isomorphism.intro natural_isomorphism_axioms.intro
<               natural_transformation_axioms)
---
>     by (simp add: B.iso_inv_iso natural_isomorphism.intro natural_isomorphism_axioms.intro
>         natural_transformation_axioms)
655,656c631,632
<       apply (intro eqI, simp_all)
<       by (auto simp add: \<sigma>\<sigma>'.map_simp_ide inv.B.comp_inv_arr inv.inv)
---
>             \<sigma>\<sigma>'.map_simp_ide inv.B.comp_inv_arr inv.inv
>       by (intro eqI, simp_all)
662,663c638,639
<       apply (intro eqI, simp_all)
<       by (auto simp add: \<sigma>'\<sigma>.map_simp_ide inv'.inv inv.B.comp_inv_arr)
---
>             \<sigma>'\<sigma>.map_simp_ide inv'.inv inv.B.comp_inv_arr
>       by (intro eqI, simp_all)
669,670c645,646
<   shows "inverse_transformations A B F H (vertical_composite.map A B \<sigma> \<tau>)
<                                          (vertical_composite.map A B \<tau>' \<sigma>')"
---
>   shows "inverse_transformations A B F H
>            (vertical_composite.map A B \<sigma> \<tau>) (vertical_composite.map A B \<tau>' \<sigma>')"
692,693c668,669
<       apply (intro eqI, simp_all)
<       by (auto simp add: \<tau>.B.comp_inv_arr \<tau>\<tau>'.map_simp_ide)
---
>             \<tau>.B.comp_inv_arr \<tau>\<tau>'.map_simp_ide
>       by (intro eqI, auto)
705,706c681,682
<             \<tau>'\<tau>.map_simp_ide
<       apply (intro eqI, auto) by fastforce
---
>             \<tau>'\<tau>.map_simp_ide \<tau>.B.comp_arr_inv
>       by (intro eqI, auto)
747c723
<   lemma naturally_isomorphic_transitive:
---
>   lemma naturally_isomorphic_transitive [trans]:
775,831d750
< \<close>
< 
<   locale horizontal_composite =
<     A: category A +
<     B: category B +
<     C: category C +
<     F: "functor" A B F +
<     G: "functor" A B G +
<     H: "functor" B C H +
<     K: "functor" B C K +
<     \<sigma>: natural_transformation A B F G \<sigma> +
<     \<tau>: natural_transformation B C H K \<tau>
<   for A :: "'a comp"      (infixr "\<cdot>\<^sub>A" 55)
<   and B :: "'b comp"      (infixr "\<cdot>\<^sub>B" 55)
<   and C :: "'c comp"      (infixr "\<cdot>\<^sub>C" 55)
<   and F :: "'a \<Rightarrow> 'b"
<   and G :: "'a \<Rightarrow> 'b"
<   and H :: "'b \<Rightarrow> 'c"
<   and K :: "'b \<Rightarrow> 'c"
<   and \<sigma> :: "'a \<Rightarrow> 'b"
<   and \<tau> :: "'b \<Rightarrow> 'c"
<   begin
< 
<     no_notation C.in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
<     notation C.in_hom ("\<guillemotleft>_ : _ \<rightarrow>\<^sub>C _\<guillemotright>") 
< 
<     abbreviation map
<     where "map \<equiv> \<tau> o \<sigma>"
< 
<     lemma is_natural_transformation:
<     shows "natural_transformation A C (H o F) (K o G) map"
<     proof -
<       interpret HF: composite_functor A B C F H ..
<       interpret KG: composite_functor A B C G K ..
<       show "natural_transformation A C (H o F) (K o G) (\<tau> o \<sigma>)"
<         using \<sigma>.is_extensional \<tau>.is_extensional
<         apply (unfold_locales, auto)
<          apply (metis \<sigma>.is_natural_1 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_1)
<         by (metis \<sigma>.is_natural_2 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_2)
<     qed
< 
<   end
< 
<   sublocale horizontal_composite \<subseteq> natural_transformation A C "H o F" "K o G" "\<tau> o \<sigma>"
<     using is_natural_transformation by auto
< 
<   context horizontal_composite
<   begin
< 
<     interpretation KF: composite_functor A B C F K ..
<     interpretation HG: composite_functor A B C G H ..
<     interpretation \<tau>F: horizontal_composite A B C F F H K F \<tau> ..
<     interpretation \<tau>G: horizontal_composite A B C G G H K G \<tau> ..
<     interpretation H\<sigma>: horizontal_composite A B C F G H H \<sigma> H ..
<     interpretation K\<sigma>: horizontal_composite A B C F G K K \<sigma> K ..
<     interpretation K\<sigma>_\<tau>F: vertical_composite A C "H o F" "K o F" "K o G" "\<tau> o F" "K o \<sigma>" ..
<     interpretation \<tau>G_H\<sigma>: vertical_composite A C "H o F" "H o G" "K o G" "H o \<sigma>" "\<tau> o G" ..
833,845c752,755
<     lemma map_simp_1:
<     assumes "A.arr f"
<     shows "(\<tau> o \<sigma>) f = K\<sigma>_\<tau>F.map f"
<       using assms
<       by (metis K\<sigma>_\<tau>F.map_simp_1 \<sigma>.is_natural_2 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_1
<                 comp_apply)
< 
<     lemma map_simp_2:
<     assumes "A.arr f"
<     shows "(\<tau> o \<sigma>) f = \<tau>G_H\<sigma>.map f"
<       using assms
<       by (metis \<sigma>.is_natural_1 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_2 \<tau>G_H\<sigma>.map_simp_2
<                 comp_apply)
---
>     Since horizontal composition turns out to coincide with ordinary composition of
>     natural transformations as functions, there is little point in defining a cumbersome
>     locale for horizontal composite.
> \<close>
847c757,773
<   end
---
>   lemma horizontal_composite:
>   assumes "natural_transformation A B F G \<sigma>"
>   and "natural_transformation B C H K \<tau>"
>   shows "natural_transformation A C (H o F) (K o G) (\<tau> o \<sigma>)"
>   proof -
>     interpret \<sigma>: natural_transformation A B F G \<sigma>
>       using assms(1) by simp
>     interpret \<tau>: natural_transformation B C H K \<tau>
>       using assms(2) by simp
>     interpret HF: composite_functor A B C F H ..
>     interpret KG: composite_functor A B C G K ..
>     show "natural_transformation A C (H o F) (K o G) (\<tau> o \<sigma>)"
>       using \<sigma>.is_extensional \<tau>.is_extensional
>       apply (unfold_locales, auto)
>        apply (metis \<sigma>.is_natural_1 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_1)
>       by (metis \<sigma>.is_natural_2 \<sigma>.preserves_reflects_arr \<tau>.preserves_comp_2)
>   qed
871c797
<   lemma hcomp_functor_vcomp:
---
>   lemma whisker_right:
873,874c799
<   and "natural_transformation B C H K \<tau>"
<   and "natural_transformation B C K L \<tau>'"
---
>   and "natural_transformation B C H K \<tau>" and "natural_transformation B C K L \<tau>'"
880,887c805,818
<     interpret HF: composite_functor A B C F H ..
<     interpret KF: composite_functor A B C F K ..
<     interpret LF: composite_functor A B C F L ..
<     interpret \<tau>F: horizontal_composite A B C F F H K F \<tau> ..
<     interpret \<tau>'F: horizontal_composite A B C F F K L F \<tau>' ..
<     interpret \<tau>'o\<tau>: vertical_composite B C H K L \<tau> \<tau>' ..
<     interpret \<tau>'o\<tau>_F: horizontal_composite A B C F F H L F \<tau>'o\<tau>.map ..
<     interpret \<tau>'Fo\<tau>F: vertical_composite A C "H o F" "K o F" "L o F" "\<tau> o F" "\<tau>' o F" ..
---
>     interpret \<tau>oF: natural_transformation A C \<open>H o F\<close> \<open>K o F\<close> \<open>\<tau> o F\<close>
>       using \<tau>.natural_transformation_axioms F.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<tau>'oF: natural_transformation A C \<open>K o F\<close> \<open>L o F\<close> \<open>\<tau>' o F\<close>
>       using \<tau>'.natural_transformation_axioms F.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<tau>'\<tau>: vertical_composite B C H K L \<tau> \<tau>' ..
>     interpret \<tau>'\<tau>oF: natural_transformation A C \<open>H o F\<close> \<open>L o F\<close> \<open>\<tau>'\<tau>.map o F\<close>
>       using \<tau>'\<tau>.natural_transformation_axioms F.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<tau>'oF_\<tau>oF: vertical_composite A C \<open>H o F\<close> \<open>K o F\<close> \<open>L o F\<close> \<open>\<tau> o F\<close> \<open>\<tau>' o F\<close> ..
889c820
<       using \<tau>'Fo\<tau>F.map_def \<tau>'o\<tau>.map_def \<tau>'o\<tau>_F.is_extensional by auto
---
>       using \<tau>'oF_\<tau>oF.map_def \<tau>'\<tau>.map_def \<tau>'\<tau>oF.is_extensional by auto
896c827
<   lemma hcomp_vcomp_functor:
---
>   lemma whisker_left:
898,899c829
<   and "natural_transformation A B F G \<tau>"
<   and "natural_transformation A B G H \<tau>'"
---
>   and "natural_transformation A B F G \<tau>" and "natural_transformation A B G H \<tau>'"
905,914c835,850
<     interpret KF: composite_functor A B C F K ..
<     interpret KG: composite_functor A B C G K ..
<     interpret KH: composite_functor A B C H K ..
<     interpret \<tau>'o\<tau>: vertical_composite A B F G H \<tau> \<tau>' ..
<     interpret K\<tau>: horizontal_composite A B C F G K K \<tau> K ..
<     interpret K\<tau>': horizontal_composite A B C G H K K \<tau>' K ..
<     interpret K_\<tau>'o\<tau>: horizontal_composite A B C F H K K \<tau>'o\<tau>.map K ..
<     interpret K\<tau>'oK\<tau>: vertical_composite A C "K o F" "K o G" "K o H" "K o \<tau>" "K o \<tau>'" ..
<     show "K o \<tau>'o\<tau>.map = K\<tau>'oK\<tau>.map"
<       using K\<tau>'oK\<tau>.map_def \<tau>'o\<tau>.map_def K_\<tau>'o\<tau>.is_extensional K\<tau>'oK\<tau>.map_simp_1 \<tau>'o\<tau>.map_simp_1
---
>     interpret \<tau>'\<tau>: vertical_composite A B F G H \<tau> \<tau>' ..
>     interpret Ko\<tau>: natural_transformation A C \<open>K o F\<close> \<open>K o G\<close> \<open>K o \<tau>\<close>
>       using \<tau>.natural_transformation_axioms K.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret Ko\<tau>': natural_transformation A C \<open>K o G\<close> \<open>K o H\<close> \<open>K o \<tau>'\<close>
>       using \<tau>'.natural_transformation_axioms K.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret Ko\<tau>'\<tau>: natural_transformation A C \<open>K o F\<close> \<open>K o H\<close> \<open>K o \<tau>'\<tau>.map\<close>
>       using \<tau>'\<tau>.natural_transformation_axioms K.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret Ko\<tau>'_Ko\<tau>: vertical_composite A C \<open>K o F\<close> \<open>K o G\<close> \<open>K o H\<close> \<open>K o \<tau>\<close> \<open>K o \<tau>'\<close> ..
>     show "K o \<tau>'\<tau>.map = Ko\<tau>'_Ko\<tau>.map"
>       using Ko\<tau>'_Ko\<tau>.map_def \<tau>'\<tau>.map_def Ko\<tau>'\<tau>.is_extensional Ko\<tau>'_Ko\<tau>.map_simp_1 \<tau>'\<tau>.map_simp_1
923,926c859,862
<   assumes "natural_transformation B C F G \<sigma>"
<   and "natural_transformation C D H K \<tau>"
<   shows "horizontal_composite.map \<sigma> \<tau> = vertical_composite.map B D (H o \<sigma>) (\<tau> o G)"
<   and "horizontal_composite.map \<sigma> \<tau> = vertical_composite.map B D (\<tau> o F) (K o \<sigma>)"
---
>   assumes "natural_transformation B C F G \<tau>" and "natural_transformation B C G H \<nu>"
>   and "natural_transformation C D K L \<sigma>" and "natural_transformation C D L M \<mu>"
>   shows "vertical_composite.map C D \<sigma> \<mu> \<circ> vertical_composite.map B C \<tau> \<nu> =
>          vertical_composite.map B D (\<sigma> \<circ> \<tau>) (\<mu> \<circ> \<nu>)"
928c864
<     interpret \<sigma>: natural_transformation B C F G \<sigma>
---
>     interpret \<tau>: natural_transformation B C F G \<tau>
930c866
<     interpret \<tau>: natural_transformation C D H K \<tau>
---
>     interpret \<nu>: natural_transformation B C G H \<nu>
932,944c868,934
<     interpret \<tau>\<sigma>: horizontal_composite B C D F G H K \<sigma> \<tau> ..
<     interpret H\<sigma>: horizontal_composite B C D F G H H \<sigma> H ..
<     interpret K\<sigma>: horizontal_composite B C D F G K K \<sigma> K ..
<     interpret \<tau>G: horizontal_composite B C D G G H K G \<tau> ..
<     interpret \<tau>F: horizontal_composite B C D F F H K F \<tau> ..
<     interpret \<tau>GoH\<sigma>: vertical_composite B D "H o F" "H o G" "K o G" "H o \<sigma>" "\<tau> o G" ..
<     interpret K\<sigma>o\<tau>F: vertical_composite B D "H o F" "K o F" "K o G" "\<tau> o F" "K o \<sigma>" ..
<     show "\<tau>\<sigma>.map = \<tau>GoH\<sigma>.map"
<       using \<tau>\<sigma>.map_simp_2 \<tau>\<sigma>.natural_transformation_axioms \<tau>GoH\<sigma>.natural_transformation_axioms
<       by (intro eqI, auto)
<     show "\<tau>\<sigma>.map = K\<sigma>o\<tau>F.map"
<       using \<tau>\<sigma>.map_simp_1 \<tau>\<sigma>.natural_transformation_axioms K\<sigma>o\<tau>F.natural_transformation_axioms
<       by (intro eqI, auto)
---
>     interpret \<sigma>: natural_transformation C D K L \<sigma>
>        using assms(3) by auto
>     interpret \<mu>: natural_transformation C D L M \<mu>
>        using assms(4) by auto
>     interpret \<nu>\<tau>: vertical_composite B C F G H \<tau> \<nu> ..
>     interpret \<mu>\<sigma>: vertical_composite C D K L M \<sigma> \<mu> ..
>     interpret \<sigma>o\<tau>: natural_transformation B D \<open>K o F\<close> \<open>L o G\<close> \<open>\<sigma> o \<tau>\<close>
>       using \<sigma>.natural_transformation_axioms \<tau>.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<mu>o\<nu>: natural_transformation B D \<open>L o G\<close> \<open>M o H\<close> \<open>\<mu> o \<nu>\<close>
>       using \<mu>.natural_transformation_axioms \<nu>.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<mu>\<sigma>o\<nu>\<tau>: natural_transformation B D \<open>K o F\<close> \<open>M o H\<close> \<open>\<mu>\<sigma>.map o \<nu>\<tau>.map\<close>
>       using \<mu>\<sigma>.natural_transformation_axioms \<nu>\<tau>.natural_transformation_axioms
>             horizontal_composite
>       by blast
>     interpret \<mu>o\<nu>_\<sigma>o\<tau>: vertical_composite B D \<open>K o F\<close> \<open>L o G\<close> \<open>M o H\<close> \<open>\<sigma> o \<tau>\<close> \<open>\<mu> o \<nu>\<close> ..
>     show "\<mu>\<sigma>.map o \<nu>\<tau>.map = \<mu>o\<nu>_\<sigma>o\<tau>.map"
>     proof (intro eqI)
>       show "natural_transformation B D (K \<circ> F) (M \<circ> H) (\<mu>\<sigma>.map o \<nu>\<tau>.map)" ..
>       show "natural_transformation B D (K \<circ> F) (M \<circ> H) \<mu>o\<nu>_\<sigma>o\<tau>.map" ..
>       show "\<And>a. \<tau>.A.ide a \<Longrightarrow> (\<mu>\<sigma>.map o \<nu>\<tau>.map) a = \<mu>o\<nu>_\<sigma>o\<tau>.map a"
>       proof -
>         fix a
>         assume a: "\<tau>.A.ide a"
>         have "(\<mu>\<sigma>.map o \<nu>\<tau>.map) a = D (\<mu> (H a)) (\<sigma> (C (\<nu> a) (\<tau> a)))"
>           using a \<mu>\<sigma>.map_simp_1 \<nu>\<tau>.map_simp_2 by simp
>         also have "... = D (\<mu> (\<nu> a)) (\<sigma> (\<tau> a))"
>           using a
>           by (metis (full_types) \<mu>.is_natural_1 \<mu>\<sigma>.map_simp_1 \<mu>\<sigma>.preserves_comp_1
>               \<nu>\<tau>.map_seq \<nu>\<tau>.map_simp_1 \<nu>\<tau>.preserves_cod \<sigma>.B.comp_assoc \<tau>.A.ide_char \<tau>.B.seqE)
>         also have "... = \<mu>o\<nu>_\<sigma>o\<tau>.map a"
>           using a \<mu>o\<nu>_\<sigma>o\<tau>.map_simp_ide by simp
>         finally show "(\<mu>\<sigma>.map o \<nu>\<tau>.map) a = \<mu>o\<nu>_\<sigma>o\<tau>.map a" by blast
>       qed
>     qed
>   qed
> 
>   text\<open>
>     A special-case of the interchange law in which two of the natural transformations
>     are functors.  It comes up reasonably often, and the reasoning is awkward.
> \<close>
> 
>   lemma interchange_spc:
>   assumes "natural_transformation B C F G \<sigma>"
>   and "natural_transformation C D H K \<tau>"
>   shows "\<tau> \<circ> \<sigma> = vertical_composite.map B D (H o \<sigma>) (\<tau> o G)"
>   and "\<tau> \<circ> \<sigma> = vertical_composite.map B D (\<tau> o F) (K o \<sigma>)"
>   proof -
>     show "\<tau> \<circ> \<sigma> = vertical_composite.map B D (H \<circ> \<sigma>) (\<tau> \<circ> G)"
>     proof -
>       have "vertical_composite.map C D H \<tau> \<circ> vertical_composite.map B C \<sigma> G =
>             vertical_composite.map B D (H \<circ> \<sigma>) (\<tau> \<circ> G)"
>         by (meson assms functor_is_transformation interchange natural_transformation.axioms(3-4))
>       thus ?thesis
>         using assms by force
>     qed
>     show "\<tau> \<circ> \<sigma> = vertical_composite.map B D (\<tau> \<circ> F) (K \<circ> \<sigma>)"
>     proof -
>       have "vertical_composite.map C D \<tau> K \<circ> vertical_composite.map B C F \<sigma> =
>             vertical_composite.map B D (\<tau> \<circ> F) (K \<circ> \<sigma>)"
>         by (meson assms functor_is_transformation interchange natural_transformation.axioms(3-4))
>       thus ?thesis
>         using assms by force
>     qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/ProductCategory.thy ../../AFPs/afp-2020/thys/Category3/ProductCategory.thy
22,23d21
<   type_synonym ('a1, 'a2) arr = "'a1 * 'a2"
< 
30a29,30
>     type_synonym ('aa1, 'aa2) arr = "'aa1 * 'aa2"
> 
183c183
<         using comp_def null_char seq_char C1.comp_assoc C2.comp_assoc comp_assoc
---
>         using comp_def null_char seq_char C1.comp_assoc C2.comp_assoc
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/SetCategory.thy ../../AFPs/afp-2020/thys/Category3/SetCategory.thy
45a46
>       \sloppypar
48c49
<       @{theory "HOL-Library.FuncSet"} did not provide results about restriction in the form that was
---
>       that theory did not provide results about restriction in the form that was
704c705
<     notation S'.in_hom    ("\<guillemotleft>_ : _ \<rightarrow>' _\<guillemotright>")
---
>     notation S'.in_hom    ("\<guillemotleft>_ : _ \<rightarrow>'' _\<guillemotright>")
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/SetCat.thy ../../AFPs/afp-2020/thys/Category3/SetCat.thy
9c9
< imports SetCategory AbstractedCategory
---
> imports SetCategory ConcreteCategory
14,31c14,17
<     a particular concrete construction of an interpretation for it.  Although the
<     construction used here is probably the first one that would come to mind
<     (arrows are defined as triples @{term "(F, (A, B))"} where @{term A} and @{term B}
<     are sets and @{term F} is an extensional function from @{term A} to @{term B}),
<     there is nothing particularly unique or special about it.
<     Because of this, we don't want clients of this theory to have implicit dependencies
<     on the specific details of the construction we use.  We therefore go to some
<     trouble to hide these details behind an opaque arrow type and export only the
<     definitions and facts that are made explicit in the \<open>set_category\<close> locale.
< \<close>
< 
<   text\<open>
<     We first define a locale \<open>setcat\<close> that gives the details of the particular
<     construction of ``the category of @{typ 'a}-sets and functions between them''.
<     We use a locale so that we can later interpret it once in a local context,
<     prove the main fact, which is that we thereby obtain an interpretation of the
<     \<open>set_category\<close> locale, and leave no other permanent vestiges of it
<     in this theory.
---
>     a particular concrete construction of an interpretation for it.
>     Applying the general construction given by @{locale concrete_category},
>     we define arrows to be terms \<open>MkArr A B F\<close>, where \<open>A\<close> and \<open>B\<close> are sets
>     and \<open>F\<close> is an extensional function that maps \<open>A\<close> to \<open>B\<close>.
37,155c23
<     text\<open>
<       We represent an arrow as a tuple @{term "(F, (A, B))"}, where @{term A} and
<       @{term B} are @{typ 'a}-sets and @{term "(F :: 'a \<Rightarrow> 'a) \<in> extensional A \<inter> (A \<rightarrow> B)"}.
<       Since in HOL every type is inhabited, we can avoid using option types here
<       by letting @{term "(\<lambda>x. x, ({undefined}, {}))"} serve as the null element of
<       the arrow type.  This term can never denote an arrow, because the set
<       @{term "{undefined} \<rightarrow> {}"} is empty at any type.
< \<close>
< 
<     type_synonym 'a arr = "('a \<Rightarrow> 'a) * 'a set * 'a set"
< 
<     abbreviation Null :: "'a arr"
<     where "Null \<equiv> (\<lambda>x. x, ({undefined}, {}))"
<   
<     abbreviation MkArr :: "'a set => 'a set => ('a \<Rightarrow> 'a) \<Rightarrow> 'a arr"
<     where "MkArr A B F \<equiv> (restrict F A, (A, B))"
<   
<     abbreviation Dom :: "'a arr \<Rightarrow> 'a set"
<     where "Dom f \<equiv> fst (snd f)"
< 
<     abbreviation Cod :: "'a arr \<Rightarrow> 'a set"
<     where "Cod f \<equiv> snd (snd f)"
< 
<     abbreviation Fun :: "'a arr \<Rightarrow> 'a \<Rightarrow> 'a"
<     where "Fun f \<equiv> fst f"
< 
<     definition Id :: "'a set \<Rightarrow> 'a arr"
<     where "Id A \<equiv> (\<lambda>x \<in> A. x, (A, A))"
< 
<     (*
<      * I attempted to use here the notion A \<rightarrow>\<^sub>E B ("extensional_funcset") defined
<      * in FuncSet, but it seems that the rules provided for reasoning directly about
<      * it are somewhat weak.  So for the moment I am just using the following
<      * longer definition, which caused me less trouble.
<      *)
<     definition Arr :: "'a arr \<Rightarrow> bool"
<     where "Arr f \<equiv> Fun f \<in> extensional (Dom f) \<inter> (Dom f \<rightarrow> Cod f)"
< 
<     (*
<      * Similarly, it is not clear that there is much to be gained from using
<      * "FuncSet.compose A G F" rather than the more basic "restrict (G o F) A".
<      * However, the differences were not that significant, so I went with the
<      * former.
<      *)
<     definition comp :: "'a arr \<Rightarrow> 'a arr \<Rightarrow> 'a arr"      (infixr "\<cdot>" 55)
<     where "g \<cdot> f = (if Arr f \<and> Arr g \<and> Cod f = Dom g then
<                       (compose (Dom f) (Fun g) (Fun f), (Dom f, Cod g))
<                     else Null)"
< 
<     text\<open>
<       Our first objective is to develop just enough properties of the preceding
<       definitions to show that they yield a category.
< \<close>
< 
<     lemma Arr_Id:
<     shows "Arr (Id A)"
<       unfolding Id_def Arr_def by force
< 
<     lemma Dom_Id:
<     shows "Dom (Id A) = A"
<       by (simp add: Id_def)
< 
<     lemma Cod_Id:
<     shows "Cod (Id A) = A"
<       by (simp add: Id_def)
< 
<     lemma comp_Id_Dom:
<     assumes "Arr f"
<     shows "f \<cdot> Id (Dom f) = f"
<     proof -
<       have "\<And>F A. F \<in> extensional A \<Longrightarrow> compose A F (\<lambda>x \<in> A. x) = F"
<         using compose_extensional extensional_arb by fastforce
<       thus ?thesis
<         using assms Arr_Id Id_def comp_def
<         by (metis (no_types, lifting) Arr_def Cod_Id Dom_Id IntD1 prod.collapse prod.sel(1))
<     qed
< 
<     lemma comp_Cod_Id:
<     assumes "Arr f"
<     shows "Id (Cod f) \<cdot> f = f"
<     proof -
<       have 1: "Fun f \<in> Dom f \<rightarrow> Cod f"
<         by (metis (no_types) Arr_def IntD2 assms)
<       have 2: "Fun (Id (Cod f)) = (\<lambda>x \<in> Cod f. x) \<and> snd (Id (Cod f)) = (Cod f, Cod f)"
<         by (simp add: Id_def)
<       hence "compose (Dom f) (Fun (Id (Cod f))) (Fun f) = Fun f"
<         using 1 by (metis (no_types) Arr_def Id_compose IntD1 assms)
<       then show ?thesis
<         using 2 by (simp add: Arr_Id assms comp_def)
<     qed
< 
<     lemma Arr_comp:
<     assumes "Arr f" and "Arr g" and "Cod f = Dom g"
<     shows "Arr (g \<cdot> f)"
<     proof -
<       have "\<forall>x. x \<in> Dom g \<longrightarrow> Fun g x \<in> Cod g"
<         using assms(2) Arr_def by fast
<       moreover have "\<forall>x. x \<in> Dom f \<longrightarrow> Fun f x \<in> Cod f"
<         using assms(1) Arr_def by fast
<       moreover have "g \<cdot> f = (compose (Dom f) (Fun g) (Fun f), Dom f, Cod g)"
<         by (simp add: assms(1-3) comp_def)
<       ultimately show ?thesis by (simp add: Arr_def assms(3))
<     qed
< 
<     lemma not_Arr_Null:
<     shows "\<not>Arr Null"
<       by (simp add: Arr_def)
< 
<     interpretation partial_magma comp
<     proof
<       show "\<exists>!n. \<forall>f. n \<cdot> f = n \<and> f \<cdot> n = n"
<       proof
<         let ?P = "\<lambda>n. \<forall>f. n \<cdot> f = n \<and> f \<cdot> n = n"
<         show 1: "?P Null" using comp_def not_Arr_Null by metis
<         thus "\<And>n. \<forall>f. n \<cdot> f = n \<and> f \<cdot> n = n \<Longrightarrow> n = Null" by metis
<       qed
<     qed
< 
<     notation in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
---
>     type_synonym 'aa arr = "('aa set, 'aa \<Rightarrow> 'aa) concrete_category.arr"
157,159c25,35
<     lemma null_char:
<     shows "null = Null"
<       using comp_def not_Arr_Null ex_un_null by (metis comp_null(2))
---
>     interpretation concrete_category \<open>UNIV :: 'a set set\<close> \<open>\<lambda>A B. extensional A \<inter> (A \<rightarrow> B)\<close>
>       \<open>\<lambda>A. \<lambda>x \<in> A. x\<close> \<open>\<lambda>C B A g f. compose A g f\<close>
>       using compose_Id Id_compose
>       apply unfold_locales
>           apply auto[3]
>        apply blast
>       by (metis IntD2 compose_assoc)
> 
>     abbreviation Comp      (infixr "\<cdot>" 55)
>     where "Comp \<equiv> COMP"
>     notation in_hom        ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
161,276c37
<     lemma ide_Id:
<     shows "ide (Id A)"
<     proof -
<       have "Id A \<cdot> Id A = Id A"
<         unfolding comp_def apply (auto simp add: Arr_Id Dom_Id Cod_Id)
<         unfolding Id_def by auto
<       moreover have "\<And>f. f \<cdot> Id A \<noteq> null \<Longrightarrow> f \<cdot> Id A = f"
<         by (metis Cod_Id comp_Id_Dom comp_def null_char)
<       moreover have "\<And>f. Id A \<cdot> f \<noteq> null \<Longrightarrow> Id A \<cdot> f = f"
<         by (metis Dom_Id comp_Cod_Id comp_def null_char)
<       ultimately show ?thesis
<         unfolding ide_def
<         using null_char not_Arr_Null Arr_Id by metis
<     qed
< 
<     lemma has_domain_char:
<     shows "Arr f \<Longrightarrow> Id (Dom f) \<in> domains f"
<     and "domains f \<noteq> {} \<Longrightarrow> Arr f"
<     proof -
<       assume f: "domains f \<noteq> {}"
<       obtain x where x: "x \<in> domains f"
<         using f by blast
<       have "f \<cdot> x \<noteq> null"
<         using x by (simp add: domains_def)
<       thus "Arr f"
<         using comp_def null_char by metis
<       next
<       assume f: "Arr f"
<       have "f \<noteq> null"
<         by (metis f not_Arr_Null null_char)
<       hence "Id (Dom f) \<in> {p. ide p \<and> comp f p \<noteq> null}"
<         by (simp add: f comp_Id_Dom ide_Id)
<       thus "Id (Dom f) \<in> domains f"
<         using domains_def by blast
<     qed
< 
<     lemma has_codomain_char:
<     shows "Arr f \<Longrightarrow> Id (Cod f) \<in> codomains f"
<     and "codomains f \<noteq> {} \<Longrightarrow> Arr f"
<     proof -
<       assume f: "codomains f \<noteq> {}"
<       obtain x where x: "x \<in> codomains f"
<         using f by blast
<       have "x \<cdot> f \<noteq> null"
<         using x by (simp add: codomains_def)
<       thus "Arr f"
<         using comp_def null_char by metis
<       next
<       assume f: "Arr f"
<       have "f \<noteq> null"
<         by (metis f not_Arr_Null null_char)
<       hence "Id (Cod f) \<in> {p. ide p \<and> comp p f \<noteq> null}"
<         by (simp add: f comp_Cod_Id ide_Id)
<       thus "Id (Cod f) \<in> codomains f"
<         using codomains_def by blast
<     qed
< 
<     lemma arr_char:
<     shows "arr f \<longleftrightarrow> Arr f"
<       using has_domain_char has_codomain_char arr_def by blast
< 
<     lemma comp_assoc:
<     assumes "g \<cdot> f \<noteq> null" and "h \<cdot> g \<noteq> null"
<     shows "h \<cdot> g \<cdot> f = (h \<cdot> g) \<cdot> f"
<     proof -
<       have 1: "Arr f \<and> Arr g \<and> Cod f = Dom g"
<         using assms(1) comp_def null_char by metis
<       have 2: "Arr g \<and> Arr h \<and> Cod g = Dom h"
<         using assms(2) comp_def null_char by metis
<       have 3: "Arr (comp g f) \<and>
<                comp g f = (compose (Dom f) (Fun g) (Fun f), (Dom f, Cod g))"
<         using 1 comp_def Arr_comp by metis
<       have 4: "Arr (comp h g) \<and>
<                comp h g = (compose (Dom g) (Fun h) (Fun g), (Dom g, Cod h))"
<         using 2 comp_def Arr_comp by metis
<       have "h \<cdot> g \<cdot> f =
<             (compose (Dom f) (Fun h) (compose (Dom f) (Fun g) (Fun f)), (Dom f, Cod h))"
<         using 1 2 3 comp_def by (metis (no_types, lifting) fst_conv snd_conv)
<       also have
<           "... = (compose (Dom f) (compose (Dom g) (Fun h) (Fun g)) (Fun f), (Dom f, Cod h))"
<         using 1 2 unfolding Arr_def using compose_assoc by fastforce
<       also have "... = (h \<cdot> g) \<cdot> f"
<         using 1 2 4 comp_def by (metis (no_types) fst_conv snd_conv)
<       finally show ?thesis by auto
<     qed
< 
<     theorem is_category:
<     shows "category comp"
<     proof
<       fix f g h :: "'a arr"
<       show "g \<cdot> f \<noteq> null \<Longrightarrow> seq g f"
<         using null_char comp_def Arr_comp arr_char by metis
<       show "(domains f \<noteq> {}) = (codomains f \<noteq> {})"
<         using has_domain_char has_codomain_char by blast
<       show "seq h g \<Longrightarrow> seq (h \<cdot> g) f \<Longrightarrow> seq g f"
<         using Arr_comp arr_char comp_def [of h g] comp_def [of g f] comp_def [of "comp h g" f]
<         by (metis fst_conv snd_conv)
<       show "seq h (g \<cdot> f) \<Longrightarrow> seq g f \<Longrightarrow> seq h g"
<         using Arr_comp arr_char comp_def [of h g] comp_def [of g f] comp_def [of h "comp g f"]
<         by (metis snd_conv)
<       show "seq g f \<Longrightarrow> seq h g \<Longrightarrow> seq (h \<cdot> g) f"
<         using Arr_comp arr_char comp_def [of h g] comp_def [of g f] comp_def [of "comp h g" f]
<         by (metis fst_conv snd_conv)
<       show "seq g f \<Longrightarrow> seq h g \<Longrightarrow> (h \<cdot> g) \<cdot> f = h \<cdot> g \<cdot> f"
<         using comp_assoc not_arr_null by metis
<     qed
< 
<     interpretation category comp
<       using is_category by auto
< 
<     text\<open>
<       Next, we obtain characterizations of the basic notions of the \<open>category\<close>
<       locale in terms of the concrete structure.
< \<close>
< 
<     lemma dom_simp:
---
>     lemma MkArr_expansion:
278,307c39,51
<     shows "dom f = Id (Dom f)"
<       using assms has_domain_char domain_unique dom_in_domains has_domain_iff_arr
<       by blast
< 
<     lemma cod_simp:
<     assumes "arr f"
<     shows "cod f = Id (Cod f)"
<       using assms has_codomain_char codomain_unique cod_in_codomains has_codomain_iff_arr
<       by blast
< 
<     lemma dom_char:
<     shows "dom f = (if arr f then (\<lambda>x \<in> Dom f. x, (Dom f, Dom f)) else null)"
<       using Id_def dom_simp has_domain_iff_arr dom_def by metis
<   
<     lemma cod_char:
<     shows "cod f = (if arr f then (\<lambda>x \<in> Cod f. x, (Cod f, Cod f)) else null)"
<       using Id_def cod_simp has_codomain_iff_arr cod_def by metis
< 
<     lemma ide_char:
<     shows "ide a \<longleftrightarrow> Dom a = Cod a \<and> Fun a = (\<lambda>x \<in> Dom a. x)"
<       using dom_char in_homE [of a a a] arr_char dom_char ide_dom Arr_Id Id_def ide_in_hom
<       by (metis fst_conv snd_conv prod.collapse)
< 
<     lemma seq_char:
<     shows "seq g f \<longleftrightarrow> Arr f \<and> Arr g \<and> Cod f = Dom g"
<     proof -
<       have "seq g f \<longrightarrow> snd (snd f) = fst (snd g)"
<         by (metis not_arr_null comp_def null_char)
<       thus ?thesis
<         using arr_char dom_char cod_char seqI seqE by metis
---
>     shows "f = MkArr (Dom f) (Cod f) (\<lambda>x \<in> Dom f. Map f x)"
>     proof (intro arr_eqI)
>       show "arr f" by fact
>       show "arr (MkArr (Dom f) (Cod f) (\<lambda>x \<in> Dom f. Map f x))"
>         using assms arr_char
>         by (metis (mono_tags, lifting) Int_iff MkArr_Map extensional_restrict)
>       show "Dom f = Dom (MkArr (Dom f) (Cod f) (\<lambda>x \<in> Dom f. Map f x))"
>         by simp
>       show "Cod f = Cod (MkArr (Dom f) (Cod f) (\<lambda>x \<in> Dom f. Map f x))"
>         by simp
>       show "Map f = Map (MkArr (Dom f) (Cod f) (\<lambda>x \<in> Dom f. Map f x))"
>         using assms arr_char
>         by (metis (mono_tags, lifting) Int_iff MkArr_Map extensional_restrict)
309,469d52
<     
<     lemma comp_char:
<     shows "g \<cdot> f = (if seq g f then
<                       (compose (Dom f) (Fun g) (Fun f), (Dom f, Cod g))
<                     else Null)"
<       using seq_char comp_def null_char by metis
<    
<   end
< 
<   sublocale setcat \<subseteq> category comp
<     using is_category by auto
< 
<   text\<open>
<     Now we want to apply the preceding construction to obtain an actual interpretation
<     of the \<open>set_category\<close> locale that hides the concrete details of the construction.
<     To do this, we first import the preceding construction into a local context,
<     then define an opaque new arrow type for the arrows, and lift just enough
<     of the properties of the concrete construction to the abstract setting to make
<     it possible to prove that the abstracted category interprets the \<open>set_category\<close>
<     locale.  We can then forget about everything except the \<open>set_category\<close> axioms.
<     All of this is done within a local context to avoid making any global interpretations.
<     Everything except what we ultimately want to export is declared ``private''.
< \<close>
< 
<   context begin
< 
<     interpretation SC: setcat .
<     no_notation SC.comp      (infixr "\<cdot>" 55)
< 
<     typedef 'a arr = "UNIV :: (('a \<Rightarrow> 'a) * ('a set * 'a set)) set" ..
< 
<     interpretation AC: abstracted_category SC.comp Abs_arr Rep_arr UNIV
<       using Rep_arr_inverse Abs_arr_inverse by (unfold_locales, auto)
< 
<     definition comp
<     where "comp \<equiv> AC.comp"
< 
<     lemma is_category:
<     shows "category comp"
<       using comp_def AC.category_axioms by metis
< 
<     interpretation category comp using is_category by auto
< 
<     notation comp      (infixr "\<cdot>" 55)
<     notation in_hom    ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
< 
<     text\<open>
<       To be able to accomplish anything with the category we just defined,
<       we have to lift a certain amount of the features of the concrete structure
<       through the abstraction.
< \<close>
< 
<     private definition MkArr
<     where "MkArr A B F \<equiv> Abs_arr (restrict F A, (A, B))"
< 
<     private abbreviation Id
<     where "Id A \<equiv> MkArr A A id"
<   
<     private definition Dom
<     where "Dom f \<equiv> SC.Dom (Rep_arr f)"
< 
<     private definition Cod
<     where "Cod f \<equiv> SC.Cod (Rep_arr f)"
< 
<     private definition Fun
<     where "Fun f \<equiv> SC.Fun (Rep_arr f)"
< 
<     private lemma Dom_MkArr [simp]:
<     shows "Dom (MkArr A B F) = A"
<       using Dom_def MkArr_def by (metis AC.rep_abs UNIV_I fst_conv snd_conv)
< 
<     private lemma Cod_MkArr [simp]:
<     shows "Cod (MkArr A B F) = B"
<       using Cod_def MkArr_def by (metis AC.rep_abs UNIV_I snd_conv)
< 
<     private lemma Fun_MkArr [simp]:
<     shows "Fun (MkArr A B F) = restrict F A"
<       using Fun_def MkArr_def by (metis AC.rep_abs UNIV_I fst_conv)
< 
<     private lemma null_char:
<     shows "null = Abs_arr SC.Null"
<       using comp_def by (metis AC.null_char SC.null_char)
< 
<     private lemma arr_char:
<     shows "arr f \<longleftrightarrow> Fun f \<in> extensional (Dom f) \<inter> (Dom f \<rightarrow> Cod f)"
<       using comp_def AC.arr_char SC.arr_char SC.Arr_def Dom_def Cod_def Fun_def by metis
< 
<     private lemma dom_char:
<     shows "dom f = (if arr f then MkArr (Dom f) (Dom f) id else null)"
<       using MkArr_def id_apply restrict_ext comp_def AC.dom_char AC.arr_char SC.dom_char
<             Dom_def
<       by metis
<    
<     private lemma cod_char:
<     shows "cod f = (if arr f then MkArr (Cod f) (Cod f) id else null)"
<       using MkArr_def id_apply restrict_ext comp_def AC.cod_char AC.arr_char SC.cod_char
<             Cod_def
<       by metis
< 
<     private lemma ide_char:
<     shows "ide f = (Dom f = Cod f \<and> Fun f = (\<lambda>x \<in> Dom f. x))"
<       using comp_def AC.ide_char SC.ide_char Dom_def Cod_def Fun_def by metis
< 
<     private lemma seq_char:
<     shows "seq g f = (arr f \<and> arr g \<and> Cod f = Dom g)"
<       using dom_char cod_char Dom_MkArr seqI seqE by metis
< 
<     private lemma comp_char:
<     shows "g \<cdot> f = (if seq g f then
<                       MkArr (Dom f) (Cod g) (compose (Dom f) (Fun g) (Fun f))
<                     else null)"
<     proof (cases "seq g f")
<       show "\<not>seq g f \<Longrightarrow> ?thesis"
<         using comp_def AC.comp_char by metis
<       show "seq g f \<Longrightarrow> ?thesis"
<       proof -
<         assume gf: "seq g f"
<         have "g \<cdot> f = Abs_arr (compose (Dom f) (Fun g) (Fun f), Dom f, Cod g)"
<           using gf
<           by (metis (no_types, lifting) AC.comp_char Cod_def Dom_def Fun_def
<               comp_def has_codomain_iff_arr null_char setcat.comp_def codomains_null)
<         also have "... = MkArr (Dom f) (Cod g) (compose (Dom f) (Fun g) (Fun f))"
<           using MkArr_def [of "Dom f" "Cod g" "compose (Dom f) (Fun g) (Fun f)"]
<                 compose_def
<           by simp
<         finally have "g \<cdot> f = MkArr (Dom f) (Cod g) (compose (Dom f) (Fun g) (Fun f))"
<           by auto
<         thus ?thesis using gf by auto
<       qed
<     qed
<    
<     private lemma arr_MkArr:
<     assumes "F \<in> A \<rightarrow> B"
<     shows "arr (MkArr A B F)"
<       using assms arr_char Fun_MkArr Dom_MkArr Cod_MkArr by force
< 
<     private lemma MkArr_Fun:
<     assumes "arr f"
<     shows "MkArr (Dom f) (Cod f) (Fun f) = f"
<       using assms arr_char MkArr_def Dom_def Cod_def Fun_def
<       by (metis AC.abs_rep IntD1 extensional_restrict prod.collapse)
< 
<     private lemma arr_eqI:
<     assumes "arr f" and "arr f'"
<     and "Dom f = Dom f'" and "Cod f = Cod f'" and "Fun f = Fun f'"
<     shows "f = f'"
<       using assms MkArr_Fun by metis
< 
<     private lemma ide_Id:
<     shows "ide (Id A)"
<       using ide_char Fun_MkArr Dom_MkArr Cod_MkArr id_apply restrict_ext by metis
< 
<     private lemma Id_Dom:
<     assumes "ide a"
<     shows "Id (Dom a) = a"
<       using assms dom_char ide_in_hom by (metis in_homE)
< 
<     private lemma Id_Cod:
<     assumes "ide a"
<     shows "Id (Cod a) = a"
<       using assms ide_char by (metis Id_Dom)
471,481c54,56
<     private lemma MkArr_in_hom:
<     assumes "F \<in> A \<rightarrow> B"
<     shows "\<guillemotleft>MkArr A B F : Id A \<rightarrow> Id B\<guillemotright>"
<     proof -
<       have 1: "arr (MkArr A B F)" using assms arr_MkArr by blast
<       moreover have "dom (MkArr A B F) = Id A"
<         using 1 dom_char Dom_MkArr by metis
<       moreover have "cod (MkArr A B F) = Id B"
<         using 1 cod_char Cod_MkArr by metis
<       ultimately show ?thesis by blast
<     qed
---
>     lemma arr_char:
>     shows "arr f \<longleftrightarrow> f \<noteq> Null \<and> Map f \<in> extensional (Dom f) \<inter> (Dom f \<rightarrow> Cod f)"
>       using arr_char by auto
483,484c58,59
<     private lemma terminal_char:
<     shows "terminal a \<longleftrightarrow> (\<exists>x. a = Id {x})"
---
>     lemma terminal_char:
>     shows "terminal a \<longleftrightarrow> (\<exists>x. a = MkIde {x})"
486c61
<       show "\<exists>x. a = Id {x} \<Longrightarrow> terminal a"
---
>       show "\<exists>x. a = MkIde {x} \<Longrightarrow> terminal a"
488,490c63,65
<         assume a: "\<exists>x. a = Id {x}"
<         from this obtain x where x: "a = Id {x}" by blast
<         have "terminal (Id {x})"
---
>         assume a: "\<exists>x. a = MkIde {x}"
>         from this obtain x where x: "a = MkIde {x}" by blast
>         have "terminal (MkIde {x})"
492,494c67,69
<           show 1: "ide (Id {x})"
<             using ide_Id by metis
<           show "\<And>a. ide a \<Longrightarrow> \<exists>!f. \<guillemotleft>f : a \<rightarrow> Id {x}\<guillemotright>"
---
>           show "ide (MkIde {x})"
>             using ide_MkIde by auto
>           show "\<And>a. ide a \<Longrightarrow> \<exists>!f. \<guillemotleft>f : a \<rightarrow> MkIde {x}\<guillemotright>"
496c71
<             fix a :: "'a arr"
---
>             fix a :: "'a setcat.arr"
498,502c73,78
<             show "\<guillemotleft>MkArr (Dom a) {x} (\<lambda>_\<in>Dom a. x) : a \<rightarrow> Id {x}\<guillemotright>"
<               using a Id_Dom MkArr_in_hom
<               by (metis restrictI singletonI)
<             fix f :: "'a arr"
<             assume f: "\<guillemotleft>f : a \<rightarrow> Id {x}\<guillemotright>"
---
>             show "\<guillemotleft>MkArr (Dom a) {x} (\<lambda>_\<in>Dom a. x) : a \<rightarrow> MkIde {x}\<guillemotright>"
>               using a MkArr_in_hom
>               by (metis (mono_tags, lifting) IntI MkIde_Dom' restrictI restrict_extensional
>                   singletonI UNIV_I)
>             fix f :: "'a setcat.arr"
>             assume f: "\<guillemotleft>f : a \<rightarrow> MkIde {x}\<guillemotright>"
505,507c81,83
<               have 2: "Dom f = Dom a \<and> Cod f = {x}"
<                 using a f Dom_MkArr dom_char cod_char in_homE by metis
<               moreover have "Fun f = (\<lambda>_ \<in> Dom a. x)"
---
>               have 1: "Dom f = Dom a \<and> Cod f = {x}"
>                 using a f by (metis (mono_tags, lifting) Dom.simps(1) in_hom_char)
>               moreover have "Map f = (\<lambda>_ \<in> Dom a. x)"
510,514c86,91
<                 have "z \<notin> Dom a \<Longrightarrow> Fun f z = (\<lambda>_ \<in> Dom a. x) z"
<                   by (metis f 2 Fun_MkArr MkArr_Fun in_homE restrict_def)
<                 moreover have "z \<in> Dom a \<Longrightarrow> Fun f z = (\<lambda>_ \<in> Dom a. x) z"
<                   using f 2 arr_char [of f] by auto
<                 ultimately show "Fun f z = (\<lambda>_ \<in> Dom a. x) z" by auto
---
>                 have "z \<notin> Dom a \<Longrightarrow> Map f z = (\<lambda>_ \<in> Dom a. x) z"
>                   using f 1 MkArr_expansion
>                   by (metis (mono_tags, lifting) Map.simps(1) in_homE restrict_apply)
>                 moreover have "z \<in> Dom a \<Longrightarrow> Map f z = (\<lambda>_ \<in> Dom a. x) z"
>                   using f 1 arr_char [of f] by fastforce
>                 ultimately show "Map f z = (\<lambda>_ \<in> Dom a. x) z" by auto
517c94
<                 using a f arr_eqI MkArr_Fun mem_Collect_eq by fastforce
---
>                using f MkArr_expansion [of f] by fastforce
523c100
<       show "terminal a \<Longrightarrow> \<exists>x. a = Id {x}"
---
>       show "terminal a \<Longrightarrow> \<exists>x. a = MkIde {x}"
532,537c109,120
<             hence 1: "a = Id {}" using \<open>ide a\<close> Id_Dom by force
<             have "\<And>f. f \<in> hom (Id {undefined}) (Id {}) \<Longrightarrow> Fun f \<in> {undefined} \<rightarrow> {}"
<               by (metis Cod_MkArr CollectD IntD2 arrI arr_char cod_char dom_char in_homE)
<             hence "hom (Id {undefined}) a = {}" using 1 by auto
<             moreover have "ide (Id {undefined})" using ide_Id by auto
<             ultimately show "\<not>terminal a" by auto
---
>             hence 1: "a = MkIde {}" using \<open>ide a\<close> MkIde_Dom' by force
>             have "\<And>f. f \<in> hom (MkIde {undefined}) (MkIde ({} :: 'a set))
>                          \<Longrightarrow> Map f \<in> {undefined} \<rightarrow> {}"
>             proof -
>               fix f
>               assume f: "f \<in> hom (MkIde {undefined}) (MkIde ({} :: 'a set))"
>               show "Map f \<in> {undefined} \<rightarrow> {}"
>                 using f MkArr_expansion arr_char [of f] in_hom_char  by auto
>             qed
>             hence "hom (MkIde {undefined}) a = {}" using 1 by auto
>             moreover have "ide (MkIde {undefined})" using ide_MkIde by auto
>             ultimately show "\<not>terminal a" by blast
543,548c126,129
<             have "\<guillemotleft>MkArr {undefined} (Dom a) (\<lambda>_. x) : Id {undefined} \<rightarrow> a\<guillemotright>"
<               using 1 MkArr_in_hom [of "\<lambda>_. x" "{undefined}" "Dom a"] Id_Dom [of a] \<open>ide a\<close>
<               by simp
<             moreover have "\<guillemotleft>MkArr {undefined} (Dom a) (\<lambda>_. x') : Id {undefined} \<rightarrow> a\<guillemotright>"
<               using 1 MkArr_in_hom [of "\<lambda>_. x'" "{undefined}" "Dom a"] Id_Dom [of a] \<open>ide a\<close>
<               by simp
---
>             have "\<guillemotleft>MkArr {undefined} (Dom a) (\<lambda>_ \<in> {undefined}. x) : MkIde {undefined} \<rightarrow> a\<guillemotright>"
>               using 1
>               by (metis (mono_tags, lifting) IntI MkIde_Dom' \<open>ide a\<close> restrictI
>                   restrict_extensional MkArr_in_hom UNIV_I)
550,551c131,137
<                 "MkArr {undefined} (Dom a) (\<lambda>_. x) \<noteq> MkArr {undefined} (Dom a) (\<lambda>_. x')"
<               using 1 Fun_MkArr restrict_apply by (metis singletonI)
---
>               "\<guillemotleft>MkArr {undefined} (Dom a) (\<lambda>_ \<in> {undefined}. x') : MkIde {undefined} \<rightarrow> a\<guillemotright>"
>               using 1
>               by (metis (mono_tags, lifting) IntI MkIde_Dom' \<open>ide a\<close> restrictI
>                   restrict_extensional MkArr_in_hom UNIV_I)
>             moreover have "MkArr {undefined} (Dom a) (\<lambda>_ \<in> {undefined}. x) \<noteq>
>                            MkArr {undefined} (Dom a) (\<lambda>_ \<in> {undefined}. x')"
>               using 1 by (metis arr.inject restrict_apply' singletonI)
553c139,140
<               using terminal_arr_unique by (metis arrI in_homE)
---
>               using terminal_arr_unique
>               by (metis (mono_tags, lifting) in_homE)
560,562c147,149
<         hence "a = Id {THE x. x \<in> Dom a}"
<           using a Id_Dom terminal_def by metis
<         thus "\<exists>x. a = Id {x}"
---
>         hence "a = MkIde {THE x. x \<in> Dom a}"
>           using a terminal_def by (metis (mono_tags, lifting) MkIde_Dom')
>         thus "\<exists>x. a = MkIde {x}"
567,568c154,155
<     private definition Img :: "'a arr \<Rightarrow> 'a arr"
<     where "Img f = Id (Fun f ` Dom f)"
---
>     definition Img :: "'a setcat.arr \<Rightarrow> 'a setcat.arr"
>     where "Img f = MkIde (Map f ` Dom f)"
570c157
<     interpretation set_category_data comp Img ..
---
>     interpretation set_category_data Comp Img ..
572c159
<     private lemma terminal_unity:
---
>     lemma terminal_unity:
574c161,162
<       using terminal_char unity_def someI_ex [of terminal] by metis
---
>       using terminal_char unity_def someI_ex [of terminal]
>       by (metis (mono_tags, lifting))
583,584c171,172
<     definition UP :: "'a \<Rightarrow> 'a arr"
<     where "UP x \<equiv> Id {x}"
---
>     definition UP :: "'a \<Rightarrow> 'a setcat.arr"
>     where "UP x \<equiv> MkIde {x}"
586c174
<     definition DOWN :: "'a arr \<Rightarrow> 'a"
---
>     definition DOWN :: "'a setcat.arr \<Rightarrow> 'a"
589c177
<     abbreviation U :: 'a
---
>     abbreviation U
608c196
<       by (metis CollectD Dom_MkArr the_elem_eq)
---
>       by (metis (mono_tags, lifting) mem_Collect_eq DOWN_UP)
617,619c205,207
<       interpret category comp using is_category by auto
<       show DOWN_UP: "\<And>x :: 'a. DOWN (UP x) = x" by auto
<       show UP_DOWN: "\<And>t. t \<in> Univ \<Longrightarrow> UP (DOWN t) = t" by auto
---
>       interpret category Comp using is_category by auto
>       show DOWN_UP: "\<And>x :: 'a. DOWN (UP x) = x" by simp
>       show UP_DOWN: "\<And>t. t \<in> Univ \<Longrightarrow> UP (DOWN t) = t" by simp
624c212
<     private lemma Dom_terminal:
---
>     lemma Dom_terminal:
627,628c215,216
<       using assms UP_DOWN UP_def
<       by (metis Dom_MkArr mem_Collect_eq)
---
>       using assms UP_def
>       by (metis (mono_tags, lifting) Dom.simps(1) DOWN_def terminal_char the_elem_eq)
635c223
<     private lemma Img_point:
---
>     lemma Img_point:
638c226
<     and "Img p = (UP o Fun p o DOWN) unity"
---
>     and "Img p = (UP o Map p o DOWN) unity"
642,658c230,253
<         fix x
<         assume x: "x \<in> hom unity a"
<         have "terminal (Id (Fun x ` Dom unity))"
<           using x terminal_char
<           by (metis (no_types, lifting) Dom_terminal image_empty image_insert terminal_unity)
<         hence "Id (Fun x ` Dom unity) \<in> Univ" by simp
<         moreover have "Id (Fun x ` Dom unity) = Img x"
<           using x dom_char Dom_MkArr Img_def in_homE by (metis CollectD)
<         ultimately show "Img x \<in> Univ" by auto
<       qed
<       have 1: "Dom p = Dom unity"
<         using assms dom_char Dom_MkArr by (metis in_homE)
<       have "Img p = Id (Fun p ` Dom p)" using Img_def by blast
<       also have "... = Id (Fun p ` {U})"
<         using 1 terminal_unity Dom_terminal by metis
<       also have "... = (UP o Fun p o DOWN) unity" by (simp add: UP_def)
<       finally show "Img p = (UP o Fun p o DOWN) unity" using assms by auto
---
>         fix f
>         assume f: "f \<in> hom unity a"
>         have "terminal (MkIde (Map f ` Dom unity))"
>         proof -
>           obtain u :: 'a where u: "unity = MkIde {u}"
>             using terminal_unity terminal_char
>             by (metis (mono_tags, lifting))
>           have "Map f ` Dom unity = {Map f u}"
>             using u by simp
>           thus ?thesis
>             using terminal_char by auto
>         qed
>         hence "MkIde (Map f ` Dom unity) \<in> Univ" by simp
>         moreover have "MkIde (Map f ` Dom unity) = Img f"
>           using f dom_char Img_def in_homE
>           by (metis (mono_tags, lifting) Dom.simps(1) mem_Collect_eq)
>         ultimately show "Img f \<in> Univ" by auto
>       qed
>       have "Img p = MkIde (Map p ` Dom p)" using Img_def by blast
>       also have "... = MkIde (Map p ` {U})"
>         using assms in_hom_char terminal_unity Dom_terminal
>         by (metis (mono_tags, lifting))
>       also have "... = (UP o Map p o DOWN) unity" by (simp add: UP_def)
>       finally show "Img p = (UP o Map p o DOWN) unity" using assms by auto
667c262
<     private abbreviation MkElem
---
>     abbreviation MkElem :: "'a setcat.arr => 'a setcat.arr => 'a setcat.arr"
670c265
<     private lemma MkElem_in_hom:
---
>     lemma MkElem_in_hom:
675,679c270,275
<         using assms dom_char [of f] by fastforce
<       moreover have "Id {U} = unity"
<         by (metis Dom_MkArr Dom_terminal terminal_char terminal_unity)
<       moreover have "Id (Dom (dom f)) = dom f"
<         using assms by (simp add: dom_char)
---
>         using assms dom_char [of f] by simp
>       moreover have "MkIde {U} = unity"
>         using terminal_char terminal_unity
>         by (metis (mono_tags, lifting) DOWN_UP UP_def)
>       moreover have "MkIde (Dom (dom f)) = dom f"
>         using assms dom_char MkIde_Dom' ide_dom by blast
681c277,278
<         using assms MkArr_in_hom [of "\<lambda>_ \<in> {U}. DOWN (UP x)" "{U}" "Dom (dom f)"] by metis
---
>         using assms MkArr_in_hom [of "{U}" "Dom (dom f)" "\<lambda>_ \<in> {U}. DOWN (UP x)"]
>         by (metis (mono_tags, lifting) IntI restrict_extensional UNIV_I)
684c281
<     private lemma MkElem_Img:
---
>     lemma MkElem_Img:
688c285
<       have 0: "Img p = UP (Fun p U)"
---
>       have 0: "Img p = UP (Map p U)"
691,692c288,289
<         using assms dom_char Dom_MkArr terminal_unity Dom_terminal
<         by (metis in_homE CollectD)
---
>         using assms terminal_unity Dom_terminal
>         by (metis (mono_tags, lifting) in_hom_char mem_Collect_eq)
694,695c291,293
<         using assms cod_char by (metis Dom_MkArr in_homE CollectD)
<       moreover have "Fun p = (\<lambda>_ \<in> {U}. DOWN (Img p))"
---
>         using assms
>         by (metis (mono_tags, lifting) in_hom_char mem_Collect_eq)
>       moreover have "Map p = (\<lambda>_ \<in> {U}. DOWN (Img p))"
698,700c296,304
<         show "Fun p e = (\<lambda>_ \<in> {U}. DOWN (Img p)) e"
<           using assms 0 1 Fun_MkArr MkArr_Fun in_homE
<           by (metis DOWN_UP restrict_apply singleton_iff CollectD)
---
>         show "Map p e = (\<lambda>_ \<in> {U}. DOWN (Img p)) e"
>         proof -
>           have "Map p e = (\<lambda>x \<in> Dom p. Map p x) e"
>             using assms MkArr_expansion [of p]
>             by (metis (mono_tags, lifting) CollectD Map.simps(1) in_homE)
>           also have "... = (\<lambda>_ \<in> {U}. DOWN (Img p)) e"
>             using assms 0 1 by simp
>           finally show ?thesis by blast
>         qed
703c307,308
<         using assms arr_eqI Dom_MkArr Cod_MkArr Fun_MkArr MkArr_Fun CollectD by fastforce
---
>         using assms MkArr_Map CollectD
>         by (metis (mono_tags, lifting) in_homE mem_Collect_eq)
706c311
<     private lemma inj_Img:
---
>     lemma inj_Img:
709c314,339
<       using assms MkElem_Img inj_onI [of "hom unity a" Img] by metis
---
>     proof (intro inj_onI)
>       fix x y
>       assume x: "x \<in> hom unity a"
>       assume y: "y \<in> hom unity a"
>       assume eq: "Img x = Img y"
>       show "x = y"
>       proof (intro arr_eqI)
>         show "arr x" using x by blast
>         show "arr y" using y by blast
>         show "Dom x = Dom y"
>           using x y in_hom_char by (metis (mono_tags, lifting) CollectD)
>         show "Cod x = Cod y"
>           using x y in_hom_char by (metis (mono_tags, lifting) CollectD)
>         show "Map x = Map y"
>         proof -
>           have "Map x = (\<lambda>z \<in> {U}. Map x z) \<and> Map y = (\<lambda>z \<in> {U}. Map y z)"
>             using x y \<open>arr x\<close> \<open>arr y\<close> Dom_terminal terminal_unity MkArr_expansion
>             by (metis (mono_tags, lifting) CollectD Map.simps(1) in_hom_char)
>           moreover have "Map x U = Map y U"
>             using x y eq
>             by (metis (mono_tags, lifting) CollectD Img_point(2) o_apply setcat.DOWN_UP)
>           ultimately show ?thesis
>             by (metis (mono_tags, lifting) restrict_ext singletonD)
>         qed
>       qed
>     qed
711c341
<     private lemma set_char:
---
>     lemma set_char:
721,723c351
<         have 1: "Dom p = Dom unity"
<           using p dom_char Dom_MkArr by (metis in_homE)
<         have "t = (UP o Fun p o DOWN) unity"
---
>         have "t = (UP o Map p o DOWN) unity"
725,727c353,355
<         moreover have "(Fun p o DOWN) unity \<in> Dom a"
<           using 1 p arr_char Dom_terminal terminal_unity cod_char
<           by (metis Dom_MkArr IntD2 PiE comp_apply in_homE singletonI)
---
>         moreover have "(Map p o DOWN) unity \<in> Dom a"
>           using p arr_char in_hom_char Dom_terminal terminal_unity
>           by (metis (mono_tags, lifting) IntD2 Pi_split_insert_domain o_apply)
737,738c365,369
<           using assms x MkElem_in_hom [of "dom a"] by auto
<         moreover have "Img ?p = t" using p x Img_point by force
---
>           using assms x MkElem_in_hom [of "dom a"] ideD(1-2) by force
>         moreover have "Img ?p = t"
>           using p x DOWN_UP
>           by (metis (no_types, lifting) Dom.simps(1) Map.simps(1) image_empty
>               image_insert image_restrict_eq setcat.Img_def UP_def)
743c374
<     private lemma Fun_via_comp:
---
>     lemma Map_via_comp:
745c376
<     shows "Fun f = restrict (\<lambda>x. Fun (comp f (MkElem (UP x) (dom f))) U) (Dom f)"
---
>     shows "Map f = (\<lambda>x \<in> Dom f. Map (f \<cdot> MkElem (UP x) (dom f)) U)"
748,749c379
<       have "x \<notin> Dom f \<Longrightarrow>
<               Fun f x = restrict (\<lambda>x. Fun (comp f (MkElem (UP x) (dom f))) U) (Dom f) x"
---
>       have "x \<notin> Dom f \<Longrightarrow> Map f x = (\<lambda>x \<in> Dom f. Map (f \<cdot> MkElem (UP x) (dom f)) U) x"
752,753c382
<            "x \<in> Dom f \<Longrightarrow>
<               Fun f x = restrict (\<lambda>x. Fun (comp f (MkElem (UP x) (dom f))) U) (Dom f) x"
---
>            "x \<in> Dom f \<Longrightarrow> Map f x = (\<lambda>x \<in> Dom f. Map (f \<cdot> MkElem (UP x) (dom f)) U) x"
756c385,386
<         have "\<guillemotleft>MkElem (UP x) (dom f) : unity \<rightarrow> dom f\<guillemotright>"
---
>         let ?X = "MkElem (UP x) (dom f)"
>         have "\<guillemotleft>?X : unity \<rightarrow> dom f\<guillemotright>"
758,762c388,393
<         hence "f \<cdot> MkElem (UP x) (dom f) =
<                MkArr {U} (Cod f) (compose {U} (Fun f) (\<lambda>_ \<in> {U}. x))"
<           using assms MkArr_Fun comp_char [of f "MkElem (UP x) (dom f)"] by auto
<         hence "Fun (f \<cdot> MkElem (UP x) (dom f)) = compose {U} (Fun f) (\<lambda>_ \<in> {U}. x)"
<            by (simp add: extensional_restrict)
---
>         moreover have "Dom ?X = {U} \<and> Map ?X = (\<lambda>_ \<in> {U}. x)"
>           using x by simp
>         ultimately have
> 	    "Map (f \<cdot> MkElem (UP x) (dom f)) = compose {U} (Map f) (\<lambda>_ \<in> {U}. x)"
>           using assms x Map_comp [of "MkElem (UP x) (dom f)" f]
>           by (metis (mono_tags, lifting) Cod.simps(1) Dom_dom arr_iff_in_hom seqE seqI')
766,767c397
<       ultimately show
<             "Fun f x = restrict (\<lambda>x. Fun (f \<cdot> MkElem (UP x) (dom f)) U) (Dom f) x"
---
>       ultimately show "Map f x = (\<lambda>x \<in> Dom f. Map (f \<cdot> MkElem (UP x) (dom f)) U) x"
769a400,419
> 
>     lemma arr_eqI':
>     assumes "par f f'" and "\<And>t. \<guillemotleft>t : unity \<rightarrow> dom f\<guillemotright> \<Longrightarrow> f \<cdot> t = f' \<cdot> t"
>     shows "f = f'"
>     proof (intro arr_eqI)
>       show "arr f" using assms by simp
>       show "arr f'" using assms by simp
>       show "Dom f = Dom f'"
>         using assms by (metis (mono_tags, lifting) Dom_dom)
>       show "Cod f = Cod f'"
>         using assms by (metis (mono_tags, lifting) Cod_cod)
>       show "Map f = Map f'"
>       proof
>         have 1: "\<And>x. x \<in> Dom f \<Longrightarrow> \<guillemotleft>MkElem (UP x) (dom f) : unity \<rightarrow> dom f\<guillemotright>"
>           using MkElem_in_hom by (metis (mono_tags, lifting) assms(1))
>         fix x
>         show "Map f x = Map f' x"
>           using assms 1 \<open>Dom f = Dom f'\<close> by (simp add: Map_via_comp)
>       qed
>     qed
777c427
<     shows "set_category comp"
---
>     shows "set_category Comp"
779c429
<       show "\<exists>img :: 'a arr \<Rightarrow> 'a arr. set_category_given_img comp img"
---
>       show "\<exists>img :: 'a setcat.arr \<Rightarrow> 'a setcat.arr. set_category_given_img Comp img"
781c431
<         show "set_category_given_img (comp :: 'a arr comp) Img"
---
>         show "set_category_given_img (Comp :: 'a setcat.arr comp) Img"
784c434
<           fix a :: "'a arr"
---
>           fix a :: "'a setcat.arr"
789c439
<           fix t :: "'a arr"
---
>           fix t :: "'a setcat.arr"
793,794c443,448
<             have "UP ` Dom t = {t}" using t Dom_terminal [of t] UP_DOWN by simp
<             thus ?thesis using t set_char set_def terminal_def by blast
---
>             have "t \<in> set t"
>               using t set_char [of t]
>               by (metis (mono_tags, lifting) Dom.simps(1) image_insert insertI1 UP_def
>                   terminal_char terminal_def)
>             thus ?thesis
>               using t set_def [of t] by simp
797c451
<           fix A :: "'a arr set"
---
>           fix A :: "'a setcat.arr set"
801c455
<             let ?a = "MkArr (DOWN ` A) (DOWN ` A) (\<lambda>x. x)"
---
>             let ?a = "MkArr (DOWN ` A) (DOWN ` A) (\<lambda>x \<in> (DOWN ` A). x)"
805c459
<                 using ide_char by fastforce
---
>                 using ide_char [of ?a] by simp
818c472
<           fix a b :: "'a arr"
---
>           fix a b :: "'a setcat.arr"
821c475,476
<             using a b ab set_char inj_UP inj_image_eq_iff dom_char in_homE ide_in_hom by metis
---
>             using a b ab set_char inj_UP inj_image_eq_iff dom_char in_homE ide_in_hom
>             by (metis (mono_tags, lifting))
823c478
<           fix f f' :: "'a arr"
---
>           fix f f' :: "'a setcat.arr"
825,829c480
<           have 1: "Dom f = Dom f' \<and> Cod f = Cod f'"
<             using par dom_char cod_char Dom_MkArr by (metis (no_types, lifting))
<           moreover have "Fun f = Fun f'"
<             using 1 par ff' MkElem_in_hom Fun_via_comp Fun_via_comp by fastforce
<           ultimately show "f = f'" using par arr_eqI by auto
---
>           show "f = f'" using par ff' arr_eqI' by blast
831c482
<           fix a b :: "'a arr" and F :: "'a arr \<Rightarrow> 'a arr"
---
>           fix a b :: "'a setcat.arr" and F :: "'a setcat.arr \<Rightarrow> 'a setcat.arr"
835,850c486,515
<             let ?f = "MkArr (Dom a) (Dom b) (\<lambda>x. Fun (F (MkElem (UP x) a)) U)"
<             have "(\<lambda>x. Fun (F (MkElem (UP x) a)) U) \<in> Dom a \<rightarrow> Dom b"
<             proof
<               fix x
<               assume x: "x \<in> Dom a"
<               have "MkElem (UP x) a \<in> hom unity a"
<                 using x a MkElem_in_hom [of a x] ide_char by force
<               hence 1: "F (MkElem (UP x) a) \<in> hom unity b"
<                 using F by auto
<               moreover have "Dom (F (MkElem (UP x) a)) = {U}"
<                 using 1 by (metis Dom_MkArr MkElem_Img)
<               moreover have "Cod (F (MkElem (UP x) a)) = Dom b"
<                 using 1 by (metis Dom_MkArr cod_char in_homE CollectD)
<               ultimately have "Fun (F (MkElem (UP x) a)) \<in> {U} \<rightarrow> Dom b"
<                 using arr_char [of "F (MkElem (UP x) a)"] by blast
<               thus "Fun (F (MkElem (UP x) a)) U \<in> Dom b" by blast
---
>             let ?f = "MkArr (Dom a) (Dom b) (\<lambda>x \<in> Dom a. Map (F (MkElem (UP x) a)) U)"
>             have 1: "\<guillemotleft>?f : a \<rightarrow> b\<guillemotright>"
>             proof -
>               have "(\<lambda>x \<in> Dom a. Map (F (MkElem (UP x) a)) U)
>                       \<in> extensional (Dom a) \<inter> (Dom a \<rightarrow> Dom b)"
>               proof
>                 show "(\<lambda>x \<in> Dom a. Map (F (MkElem (UP x) a)) U) \<in> extensional (Dom a)"
>                   using a F by simp
>                 show "(\<lambda>x \<in> Dom a. Map (F (MkElem (UP x) a)) U) \<in> Dom a \<rightarrow> Dom b"
>                 proof
>                   fix x
>                   assume x: "x \<in> Dom a"
>                   have "MkElem (UP x) a \<in> hom unity a"
>                     using x a MkElem_in_hom [of a x] ide_char ideD(1-2) by force
>                   hence 1: "F (MkElem (UP x) a) \<in> hom unity b"
>                     using F by auto
>                   moreover have "Dom (F (MkElem (UP x) a)) = {U}"
>                     using 1 MkElem_Img
>                     by (metis (mono_tags, lifting) Dom.simps(1))
>                   moreover have "Cod (F (MkElem (UP x) a)) = Dom b"
>                     using 1 by (metis (mono_tags, lifting) CollectD in_hom_char)
>                   ultimately have "Map (F (MkElem (UP x) a)) \<in> {U} \<rightarrow> Dom b"
>                     using arr_char [of "F (MkElem (UP x) a)"] by blast
>                   thus "Map (F (MkElem (UP x) a)) U \<in> Dom b" by blast
>                 qed
>               qed
>               hence "\<guillemotleft>?f : MkIde (Dom a) \<rightarrow> MkIde (Dom b)\<guillemotright>"
>                 using a b MkArr_in_hom by blast
>               thus ?thesis
>                 using a b by simp
852,854c517
<             hence 1: "\<guillemotleft>?f : a \<rightarrow> b\<guillemotright>"
<               using a b Id_Dom MkArr_in_hom by metis
<             have "\<And>x. \<guillemotleft>x : unity \<rightarrow> dom ?f\<guillemotright> \<Longrightarrow> ?f \<cdot> x = F x"
---
>             moreover have "\<And>x. \<guillemotleft>x : unity \<rightarrow> dom ?f\<guillemotright> \<Longrightarrow> ?f \<cdot> x = F x"
859c522,523
<                 using a x 1 MkElem_Img [of x a] by auto
---
>                 using a x 1 MkElem_Img [of x a]
>                 by (metis (mono_tags, lifting) in_homE mem_Collect_eq)
861,865c525,527
<                                 Fun x = (\<lambda>_ \<in> {U}. DOWN (Img x))"
<                 using x 2 Dom_MkArr [of "{U}" "Dom a" "\<lambda>_ \<in> {U}. DOWN (Img x)"]
<                       Cod_MkArr [of "{U}" "Dom a" "\<lambda>_ \<in> {U}. DOWN (Img x)"]
<                       Fun_MkArr [of "{U}" "Dom a" "\<lambda>_ \<in> {U}. DOWN (Img x)"]
<                 by simp
---
>                                 Map x = (\<lambda>_ \<in> {U}. DOWN (Img x))"
>                 using x 2
>                 by (metis (no_types, lifting) Cod.simps(1) Dom.simps(1) Map.simps(1))
869,872c531,534
<                        MkArr {U} (Dom b) (compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)))"
<                 using 1 x comp_char [of ?f "MkElem (Img x) a"] Dom_MkArr Cod_MkArr Fun_MkArr
<                 by fastforce
<               have 4: "compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) = Fun (F x)"
---
>                        MkArr {U} (Dom b) (compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)))"
>                 using 1 x comp_char [of ?f "MkElem (Img x) a"]
>                 by (metis (mono_tags, lifting) in_homE seqI)
>               have 4: "compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) = Map (F x)"
876c538
<                         compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Fun (F x) y"
---
>                         compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Map (F x) y"
879c541
<                   have "compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = undefined"
---
>                   have "compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = undefined"
881c543
<                   also have "... = Fun (F x) y"
---
>                   also have "... = Map (F x) y"
885c547
<                       by (metis Dom_MkArr MkElem_Img)
---
>                       by (metis (mono_tags, lifting) "2" CollectD Dom.simps(1) in_hom_char x)
887c549,550
<                       using y 5 arr_char [of "F x"] extensional_arb by fastforce
---
>                       using x y F 5 arr_char [of "F x"] extensional_arb [of "Map (F x)" "{U}" y]
>                       by (metis (mono_tags, lifting) CollectD Int_iff in_hom_char)
893c556
<                        compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Fun (F x) y"
---
>                        compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Map (F x) y"
896,897c559,560
<                   have "compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y =
<                         Fun ?f (DOWN (Img x))"
---
>                   have "compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y =
>                         Map ?f (DOWN (Img x))"
899c562
<                   also have "... = (\<lambda>x. Fun (F (MkElem (UP x) a)) U) (DOWN (Img x))"
---
>                   also have "... = (\<lambda>x. Map (F (MkElem (UP x) a)) U) (DOWN (Img x))"
903c566
<                       by (metis (no_types, lifting) IntD2 PiE)
---
>                       by (metis (mono_tags, lifting) IntD2 PiE)
905c568
<                       using Fun_MkArr restrict_apply by simp
---
>                       using restrict_apply by simp
907,908c570,571
<                   also have "... = Fun (F x) y"
<                     using x y 1 MkElem_Img [of x a] by auto
---
>                   also have "... = Map (F x) y"
>                     using x y 1 2 MkElem_Img [of x a] by simp
910c573
<                       "compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Fun (F x) y"
---
>                       "compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Map (F x) y"
914c577
<                     "compose {U} (Fun ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Fun (F x) y"
---
>                     "compose {U} (Map ?f) (\<lambda>_ \<in> {U}. DOWN (Img x)) y = Map (F x) y"
919,929c582,593
<                 have 5: "?f \<cdot> x \<in> hom unity b" using 1 x by auto
<                 have 6: "F x \<in> hom unity b" using x F 1 by force
<                 show "arr (comp ?f x)" using 5 by auto
<                 show "arr (F x)" using 6 by auto
<                 show "Dom (comp ?f x) = Dom (F x)"
<                   using 5 6 Dom_MkArr MkElem_Img by metis
<                 show "Cod (comp ?f x) = Cod (F x)"
<                   using 5 6 Cod_MkArr MkElem_Img by metis
<                 show "Fun (comp ?f x) = Fun (F x)"
<                   using 3 4 Fun_MkArr
<                   by (metis compose_def extensional_restrict restrict_extensional)
---
>                 have 5: "?f \<cdot> x \<in> hom unity b" using 1 x by blast
>                 have 6: "F x \<in> hom unity b"
>                   using x F 1
>                   by (metis (mono_tags, lifting) PiE in_homE mem_Collect_eq)
>                 show "arr (Comp ?f x)" using 5 by blast
>                 show "arr (F x)" using 6 by blast
>                 show "Dom (Comp ?f x) = Dom (F x)"
>                   using 5 6 by (metis (mono_tags, lifting) CollectD in_hom_char)
>                 show "Cod (Comp ?f x) = Cod (F x)"
>                   using 5 6 by (metis (mono_tags, lifting) CollectD in_hom_char)
>                 show "Map (Comp ?f x) = Map (F x)"
>                   using 3 4 by simp
932c596
<             thus "\<guillemotleft>?f : a \<rightarrow> b\<guillemotright> \<and> (\<forall>x. \<guillemotleft>x : unity \<rightarrow> dom ?f\<guillemotright> \<longrightarrow> comp ?f x = F x)"
---
>             thus "\<guillemotleft>?f : a \<rightarrow> b\<guillemotright> \<and> (\<forall>x. \<guillemotleft>x : unity \<rightarrow> dom ?f\<guillemotright> \<longrightarrow> Comp ?f x = F x)"
939a604,622
>       \<open>SetCat\<close> can be viewed as a concrete set category over its own element type
>       @{typ 'a}, using @{term UP} as the required injection from @{typ 'a} to the universe
>       of \<open>SetCat\<close>.
> \<close>
> 
>     corollary is_concrete_set_category:
>     shows "concrete_set_category Comp Univ UP"
>     proof -
>       interpret S: set_category Comp using is_set_category by auto
>       show ?thesis
>       proof
>         show 1: "UP \<in> Univ \<rightarrow> S.Univ"
>           using UP_def terminal_char by force
>         show "inj_on UP Univ"
>           by (metis (mono_tags, lifting) injD inj_UP inj_onI)
>       qed
>     qed
> 
>     text\<open>
950,951c633,634
<     shows "\<exists>\<Phi>. invertible_functor S (SetCat.comp :: 'a arr comp) \<Phi>
<               \<and> (\<forall>m. set_category.incl S m \<longrightarrow> set_category.incl SetCat.comp (\<Phi> m))"
---
>     shows "\<exists>\<Phi>. invertible_functor S (Comp :: 'a setcat.arr comp) \<Phi>
>                  \<and> (\<forall>m. set_category.incl S m \<longrightarrow> set_category.incl Comp (\<Phi> m))"
955c638
<       have "bij_betw (UP o \<phi>) S.Univ (Collect (category.terminal comp))"
---
>       have "bij_betw (UP o \<phi>) S.Univ (Collect terminal)"
957c640
<         show "UP o \<phi> \<in> S.Univ \<rightarrow> Collect (category.terminal comp)"
---
>         show "UP o \<phi> \<in> S.Univ \<rightarrow> Collect terminal"
959,960c642,649
<         show "?\<psi> o DOWN \<in> Collect (category.terminal comp) \<rightarrow> S.Univ"
<           using assms(2) by (metis Pi_I UNIV_I bij_betw_def comp_apply inv_into_into)
---
>         show "?\<psi> o DOWN \<in> Collect terminal \<rightarrow> S.Univ"
>         proof
>           fix x :: "'a setcat.arr"
>           assume x: "x \<in> Univ"
>           show "(inv_into S.Univ \<phi> \<circ> DOWN) x \<in> S.Univ"
>             using x assms(2) bij_betw_def comp_apply inv_into_into
>             by (metis UNIV_I)
>         qed
964c653,654
<           using assms(2) bij_betw_inv_into_left comp_def by fastforce
---
>           using assms(2) bij_betw_inv_into_left
>           by (metis comp_apply DOWN_UP)
966,967c656,657
<         fix t' :: "'a arr"
<         assume "t' \<in> Collect (category.terminal comp)"
---
>         fix t' :: "'a setcat.arr"
>         assume "t' \<in> Collect terminal"
969c659
<           using assms(2) by (metis UNIV_I UP_DOWN bij_betw_def comp_apply f_inv_into_f)
---
>           using assms(2) by (simp add: bij_betw_def f_inv_into_f)
972,973c662,663
<         using assms(1) set_category_is_categorical [of S SetCat.comp "UP o \<phi>"] is_set_category 
<         by blast
---
>         using assms(1) set_category_is_categorical [of S Comp "UP o \<phi>"] is_set_category
>         by auto
976,979c666,674
<     text\<open>
<       \<open>SetCat\<close> can be viewed as a concrete set category over its own element type
<       @{typ 'a}, using @{term UP} as the required injection from @{typ 'a} to the universe
<       of \<open>SetCat\<close>.
---
>   end
> 
>   text \<open>
>     The following context defines the entities that are intended to be exported
>     from this theory.  The idea is to avoid exposing as little detail about the
>     construction used in the @{locale setcat} locale as possible, so that proofs
>     using the result of that construction will depend only on facts proved from
>     axioms in the @{locale set_category} locale and not on concrete details from
>     the construction of the interpretation.
982,991c677,678
<     corollary is_concrete_set_category:
<     shows "concrete_set_category comp Univ UP"
<     proof -
<       interpret S: set_category comp using is_set_category by auto
<       show ?thesis
<       proof
<         show 1: "UP \<in> S.Univ \<rightarrow> S.Univ" using UP_mapsto by auto
<         show "inj_on UP S.Univ" by (metis injD inj_UP inj_onI)
<       qed
<     qed
---
>   context
>   begin
993,994c680
<     no_notation comp      (infixr "\<cdot>" 55)
<     no_notation in_hom    ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")
---
>     interpretation S: setcat .
996c682,719
<   end
---
>     definition comp
>     where "comp \<equiv> S.Comp"
> 
>     interpretation set_category comp
>       unfolding comp_def using S.is_set_category by simp
> 
>     lemma is_set_category:
>     shows "set_category comp"
>       ..
> 
>     definition DOWN
>     where "DOWN = S.DOWN"
> 
>     definition UP
>     where "UP = S.UP"
> 
>     lemma UP_mapsto:
>     shows "UP \<in> UNIV \<rightarrow> Univ"
>       using S.UP_mapsto
>       by (simp add: UP_def comp_def)
> 
>     lemma DOWN_mapsto:
>     shows "DOWN \<in> Univ \<rightarrow> UNIV"
>       by auto
> 
>     lemma DOWN_UP [simp]:
>     shows "DOWN (UP x) = x"
>       by (simp add: DOWN_def UP_def)
> 
>     lemma UP_DOWN [simp]:
>     assumes "t \<in> Univ"
>     shows "UP (DOWN t) = t"
>       using assms DOWN_def UP_def
>       by (simp add: DOWN_def UP_def comp_def)
> 
>     lemma inj_UP:
>     shows "inj UP"
>       by (metis DOWN_UP injI)
997a721,726
>     lemma bij_UP:
>     shows "bij_betw UP UNIV Univ"
>       by (metis S.bij_UP UP_def comp_def)
> 
>   end
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Category3/Yoneda.thy ../../AFPs/afp-2020/thys/Category3/Yoneda.thy
371,373c371,373
<     interpretation S: set_category "SetCat.comp :: 'a SetCat.arr comp"
<       using SetCat.is_set_category by auto
<     interpretation Hom: hom_functor C "SetCat.comp :: 'a SetCat.arr comp" "\<lambda>_. UP"
---
>     interpretation S: set_category \<open>SetCat.comp :: 'a setcat.arr comp\<close>
>       using is_set_category by auto
>     interpretation Hom: hom_functor C \<open>SetCat.comp :: 'a setcat.arr comp\<close> \<open>\<lambda>_. SetCat.UP\<close>
379c379
<     shows "hom_functor C (SetCat.comp :: 'a SetCat.arr comp) (\<lambda>_. UP)" ..
---
>     shows "hom_functor C (SetCat.comp :: 'a setcat.arr comp) (\<lambda>_. UP)" ..
471c471
<     where "Y f \<equiv> Cop_S.Fun (map f)"
---
>     where "Y f \<equiv> Cop_S.Map (map f)"
713c713
<     interpretation \<T>e: transformation_by_components Cop.comp S "Y a" F "\<T>o e"
---
>     interpretation \<T>e: transformation_by_components Cop.comp S \<open>Y a\<close> F \<open>\<T>o e\<close>
842c842
<       interpret \<tau>': natural_transformation Cop.comp S "Y a" F \<tau>' using assms by auto
---
>       interpret \<tau>': natural_transformation Cop.comp S \<open>Y a\<close> F \<tau>' using assms by auto
868c868
<       interpret \<T>e: natural_transformation Cop.comp S "Y a" F "\<T> e"
---
>       interpret \<T>e: natural_transformation Cop.comp S \<open>Y a\<close> F \<open>\<T> e\<close>
882c882
<       interpret \<tau>: natural_transformation Cop.comp S "Y a" F \<tau> using assms by auto
---
>       interpret \<tau>: natural_transformation Cop.comp S \<open>Y a\<close> F \<tau> using assms by auto
906c906
<       interpret natural_transformation Cop.comp S "Y a" F \<tau> using assms by auto
---
>       interpret natural_transformation Cop.comp S \<open>Y a\<close> F \<tau> using assms by auto
909c909
<       interpret yoneda_lemma_fixed_e C S \<phi> F a "\<E> \<tau>"
---
>       interpret yoneda_lemma_fixed_e C S \<phi> F a \<open>\<E> \<tau>\<close>
911c911
<       interpret \<T>e: natural_transformation Cop.comp S "Y a" F "\<T> (\<E> \<tau>)"
---
>       interpret \<T>e: natural_transformation Cop.comp S \<open>Y a\<close> F \<open>\<T> (\<E> \<tau>)\<close>
968c968
<       interpret Ye: natural_transformation Cop.comp S "Y a" "Y a'" "Y ?\<psi>e"
---
>       interpret Ye: natural_transformation Cop.comp S \<open>Y a\<close> \<open>Y a'\<close> \<open>Y ?\<psi>e\<close>
970c970
<       interpret yoneda_lemma_fixed_e C S \<phi> "Y a'" a e
---
>       interpret yoneda_lemma_fixed_e C S \<phi> \<open>Y a'\<close> a e
973c973
<       interpret \<T>e: natural_transformation Cop.comp S "Y a" "Y a'" "\<T> e"
---
>       interpret \<T>e: natural_transformation Cop.comp S \<open>Y a\<close> \<open>Y a'\<close> \<open>\<T> e\<close>
975c975
<       interpret yoneda_lemma_fixed_\<tau> C S \<phi> "Y a'" a "\<T> e" ..
---
>       interpret yoneda_lemma_fixed_\<tau> C S \<phi> \<open>Y a'\<close> a \<open>\<T> e\<close> ..
1055c1055
<         interpret Ya': yoneda_functor_fixed_object C S \<phi> "C.cod f"
---
>         interpret Ya': yoneda_functor_fixed_object C S \<phi> \<open>C.cod f\<close>
1057c1057
<         interpret yoneda_lemma_for_hom C S \<phi> "Y (C.cod f)" "C.dom f" "C.cod f"
---
>         interpret yoneda_lemma_for_hom C S \<phi> \<open>Y (C.cod f)\<close> \<open>C.dom f\<close> \<open>C.cod f\<close>
1073c1073
<         interpret yoneda_lemma_for_hom C S \<phi> "Y a'" a a'
---
>         interpret yoneda_lemma_for_hom C S \<phi> \<open>Y a'\<close> a a'
1075,1077c1075,1077
<         have NT: "natural_transformation Cop.comp S (Y a) (Y a') (Cop_S.Fun t)"
<           using t a' Y_def Cop_S.Fun_dom Cop_S.Fun_cod Cop_S.dom_simp Cop_S.cod_simp
<                 Cop_S.arr_char Cop_S.in_homE
---
>         have NT: "natural_transformation Cop.comp S (Y a) (Y a') (Cop_S.Map t)"
>           using t a' Y_def Cop_S.Map_dom Cop_S.Map_cod Cop_S.dom_char Cop_S.cod_char
>                 Cop_S.in_homE Cop_S.arrE
1079c1079
<         hence 1: "\<E> (Cop_S.Fun t) \<in> Hom.set (a, a')"
---
>         hence 1: "\<E> (Cop_S.Map t) \<in> Hom.set (a, a')"
1081c1081
<         moreover have "map (\<psi> (a, a') (\<E> (Cop_S.Fun t))) = t"
---
>         moreover have "map (\<psi> (a, a') (\<E> (Cop_S.Map t))) = t"
1083c1083
<           have 2: "\<guillemotleft>map (\<psi> (a, a') (\<E> (Cop_S.Fun t))) : map a \<rightarrow>\<^sub>[\<^sub>C\<^sub>o\<^sub>p\<^sub>,\<^sub>S\<^sub>] map a'\<guillemotright>"
---
>           have 2: "\<guillemotleft>map (\<psi> (a, a') (\<E> (Cop_S.Map t))) : map a \<rightarrow>\<^sub>[\<^sub>C\<^sub>o\<^sub>p\<^sub>,\<^sub>S\<^sub>] map a'\<guillemotright>"
1086,1087c1086,1087
<           show "Cop_S.arr (map (\<psi> (a, a') (\<E> (Cop_S.Fun t))))" using 2 by blast
<           show 3: "Cop_S.Fun (map (\<psi> (a, a') (\<E> (Cop_S.Fun t)))) = Cop_S.Fun t"
---
>           show "Cop_S.arr (map (\<psi> (a, a') (\<E> (Cop_S.Map t))))" using 2 by blast
>           show 3: "Cop_S.Map (map (\<psi> (a, a') (\<E> (Cop_S.Map t)))) = Cop_S.Map t"
1089,1092c1089,1092
<           show 4: "Cop_S.Dom (map (\<psi> (a, a') (\<E> (Cop_S.Fun t)))) = Cop_S.Dom t"
<             using t 2 natural_transformation_axioms Cop_S.Fun_dom by (metis Cop_S.in_homE)
<           show "Cop_S.Cod (map (\<psi> (a, a') (\<E> (Cop_S.Fun t)))) = Cop_S.Cod t"
<             using 2 3 4 t Cop_S.Fun_cod by (metis Cop_S.in_homE)
---
>           show 4: "Cop_S.Dom (map (\<psi> (a, a') (\<E> (Cop_S.Map t)))) = Cop_S.Dom t"
>             using t 2 natural_transformation_axioms Cop_S.Map_dom by (metis Cop_S.in_homE)
>           show "Cop_S.Cod (map (\<psi> (a, a') (\<E> (Cop_S.Map t)))) = Cop_S.Cod t"
>             using 2 3 4 t Cop_S.Map_cod by (metis Cop_S.in_homE)
1094,1095c1094,1095
<         ultimately show "\<guillemotleft>\<psi> (a, a') (\<E> (Cop_S.Fun t)) : a \<rightarrow> a'\<guillemotright> \<and>
<                          map (\<psi> (a, a') (\<E> (Cop_S.Fun t))) = t"
---
>         ultimately show "\<guillemotleft>\<psi> (a, a') (\<E> (Cop_S.Map t)) : a \<rightarrow> a'\<guillemotright> \<and>
>                          map (\<psi> (a, a') (\<E> (Cop_S.Map t))) = t"
==========
CAVA_LTL_Modelchecker
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CAVA_LTL_Modelchecker/CAVA_Impl.thy ../../AFPs/afp-2020/thys/CAVA_LTL_Modelchecker/CAVA_Impl.thy
218c218
< definition gabow_find_ce_code 
---
> definition gabow_find_ce_code :: "_ \<Rightarrow> 'a::hashable lasso option option"
221c221
<   \<equiv> map_option (Some o lasso_of_prpl) o Gabow_GBG_Code.find_lasso_tr"
---
>   \<equiv> map_option (Some o lasso_of_prpl) o Gabow_GBG_Code.find_lasso_tr (=) bounded_hashcode_nat (def_hashmap_size TYPE('a))"
230c230
<       l \<leftarrow> RETURN (find_lasso_tr gbgi);
---
>       l \<leftarrow> RETURN (find_lasso_tr (=) bounded_hashcode_nat (def_hashmap_size TYPE('a)) gbgi);
242a243,245
>     apply (simp; fail)
>     apply (rule autoref_ga_rules;simp; fail)
>     apply (rule autoref_ga_rules;simp; fail)
Only in ../../AFPs/afp-2020/thys/CAVA_LTL_Modelchecker: CAVA_Setup
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CAVA_LTL_Modelchecker/SM/Impl/SM_Wrapup.thy ../../AFPs/afp-2020/thys/CAVA_LTL_Modelchecker/SM/Impl/SM_Wrapup.thy
2c2
< imports SM_Ample_Impl LTL_to_GBA.LTL_Stutter
---
> imports SM_Ample_Impl Stuttering_Equivalence.PLTL
97c97
<         from next_free_stutter_invariant[OF NF E2] L 
---
>         from ltlc_next_free_stutter_invariant[OF NF E2] L 
Only in ../../AFPs/afp-2020/thys/CAVA_LTL_Modelchecker: SM_Base
==========
Chord_Segments
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Chord_Segments/Chord_Segments.thy ../../AFPs/afp-2020/thys/Chord_Segments/Chord_Segments.thy
6,8c6
< imports
<   "HOL-Analysis.Analysis"
<   Triangle.Triangle
---
> imports Triangle.Triangle
==========
Clean
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Clean/examples/Quicksort_concept.thy ../../AFPs/afp-2020/thys/Clean/examples/Quicksort_concept.thy
38c38
<  * Quicksort Concept 
---
>  * Quicksort Concept
51,52c51,52
<   imports Clean_Main.Clean
<           Clean_Main.Hoare_MonadSE
---
>   imports Clean
>           Hoare_MonadSE
87c87
< the concept of call-by-reference parameters; consequently, the algorithm must be specialized 
---
> the concept of call-by-reference parameters; consequently, the algorithm must be specialized
92,93c92,93
< text\<open>We demonstrate the accumulating effect of some key Clean commands by highlighting the 
< changes of  Clean's state-management module state. At the beginning, the state-type of 
---
> text\<open>We demonstrate the accumulating effect of some key Clean commands by highlighting the
> changes of  Clean's state-management module state. At the beginning, the state-type of
107c107
< ML\<open> val Type("Quicksort_concept.global_state_state_scheme",t) 
---
> ML\<open> val Type("Quicksort_concept.global_state_state_scheme",t)
123,125c123,125
< pre          "\<open>i < length A \<and> j < length A\<close>"    
< post         "\<open>\<lambda>res. length A = length(old A) \<and> res = ()\<close>" 
< local_vars   tmp :: int 
---
> pre          "\<open>i < length A \<and> j < length A\<close>"
> post         "\<open>\<lambda>res. length A = length(old A) \<and> res = ()\<close>"
> local_vars   tmp :: int
127,128c127,128
<                \<open> A := list_update A i (A ! j)\<close> ;- 
<                \<open> A := list_update A j tmp\<close> " 
---
>                \<open> A := list_update A i (A ! j)\<close> ;-
>                \<open> A := list_update A j tmp\<close> "
130c130
< text\<open>The body --- heavily using the \<open>\<lambda>\<close>-lifting cartouche --- corresponds to the low level 
---
> text\<open>The body --- heavily using the \<open>\<lambda>\<close>-lifting cartouche --- corresponds to the low level
135c135
<             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;- 
---
>             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;-
161c161
< text\<open>The somewhat vacuous parameter \<open>res\<close> for the result of the swap-computation is the conseqeuence 
---
> text\<open>The somewhat vacuous parameter \<open>res\<close> for the result of the swap-computation is the conseqeuence
182c182
<   where   "push_local_swap_state' \<sigma> = 
---
>   where   "push_local_swap_state' \<sigma> =
186,187c186,187
<   where   "pop_local_swap_state' \<sigma> = 
<                     Some(hd(local_swap_state.result_value \<sigma>), 
---
>   where   "pop_local_swap_state' \<sigma> =
>                     Some(hd(local_swap_state.result_value \<sigma>),
195,196c195,196
<                             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;- 
<                             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (j) ((hd o tmp) \<sigma>)))))" 
---
>                             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;-
>                             (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (j) ((hd o tmp) \<sigma>)))))"
205c205
<    just kept as part of the monadic calculation. The simplifications refer both to 
---
>    just kept as part of the monadic calculation. The simplifications refer both to
211,212c211,212
<                           ((assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;- 
<                            (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (j) (tmp)))))" 
---
>                           ((assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (i) (A \<sigma> ! j))) ;-
>                            (assign_global A_update (\<lambda>\<sigma>. list_update (A \<sigma>) (j) (tmp)))))"
222,223c222,223
< pre          "\<open>lo < length A \<and> hi < length A\<close>"    
< post         "\<open>\<lambda>res::nat. length A = length(old A) \<and> res = 3\<close>" 
---
> pre          "\<open>lo < length A \<and> hi < length A\<close>"
> post         "\<open>\<lambda>res::nat. length A = length(old A) \<and> res = 3\<close>"
228,229c228,229
<                (while\<^sub>C \<open>j \<le> hi - 1 \<close> 
<                 do (if\<^sub>C \<open>A ! j < pivot\<close>  
---
>                (while\<^sub>C \<open>j \<le> hi - 1 \<close>
>                 do (if\<^sub>C \<open>A ! j < pivot\<close>
232c232
<                     else skip\<^sub>S\<^sub>E 
---
>                     else skip\<^sub>S\<^sub>E
234c234
<                     \<open>j := j + 1 \<close> 
---
>                     \<open>j := j + 1 \<close>
237,238c237,238
<                 return\<^sub>C result_value_update \<open>i\<close>   
<                ) " 
---
>                 return\<^sub>C result_value_update \<open>i\<close>
>                ) "
243c243
< \<open>\<open>defines      " ((assign_local pivot_update (\<lambda>\<sigma>. A \<sigma> ! hi ))   ;- 
---
> \<open>\<open>defines      " ((assign_local pivot_update (\<lambda>\<sigma>. A \<sigma> ! hi ))   ;-
245c245
<  
---
> 
247,248c247,248
<                (while\<^sub>C (\<lambda>\<sigma>. (hd o j) \<sigma> \<le> hi - 1 ) 
<                 do (if\<^sub>C (\<lambda>\<sigma>. A \<sigma> ! (hd o j) \<sigma> < (hd o pivot)\<sigma> ) 
---
>                (while\<^sub>C (\<lambda>\<sigma>. (hd o j) \<sigma> \<le> hi - 1 )
>                 do (if\<^sub>C (\<lambda>\<sigma>. A \<sigma> ! (hd o j) \<sigma> < (hd o pivot)\<sigma> )
251c251
<                     else skip\<^sub>S\<^sub>E 
---
>                     else skip\<^sub>S\<^sub>E
253c253
<                     (assign_local j_update (\<lambda>\<sigma>. ((hd o j) \<sigma>) + 1)) 
---
>                     (assign_local j_update (\<lambda>\<sigma>. ((hd o j) \<sigma>) + 1))
256c256
<                 assign_local result_value_update (\<lambda>\<sigma>. (hd o i) \<sigma>)  
---
>                 assign_local result_value_update (\<lambda>\<sigma>. (hd o i) \<sigma>)
286c286
< text\<open> ... which results in the internal definition of the respective push and pop operations 
---
> text\<open> ... which results in the internal definition of the respective push and pop operations
295,298c295,298
<                         \<sigma>\<lparr>local_partition_state.pivot := undefined # local_partition_state.pivot \<sigma>, 
<                           local_partition_state.i     := undefined # local_partition_state.i \<sigma>, 
<                           local_partition_state.j     := undefined # local_partition_state.j \<sigma>, 
<                           local_partition_state.result_value   
---
>                         \<sigma>\<lparr>local_partition_state.pivot := undefined # local_partition_state.pivot \<sigma>,
>                           local_partition_state.i     := undefined # local_partition_state.i \<sigma>,
>                           local_partition_state.j     := undefined # local_partition_state.j \<sigma>,
>                           local_partition_state.result_value
301c301
< definition pop_local_partition_state' :: "(nat,'a local_partition_state_scheme) MON\<^sub>S\<^sub>E" 
---
> definition pop_local_partition_state' :: "(nat,'a local_partition_state_scheme) MON\<^sub>S\<^sub>E"
303,306c303,306
<                        \<sigma>\<lparr>local_partition_state.pivot := tl(local_partition_state.pivot \<sigma>), 
<                          local_partition_state.i     := tl(local_partition_state.i \<sigma>), 
<                          local_partition_state.j     := tl(local_partition_state.j \<sigma>), 
<                          local_partition_state.result_value := 
---
>                        \<sigma>\<lparr>local_partition_state.pivot := tl(local_partition_state.pivot \<sigma>),
>                          local_partition_state.i     := tl(local_partition_state.i \<sigma>),
>                          local_partition_state.j     := tl(local_partition_state.j \<sigma>),
>                          local_partition_state.result_value :=
312c312
<               ((assign_local pivot_update (\<lambda>\<sigma>. A \<sigma> ! hi ))   ;- 
---
>               ((assign_local pivot_update (\<lambda>\<sigma>. A \<sigma> ! hi ))   ;-
314c314
<  
---
> 
316,317c316,317
<                (while\<^sub>C (\<lambda>\<sigma>. (hd o j) \<sigma> \<le> hi - 1 ) 
<                 do (if\<^sub>C (\<lambda>\<sigma>. A \<sigma> ! (hd o j) \<sigma> < (hd o pivot)\<sigma> ) 
---
>                (while\<^sub>C (\<lambda>\<sigma>. (hd o j) \<sigma> \<le> hi - 1 )
>                 do (if\<^sub>C (\<lambda>\<sigma>. A \<sigma> ! (hd o j) \<sigma> < (hd o pivot)\<sigma> )
320,321c320,321
<                     else skip\<^sub>S\<^sub>E 
<                     fi) 
---
>                     else skip\<^sub>S\<^sub>E
>                     fi)
325c325
<                 assign_local result_value_update (\<lambda>\<sigma>. (hd o i) \<sigma>)  
---
>                 assign_local result_value_update (\<lambda>\<sigma>. (hd o i) \<sigma>)
333,334c333,334
<   where   "partition'  \<equiv> \<lambda>(lo,hi). block\<^sub>C push_local_partition_state 
<                                    (partition_core (lo,hi)) 
---
>   where   "partition'  \<equiv> \<lambda>(lo,hi). block\<^sub>C push_local_partition_state
>                                    (partition_core (lo,hi))
336c336
<              
---
> 
345,347c345,347
< variant      "hi - lo" 
< local_vars   p :: "nat" 
< defines      " if\<^sub>C \<open>lo < hi\<close>  
---
> variant      "hi - lo"
> local_vars   p :: "nat"
> defines      " if\<^sub>C \<open>lo < hi\<close>
350,351c350,351
<                      call\<^sub>C quicksort \<open>(lo, p + 1)\<close>  
<                else skip\<^sub>S\<^sub>E 
---
>                      call\<^sub>C quicksort \<open>(lo, p + 1)\<close>
>                else skip\<^sub>S\<^sub>E
365c365
< text\<open>This is the most complex form a Clean function may have: it may be directly 
---
> text\<open>This is the most complex form a Clean function may have: it may be directly
379c379
<   where   "push_local_quicksort_state' \<sigma> = 
---
>   where   "push_local_quicksort_state' \<sigma> =
388,389c388,389
<                        \<sigma>\<lparr>local_quicksort'_state.p   := tl(local_quicksort'_state.p \<sigma>), 
<                          local_quicksort'_state.result_value := 
---
>                        \<sigma>\<lparr>local_quicksort'_state.p   := tl(local_quicksort'_state.p \<sigma>),
>                          local_quicksort'_state.result_value :=
398c398
<      local_vars p :: int     
---
>      local_vars p :: int
412c412
<   where   "quicksort'_post \<equiv> \<lambda>(i,j). \<lambda> res. \<lambda>\<sigma>.  True"   
---
>   where   "quicksort'_post \<equiv> \<lambda>(i,j). \<lambda> res. \<lambda>\<sigma>.  True"
417,418c417,418
<   where   "quicksort'_core quicksort_rec \<equiv> \<lambda>(lo, hi). 
<                             ((if\<^sub>C (\<lambda>\<sigma>. lo < hi ) 
---
>   where   "quicksort'_core quicksort_rec \<equiv> \<lambda>(lo, hi).
>                             ((if\<^sub>C (\<lambda>\<sigma>. lo < hi )
422,423c422,423
<                                     call\<^sub>C quicksort_rec (\<lambda>\<sigma>. ((hd o p) \<sigma> + 1, hi))  
<                               else skip\<^sub>S\<^sub>E 
---
>                                     call\<^sub>C quicksort_rec (\<lambda>\<sigma>. ((hd o p) \<sigma> + 1, hi))
>                               else skip\<^sub>S\<^sub>E
430,431c430,431
<   where   "quicksort' order \<equiv> wfrec order (\<lambda>X. \<lambda>(lo, hi). block\<^sub>C push_local_quicksort'_state 
<                                                                  (quicksort'_core X (lo,hi)) 
---
>   where   "quicksort' order \<equiv> wfrec order (\<lambda>X. \<lambda>(lo, hi). block\<^sub>C push_local_quicksort'_state
>                                                                  (quicksort'_core X (lo,hi))
437c437
< text\<open>The coupling between the pre- and the post-condition state is done by the 
---
> text\<open>The coupling between the pre- and the post-condition state is done by the
441,443c441,443
< lemma quicksort_correct : 
<   "\<lbrace>\<lambda>\<sigma>.   \<not>exec_stop \<sigma> \<and> quicksort_pre (lo, hi)(\<sigma>) \<and> \<sigma> = \<sigma>\<^sub>p\<^sub>r\<^sub>e \<rbrace> 
<      quicksort (lo, hi) 
---
> lemma quicksort_correct :
>   "\<lbrace>\<lambda>\<sigma>.   \<not>exec_stop \<sigma> \<and> quicksort_pre (lo, hi)(\<sigma>) \<and> \<sigma> = \<sigma>\<^sub>p\<^sub>r\<^sub>e \<rbrace>
>      quicksort (lo, hi)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Clean/examples/SquareRoot_concept.thy ../../AFPs/afp-2020/thys/Clean/examples/SquareRoot_concept.thy
42c42
< section \<open> The Squareroot Example for Symbolic Execution \<close> 
---
> section \<open> The Squareroot Example for Symbolic Execution \<close>
45c45
<   imports Clean_Main.Test_Clean
---
>   imports Test_Clean
56,57c56,57
< pre          "\<open>0 \<le> a\<close>"    
< post         "\<open>\<lambda>res::int.  (res + 1)\<^sup>2 > a \<and> a \<ge> (res)\<^sup>2\<close>" 
---
> pre          "\<open>0 \<le> a\<close>"
> post         "\<open>\<lambda>res::int.  (res + 1)\<^sup>2 > a \<and> a \<ge> (res)\<^sup>2\<close>"
61c61
<                (while\<^sub>S\<^sub>E \<open>sqsum <= a\<close> do 
---
>                (while\<^sub>S\<^sub>E \<open>sqsum <= a\<close> do
66,67c66,67
<                return\<^sub>C result_value_update \<open>i\<close>   
<                )" 
---
>                return\<^sub>C result_value_update \<open>i\<close>
>                )"
125c125
<    tm (?r\<lparr>tm := ?k\<rparr>) \<equiv> ?k 
---
>    tm (?r\<lparr>tm := ?k\<rparr>) \<equiv> ?k
140,143c140,143
<   tm_simp tm_simp1 tm_simp2 
<   sqsum_simp sqsum_simp1 sqsum_simp2 
<   i_simp i_simp1 i_simp2 
<      
---
>   tm_simp tm_simp1 tm_simp2
>   sqsum_simp sqsum_simp1 sqsum_simp2
>   i_simp i_simp1 i_simp2
> 
159c159
< text\<open> Now we run a symbolic execution. We run match-tactics (rather than the Isabelle simplifier 
---
> text\<open> Now we run a symbolic execution. We run match-tactics (rather than the Isabelle simplifier
166,167c166,167
< lemma 
<   assumes non_exec_stop[simp]: "\<not> exec_stop \<sigma>\<^sub>0" 
---
> lemma
>   assumes non_exec_stop[simp]: "\<not> exec_stop \<sigma>\<^sub>0"
169c169
<    and    annotated_program: 
---
>    and    annotated_program:
173c173
<                 (while\<^sub>S\<^sub>E \<open>sqsum <= a\<close> do 
---
>                 (while\<^sub>S\<^sub>E \<open>sqsum <= a\<close> do
181c181
<   
---
> 
209c209
<      
---
> 
215c215
<   text\<open>Here are all abstract test-cases explicit. Each subgoal correstponds to 
---
>   text\<open>Here are all abstract test-cases explicit. Each subgoal correstponds to
221,222c221,222
<     the three test-cases for  @{term "k<3"}. \<close>   
<    defer 1 
---
>     the three test-cases for  @{term "k<3"}. \<close>
>    defer 1
227,228c227,228
<     post-condition for all @{term "k<3"} loop traversals and @{emph \<open>all\<close>} 
<     positive inputs @{term "a "}.\<close>     
---
>     post-condition for all @{term "k<3"} loop traversals and @{emph \<open>all\<close>}
>     positive inputs @{term "a "}.\<close>
230c230
<  *) 
---
>  *)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Clean/src/Test_Clean.thy ../../AFPs/afp-2020/thys/Clean/src/Test_Clean.thy
39c39
<           "~~/src/HOL/Eisbach/Eisbach"
---
>           "HOL-Eisbach.Eisbach"
==========
Closest_Pair_Points
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Closest_Pair_Points/Closest_Pair_Alternative.thy ../../AFPs/afp-2020/thys/Closest_Pair_Points/Closest_Pair_Alternative.thy
8,9c8,9
<   Formalization of a divide-and-conquer algorithm solving the Closest Pair Problem based
<   on the presentation of Kleinberg and Tardos \cite{Algorithm-Design:2005}.
---
>   Formalization of a divide-and-conquer algorithm solving the Closest Pair Problem
>   based on the presentation of Cormen \emph{et al.} \cite{Introduction-to-Algorithms:2009}.
98c98
<   qed 
---
>   qed
120c120
<   
---
> 
141a142,155
> fun find_closest_pair_tm :: "(point * point) \<Rightarrow> point list \<Rightarrow> (point \<times> point) tm" where
>   "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) [] =1 return (c\<^sub>0, c\<^sub>1)"
> | "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) [_] =1 return (c\<^sub>0, c\<^sub>1)"
> | "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ps) =1 (
>     do {
>       ps' <- take_tm 7 ps;
>       p\<^sub>1 <- find_closest_bf_tm p\<^sub>0 ps';
>       if dist c\<^sub>0 c\<^sub>1 \<le> dist p\<^sub>0 p\<^sub>1 then
>         find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps
>       else
>         find_closest_pair_tm (p\<^sub>0, p\<^sub>1) ps
>     }
>   )"
> 
152a167,171
> lemma find_closest_pair_eq_val_find_closest_pair_tm:
>   "val (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps) = find_closest_pair (c\<^sub>0, c\<^sub>1) ps"
>   by (induction "(c\<^sub>0, c\<^sub>1)" ps arbitrary: c\<^sub>0 c\<^sub>1 rule: find_closest_pair.induct)
>      (auto simp: Let_def find_closest_bf_eq_val_find_closest_bf_tm take_eq_val_take_tm)
> 
331c350
<         using def find_closest_pair_dist_mono by blast 
---
>         using def find_closest_pair_dist_mono by blast
357a377,385
> fun combine_tm :: "(point \<times> point) \<Rightarrow> (point \<times> point) \<Rightarrow> int \<Rightarrow> point list \<Rightarrow> (point \<times> point) tm" where
>   "combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps =1 (
>     let (c\<^sub>0, c\<^sub>1) = if dist p\<^sub>0\<^sub>L p\<^sub>1\<^sub>L < dist p\<^sub>0\<^sub>R p\<^sub>1\<^sub>R then (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) else (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) in
>     do {
>       ps' <- filter_tm (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps;
>       find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps'
>     }
>   )"
> 
364a393,396
> lemma combine_eq_val_combine_tm:
>   "val (combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps"
>   by (auto simp: filter_eq_val_filter_tm find_closest_pair_eq_val_find_closest_pair_tm)
> 
408c440
<   assumes "(c\<^sub>0, c\<^sub>1) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps" 
---
>   assumes "(c\<^sub>0, c\<^sub>1) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps"
455a488,490
> declare combine.simps [simp del]
> declare combine_tm.simps [simp del]
> 
457a493,520
> declare split_at_take_drop_conv [simp add]
> 
> function closest_pair_rec_tm :: "point list \<Rightarrow> (point list \<times> point \<times> point) tm" where
>   "closest_pair_rec_tm xs =1 (
>     do {
>       n <- length_tm xs;
>       if n \<le> 3 then
>         do {
>           ys <- mergesort_tm snd xs;
>           p <- closest_pair_bf_tm xs;
>           return (ys, p)
>         }
>       else
>         do {
>           (xs\<^sub>L, xs\<^sub>R) <- split_at_tm (n div 2) xs;
>           (ys\<^sub>L, p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) <- closest_pair_rec_tm xs\<^sub>L;
>           (ys\<^sub>R, p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) <- closest_pair_rec_tm xs\<^sub>R;
>           ys <- merge_tm snd ys\<^sub>L ys\<^sub>R;
>           (p\<^sub>0, p\<^sub>1) <- combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys;
>           return (ys, p\<^sub>0, p\<^sub>1)
>        }
>     }
>   )"
>   by pat_completeness auto
> termination closest_pair_rec_tm
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm)
> 
465,469c528,529
<       let l = fst (hd xs\<^sub>R) in
< 
<       let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<       let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
< 
---
>       let (ys\<^sub>L, p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) = closest_pair_rec xs\<^sub>L in
>       let (ys\<^sub>R, p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) = closest_pair_rec xs\<^sub>R in
471c531
<       (ys, combine p\<^sub>L p\<^sub>R l ys) 
---
>       (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys)
475,477c535,538
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp: Let_def)
> 
> declare split_at_take_drop_conv [simp del]
483,485c544,545
<     let l = fst (hd xs\<^sub>R) in
<     let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<     let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
---
>     let (ys\<^sub>L, p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) = closest_pair_rec xs\<^sub>L in
>     let (ys\<^sub>R, p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) = closest_pair_rec xs\<^sub>R in
487c547
<     (ys, combine p\<^sub>L p\<^sub>R l ys) 
---
>     (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys)
491c551,583
< declare combine.simps closest_pair_rec.simps [simp del]
---
> declare closest_pair_rec.simps [simp del]
> 
> lemma closest_pair_rec_eq_val_closest_pair_rec_tm:
>   "val (closest_pair_rec_tm xs) = closest_pair_rec xs"
> proof (induction rule: length_induct)
>   case (1 xs)
>   define n where "n = length xs"
>   obtain xs\<^sub>L xs\<^sub>R where xs_def: "(xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs"
>     by (metis surj_pair)
>   note defs = n_def xs_def
>   show ?case
>   proof cases
>     assume "n \<le> 3"
>     then show ?thesis
>       using defs
>       by (auto simp: length_eq_val_length_tm mergesort_eq_val_mergesort_tm
>                      closest_pair_bf_eq_val_closest_pair_bf_tm closest_pair_rec.simps)
>   next
>     assume asm: "\<not> n \<le> 3"
>     have "length xs\<^sub>L < length xs" "length xs\<^sub>R < length xs"
>       using asm defs by (auto simp: split_at_take_drop_conv)
>     hence "val (closest_pair_rec_tm xs\<^sub>L) = closest_pair_rec xs\<^sub>L"
>           "val (closest_pair_rec_tm xs\<^sub>R) = closest_pair_rec xs\<^sub>R"
>       using "1.IH" by blast+
>     thus ?thesis
>       using asm defs
>       apply (subst closest_pair_rec.simps, subst closest_pair_rec_tm.simps)
>       by (auto simp del: closest_pair_rec_tm.simps
>                simp add: Let_def length_eq_val_length_tm merge_eq_val_merge_tm
>                          split_at_eq_val_split_at_tm combine_eq_val_combine_tm
>                split: prod.split)
>   qed
> qed
578c670
<     ultimately have IH: "distinct YS\<^sub>L" "distinct YS\<^sub>R" 
---
>     ultimately have IH: "distinct YS\<^sub>L" "distinct YS\<^sub>R"
735a828,838
> fun closest_pair_tm :: "point list \<Rightarrow> (point * point) tm" where
>   "closest_pair_tm [] =1 return undefined"
> | "closest_pair_tm [_] =1 return undefined"
> | "closest_pair_tm ps =1 (
>     do {
>       xs <- mergesort_tm fst ps;
>       (_, p) <- closest_pair_rec_tm xs;
>       return p
>     }
>   )"
> 
740a844,850
> lemma closest_pair_eq_val_closest_pair_tm:
>   "val (closest_pair_tm ps) = closest_pair ps"
>   by (induction ps rule: induct_list012)
>      (auto simp del: closest_pair_rec_tm.simps mergesort_tm.simps
>            simp add: closest_pair_rec_eq_val_closest_pair_rec_tm mergesort_eq_val_mergesort_tm
>            split: prod.split)
> 
764,778c874,876
< fun t_find_closest_pair :: "point \<times> point \<Rightarrow> point list \<Rightarrow> nat" where
<   "t_find_closest_pair _ [] = 0"
< | "t_find_closest_pair _ [p\<^sub>0] = 1"
< | "t_find_closest_pair (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ps) = 1 + (
<     let p\<^sub>1 = find_closest_bf p\<^sub>0 (take 7 ps) in
<     t_take 7 ps + t_find_closest_bf p\<^sub>0 (take 7 ps) + (
<     if dist c\<^sub>0 c\<^sub>1 \<le> dist p\<^sub>0 p\<^sub>1 then
<       t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps
<     else
<       t_find_closest_pair (p\<^sub>0, p\<^sub>1) ps
<   ))"
< 
< lemma t_find_closest_pair:
<   "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps \<le> 16 * length ps"
< proof (induction ps rule: t_find_closest_pair.induct)
---
> lemma time_find_closest_pair_tm:
>   "time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps) \<le> 17 * length ps + 1"
> proof (induction ps rule: find_closest_pair_tm.induct)
781c879,881
<   let ?p\<^sub>1 = "find_closest_bf p\<^sub>0 (take 7 ?ps)"
---
>   let ?p\<^sub>1 = "val (find_closest_bf_tm p\<^sub>0 (val (take_tm 7 ?ps)))"
>   have *: "length (val (take_tm 7 ?ps)) \<le> 7"
>     by (subst take_eq_val_take_tm, simp)
785,790c885,890
<     hence "t_find_closest_pair (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ?ps) = 1 + t_take 7 ?ps +
<            t_find_closest_bf p\<^sub>0 (take 7 ?ps) + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ?ps"
<       by simp
<     also have "... \<le> 16 + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ?ps"
<       using t_take[of 7 ?ps] t_find_closest_bf by auto
<     also have "... \<le> 16 + 16 * (length ?ps)"
---
>     hence "time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ?ps)) = 1 + time (take_tm 7 ?ps) +
>            time (find_closest_bf_tm p\<^sub>0 (val (take_tm 7 ?ps))) + time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ?ps)"
>       by (auto simp: time_simps)
>     also have "... \<le> 17 + time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ?ps)"
>       using time_take_tm[of 7 ?ps] time_find_closest_bf_tm[of p\<^sub>0 "val (take_tm 7 ?ps)"] * by auto
>     also have "... \<le> 17 + 17 * (length ?ps) + 1"
792c892
<     also have "... = 16 * length (p\<^sub>0 # ?ps)"
---
>     also have "... = 17 * length (p\<^sub>0 # ?ps) + 1"
795c895
<   next 
---
>   next
797,802c897,902
<     hence "t_find_closest_pair (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ?ps) = 1 + t_take 7 ?ps +
<            t_find_closest_bf p\<^sub>0 (take 7 ?ps) + t_find_closest_pair (p\<^sub>0, ?p\<^sub>1) ?ps"
<       by simp
<     also have "... \<le> 16 + t_find_closest_pair (p\<^sub>0, ?p\<^sub>1) ?ps"
<       using t_take[of 7 ?ps] t_find_closest_bf by auto
<     also have "... \<le> 16 + 16 * (length ?ps)"
---
>     hence "time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ?ps)) = 1 + time (take_tm 7 ?ps) +
>            time (find_closest_bf_tm p\<^sub>0 (val (take_tm 7 ?ps))) + time (find_closest_pair_tm (p\<^sub>0, ?p\<^sub>1) ?ps)"
>       by (auto simp: time_simps)
>     also have "... \<le> 17 + time (find_closest_pair_tm (p\<^sub>0, ?p\<^sub>1) ?ps)"
>       using time_take_tm[of 7 ?ps] time_find_closest_bf_tm[of p\<^sub>0 "val (take_tm 7 ?ps)"] * by auto
>     also have "... \<le> 17 + 17 * (length ?ps) + 1"
804c904
<     also have "... = 16 * length (p\<^sub>0 # ?ps)"
---
>     also have "... = 17 * length (p\<^sub>0 # ?ps) + 1"
808,817c908
< qed simp_all
< 
< declare t_find_closest_pair.simps [simp del]
< 
< fun t_combine :: "(point * point) \<Rightarrow> (point * point) \<Rightarrow> int \<Rightarrow> point list \<Rightarrow> nat" where
<   "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps = (
<     let (c\<^sub>0, c\<^sub>1) = if dist p\<^sub>0\<^sub>L p\<^sub>1\<^sub>L < dist p\<^sub>0\<^sub>R p\<^sub>1\<^sub>R then (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) else (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) in
<     let ps' = filter (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps in
<     t_filter (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'
<   )"
---
> qed (auto simp: time_simps)
819c910
< lemma t_combine:
---
> lemma time_combine_tm:
821c912
<   shows "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps \<le> 17 * length ps"
---
>   shows "time (combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps) \<le> 3 + 18 * length ps"
826c917
<   define ps' where ps'_def: "ps' = filter ?P ps"
---
>   define ps' where "ps' = val (filter_tm ?P ps)"
828,838c919,927
<   have "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 16 * length ps'"
<     using t_find_closest_pair by blast
<   moreover have "length ps' \<le> length ps"
<     using ps'_def by simp
<   ultimately have *: "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 16 * length ps"
<     by simp
<   have "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps =
<         t_filter ?P ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
<     using defs by (auto split: prod.splits)
<   also have "... = length ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
<     using t_filter by auto
---
>   hence "time (combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps) = 1 + time (filter_tm ?P ps) +
>         time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps')"
>     by (auto simp: combine_tm.simps Let_def time_simps split: prod.split)
>   also have "... = 2 + length ps + time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps')"
>     using time_filter_tm by auto
>   also have "... \<le> 3 + length ps + 17 * length ps'"
>     using defs time_find_closest_pair_tm by simp
>   also have "... \<le> 3 + 18 * length ps"
>      unfolding ps'_def by (subst filter_eq_val_filter_tm, simp)
840c929
<     using * by simp
---
>     by blast
843,844d931
< declare t_combine.simps [simp del]
< 
847,890c934,947
< function t_closest_pair_rec :: "point list \<Rightarrow> nat" where
<   "t_closest_pair_rec xs = (
<     let n = length xs in
<     t_length xs + (
<     if n \<le> 3 then
<       t_mergesort snd xs + t_closest_pair_bf xs
<     else
<       let (xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs in
<       t_split_at (n div 2) xs + (
< 
<       let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<       t_closest_pair_rec xs\<^sub>L + (
<       let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
<       t_closest_pair_rec xs\<^sub>R + (
< 
<       let ys = merge (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R in
<       t_merge (\<lambda>p. snd p) (ys\<^sub>L, ys\<^sub>R) + t_combine p\<^sub>L p\<^sub>R (fst (hd xs\<^sub>R)) ys
<     ))))
<   )"
<   by pat_completeness auto
< termination t_closest_pair_rec
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
< 
< lemma t_closest_pair_rec_simps_1:
<   assumes "n = length xs" "n \<le> 3"
<   shows "t_closest_pair_rec xs = t_length xs + t_mergesort snd xs + t_closest_pair_bf xs"
<   using assms by simp
< 
< lemma t_closest_pair_rec_simps_2:
<   assumes "n = length xs" "\<not> (n \<le> 3)"
<   shows "t_closest_pair_rec xs = (
<     let (xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs in
<     let t_s = t_split_at (n div 2) xs in
<     let l = fst (hd xs\<^sub>R) in
<     let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<     let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
<     let t_cl = t_closest_pair_rec xs\<^sub>L in
<     let t_cr = t_closest_pair_rec xs\<^sub>R in
<     let ys = merge (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R in
<     let t_m = t_merge (\<lambda>p. snd p) (ys\<^sub>L, ys\<^sub>R) in
<     let t_c = t_combine p\<^sub>L p\<^sub>R l ys in
<     t_length xs + t_s + t_cl + t_cr + t_m + t_c
---
> lemma time_closest_pair_rec_tm_simps_1:
>   assumes "length xs \<le> 3"
>   shows "time (closest_pair_rec_tm xs) = 1 + time (length_tm xs) + time (mergesort_tm snd xs) + time (closest_pair_bf_tm xs)"
>   using assms by  (auto simp: time_simps length_eq_val_length_tm)
> 
> lemma time_closest_pair_rec_tm_simps_2:
>   assumes "\<not> (length xs \<le> 3)"
>   shows "time (closest_pair_rec_tm xs) = 1 + (
>     let (xs\<^sub>L, xs\<^sub>R) = val (split_at_tm (length xs div 2) xs) in
>     let (ys\<^sub>L, p\<^sub>L) = val (closest_pair_rec_tm xs\<^sub>L) in
>     let (ys\<^sub>R, p\<^sub>R) = val (closest_pair_rec_tm xs\<^sub>R) in
>     let ys = val (merge_tm (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R) in
>     time (length_tm xs) + time (split_at_tm (length xs div 2) xs) + time (closest_pair_rec_tm xs\<^sub>L) +
>     time (closest_pair_rec_tm xs\<^sub>R) + time (merge_tm (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R) + time (combine_tm p\<^sub>L p\<^sub>R (fst (hd xs\<^sub>R)) ys)
892,899c949,958
<   using assms by (auto simp add: Let_def split!: if_splits prod.splits)
< 
< declare t_closest_pair_rec.simps [simp del]
< 
< function closest_pair_rec_recurrence :: "nat \<Rightarrow> real" where
<   "n \<le> 3 \<Longrightarrow> closest_pair_rec_recurrence n = n + mergesort_recurrence n + n * n"
< | "3 < n \<Longrightarrow> closest_pair_rec_recurrence n = closest_pair_rec_recurrence (nat \<lfloor>real n / 2\<rfloor>) +
<     closest_pair_rec_recurrence (nat \<lceil>real n / 2\<rceil>) + 20 * n"
---
>   using assms
>   apply (subst closest_pair_rec_tm.simps)
>   by (auto simp del: closest_pair_rec_tm.simps
>            simp add: time_simps length_eq_val_length_tm
>               split: prod.split)
> 
> function closest_pair_recurrence :: "nat \<Rightarrow> real" where
>   "n \<le> 3 \<Longrightarrow> closest_pair_recurrence n = 3 + n + mergesort_recurrence n + n * n"
> | "3 < n \<Longrightarrow> closest_pair_recurrence n = 7 + 21 * n + closest_pair_recurrence (nat \<lfloor>real n / 2\<rfloor>) +
>     closest_pair_recurrence (nat \<lceil>real n / 2\<rceil>)"
903,905c962,964
< lemma closest_pair_rec_recurrence_nonneg[simp]:
<   "0 \<le> closest_pair_rec_recurrence n"
<   by (induction n rule: closest_pair_rec_recurrence.induct) auto
---
> lemma closest_pair_recurrence_nonneg[simp]:
>   "0 \<le> closest_pair_recurrence n"
>   by (induction n rule: closest_pair_recurrence.induct) auto
907,908c966,967
< lemma t_closest_pair_rec_conv_closest_pair_rec_recurrence:
<   "t_closest_pair_rec ps \<le> closest_pair_rec_recurrence (length ps)"
---
> lemma time_closest_pair_rec_conv_closest_pair_recurrence:
>   "time (closest_pair_rec_tm ps) \<le> closest_pair_recurrence (length ps)"
914,917c973,976
<     case True        
<     hence "t_closest_pair_rec ps =  t_length ps + t_mergesort snd ps + t_closest_pair_bf ps"
<       using t_closest_pair_rec_simps_1 by simp
<     moreover have "closest_pair_rec_recurrence ?n = ?n + mergesort_recurrence ?n + ?n * ?n"
---
>     case True
>     hence "time (closest_pair_rec_tm ps) = 1 + time (length_tm ps) + time (mergesort_tm snd ps) + time (closest_pair_bf_tm ps)"
>       using time_closest_pair_rec_tm_simps_1 by simp
>     moreover have "closest_pair_recurrence ?n = 3 + ?n + mergesort_recurrence ?n + ?n * ?n"
919,920c978,980
<     moreover have "t_length ps \<le> ?n" "t_mergesort snd ps \<le> mergesort_recurrence ?n" "t_closest_pair_bf ps \<le> ?n * ?n"
<       using t_length[of ps] t_mergesort_conv_mergesort_recurrence[of snd ps] t_closest_pair_bf[of ps] by auto
---
>     moreover have "time (length_tm ps) \<le> 1 + ?n" "time (mergesort_tm snd ps) \<le> mergesort_recurrence ?n"
>                   "time (closest_pair_bf_tm ps) \<le> 1 + ?n * ?n"
>       using time_length_tm[of ps] time_mergesort_conv_mergesort_recurrence[of snd ps] time_closest_pair_bf_tm[of ps] by auto
926c986
<     obtain XS\<^sub>L XS\<^sub>R where XS_def: "(XS\<^sub>L, XS\<^sub>R) = split_at (?n div 2) ps"
---
>     obtain XS\<^sub>L XS\<^sub>R where XS_def: "(XS\<^sub>L, XS\<^sub>R) = val (split_at_tm (?n div 2) ps)"
928,931c988
<     define TS where "TS = t_split_at (?n div 2) ps"
<     define L where "L = fst (hd XS\<^sub>R)"
< 
<     obtain YS\<^sub>L C\<^sub>0\<^sub>L C\<^sub>1\<^sub>L where CP\<^sub>L_def: "(YS\<^sub>L, C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) = closest_pair_rec XS\<^sub>L"
---
>     obtain YS\<^sub>L C\<^sub>0\<^sub>L C\<^sub>1\<^sub>L where CP\<^sub>L_def: "(YS\<^sub>L, C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) = val (closest_pair_rec_tm XS\<^sub>L)"
933,934c990
<     define TL where "TL = t_closest_pair_rec XS\<^sub>L"
<     obtain YS\<^sub>R C\<^sub>0\<^sub>R C\<^sub>1\<^sub>R where CP\<^sub>R_def: "(YS\<^sub>R, C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) = closest_pair_rec XS\<^sub>R"
---
>     obtain YS\<^sub>R C\<^sub>0\<^sub>R C\<^sub>1\<^sub>R where CP\<^sub>R_def: "(YS\<^sub>R, C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) = val (closest_pair_rec_tm XS\<^sub>R)"
936,941c992,993
<     define TR where "TR = t_closest_pair_rec XS\<^sub>R"
< 
<     define YS where "YS = merge (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R"
<     define TM where "TM = t_merge (\<lambda>p. snd p) (YS\<^sub>L, YS\<^sub>R)"
<     define TC where "TC = t_combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) L YS"
<     obtain C\<^sub>0 C\<^sub>1 where C\<^sub>0\<^sub>1_def: "(C\<^sub>0, C\<^sub>1) = combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) L YS"
---
>     define YS where "YS = val (merge_tm (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R)"
>     obtain C\<^sub>0 C\<^sub>1 where C\<^sub>0\<^sub>1_def: "(C\<^sub>0, C\<^sub>1) = val (combine_tm (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS)"
943,949c995
<     note defs = XS_def TS_def L_def CP\<^sub>L_def TL_def CP\<^sub>R_def TR_def YS_def TM_def TC_def
< 
<     have FL: "t_closest_pair_rec ps = t_length ps + TS + TL + TR + TM + TC"
<       using False t_closest_pair_rec_simps_2 defs by (auto simp: Let_def split!: if_splits prod.splits)
<     have FR: "closest_pair_rec_recurrence (length ps) = closest_pair_rec_recurrence (nat \<lfloor>real ?n / 2\<rfloor>) +
<               closest_pair_rec_recurrence (nat \<lceil>real ?n / 2\<rceil>) + 20 * ?n"
<       using False by simp
---
>     note defs = XS_def CP\<^sub>L_def CP\<^sub>R_def YS_def C\<^sub>0\<^sub>1_def
952c998
<       using defs by (auto simp: split_at_take_drop_conv)
---
>       using defs by (auto simp: split_at_take_drop_conv split_at_eq_val_split_at_tm)
958c1004
<       using defs closest_pair_rec_set_length_sorted_snd by metis+
---
>       using defs closest_pair_rec_set_length_sorted_snd closest_pair_rec_eq_val_closest_pair_rec_tm by metis+
962c1008
<     have "length XS\<^sub>L < length ps"
---
>     have "1 < length XS\<^sub>L" "length XS\<^sub>L < length ps"
964c1010
<     hence "t_closest_pair_rec XS\<^sub>L \<le> closest_pair_rec_recurrence (length XS\<^sub>L)"
---
>     hence "time (closest_pair_rec_tm XS\<^sub>L) \<le> closest_pair_recurrence (length XS\<^sub>L)"
966c1012
<     hence IHL: "t_closest_pair_rec XS\<^sub>L \<le> closest_pair_rec_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
---
>     hence IHL: "time (closest_pair_rec_tm XS\<^sub>L) \<le> closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
969c1015
<     have "length XS\<^sub>R < length ps"
---
>     have "1 < length XS\<^sub>R" "length XS\<^sub>R < length ps"
971c1017
<     hence "t_closest_pair_rec XS\<^sub>R \<le> closest_pair_rec_recurrence (length XS\<^sub>R)"
---
>     hence "time (closest_pair_rec_tm XS\<^sub>R) \<le> closest_pair_recurrence (length XS\<^sub>R)"
973c1019
<     hence IHR: "t_closest_pair_rec XS\<^sub>R \<le> closest_pair_rec_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
---
>     hence IHR: "time (closest_pair_rec_tm XS\<^sub>R) \<le> closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
976,977c1022,1023
<     have "(YS, C\<^sub>0, C\<^sub>1) = closest_pair_rec ps"
<       using False closest_pair_rec_simps defs C\<^sub>0\<^sub>1_def by (auto simp: Let_def split: prod.split)
---
>     have "(YS, C\<^sub>0, C\<^sub>1) = val (closest_pair_rec_tm ps)"
>       using False closest_pair_rec_simps defs by (auto simp: Let_def length_eq_val_length_tm split!: prod.split)
979,993c1025,1041
<       using "1.prems" closest_pair_rec_set_length_sorted_snd by auto
<     hence "TC \<le> 17 * ?n"
<       using t_combine TC_def by simp
<     moreover have "t_length ps = ?n"
<       using t_length by blast
<     moreover have "TS \<le> ?n"
<       using t_split_at TS_def by blast
<     moreover have "TL \<le> closest_pair_rec_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
<       using IHL TL_def by blast
<     moreover have "TR \<le> closest_pair_rec_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
<       using IHR TR_def by blast
<     moreover have "TM \<le> ?n"
<       using L t_merge TM_def by auto
<     ultimately show ?thesis
<       using FL FR by linarith
---
>       using closest_pair_rec_set_length_sorted_snd closest_pair_rec_eq_val_closest_pair_rec_tm by auto
>     hence combine_bound: "time (combine_tm (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS) \<le> 3 + 18 * ?n"
>       using time_combine_tm by simp
>     have "time (closest_pair_rec_tm ps) = 1 + time (length_tm ps) + time (split_at_tm (?n div 2) ps) +
>               time (closest_pair_rec_tm XS\<^sub>L) + time (closest_pair_rec_tm XS\<^sub>R) + time (merge_tm (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R) +
>               time (combine_tm (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS)"
>       using time_closest_pair_rec_tm_simps_2[OF False] defs
>       by (auto simp del: closest_pair_rec_tm.simps simp add: Let_def split: prod.split)
>     also have "... \<le> 7 + 21 * ?n + time (closest_pair_rec_tm XS\<^sub>L) + time (closest_pair_rec_tm XS\<^sub>R)"
>       using time_merge_tm[of "(\<lambda>p. snd p)" YS\<^sub>L YS\<^sub>R] L combine_bound by (simp add: time_length_tm time_split_at_tm)
>     also have "... \<le> 7 + 21 * ?n + closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>) +
>               closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
>       using IHL IHR by simp
>     also have "... = closest_pair_recurrence (length ps)"
>       using False by simp
>     finally show ?thesis
>       by simp
997,998c1045,1046
< theorem closest_pair_rec_recurrence:
<   "closest_pair_rec_recurrence \<in> \<Theta>(\<lambda>n. n * ln n)"
---
> theorem closest_pair_recurrence:
>   "closest_pair_recurrence \<in> \<Theta>(\<lambda>n. n * ln n)"
1000,1002c1048,1050
<  
< theorem t_closest_pair_rec_bigo:
<   "t_closest_pair_rec \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
---
> 
> theorem time_closest_pair_rec_bigo:
>   "(\<lambda>xs. time (closest_pair_rec_tm xs)) \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
1004,1005c1052,1053
<   have 0: "\<And>ps. t_closest_pair_rec ps \<le> (closest_pair_rec_recurrence o length) ps"
<     unfolding comp_def using t_closest_pair_rec_conv_closest_pair_rec_recurrence by auto
---
>   have 0: "\<And>ps. time (closest_pair_rec_tm ps) \<le> (closest_pair_recurrence o length) ps"
>     unfolding comp_def using time_closest_pair_rec_conv_closest_pair_recurrence by auto
1007c1055
<     using bigo_measure_trans[OF 0] bigthetaD1[OF closest_pair_rec_recurrence] of_nat_0_le_iff by blast
---
>     using bigo_measure_trans[OF 0] bigthetaD1[OF closest_pair_recurrence] of_nat_0_le_iff by blast
1010,1012d1057
< definition t_closest_pair :: "point list \<Rightarrow> nat" where
<   "t_closest_pair ps = t_mergesort fst ps + t_closest_pair_rec (mergesort fst ps)"
< 
1014c1059
<   "closest_pair_time n = mergesort_recurrence n + closest_pair_rec_recurrence n"
---
>   "closest_pair_time n = 1 + mergesort_recurrence n + closest_pair_recurrence n"
1016,1020c1061,1078
< lemma t_closest_pair_conv_closest_pair_recurrence:
<   "t_closest_pair ps \<le> closest_pair_time (length ps)"
<   unfolding t_closest_pair_def closest_pair_time_def
<   using t_closest_pair_rec_conv_closest_pair_rec_recurrence[of "mergesort fst ps"] t_mergesort_conv_mergesort_recurrence[of fst ps]
<   by (simp add: mergesort sorted_fst_def)
---
> lemma time_closest_pair_conv_closest_pair_recurrence:
>   "time (closest_pair_tm ps) \<le> closest_pair_time (length ps)"
>   unfolding closest_pair_time_def
> proof (induction rule: induct_list012)
>   case (3 x y zs)
>   let ?ps = "x # y # zs"
>   define xs where "xs = val (mergesort_tm fst ?ps)"
>   have *: "length xs = length ?ps"
>     using xs_def mergesort(3)[of fst ?ps] mergesort_eq_val_mergesort_tm by metis
>   have "time (closest_pair_tm ?ps) = 1 + time (mergesort_tm fst ?ps) + time (closest_pair_rec_tm xs)"
>     using xs_def by (auto simp del: mergesort_tm.simps closest_pair_rec_tm.simps simp add: time_simps split: prod.split)
>   also have "... \<le> 1 + mergesort_recurrence (length ?ps) + time (closest_pair_rec_tm xs)"
>     using time_mergesort_conv_mergesort_recurrence[of fst ?ps] by simp
>   also have "... \<le> 1 + mergesort_recurrence (length ?ps) + closest_pair_recurrence (length ?ps)"
>     using time_closest_pair_rec_conv_closest_pair_recurrence[of xs] * by auto
>   finally show ?case
>     by blast
> qed (auto simp: time_simps)
1022c1080
< corollary closest_pair_recurrence:
---
> corollary closest_pair_time:
1024c1082,1083
<   unfolding closest_pair_time_def using mergesort_recurrence closest_pair_rec_recurrence sum_in_bigo(1) by blast
---
>   unfolding closest_pair_time_def
>   using mergesort_recurrence closest_pair_recurrence sum_in_bigo(1) const_1_bigo_n_ln_n by blast
1026,1027c1085,1086
< corollary t_closest_pair_bigo:
<   "t_closest_pair \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
---
> corollary time_closest_pair_bigo:
>   "(\<lambda>ps. time (closest_pair_tm ps)) \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
1029,1030c1088,1089
<   have 0: "\<And>ps. t_closest_pair ps \<le> (closest_pair_time o length) ps"
<     unfolding comp_def using t_closest_pair_conv_closest_pair_recurrence by auto
---
>   have 0: "\<And>ps. time (closest_pair_tm ps) \<le> (closest_pair_time o length) ps"
>     unfolding comp_def using time_closest_pair_conv_closest_pair_recurrence by auto
1032c1091
<     using bigo_measure_trans[OF 0] closest_pair_recurrence by fastforce
---
>     using bigo_measure_trans[OF 0] closest_pair_time by simp
1182c1241
<     using assms(3) defs(1,3,5) apply (auto split: prod.splits) by (metis Pair_inject)+
---
>     using assms(3) defs(1,3,5) apply (auto simp: combine.simps split: prod.splits) by (metis Pair_inject)+
1204c1263
<       (ys, combine_code p\<^sub>L p\<^sub>R l ys) 
---
>       (ys, combine_code p\<^sub>L p\<^sub>R l ys)
1208,1210c1267,1268
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp: split_at_take_drop_conv Let_def)
1220c1278
<     (ys, combine_code p\<^sub>L p\<^sub>R l ys) 
---
>     (ys, combine_code p\<^sub>L p\<^sub>R l ys)
1438c1496
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Closest_Pair_Points/Closest_Pair.thy ../../AFPs/afp-2020/thys/Closest_Pair_Points/Closest_Pair.thy
8,9c8,9
<   Formalization of a divide-and-conquer algorithm solving the Closest Pair Problem based
<   on the presentation of Cormen \emph{et al.} \cite{Introduction-to-Algorithms:2009}.
---
>   Formalization of a slightly optimized divide-and-conquer algorithm solving the Closest Pair Problem
>   based on the presentation of Cormen \emph{et al.} \cite{Introduction-to-Algorithms:2009}.
15a16,31
> fun find_closest_tm :: "point \<Rightarrow> real \<Rightarrow> point list \<Rightarrow> point tm" where
>   "find_closest_tm _ _ [] =1 return undefined"
> | "find_closest_tm _ _ [p] =1 return p"
> | "find_closest_tm p \<delta> (p\<^sub>0 # ps) =1 (
>     if \<delta> \<le> snd p\<^sub>0 - snd p then
>       return p\<^sub>0
>     else
>       do {
>         p\<^sub>1 <- find_closest_tm p (min \<delta> (dist p p\<^sub>0)) ps;
>         if dist p p\<^sub>0 \<le> dist p p\<^sub>1 then
>           return p\<^sub>0
>         else
>           return p\<^sub>1
>       }
>   )"
> 
29a46,49
> lemma find_closest_eq_val_find_closest_tm:
>   "val (find_closest_tm p \<delta> ps) = find_closest p \<delta> ps"
>   by (induction p \<delta> ps rule: find_closest.induct) (auto simp: Let_def)
> 
82c102,115
< fun find_closest_pair :: "(point * point) \<Rightarrow> point list \<Rightarrow> (point * point)" where
---
> fun find_closest_pair_tm :: "(point * point) \<Rightarrow> point list \<Rightarrow> (point \<times> point) tm" where
>   "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) [] =1 return (c\<^sub>0, c\<^sub>1)"
> | "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) [_] =1 return (c\<^sub>0, c\<^sub>1)"
> | "find_closest_pair_tm (c\<^sub>0, c\<^sub>1) (p\<^sub>0 # ps) =1 (
>     do {
>       p\<^sub>1 <- find_closest_tm p\<^sub>0 (dist c\<^sub>0 c\<^sub>1) ps;
>       if dist c\<^sub>0 c\<^sub>1 \<le> dist p\<^sub>0 p\<^sub>1 then
>         find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps
>       else
>         find_closest_pair_tm (p\<^sub>0, p\<^sub>1) ps
>     }
>   )"
> 
> fun find_closest_pair :: "(point * point) \<Rightarrow> point list \<Rightarrow> (point \<times> point)" where
92a126,130
> lemma find_closest_pair_eq_val_find_closest_pair_tm:
>   "val (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps) = find_closest_pair (c\<^sub>0, c\<^sub>1) ps"
>   by (induction "(c\<^sub>0, c\<^sub>1)" ps arbitrary: c\<^sub>0 c\<^sub>1 rule: find_closest_pair.induct)
>      (auto simp: Let_def find_closest_eq_val_find_closest_tm)
> 
111c149
<       using defs True "3.prems" apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs True "3.prems" by (auto split: prod.splits, metis Pair_inject)+
122c160
<       using defs False "3.prems" apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs False "3.prems" by (auto split: prod.splits, metis Pair_inject)+
145c183
<       using defs True "3.prems"(3) apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs True "3.prems"(3) by (auto split: prod.splits, metis Pair_inject)+
156c194
<       using defs False "3.prems"(3) apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs False "3.prems"(3) by (auto split: prod.splits, metis Pair_inject)+
178c216
<       using defs True "3.prems" apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs True "3.prems" by (auto split: prod.splits, metis Pair_inject)+
189c227
<       using defs False "3.prems"(1) apply (auto split: prod.splits) by (metis Pair_inject)+
---
>       using defs False "3.prems"(1) by (auto split: prod.splits, metis Pair_inject)+
240c278,287
< fun combine :: "(point * point) \<Rightarrow> (point * point) \<Rightarrow> int \<Rightarrow> point list \<Rightarrow> (point * point)" where
---
> fun combine_tm :: "(point \<times> point) \<Rightarrow> (point \<times> point) \<Rightarrow> int \<Rightarrow> point list \<Rightarrow> (point \<times> point) tm" where
>   "combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps =1 (
>     let (c\<^sub>0, c\<^sub>1) = if dist p\<^sub>0\<^sub>L p\<^sub>1\<^sub>L < dist p\<^sub>0\<^sub>R p\<^sub>1\<^sub>R then (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) else (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) in
>     do {
>       ps' <- filter_tm (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps;
>       find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps'
>     }
>   )"
> 
> fun combine :: "(point \<times> point) \<Rightarrow> (point \<times> point) \<Rightarrow> int \<Rightarrow> point list \<Rightarrow> (point \<times> point)" where
246a294,297
> lemma combine_eq_val_combine_tm:
>   "val (combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps"
>   by (auto simp: filter_eq_val_filter_tm find_closest_pair_eq_val_find_closest_pair_tm)
> 
290c341
<   assumes "(c\<^sub>0, c\<^sub>1) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps" 
---
>   assumes "(c\<^sub>0, c\<^sub>1) = combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps"
322a374,376
> declare combine.simps [simp del]
> declare combine_tm.simps[simp del]
> 
324a379,406
> declare split_at_take_drop_conv [simp add]
> 
> function closest_pair_rec_tm :: "point list \<Rightarrow> (point list \<times> point \<times> point) tm" where
>   "closest_pair_rec_tm xs =1 (
>     do {
>       n <- length_tm xs;
>       if n \<le> 3 then
>         do {
>           ys <- mergesort_tm snd xs;
>           p <- closest_pair_bf_tm xs;
>           return (ys, p)
>         }
>       else
>         do {
>           (xs\<^sub>L, xs\<^sub>R) <- split_at_tm (n div 2) xs;
>           (ys\<^sub>L, p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) <- closest_pair_rec_tm xs\<^sub>L;
>           (ys\<^sub>R, p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) <- closest_pair_rec_tm xs\<^sub>R;
>           ys <- merge_tm snd ys\<^sub>L ys\<^sub>R;
>           (p\<^sub>0, p\<^sub>1) <- combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys;
>           return (ys, p\<^sub>0, p\<^sub>1)
>        }
>     }
>   )"
>   by pat_completeness auto
> termination closest_pair_rec_tm
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm)
> 
332,333d413
<       let l = fst (hd xs\<^sub>R) in
< 
336d415
< 
338c417
<       (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ys) 
---
>       (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys)
342,344c421,424
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp: Let_def)
> 
> declare split_at_take_drop_conv [simp del]
350d429
<     let l = fst (hd xs\<^sub>R) in
354c433
<     (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ys) 
---
>     (ys, combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) (fst (hd xs\<^sub>R)) ys)
358c437,469
< declare combine.simps closest_pair_rec.simps [simp del]
---
> declare closest_pair_rec.simps [simp del]
> 
> lemma closest_pair_rec_eq_val_closest_pair_rec_tm:
>   "val (closest_pair_rec_tm xs) = closest_pair_rec xs"
> proof (induction rule: length_induct)
>   case (1 xs)
>   define n where "n = length xs"
>   obtain xs\<^sub>L xs\<^sub>R where xs_def: "(xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs"
>     by (metis surj_pair)
>   note defs = n_def xs_def
>   show ?case
>   proof cases
>     assume "n \<le> 3"
>     then show ?thesis
>       using defs
>       by (auto simp: length_eq_val_length_tm mergesort_eq_val_mergesort_tm
>                      closest_pair_bf_eq_val_closest_pair_bf_tm closest_pair_rec.simps)
>   next
>     assume asm: "\<not> n \<le> 3"
>     have "length xs\<^sub>L < length xs" "length xs\<^sub>R < length xs"
>       using asm defs by (auto simp: split_at_take_drop_conv)
>     hence "val (closest_pair_rec_tm xs\<^sub>L) = closest_pair_rec xs\<^sub>L"
>           "val (closest_pair_rec_tm xs\<^sub>R) = closest_pair_rec xs\<^sub>R"
>       using "1.IH" by blast+
>     thus ?thesis
>       using asm defs
>       apply (subst closest_pair_rec.simps, subst closest_pair_rec_tm.simps)
>       by (auto simp del: closest_pair_rec_tm.simps
>                simp add: Let_def length_eq_val_length_tm merge_eq_val_merge_tm
>                          split_at_eq_val_split_at_tm combine_eq_val_combine_tm
>                split: prod.split)
>   qed
> qed
445c556
<     ultimately have IH: "distinct YS\<^sub>L" "distinct YS\<^sub>R" 
---
>     ultimately have IH: "distinct YS\<^sub>L" "distinct YS\<^sub>R"
602a714,724
> fun closest_pair_tm :: "point list \<Rightarrow> (point * point) tm" where
>   "closest_pair_tm [] =1 return undefined"
> | "closest_pair_tm [_] =1 return undefined"
> | "closest_pair_tm ps =1 (
>     do {
>       xs <- mergesort_tm fst ps;
>       (_, p) <- closest_pair_rec_tm xs;
>       return p
>     }
>   )"
> 
606c728,735
< | "closest_pair ps = (let (_, c\<^sub>0, c\<^sub>1) = closest_pair_rec (mergesort fst ps) in (c\<^sub>0, c\<^sub>1))"
---
> | "closest_pair ps = (let (_, p) = closest_pair_rec (mergesort fst ps) in p)"
> 
> lemma closest_pair_eq_val_closest_pair_tm:
>   "val (closest_pair_tm ps) = closest_pair ps"
>   by (induction ps rule: induct_list012)
>      (auto simp del: closest_pair_rec_tm.simps mergesort_tm.simps
>            simp add: closest_pair_rec_eq_val_closest_pair_rec_tm mergesort_eq_val_mergesort_tm
>            split: prod.split)
609c738
<   "1 < length ps \<Longrightarrow> closest_pair ps = (let (_, c\<^sub>0, c\<^sub>1) = closest_pair_rec (mergesort fst ps) in (c\<^sub>0, c\<^sub>1))"
---
>   "1 < length ps \<Longrightarrow> closest_pair ps = (let (_, p) = closest_pair_rec (mergesort fst ps) in p)"
701c830
<   "t_find_closest _ _ [] = 0"
---
>   "t_find_closest _ _ [] = 1"
704,710c833,834
<     if \<delta> \<le> snd p\<^sub>0 - snd p then
<       0
<     else
<       let p\<^sub>1 = find_closest p (min \<delta> (dist p p\<^sub>0)) ps in
<       t_find_closest p (min \<delta> (dist p p\<^sub>0)) ps + (
<       if dist p p\<^sub>0 \<le> dist p p\<^sub>1 then 0 else 0
<     )
---
>     if \<delta> \<le> snd p\<^sub>0 - snd p then 0
>     else t_find_closest p (min \<delta> (dist p p\<^sub>0)) ps
712a837,841
> lemma t_find_closest_eq_time_find_closest_tm:
>   "t_find_closest p \<delta> ps = time (find_closest_tm p \<delta> ps)"
>   by (induction p \<delta> ps rule: t_find_closest.induct)
>      (auto simp: time_simps)
> 
715,718c844,845
<   apply (induction rule: t_find_closest.induct)
<   apply (auto simp: Let_def min_def)
<   apply (metis surj_pair)+
<   done
---
>   by (induction rule: t_find_closest.induct)
>      (auto simp: Let_def min_def)
724d850
<   define p\<^sub>1 where p\<^sub>1_def: "p\<^sub>1 = find_closest p (min \<delta> (dist p p\<^sub>0)) (p\<^sub>2 # ps)"
735c861
<       using False p\<^sub>1_def by simp
---
>       using False by simp
737c863
<       using False 3 p\<^sub>1_def by simp
---
>       using False 3 by simp
742c868
<     ultimately show ?thesis 
---
>     ultimately show ?thesis
747c873
< corollary t_find_closest:
---
> corollary t_find_closest_bound:
757c883
<   "t_find_closest_pair _ [] = 0"
---
>   "t_find_closest_pair _ [] = 1"
768c894,899
< lemma t_find_closest_pair:
---
> lemma t_find_closest_pair_eq_time_find_closest_pair_tm:
>   "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps = time (find_closest_pair_tm (c\<^sub>0, c\<^sub>1) ps)"
>   by (induction "(c\<^sub>0, c\<^sub>1)" ps arbitrary: c\<^sub>0 c\<^sub>1 rule: t_find_closest_pair.induct)
>      (auto simp: time_simps find_closest_eq_val_find_closest_tm t_find_closest_eq_time_find_closest_tm)
> 
> lemma t_find_closest_pair_bound:
773c904
<   shows "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps \<le> 9 * length ps"
---
>   shows "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps \<le> 9 * length ps + 1"
785c916
<     using t_find_closest[of p\<^sub>0 ?ps \<Delta> ps\<^sub>L ps\<^sub>R] "3.prems" by blast
---
>     using t_find_closest_bound[of p\<^sub>0 ?ps \<Delta> ps\<^sub>L ps\<^sub>R] "3.prems" by blast
794c925
<   have E: "\<forall>p \<in> PS\<^sub>L. fst p \<le> l" "\<forall>p \<in> PS\<^sub>R. l \<le> fst p" 
---
>   have E: "\<forall>p \<in> PS\<^sub>L. fst p \<le> l" "\<forall>p \<in> PS\<^sub>R. l \<le> fst p"
801c932
<     hence "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ?ps \<le> 9 * length ?ps"
---
>     hence "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ?ps \<le> 9 * length ?ps + 1"
812c943
<     ultimately have "t_find_closest_pair (p\<^sub>0, p\<^sub>1) ?ps \<le> 9 * length ?ps"
---
>     ultimately have "t_find_closest_pair (p\<^sub>0, p\<^sub>1) ?ps \<le> 9 * length ?ps + 1"
823c954
<   "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps = (
---
>   "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps = 1 + (
826c957
<     t_filter (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'
---
>     time (filter_tm (\<lambda>p. dist p (l, snd p) < dist c\<^sub>0 c\<^sub>1) ps) + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'
829c960,964
< lemma t_combine:
---
> lemma t_combine_eq_time_combine_tm:
>   "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps = time (combine_tm (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps)"
>   by (auto simp: combine_tm.simps time_simps t_find_closest_pair_eq_time_find_closest_pair_tm filter_eq_val_filter_tm)
> 
> lemma t_combine_bound:
834c969
<   shows "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps \<le> 10 * length ps"
---
>   shows "t_combine (p\<^sub>0\<^sub>L, p\<^sub>1\<^sub>L) (p\<^sub>0\<^sub>R, p\<^sub>1\<^sub>R) l ps \<le> 10 * length ps + 3"
840c975
<   define ps\<^sub>L' where ps\<^sub>L'_def: "ps\<^sub>L' = { p \<in> ps\<^sub>L. ?P p }" 
---
>   define ps\<^sub>L' where ps\<^sub>L'_def: "ps\<^sub>L' = { p \<in> ps\<^sub>L. ?P p }"
859,860c994,995
<   ultimately have "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 9 * length ps'"
<     using t_find_closest_pair by blast
---
>   ultimately have "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 9 * length ps' + 1"
>     using t_find_closest_pair_bound by blast
863c998
<   ultimately have *: "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 9 * length ps"
---
>   ultimately have *: "t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps' \<le> 9 * length ps + 1"
866c1001
<         t_filter ?P ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
---
>         1 + time (filter_tm ?P ps) + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
868,869c1003,1004
<   also have "... = length ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
<     using t_filter by auto
---
>   also have "... = 2 + length ps + t_find_closest_pair (c\<^sub>0, c\<^sub>1) ps'"
>     using time_filter_tm by auto
878,921c1013,1026
< function t_closest_pair_rec :: "point list \<Rightarrow> nat" where
<   "t_closest_pair_rec xs = (
<     let n = length xs in
<     t_length xs + (
<     if n \<le> 3 then
<       t_mergesort snd xs + t_closest_pair_bf xs
<     else
<       let (xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs in
<       t_split_at (n div 2) xs + (
< 
<       let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<       t_closest_pair_rec xs\<^sub>L + (
<       let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
<       t_closest_pair_rec xs\<^sub>R + (
< 
<       let ys = merge (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R in
<       t_merge (\<lambda>p. snd p) (ys\<^sub>L, ys\<^sub>R) + t_combine p\<^sub>L p\<^sub>R (fst (hd xs\<^sub>R)) ys
<     ))))
<   )"
<   by pat_completeness auto
< termination t_closest_pair_rec
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
< 
< lemma t_closest_pair_rec_simps_1:
<   assumes "n = length xs" "n \<le> 3"
<   shows "t_closest_pair_rec xs = t_length xs + t_mergesort snd xs + t_closest_pair_bf xs"
<   using assms by simp
< 
< lemma t_closest_pair_rec_simps_2:
<   assumes "n = length xs" "\<not> (n \<le> 3)"
<   shows "t_closest_pair_rec xs = (
<     let (xs\<^sub>L, xs\<^sub>R) = split_at (n div 2) xs in
<     let t_s = t_split_at (n div 2) xs in
<     let l = fst (hd xs\<^sub>R) in
<     let (ys\<^sub>L, p\<^sub>L) = closest_pair_rec xs\<^sub>L in
<     let (ys\<^sub>R, p\<^sub>R) = closest_pair_rec xs\<^sub>R in
<     let t_cl = t_closest_pair_rec xs\<^sub>L in
<     let t_cr = t_closest_pair_rec xs\<^sub>R in
<     let ys = merge (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R in
<     let t_m = t_merge (\<lambda>p. snd p) (ys\<^sub>L, ys\<^sub>R) in
<     let t_c = t_combine p\<^sub>L p\<^sub>R l ys in
<     t_length xs + t_s + t_cl + t_cr + t_m + t_c
---
> lemma time_closest_pair_rec_tm_simps_1:
>   assumes "length xs \<le> 3"
>   shows "time (closest_pair_rec_tm xs) = 1 + time (length_tm xs) + time (mergesort_tm snd xs) + time (closest_pair_bf_tm xs)"
>   using assms by  (auto simp: time_simps length_eq_val_length_tm)
> 
> lemma time_closest_pair_rec_tm_simps_2:
>   assumes "\<not> (length xs \<le> 3)"
>   shows "time (closest_pair_rec_tm xs) = 1 + (
>     let (xs\<^sub>L, xs\<^sub>R) = val (split_at_tm (length xs div 2) xs) in
>     let (ys\<^sub>L, p\<^sub>L) = val (closest_pair_rec_tm xs\<^sub>L) in
>     let (ys\<^sub>R, p\<^sub>R) = val (closest_pair_rec_tm xs\<^sub>R) in
>     let ys = val (merge_tm (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R) in
>     time (length_tm xs) + time (split_at_tm (length xs div 2) xs) + time (closest_pair_rec_tm xs\<^sub>L) +
>     time (closest_pair_rec_tm xs\<^sub>R) + time (merge_tm (\<lambda>p. snd p) ys\<^sub>L ys\<^sub>R) + t_combine p\<^sub>L p\<^sub>R (fst (hd xs\<^sub>R)) ys
923,925c1028,1032
<   using assms by (auto simp add: Let_def split!: if_splits prod.splits)
< 
< declare t_closest_pair_rec.simps [simp del]
---
>   using assms
>   apply (subst closest_pair_rec_tm.simps)
>   by (auto simp del: closest_pair_rec_tm.simps
>            simp add: time_simps length_eq_val_length_tm t_combine_eq_time_combine_tm
>               split: prod.split)
928,929c1035,1036
<   "n \<le> 3 \<Longrightarrow> closest_pair_recurrence n = n + mergesort_recurrence n + n * n"
< | "3 < n \<Longrightarrow> closest_pair_recurrence n = 13 * n + 
---
>   "n \<le> 3 \<Longrightarrow> closest_pair_recurrence n = 3 + n + mergesort_recurrence n + n * n"
> | "3 < n \<Longrightarrow> closest_pair_recurrence n = 7 + 13 * n +
938c1045
< lemma t_closest_pair_rec_conv_closest_pair_recurrence:
---
> lemma time_closest_pair_rec_conv_closest_pair_recurrence:
940c1047
<   shows "t_closest_pair_rec ps \<le> closest_pair_recurrence (length ps)"
---
>   shows "time (closest_pair_rec_tm ps) \<le> closest_pair_recurrence (length ps)"
947,950c1054,1057
<     case True        
<     hence "t_closest_pair_rec ps = t_length ps + t_mergesort snd ps + t_closest_pair_bf ps"
<       using t_closest_pair_rec_simps_1 by simp
<     moreover have "closest_pair_recurrence ?n = ?n + mergesort_recurrence ?n + ?n * ?n"
---
>     case True
>     hence "time (closest_pair_rec_tm ps) = 1 + time (length_tm ps) + time (mergesort_tm snd ps) + time (closest_pair_bf_tm ps)"
>       using time_closest_pair_rec_tm_simps_1 by simp
>     moreover have "closest_pair_recurrence ?n = 3 + ?n + mergesort_recurrence ?n + ?n * ?n"
952,953c1059,1061
<     moreover have "t_length ps \<le> ?n" "t_mergesort snd ps \<le> mergesort_recurrence ?n" "t_closest_pair_bf ps \<le> ?n * ?n"
<       using t_length[of ps] t_mergesort_conv_mergesort_recurrence[of snd ps] t_closest_pair_bf[of ps] by auto
---
>     moreover have "time (length_tm ps) \<le> 1 + ?n" "time (mergesort_tm snd ps) \<le> mergesort_recurrence ?n"
>                   "time (closest_pair_bf_tm ps) \<le> 1 + ?n * ?n"
>       using time_length_tm[of ps] time_mergesort_conv_mergesort_recurrence[of snd ps] time_closest_pair_bf_tm[of ps] by auto
959c1067
<     obtain XS\<^sub>L XS\<^sub>R where XS_def: "(XS\<^sub>L, XS\<^sub>R) = split_at (?n div 2) ps"
---
>     obtain XS\<^sub>L XS\<^sub>R where XS_def: "(XS\<^sub>L, XS\<^sub>R) = val (split_at_tm (?n div 2) ps)"
961,964c1069
<     define TS where "TS = t_split_at (?n div 2) ps"
<     define L where "L = fst (hd XS\<^sub>R)"
< 
<     obtain YS\<^sub>L C\<^sub>0\<^sub>L C\<^sub>1\<^sub>L where CP\<^sub>L_def: "(YS\<^sub>L, C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) = closest_pair_rec XS\<^sub>L"
---
>     obtain YS\<^sub>L C\<^sub>0\<^sub>L C\<^sub>1\<^sub>L where CP\<^sub>L_def: "(YS\<^sub>L, C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) = val (closest_pair_rec_tm XS\<^sub>L)"
966,967c1071
<     define TL where "TL = t_closest_pair_rec XS\<^sub>L"
<     obtain YS\<^sub>R C\<^sub>0\<^sub>R C\<^sub>1\<^sub>R where CP\<^sub>R_def: "(YS\<^sub>R, C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) = closest_pair_rec XS\<^sub>R"
---
>     obtain YS\<^sub>R C\<^sub>0\<^sub>R C\<^sub>1\<^sub>R where CP\<^sub>R_def: "(YS\<^sub>R, C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) = val (closest_pair_rec_tm XS\<^sub>R)"
969,974c1073,1074
<     define TR where "TR = t_closest_pair_rec XS\<^sub>R"
< 
<     define YS where "YS = merge (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R"
<     define TM where "TM = t_merge (\<lambda>p. snd p) (YS\<^sub>L, YS\<^sub>R)"
<     define TC where "TC = t_combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) L YS"
<     obtain C\<^sub>0 C\<^sub>1 where C\<^sub>0\<^sub>1_def: "(C\<^sub>0, C\<^sub>1) = combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) L YS"
---
>     define YS where "YS = val (merge_tm (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R)"
>     obtain C\<^sub>0 C\<^sub>1 where C\<^sub>0\<^sub>1_def: "(C\<^sub>0, C\<^sub>1) = val (combine_tm (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS)"
976,982c1076
<     note defs = XS_def TS_def L_def CP\<^sub>L_def TL_def CP\<^sub>R_def TR_def YS_def TM_def TC_def
< 
<     have FL: "t_closest_pair_rec ps = t_length ps + TS + TL + TR + TM + TC"
<       using False t_closest_pair_rec_simps_2 defs by (auto simp: Let_def split!: if_splits prod.splits)
<     have FR: "closest_pair_recurrence (length ps) = closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>) +
<               closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>) + 13 * ?n"
<       using False by simp
---
>     note defs = XS_def CP\<^sub>L_def CP\<^sub>R_def YS_def C\<^sub>0\<^sub>1_def
985c1079
<       using defs by (auto simp: split_at_take_drop_conv)
---
>       using defs by (auto simp: split_at_take_drop_conv split_at_eq_val_split_at_tm)
991c1085
<       using defs closest_pair_rec_set_length_sorted_snd by metis+
---
>       using defs closest_pair_rec_set_length_sorted_snd closest_pair_rec_eq_val_closest_pair_rec_tm by metis+
999c1093
<     ultimately have "t_closest_pair_rec XS\<^sub>L \<le> closest_pair_recurrence (length XS\<^sub>L)"
---
>     ultimately have "time (closest_pair_rec_tm XS\<^sub>L) \<le> closest_pair_recurrence (length XS\<^sub>L)"
1001c1095
<     hence IHL: "t_closest_pair_rec XS\<^sub>L \<le> closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
---
>     hence IHL: "time (closest_pair_rec_tm XS\<^sub>L) \<le> closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
1008c1102
<     ultimately have "t_closest_pair_rec XS\<^sub>R \<le> closest_pair_recurrence (length XS\<^sub>R)"
---
>     ultimately have "time (closest_pair_rec_tm XS\<^sub>R) \<le> closest_pair_recurrence (length XS\<^sub>R)"
1010c1104
<     hence IHR: "t_closest_pair_rec XS\<^sub>R \<le> closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
---
>     hence IHR: "time (closest_pair_rec_tm XS\<^sub>R) \<le> closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
1013,1014c1107,1108
<     have "(YS, C\<^sub>0, C\<^sub>1) = closest_pair_rec ps"
<       using False closest_pair_rec_simps defs C\<^sub>0\<^sub>1_def by (auto simp: Let_def split: prod.split)
---
>     have "(YS, C\<^sub>0, C\<^sub>1) = val (closest_pair_rec_tm ps)"
>       using False closest_pair_rec_simps defs by (auto simp: Let_def length_eq_val_length_tm split!: prod.split)
1016,1017c1110,1112
<       using "1.prems" closest_pair_rec_set_length_sorted_snd closest_pair_rec_distinct by auto
<     moreover have "\<forall>p \<in> set YS\<^sub>L. fst p \<le> L"
---
>       using "1.prems" closest_pair_rec_set_length_sorted_snd closest_pair_rec_distinct
>             closest_pair_rec_eq_val_closest_pair_rec_tm by auto
>     moreover have "\<forall>p \<in> set YS\<^sub>L. fst p \<le> fst (hd XS\<^sub>R)"
1019,1022c1114,1118
<             L_def CP\<^sub>L_def sorted_fst_take_less_hd_drop closest_pair_rec_set_length_sorted_snd by metis
<     moreover have "\<forall>p \<in> set YS\<^sub>R. L \<le> fst p"
<       using False "1.prems"(2) XSLR L_def CP\<^sub>R_def
<             sorted_fst_hd_drop_less_drop closest_pair_rec_set_length_sorted_snd by blast
---
>             CP\<^sub>L_def sorted_fst_take_less_hd_drop closest_pair_rec_set_length_sorted_snd
>             closest_pair_rec_eq_val_closest_pair_rec_tm by metis
>     moreover have "\<forall>p \<in> set YS\<^sub>R. fst (hd XS\<^sub>R) \<le> fst p"
>       using False "1.prems"(2) XSLR CP\<^sub>R_def sorted_fst_hd_drop_less_drop
>             closest_pair_rec_set_length_sorted_snd closest_pair_rec_eq_val_closest_pair_rec_tm by metis
1024c1120
<       using set_merge defs by fast
---
>       using set_merge defs by (metis merge_eq_val_merge_tm)
1027c1123,1124
<             closest_pair_rec_dist closest_pair_rec_set_length_sorted_snd by auto
---
>             closest_pair_rec_dist closest_pair_rec_set_length_sorted_snd
>             closest_pair_rec_eq_val_closest_pair_rec_tm by auto
1030,1044c1127,1144
<             closest_pair_rec_dist closest_pair_rec_set_length_sorted_snd by auto
<     ultimately have "TC \<le> 10 * ?n"
<       using t_combine TC_def by presburger
<     moreover have "t_length ps = ?n"
<       using t_length by blast
<     moreover have "TS \<le> ?n"
<       using t_split_at TS_def by blast
<     moreover have "TL \<le> closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>)"
<       using IHL TL_def by blast
<     moreover have "TR \<le> closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
<       using IHR TR_def by blast
<     moreover have "TM \<le> ?n"
<       using L t_merge TM_def by auto
<     ultimately show ?thesis
<       using FL FR by linarith
---
>             closest_pair_rec_dist closest_pair_rec_set_length_sorted_snd
>             closest_pair_rec_eq_val_closest_pair_rec_tm by auto
>     ultimately have combine_bound: "t_combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS \<le> 3 + 10 * ?n"
>       using t_combine_bound[of YS "set YS\<^sub>L" "set YS\<^sub>R" "fst (hd XS\<^sub>R)"] by (simp add: add.commute)
>     have "time (closest_pair_rec_tm ps) = 1 + time (length_tm ps) + time (split_at_tm (?n div 2) ps) +
>               time (closest_pair_rec_tm XS\<^sub>L) + time (closest_pair_rec_tm XS\<^sub>R) + time (merge_tm (\<lambda>p. snd p) YS\<^sub>L YS\<^sub>R) +
>               t_combine (C\<^sub>0\<^sub>L, C\<^sub>1\<^sub>L) (C\<^sub>0\<^sub>R, C\<^sub>1\<^sub>R) (fst (hd XS\<^sub>R)) YS"
>       using time_closest_pair_rec_tm_simps_2[OF False] defs
>       by (auto simp del: closest_pair_rec_tm.simps simp add: Let_def split: prod.split)
>     also have "... \<le> 7 + 13 * ?n + time (closest_pair_rec_tm XS\<^sub>L) + time (closest_pair_rec_tm XS\<^sub>R)"
>       using time_merge_tm[of "(\<lambda>p. snd p)" YS\<^sub>L YS\<^sub>R] L combine_bound by (simp add: time_length_tm time_split_at_tm)
>     also have "... \<le> 7 + 13 * ?n + closest_pair_recurrence (nat \<lfloor>real ?n / 2\<rfloor>) +
>               closest_pair_recurrence (nat \<lceil>real ?n / 2\<rceil>)"
>       using IHL IHR by simp
>     also have "... = closest_pair_recurrence (length ps)"
>       using False by simp
>     finally show ?thesis
>       by simp
1051,1053c1151,1153
<  
< theorem t_closest_pair_rec_bigo:
<   "t_closest_pair_rec \<in> O[length going_to at_top within { ps. distinct ps \<and> sorted_fst ps }]((\<lambda>n. n * ln n) o length)"
---
> 
> theorem time_closest_pair_rec_bigo:
>   "(\<lambda>xs. time (closest_pair_rec_tm xs)) \<in> O[length going_to at_top within { ps. distinct ps \<and> sorted_fst ps }]((\<lambda>n. n * ln n) o length)"
1056,1057c1156,1157
<            t_closest_pair_rec ps \<le> (closest_pair_recurrence o length) ps"
<     unfolding comp_def using t_closest_pair_rec_conv_closest_pair_recurrence by auto
---
>            time (closest_pair_rec_tm ps) \<le> (closest_pair_recurrence o length) ps"
>     unfolding comp_def using time_closest_pair_rec_conv_closest_pair_recurrence by auto
1062,1064d1161
< definition t_closest_pair :: "point list \<Rightarrow> nat" where
<   "t_closest_pair ps = t_mergesort fst ps + t_closest_pair_rec (mergesort fst ps)"
< 
1066c1163
<   "closest_pair_time n = mergesort_recurrence n + closest_pair_recurrence n"
---
>   "closest_pair_time n = 1 + mergesort_recurrence n + closest_pair_recurrence n"
1068c1165
< lemma t_closest_pair_conv_closest_pair_recurrence:
---
> lemma time_closest_pair_conv_closest_pair_recurrence:
1070,1073c1167,1185
<   shows "t_closest_pair ps \<le> closest_pair_time (length ps)"
<   unfolding t_closest_pair_def closest_pair_time_def
<   using t_closest_pair_rec_conv_closest_pair_recurrence[of "mergesort fst ps"] t_mergesort_conv_mergesort_recurrence[of fst ps]
<   by (simp add: mergesort sorted_fst_def assms)
---
>   shows "time (closest_pair_tm ps) \<le> closest_pair_time (length ps)"
>   using assms
>   unfolding closest_pair_time_def
> proof (induction rule: induct_list012)
>   case (3 x y zs)
>   let ?ps = "x # y # zs"
>   define xs where "xs = val (mergesort_tm fst ?ps)"
>   have *: "distinct xs" "sorted_fst xs" "length xs = length ?ps"
>     using xs_def mergesort(4)[OF "3.prems", of fst] mergesort(1)[of fst ?ps] mergesort(3)[of fst ?ps]
>           sorted_fst_def mergesort_eq_val_mergesort_tm by metis+
>   have "time (closest_pair_tm ?ps) = 1 + time (mergesort_tm fst ?ps) + time (closest_pair_rec_tm xs)"
>     using xs_def by (auto simp del: mergesort_tm.simps closest_pair_rec_tm.simps simp add: time_simps split: prod.split)
>   also have "... \<le> 1 + mergesort_recurrence (length ?ps) + time (closest_pair_rec_tm xs)"
>     using time_mergesort_conv_mergesort_recurrence[of fst ?ps] by simp
>   also have "... \<le> 1 + mergesort_recurrence (length ?ps) + closest_pair_recurrence (length ?ps)"
>     using time_closest_pair_rec_conv_closest_pair_recurrence[of xs] * by auto
>   finally show ?case
>     by blast
> qed (auto simp: time_simps)
1078c1190
<   using mergesort_recurrence closest_pair_recurrence sum_in_bigo(1) by blast
---
>   using mergesort_recurrence closest_pair_recurrence sum_in_bigo(1) const_1_bigo_n_ln_n by blast
1080,1081c1192,1193
< corollary t_closest_pair_bigo:
<   "t_closest_pair \<in> O[length going_to at_top within { ps. distinct ps }]((\<lambda>n. n * ln n) o length)"
---
> corollary time_closest_pair_bigo:
>   "(\<lambda>ps. time (closest_pair_tm ps)) \<in> O[length going_to at_top within { ps. distinct ps }]((\<lambda>n. n * ln n) o length)"
1084,1085c1196,1197
<            t_closest_pair ps \<le> (closest_pair_time o length) ps"
<     unfolding comp_def using t_closest_pair_conv_closest_pair_recurrence by auto
---
>            time (closest_pair_tm ps) \<le> (closest_pair_time o length) ps"
>     unfolding comp_def using time_closest_pair_conv_closest_pair_recurrence by auto
1322c1434
<     using assms(4) defs(1,3,5) apply (auto split: prod.splits) by (metis Pair_inject)+
---
>     using assms(4) defs(1,3,5) apply (auto simp: combine.simps split: prod.splits) by (metis Pair_inject)+
1344c1456
<       (ys, combine_code p\<^sub>L p\<^sub>R l ys) 
---
>       (ys, combine_code p\<^sub>L p\<^sub>R l ys)
1348,1350c1460,1461
<   apply (relation "Wellfounded.measure (\<lambda>xs. length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
>   by (relation "Wellfounded.measure (\<lambda>xs. length xs)")
>      (auto simp: split_at_take_drop_conv Let_def)
1360c1471
<     (ys, combine_code p\<^sub>L p\<^sub>R l ys) 
---
>     (ys, combine_code p\<^sub>L p\<^sub>R l ys)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Closest_Pair_Points/Common.thy ../../AFPs/afp-2020/thys/Closest_Pair_Points/Common.thy
4c4
< imports
---
>   imports
8a9
>   "Root_Balanced_Tree.Time_Monad"
14a16,28
> subsubsection "Time Monad"
> 
> lemma time_distrib_bind:
>   "time (bind_tm tm f) = time tm + time (f (val tm))"
>   unfolding bind_tm_def by (simp split: tm.split)
> 
> lemmas time_simps = time_distrib_bind tick_def
> 
> lemma bind_tm_cong[fundef_cong]:
>   assumes "\<And>v. v = val n \<Longrightarrow> f v = g v" "m = n"
>   shows "bind_tm m f = bind_tm n g"
>   using assms unfolding bind_tm_def by (auto split: tm.split)
> 
48a63,88
> lemma const_1_bigo_n_ln_n:
>   "(\<lambda>(n::nat). 1) \<in> O(\<lambda>n. n * ln n)"
> proof -
>   have "\<exists>N. \<forall>(n::nat) \<ge> N. (\<lambda>x. 1 \<le> x * ln x) n"
>   proof -
>     have "\<forall>(n::nat) \<ge> 3. (\<lambda>x. 1 \<le> x * ln x) n"
>     proof standard
>       fix n
>       show "3 \<le> n \<longrightarrow> 1 \<le> real n * ln (real n)"
>       proof standard
>         assume "3 \<le> n"
>         hence "1 \<le> real n"
>           by simp
>         moreover have "1 \<le> ln (real n)" 
>           using ln_ln_nonneg' \<open>3 \<le> n\<close> by simp
>         ultimately show "1 \<le> real n * ln (real n)"
>           by (auto simp: order_trans)
>       qed
>     qed
>     thus ?thesis
>       by blast
>   qed
>   thus ?thesis
>     by auto
> qed
> 
121,122c161
<   apply (induction xs)
<   apply (auto) by (metis UnI1 UnI2 insert_iff)+
---
>   by (induction xs) (auto, metis UnI1 insert_iff, metis UnI2 insert_iff)
126,128c165,171
< fun t_length :: "'a list \<Rightarrow> nat" where
<   "t_length [] = 0"
< | "t_length (x#xs) = 1 + t_length xs"
---
> fun length_tm :: "'a list \<Rightarrow> nat tm" where
>   "length_tm [] =1 return 0"
> | "length_tm (x # xs) =1
>     do {
>       l <- length_tm xs;
>       return (1 + l)
>     }"
130,131c173,174
< lemma t_length:
<   "t_length xs = length xs"
---
> lemma length_eq_val_length_tm:
>   "val (length_tm xs) = length xs"
133a177,180
> lemma time_length_tm:
>   "time (length_tm xs) = length xs + 1"
>   by (induction xs) (auto simp: time_simps)
> 
168,174c215,224
< fun t_take :: "nat \<Rightarrow> 'a list \<Rightarrow> nat" where
<   "t_take n [] = 0"
< | "t_take n (x#xs) = 1 + (
<     case n of
<       0 \<Rightarrow> 0
<     | Suc m \<Rightarrow> t_take m xs
<   )"
---
> fun take_tm :: "nat \<Rightarrow> 'a list \<Rightarrow> 'a list tm" where
>   "take_tm n [] =1 return []"
> | "take_tm n (x # xs) =1
>     (case n of
>        0 \<Rightarrow> return []
>      | Suc m \<Rightarrow> do {
>          ys <- take_tm m xs;
>          return (x # ys)
>        }
>     )"
176,177c226,227
< lemma t_take:
<   "t_take n xs \<le> min (n + 1) (length xs)"
---
> lemma take_eq_val_take_tm:
>   "val (take_tm n xs) = take n xs"
179a230,233
> lemma time_take_tm:
>   "time (take_tm n xs) = min n (length xs) + 1"
>   by (induction xs arbitrary: n) (auto simp: time_simps split: nat.split)
> 
182,184c236,246
< fun t_filter :: "('a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> nat" where
<   "t_filter P [] = 0"
< | "t_filter P (x#xs) = 1 + (if P x then t_filter P xs else t_filter P xs)"
---
> fun filter_tm :: "('a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> 'a list tm" where
>   "filter_tm P [] =1 return []"
> | "filter_tm P (x # xs) =1
>     (if P x then
>        do {
>          ys <- filter_tm P xs;
>          return (x # ys)
>        }
>      else
>        filter_tm P xs
>     )"
186,187c248,249
< lemma t_filter:
<   "t_filter P xs = length xs"
---
> lemma filter_eq_val_filter_tm:
>   "val (filter_tm P xs) = filter P xs"
189a252,255
> lemma time_filter_tm:
>   "time (filter_tm P xs) = length xs + 1"
>   by (induction xs) (auto simp: time_simps)
> 
212c278,290
< fun split_at :: "nat \<Rightarrow> 'a list \<Rightarrow> ('a list * 'a list)" where
---
> fun split_at_tm :: "nat \<Rightarrow> 'a list \<Rightarrow> ('a list \<times> 'a list) tm" where
>   "split_at_tm n [] =1 return ([], [])"
> | "split_at_tm n (x # xs) =1 (
>     case n of
>       0 \<Rightarrow> return ([], x # xs)
>     | Suc m \<Rightarrow>
>       do {
>         (xs', ys') <- split_at_tm m xs;
>         return (x # xs', ys')
>       }
>   )"
> 
> fun split_at :: "nat \<Rightarrow> 'a list \<Rightarrow> 'a list \<times> 'a list" where
215c293
<     case n of
---
>     case n of 
217,219c295,297
<     | Suc m \<Rightarrow>
<       let (xs', ys') = split_at m xs in
<       (x # xs', ys')
---
>     | Suc m \<Rightarrow> 
>         let (xs', ys') = split_at m xs in
>         (x # xs', ys')
221a300,303
> lemma split_at_eq_val_split_at_tm:
>   "val (split_at_tm n xs) = split_at n xs"
>   by (induction xs arbitrary: n) (auto split: nat.split prod.split)
> 
224c306
<   by (induction xs arbitrary: n) (auto split: nat.split)
---
>   by (induction xs arbitrary: n) (auto simp: split: nat.split)
226,236c308,310
< fun t_split_at :: "nat \<Rightarrow> 'a list \<Rightarrow> nat" where
<   "t_split_at n [] = 0"
< | "t_split_at n (x#xs) = 1 + (
<     case n of
<       0 \<Rightarrow> 0
<     | Suc m \<Rightarrow> t_split_at m xs
<   )"
< 
< lemma t_split_at:
<   "t_split_at n xs \<le> length xs"
<   by (induction xs arbitrary: n) (auto split: nat.split)
---
> lemma time_split_at_tm:
>   "time (split_at_tm n xs) = min n (length xs) + 1"
>   by (induction xs arbitrary: n) (auto simp: time_simps split: nat.split prod.split)
250,252c324,326
<   assumes "(ts, ds) = split_at n xs" "(tsi, dsi) = split_at_it' acc n xs"
<   shows "rev acc @ ts = tsi"
<     and "ds = dsi"
---
>   assumes "(ts, ds) = split_at n xs" "(ts', ds') = split_at_it' acc n xs"
>   shows "rev acc @ ts = ts'"
>     and "ds = ds'"
254,256c328,329
<   apply (induction acc n xs arbitrary: ts rule: split_at_it'.induct)
<   apply (auto simp: split_at.simps split: prod.splits nat.splits)
<   done
---
>   by (induction acc n xs arbitrary: ts rule: split_at_it'.induct)
>      (auto simp: split: prod.splits nat.splits)
267a341,343
> declare split_at_tm.simps [simp del]
> declare split_at.simps [simp del]
> 
278a355,370
> fun merge_tm :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> 'b list \<Rightarrow> 'b list tm" where
>   "merge_tm f (x # xs) (y # ys) =1 (
>     if f x \<le> f y then
>       do {
>         tl <- merge_tm f xs (y # ys);
>         return (x # tl)
>       }
>     else
>       do {
>         tl <- merge_tm f (x # xs) ys;
>         return (y # tl)
>       }
>   )"
> | "merge_tm f [] ys =1 return ys"
> | "merge_tm f xs [] =1 return xs"
> 
288a381,384
> lemma merge_eq_val_merge_tm:
>   "val (merge_tm f xs ys) = merge f xs ys"
>   by (induction f xs ys rule: merge.induct) auto
> 
307c403,422
< function mergesort :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> 'b list" where
---
> declare split_at_take_drop_conv [simp]
> 
> function (sequential) mergesort_tm :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> 'b list tm" where
>   "mergesort_tm f [] =1 return []"
> | "mergesort_tm f [x] =1 return [x]"
> | "mergesort_tm f xs =1 (
>     do {
>       n <- length_tm xs;
>       (xs\<^sub>l, xs\<^sub>r) <- split_at_tm (n div 2) xs;
>       l <- mergesort_tm f xs\<^sub>l;
>       r <- mergesort_tm f xs\<^sub>r;
>       merge_tm f l r
>     }
>   )"
>   by pat_completeness auto
> termination mergesort_tm
>   by (relation "Wellfounded.measure (\<lambda>(_, xs). length xs)")
>      (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm)
> 
> fun mergesort :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> 'b list" where
310,311c425
< | "mergesort f (x # y # xs') = ( 
<     let xs = x # y # xs' in
---
> | "mergesort f xs = ( 
316,320c430,436
<   by pat_completeness auto
< termination mergesort
<   apply (relation "Wellfounded.measure (\<lambda>(_, xs). length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
> 
> declare split_at_take_drop_conv [simp del]
> 
> lemma mergesort_eq_val_mergesort_tm:
>   "val (mergesort_tm f xs) = mergesort f xs"
>   by (induction f xs rule: mergesort.induct)
>      (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm merge_eq_val_merge_tm split: prod.split)
328,330c444,445
<   apply (induction f xs rule: mergesort.induct)
<   apply (simp_all add: set_merge split_at_take_drop_conv)
<   using set_take_drop by (metis list.simps(15))
---
>   by (induction f xs rule: mergesort.induct)
>      (simp_all add: set_merge split_at_take_drop_conv, metis list.simps(15) set_take_drop)
367,397c482,484
< fun t_merge' :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> 'b list \<Rightarrow> nat" where
<   "t_merge' f (x#xs) (y#ys) = 1 + (
<     if f x \<le> f y then
<       t_merge' f xs (y#ys)
<     else
<       t_merge' f (x#xs) ys
<   )"
< | "t_merge' f xs [] = 0"
< | "t_merge' f [] ys = 0"
< 
< definition t_merge :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> ('b list * 'b list) \<Rightarrow> nat" where
<   "t_merge f xys = t_merge' f (fst xys) (snd xys)"
< 
< lemma t_merge:
<   "t_merge f (xs, ys) \<le> length xs + length ys"
<   unfolding t_merge_def by (induction f xs ys rule: t_merge'.induct) auto
< 
< function t_mergesort :: "('b \<Rightarrow> 'a::linorder) \<Rightarrow> 'b list \<Rightarrow> nat" where
<   "t_mergesort f [] = 0"
< | "t_mergesort f [_] = 1"
< | "t_mergesort f (x # y # xs') = (
<     let xs = x # y # xs' in
<     let (l, r) = split_at (length xs div 2) xs in
<     t_length xs + t_split_at (length xs div 2) xs +
<     t_mergesort f l + t_mergesort f r + t_merge f (l, r)
<   )"
<   by pat_completeness auto
< termination t_mergesort
<   apply (relation "Wellfounded.measure (\<lambda>(_, xs). length xs)")
<   apply (auto simp: split_at_take_drop_conv Let_def)
<   done
---
> lemma time_merge_tm:
>   "time (merge_tm f xs ys) \<le> length xs + length ys + 1"
>   by (induction f xs ys rule: merge_tm.induct) (auto simp: time_simps)
400c487
<   "mergesort_recurrence 0 = 0"
---
>   "mergesort_recurrence 0 = 1"
402,403c489,490
< | "2 \<le> n \<Longrightarrow> mergesort_recurrence n = mergesort_recurrence (nat \<lfloor>real n / 2\<rfloor>) + 
<     mergesort_recurrence (nat \<lceil>real n / 2\<rceil>) + 3 * n"
---
> | "2 \<le> n \<Longrightarrow> mergesort_recurrence n = 4 + 3 * n + mergesort_recurrence (nat \<lfloor>real n / 2\<rfloor>) + 
>     mergesort_recurrence (nat \<lceil>real n / 2\<rceil>)"
411,413c498,503
< lemma t_mergesort_conv_mergesort_recurrence:
<   "t_mergesort f xs \<le> mergesort_recurrence (length xs)"
< proof (induction f xs rule: t_mergesort.induct)
---
> lemma time_mergesort_conv_mergesort_recurrence:
>   "time (mergesort_tm f xs) \<le> mergesort_recurrence (length xs)"
> proof (induction f xs rule: mergesort_tm.induct)
>   case (1 f)
>   thus ?case by (auto simp: time_simps)
> next
415,416c505
<   thus ?case
<     using mergesort_recurrence.simps(2) by auto
---
>   thus ?case using mergesort_recurrence.simps(2) by (auto simp: time_simps)
420,422c509,511
<   define XS where "XS = x # y # xs'"
<   define N where "N = length XS"
<   obtain L R where LR_def: "(L, R) = split_at (N div 2) XS"
---
>   define xs where "xs = x # y # xs'"
>   define n where "n = length xs"
>   obtain l r where lr_def: "(l, r) = split_at (n div 2) xs"
424,427c513,520
<   note defs = XS_def N_def LR_def
< 
<   let ?LHS = "t_length XS + t_split_at (N div 2) XS + t_mergesort f L + t_mergesort f R + t_merge f (L, R)"
<   let ?RHS = "mergesort_recurrence (nat \<lfloor>real N / 2\<rfloor>) + mergesort_recurrence (nat \<lceil>real N / 2\<rceil>) + 3 * N"
---
>   define l' where "l' = mergesort f l"
>   define r' where "r' = mergesort f r"
>   note defs = xs_def n_def lr_def l'_def r'_def
> 
>   have IHL: "time (mergesort_tm f l) \<le> mergesort_recurrence (length l)"
>     using defs "3.IH"(1) by (auto simp: length_eq_val_length_tm split_at_eq_val_split_at_tm)
>   have IHR: "time (mergesort_tm f r) \<le> mergesort_recurrence (length r)"
>     using defs "3.IH"(2) by (auto simp: length_eq_val_length_tm split_at_eq_val_split_at_tm)
429,434c522
<   have IHL: "t_mergesort f L \<le> mergesort_recurrence (length L)"
<     using defs "3.IH"(1) prod.collapse by blast
<   have IHR: "t_mergesort f R \<le> mergesort_recurrence (length R)"
<     using defs "3.IH"(2) prod.collapse by blast
< 
<   have *: "length L = N div 2" "length R = N - N div 2"
---
>   have *: "length l = n div 2" "length r = n - n div 2"
436c524
<   hence "(nat \<lfloor>real N / 2\<rfloor>) = length L" "(nat \<lceil>real N / 2\<rceil>) = length R"
---
>   hence "(nat \<lfloor>real n / 2\<rfloor>) = length l" "(nat \<lceil>real n / 2\<rceil>) = length r"
438,439c526,527
<   hence IH: "t_mergesort f L \<le> mergesort_recurrence (nat \<lfloor>real N / 2\<rfloor>)"
<             "t_mergesort f R \<le> mergesort_recurrence (nat \<lceil>real N / 2\<rceil>)"
---
>   hence IH: "time (mergesort_tm f l) \<le> mergesort_recurrence (nat \<lfloor>real n / 2\<rfloor>)"
>             "time (mergesort_tm f r) \<le> mergesort_recurrence (nat \<lceil>real n / 2\<rceil>)"
442c530
<   have "N = length L + length R"
---
>   have "n = length l + length r"
444,450c532,542
<   hence "t_merge f (L, R) \<le> N"
<     using t_merge by simp
<   moreover have "t_length XS = N"
<     using t_length N_def by blast
<   moreover have "t_split_at (N div 2) XS \<le> N"
<     using t_split_at N_def by blast
<   ultimately have *: "?LHS \<le> ?RHS"
---
>   hence "time (merge_tm f l' r') \<le> n + 1"
>     using time_merge_tm defs by (metis length_mergesort)
>   
>   have "time (mergesort_tm f xs) = 1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) + 
>           time (mergesort_tm f l) + time (mergesort_tm f r) + time (merge_tm f l' r')"
>     using defs by (auto simp add: time_simps length_eq_val_length_tm  mergesort_eq_val_mergesort_tm 
>                                   split_at_eq_val_split_at_tm 
>                         split: prod.split)
>   also have "... \<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)"
>     using time_length_tm[of xs] time_split_at_tm[of "n div 2" xs] n_def \<open>time (merge_tm f l' r') \<le> n + 1\<close> by simp
>   also have "... \<le> 4 + 3 * n + mergesort_recurrence (nat \<lfloor>real n / 2\<rfloor>) + mergesort_recurrence (nat \<lceil>real n / 2\<rceil>)"
452,460c544,548
<   moreover have "t_mergesort f XS = ?LHS"
<     using defs by (auto simp: Let_def split: prod.split)
<   moreover have "mergesort_recurrence N = ?RHS"
<     by (simp add: defs)
<   ultimately have "t_mergesort f XS \<le> mergesort_recurrence N"
<     by presburger 
<   thus ?case
<     using XS_def N_def by blast
< qed auto
---
>   also have "... = mergesort_recurrence n"
>     using defs by simp
>   finally show ?case
>     using defs by simp
> qed
466,467c554,555
< theorem t_mergesort_bigo:
<   "t_mergesort f \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
---
> theorem time_mergesort_tm_bigo:
>   "(\<lambda>xs. time (mergesort_tm f xs)) \<in> O[length going_to at_top]((\<lambda>n. n * ln n) o length)"
469,470c557,558
<   have 0: "\<And>xs. t_mergesort f xs \<le> (mergesort_recurrence o length) xs"
<     unfolding comp_def using t_mergesort_conv_mergesort_recurrence by blast
---
>   have 0: "\<And>xs. time (mergesort_tm f xs) \<le> (mergesort_recurrence o length) xs"
>     unfolding comp_def using time_mergesort_conv_mergesort_recurrence by blast
518c606
<   using assms apply (auto simp: dist_commute sparse_def) by force+
---
>   using assms by (auto simp: dist_commute sparse_def, force+)
583a672,684
> fun find_closest_bf_tm :: "point \<Rightarrow> point list \<Rightarrow> point tm" where
>   "find_closest_bf_tm _ [] =1 return undefined"
> | "find_closest_bf_tm _ [p] =1 return p"
> | "find_closest_bf_tm p (p\<^sub>0 # ps) =1 (
>     do {
>       p\<^sub>1 <- find_closest_bf_tm p ps;
>       if dist p p\<^sub>0 < dist p p\<^sub>1 then
>         return p\<^sub>0
>       else
>         return p\<^sub>1
>     }
>   )"
> 
594a696,699
> lemma find_closest_bf_eq_val_find_closest_bf_tm:
>   "val (find_closest_bf_tm p ps) = find_closest_bf p ps"
>   by (induction p ps rule: find_closest_bf.induct) (auto simp: Let_def)
> 
604a710,724
> fun closest_pair_bf_tm :: "point list \<Rightarrow> (point \<times> point) tm" where
>   "closest_pair_bf_tm [] =1 return undefined"
> | "closest_pair_bf_tm [_] =1 return undefined"
> | "closest_pair_bf_tm [p\<^sub>0, p\<^sub>1] =1 return (p\<^sub>0, p\<^sub>1)"
> | "closest_pair_bf_tm (p\<^sub>0 # ps) =1 (
>     do {
>       (c\<^sub>0::point, c\<^sub>1::point) <- closest_pair_bf_tm ps;
>       p\<^sub>1 <- find_closest_bf_tm p\<^sub>0 ps;
>       if dist c\<^sub>0 c\<^sub>1 \<le> dist p\<^sub>0 p\<^sub>1 then
>         return (c\<^sub>0, c\<^sub>1)
>       else
>         return (p\<^sub>0, p\<^sub>1)
>     }
>   )"
> 
617a738,742
> lemma closest_pair_bf_eq_val_closest_pair_bf_tm:
>   "val (closest_pair_bf_tm ps) = closest_pair_bf ps"
>   by (induction ps rule: closest_pair_bf.induct) 
>      (auto simp: Let_def find_closest_bf_eq_val_find_closest_bf_tm split: prod.split)
> 
695,724c820,826
< fun t_find_closest_bf :: "point \<Rightarrow> point list \<Rightarrow> nat" where
<   "t_find_closest_bf _ [] = 0"
< | "t_find_closest_bf _ [_] = 1"
< | "t_find_closest_bf p (p\<^sub>0 # ps) = 1 + (
<     let p\<^sub>1 = find_closest_bf p ps in
<     t_find_closest_bf p ps + (
<     if dist p p\<^sub>0 < dist p p\<^sub>1 then 0 else 0
<     )
<   )"
< 
< lemma t_find_closest_bf:
<   "t_find_closest_bf p ps = length ps"
<   by (induction p ps rule: t_find_closest_bf.induct) auto
< 
< fun t_closest_pair_bf :: "point list \<Rightarrow> nat" where
<   "t_closest_pair_bf [] = 0"
< | "t_closest_pair_bf [_] = 1"
< | "t_closest_pair_bf [_, _] = 2"
< | "t_closest_pair_bf (p\<^sub>0 # ps) = 1 + (
<     let (c\<^sub>0, c\<^sub>1) = closest_pair_bf ps in
<     t_closest_pair_bf ps + (
<     let p\<^sub>1 = find_closest_bf p\<^sub>0 ps in
<     t_find_closest_bf p\<^sub>0 ps + (
<     if dist c\<^sub>0 c\<^sub>1 \<le> dist p\<^sub>0 p\<^sub>1 then 0 else 0
<     ))
<   )"
< 
< lemma t_closest_pair_bf:
<   "t_closest_pair_bf ps \<le> length ps * length ps"
< proof (induction rule: t_closest_pair_bf.induct)
---
> lemma time_find_closest_bf_tm:
>   "time (find_closest_bf_tm p ps) \<le> length ps + 1"
>   by (induction p ps rule: find_closest_bf_tm.induct) (auto simp: time_simps)
> 
> lemma time_closest_pair_bf_tm:
>   "time (closest_pair_bf_tm ps) \<le> length ps * length ps + 1"
> proof (induction ps rule: closest_pair_bf_tm.induct)
727,731c829,839
<   have "t_closest_pair_bf ?ps \<le> length ?ps * length ?ps"
<     using 4 prod_cases3 by metis
<   thus ?case
<     using "4.prems" t_find_closest_bf by simp
< qed auto
---
>   have "time (closest_pair_bf_tm (p\<^sub>0 # ?ps)) = 1 + time (find_closest_bf_tm p\<^sub>0 ?ps) + time (closest_pair_bf_tm ?ps)"
>     by (auto simp: time_simps split: prod.split)
>   also have "... \<le> 2 + length ?ps + time (closest_pair_bf_tm ?ps)"
>     using time_find_closest_bf_tm[of p\<^sub>0 ?ps] by simp
>   also have "... \<le> 2 + length ?ps + length ?ps * length ?ps + 1"
>     using "4.IH" by simp
>   also have "... \<le> length (p\<^sub>0 # ?ps) * length (p\<^sub>0 # ?ps) + 1"
>     by auto
>   finally show ?case
>     by blast
> qed (auto simp: time_simps)
979c1087
<     using card_2_exists by metis
---
>     by (meson card_2_iff')
==========
Collections
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Collections/ICF/gen_algo/PrioUniqueByAnnotatedList.thy ../../AFPs/afp-2020/thys/Collections/ICF/gen_algo/PrioUniqueByAnnotatedList.thy
343c343
<     linorder_antisym_conv2 sorted.simps(2) sorted_append)
---
>     antisym_conv2 sorted.simps(2) sorted_append)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Collections/ICF/tools/ICF_Tools.thy ../../AFPs/afp-2020/thys/Collections/ICF/tools/ICF_Tools.thy
121c121
<     val name = Facts.name_of_ref xthmref
---
>     val name = Facts.ref_name xthmref
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Collections/ICF/tools/Locale_Code.thy ../../AFPs/afp-2020/thys/Collections/ICF/tools/Locale_Code.thy
160,164c160,165
<     fun pat_eqs_of_spec thy (Spec_Rules.Equational _,(pats,thms)) = 
<       map_filter (filter_pat_eq thy thms) pats
<     | pat_eqs_of_spec thy (Spec_Rules.Unknown,
<         ([Const (@{const_name LC_DEL},_)$pat],_)) 
<         = [(DEL (Thm.global_cterm_of thy pat))]
---
>     fun pat_eqs_of_spec thy
>           {rough_classification = Spec_Rules.Equational _, terms = pats, rules = thms, ...} =
>         map_filter (filter_pat_eq thy thms) pats
>     | pat_eqs_of_spec thy
>           {rough_classification = Spec_Rules.Unknown, terms = [Const (@{const_name LC_DEL},_)$pat], ...} =
>         [(DEL (Thm.global_cterm_of thy pat))]
360c361
<     Spec_Rules.add Spec_Rules.Unknown ([dpat],[])
---
>     Spec_Rules.add Binding.empty Spec_Rules.Unknown [dpat] []
==========
Complete_Non_Orders
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Complete_Non_Orders/Fixed_Points.thy ../../AFPs/afp-2020/thys/Complete_Non_Orders/Fixed_Points.thy
464c464
< and a Scott-continous map $f: A \to A$,
---
> and a Scott-continuous map $f: A \to A$,
537c537
< lemma scott_continous_imp_mono_refl:
---
> lemma scott_continuous_imp_mono_refl:
550c550
< lemma scott_continous_imp_omega_continous:
---
> lemma scott_continuous_imp_omega_continuous:
==========
Complex_Geometry
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Complex_Geometry/Chordal_Metric.thy ../../AFPs/afp-2020/thys/Complex_Geometry/Chordal_Metric.thy
427c427
< definition "(uniformity_complex_homo :: (complex_homo \<times> complex_homo) filter) = (INF e:{0<..}. principal {(x, y). dist_class.dist x y < e})"
---
> definition "(uniformity_complex_homo :: (complex_homo \<times> complex_homo) filter) = (INF e\<in>{0<..}. principal {(x, y). dist_class.dist x y < e})"
667c667
< definition "(uniformity_riemann_sphere :: (riemann_sphere \<times> riemann_sphere) filter) = (INF e:{0<..}. principal {(x, y). dist_class.dist x y < e})"
---
> definition "(uniformity_riemann_sphere :: (riemann_sphere \<times> riemann_sphere) filter) = (INF e\<in>{0<..}. principal {(x, y). dist_class.dist x y < e})"
733c733
<         by (simp add: sign_simps)
---
>         by (simp add: algebra_split_simps)
==========
Concurrent_Revisions
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Data.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Data.thy
156c156
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Determinacy.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Determinacy.thy
1066c1066
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Executions.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Executions.thy
379c379
< end (* theory *)
\ No newline at end of file
---
> end (* theory *)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Occurrences.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Occurrences.thy
344c344
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/OperationalSemantics.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/OperationalSemantics.thy
677c677
< end (* theory *)
\ No newline at end of file
---
> end (* theory *)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Renaming.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Renaming.thy
292c292
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Concurrent_Revisions/Substitution.thy ../../AFPs/afp-2020/thys/Concurrent_Revisions/Substitution.thy
141c141
< end
\ No newline at end of file
---
> end
==========
Constructive_Cryptography
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Constructive_Cryptography/Examples/Secure_Channel/Message_Authentication_Code.thy ../../AFPs/afp-2020/thys/Constructive_Cryptography/Examples/Secure_Channel/Message_Authentication_Code.thy
968,969c968,980
<       by(cases "(fst s, projl x)" rule: sim.cases; cases "snd (snd s)")
<         (auto split: if_split_asm simp add: exec_gpv_bind auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)
---
>       apply(cases "(fst s, projl x)" rule: sim.cases; cases "snd (snd s)")  (*A MESS, but neither fastforce nor auto works for all 36 subgoals*)
>                           apply(fastforce simp: channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                          apply(fastforce simp: channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                         apply(fastforce simp: channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                        apply(fastforce simp: channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                       apply(fastforce simp: auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                      apply(fastforce simp: auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                     apply(fastforce simp: auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                    apply(fastforce simp: auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                   apply(auto split: if_split_asm simp add: exec_gpv_bind auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                  apply(auto split: if_split_asm simp add: auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)[1]
>                 apply(fastforce split: if_split_asm simp add: exec_gpv_bind auth_channel.auth_oracle.simps channel.send_oracle.simps channel.recv_oracle.simps vld_def in_nlists_UNIV \<I>_def)+
>       done 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Constructive_Cryptography/Examples/Secure_Channel/Secure_Channel.thy ../../AFPs/afp-2020/thys/Constructive_Cryptography/Examples/Secure_Channel/Secure_Channel.thy
122c122
<   show ?case by (simp add: max_def) (simp add: times_enat_def)
---
>   show ?case by (simp add: mult_2_right)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Constructive_Cryptography/More_CryptHOL.thy ../../AFPs/afp-2020/thys/Constructive_Cryptography/More_CryptHOL.thy
1942c1942
<     have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) = \<integral>\<^sup>+ generat. (INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<partial>measure_spmf (the_gpv (callee s out))"
---
>     have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) = \<integral>\<^sup>+ generat. (INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<partial>measure_spmf (the_gpv (callee s out))"
1947c1947
<                | Inr (out', callee', rpv) \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
---
>                | Inr (out', callee', rpv) \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
1949c1949
<          | IO out' rpv \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))
---
>          | IO out' rpv \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))
1956c1956
<       from x have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> expectation_gpv' (c x)" by(rule INF_lower)
---
>       from x have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> expectation_gpv' (c x)" by(rule INF_lower)
1960c1960
<                | Inr (out', callee', rpv) \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
---
>                | Inr (out', callee', rpv) \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
1964c1964
<       finally show "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
---
>       finally show "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
1968c1968
<       have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> (INF (r, s'):(\<Union>r'\<in>responses_\<I> \<I>' out'. results_gpv \<I>' (rpv r')). expectation_gpv' (c r))"
---
>       have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> (INF (r, s')\<in>(\<Union>r'\<in>responses_\<I> \<I>' out'. results_gpv \<I>' (rpv r')). expectation_gpv' (c r))"
1970c1970
<       also have "\<dots> = (INF r':responses_\<I> \<I>' out'. INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r))"
---
>       also have "\<dots> = (INF r'\<in>responses_\<I> \<I>' out'. INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r))"
1972c1972
<       also have "\<dots> \<le> (INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))"
---
>       also have "\<dots> \<le> (INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))"
1976c1976
<         have "(INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> (INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv2 (\<lambda>(x, s). f x) (inline callee (c r) s'))"
---
>         have "(INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> (INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv2 (\<lambda>(x, s). f x) (inline callee (c r) s'))"
1982c1982
<         finally show "(INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> \<dots>" .
---
>         finally show "(INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> \<dots>" .
1984c1984
<       finally show "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
---
>       finally show "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
2072c2072
<     have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) = \<integral>\<^sup>+ generat. (INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<partial>measure_spmf (the_gpv (callee s out))"
---
>     have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) = \<integral>\<^sup>+ generat. (INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<partial>measure_spmf (the_gpv (callee s out))"
2077c2077
<                | Inr (out', callee', rpv) \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
---
>                | Inr (out', callee', rpv) \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
2079c2079
<          | IO out' rpv \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))
---
>          | IO out' rpv \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))
2086c2086
<       from this(1) have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> expectation_gpv' (c x)" by(rule INF_lower)
---
>       from this(1) have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> expectation_gpv' (c x)" by(rule INF_lower)
2090c2090
<                | Inr (out', callee', rpv) \<Rightarrow> INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
---
>                | Inr (out', callee', rpv) \<Rightarrow> INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r, s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))
2094c2094
<       finally show "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
---
>       finally show "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
2098c2098
<       have "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> (INF (r, s'):(\<Union>r'\<in>responses_\<I> \<I>' out'. results_gpv \<I>' (rpv r')). expectation_gpv' (c r))"
---
>       have "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> (INF (r, s')\<in>(\<Union>r'\<in>responses_\<I> \<I>' out'. results_gpv \<I>' (rpv r')). expectation_gpv' (c r))"
2100c2100
<       also have "\<dots> = (INF r':responses_\<I> \<I>' out'. INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r))"
---
>       also have "\<dots> = (INF r'\<in>responses_\<I> \<I>' out'. INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r))"
2102c2102
<       also have "\<dots> \<le> (INF r':responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))"
---
>       also have "\<dots> \<le> (INF r'\<in>responses_\<I> \<I>' out'. expectation_gpv 0 \<I>' (\<lambda>(r', s'). expectation_gpv 0 \<I>' (\<lambda>(x, s). f x) (inline callee (c r') s')) (rpv r'))"
2106c2106
<         have "(INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> (INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv2 (\<lambda>(x, s). f x) (inline callee (c r) s'))"
---
>         have "(INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> (INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv2 (\<lambda>(x, s). f x) (inline callee (c r) s'))"
2112c2112
<         finally show "(INF (r, s'):results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> \<dots>" .
---
>         finally show "(INF (r, s')\<in>results_gpv \<I>' (rpv r'). expectation_gpv' (c r)) \<le> \<dots>" .
2114c2114
<       finally show "(INF r:responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
---
>       finally show "(INF r\<in>responses_\<I> \<I> out. expectation_gpv' (c r)) \<le> \<dots>" .
==========
CoreC++
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/CoreC++/Progress.thy ../../AFPs/afp-2020/thys/CoreC++/Progress.thy
91c91
<         ("_,_,_ \<turnstile> _ :' _"   [51,51,51]50)
---
>         ("_,_,_ \<turnstile> _ :'' _"   [51,51,51]50)
==========
Count_Complex_Roots
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Count_Complex_Roots/Count_Complex_Roots.thy ../../AFPs/afp-2020/thys/Count_Complex_Roots/Count_Complex_Roots.thy
138c138
<     then show ?thesis by (rule Lim_eventually)
---
>     then show ?thesis by (rule tendsto_eventually)
1471c1471
<     apply (rule Lim_eventually)
---
>     apply (rule tendsto_eventually)
1515c1515
<     apply (rule Lim_eventually)  
---
>     apply (rule tendsto_eventually)  
2604c2604
<       apply (rule Lim_eventually)
---
>       apply (rule tendsto_eventually)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Count_Complex_Roots/Extended_Sturm.thy ../../AFPs/afp-2020/thys/Count_Complex_Roots/Extended_Sturm.thy
345,347c345,346
<   ultimately show ?thesis 
<     unfolding cross_alt_def      
<     by (simp only:sign_times poly_mult poly_1 sign_simps)
---
>   ultimately show ?thesis
>     by (simp add: cross_alt_def sign_times)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Count_Complex_Roots/More_Polynomials.thy ../../AFPs/afp-2020/thys/Count_Complex_Roots/More_Polynomials.thy
237c237
<   fixes p::"'a::{factorial_ring_gcd,semiring_char_0} poly"
---
>   fixes p::"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize,semiring_char_0} poly"
279c279
<   fixes p::"'a::{semiring_char_0,factorial_ring_gcd} poly"
---
>   fixes p::"'a::{semiring_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
==========
Dict_Construction
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Dict_Construction/side_conditions.ML ../../AFPs/afp-2020/thys/Dict_Construction/side_conditions.ML
215c215
<       |> Option.map (map (mk_eq o Thm.close_derivation))
---
>       |> Option.map (map (mk_eq o Thm.close_derivation \<^here>))
==========
Differential_Dynamic_Logic
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Differential_Dynamic_Logic/Differential_Axioms.thy ../../AFPs/afp-2020/thys/Differential_Dynamic_Logic/Differential_Axioms.thy
2298,2299c2298
<         apply (auto simp add: norm_conv_dist real_norm_def norm_bcontfun_def dist_0_norm dist_blinfun_def)
<         by fastforce
---
>         by (auto simp add: Ball_def Bex_def norm_conv_dist image_iff norm_bcontfun_def dist_blinfun_def)
2324,2327c2323,2325
<       then have theBound:"\<exists>L. (\<forall>t. ?boundMP L t)" 
<         unfolding bdd_above_def norm_conv_dist 
<         apply (auto simp add: norm_conv_dist real_norm_def norm_bcontfun_def dist_0_norm dist_blinfun_def)
<         by fastforce
---
>       then have theBound:"\<exists>L. (\<forall>t. ?boundMP L t)"
>         unfolding bdd_above_def norm_conv_dist
>         by (auto simp add: Ball_def Bex_def norm_conv_dist image_iff norm_bcontfun_def dist_blinfun_def)
2343c2341
<         have "\<bar>x * ?f2 t + ?f3 t\<bar> \<le> \<bar>x\<bar> * \<bar>?f2 t\<bar> + \<bar>?f3 t\<bar>"                    
---
>         have "\<bar>x * ?f2 t + ?f3 t\<bar> \<le> \<bar>x\<bar> * \<bar>?f2 t\<bar> + \<bar>?f3 t\<bar>"
2372c2370
<     let ?sol' = "(\<lambda>t. \<chi> i. if i = vid2 then ?soly t else sol t $ i)" 
---
>     let ?sol' = "(\<lambda>t. \<chi> i. if i = vid2 then ?soly t else sol t $ i)"
2376,2377c2374,2375
<                                  ($f fid3 (\<lambda>i. if i = vid1 then trm.Var vid1 else Const 0))))) 
<                          (\<chi> y. if vid2 = y then r else fst (a, b) $ y, b) 
---
>                                  ($f fid3 (\<lambda>i. if i = vid1 then trm.Var vid1 else Const 0)))))
>                          (\<chi> y. if vid2 = y then r else fst (a, b) $ y, b)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Differential_Dynamic_Logic/Syntax.thy ../../AFPs/afp-2020/thys/Differential_Dynamic_Logic/Syntax.thy
43c43
< | DiffVar 'c ("$'")
---
> | DiffVar 'c ("$''")
==========
Diophantine_Eqns_Lin_Hom
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy ../../AFPs/afp-2020/thys/Diophantine_Eqns_Lin_Hom/Linear_Diophantine_Equations.thy
501c501
<        length_us less_Suc_eq_le less_imp_le_nat linorder_antisym_conv2 not_less_eq_eq
---
>        length_us less_Suc_eq_le less_imp_le_nat antisym_conv2 not_less_eq_eq
==========
Dirichlet_L
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Dirichlet_L/Dirichlet_L_Functions.thy ../../AFPs/afp-2020/thys/Dirichlet_L/Dirichlet_L_Functions.thy
359,372d358
<     from assms have "continuous_on {s. Re s > 0} (eval_fds (fds \<chi>))"
<       by (intro holomorphic_fds_eval holomorphic_on_imp_continuous_on)
<          (auto intro: le_less_trans[OF conv_abscissa_le_0])
<     hence "eval_fds (fds \<chi>) \<midarrow>s\<rightarrow> eval_fds (fds \<chi>) s" using s
<       by (subst (asm) continuous_on_eq_continuous_at) (auto simp: open_halfspace_Re_gt isCont_def)
<     also have "eval_fds (fds \<chi>) s = Dirichlet_L n \<chi> s"
<       using assms s by (simp add: Dirichlet_L_def)
<     finally have lim: "eval_fds (fds \<chi>) \<midarrow>s\<rightarrow> Dirichlet_L n \<chi> s" .
<     have "eventually (\<lambda>z. z \<in> {z. Re z > 0}) (nhds s)" using s
<       by (intro eventually_nhds_in_open) (auto simp: open_halfspace_Re_gt)
<     hence "eventually (\<lambda>z. z \<in> {z. Re z > 0}) (at s)"
<       unfolding eventually_at_filter by eventually_elim auto
<     hence ev: "eventually (\<lambda>z. eval_fds (fds \<chi>) z = Dirichlet_L n \<chi> z) (at s)"
<       by eventually_elim (auto intro!: eq [symmetric])
374c360,376
<       by (rule Lim_transform_eventually [OF ev lim])
---
>     proof (rule Lim_transform_eventually)
>       from assms have "continuous_on {s. Re s > 0} (eval_fds (fds \<chi>))"
>         by (intro holomorphic_fds_eval holomorphic_on_imp_continuous_on)
>           (auto intro: le_less_trans[OF conv_abscissa_le_0])
>       hence "eval_fds (fds \<chi>) \<midarrow>s\<rightarrow> eval_fds (fds \<chi>) s" using s
>         by (subst (asm) continuous_on_eq_continuous_at) (auto simp: open_halfspace_Re_gt isCont_def)
>       also have "eval_fds (fds \<chi>) s = Dirichlet_L n \<chi> s"
>         using assms s by (simp add: Dirichlet_L_def)
>       finally show "eval_fds (fds \<chi>) \<midarrow>s\<rightarrow> Dirichlet_L n \<chi> s" .
>     next
>       have "eventually (\<lambda>z. z \<in> {z. Re z > 0}) (nhds s)" using s
>         by (intro eventually_nhds_in_open) (auto simp: open_halfspace_Re_gt)
>       hence "eventually (\<lambda>z. z \<in> {z. Re z > 0}) (at s)"
>         unfolding eventually_at_filter by eventually_elim auto
>       then show "eventually (\<lambda>z. eval_fds (fds \<chi>) z = Dirichlet_L n \<chi> z) (at s)"
>         by eventually_elim (auto intro!: eq [symmetric])
>     qed
==========
Dirichlet_Series
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Dirichlet_Series/Dirichlet_Series_Analysis.thy ../../AFPs/afp-2020/thys/Dirichlet_Series/Dirichlet_Series_Analysis.thy
8c8
<   "HOL-Analysis.Analysis"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
245c245
<     by (auto intro!: derivative_eq_intros has_vector_derivative_real_complex)
---
>     by (auto intro!: derivative_eq_intros has_vector_derivative_real_field)
2035c2035
<   proof (rule DERIV_zero_constant, goal_cases)
---
>   proof (rule has_field_derivative_zero_constant, goal_cases)
2067c2067
<     by (rule Lim_transform_eventually) auto
---
>     by (force intro: Lim_transform_eventually) 
2104c2104
<   proof (rule DERIV_zero_constant, goal_cases)
---
>   proof (rule has_field_derivative_zero_constant, goal_cases)
2136c2136
<     by (rule Lim_transform_eventually) auto
---
>     by (force intro: Lim_transform_eventually) 
2679c2679
<   hence "?f \<longlonglongrightarrow> 1 / (1 - fds_nth f p / nat_power p s)" by (rule Lim_eventually)
---
>   hence "?f \<longlonglongrightarrow> 1 / (1 - fds_nth f p / nat_power p s)" by (rule tendsto_eventually)
==========
DiscretePricing
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/DiscretePricing/CRR_Model.thy ../../AFPs/afp-2020/thys/DiscretePricing/CRR_Model.thy
2001,2006c2001,2002
<   have "(geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False)) = u * geom_proc n w - d * geom_proc n w"
<     using geometric_process
<     by (metis geom_rand_walk_diff_induct linordered_field_class.sign_simps(39) mult.commute)
<   also have "... = geom_proc n w * (u - d)"
<     by (simp add: linordered_field_class.sign_simps(39) mult.commute)
<   finally have "(geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False)) = geom_proc n w * (u - d)" .
---
>   have "(geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False)) = geom_proc n w * (u - d)"
>     by (simp add: geom_rand_walk_diff_induct)
2943,2950c2939,2941
<               u * geom_proc n w - d * geom_proc n w"
<               using geometric_process
<               by (metis geom_rand_walk_diff_induct linordered_field_class.sign_simps(39) mult.commute)
<             also have "... = geom_proc n w * (u - d)"
<               by (simp add: linordered_field_class.sign_simps(39) mult.commute)
<             finally have "(geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False)) =
<               geom_proc n w * (u - d)" .
<             thus ?thesis by simp
---
>               geom_proc n w * (u - d)"
>               by (simp add: geom_rand_walk_diff_induct)
>             then show ?thesis by simp
3020,3030c3011
<           proof -
<             have "geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False) =
<               u * geom_proc n w - d * geom_proc n w"
<               using geometric_process
<               by (metis geom_rand_walk_diff_induct linordered_field_class.sign_simps(39) mult.commute)
<             also have "... = geom_proc n w * (u - d)"
<               by (simp add: linordered_field_class.sign_simps(39) mult.commute)
<             finally have "(geom_proc (Suc n) (spick w n True) - geom_proc (Suc n) (spick w n False)) =
<               geom_proc n w * (u - d)" .
<             thus ?thesis by simp
<           qed
---
>             by (simp add: geom_rand_walk_diff_induct)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy ../../AFPs/afp-2020/thys/DiscretePricing/Infinite_Coin_Toss_Space.thy
316c316,317
<       hence "X n = True" by simp
---
>       hence "X n = True"
>         unfolding PiE_iff by auto
324c325,326
<       hence "restrict X {n} \<in> (Pi\<^sub>E {n} (\<lambda>x::nat. {True}))" by simp
---
>       hence "restrict X {n} \<in> (Pi\<^sub>E {n} (\<lambda>x::nat. {True}))"
>         unfolding PiE_iff by auto
338c340,341
<     (\<Prod>i\<in>{n}. emeasure (?PM i) ((\<lambda>x::nat. {True}) i))" using isps by (auto simp add: product_prob_space.emeasure_PiM_emb)
---
>     (\<Prod>i\<in>{n}. emeasure (?PM i) ((\<lambda>x::nat. {True}) i))" using isps
>     by (auto simp add: product_prob_space.emeasure_PiM_emb simp del: ext_funcset_to_sing_iff)
==========
Echelon_Form
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Echelon_Form/Code_Cayley_Hamilton.thy ../../AFPs/afp-2020/thys/Echelon_Form/Code_Cayley_Hamilton.thy
77a78
> (* TODO: why does the proof step above need all of Analysis?? *)
==========
Efficient-Mergesort
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Efficient-Mergesort/Efficient_Sort.thy ../../AFPs/afp-2020/thys/Efficient-Mergesort/Efficient_Sort.thy
41c41
<       (if \<not> key a > key b then asc b (\<lambda>ys. as (a # ys)) bs
---
>       (if key a \<le> key b then asc b (\<lambda>ys. as (a # ys)) bs
80c80
< subsection \<open>Facts about Lengths\<close>
---
> subsection \<open>The Functional Argument of @{const asc}\<close>
82c82,83
< definition "ascP f = (\<forall>xs ys. f (xs @ ys) = f xs @ ys)"
---
> text \<open>\<open>f\<close> is a function that only adds some prefix to a given list.\<close>
> definition "ascP f = (\<forall>xs. f xs = f [] @ xs)"
86,89c87,88
< lemma ascP_comp_Cons [simp]: "ascP f \<Longrightarrow> ascP (\<lambda>ys. f (x # ys))"
<   by (auto simp: ascP_def simp flip: append_Cons)
< 
< lemma ascP_comp_append: "ascP f \<Longrightarrow> ascP (\<lambda>xs. f [] @ x # xs)"
---
> lemma ascP_comp_append_Cons [simp]:
>   "ascP (\<lambda>xs. f [] @ x # xs)"
91a91,103
> lemma ascP_f_Cons:
>   assumes "ascP f"
>   shows "f (x # xs) = f [] @ x # xs"
>   using \<open>ascP f\<close> [unfolded ascP_def, THEN spec, of "x # xs"] .
> 
> lemma ascP_comp_Cons [simp]:
>   assumes "ascP f"
>   shows "ascP (\<lambda>ys. f (x # ys))"
> proof (unfold ascP_def, intro allI)
>   fix xs show "f (x # xs) = f [x] @ xs"
>     using assms by (simp add: ascP_f_Cons)
> qed
> 
95c107
<   using assms [unfolded ascP_def, THEN spec, THEN spec, of "[]" "[x]"] by simp
---
>   by (rule ascP_f_Cons [OF assms])
97,100c109,110
< lemma ascP_f_Cons:
<   assumes "ascP f"
<   shows "f (x # xs) = f [] @ x # xs"
<   using assms [unfolded ascP_def, THEN spec, THEN spec, of "[]" "x # xs"] by simp
---
> 
> subsection \<open>Facts about Lengths\<close>
117c127
<   by (induct xs ys rule: merge.induct) (simp_all add: ac_simps)
---
>   by (induct xs ys rule: merge.induct) simp_all
125c135
<   by (induct xs rule: merge_pairs.induct) (auto simp: ac_simps)
---
>   by (induct xs rule: merge_pairs.induct) auto
133c143
<   by (induct xs rule: merge_all.induct) (simp_all add: ac_simps)
---
>   by (induct xs rule: merge_all.induct) simp_all
186c196
<     by (auto simp: o_def ascP_f_Cons [where f = f] ascP_comp_append)
---
>     by (auto simp: o_def ascP_f_Cons [where f = f])
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Efficient-Mergesort/Mergesort_Complexity.thy ../../AFPs/afp-2020/thys/Efficient-Mergesort/Mergesort_Complexity.thy
104,105c104,105
<     and "ascP f \<Longrightarrow> asc key a f ys \<noteq> []"
<     and "desc key a xs ys \<noteq> []"
---
>     and asc_ne: "ascP f \<Longrightarrow> asc key a f ys \<noteq> []"
>     and desc_ne: "desc key a xs ys \<noteq> []"
==========
Epistemic_Logic
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Epistemic_Logic/Epistemic_Logic.thy ../../AFPs/afp-2020/thys/Epistemic_Logic/Epistemic_Logic.thy
3c3
<   Author:    Andreas Halkjr From
---
>   Author:    Asta Halkjr From
==========
Ergodic_Theory
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Fekete.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Fekete.thy
8c8
<   imports "HOL-Analysis.Analysis"
---
>   imports "HOL-Analysis.Multivariate_Analysis"
211c211,212
<     by (metis linordered_field_class.sign_simps(5) mult_left_le_imp_le of_nat_0_less_iff)
---
>     apply (metis mult.commute mult_left_le_imp_le of_nat_0_less_iff)
>     done
377c378
<     then have "v \<longlonglongrightarrow> 0" using tendsto_explicit by force
---
>     then have "v \<longlonglongrightarrow> 0" using lim_explicit by force
424c425,426
<       then have "v n * exp(e) < a" using \<open>exp(e) < a/t\<close> by (metis \<open>0 < t\<close> linordered_field_class.sign_simps(24) pos_less_divide_eq)
---
>       with \<open>0 < t\<close> have "v n * exp(e) < a" using \<open>exp(e) < a/t\<close>
>         by (auto simp add: field_simps)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Gouezel_Karlsson.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Gouezel_Karlsson.thy
294c294
<         by (rule Lim_eventually)
---
>         by (rule tendsto_eventually)
376c376
<         by (simp add: linordered_field_class.sign_simps(38) of_nat_diff)
---
>         by (simp add: algebra_simps of_nat_diff)
794a795
>   then have "\<not> d2 < 0" using not_less [of d2 0] by (simp add: less_le)
1044c1045
<         by (metis \<open>0 < d2 / 2\<close> divide_le_eq div_0 linordered_field_class.sign_simps(24) of_nat_0 of_nat_0_le_iff)
---
>         using \<open>\<not> d2 < 0\<close> by simp
1100c1101
<       by (simp del: UN_simps, rule card_finite_union, auto)
---
>       by (simp del: UN_simps, rule card_UN_le, auto)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Invariants.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Invariants.thy
674c674
<   proof (rule Lim_eventually, cases)
---
>   proof (rule tendsto_eventually, cases)
760c760,761
<       using assms real_cond_exp_int(1)[OF assms] integrable_real_mult_indicator[OF \<open>A \<in> sets M\<close>] by auto
---
>       using assms real_cond_exp_int(1)[OF assms] integrable_real_mult_indicator[OF \<open>A \<in> sets M\<close>]
>       by (auto simp: simp del: integrable_mult_left_iff)
785c786
<           using \<open>n > 0\<close> by (simp add: add_divide_eq_iff linordered_field_class.sign_simps(27))
---
>           using \<open>n > 0\<close> by (simp add: field_simps)
959c960
<       by (rule Lim_transform_eventually)
---
>       by (blast intro: Lim_transform_eventually)
1444c1445
<       by (rule emeasure_union_inter, auto)
---
>       by (rule emeasure_Un_Int, auto)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Kingman.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Kingman.thy
485c485
<     by (subst tendsto_explicit, metis * less_le_trans zero_less_one)
---
>     by (subst lim_explicit, metis * less_le_trans zero_less_one)
532c532
<     by (subst tendsto_explicit, metis * less_le_trans zero_less_one)
---
>     by (subst lim_explicit, metis * less_le_trans zero_less_one)
1687c1687
<     apply (rule Lim_transform_eventually[OF _ subcocycle_int_tendsto_avg_ereal[OF w(1)]])
---
>     apply (rule Lim_transform_eventually[OF subcocycle_int_tendsto_avg_ereal[OF w(1)]])
1800c1800
<       using tendsto_explicit by force
---
>       using lim_explicit by force
1813c1813
<         using tendsto_explicit by force
---
>         using lim_explicit by force
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Kohlberg_Neyman_Karlsson.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Kohlberg_Neyman_Karlsson.thy
149c149
<     proof -
---
>     proof (rule Lim_transform_eventually)
152c152
<       then have *: "eventually (\<lambda>n. ereal ((u n/n - A) + eps i) * ereal n = ereal(u n - (A - eps i) * n)) sequentially"
---
>       then show "eventually (\<lambda>n. ereal ((u n/n - A) + eps i) * ereal n = ereal(u n - (A - eps i) * n)) sequentially"
158c158,159
<       then show ?thesis using Lim_transform_eventually[OF *] \<open>eps i > 0\<close> by simp
---
>       then show "(\<lambda>n. ereal (u n / real n - A + eps i) * ereal (real n)) \<longlonglongrightarrow> \<infinity>" 
>         using  \<open>eps i > 0\<close> by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/Measure_Preserving_Transformations.thy
372c372
<   also have "... = emeasure lborel A" using lborel_distr_plus2[of c] by simp
---
>   also have "... = emeasure lborel A" using lborel_distr_plus[of c] by simp
1140c1140
< by (rule borel_measurable_continuous_on1, auto)
---
> by (rule borel_measurable_continuous_onI, auto)
1158c1158
< by (rule borel_measurable_continuous_on1, auto)+
---
> by (rule borel_measurable_continuous_onI, auto)+
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ergodic_Theory/SG_Library_Complement.thy ../../AFPs/afp-2020/thys/Ergodic_Theory/SG_Library_Complement.thy
46,51d45
< lemma card_finite_union:
<   assumes "finite I"
<   shows "card(\<Union>i\<in>I. A i) \<le> (\<Sum>i\<in>I. card(A i))"
< using assms apply (induct, auto)
< using card_Un_le nat_add_left_cancel_le order_trans by blast
< 
59,70d52
< lemma UN_le_add_shift_strict:
<   "(\<Union>i<n::nat. M(i+k)) = (\<Union>i\<in>{k..<n+k}. M i)" (is "?A = ?B")
< proof
<   show "?B \<subseteq> ?A"
<   proof
<     fix x assume "x \<in> ?B"
<     then obtain i where i: "i \<in> {k..<n+k}" "x \<in> M(i)" by auto
<     then have "i - k < n \<and> x \<in> M((i-k) + k)" by auto
<     then show "x \<in> ?A" using UN_le_add_shift by blast
<   qed
< qed (fastforce)
< 
136,137c118
<   assumes "u \<longlonglongrightarrow> l"
<           "e>0"
---
>   assumes "u \<longlonglongrightarrow> l" "e>0"
139,143c120
< proof-
<   have "eventually (\<lambda>n. dist (u n) l < e) sequentially" using assms tendstoD by auto
<   then have "\<forall>\<^sub>F n in sequentially. abs(u n - l) < e" using dist_real_def by auto
<   then show ?thesis by (simp add: eventually_at_top_dense)
< qed
---
>   by (metis assms dist_real_def le_less lim_sequentially)
168c145
< using assms by (induct rule: finite_ne_induct, auto)
---
>   by (simp add: assms member_le_sum)
275,301d251
< subsection \<open>Connected.thy\<close>
< 
< text \<open>The next lemma is missing in the library, contrary to its cousin \verb+continuous_infdist+.\<close>
< 
< lemma continuous_on_infdist [continuous_intros]:
<   assumes "continuous_on S f"
<   shows "continuous_on S (\<lambda>x. infdist (f x) A)"
< using assms unfolding continuous_on by (auto intro: tendsto_infdist)
< 
< 
< subsection \<open>Transcendental.thy\<close>
< 
< text \<open>In \verb+Transcendental.thy+, the assumptions of the next two lemmas are
< $x > 0$ and $y > 0$, while large inequalities are sufficient, with the same proof.\<close>
< 
< lemma powr_divide: "0 \<le> x \<Longrightarrow> 0 \<le> y \<Longrightarrow> (x / y) powr a = (x powr a) / (y powr a)"
<   for a b x :: real
<   apply (simp add: divide_inverse positive_imp_inverse_positive powr_mult)
<   apply (simp add: powr_def exp_minus [symmetric] exp_add [symmetric] ln_inverse)
<   done
< 
< lemma powr_mult_base: "0 \<le> x \<Longrightarrow>x * x powr y = x powr (1 + y)"
<   for x :: real
<   by (auto simp: powr_add)
< 
< 
< 
304,307d253
< text \<open>\verb+lim_1_over_n+ is very useful, it could --should?-- be declared as simp and tendsto-intros.\<close>
< 
< declare lim_1_over_n [tendsto_intros]
< 
343c289
<   with Lim_transform_eventually[OF this a]
---
>   with Lim_transform_eventually[OF a this]
351,382d296
< lemma Inf_as_limit:
<   fixes A::"'a::{linorder_topology, first_countable_topology, complete_linorder} set"
<   assumes "A \<noteq> {}"
<   shows "\<exists>u. (\<forall>n. u n \<in> A) \<and> u \<longlonglongrightarrow> Inf A"
< proof (cases "Inf A \<in> A")
<   case True
<   show ?thesis
<     by (rule exI[of _ "\<lambda>n. Inf A"], auto simp add: True)
< next
<   case False
<   obtain y where "y \<in> A" using assms by auto
<   then have "Inf A < y" using False Inf_lower less_le by auto
<   obtain F :: "nat \<Rightarrow> 'a set" where F: "\<And>i. open (F i)" "\<And>i. Inf A \<in> F i"
<                                        "\<And>u. (\<forall>n. u n \<in> F n) \<Longrightarrow> u \<longlonglongrightarrow> Inf A"
<     by (metis first_countable_topology_class.countable_basis)
<   define u where "u = (\<lambda>n. SOME z. z \<in> F n \<and> z \<in> A)"
<   have "\<exists>z. z \<in> U \<and> z \<in> A" if "Inf A \<in> U" "open U" for U
<   proof -
<     obtain b where "b > Inf A" "{Inf A ..<b} \<subseteq> U"
<       using open_right[OF \<open>open U\<close> \<open>Inf A \<in> U\<close> \<open>Inf A < y\<close>] by auto
<     obtain z where "z < b" "z \<in> A"
<       using \<open>Inf A < b\<close> Inf_less_iff by auto
<     then have "z \<in> {Inf A ..<b}"
<       by (simp add: Inf_lower)
<     then show ?thesis using \<open>z \<in> A\<close> \<open>{Inf A ..<b} \<subseteq> U\<close> by auto
<   qed
<   then have *: "u n \<in> F n \<and> u n \<in> A" for n
<     using \<open>Inf A \<in> F n\<close> \<open>open (F n)\<close> unfolding u_def by (metis (no_types, lifting) someI_ex)
<   then have "u \<longlonglongrightarrow> Inf A" using F(3) by simp
<   then show ?thesis using * by auto
< qed
< 
607,613c521
< proof (cases x)
<   case (real r)
<   then show ?thesis using real_arch_simple[of r] by auto
< next
<   case top
<   then show ?thesis using assms by auto
< qed
---
>   using assms ennreal_ge_nat_imp_PInf linear by blast
682,697d589
< declare tendsto_ennrealI [tendsto_intros]
< 
< lemma tendsto_mult_ennreal [tendsto_intros]:
<   fixes f g::"_ \<Rightarrow> ennreal"
<   assumes "(f \<longlongrightarrow> l) F" "(g \<longlongrightarrow> m) F" "\<not>((l = 0 \<and> m = \<infinity>) \<or> (m = 0 \<and> l = \<infinity>))"
<   shows "((\<lambda>x. f x * g x) \<longlongrightarrow> l * m) F"
< proof -
<   have "((\<lambda>x. enn2ereal(f x) * enn2ereal(g x)) \<longlongrightarrow> enn2ereal l * enn2ereal m) F"
<     apply (auto intro!: tendsto_intros simp add: assms)
<     by (insert assms le_zero_eq less_eq_ennreal.rep_eq, fastforce)+
<   then have "((\<lambda>x. enn2ereal(f x * g x)) \<longlongrightarrow> enn2ereal(l * m)) F"
<     using times_ennreal.rep_eq by auto
<   then show ?thesis
<     by (auto intro!: tendsto_intros)
< qed
< 
773,787d664
< lemma emeasure_union_inter:
<   assumes "A \<in> sets M" "B \<in> sets M"
<   shows "emeasure M A + emeasure M B = emeasure M (A \<union> B) + emeasure M (A \<inter> B)"
< proof -
<   have "A = (A-B) \<union> (A \<inter> B)" by auto
<   then have 1: "emeasure M A = emeasure M (A-B) + emeasure M (A \<inter> B)"
<     by (metis Diff_Diff_Int Diff_disjoint assms(1) assms(2) plus_emeasure sets.Diff)
< 
<   have "A \<union> B = (A-B) \<union> B" by auto
<   then have 2: "emeasure M (A \<union> B) = emeasure M (A-B) + emeasure M B"
<     by (metis Diff_disjoint Int_commute assms(1) assms(2) plus_emeasure sets.Diff)
< 
<   show ?thesis using 1 2 by (metis add.assoc add.commute)
< qed
< 
1034c911
< by (rule borel_measurable_continuous_on1, intro continuous_intros)
---
> by (rule borel_measurable_continuous_onI, intro continuous_intros)
1169c1046
<       unfolding eventually_sequentially using tendsto_explicit by force
---
>       unfolding eventually_sequentially using lim_explicit by force
1222,1232d1098
< subsection \<open>Lebesgue-Measure.thy\<close>
< 
< text \<open>The next lemma is the same as \verb+lborel_distr_plus+ which is only formulated
< on the real line, but on any euclidean space\<close>
< 
< lemma lborel_distr_plus2:
<   fixes c :: "'a::euclidean_space"
<   shows "distr lborel borel ((+) c) = lborel"
< by (subst lborel_affine[of 1 c], auto simp: density_1)
< 
< 
1243c1109
<     by (simp add: assms(1) assms(2) fmeasurable_eq_sets measure_Un3)
---
>     by (simp add: assms fmeasurable_eq_sets measure_Un3)
==========
Error_Function
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Error_Function/Error_Function.thy ../../AFPs/afp-2020/thys/Error_Function/Error_Function.thy
9c9
<   imports "HOL-Analysis.Analysis" "HOL-Library.Landau_Symbols"
---
>   imports "HOL-Complex_Analysis.Complex_Analysis" "HOL-Library.Landau_Symbols"
217c217
<        (auto intro!: derivative_eq_intros has_vector_derivative_real_complex 
---
>        (auto intro!: derivative_eq_intros has_vector_derivative_real_field 
613,614c613,614
<     by (intro DERIV_zero_UNIV_unique[of "\<lambda>z. erf z - 2 / sqrt pi * A z"]) 
<        (auto intro!: derivative_eq_intros)
---
>     by (rule has_derivative_zero_unique [where f = "\<lambda>z. erf z - 2 / sqrt pi * A z" and s = UNIV])
>        (auto intro!: has_field_derivative_imp_has_derivative derivative_eq_intros)
==========
E_Transcendental
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/E_Transcendental/E_Transcendental.thy ../../AFPs/afp-2020/thys/E_Transcendental/E_Transcendental.thy
12c12
<     "HOL-Analysis.Analysis"
---
>     "HOL-Complex_Analysis.Complex_Analysis"
==========
Euler_MacLaurin
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Euler_MacLaurin/Euler_MacLaurin.thy ../../AFPs/afp-2020/thys/Euler_MacLaurin/Euler_MacLaurin.thy
4,5c4
<   "HOL-Analysis.Analysis"
<   "HOL-Library.Multiset"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
368c367
<     by (intro integral_combine assms integrable_EM_remainder')
---
>     by (intro Henstock_Kurzweil_Integration.integral_combine assms integrable_EM_remainder')
435c434
<         by (rule Lim_transform_eventually [rotated])
---
>         by (rule Lim_transform_eventually)
1443c1442
<       by (intro integral_combine [symmetric] integrable_EM_remainder' cont) auto
---
>       by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] integrable_EM_remainder' cont) auto
==========
Euler_Partition
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Euler_Partition/Euler_Partition.thy ../../AFPs/afp-2020/thys/Euler_Partition/Euler_Partition.thy
40,62d39
< subsubsection \<open>Additions to Set-Interval Theory\<close>
< 
< lemma geometric_sum_2nat:
<   "(\<Sum>i<n. (2::nat) ^ i) = (2 ^ n - 1)"
< by (induct n) auto
< 
< subsubsection \<open>Additions to Nat Theory or Power Theory\<close>
< 
< lemma n_leq_2_pow_n:
<   "n \<le> 2 ^ n"
< proof (induct n)
<   case (Suc n)
<   from this have approx: "2 * n \<le> 2 ^ Suc n" by auto
<   show ?case
<   proof (cases n)
<     case 0
<     from this show ?thesis by simp
<   next
<     case Suc
<     from this show ?thesis by (intro le_trans[OF _ approx]) simp
<   qed
< qed (simp)
< 
68,70c45,47
<   have "{i::nat. 2 ^ i \<le> n} \<subseteq> {..n}"
<     using dual_order.trans n_leq_2_pow_n by auto
<   from this show ?thesis by (simp add: finite_subset)
---
>   have "{i::nat. 2 ^ i \<le> n} \<subseteq> {0..n}"
>     using dual_order.trans by fastforce
>   from finite_subset[OF this] show ?thesis by simp
85c62
< by (auto dest: in_bitset_bound intro: le_trans n_leq_2_pow_n)
---
> by (meson order.trans in_bitset_bound self_le_ge2_pow[OF order_refl])
98,104d74
< lemma binary_induct [case_names zero even odd]:
<   assumes "P (0 :: nat)"
<   assumes "\<And>n. P n \<Longrightarrow> P (2 * n)"
<   assumes "\<And>n. P n \<Longrightarrow> P (2 * n + 1)"
<   shows "\<And>n. P n"
< using assms parity_induct by auto
< 
127c97
< proof (induct rule: binary_induct)
---
> proof (induct rule: nat_bit_induct)
142c112
<   finally show ?case .
---
>   finally show ?case by simp
154c124
<     show "... < 2 ^ j" by (simp add: geometric_sum_2nat)
---
>     show "... < 2 ^ j" using sum_power2 by (simp add: atLeast0LessThan)
==========
Fermat3_4
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fermat3_4/Fermat4.thy ../../AFPs/afp-2020/thys/Fermat3_4/Fermat4.thy
88c88,89
<   also with a2_ge_b2 have "\<dots> = a*b + (a^2 - b^2) + b^2 - 2*a*b" by simp
---
>   also with a2_ge_b2 have "\<dots> = a*b + (a^2 - b^2) + b^2 - 2*a*b"
>     by (simp add: power2_eq_square)
96,101c97
< proof -
<   assume "n \<noteq> 0" and ab: "a^n \<le> b^n"
<   then obtain m where "n = Suc m" by (frule_tac n="n" in not0_implies_Suc, auto)
<   with ab have "a \<ge> 0" and "a^Suc m \<le> b^Suc m" and "b \<ge> 0" by auto
<   thus ?thesis by (rule_tac n="m" in power_le_imp_le_base)
< qed
---
>   by simp
136c132
<     from abc have "b^2 \<le> c^2" by auto
---
>     from abc have "b^2 \<le> c^2" by linarith
319,320c315,316
<     assume "\<not> n^2 \<le> m^2" hence "n^2 > m^2" by simp 
<     with mn have "?a = 0" by simp
---
>     assume "\<not> n^2 \<le> m^2"
>     with mn have "?a = 0" by auto
==========
First_Welfare_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Argmax.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Argmax.thy
8c8
<     "HOL-Analysis.Analysis"
---
>     "Complex_Main"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Microeconomics/Arrow_Debreu_Model.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Microeconomics/Arrow_Debreu_Model.thy
12d11
<     "HOL-Analysis.Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Microeconomics/Common.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Microeconomics/Common.thy
10d9
<     "HOL-Analysis.Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Microeconomics/Consumers.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Microeconomics/Consumers.thy
14,15c14,15
<   imports
<     "HOL-Analysis.Analysis"
---
>   imports                 
>     "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Microeconomics/Exchange_Economy.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Microeconomics/Exchange_Economy.thy
10d9
<     "HOL-Analysis.Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Microeconomics/Private_Ownership_Economy.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Microeconomics/Private_Ownership_Economy.thy
16d15
<     "HOL-Analysis.Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Preferences.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Preferences.thy
13c13
<     "HOL-Analysis.Analysis"
---
>     "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/First_Welfare_Theorem/Utility_Functions.thy ../../AFPs/afp-2020/thys/First_Welfare_Theorem/Utility_Functions.thy
14d13
<     Syntax
16d14
<     "HOL-Analysis.Analysis"
==========
Flyspeck-Tame
Only in ../../AFPs/afp-2019/thys/Flyspeck-Tame: ArchComp.thy
Only in ../../AFPs/afp-2019/thys/Flyspeck-Tame: Completeness.thy
Only in ../../AFPs/afp-2020/thys/Flyspeck-Tame: Computation
==========
FOL-Fitting
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/FOL-Fitting/FOL_Fitting.thy ../../AFPs/afp-2020/thys/FOL-Fitting/FOL_Fitting.thy
2c2
<     Author: Andreas Halkjr From, DTU Compute, 2019
---
>     Author: Asta Halkjr From, DTU Compute, 2019
2226c2226
<   assume \<open>S \<in> {set G |G. \<not> G \<turnstile> FF}\<close> (is \<open>S \<in> ?C\<close>)
---
>   assume \<open>S \<in> {set G | G. \<not> G \<turnstile> FF}\<close> (is \<open>S \<in> ?C\<close>)
==========
FOL_Seq_Calc1
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/FOL_Seq_Calc1/Common.thy ../../AFPs/afp-2020/thys/FOL_Seq_Calc1/Common.thy
2c2
<     Author: Andreas Halkjr From, DTU Compute, 2019
---
>     Author: Asta Halkjr From, DTU Compute, 2019
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/FOL_Seq_Calc1/Sequent.thy ../../AFPs/afp-2020/thys/FOL_Seq_Calc1/Sequent.thy
2c2
<     Author: Andreas Halkjr From, DTU Compute, 2019
---
>     Author: Asta Halkjr From, DTU Compute, 2019
34c34
< lemma \<open>\<turnstile> [Neg (Pred ''A'' []) , Pred ''A'' []]\<close>
---
> lemma \<open>\<turnstile> [Neg (Pred ''A'' []), Pred ''A'' []]\<close>
51c51
< lemma sc_soundness: \<open>\<turnstile> G \<Longrightarrow> \<exists>p \<in> set G. eval e f g p\<close>
---
> lemma SC_soundness: \<open>\<turnstile> G \<Longrightarrow> \<exists>p \<in> set G. eval e f g p\<close>
188c188
< theorem sc_completeness:
---
> theorem SC_completeness:
203c203
<   using assms sc_completeness list.map(1) by metis
---
>   using assms SC_completeness list.map(1) by metis
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/FOL_Seq_Calc1/Tableau.thy ../../AFPs/afp-2020/thys/FOL_Seq_Calc1/Tableau.thy
2c2
<     Author: Andreas Halkjr From, DTU Compute, 2019
---
>     Author: Asta Halkjr From, DTU Compute, 2019
37c37
< theorem tableauNotAA: \<open>\<stileturn> [Neg (Pred ''A'' []) , Pred ''A'' []]\<close>
---
> theorem tableauNotAA: \<open>\<stileturn> [Neg (Pred ''A'' []), Pred ''A'' []]\<close>
140c140
<   assume \<open>S \<in> {set G |G. \<not> (\<stileturn> G)}\<close> (is \<open>S \<in> ?C\<close>)
---
>   assume \<open>S \<in> {set G | G. \<not> (\<stileturn> G)}\<close> (is \<open>S \<in> ?C\<close>)
==========
Formula_Derivatives
Only in ../../AFPs/afp-2020/thys/Formula_Derivatives: Examples
Only in ../../AFPs/afp-2019/thys/Formula_Derivatives: Presburger_Examples.thy
Only in ../../AFPs/afp-2019/thys/Formula_Derivatives: WS1S_Alt_Examples.thy
Only in ../../AFPs/afp-2019/thys/Formula_Derivatives: WS1S_Examples.thy
Only in ../../AFPs/afp-2019/thys/Formula_Derivatives: WS1S_Nameful_Examples.thy
Only in ../../AFPs/afp-2019/thys/Formula_Derivatives: WS1S_Presburger_Examples.thy
==========
Fourier
Only in ../../AFPs/afp-2019/thys/Fourier: Fourier_Aux1.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fourier/Fourier_Aux2.thy ../../AFPs/afp-2020/thys/Fourier/Fourier_Aux2.thy
1c1
< section\<open>Lemmas destined for the development version\<close>
---
> section\<open>Lemmas possibly destined for future Isabelle releases\<close>
4c4
<   imports Fourier_Aux1 Ergodic_Theory.SG_Library_Complement
---
>   imports "HOL-Analysis.Analysis" 
6,60c6
< 
< lemma has_integral_divide:
<   fixes c :: "_ :: real_normed_div_algebra"
<   shows "(f has_integral y) S \<Longrightarrow> ((\<lambda>x. f x / c) has_integral (y / c)) S"
<   unfolding divide_inverse
<   by (simp add: has_integral_mult_left)
< 
< lemma integral_sin [simp]:
<   fixes a::real
<   assumes "a \<le> b" shows "integral {a..b} sin = cos a - cos b"
< proof -
<   have "(sin has_integral (- cos b - - cos a)) {a..b}"
<   proof (rule fundamental_theorem_of_calculus)
<     show "((\<lambda>a. - cos a) has_vector_derivative sin x) (at x within {a..b})" for x
<       unfolding has_field_derivative_iff_has_vector_derivative [symmetric]
<       by (rule derivative_eq_intros | force)+
<   qed (use assms in auto)
<   then show ?thesis
<     by (simp add: integral_unique)
< qed
< 
< lemma integral_cos [simp]:
<   fixes a::real
<   assumes "a \<le> b" shows "integral {a..b} cos = sin b - sin a"
< proof -
<   have "(cos has_integral (sin b - sin a)) {a..b}"
<   proof (rule fundamental_theorem_of_calculus)
<     show "(sin has_vector_derivative cos x) (at x within {a..b})" for x
<       unfolding has_field_derivative_iff_has_vector_derivative [symmetric]
<       by (rule derivative_eq_intros | force)+
<   qed (use assms in auto)
<   then show ?thesis
<     by (simp add: integral_unique)
< qed
< 
< lemma has_integral_sin_nx: "((\<lambda>x. sin(real_of_int n * x)) has_integral 0) {-pi..pi}"
< proof (cases "n = 0")
<   case False
<   have "((\<lambda>x. sin (n * x)) has_integral (- cos (n * pi)/n - - cos (n * - pi)/n)) {-pi..pi}"
<   proof (rule fundamental_theorem_of_calculus)
<     show "((\<lambda>x. - cos (n * x) / n) has_vector_derivative sin (n * a)) (at a within {-pi..pi})"
<       if "a \<in> {-pi..pi}" for a :: real
<       using that False
<       apply (simp only: has_vector_derivative_def)
<       apply (rule derivative_eq_intros | force)+
<       done
<   qed auto
<   then show ?thesis
<     by simp
< qed auto
< 
< lemma integral_sin_nx:
<    "integral {-pi..pi} (\<lambda>x. sin(x * real_of_int n)) = 0"
<   using has_integral_sin_nx [of n] by (force simp: mult.commute)
< 
---
>     
75,101c21
< 
< lemma has_integral_cos_nx:
<   "((\<lambda>x. cos(real_of_int n * x)) has_integral (if n = 0 then 2 * pi else 0)) {-pi..pi}"
< proof (cases "n = 0")
<   case True
<   then show ?thesis
<     using has_integral_const_real [of "1::real" "-pi" pi] by auto
< next
<   case False
<   have "((\<lambda>x. cos (n * x)) has_integral (sin (n * pi)/n - sin (n * - pi)/n)) {-pi..pi}"
<   proof (rule fundamental_theorem_of_calculus)
<     show "((\<lambda>x. sin (n * x) / n) has_vector_derivative cos (n * x)) (at x within {-pi..pi})"
<       if "x \<in> {-pi..pi}"
<       for x :: real
<       using that False
<       apply (simp only: has_vector_derivative_def)
<       apply (rule derivative_eq_intros | force)+
<       done
<   qed auto
<   with False show ?thesis
<     by (simp add: mult.commute)
< qed
< 
< lemma integral_cos_nx:
<    "integral {-pi..pi} (\<lambda>x. cos(x * real_of_int n)) = (if n = 0 then 2 * pi else 0)"
<   using has_integral_cos_nx [of n] by (force simp: mult.commute)
< 
---
>     
117,168d36
< lemma real_tendsto_mult_left_iff:
<    "c \<noteq> 0 \<Longrightarrow> tendsto(\<lambda>x. c * f x) (c * l) F \<longleftrightarrow> tendsto f l F" for c :: real
<   by (auto simp: tendsto_mult_left dest: tendsto_mult_left [where c = "1/c"])
< 
< lemma real_tendsto_mult_right_iff:
<    "c \<noteq> 0 \<Longrightarrow> tendsto(\<lambda>x. f x * c) (l * c) F \<longleftrightarrow> tendsto f l F" for c :: real
<   by (simp add: mult.commute real_tendsto_mult_left_iff)
< 
< lemma real_tendsto_zero_mult_right_iff [simp]:
<   fixes c::real assumes "c \<noteq> 0" shows "(\<lambda>n. a n * c)\<longlonglongrightarrow> 0 \<longleftrightarrow> a \<longlonglongrightarrow> 0"
<   by (metis assms mult_zero_left real_tendsto_mult_right_iff)
< 
< lemma real_tendsto_zero_divide_iff [simp]:
<   fixes c::real assumes "c \<noteq> 0" shows "(\<lambda>n. a n / c)\<longlonglongrightarrow> 0 \<longleftrightarrow> a \<longlonglongrightarrow> 0"
<   using real_tendsto_zero_mult_right_iff [of "1/c" a] assms by (simp add: field_simps)
< 
< lemma measurable_restrict_mono:
<   assumes f: "f \<in> restrict_space M A \<rightarrow>\<^sub>M N" and "B \<subseteq> A"
<   shows "f \<in> restrict_space M B \<rightarrow>\<^sub>M N"
< by (rule measurable_compose[OF measurable_restrict_space3 f])
<    (insert \<open>B \<subseteq> A\<close>, auto)
< 
< lemma borel_measurable_if_lebesgue_on:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "S \<in> sets lebesgue" "T \<in> sets lebesgue" "S \<subseteq> T"
<   shows "(\<lambda>x. if x \<in> S then f x else 0) \<in> borel_measurable (lebesgue_on T) \<longleftrightarrow> f \<in> borel_measurable (lebesgue_on S)"
<   (is "?lhs = ?rhs")
< proof
<   assume ?lhs then show ?rhs
<     using measurable_restrict_mono [OF _ \<open>S \<subseteq> T\<close>]
<     by (subst measurable_lebesgue_cong [where g = "(\<lambda>x. if x \<in> S then f x else 0)"]) auto
< next
<   assume ?rhs then show ?lhs
<   by (simp add: \<open>S \<in> sets lebesgue\<close> borel_measurable_If_I measurable_restrict_space1)
< qed
< 
< 
< lemma insert_sets_lebesgue_on:
<   assumes "A \<in> sets (lebesgue_on S)" "a \<in> S" "S \<in> sets lebesgue"
<   shows "insert a A \<in> sets (lebesgue_on S)"
<   by (metis assms borel_singleton insert_subset lborelD sets.Int_space_eq2 sets.empty_sets sets.insert_in_sets sets_completionI_sets sets_restrict_space_iff)
< 
< lemma integrable_lebesgue_on_empty [iff]:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::{second_countable_topology,banach}"
<   shows "integrable (lebesgue_on {}) f"
<   by (simp add: integrable_restrict_space)
< 
< lemma integral_lebesgue_on_empty [simp]:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::{second_countable_topology,banach}"
<   shows "integral\<^sup>L (lebesgue_on {}) f = 0"
<   by (simp add: Bochner_Integration.integral_empty)
< 
173,2170d40
< 
< lemma null_AE_impI: "\<lbrakk>N \<in> null_sets (lebesgue_on S); S \<in> sets lebesgue\<rbrakk> \<Longrightarrow> AE x in lebesgue_on S. x \<in> N \<longrightarrow> P x"
<   by (rule AE_I' [of N]) auto
< 
< lemma has_bochner_integral_restrict_space:
<   fixes f :: "'a \<Rightarrow> 'b::{banach, second_countable_topology}"
<   assumes \<Omega>: "\<Omega> \<inter> space M \<in> sets M"
<   shows "has_bochner_integral (restrict_space M \<Omega>) f i
<      \<longleftrightarrow> has_bochner_integral M (\<lambda>x. indicator \<Omega> x *\<^sub>R f x) i"
<   by (simp add: integrable_restrict_space [OF assms] integral_restrict_space [OF assms] has_bochner_integral_iff)
< 
< lemma integrable_restrict_UNIV:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::{banach, second_countable_topology}"
<   assumes S: "S \<in> sets lebesgue"
<   shows  "integrable lebesgue (\<lambda>x. if x \<in> S then f x else 0) \<longleftrightarrow> integrable (lebesgue_on S) f"
<   using has_bochner_integral_restrict_space [of S lebesgue f] assms
<   by (simp add: integrable.simps indicator_scaleR_eq_if)
< 
< lemma integral_mono_lebesgue_on_AE:
<   fixes f::"_ \<Rightarrow> real"
<   assumes f: "integrable (lebesgue_on T) f"
<     and gf: "AE x in (lebesgue_on S). g x \<le> f x"
<     and f0: "AE x in (lebesgue_on T). 0 \<le> f x"
<     and "S \<subseteq> T" and S: "S \<in> sets lebesgue" and T: "T \<in> sets lebesgue"
<   shows "(\<integral>x. g x \<partial>(lebesgue_on S)) \<le> (\<integral>x. f x \<partial>(lebesgue_on T))"
< proof -
<   have "(\<integral>x. g x \<partial>(lebesgue_on S)) = (\<integral>x. (if x \<in> S then g x else 0) \<partial>lebesgue)"
<     by (simp add: integral_restrict_UNIV S)
<   also have "\<dots> \<le> (\<integral>x. (if x \<in> T then f x else 0) \<partial>lebesgue)"
<   proof (rule Bochner_Integration.integral_mono_AE')
<     show "integrable lebesgue (\<lambda>x. if x \<in> T then f x else 0)"
<       by (simp add: integrable_restrict_UNIV T f)
<     show "AE x in lebesgue. (if x \<in> S then g x else 0) \<le> (if x \<in> T then f x else 0)"
<       using assms by (auto simp: AE_restrict_space_iff)
<     show "AE x in lebesgue. 0 \<le> (if x \<in> T then f x else 0)"
<       using f0 by (simp add: AE_restrict_space_iff T)
<   qed
<   also have "\<dots> = (\<integral>x. f x \<partial>(lebesgue_on T))"
<     using integral_restrict_UNIV T by blast
<   finally show ?thesis .
< qed
< 
< 
< 
< lemma integrable_subinterval_real:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes "integrable (lebesgue_on {a..b}) f"
<     and "{c..d} \<subseteq> {a..b}"
<   shows "integrable (lebesgue_on {c..d}) f"
<   by (metis (full_types) absolutely_integrable_on_def assms fmeasurableD integrable_restrict_space integrable_subinterval_real interval_cbox lmeasurable_cbox set_integrable_def sets.Int_space_eq2)
< 
< 
< lemma indefinite_integral_continuous_1:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes "integrable (lebesgue_on {a..b}) f"
<   shows "continuous_on {a..b} (\<lambda>x. integral\<^sup>L (lebesgue_on {a..x}) f)"
< proof -
<   have "f integrable_on {a..b}"
<     by (simp add: assms integrable_on_lebesgue_on)
<   then have "continuous_on {a..b} (\<lambda>x. integral {a..x} f)"
<     using indefinite_integral_continuous_1 by blast
<   moreover have "integral\<^sup>L (lebesgue_on {a..x}) f = integral {a..x} f" if "a \<le> x" "x \<le> b" for x
<   proof -
<     have "{a..x} \<subseteq> {a..b}"
<       using that by auto
<     then have "integrable (lebesgue_on {a..x}) f"
<       using integrable_subinterval_real assms by blast
<     then show "integral\<^sup>L (lebesgue_on {a..x}) f = integral {a..x} f"
<       by (smt integrable_restrict_UNIV integral_restrict_UNIV Henstock_Kurzweil_Integration.integral_restrict_UNIV atLeastAtMost_borel integral_lebesgue sets_completionI_sets sets_lborel)
<   qed
<   ultimately show ?thesis
<     by (metis (no_types, lifting) atLeastAtMost_iff continuous_on_cong)
< qed
< 
< 
< lemma AE_null_sets_lebesgue:
<   assumes "AE x in lebesgue. P x"
<   obtains N where "N \<in> null_sets lebesgue" "\<And>x. x \<notin> N \<Longrightarrow> P x"
<   using assms unfolding completion.AE_iff_null_sets  by auto
< 
< 
< lemma measure_lebesgue_on_ivl [simp]: "\<lbrakk>{a..b} \<subseteq> S; S \<in> sets lebesgue\<rbrakk> \<Longrightarrow> measure (lebesgue_on S) {a..b} = content {a..b::real}"
<   by (simp add: measure_restrict_space)
< 
< 
< 
< subsection\<open>Linear functions are (uniformly) continuous on any set\<close>
< 
< lemma linear_lim_0:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::real_normed_vector"
<   assumes "linear f"
<   shows "(f \<longlongrightarrow> 0) (at 0)"
< proof -
<   obtain B where "B > 0" "\<And>x. norm (f x) \<le> B * norm x"
<     using assms linear_bounded_pos by blast
<   then have "\<And>e x. \<lbrakk>0 < e; x \<noteq> 0; norm x < e / B\<rbrakk> \<Longrightarrow> norm (f x) < e"
<     by (metis le_less_trans mult.commute pos_less_divide_eq)
<   then show ?thesis
<     unfolding Lim_at dist_norm
<     by (metis \<open>0 < B\<close> diff_zero divide_pos_pos zero_less_norm_iff)
< qed
< 
< lemma linear_continuous_at:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::real_normed_vector"
<   assumes "linear f"
<   shows "continuous (at a) f"
<   using assms has_derivative_continuous linear_imp_has_derivative by blast
< 
< 
< lemma linear_continuous_within:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::real_normed_vector"
<   assumes "linear f"
<   shows "continuous (at x within S) f"
<   by (simp add: assms differentiable_imp_continuous_within linear_imp_differentiable)
< 
< lemma linear_continuous_on:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::real_normed_vector"
<   assumes "linear f"
<   shows "continuous_on S f"
<   by (simp add: continuous_at_imp_continuous_on linear_continuous_within assms)
< 
< lemma Lim_linear:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space" and h :: "'b \<Rightarrow> 'c::real_normed_vector"
<   assumes "(f \<longlongrightarrow> l) F" "linear h"
<   shows "((\<lambda>x. h(f x)) \<longlongrightarrow> h l) F"
< proof -
<   obtain B where B: "B > 0" "\<And>x. norm (h x) \<le> B * norm x"
<     using linear_bounded_pos [OF \<open>linear h\<close>] by blast
<   show ?thesis
<     unfolding tendsto_iff
<   proof (intro allI impI)
<     show "\<forall>\<^sub>F x in F. dist (h (f x)) (h l) < e" if "e > 0" for e
<     proof -
<       have "\<forall>\<^sub>F x in F. dist (f x) l < e/B"
<         by (simp add: \<open>0 < B\<close> assms(1) tendstoD that)
<       then show ?thesis
<         unfolding dist_norm
<       proof (rule eventually_mono)
<         show "norm (h (f x) - h l) < e" if "norm (f x - l) < e / B" for x
<           using that B
<           apply (simp add: divide_simps)
<           by (metis \<open>linear h\<close> le_less_trans linear_diff mult.commute)
<       qed
<     qed
<   qed
< qed
< 
< lemma linear_continuous_compose:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space" and g :: "'b \<Rightarrow> 'c::real_normed_vector"
<   assumes "continuous F f" "linear g"
<   shows "continuous F (\<lambda>x. g(f x))"
<   using assms unfolding continuous_def by (rule Lim_linear)
< 
< lemma linear_continuous_on_compose:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space" and g :: "'b \<Rightarrow> 'c::real_normed_vector"
<   assumes "continuous_on S f" "linear g"
<   shows "continuous_on S (\<lambda>x. g(f x))"
<   using assms by (simp add: continuous_on_eq_continuous_within linear_continuous_compose)
< 
< 
< subsection\<open>Also bilinear functions, in composition form\<close>
< 
< 
< lemma bilinear_continuous_compose:
<   fixes h :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space \<Rightarrow> 'c::real_normed_vector"
<   assumes "continuous F f" "continuous F g" "bilinear h"
<   shows "continuous F (\<lambda>x. h (f x) (g x))"
<   using assms Lim_bilinear bilinear_conv_bounded_bilinear
<   unfolding continuous_def
<   by blast
< 
< lemma bilinear_continuous_on_compose:
<   fixes h :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space \<Rightarrow> 'c::real_normed_vector"
<     and f :: "'d::t2_space \<Rightarrow> 'a"
<   assumes "continuous_on S f" "continuous_on S g" "bilinear h"
<   shows "continuous_on S (\<lambda>x. h (f x) (g x))"
<   using assms
<   by (simp add: continuous_on_eq_continuous_within bilinear_continuous_compose)
< 
< 
< 
< 
< 
< subsection\<open>Austin's Lemma\<close>
< 
< lemma Austin_Lemma:
<   fixes \<D> :: "'a::euclidean_space set set"
<   assumes "finite \<D>" and \<D>: "\<And>D. D \<in> \<D> \<Longrightarrow> \<exists>k a b. D = cbox a b \<and> (\<forall>i \<in> Basis. b\<bullet>i - a\<bullet>i = k)"
<   obtains \<C> where "\<C> \<subseteq> \<D>" "pairwise disjnt \<C>"
<                   "measure lebesgue (\<Union>\<C>) \<ge> measure lebesgue (\<Union>\<D>) / 3 ^ (DIM('a))"
<   using assms
< proof (induction "card \<D>" arbitrary: \<D> thesis rule: less_induct)
<   case less
<   show ?case
<   proof (cases "\<D> = {}")
<     case True
<     then show thesis
<       using less by auto
<   next
<     case False
<     then have "Max (Sigma_Algebra.measure lebesgue ` \<D>) \<in> Sigma_Algebra.measure lebesgue ` \<D>"
<       using Max_in finite_imageI \<open>finite \<D>\<close> by blast
<     then obtain D where "D \<in> \<D>" and "measure lebesgue D = Max (measure lebesgue ` \<D>)"
<       by auto
<     then have D: "\<And>C. C \<in> \<D> \<Longrightarrow> measure lebesgue C \<le> measure lebesgue D"
<       by (simp add: \<open>finite \<D>\<close>)
<     let ?\<E> = "{C. C \<in> \<D> - {D} \<and> disjnt C D}"
<     obtain \<D>' where \<D>'sub: "\<D>' \<subseteq> ?\<E>" and \<D>'dis: "pairwise disjnt \<D>'"
<       and \<D>'m: "measure lebesgue (\<Union>\<D>') \<ge> measure lebesgue (\<Union>?\<E>) / 3 ^ (DIM('a))"
<     proof (rule less.hyps)
<       have *: "?\<E> \<subset> \<D>"
<         using \<open>D \<in> \<D>\<close> by auto
<       then show "card ?\<E> < card \<D>" "finite ?\<E>"
<         by (auto simp: \<open>finite \<D>\<close> psubset_card_mono)
<       show "\<exists>k a b. D = cbox a b \<and> (\<forall>i\<in>Basis. b \<bullet> i - a \<bullet> i = k)" if "D \<in> ?\<E>" for D
<         using less.prems(3) that by auto
<     qed
<     then have [simp]: "\<Union>\<D>' - D = \<Union>\<D>'"
<       by (auto simp: disjnt_iff)
<     show ?thesis
<     proof (rule less.prems)
<       show "insert D \<D>' \<subseteq> \<D>"
<         using \<D>'sub \<open>D \<in> \<D>\<close> by blast
<       show "disjoint (insert D \<D>')"
<         using \<D>'dis \<D>'sub by (fastforce simp add: pairwise_def disjnt_sym)
<       obtain a3 b3 where  m3: "content (cbox a3 b3) = 3 ^ DIM('a) * measure lebesgue D"
<         and sub3: "\<And>C. \<lbrakk>C \<in> \<D>; \<not> disjnt C D\<rbrakk> \<Longrightarrow> C \<subseteq> cbox a3 b3"
<       proof -
<         obtain k a b where ab: "D = cbox a b" and k: "\<And>i. i \<in> Basis \<Longrightarrow> b\<bullet>i - a\<bullet>i = k"
<           using less.prems \<open>D \<in> \<D>\<close> by blast
<         then have eqk: "\<And>i. i \<in> Basis \<Longrightarrow> a \<bullet> i \<le> b \<bullet> i \<longleftrightarrow> k \<ge> 0"
<           by force
<         show thesis
<         proof
<           let ?a = "(a + b) /\<^sub>R 2 - (3/2) *\<^sub>R (b - a)"
<           let ?b = "(a + b) /\<^sub>R 2 + (3/2) *\<^sub>R (b - a)"
<           have eq: "(\<Prod>i\<in>Basis. b \<bullet> i * 3 - a \<bullet> i * 3) = (\<Prod>i\<in>Basis. b \<bullet> i - a \<bullet> i) * 3 ^ DIM('a)"
<             by (simp add: comm_monoid_mult_class.prod.distrib flip: left_diff_distrib inner_diff_left)
<           show "content (cbox ?a ?b) = 3 ^ DIM('a) * measure lebesgue D"
<             by (simp add: content_cbox_if box_eq_empty algebra_simps eq ab k)
<           show "C \<subseteq> cbox ?a ?b" if "C \<in> \<D>" and CD: "\<not> disjnt C D" for C
<           proof -
<             obtain k' a' b' where ab': "C = cbox a' b'" and k': "\<And>i. i \<in> Basis \<Longrightarrow> b'\<bullet>i - a'\<bullet>i = k'"
<               using less.prems \<open>C \<in> \<D>\<close> by blast
<             then have eqk': "\<And>i. i \<in> Basis \<Longrightarrow> a' \<bullet> i \<le> b' \<bullet> i \<longleftrightarrow> k' \<ge> 0"
<               by force
<             show ?thesis
<             proof (clarsimp simp add: disjoint_interval disjnt_def ab ab' not_less subset_box algebra_simps)
<               show "a \<bullet> i * 2 \<le> a' \<bullet> i + b \<bullet> i \<and> a \<bullet> i + b' \<bullet> i \<le> b \<bullet> i * 2"
<                 if * [rule_format]: "\<forall>j\<in>Basis. a' \<bullet> j \<le> b' \<bullet> j" and "i \<in> Basis" for i
<               proof -
<                 have "a' \<bullet> i \<le> b' \<bullet> i \<and> a \<bullet> i \<le> b \<bullet> i \<and> a \<bullet> i \<le> b' \<bullet> i \<and> a' \<bullet> i \<le> b \<bullet> i"
<                   using \<open>i \<in> Basis\<close> CD by (simp_all add: disjoint_interval disjnt_def ab ab' not_less)
<                 then show ?thesis
<                   using D [OF \<open>C \<in> \<D>\<close>] \<open>i \<in> Basis\<close>
<                   apply (simp add: ab ab' k k' eqk eqk' content_cbox_cases)
<                   using k k' by fastforce
<               qed
<             qed
<           qed
<         qed
<       qed
<       have \<D>lm: "\<And>D. D \<in> \<D> \<Longrightarrow> D \<in> lmeasurable"
<         using less.prems(3) by blast
<       have "measure lebesgue (\<Union>\<D>)  \<le> measure lebesgue (cbox a3 b3 \<union> (\<Union>\<D> - cbox a3 b3))"
<       proof (rule measure_mono_fmeasurable)
<         show "\<Union>\<D> \<in> sets lebesgue"
<           using \<D>lm \<open>finite \<D>\<close> by blast
<         show "cbox a3 b3 \<union> (\<Union>\<D> - cbox a3 b3) \<in> lmeasurable"
<           by (simp add: \<D>lm fmeasurable.Un fmeasurable.finite_Union less.prems(2) subset_eq)
<       qed auto
<       also have "\<dots> = content (cbox a3 b3) + measure lebesgue (\<Union>\<D> - cbox a3 b3)"
<         by (simp add: \<D>lm fmeasurable.finite_Union less.prems(2) measure_Un2 subsetI)
<       also have "\<dots> \<le> (measure lebesgue D + measure lebesgue (\<Union>\<D>')) * 3 ^ DIM('a)"
<       proof -
<         have "(\<Union>\<D> - cbox a3 b3) \<subseteq> \<Union>?\<E>"
<           using sub3 by fastforce
<         then have "measure lebesgue (\<Union>\<D> - cbox a3 b3) \<le> measure lebesgue (\<Union>?\<E>)"
<         proof (rule measure_mono_fmeasurable)
<           show "\<Union> \<D> - cbox a3 b3 \<in> sets lebesgue"
<             by (simp add: \<D>lm fmeasurableD less.prems(2) sets.Diff sets.finite_Union subsetI)
<           show "\<Union> {C \<in> \<D> - {D}. disjnt C D} \<in> lmeasurable"
<             using \<D>lm less.prems(2) by auto
<         qed
<         then have "measure lebesgue (\<Union>\<D> - cbox a3 b3) / 3 ^ DIM('a) \<le> measure lebesgue (\<Union> \<D>')"
<           using \<D>'m by (simp add: divide_simps)
<         then show ?thesis
<           by (simp add: m3 field_simps)
<       qed
<       also have "\<dots> \<le> measure lebesgue (\<Union>(insert D \<D>')) * 3 ^ DIM('a)"
<       proof (simp add: \<D>lm \<open>D \<in> \<D>\<close>)
<         show "measure lebesgue D + measure lebesgue (\<Union>\<D>') \<le> measure lebesgue (D \<union> \<Union> \<D>')"
<         proof (subst measure_Un2)
<           show "\<Union> \<D>' \<in> lmeasurable"
<             by (meson \<D>lm \<open>insert D \<D>' \<subseteq> \<D>\<close> fmeasurable.finite_Union less.prems(2) finite_subset subset_eq subset_insertI)
<           show "measure lebesgue D + measure lebesgue (\<Union> \<D>') \<le> measure lebesgue D + measure lebesgue (\<Union> \<D>' - D)"
<             using \<open>insert D \<D>' \<subseteq> \<D>\<close> infinite_super less.prems(2) by force
<         qed (simp add: \<D>lm \<open>D \<in> \<D>\<close>)
<       qed
<       finally show "measure lebesgue (\<Union>\<D>) / 3 ^ DIM('a) \<le> measure lebesgue (\<Union>(insert D \<D>'))"
<         by (simp add: divide_simps)
<     qed
<   qed
< qed
< 
< 
< subsection\<open>A differentiability-like property of the indefinite integral.        \<close>
< 
< proposition integrable_ccontinuous_explicit:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "\<And>a b::'a. f integrable_on cbox a b"
<   obtains N where
<        "negligible N"
<        "\<And>x e. \<lbrakk>x \<notin> N; 0 < e\<rbrakk> \<Longrightarrow>
<                \<exists>d>0. \<forall>h. 0 < h \<and> h < d \<longrightarrow>
<                          norm(integral (cbox x (x + h *\<^sub>R One)) f /\<^sub>R h ^ DIM('a) - f x) < e"
< proof -
<   define BOX where "BOX \<equiv> \<lambda>h. \<lambda>x::'a. cbox x (x + h *\<^sub>R One)"
<   define BOX2 where "BOX2 \<equiv> \<lambda>h. \<lambda>x::'a. cbox (x - h *\<^sub>R One) (x + h *\<^sub>R One)"
<   define i where "i \<equiv> \<lambda>h x. integral (BOX h x) f /\<^sub>R h ^ DIM('a)"
<   define \<Psi> where "\<Psi> \<equiv> \<lambda>x r. \<forall>d>0. \<exists>h. 0 < h \<and> h < d \<and> r \<le> norm(i h x - f x)"
<   let ?N = "{x. \<exists>e>0. \<Psi> x e}"
<   have "\<exists>N. negligible N \<and> (\<forall>x e. x \<notin> N \<and> 0 < e \<longrightarrow> \<not> \<Psi> x e)"
<   proof (rule exI ; intro conjI allI impI)
<     let ?M =  "\<Union>n. {x. \<Psi> x (inverse(real n + 1))}"
<     have "negligible ({x. \<Psi> x \<mu>} \<inter> cbox a b)"
<       if "\<mu> > 0" for a b \<mu>
<     proof (cases "negligible(cbox a b)")
<       case True
<       then show ?thesis
<         by (simp add: negligible_Int)
<     next
<       case False
<       then have "box a b \<noteq> {}"
<         by (simp add: negligible_interval)
<       then have ab: "\<And>i. i \<in> Basis \<Longrightarrow> a\<bullet>i < b\<bullet>i"
<         by (simp add: box_ne_empty)
<       show ?thesis
<         unfolding negligible_outer_le
<       proof (intro allI impI)
<         fix e::real
<         let ?ee = "(e * \<mu>) / 2 / 6 ^ (DIM('a))"
<         assume "e > 0"
<         then have gt0: "?ee > 0"
<           using \<open>\<mu> > 0\<close> by auto
<         have f': "f integrable_on cbox (a - One) (b + One)"
<           using assms by blast
<         obtain \<gamma> where "gauge \<gamma>"
<           and \<gamma>: "\<And>p. \<lbrakk>p tagged_partial_division_of (cbox (a - One) (b + One)); \<gamma> fine p\<rbrakk>
<                     \<Longrightarrow> (\<Sum>(x, k)\<in>p. norm (content k *\<^sub>R f x - integral k f)) < ?ee"
<           using Henstock_lemma [OF f' gt0] that by auto
<         let ?E = "{x. x \<in> cbox a b \<and> \<Psi> x \<mu>}"
<         have "\<exists>h>0. BOX h x \<subseteq> \<gamma> x \<and>
<                     BOX h x \<subseteq> cbox (a - One) (b + One) \<and> \<mu> \<le> norm (i h x - f x)"
<           if "x \<in> cbox a b" "\<Psi> x \<mu>" for x
<         proof -
<           obtain d where "d > 0" and d: "ball x d \<subseteq> \<gamma> x"
<             using gaugeD [OF \<open>gauge \<gamma>\<close>, of x] openE by blast
<           then obtain h where "0 < h" "h < 1" and hless: "h < d / real DIM('a)"
<                           and mule: "\<mu> \<le> norm (i h x - f x)"
<             using \<open>\<Psi> x \<mu>\<close> [unfolded \<Psi>_def, rule_format, of "min 1 (d / DIM('a))"]
<             by auto
<           show ?thesis
<           proof (intro exI conjI)
<             show "0 < h" "\<mu> \<le> norm (i h x - f x)" by fact+
<             have "BOX h x \<subseteq> ball x d"
<             proof (clarsimp simp: BOX_def mem_box dist_norm algebra_simps)
<               fix y
<               assume "\<forall>i\<in>Basis. x \<bullet> i \<le> y \<bullet> i \<and> y \<bullet> i \<le> h + x \<bullet> i"
<               then have lt: "\<bar>(x - y) \<bullet> i\<bar> < d / real DIM('a)" if "i \<in> Basis" for i
<                 using hless that by (force simp: inner_diff_left)
<               have "norm (x - y) \<le> (\<Sum>i\<in>Basis. \<bar>(x - y) \<bullet> i\<bar>)"
<                 using norm_le_l1 by blast
<               also have "\<dots> < d"
<                 using sum_bounded_above_strict [of Basis "\<lambda>i. \<bar>(x - y) \<bullet> i\<bar>" "d / DIM('a)", OF lt]
<                 by auto
<               finally show "norm (x - y) < d" .
<             qed
<             with d show "BOX h x \<subseteq> \<gamma> x"
<               by blast
<             show "BOX h x \<subseteq> cbox (a - One) (b + One)"
<               using that \<open>h < 1\<close>
<               by (force simp: BOX_def mem_box algebra_simps intro: subset_box_imp)
<           qed
<         qed
<         then obtain \<eta> where h0: "\<And>x. x \<in> ?E \<Longrightarrow> \<eta> x > 0"
<           and BOX_\<gamma>: "\<And>x. x \<in> ?E \<Longrightarrow> BOX (\<eta> x) x \<subseteq> \<gamma> x"
<           and "\<And>x. x \<in> ?E \<Longrightarrow> BOX (\<eta> x) x \<subseteq> cbox (a - One) (b + One) \<and> \<mu> \<le> norm (i (\<eta> x) x - f x)"
<           by simp metis
<         then have BOX_cbox: "\<And>x. x \<in> ?E \<Longrightarrow> BOX (\<eta> x) x \<subseteq> cbox (a - One) (b + One)"
<              and \<mu>_le: "\<And>x. x \<in> ?E \<Longrightarrow> \<mu> \<le> norm (i (\<eta> x) x - f x)"
<           by blast+
<         define \<gamma>' where "\<gamma>' \<equiv> \<lambda>x. if x \<in> cbox a b \<and> \<Psi> x \<mu> then ball x (\<eta> x) else \<gamma> x"
<         have "gauge \<gamma>'"
<           using \<open>gauge \<gamma>\<close> by (auto simp: h0 gauge_def \<gamma>'_def)
<         obtain \<D> where "countable \<D>"
<           and \<D>: "\<Union>\<D> \<subseteq> cbox a b"
<           "\<And>K. K \<in> \<D> \<Longrightarrow> interior K \<noteq> {} \<and> (\<exists>c d. K = cbox c d)"
<           and Dcovered: "\<And>K. K \<in> \<D> \<Longrightarrow> \<exists>x. x \<in> cbox a b \<and> \<Psi> x \<mu> \<and> x \<in> K \<and> K \<subseteq> \<gamma>' x"
<           and subUD: "?E \<subseteq> \<Union>\<D>"
<           by (rule covering_lemma [of ?E a b \<gamma>']) (simp_all add: Bex_def \<open>box a b \<noteq> {}\<close> \<open>gauge \<gamma>'\<close>)
<         then have "\<D> \<subseteq> sets lebesgue"
<           by fastforce
<         show "\<exists>T. {x. \<Psi> x \<mu>} \<inter> cbox a b \<subseteq> T \<and> T \<in> lmeasurable \<and> measure lebesgue T \<le> e"
<         proof (intro exI conjI)
<           show "{x. \<Psi> x \<mu>} \<inter> cbox a b \<subseteq> \<Union>\<D>"
<             apply auto
<             using subUD by auto
<           have mUE: "measure lebesgue (\<Union> \<E>) \<le> measure lebesgue (cbox a b)"
<             if "\<E> \<subseteq> \<D>" "finite \<E>" for \<E>
<           proof (rule measure_mono_fmeasurable)
<             show "\<Union> \<E> \<subseteq> cbox a b"
<               using \<D>(1) that(1) by blast
<             show "\<Union> \<E> \<in> sets lebesgue"
<               by (metis \<D>(2) fmeasurable.finite_Union fmeasurableD lmeasurable_cbox subset_eq that)
<           qed auto
<           then show "\<Union>\<D> \<in> lmeasurable"
<             by (metis \<D>(2) \<open>countable \<D>\<close> fmeasurable_Union_bound lmeasurable_cbox)
<           then have leab: "measure lebesgue (\<Union>\<D>) \<le> measure lebesgue (cbox a b)"
<             by (meson \<D>(1) fmeasurableD lmeasurable_cbox measure_mono_fmeasurable)
<           obtain \<F> where "\<F> \<subseteq> \<D>" "finite \<F>"
<             and \<F>: "measure lebesgue (\<Union>\<D>) \<le> 2 * measure lebesgue (\<Union>\<F>)"
<           proof (cases "measure lebesgue (\<Union>\<D>) = 0")
<             case True
<             then show ?thesis
<               by (force intro: that [where \<F> = "{}"])
<           next
<             case False
<             obtain \<F> where "\<F> \<subseteq> \<D>" "finite \<F>"
<               and \<F>: "measure lebesgue (\<Union>\<D>)/2 < measure lebesgue (\<Union>\<F>)"
<             proof (rule measure_countable_Union_approachable [of \<D> "measure lebesgue (\<Union>\<D>) / 2" "content (cbox a b)"])
<               show "countable \<D>"
<                 by fact
<               show "0 < measure lebesgue (\<Union> \<D>) / 2"
<                 using False by (simp add: zero_less_measure_iff)
<               show Dlm: "D \<in> lmeasurable" if "D \<in> \<D>" for D
<                 using \<D>(2) that by blast
<               show "measure lebesgue (\<Union> \<F>) \<le> content (cbox a b)"
<                 if "\<F> \<subseteq> \<D>" "finite \<F>" for \<F>
<               proof -
<                 have "measure lebesgue (\<Union> \<F>) \<le> measure lebesgue (\<Union>\<D>)"
<                 proof (rule measure_mono_fmeasurable)
<                   show "\<Union> \<F> \<subseteq> \<Union> \<D>"
<                     by (simp add: Sup_subset_mono \<open>\<F> \<subseteq> \<D>\<close>)
<                   show "\<Union> \<F> \<in> sets lebesgue"
<                     by (meson Dlm fmeasurableD sets.finite_Union subset_eq that)
<                   show "\<Union> \<D> \<in> lmeasurable"
<                     by fact
<                 qed
<                 also have "\<dots> \<le> measure lebesgue (cbox a b)"
<                 proof (rule measure_mono_fmeasurable)
<                   show "\<Union> \<D> \<in> sets lebesgue"
<                     by (simp add: \<open>\<Union> \<D> \<in> lmeasurable\<close> fmeasurableD)
<                 qed (auto simp:\<D>(1))
<                 finally show ?thesis
<                   by simp
<               qed
<             qed auto
<             then show ?thesis
<               using that by auto
<           qed
<           obtain tag where tag_in_E: "\<And>D. D \<in> \<D> \<Longrightarrow> tag D \<in> ?E"
<             and tag_in_self: "\<And>D. D \<in> \<D> \<Longrightarrow> tag D \<in> D"
<             and tag_sub: "\<And>D. D \<in> \<D> \<Longrightarrow> D \<subseteq> \<gamma>' (tag D)"
<             using Dcovered by simp metis
<           then have sub_ball_tag: "\<And>D. D \<in> \<D> \<Longrightarrow> D \<subseteq> ball (tag D) (\<eta> (tag D))"
<             by (simp add: \<gamma>'_def)
<           define \<Phi> where "\<Phi> \<equiv> \<lambda>D. BOX (\<eta>(tag D)) (tag D)"
<           define \<Phi>2 where "\<Phi>2 \<equiv> \<lambda>D. BOX2 (\<eta>(tag D)) (tag D)"
<           obtain \<C> where "\<C> \<subseteq> \<Phi>2 ` \<F>" "pairwise disjnt \<C>"
<             "measure lebesgue (\<Union>\<C>) \<ge> measure lebesgue (\<Union>(\<Phi>2`\<F>)) / 3 ^ (DIM('a))"
<           proof (rule Austin_Lemma)
<             show "finite (\<Phi>2`\<F>)"
<               using \<open>finite \<F>\<close> by blast
<             have "\<exists>k a b. \<Phi>2 D = cbox a b \<and> (\<forall>i\<in>Basis. b \<bullet> i - a \<bullet> i = k)" if "D \<in> \<F>" for D
<               apply (rule_tac x="2 * \<eta>(tag D)" in exI)
<               apply (rule_tac x="tag D - \<eta>(tag D) *\<^sub>R One" in exI)
<               apply (rule_tac x="tag D + \<eta>(tag D) *\<^sub>R One" in exI)
<               using that
<               apply (auto simp: \<Phi>2_def BOX2_def algebra_simps)
<               done
<             then show "\<And>D. D \<in> \<Phi>2 ` \<F> \<Longrightarrow> \<exists>k a b. D = cbox a b \<and> (\<forall>i\<in>Basis. b \<bullet> i - a \<bullet> i = k)"
<               by blast
<           qed auto
<           then obtain \<G> where "\<G> \<subseteq> \<F>" and disj: "pairwise disjnt (\<Phi>2 ` \<G>)"
<             and "measure lebesgue (\<Union>(\<Phi>2 ` \<G>)) \<ge> measure lebesgue (\<Union>(\<Phi>2`\<F>)) / 3 ^ (DIM('a))"
<             unfolding \<Phi>2_def subset_image_iff
<             by (meson empty_subsetI equals0D pairwise_imageI)
<           moreover
<           have "measure lebesgue (\<Union>(\<Phi>2 ` \<G>)) * 3 ^ DIM('a) \<le> e/2"
<           proof -
<             have "finite \<G>"
<               using \<open>finite \<F>\<close> \<open>\<G> \<subseteq> \<F>\<close> infinite_super by blast
<             have BOX2_m: "\<And>x. x \<in> tag ` \<G> \<Longrightarrow> BOX2 (\<eta> x) x \<in> lmeasurable"
<               by (auto simp: BOX2_def)
<             have BOX_m: "\<And>x. x \<in> tag ` \<G> \<Longrightarrow> BOX (\<eta> x) x \<in> lmeasurable"
<               by (auto simp: BOX_def)
<             have BOX_sub: "BOX (\<eta> x) x \<subseteq> BOX2 (\<eta> x) x" for x
<               by (auto simp: BOX_def BOX2_def subset_box algebra_simps)
<             have DISJ2: "BOX2 (\<eta> (tag X)) (tag X) \<inter> BOX2 (\<eta> (tag Y)) (tag Y) = {}"
<               if "X \<in> \<G>" "Y \<in> \<G>" "tag X \<noteq> tag Y" for X Y
<             proof -
<               obtain i where i: "i \<in> Basis" "tag X \<bullet> i \<noteq> tag Y \<bullet> i"
<                 using \<open>tag X \<noteq> tag Y\<close> by (auto simp: euclidean_eq_iff [of "tag X"])
<               have XY: "X \<in> \<D>" "Y \<in> \<D>"
<                 using \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> that by auto
<               then have "0 \<le> \<eta> (tag X)" "0 \<le> \<eta> (tag Y)"
<                 by (meson h0 le_cases not_le tag_in_E)+
<               with XY i have "BOX2 (\<eta> (tag X)) (tag X) \<noteq> BOX2 (\<eta> (tag Y)) (tag Y)"
<                 unfolding eq_iff
<                 by (fastforce simp add: BOX2_def subset_box algebra_simps)
<               then show ?thesis
<                 using disj that by (auto simp: pairwise_def disjnt_def \<Phi>2_def)
<             qed
<             then have BOX2_disj: "pairwise (\<lambda>x y. negligible (BOX2 (\<eta> x) x \<inter> BOX2 (\<eta> y) y)) (tag ` \<G>)"
<               by (simp add: pairwise_imageI)
<             then have BOX_disj: "pairwise (\<lambda>x y. negligible (BOX (\<eta> x) x \<inter> BOX (\<eta> y) y)) (tag ` \<G>)"
<             proof (rule pairwise_mono)
<               show "negligible (BOX (\<eta> x) x \<inter> BOX (\<eta> y) y)"
<                 if "negligible (BOX2 (\<eta> x) x \<inter> BOX2 (\<eta> y) y)" for x y
<                 by (metis (no_types, hide_lams) that Int_mono negligible_subset BOX_sub)
<             qed auto
< 
<             have eq: "\<And>box. (\<lambda>D. box (\<eta> (tag D)) (tag D)) ` \<G> = (\<lambda>t. box (\<eta> t) t) ` tag ` \<G>"
<               by (simp add: image_comp)
<             have "measure lebesgue (BOX2 (\<eta> t) t) * 3 ^ DIM('a)
<                 = measure lebesgue (BOX (\<eta> t) t) * (2*3) ^ DIM('a)"
<               if "t \<in> tag ` \<G>" for t
<             proof -
<               have "content (cbox (t - \<eta> t *\<^sub>R One) (t + \<eta> t *\<^sub>R One))
<                   = content (cbox t (t + \<eta> t *\<^sub>R One)) * 2 ^ DIM('a)"
<                 using that by (simp add: algebra_simps content_cbox_if box_eq_empty)
<               then show ?thesis
<                 by (simp add: BOX2_def BOX_def flip: power_mult_distrib)
<             qed
<             then have "measure lebesgue (\<Union>(\<Phi>2 ` \<G>)) * 3 ^ DIM('a) = measure lebesgue (\<Union>(\<Phi> ` \<G>)) * 6 ^ DIM('a)"
<               unfolding \<Phi>_def \<Phi>2_def eq
<               by (simp add: measure_negligible_finite_Union_image
<                   \<open>finite \<G>\<close> BOX2_m BOX_m BOX2_disj BOX_disj sum_distrib_right
<                   del: UN_simps)
<             also have "\<dots> \<le> e/2"
<             proof -
<               have "\<mu> * measure lebesgue (\<Union>D\<in>\<G>. \<Phi> D) \<le> \<mu> * (\<Sum>D \<in> \<Phi>`\<G>. measure lebesgue D)"
<                 using \<open>\<mu> > 0\<close> \<open>finite \<G>\<close> by (force simp: BOX_m \<Phi>_def fmeasurableD intro: measure_Union_le)
<               also have "\<dots> = (\<Sum>D \<in> \<Phi>`\<G>. measure lebesgue D * \<mu>)"
<                 by (metis mult.commute sum_distrib_right)
<               also have "\<dots> \<le> (\<Sum>(x, K) \<in> (\<lambda>D. (tag D, \<Phi> D)) ` \<G>.  norm (content K *\<^sub>R f x - integral K f))"
<               proof (rule sum_le_included; clarify?)
<                 fix D
<                 assume "D \<in> \<G>"
<                 then have "\<eta> (tag D) > 0"
<                   using \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> h0 tag_in_E by auto
<                 then have m_\<Phi>: "measure lebesgue (\<Phi> D) > 0"
<                   by (simp add: \<Phi>_def BOX_def algebra_simps)
<                 have "\<mu> \<le> norm (i (\<eta>(tag D)) (tag D) - f(tag D))"
<                   using \<mu>_le \<open>D \<in> \<G>\<close> \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> tag_in_E by auto
<                 also have "\<dots> = norm ((content (\<Phi> D) *\<^sub>R f(tag D) - integral (\<Phi> D) f) /\<^sub>R measure lebesgue (\<Phi> D))"
<                   using m_\<Phi>
<                   unfolding i_def \<Phi>_def BOX_def
<                   by (simp add: algebra_simps content_cbox_plus norm_minus_commute)
<                 finally have "measure lebesgue (\<Phi> D) * \<mu> \<le> norm (content (\<Phi> D) *\<^sub>R f(tag D) - integral (\<Phi> D) f)"
<                   using m_\<Phi> by (simp add: field_simps)
<                 then show "\<exists>y\<in>(\<lambda>D. (tag D, \<Phi> D)) ` \<G>.
<                         snd y = \<Phi> D \<and> measure lebesgue (\<Phi> D) * \<mu> \<le> (case y of (x, k) \<Rightarrow> norm (content k *\<^sub>R f x - integral k f))"
<                   using \<open>D \<in> \<G>\<close> by auto
<               qed (use \<open>finite \<G>\<close> in auto)
<               also have "\<dots> < ?ee"
<               proof (rule \<gamma>)
<                 show "(\<lambda>D. (tag D, \<Phi> D)) ` \<G> tagged_partial_division_of cbox (a - One) (b + One)"
<                   unfolding tagged_partial_division_of_def
<                 proof (intro conjI allI impI ; clarify ?)
<                   show "tag D \<in> \<Phi> D"
<                     if "D \<in> \<G>" for D
<                     using that \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> h0 tag_in_E
<                     by (auto simp: \<Phi>_def BOX_def mem_box algebra_simps eucl_less_le_not_le in_mono)
<                   show "y \<in> cbox (a - One) (b + One)" if "D \<in> \<G>" "y \<in> \<Phi> D" for D y
<                     using that BOX_cbox \<Phi>_def \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> tag_in_E by blast
<                   show "tag D = tag E \<and> \<Phi> D = \<Phi> E"
<                     if "D \<in> \<G>" "E \<in> \<G>" and ne: "interior (\<Phi> D) \<inter> interior (\<Phi> E) \<noteq> {}" for D E
<                   proof -
<                     have "BOX2 (\<eta> (tag D)) (tag D) \<inter> BOX2 (\<eta> (tag E)) (tag E) = {} \<or> tag E = tag D"
<                       using DISJ2 \<open>D \<in> \<G>\<close> \<open>E \<in> \<G>\<close> by force
<                     then have "BOX (\<eta> (tag D)) (tag D) \<inter> BOX (\<eta> (tag E)) (tag E) = {} \<or> tag E = tag D"
<                       using BOX_sub by blast
<                     then show "tag D = tag E \<and> \<Phi> D = \<Phi> E"
<                       by (metis \<Phi>_def interior_Int interior_empty ne)
<                   qed
<                 qed (use \<open>finite \<G>\<close> \<Phi>_def BOX_def in auto)
<                 show "\<gamma> fine (\<lambda>D. (tag D, \<Phi> D)) ` \<G>"
<                   unfolding fine_def \<Phi>_def using BOX_\<gamma> \<open>\<F> \<subseteq> \<D>\<close> \<open>\<G> \<subseteq> \<F>\<close> tag_in_E by blast
<               qed
<               finally show ?thesis
<                 using \<open>\<mu> > 0\<close> by (auto simp: divide_simps)
<           qed
<             finally show ?thesis .
<           qed
<           moreover
<           have "measure lebesgue (\<Union>\<F>) \<le> measure lebesgue (\<Union>(\<Phi>2`\<F>))"
<           proof (rule measure_mono_fmeasurable)
<             have "D \<subseteq> ball (tag D) (\<eta>(tag D))" if "D \<in> \<F>" for D
<               using \<open>\<F> \<subseteq> \<D>\<close> sub_ball_tag that by blast
<             moreover have "ball (tag D) (\<eta>(tag D)) \<subseteq> BOX2 (\<eta> (tag D)) (tag D)" if "D \<in> \<F>" for D
<             proof (clarsimp simp: \<Phi>2_def BOX2_def mem_box algebra_simps dist_norm)
<               fix x and i::'a
<               assume "norm (tag D - x) < \<eta> (tag D)" and "i \<in> Basis"
<               then have "\<bar>tag D \<bullet> i - x \<bullet> i\<bar> \<le> \<eta> (tag D)"
<                 by (metis eucl_less_le_not_le inner_commute inner_diff_right norm_bound_Basis_le)
<               then show "tag D \<bullet> i \<le> x \<bullet> i + \<eta> (tag D) \<and> x \<bullet> i \<le> \<eta> (tag D) + tag D \<bullet> i"
<                 by (simp add: abs_diff_le_iff)
<             qed
<             ultimately show "\<Union>\<F> \<subseteq> \<Union>(\<Phi>2`\<F>)"
<               by (force simp: \<Phi>2_def)
<             show "\<Union>\<F> \<in> sets lebesgue"
<               using \<open>finite \<F>\<close> \<open>\<D> \<subseteq> sets lebesgue\<close> \<open>\<F> \<subseteq> \<D>\<close> by blast
<             show "\<Union>(\<Phi>2`\<F>) \<in> lmeasurable"
<               unfolding \<Phi>2_def BOX2_def using \<open>finite \<F>\<close> by blast
<           qed
<           ultimately
<           have "measure lebesgue (\<Union>\<F>) \<le> e/2"
<             by (auto simp: divide_simps)
<           then show "measure lebesgue (\<Union>\<D>) \<le> e"
<             using \<F> by linarith
<         qed
<       qed
<     qed
<     then have "\<And>j. negligible {x. \<Psi> x (inverse(real j + 1))}"
<       using negligible_on_intervals
<       by (metis (full_types) inverse_positive_iff_positive le_add_same_cancel1 linorder_not_le nat_le_real_less not_add_less1 of_nat_0)
<     then have "negligible ?M"
<       by auto
<     moreover have "?N \<subseteq> ?M"
<     proof (clarsimp simp: dist_norm)
<       fix y e
<       assume "0 < e"
<         and ye [rule_format]: "\<Psi> y e"
<       then obtain k where k: "0 < k" "inverse (real k + 1) < e"
<         by (metis One_nat_def add.commute less_add_same_cancel2 less_imp_inverse_less less_trans neq0_conv of_nat_1 of_nat_Suc reals_Archimedean zero_less_one)
<       with ye show "\<exists>n. \<Psi> y (inverse (real n + 1))"
<         apply (rule_tac x=k in exI)
<         unfolding \<Psi>_def
<         by (force intro: less_le_trans)
<     qed
<     ultimately show "negligible ?N"
<       by (blast intro: negligible_subset)
<     show "\<not> \<Psi> x e" if "x \<notin> ?N \<and> 0 < e" for x e
<       using that by blast
<   qed
<   with that show ?thesis
<     unfolding i_def BOX_def \<Psi>_def by (fastforce simp add: not_le)
< qed
< 
< 
< 
< subsection\<open>HOL Light measurability\<close>
< 
< definition measurable_on :: "('a::euclidean_space \<Rightarrow> 'b::real_normed_vector) \<Rightarrow> 'a set \<Rightarrow> bool"
<   (infixr "measurable'_on" 46)
<   where "f measurable_on S \<equiv>
<         \<exists>N g. negligible N \<and>
<               (\<forall>n. continuous_on UNIV (g n)) \<and>
<               (\<forall>x. x \<notin> N \<longrightarrow> (\<lambda>n. g n x) \<longlonglongrightarrow> (if x \<in> S then f x else 0))"
< 
< lemma measurable_on_UNIV:
<   "(\<lambda>x.  if x \<in> S then f x else 0) measurable_on UNIV \<longleftrightarrow> f measurable_on S"
<   by (auto simp: measurable_on_def)
< 
< lemma measurable_on_spike_set:
<   assumes f: "f measurable_on S" and neg: "negligible ((S - T) \<union> (T - S))"
<   shows "f measurable_on T"
< proof -
<   obtain N and F
<     where N: "negligible N"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> N \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> S then f x else 0)"
<     using f by (auto simp: measurable_on_def)
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "continuous_on UNIV (\<lambda>x. F n x)" for n
<       by (intro conF continuous_intros)
<     show "negligible (N \<union> (S - T) \<union> (T - S))"
<       by (metis (full_types) N neg negligible_Un_eq)
<     show "(\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> T then f x else 0)"
<       if "x \<notin> (N \<union> (S - T) \<union> (T - S))" for x
<       using that tendsF [of x] by auto
<   qed
< qed
< 
< text\<open> Various common equivalent forms of function measurability.                \<close>
< 
< lemma measurable_on_0 [simp]: "(\<lambda>x. 0) measurable_on S"
<   unfolding measurable_on_def
< proof (intro exI conjI allI impI)
<   show "(\<lambda>n. 0) \<longlonglongrightarrow> (if x \<in> S then 0::'b else 0)" for x
<     by force
< qed auto
< 
< lemma measurable_on_scaleR_const:
<   assumes f: "f measurable_on S"
<   shows "(\<lambda>x. c *\<^sub>R f x) measurable_on S"
< proof -
<   obtain NF and F
<     where NF: "negligible NF"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> NF \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> S then f x else 0)"
<     using f by (auto simp: measurable_on_def)
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "continuous_on UNIV (\<lambda>x. c *\<^sub>R F n x)" for n
<       by (intro conF continuous_intros)
<     show "(\<lambda>n. c *\<^sub>R F n x) \<longlonglongrightarrow> (if x \<in> S then c *\<^sub>R f x else 0)"
<       if "x \<notin> NF" for x
<       using tendsto_scaleR [OF tendsto_const tendsF, of x] that by auto
<   qed (auto simp: NF)
< qed
< 
< 
< lemma measurable_on_cmul:
<   fixes c :: real
<   assumes "f measurable_on S"
<   shows "(\<lambda>x. c * f x) measurable_on S"
<   using measurable_on_scaleR_const [OF assms] by simp
< 
< lemma measurable_on_cdivide:
<   fixes c :: real
<   assumes "f measurable_on S"
<   shows "(\<lambda>x. f x / c) measurable_on S"
< proof (cases "c=0")
<   case False
<   then show ?thesis
<     using measurable_on_cmul [of f S "1/c"]
<     by (simp add: assms)
< qed auto
< 
< 
< lemma measurable_on_minus:
<    "f measurable_on S \<Longrightarrow> (\<lambda>x. -(f x)) measurable_on S"
<   using measurable_on_scaleR_const [of f S "-1"] by auto
< 
< 
< lemma continuous_imp_measurable_on:
<    "continuous_on UNIV f \<Longrightarrow> f measurable_on UNIV"
<   unfolding measurable_on_def
<   apply (rule_tac x="{}" in exI)
<   apply (rule_tac x="\<lambda>n. f" in exI, auto)
<   done
< 
< proposition integrable_subintervals_imp_measurable:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "\<And>a b. f integrable_on cbox a b"
<   shows "f measurable_on UNIV"
< proof -
<   define BOX where "BOX \<equiv> \<lambda>h. \<lambda>x::'a. cbox x (x + h *\<^sub>R One)"
<   define i where "i \<equiv> \<lambda>h x. integral (BOX h x) f /\<^sub>R h ^ DIM('a)"
<   obtain N where "negligible N"
<     and k: "\<And>x e. \<lbrakk>x \<notin> N; 0 < e\<rbrakk>
<             \<Longrightarrow> \<exists>d>0. \<forall>h. 0 < h \<and> h < d \<longrightarrow>
<                   norm (integral (cbox x (x + h *\<^sub>R One)) f /\<^sub>R h ^ DIM('a) - f x) < e"
<     using integrable_ccontinuous_explicit assms by blast
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "continuous_on UNIV ((\<lambda>n x. i (inverse(Suc n)) x) n)" for n
<     proof (clarsimp simp: continuous_on_iff)
<       show "\<exists>d>0. \<forall>x'. dist x' x < d \<longrightarrow> dist (i (inverse (1 + real n)) x') (i (inverse (1 + real n)) x) < e"
<         if "0 < e"
<         for x e
<       proof -
<         let ?e = "e / (1 + real n) ^ DIM('a)"
<         have "?e > 0"
<           using \<open>e > 0\<close> by auto
<         moreover have "x \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One)"
<           by (simp add: mem_box inner_diff_left inner_left_distrib)
<         moreover have "x + One /\<^sub>R real (Suc n) \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One)"
<           by (auto simp: mem_box inner_diff_left inner_left_distrib field_simps)
<         ultimately obtain \<delta> where "\<delta> > 0"
<           and \<delta>: "\<And>c' d'. \<lbrakk>c' \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One);
<                            d' \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One);
<                            norm(c' - x) \<le> \<delta>; norm(d' - (x + One /\<^sub>R Suc n)) \<le> \<delta>\<rbrakk>
<                           \<Longrightarrow> norm(integral(cbox c' d') f - integral(cbox x (x + One /\<^sub>R Suc n)) f) < ?e"
<           by (blast intro: indefinite_integral_continuous [of f _ _ x] assms)
<         show ?thesis
<         proof (intro exI impI conjI allI)
<           show "min \<delta> 1 > 0"
<             using \<open>\<delta> > 0\<close> by auto
<           show "dist (i (inverse (1 + real n)) y) (i (inverse (1 + real n)) x) < e"
<             if "dist y x < min \<delta> 1" for y
<           proof -
<             have no: "norm (y - x) < 1"
<               using that by (auto simp: dist_norm)
<             have le1: "inverse (1 + real n) \<le> 1"
<               by (auto simp: divide_simps)
<             have "norm (integral (cbox y (y + One /\<^sub>R real (Suc n))) f
<                 - integral (cbox x (x + One /\<^sub>R real (Suc n))) f)
<                 < e / (1 + real n) ^ DIM('a)"
<             proof (rule \<delta>)
<               show "y \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One)"
<                 using no by (auto simp: mem_box algebra_simps dest: Basis_le_norm [of _ "y-x"])
<               show "y + One /\<^sub>R real (Suc n) \<in> cbox (x - 2 *\<^sub>R One) (x + 2 *\<^sub>R One)"
<               proof (simp add: dist_norm mem_box algebra_simps, intro ballI conjI)
<                 fix i::'a
<                 assume "i \<in> Basis"
<                 then have 1: "\<bar>y \<bullet> i - x \<bullet> i\<bar> < 1"
<                   by (metis inner_commute inner_diff_right no norm_bound_Basis_lt)
<                 moreover have "\<dots> < (2 + inverse (1 + real n))" "1 \<le> 2 - inverse (1 + real n)"
<                   by (auto simp: field_simps)
<                 ultimately show "x \<bullet> i \<le> y \<bullet> i + (2 + inverse (1 + real n))"
<                                 "y \<bullet> i + inverse (1 + real n) \<le> x \<bullet> i + 2"
<                   by linarith+
<               qed
<               show "norm (y - x) \<le> \<delta>" "norm (y + One /\<^sub>R real (Suc n) - (x + One /\<^sub>R real (Suc n))) \<le> \<delta>"
<                 using that by (auto simp: dist_norm)
<             qed
<             then show ?thesis
<               using that by (simp add: dist_norm i_def BOX_def field_simps flip: scaleR_diff_right)
<           qed
<         qed
<       qed
<     qed
<     show "negligible N"
<       by (simp add: \<open>negligible N\<close>)
<     show "(\<lambda>n. i (inverse (Suc n)) x) \<longlonglongrightarrow> (if x \<in> UNIV then f x else 0)"
<       if "x \<notin> N" for x
<       unfolding lim_sequentially
<     proof clarsimp
<       show "\<exists>no. \<forall>n\<ge>no. dist (i (inverse (1 + real n)) x) (f x) < e"
<         if "0 < e" for e
<       proof -
<         obtain d where "d > 0"
<           and d: "\<And>h. \<lbrakk>0 < h; h < d\<rbrakk> \<Longrightarrow>
<               norm (integral (cbox x (x + h *\<^sub>R One)) f /\<^sub>R h ^ DIM('a) - f x) < e"
<           using k [of x e] \<open>x \<notin> N\<close> \<open>0 < e\<close> by blast
<         then obtain M where M: "M \<noteq> 0" "0 < inverse (real M)" "inverse (real M) < d"
<           using real_arch_invD by auto
<         show ?thesis
<         proof (intro exI allI impI)
<           show "dist (i (inverse (1 + real n)) x) (f x) < e"
<             if "M \<le> n" for n
<           proof -
<             have *: "0 < inverse (1 + real n)" "inverse (1 + real n) \<le> inverse M"
<               using that \<open>M \<noteq> 0\<close> by auto
<             show ?thesis
<               using that M
<               apply (simp add: i_def BOX_def dist_norm)
<               apply (blast intro: le_less_trans * d)
<               done
<           qed
<         qed
<       qed
<     qed
<   qed
< qed
< 
< subsection\<open>Composing continuous and measurable functions; a few variants\<close>
< 
< lemma measurable_on_compose_continuous:
<    assumes f: "f measurable_on UNIV" and g: "continuous_on UNIV g"
<    shows "(g \<circ> f) measurable_on UNIV"
< proof -
<   obtain N and F
<     where "negligible N"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> N \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> f x"
<     using f by (auto simp: measurable_on_def)
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "negligible N"
<       by fact
<     show "continuous_on UNIV (g \<circ> (F n))" for n
<       using conF continuous_on_compose continuous_on_subset g by blast
<     show "(\<lambda>n. (g \<circ> F n) x) \<longlonglongrightarrow> (if x \<in> UNIV then (g \<circ> f) x else 0)"
<       if "x \<notin> N" for x :: 'a
<       using that g tendsF by (auto simp: continuous_on_def intro: tendsto_compose)
<   qed
< qed
< 
< lemma measurable_on_compose_continuous_0:
<    assumes f: "f measurable_on S" and g: "continuous_on UNIV g" and "g 0 = 0"
<    shows "(g \<circ> f) measurable_on S"
< proof -
<   have f': "(\<lambda>x. if x \<in> S then f x else 0) measurable_on UNIV"
<     using f measurable_on_UNIV by blast
<   show ?thesis
<     using measurable_on_compose_continuous [OF f' g]
<     by (simp add: measurable_on_UNIV o_def if_distrib \<open>g 0 = 0\<close> cong: if_cong)
< qed
< 
< 
< lemma measurable_on_compose_continuous_box:
<   assumes fm: "f measurable_on UNIV" and fab: "\<And>x. f x \<in> box a b"
<     and contg: "continuous_on (box a b) g"
<   shows "(g \<circ> f) measurable_on UNIV"
< proof -
<   have "\<exists>\<gamma>. (\<forall>n. continuous_on UNIV (\<gamma> n)) \<and> (\<forall>x. x \<notin> N \<longrightarrow> (\<lambda>n. \<gamma> n x) \<longlonglongrightarrow> g (f x))"
<     if "negligible N"
<       and conth [rule_format]: "\<forall>n. continuous_on UNIV (\<lambda>x. h n x)"
<       and tends [rule_format]: "\<forall>x. x \<notin> N \<longrightarrow> (\<lambda>n. h n x) \<longlonglongrightarrow> f x"
<     for N and h :: "nat \<Rightarrow> 'a \<Rightarrow> 'b"
<   proof -
<     define \<theta> where "\<theta> \<equiv> \<lambda>n x. (\<Sum>i\<in>Basis. (max (a\<bullet>i + (b\<bullet>i - a\<bullet>i) / real (n+2))
<                                             (min ((h n x)\<bullet>i)
<                                                  (b\<bullet>i - (b\<bullet>i - a\<bullet>i) / real (n+2)))) *\<^sub>R i)"
<     have aibi: "\<And>i. i \<in> Basis \<Longrightarrow> a \<bullet> i < b \<bullet> i"
<       using box_ne_empty(2) fab by auto
<     then have *: "\<And>i n. i \<in> Basis \<Longrightarrow> a \<bullet> i + real n * (a \<bullet> i) < b \<bullet> i + real n * (b \<bullet> i)"
<       by (meson add_mono_thms_linordered_field(3) less_eq_real_def mult_left_mono of_nat_0_le_iff)
<     show ?thesis
<     proof (intro exI conjI allI impI)
<       show "continuous_on UNIV (g \<circ> (\<theta> n))" for n :: nat
<         unfolding \<theta>_def
<         apply (intro continuous_on_compose2 [OF contg] continuous_intros conth)
<          apply (auto simp: aibi * mem_box less_max_iff_disj min_less_iff_disj algebra_simps divide_simps)
<         done
<       show "(\<lambda>n. (g \<circ> \<theta> n) x) \<longlonglongrightarrow> g (f x)"
<         if "x \<notin> N" for x
<         unfolding o_def
<       proof (rule isCont_tendsto_compose [where g=g])
<         show "isCont g (f x)"
<           using contg fab continuous_on_eq_continuous_at by blast
<         have "(\<lambda>n. \<theta> n x) \<longlonglongrightarrow> (\<Sum>i\<in>Basis. max (a \<bullet> i) (min (f x \<bullet> i) (b \<bullet> i)) *\<^sub>R i)"
<           unfolding \<theta>_def
<         proof (intro tendsto_intros \<open>x \<notin> N\<close> tends)
<           fix i::'b
<           assume "i \<in> Basis"
<           have a: "(\<lambda>n. a \<bullet> i + (b \<bullet> i - a \<bullet> i) / real n) \<longlonglongrightarrow> a\<bullet>i + 0"
<             by (intro tendsto_add lim_const_over_n tendsto_const)
<           show "(\<lambda>n. a \<bullet> i + (b \<bullet> i - a \<bullet> i) / real (n + 2)) \<longlonglongrightarrow> a \<bullet> i"
<             using LIMSEQ_ignore_initial_segment [where k=2, OF a] by simp
<           have b: "(\<lambda>n. b\<bullet>i - (b \<bullet> i - a \<bullet> i) / (real n)) \<longlonglongrightarrow> b\<bullet>i - 0"
<             by (intro tendsto_diff lim_const_over_n tendsto_const)
<           show "(\<lambda>n. b \<bullet> i - (b \<bullet> i - a \<bullet> i) / real (n + 2)) \<longlonglongrightarrow> b \<bullet> i"
<             using LIMSEQ_ignore_initial_segment [where k=2, OF b] by simp
<         qed
<         also have "(\<Sum>i\<in>Basis. max (a \<bullet> i) (min (f x \<bullet> i) (b \<bullet> i)) *\<^sub>R i) = (\<Sum>i\<in>Basis. (f x \<bullet> i) *\<^sub>R i)"
<           apply (rule sum.cong)
<           using fab
<            apply auto
<           apply (intro order_antisym)
<            apply (auto simp: mem_box)
<           using less_imp_le apply blast
<           by (metis (full_types) linear max_less_iff_conj min.bounded_iff not_le)
<         also have "\<dots> = f x"
<           using euclidean_representation by blast
<         finally show "(\<lambda>n. \<theta> n x) \<longlonglongrightarrow> f x" .
<       qed
<     qed
<   qed
<   then show ?thesis
<     using fm by (auto simp: measurable_on_def)
< qed
< 
< lemma measurable_on_Pair:
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<   shows "(\<lambda>x. (f x, g x)) measurable_on S"
< proof -
<   obtain NF and F
<     where NF: "negligible NF"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> NF \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> S then f x else 0)"
<     using f by (auto simp: measurable_on_def)
<   obtain NG and G
<     where NG: "negligible NG"
<       and conG: "\<And>n. continuous_on UNIV (G n)"
<       and tendsG: "\<And>x. x \<notin> NG \<Longrightarrow> (\<lambda>n. G n x) \<longlonglongrightarrow> (if x \<in> S then g x else 0)"
<     using g by (auto simp: measurable_on_def)
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "negligible (NF \<union> NG)"
<       by (simp add: NF NG)
<     show "continuous_on UNIV (\<lambda>x. (F n x, G n x))" for n
<       using conF conG continuous_on_Pair by blast
<     show "(\<lambda>n. (F n x, G n x)) \<longlonglongrightarrow> (if x \<in> S then (f x, g x) else 0)"
<       if "x \<notin> NF \<union> NG" for x
<       using tendsto_Pair [OF tendsF tendsG, of x x] that unfolding zero_prod_def
<       by (simp add: split: if_split_asm)
<   qed
< qed
< 
< lemma measurable_on_combine:
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<     and h: "continuous_on UNIV (\<lambda>x. h (fst x) (snd x))" and "h 0 0 = 0"
<   shows "(\<lambda>x. h (f x) (g x)) measurable_on S"
< proof -
<   have *: "(\<lambda>x. h (f x) (g x)) = (\<lambda>x. h (fst x) (snd x)) \<circ> (\<lambda>x. (f x, g x))"
<     by auto
<   show ?thesis
<     unfolding * by (auto simp: measurable_on_compose_continuous_0 measurable_on_Pair assms)
< qed
< 
< lemma measurable_on_add:
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<   shows "(\<lambda>x. f x + g x) measurable_on S"
<   by (intro continuous_intros measurable_on_combine [OF assms]) auto
< 
< lemma measurable_on_diff:
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<   shows "(\<lambda>x. f x - g x) measurable_on S"
<   by (intro continuous_intros measurable_on_combine [OF assms]) auto
< 
< lemma measurable_on_scaleR:
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<   shows "(\<lambda>x. f x *\<^sub>R g x) measurable_on S"
<   by (intro continuous_intros measurable_on_combine [OF assms]) auto
< 
< lemma measurable_on_sum:
<   assumes "finite I" "\<And>i. i \<in> I \<Longrightarrow> f i measurable_on S"
<   shows "(\<lambda>x. sum  (\<lambda>i. f i x) I) measurable_on S"
<   using assms by (induction I) (auto simp: measurable_on_add)
< 
< lemma measurable_on_spike:
<   assumes f: "f measurable_on T" and "negligible S" and gf: "\<And>x. x \<in> T - S \<Longrightarrow> g x = f x"
<   shows "g measurable_on T"
< proof -
<   obtain NF and F
<     where NF: "negligible NF"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> NF \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> T then f x else 0)"
<     using f by (auto simp: measurable_on_def)
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "negligible (NF \<union> S)"
<       by (simp add: NF \<open>negligible S\<close>)
<     show "\<And>x. x \<notin> NF \<union> S \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> T then g x else 0)"
<       by (metis (full_types) Diff_iff Un_iff gf tendsF)
<   qed (auto simp: conF)
< qed
< 
< 
< lemma measurable_on_preimage_lemma0:
<   fixes f :: "'a::euclidean_space \<Rightarrow> real"
<   assumes "m \<in> \<int>" and f: "m / 2^n \<le> (f x)" "(f x) < (m+1) / 2^n" and m: "\<bar>m\<bar> \<le> 2^(2 * n)"
<   shows "(\<Sum>k\<in>{k \<in> \<int>. \<bar>k\<bar> \<le> 2^(2 * n)}.
<              (k / 2^n) * indicator {y. k / 2^n \<le> f y \<and> f y < (k+1) / 2^n} x)
<        = (m / 2^n)"  (is "?lhs = ?rhs")
< proof -
<   have "?lhs = (\<Sum>k\<in>{m}. (k / 2^n) * indicator {y. k / 2^n \<le> f y \<and> f y < (k+1) / 2^n} x)"
<   proof (intro sum.mono_neutral_right ballI)
<     show "finite {k::real. k \<in> \<int> \<and> \<bar>k\<bar> \<le> 2^(2 * n)}"
<       using finite_abs_int_segment by blast
<     show "(i / 2^n) * indicat_real {y. i / 2^n \<le> f y \<and> f y < (i+1) / 2^n} x = 0"
<       if "i \<in> {N \<in> \<int>. \<bar>N\<bar> \<le> 2^(2 * n)} - {m}" for i
<       using f m \<open>m \<in> \<int>\<close> that Ints_eq_abs_less1 [of i m]
<       by (auto simp: indicator_def divide_simps)
<   qed (auto simp: assms)
<   also have "\<dots> = ?rhs"
<     using assms by (auto simp: indicator_def)
<   finally show ?thesis .
< qed
< 
< (*see HOL Light's lebesgue_measurable BUT OUR lmeasurable IS NOT THE SAME. It's more like "sets lebesgue"
<  `lebesgue_measurable s <=> (indicator s) measurable_on (:real^N)`;;
< *)
< 
< proposition indicator_measurable_on:
<   assumes "S \<in> sets lebesgue"
<   shows "indicat_real S measurable_on UNIV"
< proof -
<   { fix n::nat
<     let ?\<epsilon> = "(1::real) / (2 * 2^n)"
<     have \<epsilon>: "?\<epsilon> > 0"
<       by auto
<     obtain T where "closed T" "T \<subseteq> S" "S-T \<in> lmeasurable" and ST: "emeasure lebesgue (S - T) < ?\<epsilon>"
<       by (meson \<epsilon> assms sets_lebesgue_inner_closed)
<     obtain U where "open U" "S \<subseteq> U" "(U - S) \<in> lmeasurable" and US: "emeasure lebesgue (U - S) < ?\<epsilon>"
<       by (meson \<epsilon> assms sets_lebesgue_outer_open)
<     have eq: "-T \<inter> U = (S-T) \<union> (U - S)"
<       using \<open>T \<subseteq> S\<close> \<open>S \<subseteq> U\<close> by auto
<     have "emeasure lebesgue ((S-T) \<union> (U - S)) \<le> emeasure lebesgue (S - T) + emeasure lebesgue (U - S)"
<       using \<open>S - T \<in> lmeasurable\<close> \<open>U - S \<in> lmeasurable\<close> emeasure_subadditive by blast
<     also have "\<dots> < ?\<epsilon> + ?\<epsilon>"
<       using ST US add_mono_ennreal by metis
<     finally have le: "emeasure lebesgue (-T \<inter> U) < ennreal (1 / 2^n)"
<       by (simp add: eq)
<     have 1: "continuous_on (T \<union> -U) (indicat_real S)"
<       unfolding indicator_def
<     proof (rule continuous_on_cases [OF \<open>closed T\<close>])
<       show "closed (- U)"
<         using \<open>open U\<close> by blast
<       show "continuous_on T (\<lambda>x. 1::real)" "continuous_on (- U) (\<lambda>x. 0::real)"
<         by (auto simp: continuous_on)
<       show "\<forall>x. x \<in> T \<and> x \<notin> S \<or> x \<in> - U \<and> x \<in> S \<longrightarrow> (1::real) = 0"
<         using \<open>T \<subseteq> S\<close> \<open>S \<subseteq> U\<close> by auto
<     qed
<     have 2: "closedin (top_of_set UNIV) (T \<union> -U)"
<       using \<open>closed T\<close> \<open>open U\<close> by auto
<     obtain g where "continuous_on UNIV g" "\<And>x. x \<in> T \<union> -U \<Longrightarrow> g x = indicat_real S x" "\<And>x. norm(g x) \<le> 1"
<       by (rule Tietze [OF 1 2, of 1]) auto
<     with le have "\<exists>g E. continuous_on UNIV g \<and> (\<forall>x \<in> -E. g x = indicat_real S x) \<and>
<                         (\<forall>x. norm(g x) \<le> 1) \<and> E \<in> sets lebesgue \<and> emeasure lebesgue E < ennreal (1 / 2^n)"
<       apply (rule_tac x=g in exI)
<       apply (rule_tac x="-T \<inter> U" in exI)
<       using \<open>S - T \<in> lmeasurable\<close> \<open>U - S \<in> lmeasurable\<close> eq by auto
<   }
<   then obtain g E where cont: "\<And>n. continuous_on UNIV (g n)"
<     and geq: "\<And>n x. x \<in> - E n \<Longrightarrow> g n x = indicat_real S x"
<     and ng1: "\<And>n x. norm(g n x) \<le> 1"
<     and Eset: "\<And>n. E n \<in> sets lebesgue"
<     and Em: "\<And>n. emeasure lebesgue (E n) < ennreal (1 / 2^n)"
<     by metis
<   have null: "limsup E \<in> null_sets lebesgue"
<   proof (rule borel_cantelli_limsup1 [OF Eset])
<     show "emeasure lebesgue (E n) < \<infinity>" for n
<       by (metis Em infinity_ennreal_def order.asym top.not_eq_extremum)
<     show "summable (\<lambda>n. measure lebesgue (E n))"
<     proof (rule summable_comparison_test' [OF summable_geometric, of "1/2" 0])
<       show "norm (measure lebesgue (E n)) \<le> (1/2) ^ n"  for n
<         using Em [of n] by (simp add: measure_def enn2real_leI power_one_over)
<     qed auto
<   qed
<   have tends: "(\<lambda>n. g n x) \<longlonglongrightarrow> indicat_real S x" if "x \<notin> limsup E" for x
<   proof -
<     have "\<forall>\<^sub>F n in sequentially. x \<in> - E n"
<       using that by (simp add: mem_limsup_iff not_frequently)
<     then show ?thesis
<       unfolding tendsto_iff dist_real_def
<       by (simp add: eventually_mono geq)
<   qed
<   show ?thesis
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "negligible (limsup E)"
<       using negligible_iff_null_sets null by blast
<     show "continuous_on UNIV (g n)" for n
<       using cont by blast
<   qed (use tends in auto)
< qed
< 
< lemma measurable_on_restrict:
<   assumes f: "f measurable_on UNIV" and S: "S \<in> sets lebesgue"
<   shows "(\<lambda>x. if x \<in> S then f x else 0) measurable_on UNIV"
< proof -
<   have "indicat_real S measurable_on UNIV"
<     by (simp add: S indicator_measurable_on)
<   then show ?thesis
<     using measurable_on_scaleR [OF _ f, of "indicat_real S"]
<     by (simp add: indicator_scaleR_eq_if)
< qed
< 
< lemma measurable_on_const_UNIV: "(\<lambda>x. k) measurable_on UNIV"
<   by (simp add: continuous_imp_measurable_on)
< 
< lemma measurable_on_const [simp]: "S \<in> sets lebesgue \<Longrightarrow> (\<lambda>x. k) measurable_on S"
<   using measurable_on_UNIV measurable_on_const_UNIV measurable_on_restrict by blast
< 
< lemma simple_function_indicator_representation_real:
<   fixes f ::"'a \<Rightarrow> real"
<   assumes f: "simple_function M f" and x: "x \<in> space M" and nn: "\<And>x. f x \<ge> 0"
<   shows "f x = (\<Sum>y \<in> f ` space M. y * indicator (f -` {y} \<inter> space M) x)"
< proof -
<   have f': "simple_function M (ennreal \<circ> f)"
<     by (simp add: f)
<   have *: "f x =
<      enn2real
<       (\<Sum>y\<in> ennreal ` f ` space M.
<          y * indicator ((ennreal \<circ> f) -` {y} \<inter> space M) x)"
<     using arg_cong [OF simple_function_indicator_representation [OF f' x], of enn2real, simplified nn o_def] nn
<     unfolding o_def image_comp
<     by (metis enn2real_ennreal)
<   have "enn2real (\<Sum>y\<in>ennreal ` f ` space M. if ennreal (f x) = y \<and> x \<in> space M then y else 0)
<       = sum (enn2real \<circ> (\<lambda>y. if ennreal (f x) = y \<and> x \<in> space M then y else 0))
<             (ennreal ` f ` space M)"
<     by (rule enn2real_sum) auto
<   also have "\<dots> = sum (enn2real \<circ> (\<lambda>y. if ennreal (f x) = y \<and> x \<in> space M then y else 0) \<circ> ennreal)
<                    (f ` space M)"
<     by (rule sum.reindex) (use nn in \<open>auto simp: inj_on_def intro: sum.cong\<close>)
<   also have "\<dots> = (\<Sum>y\<in>f ` space M. if f x = y \<and> x \<in> space M then y else 0)"
<     using nn
<     by (auto simp: inj_on_def intro: sum.cong)
<   finally show ?thesis
<     by (subst *) (simp add: enn2real_sum indicator_def if_distrib cong: if_cong)
< qed
< 
< lemma\<^marker>\<open>tag important\<close> simple_function_induct_real
<     [consumes 1, case_names cong set mult add, induct set: simple_function]:
<   fixes u :: "'a \<Rightarrow> real"
<   assumes u: "simple_function M u"
<   assumes cong: "\<And>f g. simple_function M f \<Longrightarrow> simple_function M g \<Longrightarrow> (AE x in M. f x = g x) \<Longrightarrow> P f \<Longrightarrow> P g"
<   assumes set: "\<And>A. A \<in> sets M \<Longrightarrow> P (indicator A)"
<   assumes mult: "\<And>u c. P u \<Longrightarrow> P (\<lambda>x. c * u x)"
<   assumes add: "\<And>u v. P u \<Longrightarrow> P v \<Longrightarrow> P (\<lambda>x. u x + v x)"
<   and nn: "\<And>x. u x \<ge> 0"
<   shows "P u"
< proof (rule cong)
<   from AE_space show "AE x in M. (\<Sum>y\<in>u ` space M. y * indicator (u -` {y} \<inter> space M) x) = u x"
<   proof eventually_elim
<     fix x assume x: "x \<in> space M"
<     from simple_function_indicator_representation_real[OF u x] nn
<     show "(\<Sum>y\<in>u ` space M. y * indicator (u -` {y} \<inter> space M) x) = u x"
<       by metis
<   qed
< next
<   from u have "finite (u ` space M)"
<     unfolding simple_function_def by auto
<   then show "P (\<lambda>x. \<Sum>y\<in>u ` space M. y * indicator (u -` {y} \<inter> space M) x)"
<   proof induct
<     case empty
<     then show ?case
<       using set[of "{}"] by (simp add: indicator_def[abs_def])
<   next
<     case (insert a F)
<     have eq: "\<Sum> {y. u x = y \<and> (y = a \<or> y \<in> F) \<and> x \<in> space M}
<             = (if u x = a \<and> x \<in> space M then a else 0) + \<Sum> {y. u x = y \<and> y \<in> F \<and> x \<in> space M}" for x
<     proof (cases "x \<in> space M")
<       case True
<       have *: "{y. u x = y \<and> (y = a \<or> y \<in> F)} = {y. u x = a \<and> y = a} \<union> {y. u x = y \<and> y \<in> F}"
<         by auto
<       show ?thesis
<         using insert by (simp add: * True)
<     qed auto
<     have a: "P (\<lambda>x. a * indicator (u -` {a} \<inter> space M) x)"
<     proof (intro mult set)
<       show "u -` {a} \<inter> space M \<in> sets M"
<         using u by auto
<     qed
<     show ?case
<       using nn insert a
<       by (simp add: eq indicator_times_eq_if [where f = "\<lambda>x. a"] add)
<   qed
< next
<   show "simple_function M (\<lambda>x. (\<Sum>y\<in>u ` space M. y * indicator (u -` {y} \<inter> space M) x))"
<     apply (subst simple_function_cong)
<     apply (rule simple_function_indicator_representation_real[symmetric])
<     apply (auto intro: u nn)
<     done
< qed fact
< 
< proposition simple_function_measurable_on_UNIV:
<   fixes f :: "'a::euclidean_space \<Rightarrow> real"
<   assumes f: "simple_function lebesgue f" and nn: "\<And>x. f x \<ge> 0"
<   shows "f measurable_on UNIV"
<   using f
< proof (induction f)
<   case (cong f g)
<   then obtain N where "negligible N" "{x. g x \<noteq> f x} \<subseteq> N"
<     by (auto simp: eventually_ae_filter_negligible eq_commute)
<   then show ?case
<     by (blast intro: measurable_on_spike cong)
< next
<   case (set S)
<   then show ?case
<     by (simp add: indicator_measurable_on)
< next
<   case (mult u c)
<   then show ?case
<     by (simp add: measurable_on_cmul)
<   case (add u v)
<   then show ?case
<     by (simp add: measurable_on_add)
< qed (auto simp: nn)
< 
< lemma simple_function_lebesgue_if:
<   fixes f :: "'a::euclidean_space \<Rightarrow> real"
<   assumes f: "simple_function lebesgue f" and S: "S \<in> sets lebesgue"
<   shows "simple_function lebesgue (\<lambda>x. if x \<in> S then f x else 0)"
< proof -
<   have ffin: "finite (range f)" and fsets: "\<forall>x. f -` {f x} \<in> sets lebesgue"
<     using f by (auto simp: simple_function_def)
<   have "finite (f ` S)"
<     by (meson finite_subset subset_image_iff ffin top_greatest)
<   moreover have "finite ((\<lambda>x. 0::real) ` T)" for T :: "'a set"
<     by (auto simp: image_def)
<   moreover have if_sets: "(\<lambda>x. if x \<in> S then f x else 0) -` {f a} \<in> sets lebesgue" for a
<   proof -
<     have *: "(\<lambda>x. if x \<in> S then f x else 0) -` {f a}
<            = (if f a = 0 then -S \<union> f -` {f a} else (f -` {f a}) \<inter> S)"
<       by (auto simp: split: if_split_asm)
<     show ?thesis
<       unfolding * by (metis Compl_in_sets_lebesgue S sets.Int sets.Un fsets)
<   qed
<   moreover have "(\<lambda>x. if x \<in> S then f x else 0) -` {0} \<in> sets lebesgue"
<   proof (cases "0 \<in> range f")
<     case True
<     then show ?thesis
<       by (metis (no_types, lifting) if_sets rangeE)
<   next
<     case False
<     then have "(\<lambda>x. if x \<in> S then f x else 0) -` {0} = -S"
<       by auto
<     then show ?thesis
<       by (simp add: Compl_in_sets_lebesgue S)
<   qed
<   ultimately show ?thesis
<     by (auto simp: simple_function_def)
< qed
< 
< corollary simple_function_measurable_on:
<   fixes f :: "'a::euclidean_space \<Rightarrow> real"
<   assumes f: "simple_function lebesgue f" and nn: "\<And>x. f x \<ge> 0" and S: "S \<in> sets lebesgue"
<   shows "f measurable_on S"
<   by (simp add: measurable_on_UNIV [symmetric, of f] S f simple_function_lebesgue_if nn simple_function_measurable_on_UNIV)
< 
< lemma
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::ordered_euclidean_space"
<   assumes f: "f measurable_on S" and g: "g measurable_on S"
<   shows measurable_on_sup: "(\<lambda>x. f x \<squnion> g x) measurable_on S"
<   and   measurable_on_inf: "(\<lambda>x. f x \<sqinter> g x) measurable_on S"
< proof -
<   obtain NF and F
<     where NF: "negligible NF"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> NF \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> (if x \<in> S then f x else 0)"
<     using f by (auto simp: measurable_on_def)
<   obtain NG and G
<     where NG: "negligible NG"
<       and conG: "\<And>n. continuous_on UNIV (G n)"
<       and tendsG: "\<And>x. x \<notin> NG \<Longrightarrow> (\<lambda>n. G n x) \<longlonglongrightarrow> (if x \<in> S then g x else 0)"
<     using g by (auto simp: measurable_on_def)
<   show "(\<lambda>x. f x \<squnion> g x) measurable_on S"
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "continuous_on UNIV (\<lambda>x. F n x \<squnion> G n x)" for n
<       unfolding sup_max eucl_sup  by (intro conF conG continuous_intros)
<     show "(\<lambda>n. F n x \<squnion> G n x) \<longlonglongrightarrow> (if x \<in> S then f x \<squnion> g x else 0)"
<       if "x \<notin> NF \<union> NG" for x
<       using tendsto_sup [OF tendsF tendsG, of x x] that by auto
<   qed (simp add: NF NG)
<   show "(\<lambda>x. f x \<sqinter> g x) measurable_on S"
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "continuous_on UNIV (\<lambda>x. F n x \<sqinter> G n x)" for n
<       unfolding inf_min eucl_inf  by (intro conF conG continuous_intros)
<     show "(\<lambda>n. F n x \<sqinter> G n x) \<longlonglongrightarrow> (if x \<in> S then f x \<sqinter> g x else 0)"
<       if "x \<notin> NF \<union> NG" for x
<       using tendsto_inf [OF tendsF tendsG, of x x] that by auto
<   qed (simp add: NF NG)
< qed
< 
< proposition measurable_on_componentwise_UNIV:
<   "f measurable_on UNIV \<longleftrightarrow> (\<forall>i\<in>Basis. (\<lambda>x. (f x \<bullet> i) *\<^sub>R i) measurable_on UNIV)"
<   (is "?lhs = ?rhs")
< proof
<   assume L: ?lhs
<   show ?rhs
<   proof
<     fix i::'b
<     assume "i \<in> Basis"
<     have cont: "continuous_on UNIV (\<lambda>x. (x \<bullet> i) *\<^sub>R i)"
<       by (intro continuous_intros)
<     show "(\<lambda>x. (f x \<bullet> i) *\<^sub>R i) measurable_on UNIV"
<       using measurable_on_compose_continuous [OF L cont]
<       by (simp add: o_def)
<   qed
< next
<   assume ?rhs
<   then have "\<exists>N g. negligible N \<and>
<               (\<forall>n. continuous_on UNIV (g n)) \<and>
<               (\<forall>x. x \<notin> N \<longrightarrow> (\<lambda>n. g n x) \<longlonglongrightarrow> (f x \<bullet> i) *\<^sub>R i)"
<     if "i \<in> Basis" for i
<     by (simp add: measurable_on_def that)
<   then obtain N g where N: "\<And>i. i \<in> Basis \<Longrightarrow> negligible (N i)"
<         and cont: "\<And>i n. i \<in> Basis \<Longrightarrow> continuous_on UNIV (g i n)"
<         and tends: "\<And>i x. \<lbrakk>i \<in> Basis; x \<notin> N i\<rbrakk> \<Longrightarrow> (\<lambda>n. g i n x) \<longlonglongrightarrow> (f x \<bullet> i) *\<^sub>R i"
<     by metis
<   show ?lhs
<     unfolding measurable_on_def
<   proof (intro exI conjI allI impI)
<     show "negligible (\<Union>i \<in> Basis. N i)"
<       using N eucl.finite_Basis by blast
<     show "continuous_on UNIV (\<lambda>x. (\<Sum>i\<in>Basis. g i n x))" for n
<       by (intro continuous_intros cont)
<   next
<     fix x
<     assume "x \<notin> (\<Union>i \<in> Basis. N i)"
<     then have "\<And>i. i \<in> Basis \<Longrightarrow> x \<notin> N i"
<       by auto
<     then have "(\<lambda>n. (\<Sum>i\<in>Basis. g i n x)) \<longlonglongrightarrow> (\<Sum>i\<in>Basis. (f x \<bullet> i) *\<^sub>R i)"
<       by (intro tends tendsto_intros)
<     then show "(\<lambda>n. (\<Sum>i\<in>Basis. g i n x)) \<longlonglongrightarrow> (if x \<in> UNIV then f x else 0)"
<       by (simp add: euclidean_representation)
<   qed
< qed
< 
< corollary measurable_on_componentwise:
<   "f measurable_on S \<longleftrightarrow> (\<forall>i\<in>Basis. (\<lambda>x. (f x \<bullet> i) *\<^sub>R i) measurable_on S)"
<   apply (subst measurable_on_UNIV [symmetric])
<   apply (subst measurable_on_componentwise_UNIV)
<   apply (simp add: measurable_on_UNIV if_distrib [of "\<lambda>x. inner x _"] if_distrib [of "\<lambda>x. scaleR x _"] cong: if_cong)
<   done
< 
< 
< lemma\<^marker>\<open>tag important\<close> borel_measurable_implies_simple_function_sequence_real:
<   fixes u :: "'a \<Rightarrow> real"
<   assumes u[measurable]: "u \<in> borel_measurable M" and nn: "\<And>x. u x \<ge> 0"
<   shows "\<exists>f. incseq f \<and> (\<forall>i. simple_function M (f i)) \<and> (\<forall>x. bdd_above (range (\<lambda>i. f i x))) \<and>
<              (\<forall>i x. 0 \<le> f i x) \<and> u = (SUP i. f i)"
< proof -
<   define f where [abs_def]:
<     "f i x = real_of_int (floor ((min i (u x)) * 2^i)) / 2^i" for i x
< 
<   have [simp]: "0 \<le> f i x" for i x
<     by (auto simp: f_def intro!: divide_nonneg_nonneg mult_nonneg_nonneg nn)
< 
<   have *: "2^n * real_of_int x = real_of_int (2^n * x)" for n x
<     by simp
< 
<   have "real_of_int \<lfloor>real i * 2 ^ i\<rfloor> = real_of_int \<lfloor>i * 2 ^ i\<rfloor>" for i
<     by (intro arg_cong[where f=real_of_int]) simp
<   then have [simp]: "real_of_int \<lfloor>real i * 2 ^ i\<rfloor> = i * 2 ^ i" for i
<     unfolding floor_of_nat by simp
< 
<   have bdd: "bdd_above (range (\<lambda>i. f i x))" for x
<     by (rule bdd_aboveI [where M = "u x"]) (auto simp: f_def field_simps min_def)
< 
<   have "incseq f"
<   proof (intro monoI le_funI)
<     fix m n :: nat and x assume "m \<le> n"
<     moreover
<     { fix d :: nat
<       have "\<lfloor>2^d::real\<rfloor> * \<lfloor>2^m * (min (of_nat m) (u x))\<rfloor> \<le> \<lfloor>2^d * (2^m * (min (of_nat m) (u x)))\<rfloor>"
<         by (rule le_mult_floor) (auto simp: nn)
<       also have "\<dots> \<le> \<lfloor>2^d * (2^m *  (min (of_nat d + of_nat m) (u x)))\<rfloor>"
<         by (intro floor_mono mult_mono min.mono)
<            (auto simp: nn min_less_iff_disj of_nat_less_top)
<       finally have "f m x \<le> f(m + d) x"
<         unfolding f_def
<         by (auto simp: field_simps power_add * simp del: of_int_mult) }
<     ultimately show "f m x \<le> f n x"
<       by (auto simp: le_iff_add)
<   qed
<   then have inc_f: "incseq (\<lambda>i. f i x)" for x
<     by (auto simp: incseq_def le_fun_def)
<   moreover
<   have "simple_function M (f i)" for i
<   proof (rule simple_function_borel_measurable)
<     have "\<lfloor>(min (of_nat i) (u x)) * 2 ^ i\<rfloor> \<le> \<lfloor>int i * 2 ^ i\<rfloor>" for x
<       by (auto split: split_min intro!: floor_mono)
<     then have "f i ` space M \<subseteq> (\<lambda>n. real_of_int n / 2^i) ` {0 .. of_nat i * 2^i}"
<       unfolding floor_of_int by (auto simp: f_def nn intro!: imageI)
<     then show "finite (f i ` space M)"
<       by (rule finite_subset) auto
<     show "f i \<in> borel_measurable M"
<       unfolding f_def enn2real_def by measurable
<   qed
<   moreover
<   { fix x
<     have "(SUP i. (f i x)) = u x"
<     proof -
<       obtain n where "u x \<le> of_nat n" using real_arch_simple by auto
<       then have min_eq_r: "\<forall>\<^sub>F i in sequentially. min (real i) (u x) = u x"
<         by (auto simp: eventually_sequentially intro!: exI[of _ n] split: split_min)
<       have "(\<lambda>i. real_of_int \<lfloor>min (real i) (u x) * 2^i\<rfloor> / 2^i) \<longlonglongrightarrow> u x"
<       proof (rule tendsto_sandwich)
<         show "(\<lambda>n. u x - (1/2)^n) \<longlonglongrightarrow> u x"
<           by (auto intro!: tendsto_eq_intros LIMSEQ_power_zero)
<         show "\<forall>\<^sub>F n in sequentially. real_of_int \<lfloor>min (real n) (u x) * 2 ^ n\<rfloor> / 2 ^ n \<le> u x"
<           using min_eq_r by eventually_elim (auto simp: field_simps)
<         have *: "u x * (2 ^ n * 2 ^ n) \<le> 2^n + 2^n * real_of_int \<lfloor>u x * 2 ^ n\<rfloor>" for n
<           using real_of_int_floor_ge_diff_one[of "u x * 2^n", THEN mult_left_mono, of "2^n"]
<           by (auto simp: field_simps)
<         show "\<forall>\<^sub>F n in sequentially. u x - (1/2)^n \<le> real_of_int \<lfloor>min (real n) (u x) * 2 ^ n\<rfloor> / 2 ^ n"
<           using min_eq_r by eventually_elim (insert *, auto simp: field_simps)
<       qed auto
<       then have "(\<lambda>i. (f i x)) \<longlonglongrightarrow> u x"
<         by (simp add: f_def)
<       from LIMSEQ_unique LIMSEQ_incseq_SUP [OF bdd inc_f] this
<       show ?thesis
<         by blast
<     qed }
<   ultimately show ?thesis
<     by (intro exI [of _ "\<lambda>i x. f i x"]) (auto simp: \<open>incseq f\<close> bdd image_comp)
< qed
< 
< 
< lemma homeomorphic_open_interval_UNIV:
<   fixes a b:: real
<   assumes "a < b"
<   shows "{a<..<b} homeomorphic (UNIV::real set)"
< proof -
<   have "{a<..<b} = ball ((b+a) / 2) ((b-a) / 2)"
<     using assms
<     by (auto simp: dist_real_def abs_if divide_simps split: if_split_asm)
<   then show ?thesis
<     by (simp add: homeomorphic_ball_UNIV assms)
< qed
< 
< proposition homeomorphic_box_UNIV:
<   fixes a b:: "'a::euclidean_space"
<   assumes "box a b \<noteq> {}"
<   shows "box a b homeomorphic (UNIV::'a set)"
< proof -
<   have "{a \<bullet> i <..<b \<bullet> i} homeomorphic (UNIV::real set)" if "i \<in> Basis" for i
<     using assms box_ne_empty that by (blast intro: homeomorphic_open_interval_UNIV)
<   then have "\<exists>f g. (\<forall>x. a \<bullet> i < x \<and> x < b \<bullet> i \<longrightarrow> g (f x) = x) \<and>
<                    (\<forall>y. a \<bullet> i < g y \<and> g y < b \<bullet> i \<and> f(g y) = y) \<and>
<                    continuous_on {a \<bullet> i<..<b \<bullet> i} f \<and>
<                    continuous_on (UNIV::real set) g"
<     if "i \<in> Basis" for i
<     using that by (auto simp: homeomorphic_minimal mem_box Ball_def)
<   then obtain f g where gf: "\<And>i x. \<lbrakk>i \<in> Basis; a \<bullet> i < x; x < b \<bullet> i\<rbrakk> \<Longrightarrow> g i (f i x) = x"
<               and fg: "\<And>i y. i \<in> Basis \<Longrightarrow> a \<bullet> i < g i y \<and> g i y < b \<bullet> i \<and> f i (g i y) = y"
<               and contf: "\<And>i. i \<in> Basis \<Longrightarrow> continuous_on {a \<bullet> i<..<b \<bullet> i} (f i)"
<               and contg: "\<And>i. i \<in> Basis \<Longrightarrow> continuous_on (UNIV::real set) (g i)"
<     by metis
<   define F where "F \<equiv> \<lambda>x. \<Sum>i\<in>Basis. (f i (x \<bullet> i)) *\<^sub>R i"
<   define G where "G \<equiv> \<lambda>x. \<Sum>i\<in>Basis. (g i (x \<bullet> i)) *\<^sub>R i"
<   show ?thesis
<     unfolding homeomorphic_minimal
<   proof (intro exI conjI ballI)
<     show "G y \<in> box a b" for y
<       using fg by (simp add: G_def mem_box)
<     show "G (F x) = x" if "x \<in> box a b" for x
<       using that by (simp add: F_def G_def gf mem_box euclidean_representation)
<     show "F (G y) = y" for y
<       by (simp add: F_def G_def fg mem_box euclidean_representation)
<     show "continuous_on (box a b) F"
<       unfolding F_def
<     proof (intro continuous_intros continuous_on_compose2 [OF contf continuous_on_inner])
<       show "(\<lambda>x. x \<bullet> i) ` box a b \<subseteq> {a \<bullet> i<..<b \<bullet> i}" if "i \<in> Basis" for i
<         using that by (auto simp: mem_box)
<     qed
<     show "continuous_on UNIV G"
<       unfolding G_def
<       by (intro continuous_intros continuous_on_compose2 [OF contg continuous_on_inner]) auto
<   qed auto
< qed
< 
< 
< 
< lemma diff_null_sets_lebesgue: "\<lbrakk>N \<in> null_sets (lebesgue_on S); X-N \<in> sets (lebesgue_on S); N \<subseteq> X\<rbrakk>
<     \<Longrightarrow> X \<in> sets (lebesgue_on S)"
<   by (metis Int_Diff_Un inf.commute inf.orderE null_setsD2 sets.Un)
< 
< lemma borel_measurable_diff_null:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes N: "N \<in> null_sets (lebesgue_on S)" and S: "S \<in> sets lebesgue"
<   shows "f \<in> borel_measurable (lebesgue_on (S-N)) \<longleftrightarrow> f \<in> borel_measurable (lebesgue_on S)"
<   unfolding in_borel_measurable borel_measurable_UNIV_eq [symmetric] space_lebesgue_on sets_restrict_UNIV
< proof (intro ball_cong iffI)
<   show "f -` T \<inter> S \<in> sets (lebesgue_on S)"
<     if "f -` T \<inter> (S-N) \<in> sets (lebesgue_on (S-N))" for T
<     using that  assms
<     by (smt Diff_Int_distrib completion.complete2 diff_null_sets_lebesgue inf.idem inf_le2 inf_mono lebesgue_on_UNIV_eq null_setsD2 null_sets_restrict_space sets.Diff sets_restrict_space_iff space_lebesgue_on space_restrict_space)
<   show "f -` T \<inter> (S-N) \<in> sets (lebesgue_on (S-N))"
<     if "f -` T \<inter> S \<in> sets (lebesgue_on S)" for T
<     using image_eqI inf.commute inf_top_right sets_restrict_space that
<     by (smt Int_Diff S sets.Int_space_eq2 sets_restrict_space_iff space_lebesgue_on)
< qed auto
< 
< lemma lebesgue_measurable_diff_null:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "N \<in> null_sets lebesgue"
<   shows "f \<in> borel_measurable (lebesgue_on (-N)) \<longleftrightarrow> f \<in> borel_measurable lebesgue"
<   by (simp add: Compl_eq_Diff_UNIV assms borel_measurable_diff_null lebesgue_on_UNIV_eq)
< 
< 
< 
< proposition measurable_on_imp_borel_measurable_lebesgue_UNIV:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "f measurable_on UNIV"
<   shows "f \<in> borel_measurable lebesgue"
< proof -
<   obtain N and F
<     where NF: "negligible N"
<       and conF: "\<And>n. continuous_on UNIV (F n)"
<       and tendsF: "\<And>x. x \<notin> N \<Longrightarrow> (\<lambda>n. F n x) \<longlonglongrightarrow> f x"
<     using assms by (auto simp: measurable_on_def)
<   obtain N where "N \<in> null_sets lebesgue" "f \<in> borel_measurable (lebesgue_on (-N))"
<   proof
<     show "f \<in> borel_measurable (lebesgue_on (- N))"
<     proof (rule borel_measurable_LIMSEQ_metric)
<       show "F i \<in> borel_measurable (lebesgue_on (- N))" for i
<         by (meson Compl_in_sets_lebesgue NF conF continuous_imp_measurable_on_sets_lebesgue continuous_on_subset negligible_imp_sets subset_UNIV)
<       show "(\<lambda>i. F i x) \<longlonglongrightarrow> f x" if "x \<in> space (lebesgue_on (- N))" for x
<         using that
<         by (simp add: tendsF)
<     qed
<     show "N \<in> null_sets lebesgue"
<       using NF negligible_iff_null_sets by blast
<   qed
<   then show ?thesis
<     using lebesgue_measurable_diff_null by blast
< qed
< 
< corollary measurable_on_imp_borel_measurable_lebesgue:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "f measurable_on S" and S: "S \<in> sets lebesgue"
<   shows "f \<in> borel_measurable (lebesgue_on S)"
< proof -
<   have "(\<lambda>x. if x \<in> S then f x else 0) measurable_on UNIV"
<     using assms(1) measurable_on_UNIV by blast
<   then show ?thesis
<     by (simp add: borel_measurable_If_D measurable_on_imp_borel_measurable_lebesgue_UNIV)
< qed
< 
< 
< proposition measurable_on_limit:
<   fixes f :: "nat \<Rightarrow> 'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes f: "\<And>n. f n measurable_on S" and N: "negligible N"
<     and lim: "\<And>x. x \<in> S - N \<Longrightarrow> (\<lambda>n. f n x) \<longlonglongrightarrow> g x"
<   shows "g measurable_on S"
< proof -
<   have "box (0::'b) One homeomorphic (UNIV::'b set)"
<     by (simp add: homeomorphic_box_UNIV)
<   then obtain h h':: "'b\<Rightarrow>'b" where hh': "\<And>x. x \<in> box 0 One \<Longrightarrow> h (h' x) = x"
<                   and h'im:  "h' ` box 0 One = UNIV"
<                   and conth: "continuous_on UNIV h"
<                   and conth': "continuous_on (box 0 One) h'"
<                   and h'h:   "\<And>y. h' (h y) = y"
<                   and rangeh: "range h = box 0 One"
<     by (auto simp: homeomorphic_def homeomorphism_def)
<   have "norm y \<le> DIM('b)" if y: "y \<in> box 0 One" for y::'b
<   proof -
<     have y01: "0 < y \<bullet> i" "y \<bullet> i < 1" if "i \<in> Basis" for i
<       using that y by (auto simp: mem_box)
<     have "norm y \<le> (\<Sum>i\<in>Basis. \<bar>y \<bullet> i\<bar>)"
<       using norm_le_l1 by blast
<     also have "\<dots> \<le> (\<Sum>i::'b\<in>Basis. 1)"
<     proof (rule sum_mono)
<       show "\<bar>y \<bullet> i\<bar> \<le> 1" if "i \<in> Basis" for i
<         using y01 that by fastforce
<     qed
<     also have "\<dots> \<le> DIM('b)"
<       by auto
<     finally show ?thesis .
<   qed
<   then have norm_le: "norm(h y) \<le> DIM('b)" for y
<     by (metis UNIV_I image_eqI rangeh)
<   have "(h' \<circ> (h \<circ> (\<lambda>x. if x \<in> S then g x else 0))) measurable_on UNIV"
<   proof (rule measurable_on_compose_continuous_box)
<     let ?\<chi> =  "h \<circ> (\<lambda>x. if x \<in> S then g x else 0)"
<     let ?f = "\<lambda>n. h \<circ> (\<lambda>x. if x \<in> S then f n x else 0)"
<     show "?\<chi> measurable_on UNIV"
<     proof (rule integrable_subintervals_imp_measurable)
<       show "?\<chi> integrable_on cbox a b" for a b
<       proof (rule integrable_spike_set)
<         show "?\<chi> integrable_on (cbox a b - N)"
<         proof (rule dominated_convergence_integrable)
<           show const: "(\<lambda>x. DIM('b)) integrable_on cbox a b - N"
<             by (simp add: N has_integral_iff integrable_const integrable_negligible integrable_setdiff negligible_diff)
<           show "norm ((h \<circ> (\<lambda>x. if x \<in> S then g x else 0)) x) \<le> DIM('b)" if "x \<in> cbox a b - N" for x
<             using that norm_le  by (simp add: o_def)
<           show "(\<lambda>k. ?f k x) \<longlonglongrightarrow> ?\<chi> x" if "x \<in> cbox a b - N" for x
<             using that lim [of x] conth
<             by (auto simp: continuous_on_def intro: tendsto_compose)
<           show "(?f n) absolutely_integrable_on cbox a b - N" for n
<           proof (rule measurable_bounded_by_integrable_imp_absolutely_integrable)
<             show "?f n \<in> borel_measurable (lebesgue_on (cbox a b - N))"
<             proof (rule measurable_on_imp_borel_measurable_lebesgue [OF measurable_on_spike_set])
<               show "?f n measurable_on cbox a b"
<                 unfolding measurable_on_UNIV [symmetric, of _ "cbox a b"]
<               proof (rule measurable_on_restrict)
<                 have f': "(\<lambda>x. if x \<in> S then f n x else 0) measurable_on UNIV"
<                   by (simp add: f measurable_on_UNIV)
<                 show "?f n measurable_on UNIV"
<                   using measurable_on_compose_continuous [OF f' conth] by auto
<               qed auto
<               show "negligible (cbox a b \<Delta> (cbox a b - N))"
<                 by (auto intro: negligible_subset [OF N])
<               show "cbox a b - N \<in> sets lebesgue"
<                 by (simp add: N negligible_imp_sets sets.Diff)
<             qed
<             show "cbox a b - N \<in> sets lebesgue"
<               by (simp add: N negligible_imp_sets sets.Diff)
<             show "norm (?f n x) \<le> DIM('b)"
<               if "x \<in> cbox a b - N" for x
<               using that local.norm_le by simp
<           qed (auto simp: const)
<         qed
<         show "negligible {x \<in> cbox a b - N - cbox a b. ?\<chi> x \<noteq> 0}"
<           by (auto simp: empty_imp_negligible)
<         have "{x \<in> cbox a b - (cbox a b - N). ?\<chi> x \<noteq> 0} \<subseteq> N"
<           by auto
<         then show "negligible {x \<in> cbox a b - (cbox a b - N). ?\<chi> x \<noteq> 0}"
<           using N negligible_subset by blast
<       qed
<     qed
<     show "?\<chi> x \<in> box 0 One" for x
<       using rangeh by auto
<     show "continuous_on (box 0 One) h'"
<       by (rule conth')
<   qed
<   then show ?thesis
<     by (simp add: o_def h'h measurable_on_UNIV)
< qed
< 
< 
< lemma measurable_on_if_simple_function_limit:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   shows  "\<lbrakk>\<And>n. g n measurable_on UNIV; \<And>n. finite (range (g n)); \<And>x. (\<lambda>n. g n x) \<longlonglongrightarrow> f x\<rbrakk>
<    \<Longrightarrow> f measurable_on UNIV"
<   by (force intro: measurable_on_limit [where N="{}"])
< 
< 
< lemma lebesgue_measurable_imp_measurable_on_nnreal_UNIV:
<   fixes u :: "'a::euclidean_space \<Rightarrow> real"
<   assumes u: "u \<in> borel_measurable lebesgue" and nn: "\<And>x. u x \<ge> 0"
<   shows "u measurable_on UNIV"
< proof -
<   obtain f where "incseq f" and f: "\<forall>i. simple_function lebesgue (f i)"
<     and bdd: "\<And>x. bdd_above (range (\<lambda>i. f i x))"
<     and nnf: "\<And>i x. 0 \<le> f i x" and *: "u = (SUP i. f i)"
<     using borel_measurable_implies_simple_function_sequence_real nn u by metis
<   show ?thesis
<     unfolding *
<   proof (rule measurable_on_if_simple_function_limit [of concl: "\<Squnion> range f"])
<     show "(f i) measurable_on UNIV" for i
<       by (simp add: f nnf simple_function_measurable_on_UNIV)
<     show "finite (range (f i))" for i
<       by (metis f simple_function_def space_borel space_completion space_lborel)
<     show "(\<lambda>i. f i x) \<longlonglongrightarrow> (\<Squnion> range f) x" for x
<     proof -
<       have "incseq (\<lambda>i. f i x)"
<         using \<open>incseq f\<close> apply (auto simp: incseq_def)
<         by (simp add: le_funD)
<       then show ?thesis
<         by (metis SUP_apply bdd LIMSEQ_incseq_SUP)
<     qed
<   qed
< qed
< 
< lemma lebesgue_measurable_imp_measurable_on_nnreal:
<   fixes u :: "'a::euclidean_space \<Rightarrow> real"
<   assumes "u \<in> borel_measurable lebesgue" "\<And>x. u x \<ge> 0""S \<in> sets lebesgue"
<   shows "u measurable_on S"
<   unfolding measurable_on_UNIV [symmetric, of u]
<   using assms
<   by (auto intro: lebesgue_measurable_imp_measurable_on_nnreal_UNIV)
< 
< lemma lebesgue_measurable_imp_measurable_on_real:
<   fixes u :: "'a::euclidean_space \<Rightarrow> real"
<   assumes u: "u \<in> borel_measurable lebesgue" and S: "S \<in> sets lebesgue"
<   shows "u measurable_on S"
< proof -
<   let ?f = "\<lambda>x. \<bar>u x\<bar> + u x"
<   let ?g = "\<lambda>x. \<bar>u x\<bar> - u x"
<   have "?f measurable_on S" "?g measurable_on S"
<     using S u by (auto intro: lebesgue_measurable_imp_measurable_on_nnreal)
<   then have "(\<lambda>x. (?f x - ?g x) / 2) measurable_on S"
<     using measurable_on_cdivide measurable_on_diff by blast
<   then show ?thesis
<     by auto
< qed
< 
< 
< proposition lebesgue_measurable_imp_measurable_on:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes f: "f \<in> borel_measurable lebesgue" and S: "S \<in> sets lebesgue"
<   shows "f measurable_on S"
<   unfolding measurable_on_componentwise [of f]
< proof
<   fix i::'b
<   assume "i \<in> Basis"
<   have "(\<lambda>x. (f x \<bullet> i)) \<in> borel_measurable lebesgue"
<     using \<open>i \<in> Basis\<close> borel_measurable_euclidean_space f by blast
<   then have "(\<lambda>x. (f x \<bullet> i)) measurable_on S"
<     using S lebesgue_measurable_imp_measurable_on_real by blast
<   then show "(\<lambda>x. (f x \<bullet> i) *\<^sub>R i) measurable_on S"
<     by (intro measurable_on_scaleR measurable_on_const S)
< qed
< 
< proposition measurable_on_iff_borel_measurable:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "S \<in> sets lebesgue"
<   shows "f measurable_on S \<longleftrightarrow> f \<in> borel_measurable (lebesgue_on S)" (is "?lhs = ?rhs")
< proof
<   show "f \<in> borel_measurable (lebesgue_on S)"
<     if "f measurable_on S"
<     using that by (simp add: assms measurable_on_imp_borel_measurable_lebesgue)
< next
<   assume "f \<in> borel_measurable (lebesgue_on S)"
<   then have "(\<lambda>a. if a \<in> S then f a else 0) measurable_on UNIV"
<     by (simp add: assms borel_measurable_If_I lebesgue_measurable_imp_measurable_on)
<   then show "f measurable_on S"
<     using measurable_on_UNIV by blast
< qed
< 
< lemma measurable_on_bilinear:
<   fixes h :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space \<Rightarrow> 'c::euclidean_space"
<   assumes h: "bilinear h" and f: "f measurable_on S" and g: "g measurable_on S"
<   shows "(\<lambda>x. h (f x) (g x)) measurable_on S"
< proof (rule measurable_on_combine [where h = h])
<   show "continuous_on UNIV (\<lambda>x. h (fst x) (snd x))"
<     by (metis (mono_tags, lifting) bilinear_continuous_on_compose continuous_on_cong continuous_on_fst continuous_on_id continuous_on_snd h)
<   show "h 0 0 = 0"
<   by (simp add: bilinear_lzero h)
< qed (auto intro: assms)
< 
< lemma borel_measurable_bilinear:
<   fixes h :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space \<Rightarrow> 'c::euclidean_space"
<   assumes "bilinear h" "f \<in> borel_measurable (lebesgue_on S)" "g \<in> borel_measurable (lebesgue_on S)"
<     and S: "S \<in> sets lebesgue"
<   shows "(\<lambda>x. h (f x) (g x)) \<in> borel_measurable (lebesgue_on S)"
<   using assms measurable_on_bilinear [of h f S g]
<   by (simp flip: measurable_on_iff_borel_measurable)
< 
< 
< lemma absolutely_integrable_bounded_measurable_product:
<   fixes h :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space \<Rightarrow> 'c::euclidean_space"
<   assumes "bilinear h" and f: "f \<in> borel_measurable (lebesgue_on S)" "S \<in> sets lebesgue"
<     and bou: "bounded (f ` S)" and g: "g absolutely_integrable_on S"
<   shows "(\<lambda>x. h (f x) (g x)) absolutely_integrable_on S"
< proof -
<   obtain B where "B > 0" and B: "\<And>x y. norm (h x y) \<le> B * norm x * norm y"
<     using bilinear_bounded_pos \<open>bilinear h\<close> by blast
<   obtain C where "C > 0" and C: "\<And>x. x \<in> S \<Longrightarrow> norm (f x) \<le> C"
<     using bounded_pos by (metis bou imageI)
<   show ?thesis
<   proof (rule measurable_bounded_by_integrable_imp_absolutely_integrable [OF _ \<open>S \<in> sets lebesgue\<close>])
<     show "norm (h (f x) (g x)) \<le> B * C * norm(g x)" if "x \<in> S" for x
<       by (meson less_le mult_left_mono mult_right_mono norm_ge_zero order_trans that \<open>B > 0\<close> B C)
<     show "(\<lambda>x. h (f x) (g x)) \<in> borel_measurable (lebesgue_on S)"
<       using \<open>bilinear h\<close> f g absolutely_integrable_measurable borel_measurable_bilinear by blast
<     show "(\<lambda>x. B * C * norm(g x)) integrable_on S"
<       using \<open>0 < B\<close> \<open>0 < C\<close> absolutely_integrable_on_def g by auto
<   qed
< qed
< 
< lemma absolutely_integrable_bounded_measurable_product_real:
<   fixes f :: "real \<Rightarrow> real"
<   assumes "f \<in> borel_measurable (lebesgue_on S)" "S \<in> sets lebesgue"
<       and "bounded (f ` S)" and "g absolutely_integrable_on S"
<   shows "(\<lambda>x. f x * g x) absolutely_integrable_on S"
<   using absolutely_integrable_bounded_measurable_product bilinear_times assms by blast
< 
< 
< 
< 
< lemma set_integrable_mult_right_iff [simp]:
<   fixes a :: "'a::{real_normed_field, second_countable_topology}"
<   assumes "a \<noteq> 0"
<   shows "set_integrable M A (\<lambda>t. a * f t) \<longleftrightarrow> set_integrable M A f"
< proof
<   assume "set_integrable M A (\<lambda>t. a * f t)"
<   then have "set_integrable M A (\<lambda>t. 1/a * (a * f t))"
<     using set_integrable_mult_right by blast
<   then show "set_integrable M A f"
<     using assms by auto
< qed auto
< 
< lemma set_integrable_mult_left_iff [simp]:
<   fixes a :: "'a::{real_normed_field, second_countable_topology}"
<   assumes "a \<noteq> 0"
<   shows "set_integrable M A (\<lambda>t. f t * a) \<longleftrightarrow> set_integrable M A f"
<   using assms
<   by (subst set_integrable_mult_right_iff [symmetric]) (auto simp: mult.commute)
< 
< 
< lemma set_integrable_mult_divide_iff [simp]:
<   fixes a :: "'a::{real_normed_field, second_countable_topology}"
<   assumes "a \<noteq> 0"
<   shows "set_integrable M A (\<lambda>t. f t / a) \<longleftrightarrow> set_integrable M A f"
<   by (simp add: divide_inverse assms)
< 
< 
< lemma borel_measurable_AE:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "f \<in> borel_measurable lebesgue" and ae: "AE x in lebesgue. f x = g x"
<   shows "g \<in> borel_measurable lebesgue"
< proof -
<   obtain N where N: "N \<in> null_sets lebesgue" "\<And>x. x \<notin> N \<Longrightarrow> f x = g x"
<     using AE_null_sets_lebesgue [OF ae] by blast
<   have "f measurable_on UNIV"
<     by (simp add: assms lebesgue_measurable_imp_measurable_on)
<   then have "g measurable_on UNIV"
<     by (metis Diff_iff N measurable_on_spike negligible_iff_null_sets)
<   then show ?thesis
<     using measurable_on_imp_borel_measurable_lebesgue_UNIV by blast
< qed
< 
< 
< lemma has_bochner_integral_combine:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes "a \<le> c" "c \<le> b"
<     and ac: "has_bochner_integral (lebesgue_on {a..c}) f i"
<     and cb: "has_bochner_integral (lebesgue_on {c..b}) f j"
<   shows "has_bochner_integral (lebesgue_on {a..b}) f(i + j)"
< proof -
<   have i: "has_bochner_integral lebesgue (\<lambda>x. indicator {a..c} x *\<^sub>R f x) i"
<    and j: "has_bochner_integral lebesgue (\<lambda>x. indicator {c..b} x *\<^sub>R f x) j"
<     using assms  by (auto simp: has_bochner_integral_restrict_space)
<   have AE: "AE x in lebesgue. indicat_real {a..c} x *\<^sub>R f x + indicat_real {c..b} x *\<^sub>R f x = indicat_real {a..b} x *\<^sub>R f x"
<   proof (rule AE_I')
<     have eq: "indicat_real {a..c} x *\<^sub>R f x + indicat_real {c..b} x *\<^sub>R f x = indicat_real {a..b} x *\<^sub>R f x" if "x \<noteq> c" for x
<       using assms that by (auto simp: indicator_def)
<     then show "{x \<in> space lebesgue. indicat_real {a..c} x *\<^sub>R f x + indicat_real {c..b} x *\<^sub>R f x \<noteq> indicat_real {a..b} x *\<^sub>R f x} \<subseteq> {c}"
<       by auto
<   qed auto
<   have "has_bochner_integral lebesgue (\<lambda>x. indicator {a..b} x *\<^sub>R f x) (i + j)"
<   proof (rule has_bochner_integralI_AE [OF has_bochner_integral_add [OF i j] _ AE])
<     have eq: "indicat_real {a..c} x *\<^sub>R f x + indicat_real {c..b} x *\<^sub>R f x = indicat_real {a..b} x *\<^sub>R f x" if "x \<noteq> c" for x
<       using assms that by (auto simp: indicator_def)
<     show "(\<lambda>x. indicat_real {a..b} x *\<^sub>R f x) \<in> borel_measurable lebesgue"
<     proof (rule borel_measurable_AE [OF borel_measurable_add AE])
<       show "(\<lambda>x. indicator {a..c} x *\<^sub>R f x) \<in> borel_measurable lebesgue"
<            "(\<lambda>x. indicator {c..b} x *\<^sub>R f x) \<in> borel_measurable lebesgue"
<         using i j by auto
<     qed
<   qed
<   then show ?thesis
<     by (simp add: has_bochner_integral_restrict_space)
< qed
< 
< lemma integrable_combine:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes "integrable (lebesgue_on {a..c}) f" "integrable (lebesgue_on {c..b}) f"
<     and "a \<le> c" "c \<le> b"
<   shows "integrable (lebesgue_on {a..b}) f"
<   using assms has_bochner_integral_combine has_bochner_integral_iff by blast
< 
< lemma integral_combine:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes f: "integrable (lebesgue_on {a..b}) f" and "a \<le> c" "c \<le> b"
<   shows "integral\<^sup>L (lebesgue_on {a..b}) f = integral\<^sup>L (lebesgue_on {a..c}) f + integral\<^sup>L (lebesgue_on {c..b}) f"
< proof -
<   have i: "has_bochner_integral (lebesgue_on {a..c}) f(integral\<^sup>L (lebesgue_on {a..c}) f)"
<     using integrable_subinterval_real \<open>c \<le> b\<close> f has_bochner_integral_iff by fastforce
<   have j: "has_bochner_integral (lebesgue_on {c..b}) f(integral\<^sup>L (lebesgue_on {c..b}) f)"
<     using integrable_subinterval_real \<open>a \<le> c\<close> f has_bochner_integral_iff by fastforce
<   show ?thesis
<     by (meson \<open>a \<le> c\<close> \<open>c \<le> b\<close> has_bochner_integral_combine has_bochner_integral_iff i j)
< qed
< 
< lemma has_bochner_integral_reflect_real_lemma[intro]:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   assumes "has_bochner_integral (lebesgue_on {a..b}) f i"
<   shows "has_bochner_integral (lebesgue_on {-b..-a}) (\<lambda>x. f(-x)) i"
< proof -
<   have eq: "indicat_real {a..b} (- x) *\<^sub>R f(- x) = indicat_real {- b..- a} x *\<^sub>R f(- x)" for x
<     by (auto simp: indicator_def)
<   have i: "has_bochner_integral lebesgue (\<lambda>x. indicator {a..b} x *\<^sub>R f x) i"
<     using assms by (auto simp: has_bochner_integral_restrict_space)
<   then have "has_bochner_integral lebesgue (\<lambda>x. indicator {-b..-a} x *\<^sub>R f(-x)) i"
<     using has_bochner_integral_lebesgue_real_affine_iff [of "-1" "(\<lambda>x. indicator {a..b} x *\<^sub>R f x)" i 0]
<     by (auto simp: eq)
<   then show ?thesis
<     by (auto simp: has_bochner_integral_restrict_space)
< qed
< 
< lemma has_bochner_integral_reflect_real[simp]:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   shows "has_bochner_integral (lebesgue_on {-b..-a}) (\<lambda>x. f(-x)) i \<longleftrightarrow> has_bochner_integral (lebesgue_on {a..b}) f i"
<   by (auto simp: dest: has_bochner_integral_reflect_real_lemma)
< 
< lemma has_bochner_integral_null [intro]:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "N \<in> null_sets lebesgue"
<   shows "has_bochner_integral (lebesgue_on N) f 0"
<   unfolding has_bochner_integral_iff
< proof
<   show "integrable (lebesgue_on N) f"
<   proof (subst integrable_restrict_space)
<     show "N \<inter> space lebesgue \<in> sets lebesgue"
<       using assms by force
<     show "integrable lebesgue (\<lambda>x. indicat_real N x *\<^sub>R f x)"
<     proof (rule integrable_cong_AE_imp)
<       show "integrable lebesgue (\<lambda>x. 0)"
<         by simp
<       show *: "AE x in lebesgue. 0 = indicat_real N x *\<^sub>R f x"
<         using assms
<         by (simp add: indicator_def completion.null_sets_iff_AE eventually_mono)
<       show "(\<lambda>x. indicat_real N x *\<^sub>R f x) \<in> borel_measurable lebesgue"
<         by (auto intro: borel_measurable_AE [OF _ *])
<     qed
<   qed
<   show "integral\<^sup>L (lebesgue_on N) f = 0"
<   proof (rule integral_eq_zero_AE)
<     show "AE x in lebesgue_on N. f x = 0"
<       by (rule AE_I' [where N=N]) (auto simp: assms null_setsD2 null_sets_restrict_space)
<   qed
< qed
< 
< 
< lemma has_bochner_integral_null_eq[simp]:
<   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
<   assumes "N \<in> null_sets lebesgue"
<   shows "has_bochner_integral (lebesgue_on N) f i \<longleftrightarrow> i = 0"
<   using assms has_bochner_integral_eq by blast
< 
< lemma integrable_reflect_real[simp]:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   shows "integrable (lebesgue_on {-b..-a}) (\<lambda>x. f(-x)) \<longleftrightarrow> integrable (lebesgue_on {a..b}) f"
<   by (metis has_bochner_integral_iff has_bochner_integral_reflect_real)
< 
< lemma integral_reflect_real[simp]:
<   fixes f :: "real \<Rightarrow> 'a::euclidean_space"
<   shows "integral\<^sup>L (lebesgue_on {-b .. -a}) (\<lambda>x. f(-x)) = integral\<^sup>L (lebesgue_on {a..b::real}) f"
<   using has_bochner_integral_reflect_real [of b a f]
<   by (metis has_bochner_integral_iff not_integrable_integral_eq)
< 
< lemma monoseq_convergent:
<   fixes X :: "nat \<Rightarrow> real"
<   assumes X: "monoseq X" and B: "\<And>i. \<bar>X i\<bar> \<le> B"
<   obtains L where "X \<longlonglongrightarrow> L"
<   using X unfolding monoseq_iff
< proof
<   assume "incseq X"
<   show thesis
<     using abs_le_D1 [OF B] incseq_convergent [OF \<open>incseq X\<close>] that by meson
< next
<   assume "decseq X"
<   show thesis
<     using decseq_convergent [OF \<open>decseq X\<close>] that
<     by (metis B abs_le_iff add.inverse_inverse neg_le_iff_le)
< qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fourier/Fourier.thy ../../AFPs/afp-2020/thys/Fourier/Fourier.thy
6c6
<   imports Periodic Square_Integrable "HOL-Real_Asymp.Real_Asymp" Confine
---
>   imports Periodic Square_Integrable "HOL-Real_Asymp.Real_Asymp" Confine Fourier_Aux2
35,37c35,37
<     apply (simp add: square_integrable_diff l2norm_pow_2 orthonormal_coeff_def orthonormal_system_def)
<     apply (simp add: square_integrable_diff square_integrable_lmult l2product_rdiff l2product_sym
<            l2product_rsum l2product_rmult algebra_simps  power2_eq_square if_distrib [of "\<lambda>x. _ * x"])
---
>     apply (simp add: l2norm_pow_2 orthonormal_coeff_def orthonormal_system_def)
>     apply (simp add: l2product_rdiff l2product_sym
>            l2product_rsum l2product_rmult algebra_simps power2_eq_square if_distrib [of "\<lambda>x. _ * x"])
208d207
< 
218a218,222
> lemma integral_cos_Z' [simp]:
>   assumes "n \<in> \<int>"
>   shows "integral\<^sup>L (lebesgue_on {-pi..pi}) (\<lambda>x. cos(n * x)) = (if n = 0 then 2 * pi else 0)"
>   by (metis assms integral_cos_Z mult_commute_abs)
> 
280d283
< 
288c291
<       by (induction n rule: odd_even_cases) (auto simp: trigonometric_set l2product_def)
---
>       by (induction n rule: odd_even_cases) (auto simp: trigonometric_set l2product_def measure_restrict_space)
475,477c478,479
<       by (auto simp add: sin_times_sin cos_times_cos sin_times_cos cos_times_sin diff_divide_distrib
<                simp flip: of_nat_diff left_diff_distrib distrib_right
<                intro!: tp_add tp_diff tp_cdiv tp_cos tp_sin)
---
>       by (simp add: sin_times_sin cos_times_cos sin_times_cos cos_times_sin diff_divide_distrib 
>                     tp_add tp_diff tp_cdiv tp_cos tp_sin flip: left_diff_distrib distrib_right)
560c562
<     using borel_measurable_If_I [of _ "{a}", OF borel_measurable_const] by auto
---
>     using borel_measurable_if_I [of _ "{a}", OF borel_measurable_const] by auto
568c570
<       using borel_measurable_If_I [of _ "{.. a+1 / (Suc k)}", OF bm]  apply auto
---
>       using borel_measurable_if_I [of _ "{.. a+1 / (Suc k)}", OF bm]  apply auto
635c637
<       using null_AE_impI [OF null_a] by (force intro: integral_eq_zero_AE)
---
>       by (force intro: integral_eq_zero_AE AE_I' [OF null_a])
736c738
<           using \<open>e > 0\<close> pi_less_4 by (auto simp: power2_eq_square)
---
>           using \<open>e > 0\<close> pi_less_4 by (auto simp: power2_eq_square measure_restrict_space)
1233c1235
<   by (auto simp: Fourier_coefficient_def orthonormal_coeff_def l2product_def trigonometric_set_def divide_simps)
---
>   by (auto simp: Fourier_coefficient_def orthonormal_coeff_def l2product_def trigonometric_set_def divide_simps measure_restrict_space)
1381c1383
<       by (force simp: Dirichlet_kernel_def continuous_at eventually_at_filter elim: Lim_transform_eventually [rotated])
---
>       by (force simp: Dirichlet_kernel_def continuous_at eventually_at_filter elim: Lim_transform_eventually)
1467c1469
<       by auto
---
>       by (auto simp: measure_restrict_space)
1545c1547
<     using real_tendsto_mult_right_iff [of "inverse pi", symmetric] by auto
---
>     using tendsto_mult_right_iff [of "inverse pi", symmetric] by auto
1567c1569
<   proof (rule Lim_transform_eventually [OF eventually_sequentiallyI that])
---
>   proof (rule Lim_transform_eventually [OF that eventually_sequentiallyI])
1586c1588
<         by (auto simp: divide_simps trigonometric_set absolutely_integrable_imp_integrable)
---
>         by (auto simp: divide_simps trigonometric_set absolutely_integrable_imp_integrable measure_restrict_space)
1681c1683
<       by (intro absolutely_integrable_diff fxt) (simp add: set_integrable_def)
---
>       by (intro set_integral_diff fxt) (simp add: set_integrable_def)
1846d1847
< 
1854c1855
<     using integrable_subinterval_real assms by fastforce+
---
>     using integrable_subinterval assms by fastforce+
2203c2204
<       unfolding \<theta>_def using indefinite_integral_continuous_1 int0d by blast
---
>       unfolding \<theta>_def using indefinite_integral_continuous_real int0d by blast
2230c2231
<       proof (rule integrable_subinterval_real [of 0 d])
---
>       proof (rule integrable_subinterval [of 0 d])
2274,2275c2275,2276
<     apply (intro absolutely_integrable_bounded_measurable_product_real measurable absolutely_integrable_diff)
<           apply (auto simp: borel_measurable_UNIV_eq measurable_completion simp flip: absolutely_integrable_restrict_UNIV [where S = "{-pi..pi}"])
---
>     apply (intro absolutely_integrable_bounded_measurable_product_real measurable set_integral_diff)
>           apply (auto simp: lebesgue_on_UNIV_eq measurable_completion simp flip: absolutely_integrable_restrict_UNIV [where S = "{-pi..pi}"])
2297c2298
<     by (simp flip: integral_restrict_UNIV)
---
>     by (simp flip: Lebesgue_Measure.integral_restrict_UNIV)
2310c2311
<         by (meson integrable_subinterval_real \<open>\<delta> \<le> pi\<close> int atLeastatMost_subset_iff order_refl)
---
>         by (meson integrable_subinterval \<open>\<delta> \<le> pi\<close> int atLeastatMost_subset_iff order_refl)
2314c2315
<         by (rule integrable_subinterval_real [OF int0d])
---
>         by (rule integrable_subinterval [OF int0d])
2447c2448
<   by (intro absolutely_integrable_add absolutely_integrable_mult_Fejer_kernel_reflected_part1 absolutely_integrable_mult_Fejer_kernel_reflected_part2 assms)
---
>   by (intro set_integral_add absolutely_integrable_mult_Fejer_kernel_reflected_part1 absolutely_integrable_mult_Fejer_kernel_reflected_part2 assms)
2454c2455
<   by (intro absolutely_integrable_add absolutely_integrable_diff absolutely_integrable_on_const
---
>   by (intro set_integral_add set_integral_diff absolutely_integrable_on_const
2502c2503
<     using real_tendsto_mult_right_iff [OF pi_neq_zero] by simp
---
>     using tendsto_mult_right_iff [OF pi_neq_zero] by simp
2580c2581
<         by (intro absolutely_integrable_on_const absolutely_integrable_diff absolutely_integrable_add, auto simp: ftx ftmx)
---
>         by (intro absolutely_integrable_on_const set_integral_diff set_integral_add, auto simp: ftx ftmx)
2679c2680
<               apply (auto simp: \<dagger> insert_sets_lebesgue_on cong: conj_cong)
---
>               apply (auto simp: \<dagger> sets.insert_in_sets sets_restrict_space_iff cong: conj_cong)
2706a2708
> 
2711c2713
<            = (LINT x|lebesgue_on {0..\<xi>}. Fejer_kernel n x * h x) + (LINT x|lebesgue_on {\<xi>..pi}. Fejer_kernel n x * h x)"
---
>                  = (LINT x|lebesgue_on {0..\<xi>}. Fejer_kernel n x * h x) + (LINT x|lebesgue_on {\<xi>..pi}. Fejer_kernel n x * h x)"
2723c2725
< assumes f: "continuous_on UNIV f"
---
>   assumes f: "continuous_on UNIV f"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fourier/Lspace.thy ../../AFPs/afp-2020/thys/Fourier/Lspace.thy
6c6
<   imports Lp.Lp Fourier_Aux1
---
>   imports Lp.Lp 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fourier/Periodic.thy ../../AFPs/afp-2020/thys/Fourier/Periodic.thy
4c4
<   imports "HOL-Analysis.Analysis" Fourier_Aux2
---
>   imports "HOL-Analysis.Analysis" 
6a7,40
> lemma has_bochner_integral_null [intro]:
>   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
>   assumes "N \<in> null_sets lebesgue"
>   shows "has_bochner_integral (lebesgue_on N) f 0"
>   unfolding has_bochner_integral_iff
> proof
>   show "integrable (lebesgue_on N) f"
>   proof (subst integrable_restrict_space)
>     show "N \<inter> space lebesgue \<in> sets lebesgue"
>       using assms by force
>     show "integrable lebesgue (\<lambda>x. indicat_real N x *\<^sub>R f x)"
>     proof (rule integrable_cong_AE_imp)
>       show "integrable lebesgue (\<lambda>x. 0)"
>         by simp
>       show *: "AE x in lebesgue. 0 = indicat_real N x *\<^sub>R f x"
>         using assms
>         by (simp add: indicator_def completion.null_sets_iff_AE eventually_mono)
>       show "(\<lambda>x. indicat_real N x *\<^sub>R f x) \<in> borel_measurable lebesgue"
>         by (auto intro: borel_measurable_AE [OF _ *])
>     qed
>   qed
>   show "integral\<^sup>L (lebesgue_on N) f = 0"
>   proof (rule integral_eq_zero_AE)
>     show "AE x in lebesgue_on N. f x = 0"
>       by (rule AE_I' [where N=N]) (auto simp: assms null_setsD2 null_sets_restrict_space)
>   qed
> qed
> 
> lemma has_bochner_integral_null_eq[simp]:
>   fixes f :: "'a::euclidean_space \<Rightarrow> 'b::euclidean_space"
>   assumes "N \<in> null_sets lebesgue"
>   shows "has_bochner_integral (lebesgue_on N) f i \<longleftrightarrow> i = 0"
>   using assms has_bochner_integral_eq by blast
> 
70c104
<     by (meson integrable_subinterval_real f has_bochner_integral_iff)
---
>     by (meson integrable_subinterval f has_bochner_integral_iff)
76c110
<     by (meson integrable_subinterval_real f has_bochner_integral_integrable integrable.intros)
---
>     by (meson integrable_subinterval f has_bochner_integral_integrable integrable.intros)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Fourier/Square_Integrable.thy ../../AFPs/afp-2020/thys/Fourier/Square_Integrable.thy
4c4
<   imports Lspace Fourier_Aux2 
---
>   imports Lspace 
187,211d186
< lemma isCont_id [continuous_intros,iff]:
<   fixes x :: "'a::t2_space" shows "isCont id x"
<   unfolding id_def by (intro continuous_intros)
< 
< lemma continuous_floor:
<   fixes x::real
<   shows "x \<notin> \<int> \<Longrightarrow> continuous (at x) (real_of_int \<circ> floor)"
<   using floor_has_real_derivative [where f=id]
<   by (auto simp: o_def has_field_derivative_def intro: has_derivative_continuous)
< 
< lemma continuous_frac:
<   fixes x::real
<   assumes "x \<notin> \<int>"
<   shows "continuous (at x) frac"
< proof -
<   have "isCont (\<lambda>x. real_of_int \<lfloor>x\<rfloor>) x"
<     using continuous_floor [OF assms] by (simp add: o_def)
<   then have *: "continuous (at x) (\<lambda>x. x - real_of_int \<lfloor>x\<rfloor>)"
<     by (intro continuous_intros)
<   moreover have "\<forall>\<^sub>F x in nhds x. frac x = x - real_of_int \<lfloor>x\<rfloor>"
<     by (simp add: frac_def)
<   ultimately show ?thesis
<     by (simp add: LIM_imp_LIM frac_def isCont_def)
< qed
< 
612,613c587
<             apply (simp add: Norm_def)
<             by (smt enn2real_ennreal ennreal_less_iff less_top_ennreal)
---
>             by (simp add: Norm_def)
==========
Functional_Ordered_Resolution_Prover
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Functional_Ordered_Resolution_Prover/IsaFoR_Term.thy ../../AFPs/afp-2020/thys/Functional_Ordered_Resolution_Prover/IsaFoR_Term.thy
241c241
<   have "vars_clause (subst_cls C \<sigma>) \<subseteq> UNION (range \<sigma>) vars_term"
---
>   have "vars_clause (subst_cls C \<sigma>) \<subseteq> \<Union> (vars_term ` range \<sigma>)"
244c244
<   moreover have "UNION (range \<sigma>) vars_term
---
>   moreover have "\<Union> (vars_term ` range \<sigma>)
==========
Furstenberg_Topology
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Furstenberg_Topology/Furstenberg_Topology.thy ../../AFPs/afp-2020/thys/Furstenberg_Topology/Furstenberg_Topology.thy
413c413
<   Since the Frstenberg topology is $T_2$ and every arithmetic progression is also closed,
---
>   Since the Furstenberg topology is $T_2$ and every arithmetic progression is also closed,
820c820
<   We now show that the Frstenberg space is a metric space with this metric (with \<open>q = 2\<close>),
---
>   We now show that the Furstenberg space is a metric space with this metric (with \<open>q = 2\<close>),
880c880
< end
\ No newline at end of file
---
> end
==========
Gabow_SCC
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gabow_SCC/Find_Path_Impl.thy ../../AFPs/afp-2020/thys/Gabow_SCC/Find_Path_Impl.thy
274c274,280
<     fixes U0::"'a::hashable set" and P::"'a \<Rightarrow> bool" and E::"('a\<times>'a) set"
---
>     fixes U0::"'a set" and P::"'a \<Rightarrow> bool" and E::"('a\<times>'a) set"
>       and Pimpl :: "'ai \<Rightarrow> bool"
>       and node_rel :: "('ai \<times> 'a) set"
>       and node_eq_impl :: "'ai \<Rightarrow> 'ai \<Rightarrow> bool"
>       and node_hash_impl
>       and node_def_hash_size
>     
276,277c282,288
<       "(succi,E)\<in>\<langle>Id\<rangle>slg_rel"
<       "(U0',U0)\<in>\<langle>Id\<rangle>list_set_rel"
---
>       "(succi,E)\<in>\<langle>node_rel\<rangle>slg_rel"
>       "(Pimpl,P)\<in>node_rel \<rightarrow> bool_rel"
>       "(node_eq_impl, (=)) \<in> node_rel \<rightarrow> node_rel \<rightarrow> bool_rel"
>       "(U0',U0)\<in>\<langle>node_rel\<rangle>list_set_rel"
>     assumes [autoref_ga_rules]: 
>       "is_bounded_hashcode node_rel node_eq_impl node_hash_impl"  
>       "is_valid_def_hm_size TYPE('ai) node_def_hash_size"
280,281c291,292
<         R="\<langle>Id::(('a\<times>'a) set),\<langle>Id::(('a\<times>'a) set)\<rangle>list_rel\<rangle>list_map_rel"]
<       TYRELI[where R="\<langle>Id::(('a\<times>'a) set)\<rangle>map2set_rel dflt_ahm_rel"]
---
>         R="\<langle>node_rel,\<langle>node_rel\<rangle>list_rel\<rangle>list_map_rel"]
>       TYRELI[where R="\<langle>node_rel\<rangle>map2set_rel (ahm_rel node_hash_impl)"]
283,284c294,295
<     notes [autoref_rules] = 
<       IdI[of P, unfolded fun_rel_id_simp[symmetric]]
---
>     (*notes [autoref_rules] = 
>       IdI[of P, unfolded fun_rel_id_simp[symmetric]]*)
294c305,307
<   concrete_definition wset_find_path_impl for succi U0' P 
---
>   find_theorems list_map_update  
>     
>   concrete_definition wset_find_path_impl for node_eq_impl succi U0' Pimpl 
303a317,320
>       fixes node_rel :: "('ai \<times> 'a) set"
>       assumes eq: "GEN_OP node_eq_impl (=) (node_rel\<rightarrow>node_rel\<rightarrow>bool_rel)"
>       assumes hash: "SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)"
>       assumes hash_dsz: "SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)"
305c322
<         wset_find_path_impl, 
---
>         wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl, 
307,308c324,325
<         \<in> \<langle>Id\<rangle>slg_rel \<rightarrow> \<langle>Id\<rangle>list_set_rel \<rightarrow> (Id\<rightarrow>bool_rel) 
<           \<rightarrow> \<langle>\<langle>\<langle>Id\<rangle>list_rel\<times>\<^sub>rId\<rangle>option_rel\<rangle>nres_rel"
---
>         \<in> \<langle>node_rel\<rangle>slg_rel \<rightarrow> \<langle>node_rel\<rangle>list_set_rel \<rightarrow> (node_rel\<rightarrow>bool_rel) 
>           \<rightarrow> \<langle>\<langle>\<langle>node_rel\<rangle>list_rel\<times>\<^sub>rnode_rel\<rangle>option_rel\<rangle>nres_rel"
310c327,332
<       note wset_find_path_impl.refine[THEN nres_relD]
---
>       note EQI = GEN_OP_D[OF eq]
>       note HASHI = SIDE_GEN_ALGO_D[OF hash]
>       note DSZI = SIDE_GEN_ALGO_D[OF hash_dsz]
>     
>     
>       note wset_find_path_impl.refine[THEN nres_relD, OF _ _ EQI _ HASHI DSZI]
319c341
<     "RETURN ?c \<le> wset_find_path_impl E U0 P"
---
>     "RETURN ?c \<le> wset_find_path_impl hashi dszi eqi E U0 P"
347c369,375
<   shows "(?c::?'c,find_path1_gen::(_\<times>_::hashable) set \<Rightarrow> _)\<in>?R"
---
>   fixes node_rel :: "('ai \<times> 'a) set"
>   assumes [autoref_rules]: "(node_eq_impl, (=)) \<in> node_rel \<rightarrow> node_rel \<rightarrow> bool_rel"
>   assumes [autoref_ga_rules]: 
>     "is_bounded_hashcode node_rel node_eq_impl node_hash_impl"  
>     "is_valid_def_hm_size TYPE('ai) node_def_hash_size"
> 
>   shows "(?c,find_path1_gen::(_\<times>_) set \<Rightarrow> _) \<in> \<langle>node_rel\<rangle>slg_rel \<rightarrow> node_rel \<rightarrow> (node_rel \<rightarrow> bool_rel) \<rightarrow> \<langle>\<langle>\<langle>node_rel\<rangle>list_rel \<times>\<^sub>r node_rel\<rangle>option_rel\<rangle>nres_rel"
349c377
<   apply (autoref (keep_goal))
---
>   apply (autoref (trace,keep_goal))
359,366c387,406
<   "(find_path1_impl,find_path1) 
<     \<in> \<langle>Id\<rangle>slg_rel \<rightarrow>Id \<rightarrow> (Id \<rightarrow> bool_rel) \<rightarrow> 
<       \<langle>\<langle>\<langle>Id\<rangle>list_rel \<times>\<^sub>r Id\<rangle>Relators.option_rel\<rangle>nres_rel"
<   apply (rule fun_relI nres_relI)+
<   apply (rule order_trans)
<   apply (erule (2) find_path1_impl.refine[param_fo, THEN nres_relD])
<   apply (simp add: find_path1_gen_correct)
<   done
---
>   fixes node_rel :: "('ai \<times> 'a) set"
>   assumes eq: "GEN_OP node_eq_impl (=) (node_rel\<rightarrow>node_rel\<rightarrow>bool_rel)"
>   assumes hash: "SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)"
>   assumes hash_dsz: "SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)"
>   
>   shows "(find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,find_path1) 
>     \<in> \<langle>node_rel\<rangle>slg_rel \<rightarrow>node_rel \<rightarrow> (node_rel \<rightarrow> bool_rel) \<rightarrow> 
>       \<langle>\<langle>\<langle>node_rel\<rangle>list_rel \<times>\<^sub>r node_rel\<rangle>Relators.option_rel\<rangle>nres_rel"
> proof -
> 
>   note EQI = GEN_OP_D[OF eq]
>   note HASHI = SIDE_GEN_ALGO_D[OF hash]
>   note DSZI = SIDE_GEN_ALGO_D[OF hash_dsz]
>   
>   note R = find_path1_impl.refine[param_fo, THEN nres_relD, OF EQI HASHI DSZI]
>   
>   note R
>   also note find_path1_gen_correct
>   finally show ?thesis by (blast intro: nres_relI)
> qed
369c409
<   "RETURN ?c \<le> find_path1_impl E u P"
---
>   "RETURN ?c \<le> find_path1_impl eqi hashi dszi E u P"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gabow_SCC/Gabow_GBG_Code.thy ../../AFPs/afp-2020/thys/Gabow_SCC/Gabow_GBG_Code.thy
14,15c14,15
<   + fr_graph_impl_loc "\<langle>mrel,Id\<rangle>igbg_impl_rel_eext" G_impl G
<   for mrel and G_impl and G :: "('q::hashable,'more) igb_graph_rec_scheme"
---
>   + fr_graph_impl_loc "\<langle>mrel,node_rel\<rangle>igbg_impl_rel_eext" node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G
>   for mrel and node_rel and node_eq_impl node_hash_impl node_def_hash_size and G_impl and G :: "('q,'more) igb_graph_rec_scheme"
18c18
<   lemma locale_this: "impl_lasso_loc mrel G_impl G"
---
>   lemma locale_this: "impl_lasso_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"
44,45c44,45
<   abbreviation (in -) "ce_rel \<equiv> \<langle>\<langle>Id\<rangle>fun_set_rel \<times>\<^sub>r \<langle>Id\<rangle>fun_set_rel\<rangle>option_rel"
<   abbreviation "goGSi_rel \<equiv> ce_rel \<times>\<^sub>r oGSi_rel"
---
>   abbreviation (in -) "ce_rel node_rel \<equiv> \<langle>\<langle>node_rel\<rangle>fun_set_rel \<times>\<^sub>r \<langle>node_rel\<rangle>fun_set_rel\<rangle>option_rel"
>   abbreviation "goGSi_rel \<equiv> ce_rel node_rel \<times>\<^sub>r oGSi_rel"
83c83
<   schematic_goal goBrk_code_aux: "(?c,goBrk_impl)\<in>goGSi_rel\<rightarrow>ce_rel"
---
>   schematic_goal goBrk_code_aux: "(?c,goBrk_impl)\<in>goGSi_rel\<rightarrow>ce_rel node_rel"
93c93
<     "(?c,gto_outer_impl)\<in>ce_rel \<rightarrow> gGSi_rel\<rightarrow>goGSi_rel"
---
>     "(?c,gto_outer_impl)\<in>ce_rel node_rel \<rightarrow> gGSi_rel\<rightarrow>goGSi_rel"
170c170
<     \<in>gGSi_rel\<rightarrow>\<langle>ce_rel \<times>\<^sub>r gGSi_rel\<rangle>nres_rel"
---
>     \<in>gGSi_rel\<rightarrow>\<langle>ce_rel node_rel \<times>\<^sub>r gGSi_rel\<rangle>nres_rel"
205c205
<   schematic_goal find_ce_code_aux: "(?c,find_ce_impl)\<in>\<langle>ce_rel\<rangle>nres_rel"
---
>   schematic_goal find_ce_code_aux: "(?c,find_ce_impl)\<in>\<langle>ce_rel node_rel\<rangle>nres_rel"
214c214
<   schematic_goal find_ce_tr_aux: "RETURN ?c \<le> find_ce_code G_impl"
---
>   schematic_goal find_ce_tr_aux: "RETURN ?c \<le> find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl"
241c241
<     shows "(find_ce_code G_impl, find_ce_spec) \<in> \<langle>ce_rel\<rangle>nres_rel"
---
>     shows "(find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl, find_ce_spec) \<in> \<langle>ce_rel node_rel\<rangle>nres_rel"
269d268
< 
271a271
>     
291c291
<     "RETURN ?c \<le> reconstruct_lasso_code G_impl Vr Vl"
---
>     "RETURN ?c \<le> reconstruct_lasso_code eqi hi dszi G_impl Vr Vl"
310c310
<     "RETURN ?c \<le> find_lasso_code G_impl"
---
>     "RETURN ?c \<le> find_lasso_code node_eq_impl node_hash_impl node_def_hash_size G_impl"
324,325c324,325
< abbreviation fl_rel :: "(_ \<times> ('a list \<times> 'b list) option) set" where  
<   "fl_rel \<equiv> \<langle>\<langle>Id\<rangle>list_rel \<times>\<^sub>r \<langle>Id\<rangle>list_rel\<rangle>Relators.option_rel"
---
> abbreviation fl_rel :: "_ \<Rightarrow> (_ \<times> ('a list \<times> 'a list) option) set" where  
>   "fl_rel node_rel \<equiv> \<langle>\<langle>node_rel\<rangle>list_rel \<times>\<^sub>r \<langle>node_rel\<rangle>list_rel\<rangle>Relators.option_rel"
329,330c329,334
<   fixes Re
<   assumes A: "(G_impl,G)\<in>igbg_impl_rel_ext Re Id"
---
>   fixes Re and node_rel :: "('vi \<times> 'v) set"
>   assumes A: "(G_impl,G)\<in>igbg_impl_rel_ext Re node_rel"
>       and node_eq_refine: "(node_eq_impl, (=)) \<in> node_rel \<rightarrow> node_rel \<rightarrow> bool_rel"
>       and node_hash: "is_bounded_hashcode node_rel node_eq_impl node_hash_impl"
>       and node_hash_def_size: "(is_valid_def_hm_size TYPE('vi) node_def_hash_size)"
>   
332,333c336,337
<   shows "RETURN (find_lasso_tr G_impl) 
<   \<le> \<Down>fl_rel (igb_graph.find_lasso_spec G)"
---
>   shows "RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) 
>   \<le> \<Down>(fl_rel node_rel) (igb_graph.find_lasso_spec G)"
337,339c341,345
<   have I: "impl_lasso_loc Re G_impl G"
<     by unfold_locales fact
<   then interpret impl_lasso_loc Re G_impl G .
---
>   have I: "impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"
>     apply unfold_locales
>     by fact+
>     
>   then interpret impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G .
365,369c371,377
<   fixes Re
<   assumes "SIDE_PRECOND (igb_fr_graph G)"
<   assumes "PREFER_id R"
<   assumes "(G_impl,G)\<in>igbg_impl_rel_ext Re R"
<   shows "(RETURN (find_lasso_tr G_impl), 
---
>   fixes Re and node_rel :: "('vi \<times> 'v) set" 
>   assumes GR: "SIDE_PRECOND (igb_fr_graph G)"
>   assumes eq: "GEN_OP node_eq_impl (=) (node_rel\<rightarrow>node_rel\<rightarrow>bool_rel)"
>   assumes hash: "SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)"
>   assumes hash_dsz: "SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) node_def_hash_size)"
>   assumes Gi: "(G_impl,G)\<in>igbg_impl_rel_ext Re node_rel"
>   shows "(RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl), 
371,372c379,380
<       ::: igbg_impl_rel_ext Re R \<rightarrow> \<langle>fl_rel\<rangle>nres_rel)$G) \<in> \<langle>fl_rel\<rangle>nres_rel"
<   using find_lasso_tr_correct assms
---
>       ::: igbg_impl_rel_ext Re node_rel \<rightarrow> \<langle>fl_rel node_rel\<rangle>nres_rel)$G) \<in> \<langle>fl_rel node_rel\<rangle>nres_rel"
>   using find_lasso_tr_correct[OF Gi GEN_OP_D[OF eq] SIDE_GEN_ALGO_D[OF hash] SIDE_GEN_ALGO_D[OF hash_dsz]] using GR
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gabow_SCC/Gabow_SCC_Code.thy ../../AFPs/afp-2020/thys/Gabow_SCC/Gabow_SCC_Code.thy
8a9
> 
48c49
<   schematic_goal compute_SCC_tr_aux: "RETURN ?c \<le> compute_SCC_code g"
---
>   schematic_goal compute_SCC_tr_aux: "RETURN ?c \<le> compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size g"
61,63c62,69
<   fixes Re
<   fixes G :: "('a::hashable,'more) graph_rec_scheme"
<   assumes A: "(G_impl,G)\<in>\<langle>Re,Id\<rangle>g_impl_rel_ext"
---
>   fixes Re and node_rel :: "('vi \<times> 'v) set"
>   fixes G :: "('v,'more) graph_rec_scheme"
>   assumes A: 
>       "(G_impl,G)\<in>\<langle>Re,node_rel\<rangle>g_impl_rel_ext"
>       "(node_eq_impl, (=)) \<in> node_rel \<rightarrow> node_rel \<rightarrow> bool_rel"
>       "is_bounded_hashcode node_rel node_eq_impl node_hash_impl"
>       "(is_valid_def_hm_size TYPE('vi) node_def_hash_size)"
>   
65,66c71,72
<   shows "RETURN (compute_SCC_tr G_impl) 
<   \<le> \<Down>(\<langle>\<langle>Id\<rangle>list_set_rel\<rangle>list_rel) (fr_graph.compute_SCC_spec G)"
---
>   shows "RETURN (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) 
>   \<le> \<Down>(\<langle>\<langle>node_rel\<rangle>list_set_rel\<rangle>list_rel) (fr_graph.compute_SCC_spec G)"
69c75
<   have I: "fr_graph_impl_loc Re G_impl G"
---
>   have I: "fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"
71c77
<   then interpret fr_graph_impl_loc Re G_impl G .
---
>   then interpret fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G .
89c95
< definition compute_SCC_tr_nat :: "_ \<Rightarrow> nat list list"
---
> definition compute_SCC_tr_nat :: "_ \<Rightarrow> _ \<Rightarrow> _ \<Rightarrow> _ \<Rightarrow> nat list list"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gabow_SCC/Gabow_Skeleton_Code.thy ../../AFPs/afp-2020/thys/Gabow_SCC/Gabow_Skeleton_Code.thy
99c99,104
<   for mrel and G_impl and G :: "('v::hashable,'more) graph_rec_scheme"
---
>   for mrel and node_rel :: "('vi \<times> 'v) set" 
>     and node_eq_impl :: "'vi \<Rightarrow> 'vi \<Rightarrow> bool"
>     and node_hash_impl :: "nat \<Rightarrow> 'vi \<Rightarrow> nat"
>     and node_def_hash_size :: nat
>     and G_impl and G :: "('v,'more) graph_rec_scheme"
>      
101c106,109
<   assumes G_refine: "(G_impl,G)\<in>\<langle>mrel,Id\<rangle>g_impl_rel_ext"
---
>   assumes G_refine: "(G_impl,G)\<in>\<langle>mrel,node_rel\<rangle>g_impl_rel_ext"
>       and node_eq_refine: "(node_eq_impl, (=)) \<in> node_rel \<rightarrow> node_rel \<rightarrow> bool_rel"
>       and node_hash: "is_bounded_hashcode node_rel node_eq_impl node_hash_impl"
>       and node_hash_def_size: "(is_valid_def_hm_size TYPE('vi) node_def_hash_size)"
103c111
<   abbreviation "node_rel \<equiv> Id :: ('v \<times> _) set"
---
>   (*abbreviation "node_rel \<equiv> Id :: ('v \<times> _) set"*)
106c114
<   lemmas [autoref_rules] = G_refine
---
>   lemmas [autoref_rules] = G_refine node_eq_refine
108c116,119
<   lemma locale_this: "fr_graph_impl_loc mrel G_impl G"
---
>   lemmas [autoref_ga_rules] = node_hash node_hash_def_size
>   
>   
>   lemma locale_this: "fr_graph_impl_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"
111c122
<   abbreviation "oGSi_rel \<equiv> \<langle>node_rel,node_state_rel\<rangle>dflt_ahm_rel"
---
>   abbreviation "oGSi_rel \<equiv> \<langle>node_rel,node_state_rel\<rangle>(ahm_rel node_hash_impl)"
116c127
<     \<times>\<^sub>r \<langle>node_rel,node_state_rel\<rangle>dflt_ahm_rel
---
>     \<times>\<^sub>r oGSi_rel
124a136,139
> 
> thm autoref_ga_rules
> 
> 
202a218,219
>   find_theorems is_valid_def_hm_size
>   
210d226
< 
212a229,231
>     
>     
>     
213a233
>     for node_eq_impl G_impl
214a235,237
>     
>   thm   skeleton_code.refine
>     
218c241
<   schematic_goal pop_tr_aux: "RETURN ?c \<le> pop_code s"
---
>   schematic_goal pop_tr_aux: "RETURN ?c \<le> pop_code node_eq_impl node_hash_impl s"
223c246
<   schematic_goal select_edge_tr_aux: "RETURN ?c \<le> select_edge_code s"
---
>   schematic_goal select_edge_tr_aux: "RETURN ?c \<le> select_edge_code node_eq_impl s"
229c252
<   schematic_goal idx_of_tr_aux: "RETURN ?c \<le> idx_of_code v s"
---
>   schematic_goal idx_of_tr_aux: "RETURN ?c \<le> idx_of_code node_eq_impl node_hash_impl v s"
234c257
<   schematic_goal collapse_tr_aux: "RETURN ?c \<le> collapse_code v s"
---
>   schematic_goal collapse_tr_aux: "RETURN ?c \<le> collapse_code node_eq_impl node_hash_impl v s"
239c262
<   schematic_goal skeleton_tr_aux: "RETURN ?c \<le> skeleton_code g"
---
>   schematic_goal skeleton_tr_aux: "RETURN ?c \<le> skeleton_code node_hash_impl node_def_hash_size node_eq_impl g"
==========
Gauss_Jordan
Only in ../../AFPs/afp-2019/thys/Gauss_Jordan: Code_Bit.thy
Only in ../../AFPs/afp-2020/thys/Gauss_Jordan: Code_Z2.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gauss_Jordan/Examples_Gauss_Jordan_Abstract.thy ../../AFPs/afp-2020/thys/Gauss_Jordan/Examples_Gauss_Jordan_Abstract.thy
14c14
<   Code_Bit
---
>   Code_Z2
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gauss_Jordan/Examples_Gauss_Jordan_IArrays.thy ../../AFPs/afp-2020/thys/Gauss_Jordan/Examples_Gauss_Jordan_IArrays.thy
14c14
<   Code_Bit
---
>   Code_Z2
==========
Gauss_Sums
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gauss_Sums/Complex_Roots_Of_Unity.thy ../../AFPs/afp-2020/thys/Gauss_Sums/Complex_Roots_Of_Unity.thy
113c113
<   by (simp add: Complex.DeMoivre linordered_field_class.sign_simps(6) mult.commute)
---
>   by (simp add: Complex.DeMoivre mult.commute algebra_split_simps(6))
==========
Generic_Deriving
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Generic_Deriving/derive.ML ../../AFPs/afp-2020/thys/Generic_Deriving/derive.ML
21c21,22
< fun get_type_info thy tname constr_names = Symtab.lookup (Type_Data.get thy) (mk_key tname constr_names)
---
> fun get_type_info thy tname constr_names =
>   Symreltab.lookup (Type_Data.get thy) (tname, Bool.toString constr_names)
23c24
< fun get_inst_info thy classname tname = Symtab.lookup (Instance_Data.get thy) (hash_string (classname ^ tname))
---
> fun get_inst_info thy classname tname = Symreltab.lookup (Instance_Data.get thy) (classname, tname)
260,262c261,263
<           filter (fn (c,_) => 
<             (not (is_instantiated thy comb_type_name_full c)) andalso not (is_instantiated thy tname c))
<             params
---
>           params |> filter (fn (c,_) => 
>             not_instantiated thy comb_type_name_full c andalso
>             not_instantiated thy tname c)
307c308
<       if not (is_instantiated (Proof_Context.theory_of lthy) tname (fst p))
---
>       if not_instantiated (Proof_Context.theory_of lthy) tname (fst p)
812,813c813,816
<     fun add_info info thy = Type_Data.put (Symtab.update (mk_key (#tname info) (#uses_metadata info),info) (Type_Data.get thy)) thy
<     fun add_inst_info classname tname thy = Instance_Data.put (Symtab.update (hash_string (classname^tname),inst_info) (Instance_Data.get thy)) thy
---
>     fun add_info info thy =
>       Type_Data.put (Symreltab.update ((#tname info, Bool.toString (#uses_metadata info)),info) (Type_Data.get thy)) thy
>     fun add_inst_info classname tname thy =
>       Instance_Data.put (Symreltab.update ((classname, tname), inst_info) (Instance_Data.get thy)) thy
921c924
<   Instance_Data.put (Symtab.update (hash_string (classname^tname),{defs = thms}) (Instance_Data.get thy)) thy
---
>   Instance_Data.put (Symreltab.update ((classname, tname) ,{defs = thms}) (Instance_Data.get thy)) thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Generic_Deriving/derive_util.ML ../../AFPs/afp-2020/thys/Generic_Deriving/derive_util.ML
5c5
<   type rep_type_info = 
---
>   type rep_type_info =
21c21
<   
---
> 
36c36
<   type class_info = 
---
>   type class_info =
49c49
<   type instance_info = 
---
>   type instance_info =
61c61
<   val is_instantiated : theory -> string -> class -> bool
---
>   val not_instantiated : theory -> string -> class -> bool
67c67
<   val add_iso_info : thm option -> type_info -> type_info 
---
>   val add_iso_info : thm option -> type_info -> type_info
75,76d74
<   val hash_string : string -> string
<   val mk_key : string -> bool -> string
90c88
< struct   
---
> struct
92c90
< type ctr_info = (string * (string * typ list) list) list 
---
> type ctr_info = (string * (string * typ list) list) list
94c92
< type rep_type_info = 
---
> type rep_type_info =
125c123
< type class_info = 
---
> type class_info =
138c136
< type instance_info = 
---
> type instance_info =
146c144
< fun add_tvars tname tvar_names = 
---
> fun add_tvars tname tvar_names =
153c151
<       end    
---
>       end
156c154
< fun replace_tfree tfree_names replacement_name tfree = 
---
> fun replace_tfree tfree_names replacement_name tfree =
158,159c156,157
<         of SOME _ => replacement_name 
<          | NONE => tfree) 
---
>         of SOME _ => replacement_name
>          | NONE => tfree)
163c161
< fun collect_tfrees ctrs = map (fn (t,s) => (TFree (t,s),s)) 
---
> fun collect_tfrees ctrs = map (fn (t,s) => (TFree (t,s),s))
167,168c165,166
< (* Check if an instance of a type class exists *)
< fun is_instantiated thy tname class = Axclass.thynames_of_arity thy (tname,class) |> null |> not
---
> fun not_instantiated thy tname class =
>   null (Thm.thynames_of_arity thy (tname, class))
170c168
< fun combs_to_list t = 
---
> fun combs_to_list t =
180c178
<   case ts of 
---
>   case ts of
195c193
<     lthy |> 
---
>     lthy |>
200c198
< fun add_conversion_info from_info to_info (ty_info : type_info) = 
---
> fun add_conversion_info from_info to_info (ty_info : type_info) =
205,206c203,204
<    {tname = tname, uses_metadata = uses_metadata, tfrees = tfrees,  mutual_tnames = mutual_tnames, mutual_Ts = mutual_Ts, 
<     mutual_ctrs = mutual_ctrs, mutual_sels = mutual_sels, is_rec = is_rec, is_mutually_rec = is_mutually_rec, 
---
>    {tname = tname, uses_metadata = uses_metadata, tfrees = tfrees,  mutual_tnames = mutual_tnames, mutual_Ts = mutual_Ts,
>     mutual_ctrs = mutual_ctrs, mutual_sels = mutual_sels, is_rec = is_rec, is_mutually_rec = is_mutually_rec,
210c208
< fun add_iso_info iso_thm (ty_info : type_info) = 
---
> fun add_iso_info iso_thm (ty_info : type_info) =
214,215c212,213
<    {tname = tname, uses_metadata = uses_metadata, tfrees = tfrees,  mutual_tnames = mutual_tnames, mutual_Ts = mutual_Ts, 
<     mutual_ctrs = mutual_ctrs, mutual_sels = mutual_sels, is_rec = is_rec, is_mutually_rec = is_mutually_rec, 
---
>    {tname = tname, uses_metadata = uses_metadata, tfrees = tfrees,  mutual_tnames = mutual_tnames, mutual_Ts = mutual_Ts,
>     mutual_ctrs = mutual_ctrs, mutual_sels = mutual_sels, is_rec = is_rec, is_mutually_rec = is_mutually_rec,
219c217
< fun has_class_law classname thy = 
---
> fun has_class_law classname thy =
226c224
< fun 
---
> fun
233c231
< fun 
---
> fun
244,245c242,243
< fun get_superclasses class classname thy = 
< let 
---
> fun get_superclasses class classname thy =
> let
255c253
<     fun measure_tac ctxt = Function_Relation.relation_infer_tac ctxt 
---
>     fun measure_tac ctxt = Function_Relation.relation_infer_tac ctxt
262,263c260,261
< fun get_mapping_function lthy T = 
< let 
---
> fun get_mapping_function lthy T =
> let
273,275d270
< fun hash_string s = string_of_int (ATP_Util.hash_string s)
< fun mk_key tname use_metadata = hash_string (tname ^ (if use_metadata then "true" else "false"))
< 
309,310c304,305
<   type T = Derive_Util.type_info Symtab.table;
<   val empty = Symtab.empty;
---
>   type T = Derive_Util.type_info Symreltab.table;
>   val empty = Symreltab.empty;
312c307
<   fun merge data : T = Symtab.merge (K true) data;
---
>   fun merge data : T = Symreltab.merge (K true) data;
325,326c320,321
<   type T = Derive_Util.instance_info Symtab.table;
<   val empty = Symtab.empty;
---
>   type T = Derive_Util.instance_info Symreltab.table;
>   val empty = Symreltab.empty;
328c323
<   fun merge data : T = Symtab.merge (K true) data;
---
>   fun merge data : T = Symreltab.merge (K true) data;
==========
Girth_Chromatic
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Girth_Chromatic/Girth_Chromatic.thy ../../AFPs/afp-2020/thys/Girth_Chromatic/Girth_Chromatic.thy
668c668
<           using \<open>0 < \<epsilon>\<close> by (auto elim: eventually_mono simp: dist_real_def dest!: tendstoD[where e=1])
---
>           using \<open>0 < \<epsilon>\<close> by - (drule tendstoD[where e=1], auto elim: eventually_mono)
==========
Graph_Saturation
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Graph_Saturation/CombinedCorrectness.thy ../../AFPs/afp-2020/thys/Graph_Saturation/CombinedCorrectness.thy
13c13
<   \<equiv> let L = fst ` UNION Rs (edges o snd) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C;
---
>   \<equiv> let L = fst ` \<Union> ((edges o snd) ` Rs) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C;
20c20
<   \<equiv> let L = fst ` UNION Rs (edges o snd) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C \<union> fst ` edges init;
---
>   \<equiv> let L = fst ` \<Union> ((edges o snd) ` Rs) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C \<union> fst ` edges init;
34c34
<   "transl_rules T = UNION T (\<lambda> (x,y). {(translation x, translation (A_Int x y)),(translation y, translation (A_Int y x))})"
---
>   "transl_rules T = (\<Union>(x, y)\<in>T. {(translation x, translation (A_Int x y)), (translation y, translation (A_Int y x))})"
48,49c48,49
<     "L = fst ` UNION (transl_rules T) (edges \<circ> snd) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C"
<   have "finite (UNION (transl_rules T) (edges \<circ> snd))" using fin_t gr_transl_rules by auto
---
>     "L = fst ` \<Union> ((edges \<circ> snd) ` transl_rules T) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C"
>   have "finite (\<Union> ((edges \<circ> snd) ` transl_rules T))" using fin_t gr_transl_rules by auto
53c53
<   have incl_L:"fst ` UNION Rules (edges o snd) \<subseteq> L"
---
>   have incl_L:"fst ` (\<Union> ((edges o snd) ` Rules)) \<subseteq> L"
137,138c137,138
<     "L = fst ` UNION Rs (edges \<circ> snd) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C \<union> fst ` edges (fst R)"
<   have "finite (UNION (transl_rules T) (edges \<circ> snd))" using fin_t gr_transl_rules by auto
---
>     "L = fst ` (\<Union> ((edges o snd) ` Rs)) \<union> {S_Bot,S_Top,S_Idt} \<union> S_Const ` C \<union> fst ` edges (fst R)"
>   have "finite (\<Union> ((edges \<circ> snd) ` transl_rules T))" using fin_t gr_transl_rules by auto
143c143
<   have incl_L:"fst ` UNION Rules (edges o snd) \<subseteq> L" "fst ` snd init \<subseteq> L" 
---
>   have incl_L:"fst ` (\<Union> ((edges o snd) ` Rules)) \<subseteq> L" "fst ` snd init \<subseteq> L" 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Graph_Saturation/GraphRewriting.thy ../../AFPs/afp-2020/thys/Graph_Saturation/GraphRewriting.thy
498c498
<           "UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV"
---
>           "\<Union> ((edges o snd) ` Rules) \<subseteq> L \<times> UNIV"
522c522
<           "fst ` UNION Rules (edges \<circ> snd) \<subseteq> L" (is "fst `?fR \<subseteq> _")
---
>           "fst ` (\<Union> ((edges o snd) ` Rules)) \<subseteq> L" (is "fst `?fR \<subseteq> _")
528c528
<   hence "UNION Rules (edges \<circ> snd) \<subseteq> L \<times> UNIV" "edges (graph_of G) \<subseteq> L \<times> UNIV"
---
>   hence "(\<Union> ((edges o snd) ` Rules)) \<subseteq> L \<times> UNIV" "edges (graph_of G) \<subseteq> L \<times> UNIV"
==========
Green
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Green/Derivs.thy ../../AFPs/afp-2020/thys/Green/Derivs.thy
50c50
< (*move to Cauchy_Integral_Theorem*)
---
> (*move to Derivative*)
489,493c489,490
<     using Cauchy_Integral_Theorem.C1_differentiable_on_mult
<       Cauchy_Integral_Theorem.C1_differentiable_on_add
<       Cauchy_Integral_Theorem.C1_differentiable_on_const
<       Cauchy_Integral_Theorem.C1_differentiable_on_ident
<     by auto
---
>     using C1_differentiable_on_mult C1_differentiable_on_add C1_differentiable_on_const
>           C1_differentiable_on_ident by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Green/Green.thy ../../AFPs/afp-2020/thys/Green/Green.thy
454c454
<       using Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
---
>       using piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
472c472
<       using Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g1_smooth finite_vimg]
---
>       using piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g1_smooth finite_vimg]
705c705
<       using Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
---
>       using piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
1448c1448
<       using Cauchy_Integral_Theorem.piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
---
>       using piecewise_C1_differentiable_compose[OF scale_shif_pw_smth g2_smooth finite_vimg]
2004c2004
<       using sum_not_0 by blast
---
>       by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Green/Integrals.thy ../../AFPs/afp-2020/thys/Green/Integrals.thy
695c695
<         using False x by (simp add: algebra_simps integral_combine)
---
>         using False x by (simp add: algebra_simps Henstock_Kurzweil_Integration.integral_combine)
717c717
<         using True x y by (simp add: algebra_simps integral_combine)
---
>         using True x y by (simp add: algebra_simps Henstock_Kurzweil_Integration.integral_combine)
892,893c892
<       using integral_combine f(1) le
<       by (smt atLeastatMost_subset_iff integrable_subinterval_real)
---
>       by (meson Henstock_Kurzweil_Integration.integral_combine atLeastatMost_subset_iff f(1) integrable_on_subinterval le(2) order_refl)
901,902c900
<       using integral_combine f(1) le
<       by (smt atLeastatMost_subset_iff integrable_subinterval_real)
---
>       by (meson Henstock_Kurzweil_Integration.integral_combine atLeastatMost_subset_iff f(1) integrable_on_subinterval le(2) order_refl)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Green/Paths.thy ../../AFPs/afp-2020/thys/Green/Paths.thy
834c834
<         using Cauchy_Integral_Theorem.valid_path_imp_reverse
---
>         using valid_path_imp_reverse
839c839
<         using 0 1 Cauchy_Integral_Theorem.valid_path_join that(4) l_nempty by blast
---
>         using 0 1 valid_path_join that(4) l_nempty by blast
947c947
<         using Cauchy_Integral_Theorem.valid_path_imp_reverse by auto
---
>         using valid_path_imp_reverse by auto
1045c1045
<         using Cauchy_Integral_Theorem.valid_path_imp_reverse by auto
---
>         using valid_path_imp_reverse by auto
1246c1246
<         using Cauchy_Integral_Theorem.valid_path_imp_reverse ass props by auto
---
>         using valid_path_imp_reverse ass props by auto
1388c1388
<         using  reversepath_reversepath Cauchy_Integral_Theorem.valid_path_imp_reverse
---
>         using  reversepath_reversepath valid_path_imp_reverse
==========
Groebner_Macaulay
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Groebner_Macaulay/Degree_Bound_Utils.thy ../../AFPs/afp-2020/thys/Groebner_Macaulay/Degree_Bound_Utils.thy
14c14
<     (\<exists>G. punit.is_Groebner_basis G \<and> ideal G = ideal F \<and> UNION G indets \<subseteq> UNION F indets \<and>
---
>     (\<exists>G. punit.is_Groebner_basis G \<and> ideal G = ideal F \<and> (UN g:G. indets g) \<subseteq> (UN f:F. indets f) \<and>
21c21
<   assumes "punit.is_Groebner_basis G" and "ideal G = ideal F" and "UNION G indets \<subseteq> UNION F indets"
---
>   assumes "punit.is_Groebner_basis G" and "ideal G = ideal F" and "\<Union>(indets ` G) \<subseteq> \<Union>(indets ` F)"
29c29
<   obtains G where "punit.is_Groebner_basis G" and "ideal G = ideal F" and "UNION G indets \<subseteq> UNION F indets"
---
>   obtains G where "punit.is_Groebner_basis G" and "ideal G = ideal F" and "\<Union>(indets ` G) \<subseteq> \<Union>(indets ` F)"
31c31
<                           (\<forall>f. indets (q f) \<subseteq> UNION F indets \<and> poly_deg (q f * f) \<le> b \<and> (f \<notin> F' \<longrightarrow> q f = 0))"
---
>                           (\<forall>f. indets (q f) \<subseteq> \<Union>(indets ` F) \<and> poly_deg (q f * f) \<le> b \<and> (f \<notin> F' \<longrightarrow> q f = 0))"
33,34c33,34
<   let ?X = "UNION F indets"
<   from assms obtain G where "punit.is_Groebner_basis G" and "ideal G = ideal F" and "UNION G indets \<subseteq> ?X"
---
>   let ?X = "\<Union>(indets ` F)"
>   from assms obtain G where "punit.is_Groebner_basis G" and "ideal G = ideal F" and "\<Union>(indets ` G) \<subseteq> ?X"
52c52
<       let ?X = "UNION F indets"
---
>       let ?X = "\<Union>(indets ` F)"
62c62
<         from that \<open>g \<in> G\<close> have "x \<in> UNION G indets" by blast
---
>         from that \<open>g \<in> G\<close> have "x \<in> \<Union>(indets ` G)" by blast
141c141
<   let ?X = "UNION F indets"
---
>   let ?X = "\<Union>(indets ` F)"
152c152
<     and 1: "UNION G indets \<subseteq> ?X"
---
>     and 1: "\<Union>(indets ` G) \<subseteq> ?X"
162c162
<       hence "indets g \<subseteq> UNION G indets" by blast
---
>       hence "indets g \<subseteq> \<Union>(indets ` G)" by blast
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Groebner_Macaulay/Dube_Bound.thy ../../AFPs/afp-2020/thys/Groebner_Macaulay/Dube_Bound.thy
1478c1478
<   shows "poly_deg g \<le> Dube (card (UNION F indets)) (maxdeg F)"
---
>   shows "poly_deg g \<le> Dube (card (\<Union>(indets ` F))) (maxdeg F)"
1481c1481
<   from assms show "finite (UNION F indets)" by (simp add: finite_indets)
---
>   from assms show "finite (\<Union>(indets ` F))" by (simp add: finite_indets)
1483c1483
<   show "F \<subseteq> P[UNION F indets]" by (auto simp: Polys_alt)
---
>   show "F \<subseteq> P[\<Union>(indets ` F)]" by (auto simp: Polys_alt)
1487c1487
<   "finite F \<Longrightarrow> is_hom_GB_bound F (Dube (card (UNION F indets)) (maxdeg F))"
---
>   "finite F \<Longrightarrow> is_hom_GB_bound F (Dube (card (\<Union>(indets ` F))) (maxdeg F))"
1573c1573
<   shows "is_GB_cofactor_bound F (Dube (Suc (card (UNION F indets))) (maxdeg F))"
---
>   shows "is_GB_cofactor_bound F (Dube (Suc (card (\<Union>(indets ` F)))) (maxdeg F))"
1576c1576
<   from assms show "finite (UNION F indets)" by (simp add: finite_indets)
---
>   from assms show "finite (\<Union>(indets ` F))" by (simp add: finite_indets)
1578c1578
<   show "F \<subseteq> P[UNION F indets]" by (auto simp: Polys_alt)
---
>   show "F \<subseteq> P[\<Union>(indets ` F)]" by (auto simp: Polys_alt)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Groebner_Macaulay/Groebner_Macaulay_Examples.thy ../../AFPs/afp-2020/thys/Groebner_Macaulay/Groebner_Macaulay_Examples.thy
34c34
<   defines "X \<equiv> UNION (set fs) indets"
---
>   defines "X \<equiv> \<Union>(indets ` set fs)"
41c41
<   defines "X \<equiv> UNION (set fs) indets"
---
>   defines "X \<equiv> \<Union>(indets ` set fs)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Groebner_Macaulay/Groebner_Macaulay.thy ../../AFPs/afp-2020/thys/Groebner_Macaulay/Groebner_Macaulay.thy
192c192
<   shows "punit.is_Groebner_basis (set (punit.Macaulay_list (deg_shifts (UNION (set fs) indets) b fs)))"
---
>   shows "punit.is_Groebner_basis (set (punit.Macaulay_list (deg_shifts (\<Union>(indets ` (set fs))) b fs)))"
195c195
<   from finite_set show "finite (UNION (set fs) indets)" by (simp add: finite_indets)
---
>   from finite_set show "finite (\<Union>(indets ` (set fs)))" by (simp add: finite_indets)
197c197
<   show "set fs \<subseteq> P[UNION (set fs) indets]" by (auto simp: Polys_alt)
---
>   show "set fs \<subseteq> P[\<Union>(indets ` (set fs))]" by (auto simp: Polys_alt)
202c202
<   shows "1 \<in> ideal (set fs) \<longleftrightarrow> 1 \<in> set (punit.Macaulay_list (deg_shifts (UNION (set fs) indets) b fs))"
---
>   shows "1 \<in> ideal (set fs) \<longleftrightarrow> 1 \<in> set (punit.Macaulay_list (deg_shifts (\<Union>(indets ` (set fs))) b fs))"
205c205
<   from finite_set show "finite (UNION (set fs) indets)" by (simp add: finite_indets)
---
>   from finite_set show "finite (\<Union>(indets ` (set fs)))" by (simp add: finite_indets)
207c207
<   show "set fs \<subseteq> P[UNION (set fs) indets]" by (auto simp: Polys_alt)
---
>   show "set fs \<subseteq> P[\<Union>(indets ` (set fs))]" by (auto simp: Polys_alt)
==========
Gromov_Hyperbolicity
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Boundary_Extension.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Boundary_Extension.thy
409c409,410
<         unfolding B[OF fx, symmetric] apply (rule Lim_transform_eventually[rotated]) using eventually_mono[OF fu_in B] by auto
---
>         unfolding B[OF fx, symmetric] 
>         by (force intro: Lim_transform_eventually eventually_mono[OF fu_in B]) 
422c423
<         by (rule Lim_transform_eventually[OF _ L])
---
>         by (rule Lim_transform_eventually[OF L])
627c628,629
<         unfolding B[OF fx, symmetric] apply (rule Lim_transform_eventually[rotated]) using eventually_mono[OF fu_in B] by auto
---
>         unfolding B[OF fx, symmetric] 
>         by (force intro: Lim_transform_eventually eventually_mono[OF fu_in B])
639c641
<         by (rule Lim_transform_eventually[OF _ L])
---
>         by (rule Lim_transform_eventually[OF L])
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries_Classification.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Isometries_Classification.thy
389,390d388
<     have A: "eventually (\<lambda>n. additive_strength f xi - (2 * deltaG(TYPE('a))) * (1/n) = (real n * additive_strength f xi - 2 * deltaG TYPE('a)) / real n) sequentially"
<       unfolding eventually_sequentially apply (rule exI[of _ 1]) by (simp add: divide_simps)
394c392,395
<       using Lim_transform_eventually[OF A B] by simp
---
>     proof (rule Lim_transform_eventually)
>       show "eventually (\<lambda>n. additive_strength f xi - (2 * deltaG(TYPE('a))) * (1/n) = (real n * additive_strength f xi - 2 * deltaG TYPE('a)) / real n) sequentially"
>         unfolding eventually_sequentially apply (rule exI[of _ 1]) by (simp add: divide_simps)
>     qed (use B in auto)
403,404d403
<     have A: "eventually (\<lambda>n. dist x (f x) * (1/n) + additive_strength f xi + 16 * deltaG TYPE('a) * (\<lceil>log 2 n\<rceil> / n) = (dist x (f x) + real n * additive_strength f xi + real_of_int (\<lceil>log 2 (real n)\<rceil> * 16) * deltaG TYPE('a)) / real n) sequentially"
<       unfolding eventually_sequentially apply (rule exI[of _ 1]) by (simp add: algebra_simps divide_simps)
408c407,410
<       using Lim_transform_eventually[OF A B] by simp
---
>     proof (rule Lim_transform_eventually)
>       show "eventually (\<lambda>n. dist x (f x) * (1/n) + additive_strength f xi + 16 * deltaG TYPE('a) * (\<lceil>log 2 n\<rceil> / n) = (dist x (f x) + real n * additive_strength f xi + real_of_int (\<lceil>log 2 (real n)\<rceil> * 16) * deltaG TYPE('a)) / real n) sequentially"
>         unfolding eventually_sequentially apply (rule exI[of _ 1]) by (simp add: algebra_simps divide_simps)
>     qed (use B in auto)
1058,1059c1060,1063
<       unfolding ereal_minus(1)[symmetric] apply (simp only: ereal_minus_le[OF J]) apply (auto simp add: algebra_simps)
<       by (metis (no_types, hide_lams) linordered_field_class.sign_simps(1) linordered_field_class.sign_simps(3) mult_2_right plus_ereal.simps(1))
---
>       apply (simp only: ereal_minus_le [OF J] ereal_minus(1) [symmetric])
>       apply (auto simp add: algebra_simps)
>       apply (metis (no_types, hide_lams) add.assoc add.left_commute mult_2_right plus_ereal.simps(1))
>       done
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Isometries.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Isometries.thy
1043,1044c1043,1046
<     apply (rule exI[of _ "t/dist x y"]) using H apply (auto simp add: algebra_simps divide_simps)
<     by (metis add_diff_cancel_left' add_divide_distrib dist_not_less_zero dist_pos_lt divide_eq_1_iff linordered_field_class.sign_simps(29) scaleR_left.add scaleR_one)
---
>     apply (rule exI[of _ "t/dist x y"])
>     using H apply (auto simp add: algebra_simps divide_simps)
>     apply (metis add_diff_cancel_left' add_diff_eq add_divide_distrib dist_eq_0_iff scaleR_add_left vector_fraction_eq_iff)
>     done
1819c1821
<     by (metis linordered_field_class.sign_simps(24) mult_le_cancel_left1 not_less numeral_le_iff one_eq_numeral_iff order.trans semiring_norm(68))
---
>     by (simp add: algebra_simps mult_ge1_mono)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Library_Complements.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Library_Complements.thy
375,383d374
< lemma homeomorphism_cong:
<   "homeomorphism X' Y' f' g'" if "homeomorphism X Y f g"
<     "X' = X" "Y' = Y" "\<And>x. x \<in> X \<Longrightarrow> f' x = f x" "\<And>y. y \<in> Y \<Longrightarrow> g' y = g y"
<   using that by (auto simp add: homeomorphism_def)
< 
< lemma homeomorphism_empty [simp]:
<   "homeomorphism {} {} f g"
< unfolding homeomorphism_def by auto
< 
760c751
< using assms(1) assms(2) Lim_transform_eventually unfolding continuous_within assms(3) by auto
---
>   using assms continuous_within filterlim_cong by fastforce
796c787
< text \<open>The image of a ball by an affine map is still a ball, with explicit center and radius.\<close>
---
> text \<open>The image of a ball by an affine map is still a ball, with explicit center and radius. (Now unused)\<close>
836,837c827,828
< using measure_lebesgue_affine[of R x "cball 0 1"] emeasure_lebesgue_affine[of R x "cball 0 1"] assms
< unfolding affine_image_ball by (auto simp add: ennreal_power)
---
>   apply (simp add: assms content_cball)
>   by (simp add: assms emeasure_cball ennreal_mult' ennreal_power mult.commute)
880,885c871
< proof -
<   have "(INF a\<in>B. dist x a) \<le> (INF a\<in>A. dist x a)"
<     by (rule cINF_superset_mono[OF assms(2) _ assms(1)], auto)
<   then show ?thesis
<     unfolding infdist_def using assms by auto
< qed
---
>   by (simp add: assms infdist_eq_setdist setdist_subset_right)
918,922d903
< lemma continuous_on_infdist [continuous_intros]:
<   assumes "continuous_on S f"
<   shows "continuous_on S (\<lambda>x. infdist (f x) A)"
< using assms unfolding continuous_on by (auto intro: tendsto_infdist)
< 
926,929d906
< lemma infdist_point [simp]:
<   "infdist x {y} = dist x y"
< unfolding infdist_def by (metis cInf_singleton image_empty image_insert insert_not_empty)
< 
1029,1032d1005
< lemma inverse_eq_infinity_iff_eq_zero [simp]:
<   "1/(x::ereal) = \<infinity> \<longleftrightarrow> x = 0"
< by (simp add: divide_ereal_def)
< 
1064,1098d1036
< lemma ereal_distrib_left:
<   fixes a b c :: ereal
<   assumes "a \<noteq> \<infinity> \<or> b \<noteq> -\<infinity>"
<     and "a \<noteq> -\<infinity> \<or> b \<noteq> \<infinity>"
<     and "\<bar>c\<bar> \<noteq> \<infinity>"
<   shows "c * (a + b) = c * a + c * b"
< using assms
< by (cases rule: ereal3_cases[of a b c]) (simp_all add: field_simps)
< 
< lemma ereal_distrib_minus_left:
<   fixes a b c :: ereal
<   assumes "a \<noteq> \<infinity> \<or> b \<noteq> \<infinity>"
<     and "a \<noteq> -\<infinity> \<or> b \<noteq> -\<infinity>"
<     and "\<bar>c\<bar> \<noteq> \<infinity>"
<   shows "c * (a - b) = c * a - c * b"
< using assms
< by (cases rule: ereal3_cases[of a b c]) (simp_all add: field_simps)
< 
< lemma ereal_distrib_minus_right:
<   fixes a b c :: ereal
<   assumes "a \<noteq> \<infinity> \<or> b \<noteq> \<infinity>"
<     and "a \<noteq> -\<infinity> \<or> b \<noteq> -\<infinity>"
<     and "\<bar>c\<bar> \<noteq> \<infinity>"
<   shows "(a - b) * c = a * c - b * c"
< using assms
< by (cases rule: ereal3_cases[of a b c]) (simp_all add: field_simps)
< 
< text \<open>The next one is missing close to its friend \verb+Liminf_ereal_mult_right+.\<close>
< 
< lemma Liminf_ereal_mult_left:
<   assumes "F \<noteq> bot" "(c::real) \<ge> 0"
<     shows "Liminf F (\<lambda>n. ereal c * f n) = ereal c * Liminf F f"
< using Liminf_ereal_mult_right[OF assms] by (subst (1 2) mult.commute)
< 
< 
1197,1210d1134
< declare lim_1_over_n [tendsto_intros]
< declare lim_ln_over_n [tendsto_intros]
< 
< lemma lim_log_over_n [tendsto_intros]:
<   "(\<lambda>n. log k n/n) \<longlonglongrightarrow> 0"
< proof -
<   have *: "log k n/n = (1/ln k) * (ln n / n)" for n
<     unfolding log_def by auto
<   have "(\<lambda>n. (1/ln k) * (ln n / n)) \<longlonglongrightarrow> (1/ln k) * 0"
<     by (intro tendsto_intros)
<   then show ?thesis
<     unfolding * by auto
< qed
< 
1224,1228d1147
< lemma power4_eq_xxxx:
<   fixes x::"'a::monoid_mult"
<   shows "x^4 = x * x * x * x"
< by (simp add: mult.assoc power_numeral_even)
< 
1412c1331
< text \<open>We will need below to contruct finite sets of real numbers with good properties expressed
---
> text \<open>We will need below to construct finite sets of real numbers with good properties expressed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Metric_Completion.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Metric_Completion.thy
67c67
<       by (metis add.commute add.left_commute add_left_mono dist_commute dist_triangle2 dist_triangle_le linordered_field_class.sign_simps(42))
---
>       by (simp add: algebra_simps) (metis add_le_cancel_left dist_commute dist_triangle2 dist_triangle_le)
73c73
<       by (metis add.commute add.left_commute add_left_mono dist_commute dist_triangle2 dist_triangle_le linordered_field_class.sign_simps(42))
---
>       by (simp add: algebra_simps) (metis add_le_cancel_left dist_commute dist_triangle2 dist_triangle_le)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy ../../AFPs/afp-2020/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy
814c814
<       by (simp add: log2_of_power_eq)
---
>       by simp
821c821,822
<       using \<open>0 < lambda * (b - a)\<close> \<open>0 < delta\<close> by auto
---
>       using \<open>0 < lambda * (b - a)\<close> \<open>0 < delta\<close>
>       by (simp add: le_log_iff powr_realpow)
==========
Group-Ring-Module
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Group-Ring-Module/Algebra3.thy ../../AFPs/afp-2020/thys/Group-Ring-Module/Algebra3.thy
2403c2403
< apply (metis Group.d_gchainTr1 [OF Group_axioms] linorder_antisym_conv2)
---
> apply (metis Group.d_gchainTr1 [OF Group_axioms] antisym_conv2)
==========
Hermite
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hermite/Hermite.thy ../../AFPs/afp-2020/thys/Hermite/Hermite.thy
265c265
< qed (auto simp: normalize_Units normalize_mult)
---
> qed (auto simp: normalize_Units Units_def)
350,353c350,358
<   using assms unfolding ass_function_def pairwise_def
<   by (metis ass_function_0 associatedD2 div_self div_by_0 dvd_normalize_div
<             normalize_0 normalize_1 one_neq_zero r)
< 
---
> proof safe
>   assume *: "ass x div x = 0"
>   from r have **: "normalize (ass x) = normalize x"
>     by (simp add: ass_function_def)
>   from associatedD2[OF this] have "x dvd ass x"
>     by simp
>   with * ** show "x = 0"
>     by (auto simp: dvd_div_eq_0_iff)
> qed auto
==========
Hoare_Time
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hoare_Time/QuantK_Hoare.thy ../../AFPs/afp-2020/thys/Hoare_Time/QuantK_Hoare.thy
28c28
<   ("\<Turnstile>\<^sub>2\<^sub>' {(1_)}/ (_)/ {(1_)}" 50) where
---
>   ("\<Turnstile>\<^sub>2\<^sub>'' {(1_)}/ (_)/ {(1_)}" 50) where
35c35
<   hoareQ :: "qassn \<Rightarrow> com \<Rightarrow> qassn \<Rightarrow> bool" ("\<turnstile>\<^sub>2\<^sub>' ({(1_)}/ (_)/ {(1_)})" 50)
---
>   hoareQ :: "qassn \<Rightarrow> com \<Rightarrow> qassn \<Rightarrow> bool" ("\<turnstile>\<^sub>2\<^sub>'' ({(1_)}/ (_)/ {(1_)})" 50)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hoare_Time/SepLogK_Hoare.thy ../../AFPs/afp-2020/thys/Hoare_Time/SepLogK_Hoare.thy
11c11
<   ("\<Turnstile>\<^sub>3\<^sub>' {(1_)}/ (_)/ { (1_)}" 50) where
---
>   ("\<Turnstile>\<^sub>3\<^sub>'' {(1_)}/ (_)/ { (1_)}" 50) where
60c60
<   hoare3' :: "assn2 \<Rightarrow> com \<Rightarrow> assn2 \<Rightarrow> bool" ("\<turnstile>\<^sub>3\<^sub>' ({(1_)}/ (_)/ { (1_)})" 50)
---
>   hoare3' :: "assn2 \<Rightarrow> com \<Rightarrow> assn2 \<Rightarrow> bool" ("\<turnstile>\<^sub>3\<^sub>'' ({(1_)}/ (_)/ { (1_)})" 50)
850c850
< definition wp3' :: "com \<Rightarrow> assn2 \<Rightarrow> assn2" ("wp\<^sub>3\<^sub>'") where 
---
> definition wp3' :: "com \<Rightarrow> assn2 \<Rightarrow> assn2" ("wp\<^sub>3\<^sub>''") where 
==========
HOL-CSP
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/HOL-CSP/Process.thy ../../AFPs/afp-2020/thys/HOL-CSP/Process.thy
917c917
<   where   "lim_proc (X) = Abs_process (INTER X F, INTER X D)"
---
>   where   "lim_proc (X) = Abs_process (\<Inter> (F ` X), \<Inter> (D ` X))"
967c967
<   shows "is_process(INTER (range S) F,INTER (range S) D)"
---
>   shows "is_process (\<Inter> (F ` range S), \<Inter> (D ` range S))"
1069c1069
< lemma F_LUB: "chain S \<Longrightarrow> F(lim_proc(range S)) = INTER (range S) F"
---
> lemma F_LUB: "chain S \<Longrightarrow> F(lim_proc(range S)) = \<Inter> (F ` range S)"
1072c1072
< lemma D_LUB: "chain S \<Longrightarrow> D(lim_proc(range S)) = INTER (range S) D"
---
> lemma D_LUB: "chain S \<Longrightarrow> D(lim_proc(range S)) = \<Inter> (D ` range S)"
1075c1075
< lemma T_LUB: "chain S \<Longrightarrow> T(lim_proc(range S)) = INTER (range S) T"
---
> lemma T_LUB: "chain S \<Longrightarrow> T(lim_proc(range S)) = \<Inter> (T ` range S)"
1190c1190
<   have B : "D (lim_proc X) = INTER X D" by(simp add: * ** D_LUB)
---
>   have B : "D (lim_proc X) = \<Inter> (D ` X)" by(simp add: * ** D_LUB)
==========
Hybrid_Logic
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Logic/Hybrid_Logic.thy ../../AFPs/afp-2020/thys/Hybrid_Logic/Hybrid_Logic.thy
165,167d164
< definition new :: \<open>('a, 'b) fm \<Rightarrow> 'b \<Rightarrow> ('a, 'b) branch \<Rightarrow> bool\<close> where
<   \<open>new p a branch \<equiv> \<nexists>ps. (ps, a) \<in>. branch \<and> p on (ps, a)\<close>
< 
171a169,171
> definition new :: \<open>('a, 'b) fm \<Rightarrow> 'b \<Rightarrow> ('a, 'b) branch \<Rightarrow> bool\<close> where
>   \<open>new p a branch \<equiv> \<not> p at a in branch\<close>
> 
177a178
>   The number in front of the turnstile is the number of available coins to spend on GoTo.
180c181
< inductive ST :: \<open>('a, 'b) branch \<Rightarrow> bool\<close> (\<open>\<turnstile> _\<close> [50] 50) where
---
> inductive ST :: \<open>nat \<Rightarrow> ('a, 'b) branch \<Rightarrow> bool\<close> (\<open>_ \<turnstile> _\<close> [50, 50] 50) where
183c184
<    \<turnstile> branch\<close>
---
>    n \<turnstile> branch\<close>
187,188c188,189
<    \<turnstile> (p # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> (p # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
192,193c193,194
<    \<turnstile> (p # ps, a) # branch \<Longrightarrow> \<turnstile> (q # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> (p # ps, a) # branch \<Longrightarrow> Suc n \<turnstile> (q # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
197,198c198,199
<    \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
203,204c204,205
<    \<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
209,210c210,211
<    \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
214,215c215,216
<    \<turnstile> (p # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> (p # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
219,220c220,221
<    \<turnstile> ((\<^bold>\<not> p) # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> ((\<^bold>\<not> p) # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
223,224c224,225
<    \<turnstile> ([], i) # branch \<Longrightarrow>
<    \<turnstile> branch\<close>
---
>    n \<turnstile> ([], i) # branch \<Longrightarrow>
>    Suc n \<turnstile> branch\<close>
229,230c230,237
<    \<turnstile> (p # ps, a) # branch \<Longrightarrow>
<    \<turnstile> (ps, a) # branch\<close>
---
>    Suc n \<turnstile> (p # ps, a) # branch \<Longrightarrow>
>    n \<turnstile> (ps, a) # branch\<close>
> 
> abbreviation ST_ex :: \<open>('a, 'b) branch \<Rightarrow> bool\<close> (\<open>\<turnstile> _\<close> [50] 50) where
>   \<open>\<turnstile> branch \<equiv> \<exists>n. n \<turnstile> branch\<close>
> 
> lemma ST_Suc: \<open>n \<turnstile> branch \<Longrightarrow> Suc n \<turnstile> branch\<close>
>   by (induct n branch rule: ST.induct) (simp_all add: ST.intros)
237c244
<   shows \<open>\<turnstile> [([p], a)]\<close>
---
>   shows \<open>Suc n \<turnstile> [([p], a)]\<close>
241c248
<   then have ?thesis if \<open>\<turnstile> [([], i), ([p], a)]\<close>
---
>   then have ?thesis if \<open>n \<turnstile> [([], i), ([p], a)]\<close>
247c254
<   ultimately have ?thesis if \<open>\<turnstile> [([\<^bold>\<not> Nom i], i), ([p], a)]\<close>
---
>   ultimately have ?thesis if \<open>Suc n \<turnstile> [([\<^bold>\<not> Nom i], i), ([p], a)]\<close>
297c304
< lemma soundness': \<open>\<turnstile> branch \<Longrightarrow> M, g \<Turnstile>\<^sub>\<Theta> branch \<Longrightarrow> False\<close>
---
> lemma soundness': \<open>n \<turnstile> branch \<Longrightarrow> M, g \<Turnstile>\<^sub>\<Theta> branch \<Longrightarrow> False\<close>
416c423
<   assumes \<open>\<turnstile> branch\<close>
---
>   assumes \<open>n \<turnstile> branch\<close>
420c427
< corollary \<open>\<not> \<turnstile> []\<close>
---
> corollary \<open>\<not> n \<turnstile> []\<close>
424c431
<   assumes \<open>\<turnstile> [([\<^bold>\<not> p], i)]\<close> \<open>i \<notin> nominals p\<close>
---
>   assumes \<open>n \<turnstile> [([\<^bold>\<not> p], i)]\<close> \<open>i \<notin> nominals p\<close>
438a446,769
> section \<open>No Detours\<close>
> 
> text \<open>
>   We only need to spend initial coins when we apply GoTo twice in a row.
>   Otherwise another rule will have been applied in-between that justifies the GoTo.
>   Therefore by avoiding detours we can close any closeable branch starting from 1 coin.
> \<close>
> 
> primrec nonempty :: \<open>('a, 'b) block \<Rightarrow> bool\<close> where
>   \<open>nonempty (ps, i) = (ps \<noteq> [])\<close>
> 
> lemma nonempty_Suc:
>   assumes
>     \<open>n \<turnstile> (ps, a) # filter nonempty left @ right\<close>
>     \<open>q at a in (ps, a) # filter nonempty left @ right\<close> \<open>q \<noteq> Nom a\<close>
>   shows \<open>Suc n \<turnstile> filter nonempty ((ps, a) # left) @ right\<close>
> proof (cases ps)
>   case Nil
>   then have \<open>a \<in> branch_nominals (filter nonempty left @ right)\<close>
>     unfolding branch_nominals_def using assms(2-3) by fastforce
>   then show ?thesis
>     using assms(1) Nil GoTo by auto
> next
>   case Cons
>   then show ?thesis
>     using assms(1) ST_Suc by auto
> qed
> 
> lemma ST_nonempty:
>   \<open>n \<turnstile> left @ right \<Longrightarrow> Suc m \<turnstile> filter nonempty left @ right\<close>
> proof (induct n \<open>left @ right\<close> arbitrary: left right rule: ST.induct)
>   case (Close p i n)
>   have \<open>(\<^bold>\<not> p) at i in filter nonempty left @ right\<close>
>     using Close(2) by fastforce
>   moreover from this have \<open>p at i in filter nonempty left @ right\<close>
>     using Close(1) by fastforce
>   ultimately show ?case
>     using ST.Close by fast
> next
>   case (Neg p a ps branch n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> (p # ps, a) # branch\<close>
>       using Neg(4) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using Neg(1-2) ST.Neg by fast
>     then show ?thesis
>       using Nil Neg(5) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> (p # ps, a) # filter nonempty left' @ right\<close>
>       using Neg(4)[where left=\<open>_ # left'\<close>] Neg(5) by fastforce
>     moreover have *: \<open>(\<^bold>\<not> \<^bold>\<not> p) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons Neg(1, 5) by fastforce
>     moreover have \<open>new p a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons Neg(2, 5) unfolding new_def by auto
>     ultimately have \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.Neg by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>       using * nonempty_Suc by fast
>     then show ?thesis
>       using Cons Neg(5) by auto
>   qed
> next
>   case (DisP p q a ps branch n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> (p # ps, a) # branch\<close> \<open>Suc m \<turnstile> (q # ps, a) # branch\<close>
>       using DisP(5, 7) by fastforce+
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using DisP(1-3) ST.DisP by fast
>     then show ?thesis
>       using Nil DisP(8) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have
>       \<open>Suc m \<turnstile> (p # ps, a) # filter nonempty left' @ right\<close>
>       \<open>Suc m \<turnstile> (q # ps, a) # filter nonempty left' @ right\<close>
>       using DisP(5, 7)[where left=\<open>_ # left'\<close>] DisP(8) by fastforce+
>     moreover have *: \<open>(p \<^bold>\<or> q) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons DisP(1, 8) by fastforce
>     moreover have
>       \<open>new p a ((ps, a) # filter nonempty left' @ right)\<close>
>       \<open>new q a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons DisP(2-3, 8) unfolding new_def by auto
>     ultimately have \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.DisP by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>       using * nonempty_Suc by fast
>     then show ?thesis
>       using Cons DisP(8) by auto
>   qed
> next
>   case (DisN p q a ps branch n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch\<close>
>       using DisN(4) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using DisN(1-2) ST.DisN by fast
>     then show ?thesis
>       using Nil DisN(5) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # filter nonempty left' @ right\<close>
>       using DisN(4)[where left=\<open>_ # left'\<close>] DisN(5) by fastforce
>     moreover have *: \<open>(\<^bold>\<not> (p \<^bold>\<or> q)) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons DisN(1, 5) by fastforce
>     moreover consider
>       \<open>new (\<^bold>\<not> p) a ((ps, a) # filter nonempty left' @ right)\<close> |
>       \<open>new (\<^bold>\<not> q) a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons DisN(2, 5) unfolding new_def by auto
>     ultimately have \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.DisN by metis
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>       using * nonempty_Suc by fast
>     then show ?thesis
>       using Cons DisN(5) by auto
>   qed
> next
>   case (DiaP p a ps branch i n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch\<close>
>       using DiaP(6) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using DiaP(1-4) ST.DiaP by fast
>     then show ?thesis
>       using Nil DiaP(7) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # filter nonempty left' @ right\<close>
>       using DiaP(6)[where left=\<open>_ # left'\<close>] DiaP(7) by fastforce
>     moreover have *: \<open>(\<^bold>\<diamond> p) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons DiaP(1, 7) by fastforce
>     moreover have \<open>i \<notin> branch_nominals ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons DiaP(2, 7) unfolding branch_nominals_def by auto
>     moreover have \<open>\<not> witnessed p a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons DiaP(4, 7) unfolding witnessed_def by auto
>     ultimately have \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using DiaP(3) ST.DiaP by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>       using * nonempty_Suc by fast
>     then show ?thesis
>       using Cons DiaP(7) by auto
>   qed
> next
>   case (DiaN p a ps branch i n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch\<close>
>       using DiaN(5) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using DiaN(1-3) ST.DiaN by fast
>     then show ?thesis
>       using Nil DiaN(6) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # filter nonempty left' @ right\<close>
>       using DiaN(5)[where left=\<open>_ # left'\<close>] DiaN(6) by fastforce
>     moreover have *: \<open>(\<^bold>\<not> (\<^bold>\<diamond> p)) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons DiaN(1, 6) by fastforce
>     moreover have *: \<open>(\<^bold>\<diamond> Nom i) at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons DiaN(2, 6) by fastforce
>     moreover have \<open>new (\<^bold>\<not> (\<^bold>@ i p)) a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons DiaN(3, 6) unfolding new_def by auto
>     ultimately have \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.DiaN by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>       using * nonempty_Suc by fast
>     then show ?thesis
>       using Cons DiaN(6) by auto
>   qed
> next
>   case (SatP a p b ps branch n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> (p # ps, a) # branch\<close>
>       using SatP(4) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using SatP(1-2) ST.SatP by fast
>     then show ?thesis
>       using Nil SatP(5) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> (p # ps, a) # filter nonempty left' @ right\<close>
>       using SatP(4)[where left=\<open>_ # left'\<close>] SatP(5) by fastforce
>     moreover have \<open>(\<^bold>@ a p) at b in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons SatP(1, 5) by fastforce
>     moreover have \<open>new p a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons SatP(2, 5) unfolding new_def by auto
>     ultimately have *: \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.SatP by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>     proof (cases ps)
>       case Nil
>       then have \<open>a \<in> branch_nominals (filter nonempty left' @ right)\<close>
>         unfolding branch_nominals_def using SatP(1, 5) Cons by fastforce
>       then show ?thesis
>         using * Nil GoTo by fastforce
>     next
>       case Cons
>       then show ?thesis
>         using * ST_Suc by auto
>     qed
>     then show ?thesis
>       using Cons SatP(5) by auto
>   qed
> next
>   case (SatN a p b ps branch n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> p) # ps, a) # branch\<close>
>       using SatN(4) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using SatN(1-2) ST.SatN by fast
>     then show ?thesis
>       using Nil SatN(5) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> ((\<^bold>\<not> p) # ps, a) # filter nonempty left' @ right\<close>
>       using SatN(4)[where left=\<open>_ # left'\<close>] SatN(5) by fastforce
>     moreover have \<open>(\<^bold>\<not> (\<^bold>@ a p)) at b in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons SatN(1, 5) by fastforce
>     moreover have \<open>new (\<^bold>\<not> p) a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons SatN(2, 5) unfolding new_def by auto
>     ultimately have *: \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.SatN by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>     proof (cases ps)
>       case Nil
>       then have \<open>a \<in> branch_nominals (filter nonempty left' @ right)\<close>
>         unfolding branch_nominals_def using SatN(1, 5) Cons by fastforce
>       then show ?thesis
>         using * Nil GoTo by fastforce
>     next
>       case Cons
>       then show ?thesis
>         using * ST_Suc by auto
>     qed
>     then show ?thesis
>       using Cons SatN(5) by auto
>   qed
> next
>   case (GoTo i n)
>   show ?case
>     using GoTo(3)[where left=\<open>([], i) # left\<close>] by simp
> next
>   case (Nom p b ps a branch i n)
>   then show ?case
>   proof (cases left)
>     case Nil
>     then have \<open>Suc m \<turnstile> (p # ps, a) # branch\<close>
>       using Nom(6) by fastforce
>     then have \<open>m \<turnstile> (ps, a) # branch\<close>
>       using Nom(1-4) ST.Nom by fast
>     then show ?thesis
>       using Nil Nom(7) ST_Suc by auto
>   next
>     case (Cons _ left')
>     then have \<open>Suc m \<turnstile> (p # ps, a) # filter nonempty left' @ right\<close>
>       using Nom(6)[where left=\<open>_ # left'\<close>] Nom(7) by fastforce
>     moreover have
>       \<open>p at b in (ps, a) # filter nonempty left' @ right\<close>
>       \<open>Nom i at b in (ps, a) # filter nonempty left' @ right\<close>
>       \<open>Nom i at a in (ps, a) # filter nonempty left' @ right\<close>
>       using Cons Nom(1-4, 7) unfolding new_def by simp_all (metis empty_iff empty_set)+
>     moreover have \<open>new p a ((ps, a) # filter nonempty left' @ right)\<close>
>       using Cons Nom(4, 7) unfolding new_def by auto
>     ultimately have *: \<open>m \<turnstile> (ps, a) # filter nonempty left' @ right\<close>
>       using ST.Nom by fast
>     then have \<open>Suc m \<turnstile> filter nonempty ((ps, a) # left') @ right\<close>
>     proof (cases ps)
>       case Nil
>       moreover have \<open>a \<noteq> b\<close>
>         using Nom(1, 4) unfolding new_def by blast
>       ultimately have \<open>a \<in> branch_nominals (filter nonempty left' @ right)\<close>
>       proof (cases \<open>i = a\<close>)
>         case True
>         then have \<open>Nom a at b in left' @ right\<close>
>           using \<open>a \<noteq> b\<close> Nom(2, 7) Cons by auto
>         then show ?thesis
>           unfolding branch_nominals_def using \<open>a \<noteq> b\<close> by fastforce
>       next
>         case False
>         then have \<open>Nom i at a in left' @ right\<close>
>           using Nom(3, 7) Nil Cons by auto
>         then show ?thesis
>           unfolding branch_nominals_def using False by fastforce
>       qed
>       then show ?thesis
>         using * Nil GoTo by auto
>     next
>       case Cons
>       then show ?thesis
>         using * ST_Suc by auto
>     qed
>     then show ?thesis
>       using Cons Nom(7) by auto
>   qed
> qed
> 
> theorem ST_coins: \<open>n \<turnstile> branch \<Longrightarrow> Suc m \<turnstile> branch\<close>
>   using ST_nonempty[where left=\<open>[]\<close>] by auto
> 
> corollary ST_one: \<open>n \<turnstile> branch \<Longrightarrow> 1 \<turnstile> branch\<close>
>   using ST_coins by auto
> 
> subsection \<open>Free GoTo\<close>
> 
> text \<open>The above result allows us to derive a version of GoTo that works "for free."\<close>
> 
> lemma GoTo':
>   assumes \<open>Suc n \<turnstile> ([], i) # branch\<close> \<open>i \<in> branch_nominals branch\<close>
>   shows \<open>Suc n \<turnstile> branch\<close>
>   using assms GoTo ST_coins by fast
> 
1012,1013c1343,1344
<   assumes \<open>\<turnstile> branch\<close> \<open>Dup q i branch xs\<close>
<   shows \<open>\<turnstile> omit_branch xs branch\<close>
---
>   assumes \<open>n \<turnstile> branch\<close> \<open>Dup q i branch xs\<close>
>   shows \<open>n \<turnstile> omit_branch xs branch\<close>
1015,1016c1346,1347
< proof (induct branch)
<   case (Close p i' branch)
---
> proof (induct n branch)
>   case (Close p i' branch n)
1024,1025c1355,1356
<   case (Neg p a ps branch)
<   have \<open>\<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
---
>   case (Neg p a ps branch n)
>   have \<open>Suc n \<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
1030c1361
<     \<open>\<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
---
>     \<open>Suc n \<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
1039c1370
<   case (DisP p q a ps branch)
---
>   case (DisP p q a ps branch n)
1041,1042c1372,1373
<     \<open>\<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
<     \<open>\<turnstile> omit_branch xs ((q # ps, a) # branch)\<close>
---
>     \<open>Suc n \<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
>     \<open>Suc n \<turnstile> omit_branch xs ((q # ps, a) # branch)\<close>
1047,1048c1378,1379
<     \<open>\<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
<     \<open>\<turnstile> (q # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
---
>     \<open>Suc n \<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
>     \<open>Suc n \<turnstile> (q # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
1059,1060c1390,1391
<   case (DisN p q a ps branch)
<   have \<open>\<turnstile> omit_branch xs (((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch)\<close>
---
>   case (DisN p q a ps branch n)
>   have \<open>Suc n \<turnstile> omit_branch xs (((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch)\<close>
1067c1398
<     \<open>\<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # omit (proj xs (length branch)) ps, a) #
---
>     \<open>Suc n \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # omit (proj xs (length branch)) ps, a) #
1079,1080c1410,1411
<   case (DiaP p a ps branch i)
<   have \<open>\<turnstile> omit_branch xs (((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch)\<close>
---
>   case (DiaP p a ps branch i n)
>   have \<open>Suc n \<turnstile> omit_branch xs (((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch)\<close>
1087c1418
<     \<open>\<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # omit (proj xs (length branch)) ps, a) #
---
>     \<open>Suc n \<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # omit (proj xs (length branch)) ps, a) #
1099,1100c1430,1431
<   case (DiaN p a ps branch i)
<   have \<open>\<turnstile> omit_branch xs (((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch)\<close>
---
>   case (DiaN p a ps branch i n)
>   have \<open>Suc n \<turnstile> omit_branch xs (((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch)\<close>
1105c1436
<     \<open>\<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # omit (proj xs (length branch)) ps, a) #
---
>     \<open>Suc n \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # omit (proj xs (length branch)) ps, a) #
1117,1118c1448,1449
<   case (SatP a p b ps branch)
<   have \<open>\<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
---
>   case (SatP a p b ps branch n)
>   have \<open>Suc n \<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
1123c1454
<     \<open>\<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
---
>     \<open>Suc n \<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
1132,1133c1463,1464
<   case (SatN a p b ps branch)
<   have \<open>\<turnstile> omit_branch xs (((\<^bold>\<not> p) # ps, a) # branch)\<close>
---
>   case (SatN a p b ps branch n)
>   have \<open>Suc n \<turnstile> omit_branch xs (((\<^bold>\<not> p) # ps, a) # branch)\<close>
1138c1469
<     \<open>\<turnstile> ((\<^bold>\<not> p) # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
---
>     \<open>Suc n \<turnstile> ((\<^bold>\<not> p) # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
1147,1148c1478,1479
<   case (GoTo i branch)
<   then have \<open>\<turnstile> omit_branch xs (([], i) # branch)\<close>
---
>   case (GoTo i branch n)
>   then have \<open>n \<turnstile> omit_branch xs (([], i) # branch)\<close>
1150c1481
<   then have \<open>\<turnstile> ([], i) # omit_branch xs branch\<close>
---
>   then have \<open>n \<turnstile> ([], i) # omit_branch xs branch\<close>
1157,1158c1488,1489
<   case (Nom p b ps a branch i')
<   have \<open>\<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
---
>   case (Nom p b ps a branch i' n)
>   have \<open>Suc n \<turnstile> omit_branch xs ((p # ps, a) # branch)\<close>
1163c1494
<     \<open>\<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
---
>     \<open>Suc n \<turnstile> (p # omit (proj xs (length branch)) ps, a) # omit_branch xs branch\<close>
1178,1179c1509,1510
<   assumes \<open>\<turnstile> (p # ps, a) # branch\<close> \<open>\<not> new p a ((ps, a) # branch)\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
---
>   assumes \<open>n \<turnstile> (p # ps, a) # branch\<close> \<open>\<not> new p a ((ps, a) # branch)\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
1234c1565
<   then have \<open>\<turnstile> omit_branch ?xs ((p # ps, a) # branch)\<close>
---
>   then have \<open>n \<turnstile> omit_branch ?xs ((p # ps, a) # branch)\<close>
1236c1567
<   then have \<open>\<turnstile> (omit (proj ?xs (length branch)) ps, a) # omit_branch ?xs branch\<close>
---
>   then have \<open>n \<turnstile> (omit (proj ?xs (length branch)) ps, a) # omit_branch ?xs branch\<close>
1253a1585,1590
> lemma ST_add: \<open>n \<turnstile> branch \<Longrightarrow> m + n \<turnstile> branch\<close>
>   using ST_Suc by (induct m) auto
> 
> lemma ST_le: \<open>n \<turnstile> branch \<Longrightarrow> n \<le> m \<Longrightarrow> m \<turnstile> branch\<close>
>   using ST_add by (metis le_add_diff_inverse2)
> 
1257,1259c1594,1596
<     \<open>\<turnstile> (p # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms Neg Dup by metis
---
>     \<open>n \<turnstile> (p # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
>   using assms Neg Dup ST_Suc by metis
1264,1266c1601,1630
<     \<open>\<turnstile> (p # ps, a) # branch\<close> \<open>\<turnstile> (q # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms DisP Dup by metis
---
>     \<open>n \<turnstile> (p # ps, a) # branch\<close> \<open>n \<turnstile> (q # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
> proof (cases \<open>new p a ((ps, a) # branch) \<and> new q a ((ps, a) # branch)\<close>)
>   case True
>   then show ?thesis
>     using assms DisP ST_Suc by fast
> next
>   case False
>   then show ?thesis
>     using assms Dup by fast
> qed
> 
> lemma DisP'':
>   assumes
>     \<open>(p \<^bold>\<or> q) at a in (ps, a) # branch\<close>
>     \<open>n \<turnstile> (p # ps, a) # branch\<close> \<open>m \<turnstile> (q # ps, a) # branch\<close>
>   shows \<open>max n m \<turnstile> (ps, a) # branch\<close>
> proof (cases \<open>n \<le> m\<close>)
>   case True
>   then have \<open>m \<turnstile> (p # ps, a) # branch\<close>
>     using assms(2) ST_le by blast
>   then show ?thesis
>     using assms True by (simp add: DisP' max.absorb2)
> next
>   case False
>   then have \<open>n \<turnstile> (q # ps, a) # branch\<close>
>     using assms(3) ST_le by fastforce
>   then show ?thesis
>     using assms False by (simp add: DisP' max.absorb1)
> qed
1271,1274c1635,1646
<     \<open>\<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms DisN Dup
<   by (metis (no_types, lifting) list.set_intros(1-2) new_def on.simps set_ConsD)
---
>     \<open>n \<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
> proof (cases \<open>new (\<^bold>\<not> q) a ((ps, a) # branch) \<or> new (\<^bold>\<not> p) a ((ps, a) # branch)\<close>)
>   case True
>   then show ?thesis
>     using assms DisN ST_Suc by fast
> next
>   case False
>   then show ?thesis
>     using assms Dup
>     by (metis (no_types, lifting) list.set_intros(1-2) new_def on.simps set_ConsD)
> qed
1280,1282c1652,1654
<     \<open>\<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms DiaN Dup by metis
---
>     \<open>n \<turnstile> ((\<^bold>\<not> (\<^bold>@ i p)) # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
>   using assms DiaN Dup ST_Suc by fast
1287,1289c1659,1661
<     \<open>\<turnstile> (p # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms SatP Dup by metis
---
>     \<open>n \<turnstile> (p # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
>   using assms SatP Dup ST_Suc by fast
1294,1296c1666,1668
<     \<open>\<turnstile> ((\<^bold>\<not> p) # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms SatN Dup by metis
---
>     \<open>n \<turnstile> ((\<^bold>\<not> p) # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
>   using assms SatN Dup ST_Suc by fast
1303,1305c1675,1677
<     \<open>\<turnstile> (p # ps, a) # branch\<close>
<   shows \<open>\<turnstile> (ps, a) # branch\<close>
<   using assms Nom Dup by metis
---
>     \<open>n \<turnstile> (p # ps, a) # branch\<close>
>   shows \<open>n \<turnstile> (ps, a) # branch\<close>
>   using assms Nom Dup ST_Suc by fast
1384c1756,1760
< text \<open>If a branch has a closing tableau then so does any branch obtained by renaming nominals.\<close>
---
> text \<open>
>   If a branch has a closing tableau then so does any branch obtained by renaming nominals.
>   Since some formulas on the renamed branch may no longer be new, they do not contribute
>     any fuel and so we existentially quantify over the fuel needed to close the new branch.
> \<close>
1389c1765
<   shows \<open>\<turnstile> branch \<Longrightarrow> \<turnstile> sub_branch f branch\<close>
---
>   shows \<open>n \<turnstile> branch \<Longrightarrow> \<turnstile> sub_branch f branch\<close>
1399c1775
<   case (Neg p a ps branch)
---
>   case (Neg p a ps branch n)
1402,1405c1778,1783
<   moreover have \<open>sub f (\<^bold>\<not> \<^bold>\<not> p) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using Neg(1) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: Neg')
---
>   moreover have \<open>(\<^bold>\<not> \<^bold>\<not> sub f p) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using Neg(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(3))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using Neg' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1407c1785
<   case (DisP p q a ps branch)
---
>   case (DisP p q a ps branch n)
1412,1415c1790,1795
<   moreover have \<open>sub f (p \<^bold>\<or> q) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using DisP(1) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: DisP')
---
>   moreover have \<open>(sub f p \<^bold>\<or> sub f q) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DisP(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(4))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DisP'' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1417c1797
<   case (DisN p q a ps branch)
---
>   case (DisN p q a ps branch n)
1420,1423c1800,1805
<   moreover have \<open>sub f (\<^bold>\<not> (p \<^bold>\<or> q)) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using DisN(1) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: DisN')
---
>   moreover have \<open>(\<^bold>\<not> (sub f p \<^bold>\<or> sub f q)) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DisN(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(3-4))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DisN' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1425c1807
<   case (DiaP p a ps branch i)
---
>   case (DiaP p a ps branch i n)
1456c1838
<       unfolding sub_branch_def by simp
---
>       unfolding sub_branch_def by auto
1478c1860
<       using DiaP(6)[where f=\<open>?f\<close>] unfolding sub_branch_def by simp
---
>       using DiaP(6)[where f=\<open>?f\<close>] ST_Suc unfolding sub_branch_def by simp
1489c1871
<       using w ST.DiaP by fast
---
>       using w ST.DiaP ST_Suc by fast
1494c1876
<   case (DiaN p a ps branch i)
---
>   case (DiaN p a ps branch i n)
1497,1502c1879,1886
<   moreover have \<open>sub f (\<^bold>\<not> (\<^bold>\<diamond> p)) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using DiaN(1) at_in_sub_branch by fast
<   moreover have \<open>sub f (\<^bold>\<diamond> Nom i) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using DiaN(2) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: DiaN')
---
>   moreover have \<open>(\<^bold>\<not> (\<^bold>\<diamond> sub f p)) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DiaN(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(3, 5))
>   moreover have \<open>(\<^bold>\<diamond> Nom (f i)) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DiaN(2) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(2, 5))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using DiaN' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1504c1888
<   case (SatP a p b ps branch)
---
>   case (SatP a p b ps branch n)
1507,1510c1891,1896
<   moreover have \<open>sub f (\<^bold>@ a p) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using SatP(1) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: SatP')
---
>   moreover have \<open>(\<^bold>@ (f a) (sub f p)) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using SatP(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(6))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using SatP' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1512c1898
<   case (SatN a p b ps branch)
---
>   case (SatN a p b ps branch n)
1515,1518c1901,1906
<   moreover have \<open>sub f (\<^bold>\<not> (\<^bold>@ a p)) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using SatN(1) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: SatN')
---
>   moreover have \<open>(\<^bold>\<not> (\<^bold>@ (f a) (sub f p))) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using SatN(1) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(3, 6))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using SatN' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1520c1908
<   case (GoTo i branch)
---
>   case (GoTo i branch n)
1525,1526d1912
<   then have \<open>f i \<in> branch_nominals (sub_branch f branch)\<close>
<     unfolding sub_branch_def by simp
1528c1914
<     by (simp add: ST.GoTo sub_branch_def)
---
>     using ST.GoTo by fast
1530c1916
<   case (Nom p b ps a branch i)
---
>   case (Nom p b ps a branch i n)
1535,1540c1921,1928
<   moreover have \<open>sub f (Nom i) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using Nom(2) at_in_sub_branch by fast
<   moreover have \<open>sub f (Nom i) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
<     using Nom(3) at_in_sub_branch by fast
<   ultimately show ?case
<     unfolding sub_branch_def by (simp add: Nom')
---
>   moreover have \<open>Nom (f i) at f b in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using Nom(2) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(2))
>   moreover have \<open>Nom (f i) at f a in (sub_list f ps, f a) # sub_branch f branch\<close>
>     using Nom(3) at_in_sub_branch by (metis (no_types, hide_lams) sub.simps(2))
>   ultimately have \<open>\<turnstile> (sub_list f ps, f a) # sub_branch f branch\<close>
>     using Nom' by fast
>   then show ?case
>     unfolding sub_branch_def by simp
1556c1944
< lemma ST_sub_gt:
---
> corollary ST_sub_gt:
1562c1950
< lemma ST_sub_inf:
---
> corollary ST_sub_inf:
1564c1952
<   assumes \<open>infinite (UNIV :: 'c set)\<close> \<open>\<turnstile> branch\<close>
---
>   assumes \<open>infinite (UNIV :: 'c set)\<close> \<open>n \<turnstile> branch\<close>
1573c1961
< lemma ST_sub:
---
> corollary ST_sub:
1589d1976
<     \<open>\<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch\<close>
1590a1978
>     \<open>\<turnstile> ((\<^bold>@ i p) # (\<^bold>\<diamond> Nom i) # ps, a) # branch\<close>
1604c1992
<     using assms(2) ST_sub by blast
---
>     using assms(4) ST_sub by blast
1608c1996
<     using assms(1-2, 4) unfolding branch_nominals_def by fastforce+
---
>     using assms(1-3) unfolding branch_nominals_def by fastforce+
1626c2014
<     using assms DiaP by fast
---
>     using assms DiaP ST_Suc by fast
1653,1654c2041,2042
<   assumes \<open>set ps \<subseteq> set qs\<close> \<open>(qs, a) \<in>. branch\<close> \<open>\<turnstile> (ps @ ps', a) # branch\<close>
<   shows \<open>\<turnstile> (ps', a) # branch\<close>
---
>   assumes \<open>set ps \<subseteq> set qs\<close> \<open>(qs, a) \<in>. branch\<close> \<open>n \<turnstile> (ps @ ps', a) # branch\<close>
>   shows \<open>n \<turnstile> (ps', a) # branch\<close>
1675,1676c2063,2064
<     \<open>\<turnstile> (ps, a) # branch\<close>
<   shows \<open>\<turnstile> branch\<close>
---
>     \<open>n \<turnstile> (ps, a) # branch\<close>
>   shows \<open>Suc n \<turnstile> branch\<close>
1687c2075
<     then have \<open>\<turnstile> ([], a) # (qs, b) # branch\<close>
---
>     then have \<open>n \<turnstile> ([], a) # (qs, b) # branch\<close>
1691c2079
<     ultimately have \<open>\<turnstile> (qs, b) # branch\<close>
---
>     ultimately have \<open>Suc n \<turnstile> (qs, b) # branch\<close>
1699,1700c2087,2088
<   assumes \<open>\<turnstile> (ps, a) # branch\<close> \<open>(ps, a) \<in>. branch\<close>
<   shows \<open>\<turnstile> branch\<close>
---
>   assumes \<open>n \<turnstile> (ps, a) # branch\<close> \<open>(ps, a) \<in>. branch\<close>
>   shows \<open>Suc n \<turnstile> branch\<close>
1722c2110
<     \<open>\<turnstile> branch\<close> \<open>set branch \<subseteq> set branch'\<close>
---
>     \<open>n \<turnstile> branch\<close> \<open>set branch \<subseteq> set branch'\<close>
1725c2113
< proof (induct branch arbitrary: branch' rule: ST.induct)
---
> proof (induct n branch arbitrary: branch' rule: ST.induct)
1730c2118
<   case (Neg p a ps branch)
---
>   case (Neg p a ps branch n)
1748c2136
<     using DisP' by fast
---
>     using DisP'' by fast
1754c2142
<   case (DisN p q a ps branch)
---
>   case (DisN p q a ps branch n)
1766c2154
<   case (DiaP p a ps branch i)
---
>   case (DiaP p a ps branch i n)
1795c2183,2184
<     using DiaP(6) * by (simp add: subset_code(1))
---
>     using DiaP(6) *
>     by (metis (no_types, lifting) subset_code(1) insert_mono list.set(2) set_subset_Cons)
1799c2188
<     using inf DiaP(3) i by (simp add: DiaP')
---
>     using inf DiaP(3) i DiaP' by metis
1809c2198
<   case (DiaN p a ps branch i)
---
>   case (DiaN p a ps branch i n)
1823c2212
<   case (SatP a p b ps branch)
---
>   case (SatP a p b ps branch n)
1835,1836c2224,2225
<   case (SatN a p b ps branch)
<   have \<open>\<turnstile> ((\<^bold>\<not> p) # ps, a) # branch'\<close>
---
>   case (SatN a p b ps branch n)
>   have\<open>\<turnstile> ((\<^bold>\<not> p) # ps, a) # branch'\<close>
1847c2236
<   case (GoTo i branch)
---
>   case (GoTo i branch n)
1853c2242
<     using GoTo(2) by (simp add: ST.GoTo)
---
>     using GoTo(2) ST.GoTo by fast
1855c2244
<   case (Nom p b ps a branch i)
---
>   case (Nom p b ps a branch i n)
1881c2270
<     \<open>\<turnstile> (ps, a) # branch\<close> \<open>set ps \<subseteq> set ps'\<close>
---
>     \<open>n \<turnstile> (ps, a) # branch\<close> \<open>set ps \<subseteq> set ps'\<close>
1885c2274
<   case (Close p i ts ts')
---
>   case (Close p i n ts ts')
1891c2280
<   case (Neg p ps)
---
>   case (Neg p ps n)
1899c2288
<   case (DisP p q ps)
---
>   case (DisP p q ps n)
1905c2294
<     using DisP' by fast
---
>     using DisP'' by fast
1907c2296
<   case (DisN p q ps)
---
>   case (DisN p q ps n)
1915c2304
<   case (DiaP p ps i)
---
>   case (DiaP p ps i n)
1968c2357
<   case (DiaN p ps i)
---
>   case (DiaN p ps i n)
1978c2367
<   case (SatP p b ps)
---
>   case (SatP p b ps n)
1986c2375
<   case (SatN p b ps)
---
>   case (SatN p b ps n)
1994,1995c2383,2384
<   case (GoTo i ps)
<   then have \<open>\<turnstile> (ps, a) # branch\<close>
---
>   case (GoTo i n ps)
>   then have \<open>Suc n \<turnstile> (ps, a) # branch\<close>
1997c2386
<   then have \<open>\<turnstile> (ps, a) # (ps', a) # branch\<close>
---
>   then obtain m where \<open>m \<turnstile> (ps, a) # (ps', a) # branch\<close>
1999c2388
<   then show ?case
---
>   then have \<open>Suc m \<turnstile> (ps', a) # branch\<close>
2000a2390,2391
>   then show ?case
>     by blast
2030c2421
<     using that by (simp add: GoTo)
---
>     using that GoTo by fast
2036c2427
<     using that inf ST_struct[where branch'=\<open>_ # _ # _\<close>] by fastforce
---
>     using that inf ST_struct[where branch'=\<open>([p, Nom a], i) # (ps, a) # branch\<close>] by fastforce
2040c2431,2432
<     using inf assms(4) ST_struct[where branch'=\<open>_ # ([_, _], _) # _\<close>] by fastforce
---
>     using inf assms(4) ST_struct[where branch'=\<open>(p # ps, a) # ([p, Nom a], i) # branch\<close>]
>     by fastforce
2055c2447
<     using that by (simp add: GoTo)
---
>     using that GoTo by fast
2061c2453
<     using that inf ST_struct[where branch'=\<open>_ # _ # _\<close>] by fastforce
---
>     using that inf ST_struct[where branch'=\<open>([\<^bold>\<not> p, Nom a], i) # (ps, a) # branch\<close>] by fastforce
2065c2457,2458
<     using inf assms(4) ST_struct[where branch'=\<open>_ # ([_, _], _) # _\<close>] by fastforce
---
>     using inf assms(4) ST_struct[where branch'=\<open>((\<^bold>\<not> p) # ps, a) # ([\<^bold>\<not> p, Nom a], i) # branch\<close>]
>     by fastforce
2400c2793
<     \<open>\<turnstile> (ps, a) # branch\<close>
---
>     \<open>n \<turnstile> (ps, a) # branch\<close>
2405c2798
< proof (induct \<open>(ps, a) # branch\<close> arbitrary: ps a branch xs rule: ST.induct)
---
> proof (induct n \<open>(ps, a) # branch\<close> arbitrary: ps a branch xs rule: ST.induct)
2465c2858
<         using that by (simp add: GoTo)
---
>         using that GoTo by fast
2475,2479c2868,2872
<         using that by (simp add: GoTo)
<       moreover have
<         \<open>Nom j at c in ([], j) # ([\<^bold>\<not> (\<^bold>@ j (Nom k))], i') # ?branch\<close>
<         \<open>Nom k at c in ([], j) # ([\<^bold>\<not> (\<^bold>@ j (Nom k))], i') # ?branch\<close>
<         using j k by auto
---
>         using that GoTo by fast
>       moreover have \<open>Nom j at c in ([], j) # ([\<^bold>\<not> (\<^bold>@ j (Nom k))], i') # ?branch\<close>
>         using j by auto
>       moreover have \<open>Nom k at c in ([], j) # ([\<^bold>\<not> (\<^bold>@ j (Nom k))], i') # ?branch\<close>
>         using k by auto
2502c2895
<         using that by (simp add: GoTo)
---
>         using that GoTo by fast
2510c2903
<         using that j by (simp add: GoTo)
---
>         using that j GoTo by fast
2539c2932
<         using that by (simp add: GoTo)
---
>         using that GoTo by fast
2584,2585c2977,2980
<   ultimately show ?case
<     unfolding mapi_branch_def by (simp add: Neg')
---
>   ultimately have \<open>\<turnstile> (mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
>     using Neg' by fast
>   then show ?case
>     unfolding mapi_branch_def by auto
2610,2611c3005,3008
<   ultimately show ?case
<     unfolding mapi_branch_def by (simp add: DisP')
---
>   ultimately have \<open>\<turnstile> (mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
>     using DisP'' by fast
>   then show ?case
>     unfolding mapi_branch_def by auto
2634,2635c3031,3034
<   ultimately show ?case
<     unfolding mapi_branch_def by (simp add: DisN')
---
>   ultimately have \<open>\<turnstile> (mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
>     using DisN' by fast
>   then show ?case
>     unfolding mapi_branch_def by auto
2659c3058,3059
<   then have \<open>\<turnstile> ((\<^bold>@ i' p) # (\<^bold>\<diamond> Nom i') # mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
---
>   then have \<open>\<turnstile> ((\<^bold>@ i' p) # (\<^bold>\<diamond> Nom i') # mapi (?f (length branch)) ps, a) #
>       mapi_branch ?f branch\<close>
2666c3066
<     using i' DiaP(3) by (simp add: DiaP')
---
>     using i' DiaP(3) DiaP' by fast
2740c3140,3141
<     ultimately have \<open>\<turnstile> ((\<^bold>\<not> (\<^bold>@ i' p)) # mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
---
>     ultimately have \<open>\<turnstile> ((\<^bold>\<not> (\<^bold>@ i' p)) # mapi (?f (length branch)) ps, a) #
>         mapi_branch ?f branch\<close>
2778,2779c3179,3182
<   ultimately show ?case
<     unfolding mapi_branch_def by (simp add: SatP')
---
>   ultimately have \<open>\<turnstile> (mapi (?f (length branch)) ps, a) # mapi_branch ?f branch\<close>
>     using SatP' by fast
>   then show ?case
>     unfolding mapi_branch_def by simp
2866c3269
<   case (GoTo i' ps a branch)
---
>   case (GoTo i' n ps a branch)
3041c3444
<     using * by (simp add: GoTo)
---
>     using * GoTo by fast
3083a3487,3490
> abbreviation at_in' :: \<open>('a, 'b) fm \<Rightarrow> 'b \<Rightarrow> ('a, 'b) block set \<Rightarrow> bool\<close>
>   (\<open>_ at _ in'' _\<close> [51, 51, 51] 50) where
>   \<open>p at a in' branch \<equiv> \<exists>ps. (ps, a) \<in> branch \<and> p on (ps, a)\<close>
> 
3091,3115c3498,3527
<    ((\<forall>x i j. (\<exists>ps. (ps, i) \<in> H \<and> Nom j on (ps, i)) \<longrightarrow> (\<exists>qs. (qs, j) \<in> H \<and> Pro x on (qs, j)) \<longrightarrow>
<       (\<nexists>rs. (rs, i) \<in> H \<and> (\<^bold>\<not> Pro x) on (rs, i))) \<and>
<     (\<forall>a i. (\<exists>ps. (ps, i) \<in> H \<and> Nom a on (ps, i)) \<longrightarrow> (\<nexists>qs. (qs, i) \<in> H \<and> (\<^bold>\<not> Nom a) on (qs, i))) \<and>
<     (\<forall>i j. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (ps, i)) \<longrightarrow>
<       (\<nexists>qs. (qs, i) \<in> H \<and> (\<^bold>\<not> (\<^bold>\<diamond> Nom j)) on (qs, i))) \<and>
<     (\<forall>p i. i \<in> nominals p \<and> (\<exists>block \<in> H. p on block) \<longrightarrow> (\<exists>qs. (qs, i) \<in> H)) \<and>
<     (\<forall>i j. (\<exists>ps. (ps, i) \<in> H \<and> Nom j on (ps, i)) \<longrightarrow> (\<exists>qs. (qs, j) \<in> H \<and> Nom i on (qs, j))) \<and>
<     (\<forall>i j k. (\<exists>ps. (ps, i) \<in> H \<and> Nom j on (ps, i)) \<longrightarrow> (\<exists>qs. (qs, j) \<in> H \<and> Nom k on (qs, j)) \<longrightarrow>
<       (\<exists>rs. (rs, i) \<in> H \<and> Nom k on (rs, i))) \<and>
<     (\<forall>i j k. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (ps, i)) \<longrightarrow>
<       (\<exists>qs. (qs, j) \<in> H \<and> Nom k on (qs, j)) \<longrightarrow> (\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>\<diamond> Nom k) on (rs, i))) \<and>
<     (\<forall>i j k. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (ps, i)) \<longrightarrow>
<       (\<exists>qs. (qs, i) \<in> H \<and> Nom k on (qs, i)) \<longrightarrow> (\<exists>rs. (rs, k) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (rs, k))) \<and>
<     (\<forall>p q i. (\<exists>ps. (ps, i) \<in> H \<and> (p \<^bold>\<or> q) on (ps, i)) \<longrightarrow>
<       (\<exists>qs. (qs, i) \<in> H \<and> (p on (qs, i) \<or> q on (qs, i)))) \<and>
<     (\<forall>p q i. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<not> (p \<^bold>\<or> q)) on (ps, i)) \<longrightarrow>
<       (\<exists>qs. (qs, i) \<in> H \<and> (\<^bold>\<not> p) on (qs, i) \<and> (\<^bold>\<not> q) on (qs, i))) \<and>
<     (\<forall>p i. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<not> \<^bold>\<not> p) on (ps, i)) \<longrightarrow> (\<exists>qs. (qs, i) \<in> H \<and> p on (qs, i))) \<and>
<     (\<forall>p i. (\<exists>block \<in> H. (\<^bold>@ i p) on block) \<longrightarrow> (\<exists>qs. (qs, i) \<in> H \<and> p on (qs, i))) \<and>
<     (\<forall>p i. (\<exists>block \<in> H. (\<^bold>\<not> (\<^bold>@ i p)) on block) \<longrightarrow> (\<exists>qs. (qs, i) \<in> H \<and> (\<^bold>\<not> p) on (qs, i))) \<and>
<     (\<forall>p i. (\<nexists>a. p = Nom a) \<longrightarrow> (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<diamond> p) on (ps, i)) \<longrightarrow>
<       (\<exists>j. (\<exists>qs. (qs, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (qs, i)) \<and> (\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>@ j p) on (rs, i)))) \<and>
<     (\<forall>p i j. (\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<not> (\<^bold>\<diamond> p)) on (ps, i)) \<longrightarrow>
<       (\<exists>qs. (qs, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (qs, i)) \<longrightarrow>
<       (\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>\<not> (\<^bold>@ j p)) on (rs, i))))\<close>
---
>     (\<forall>x i j. Nom j at i in' H \<longrightarrow> Pro x at j in' H \<longrightarrow>
>       \<not> (\<^bold>\<not> Pro x) at i in' H) \<and>
>     (\<forall>a i. Nom a at i in' H \<longrightarrow>
>       \<not> (\<^bold>\<not> Nom a) at i in' H) \<and>
>     (\<forall>i j. (\<^bold>\<diamond> Nom j) at i in' H \<longrightarrow>
>       \<not> (\<^bold>\<not> (\<^bold>\<diamond> Nom j)) at i in' H) \<and>
>     (\<forall>p i. i \<in> nominals p \<longrightarrow> (\<exists>block \<in> H. p on block) \<longrightarrow>
>       (\<exists>ps. (ps, i) \<in> H)) \<and>
>     (\<forall>i j. Nom j at i in' H \<longrightarrow>
>       Nom i at j in' H) \<and>
>     (\<forall>i j k. Nom j at i in' H \<longrightarrow> Nom k at j in' H \<longrightarrow>
>       Nom k at i in' H) \<and>
>     (\<forall>i j k. (\<^bold>\<diamond> Nom j) at i in' H \<longrightarrow> Nom k at j in' H \<longrightarrow>
>       (\<^bold>\<diamond> Nom k) at i in' H) \<and>
>     (\<forall>i j k. (\<^bold>\<diamond> Nom j) at i in' H \<longrightarrow> Nom k at i in' H \<longrightarrow>
>       (\<^bold>\<diamond> Nom j) at k in' H) \<and>
>     (\<forall>p q i. (p \<^bold>\<or> q) at i in' H \<longrightarrow>
>       p at i in' H \<or> q at i in' H) \<and>
>     (\<forall>p q i. (\<^bold>\<not> (p \<^bold>\<or> q)) at i in' H \<longrightarrow>
>       (\<^bold>\<not> p) at i in' H \<and> (\<^bold>\<not> q) at i in' H) \<and>
>     (\<forall>p i. (\<^bold>\<not> \<^bold>\<not> p) at i in' H \<longrightarrow>
>       p at i in' H) \<and>
>     (\<forall>p i a. (\<^bold>@ i p) at a in' H \<longrightarrow>
>       p at i in' H) \<and>
>     (\<forall>p i a. (\<^bold>\<not> (\<^bold>@ i p)) at a in' H \<longrightarrow>
>       (\<^bold>\<not> p) at i in' H) \<and>
>     (\<forall>p i. (\<nexists>a. p = Nom a) \<longrightarrow> (\<^bold>\<diamond> p) at i in' H \<longrightarrow>
>       (\<exists>j. (\<^bold>\<diamond> Nom j) at i in' H \<and> (\<^bold>@ j p) at i in' H)) \<and>
>     (\<forall>p i j. (\<^bold>\<not> (\<^bold>\<diamond> p)) at i in' H \<longrightarrow> (\<^bold>\<diamond> Nom j) at i in' H \<longrightarrow>
>       (\<^bold>\<not> (\<^bold>@ j p)) at i in' H)\<close>
3124c3536
<   \<open>hequiv H i j \<equiv> \<exists>ps. (ps, i) \<in> H \<and> Nom j on (ps, i)\<close>
---
>   \<open>hequiv H i j \<equiv> Nom j at i in' H\<close>
3130c3542
<   \<open>names H \<equiv> {i |block i. (block, i) \<in> H}\<close>
---
>   \<open>names H \<equiv> {i |ps i. (ps, i) \<in> H}\<close>
3180c3592
<   \<open>assign H i \<equiv> Equiv_Relations.proj (hequiv_rel H) i\<close>
---
>   \<open>assign H i \<equiv> proj (hequiv_rel H) i\<close>
3183c3595
<   \<open>reach H is \<equiv> {assign H j |i j ps. i \<in> is \<and> (ps, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (ps, i)}\<close>
---
>   \<open>reach H is \<equiv> {assign H j |i j. i \<in> is \<and> (\<^bold>\<diamond> Nom j) at i in' H}\<close>
3186c3598
<   \<open>val H is x \<equiv> \<exists>i \<in> is. \<exists>ps. (ps, i) \<in> H \<and> Pro x on (ps, i)\<close>
---
>   \<open>val H is x \<equiv> \<exists>i \<in> is. Pro x at i in' H\<close>
3222c3634
<   assumes \<open>hintikka H\<close> \<open>(ps, i) \<in> H\<close>
---
>   assumes \<open>hintikka H\<close>
3224,3228c3636,3639
<     \<open>p on (ps, i) \<Longrightarrow> Model (reach H) (val H), assign H, assign H i \<Turnstile> p\<close>
<     \<open>(\<^bold>\<not> p) on (ps, i) \<Longrightarrow> \<not> Model (reach H) (val H), assign H, assign H i \<Turnstile> p\<close>
<   using assms(2)
< proof (induct p arbitrary: i ps)
<   fix ps i
---
>     \<open>p at i in' H \<Longrightarrow> Model (reach H) (val H), assign H, assign H i \<Turnstile> p\<close>
>     \<open>(\<^bold>\<not> p) at i in' H \<Longrightarrow> \<not> Model (reach H) (val H), assign H, assign H i \<Turnstile> p\<close>
> proof (induct p arbitrary: i)
>   fix i
3230c3641
<   assume \<open>Pro x on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>   assume \<open>Pro x at i in' H\<close>
3234c3645
<   fix ps i
---
>   fix i
3236,3238c3647,3648
<   assume \<open>(\<^bold>\<not> Pro x) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   then have \<open>\<nexists>qs. (qs, j) \<in> H \<and> Pro x on (qs, j)\<close>
<     if \<open>\<exists>ps. (ps, i) \<in> H \<and> Nom j on (ps, i)\<close> for j
---
>   assume \<open>(\<^bold>\<not> Pro x) at i in' H\<close>
>   then have \<open>\<not> Pro x at j in' H\<close> if \<open>Nom j at i in' H\<close> for j
3240c3650
<   then have \<open>\<nexists>qs. (qs, j) \<in> H \<and> Pro x on (qs, j)\<close> if \<open>hequiv H i j\<close> for j
---
>   then have \<open>\<not> Pro x at j in' H\<close> if \<open>hequiv H i j\<close> for j
3247c3657
<   fix ps i
---
>   fix i
3249c3659
<   assume \<open>Nom a on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>   assume \<open>Nom a at i in' H\<close>
3255c3665
<   fix ps i
---
>   fix i
3257,3258c3667,3668
<   assume \<open>(\<^bold>\<not> Nom a) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   then have \<open>\<nexists>qs. (qs, i) \<in> H \<and> Nom a on (qs, i)\<close>
---
>   assume \<open>(\<^bold>\<not> Nom a) at i in' H\<close>
>   then have \<open>\<not> Nom a at i in' H\<close>
3265c3675
<     using assms(1) \<open>(ps, i) \<in> H\<close> hequiv_refl' by fast
---
>     using assms(1) \<open>(\<^bold>\<not> Nom a) at i in' H\<close> hequiv_refl' by fast
3271c3681
<   fix ps i
---
>   fix i
3273c3683
<   moreover assume \<open>(\<^bold>\<not> p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>   moreover assume \<open>(\<^bold>\<not> p) at i in' H\<close>
3277c3687
<   fix ps i
---
>   fix i
3279,3280c3689,3690
<   moreover assume \<open>(\<^bold>\<not> \<^bold>\<not> p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   then have \<open>\<exists>ps. (ps, i) \<in> H \<and> p on (ps, i)\<close>
---
>   moreover assume \<open>(\<^bold>\<not> \<^bold>\<not> p) at i in' H\<close>
>   then have \<open>p at i in' H\<close>
3285c3695
<   fix ps i
---
>   fix i
3287,3288c3697,3698
<   moreover assume \<open>(p \<^bold>\<or> q) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   then have \<open>\<exists>ps. (ps, i) \<in> H \<and> (p on (ps, i) \<or> q on (ps, i))\<close>
---
>   moreover assume \<open>(p \<^bold>\<or> q) at i in' H\<close>
>   then have \<open>p at i in' H \<or> q at i in' H\<close>
3293c3703
<   fix ps i
---
>   fix i
3295,3297c3705,3707
<   moreover assume \<open>(\<^bold>\<not> (p \<^bold>\<or> q)) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   then have \<open>\<exists>ps. (ps, i) \<in> H \<and> (\<^bold>\<not> p) on (ps, i) \<and> (\<^bold>\<not> q) on (ps, i)\<close>
<     using assms(1) unfolding hintikka_def by meson
---
>   moreover assume \<open>(\<^bold>\<not> (p \<^bold>\<or> q)) at i in' H\<close>
>   then have \<open>(\<^bold>\<not> p) at i in' H\<close> \<open>(\<^bold>\<not> q) at i in' H\<close>
>     using assms(1) unfolding hintikka_def by meson+
3301c3711
<   fix ps i
---
>   fix i
3303c3713
<   moreover assume \<open>(\<^bold>\<diamond> p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>   moreover assume \<open>(\<^bold>\<diamond> p) at i in' H\<close>
3310c3720
<       using assms(1) \<open>(ps, i) \<in> H\<close> assign_refl' by fast
---
>       using assms(1) \<open>(\<^bold>\<diamond> p) at i in' H\<close> assign_refl' by fast
3316c3726
<       using \<open>(\<^bold>\<diamond> p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close> by blast
---
>       using \<open>(\<^bold>\<diamond> p) at i in' H\<close> by blast
3318,3320c3728,3730
<       using assms(1) \<open>(ps, i) \<in> H\<close> assign_refl' by fast
<     moreover have \<open>(\<^bold>\<diamond> Nom j) on (ps, i)\<close>
<       using \<open>p = Nom j\<close> \<open>(\<^bold>\<diamond> p) on (ps, i)\<close> by blast
---
>       using assms(1) \<open>(\<^bold>\<diamond> p) at i in' H\<close> assign_refl' by fast
>     moreover have \<open>(\<^bold>\<diamond> Nom j) at i in' H\<close>
>       using \<open>p = Nom j\<close> \<open>(\<^bold>\<diamond> p) at i in' H\<close> by blast
3322c3732
<       using \<open>(ps, i) \<in> H\<close> unfolding reach_def by auto
---
>       using \<open>(\<^bold>\<diamond> p) at i in' H\<close> unfolding reach_def by auto
3327,3333c3737,3739
<     then have \<open>\<exists>j.
<         (\<exists>qs. (qs, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (qs, i)) \<and>
<         (\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>@ j p) on (rs, i))\<close>
<       using assms \<open>(\<^bold>\<diamond> p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close> unfolding hintikka_def by blast
<     then obtain j qs rs where
<       qs: \<open>(qs, i) \<in> H\<close> \<open>(\<^bold>\<diamond> Nom j) on (qs, i)\<close> and
<       rs: \<open>(rs, i) \<in> H\<close> \<open>(\<^bold>@ j p) on (rs, i)\<close>
---
>     then have \<open>\<exists>j. (\<^bold>\<diamond> Nom j) at i in' H \<and> (\<^bold>@ j p) at i in' H\<close>
>       using assms \<open>(\<^bold>\<diamond> p) at i in' H\<close> unfolding hintikka_def by blast
>     then obtain j where *: \<open>(\<^bold>\<diamond> Nom j) at i in' H\<close> \<open>(\<^bold>@ j p) at i in' H\<close>
3336c3742
<     from rs have \<open>\<exists>ts. (ts, j) \<in> H \<and> p on (ts, j)\<close>
---
>     from *(2) have \<open>p at j in' H\<close>
3342c3748
<       using assms(1) assign_refl' \<open>(ps, i) \<in> H\<close> by fast
---
>       using assms(1) assign_refl' \<open>(\<^bold>\<diamond> p) at i in' H\<close> by fast
3344c3750
<       using assms(1) assign_refl' \<open>\<exists>ts. (ts, j) \<in> H \<and> p on (ts, j)\<close> by fast
---
>       using assms(1) assign_refl' \<open>p at j in' H\<close> by fast
3346c3752
<       using qs unfolding reach_def by auto
---
>       using *(1) unfolding reach_def by auto
3351c3757
<   fix ps i
---
>   fix i
3353c3759
<   assume \<open>(\<^bold>\<not> (\<^bold>\<diamond> p)) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>   assume \<open>(\<^bold>\<not> (\<^bold>\<diamond> p)) at i in' H\<close>
3357c3763
<     then obtain i' j qs where
---
>     then obtain i' j where
3359c3765
<       \<open>i' \<in> assign H i\<close> \<open>(qs, i') \<in> H\<close> \<open>(\<^bold>\<diamond> Nom j) on (qs, i')\<close>
---
>       \<open>i' \<in> assign H i\<close> \<open>(\<^bold>\<diamond> Nom j) at i' in' H\<close>
3362,3363c3768,3769
<     have \<open>\<exists>rs. (rs, i) \<in> H \<and> Nom i' on (rs, i)\<close>
<       using \<open>i' \<in> assign H i\<close> \<open>(qs, i') \<in> H\<close>
---
>     have \<open>Nom i' at i in' H\<close>
>       using \<open>i' \<in> assign H i\<close> \<open>(\<^bold>\<diamond> Nom j) at i' in' H\<close>
3365c3771
<     then have \<open>\<exists>rs. (rs, i') \<in> H \<and> Nom i on (rs, i')\<close>
---
>     then have \<open>Nom i at i' in' H\<close>
3367,3368c3773,3774
<     then have \<open>\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>\<diamond> Nom j) on (rs, i)\<close>
<       using assms(1) \<open>(\<^bold>\<diamond> Nom j) on (qs, i')\<close> \<open>(qs, i') \<in> H\<close>
---
>     then have \<open>(\<^bold>\<diamond> Nom j) at i in' H\<close>
>       using assms(1) \<open>(\<^bold>\<diamond> Nom j) at i' in' H\<close>
3370,3371c3776,3777
<     then have \<open>\<exists>rs. (rs, i) \<in> H \<and> (\<^bold>\<not> (\<^bold>@ j p)) on (rs, i)\<close>
<       using assms(1) \<open>(\<^bold>\<not> (\<^bold>\<diamond> p)) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
---
>     then have \<open>(\<^bold>\<not> (\<^bold>@ j p)) at i in' H\<close>
>       using assms(1) \<open>(\<^bold>\<not> (\<^bold>\<diamond> p)) at i in' H\<close>
3373,3376c3779,3781
<     moreover have \<open>\<exists>qs. (qs, j) \<in> H \<and> (\<^bold>\<not> p) on (qs, j)\<close>
<       if \<open>\<exists>block \<in> H. (\<^bold>\<not> (\<^bold>@ j p)) on block\<close>
<       using that assms(1) unfolding hintikka_def by meson
<     ultimately obtain rs where \<open>(rs, j) \<in> H\<close> \<open>(\<^bold>\<not> p) on (rs, j)\<close>
---
>     moreover have \<open>(\<^bold>\<not> p) at j in' H\<close> if \<open>\<exists>a. (\<^bold>\<not> (\<^bold>@ j p)) at a in' H\<close>
>       using that assms(1) unfolding hintikka_def by blast
>     ultimately have \<open>(\<^bold>\<not> p) at j in' H\<close>
3384c3789
<   fix ps i
---
>   fix i
3386,3388c3791,3792
<   assume \<open>(\<^bold>@ j p) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   moreover have \<open>\<exists>qs. (qs, j) \<in> H \<and> p on (qs, j)\<close>
<     if \<open>\<exists>block \<in> H. (\<^bold>@ j p) on block\<close>
---
>   assume \<open>(\<^bold>@ j p) at i in' H\<close>
>   moreover have \<open>p at j in' H\<close> if \<open>\<exists>a. (\<^bold>@ j p) at a in' H\<close>
3390c3794
<   ultimately obtain qs where \<open>(qs, j) \<in> H\<close> \<open>p on (qs, j)\<close>
---
>   ultimately have \<open>p at j in' H\<close>
3395c3799
<   fix ps i
---
>   fix i
3397,3399c3801,3802
<   assume \<open>(\<^bold>\<not> (\<^bold>@ j p)) on (ps, i)\<close> \<open>(ps, i) \<in> H\<close>
<   moreover have \<open>\<exists>qs. (qs, j) \<in> H \<and> (\<^bold>\<not> p) on (qs, j)\<close>
<     if \<open>\<exists>block \<in> H. (\<^bold>\<not> (\<^bold>@ j p)) on block\<close>
---
>   assume \<open>(\<^bold>\<not> (\<^bold>@ j p)) at i in' H\<close>
>   moreover have \<open>(\<^bold>\<not> p) at j in' H\<close> if \<open>\<exists>a. (\<^bold>\<not> (\<^bold>@ j p)) at a in' H\<close>
3401c3804
<   ultimately obtain qs where \<open>(qs, j) \<in> H\<close> \<open>(\<^bold>\<not> p) on (qs, j)\<close>
---
>   ultimately have \<open>(\<^bold>\<not> p) at j in' H\<close>
3455,3459c3858,3859
<       (if \<nexists>p. (\<^bold>\<diamond> p) on f n
<        then {f n} \<union> extend S f n
<        else
<         let used = (\<Union>block \<in> {f n} \<union> extend S f n. block_nominals block)
<         in {f n, witness (f n) used} \<union> extend S f n))\<close>
---
>       let used = (\<Union>block \<in> {f n} \<union> extend S f n. block_nominals block)
>       in {f n, witness (f n) used} \<union> extend S f n)\<close>
3488,3489c3888,3889
<   assume \<open>\<exists>S'. set S' \<subseteq> {(ps, a)} \<union> S \<and> \<turnstile> S'\<close>
<   then obtain S' where \<open>set S' \<subseteq> {(ps, a)} \<union> S\<close> \<open>(ps, a) \<in>. S'\<close> \<open>\<turnstile> S'\<close>
---
>   assume \<open>\<exists>S'. set S' \<subseteq> {(ps, a)} \<union> S \<and> (\<exists>n. n \<turnstile> S')\<close>
>   then obtain S' n where \<open>set S' \<subseteq> {(ps, a)} \<union> S\<close> \<open>(ps, a) \<in>. S'\<close> \<open>n \<turnstile> S'\<close>
3494c3894
<     using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>     using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
3496c3896
<     using inf ST_struct_block[where ps'=\<open>p # ps\<close>] by auto
---
>     using inf ST_struct_block[where ps'=\<open>p # ps\<close>] by fastforce
3565,3566c3965,3966
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite S\<close>
<     \<open>(ps, a) \<in> S\<close> \<open>finite used\<close> \<open>(\<Union>block \<in> S. block_nominals block) \<subseteq> used\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close>
>     \<open>(ps, a) \<in> S\<close> \<open>finite used\<close> \<open>(\<Union> (block_nominals ` S)) \<subseteq> used\<close>
3583,3584d3982
<   moreover have \<open>finite ({(ps, a)} \<union> S)\<close>
<     using \<open>finite S\<close> by simp
3631,3633c4029,4031
<       assume \<open>\<exists>S'. set S' \<subseteq> {((\<^bold>@ ?i q) # (\<^bold>\<diamond> Nom ?i) # ?tail, a)} \<union> S \<and> \<turnstile> S'\<close>
<       then obtain S' where
<         \<open>\<turnstile> S'\<close> and S':
---
>       assume \<open>\<exists>S'. set S' \<subseteq> {((\<^bold>@ ?i q) # (\<^bold>\<diamond> Nom ?i) # ?tail, a)} \<union> S \<and> (\<exists>n. n \<turnstile> S')\<close>
>       then obtain S' n where
>         \<open>n \<turnstile> S'\<close> and S':
3642c4040
<         using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>         using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
3682,3694c4080,4082
<     \<open>consistent S\<close> \<open>finite S\<close> \<open>block \<in> S\<close>
<   shows \<open>consistent ({witness block ((\<Union>block \<in> S. block_nominals block))} \<union> S)\<close>
<   using assms
< proof (induct block)
<   case (Pair ps i)
<   then have \<open>finite (\<Union>block \<in> S. block_nominals block)\<close>
<     using finite_nominals_set by blast
<   then show ?case
<     using Pair consistent_witness_list[where ps=ps] by simp
< qed
< 
< lemma finite_extend: \<open>finite S \<Longrightarrow> finite (extend S f n)\<close>
<   by (induct n) simp_all
---
>     \<open>consistent S\<close> \<open>finite (\<Union> (block_nominals ` S))\<close> \<open>block \<in> S\<close>
>   shows \<open>consistent ({witness block (\<Union> (block_nominals ` S))} \<union> S)\<close>
>   using assms consistent_witness_list by (cases block) fastforce
3698c4086,4087
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent (extend S f n)\<close> \<open>finite S\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and
>     \<open>consistent (extend S f n)\<close> \<open>finite (\<Union> (block_nominals ` extend S f n))\<close>
3703,3704c4092
<     (clear) \<open>consistent ({f n} \<union> extend S f n) \<and> (\<nexists>p. (\<^bold>\<diamond> p) on f n)\<close> |
<     (dia) \<open>consistent ({f n} \<union> extend S f n) \<and> (\<exists>p. (\<^bold>\<diamond> p) on f n)\<close>
---
>     (consistent) \<open>consistent ({f n} \<union> extend S f n)\<close>
3712,3716c4100
<     case clear
<     then show ?thesis
<       by simp
<   next
<     case dia
---
>     case consistent
3719c4103
<       using dia by simp
---
>       using consistent by simp
3722,3724c4106,4108
<       using dia by simp
<     moreover have \<open>finite ({f n} \<union> extend S f n)\<close>
<       using \<open>finite S\<close> finite_extend by blast
---
>       using consistent by simp
>     moreover have \<open>finite ((\<Union> (block_nominals ` ({f n} \<union> extend S f n))))\<close>
>       using \<open>finite (\<Union> (block_nominals ` extend S f n))\<close> finite_nominals_set by force
3733a4118,4122
> lemma finite_nominals_extend:
>   assumes \<open>finite (\<Union> (block_nominals ` S))\<close>
>   shows \<open>finite (\<Union> (block_nominals ` extend S f n))\<close>
>   using assms by (induct n) (simp_all add: finite_block_nominals)
> 
3736c4125
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite S\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite (\<Union> (block_nominals ` S))\<close>
3738c4127
<   using assms by (induct n) (simp, metis consistent_extend)
---
>   using assms by (induct n) (simp, metis consistent_extend finite_nominals_extend)
3773c4162,4163
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite S\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and
>     \<open>consistent S\<close> \<open>finite (\<Union> (block_nominals ` S))\<close>
3778,3779c4168,4169
<   then obtain S' where
<     \<open>\<turnstile> S'\<close>
---
>   then obtain S' n where
>     \<open>n \<turnstile> S'\<close>
3791c4181
<     unfolding consistent_def using \<open>\<turnstile> S'\<close> by blast
---
>     unfolding consistent_def using \<open>n \<turnstile> S'\<close> by blast
3808c4198,4199
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite S\<close> \<open>surj f\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and
>     \<open>consistent S\<close> \<open>finite (\<Union> (block_nominals ` S))\<close> \<open>surj f\<close>
3836,3839c4227,4228
<   \<open>saturated S \<equiv> \<forall>(ps, i) \<in> S. \<forall>p.
<     (\<^bold>\<diamond> p) on (ps, i) \<longrightarrow> (\<nexists>a. p = Nom a) \<longrightarrow> (\<exists>j.
<       (\<exists>qs. (qs, i) \<in> S \<and> (\<^bold>@ j p) on (qs, i)) \<and>
<       (\<exists>rs. (rs, i) \<in> S \<and> (\<^bold>\<diamond> Nom j) on (rs, i)))\<close>
---
>   \<open>saturated S \<equiv> \<forall>p i. (\<^bold>\<diamond> p) at i in' S \<longrightarrow> (\<nexists>a. p = Nom a) \<longrightarrow>
>     (\<exists>j. (\<^bold>@ j p) at i in' S \<and> (\<^bold>\<diamond> Nom j) at i in' S)\<close>
3908c4297,4298
<   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and \<open>consistent S\<close> \<open>finite S\<close> \<open>surj f\<close>
---
>   assumes inf: \<open>infinite (UNIV :: 'b set)\<close> and
>     \<open>consistent S\<close> \<open>finite (\<Union> (block_nominals ` S))\<close> \<open>surj f\<close>
3960c4350
<   then have \<open>\<not> \<turnstile> [(ps, i), (qs, j), (rs, i)]\<close>
---
>   then have \<open>\<not> n \<turnstile> [(ps, i), (qs, j), (rs, i)]\<close> for n
3962,3964c4352,4354
<   moreover have \<open>\<turnstile> [(Pro x # ps, i), (qs, j), (rs, i)]\<close>
<     using ps(2) rs(2) Close[where p=\<open>Pro x\<close> and i=i] by force
<   then have \<open>\<turnstile> [(ps, i), (qs, j), (rs, i)]\<close>
---
>   moreover have \<open>n \<turnstile> [(Pro x # ps, i), (qs, j), (rs, i)]\<close> for n
>     using ps(2) rs(2) by (meson Close list.set_intros(1) on.simps set_subset_Cons subsetD)
>   then have \<open>n \<turnstile> [(ps, i), (qs, j), (rs, i)]\<close> for n
3974c4364
<   then have \<open>\<not> \<turnstile> [(ps, i), (qs, i)]\<close>
---
>   then have \<open>\<not> n \<turnstile> [(ps, i), (qs, i)]\<close> for n
3976,3977c4366,4367
<   moreover have \<open>\<turnstile> [(ps, i), (qs, i)]\<close>
<     using ps(2) qs(2) Close[where p=\<open>Nom a\<close> and i=i] by force
---
>   moreover have \<open>n \<turnstile> [(ps, i), (qs, i)]\<close> for n
>     using ps(2) qs(2) by (meson Close list.set_intros(1) set_subset_Cons subset_code(1))
3985c4375
<   then have \<open>\<not> \<turnstile> [(ps, i), (qs, i)]\<close>
---
>   then have \<open>\<not> n \<turnstile> [(ps, i), (qs, i)]\<close> for n
3987c4377
<   moreover have \<open>\<turnstile> [(ps, i), (qs, i)]\<close>
---
>   moreover have \<open>n \<turnstile> [(ps, i), (qs, i)]\<close> for n
3997,3999c4387,4390
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([], i)} \<union> S\<close> and \<open>([], i) \<in>. S'\<close>
<       using \<open>maximal S\<close> unfolding maximal_def consistent_def by fast
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([], i)} \<union> S\<close> and \<open>([], i) \<in>. S'\<close>
>       using \<open>maximal S\<close> unfolding maximal_def consistent_def
>       by (metis insert_is_Un subset_insert)
4004c4395
<       using inf ST_struct[where branch'=\<open>([], i) # (ps, a) # _\<close>] \<open>\<turnstile> S'\<close> by auto
---
>       using inf ST_struct[where branch'=\<open>([], i) # (ps, a) # S''\<close>] \<open>n \<turnstile> S'\<close> by fastforce
4008c4399
<       by (simp add: GoTo)
---
>       using GoTo by fast
4020,4021c4411,4412
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([Nom i], j)} \<union> S\<close> and \<open>([Nom i], j) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([Nom i], j)} \<union> S\<close> and \<open>([Nom i], j) \<in>. S'\<close>
4028,4029c4419
<       using inf ST_struct[where branch'=\<open>([Nom i], j) # (ps, i) # _\<close>] \<open>\<turnstile> S'\<close>
<       by auto
---
>       using inf ST_struct[where branch'=\<open>([Nom i], j) # (ps, i) # S''\<close>] \<open>n \<turnstile> S'\<close> by fastforce
4031,4032c4421
<       using \<open>Nom j on (ps, i)\<close>
<       by (meson Nom' list.set_intros(1) list.set_intros(2) on.simps)
---
>       using \<open>Nom j on (ps, i)\<close> by (meson Nom' list.set_intros(1) list.set_intros(2) on.simps)
4036c4425
<       by (simp add: GoTo)
---
>       using GoTo by fast
4050,4051c4439,4440
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([Nom k], i)} \<union> S\<close> and \<open>([Nom k], i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([Nom k], i)} \<union> S\<close> and \<open>([Nom k], i) \<in>. S'\<close>
4058,4059c4447,4448
<       using inf ST_struct[where branch'=\<open>([Nom k], i) # (Nom k # ps, i) # (qs, j) # _\<close>] \<open>\<turnstile> S'\<close>
<       by auto
---
>       using inf ST_struct[where branch'=\<open>([Nom k], i) # (Nom k # ps, i) # (qs, j) # S''\<close>] \<open>n \<turnstile> S'\<close>
>       by fastforce
4065c4454
<       by (simp add: GoTo)
---
>       using GoTo by fast
4081,4082c4470,4471
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<diamond> Nom k], i)} \<union> S\<close> and \<open>([\<^bold>\<diamond> Nom k], i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<diamond> Nom k], i)} \<union> S\<close> and \<open>([\<^bold>\<diamond> Nom k], i) \<in>. S'\<close>
4089,4090c4478,4479
<       using inf ST_struct[where branch'=\<open>([\<^bold>\<diamond> Nom k], i) # (ps, i) # (qs, j) # S''\<close>] \<open>\<turnstile> S'\<close>
<       by auto
---
>       using inf ST_struct[where branch'=\<open>([\<^bold>\<diamond> Nom k], i) # (ps, i) # (qs, j) # S''\<close>] \<open>n \<turnstile> S'\<close>
>       by fastforce
4092c4481
<       using ps qs inf by (meson Bridge list.set_intros(1) on.simps set_subset_Cons subset_iff)
---
>       using ps(2) qs(2) inf by (meson Bridge list.set_intros(1) on.simps set_subset_Cons subset_iff)
4096c4485
<       by (simp add: GoTo)
---
>       using GoTo by fast
4110,4111c4499,4500
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<diamond> Nom j], k)} \<union> S\<close> and \<open>([\<^bold>\<diamond> Nom j], k) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<diamond> Nom j], k)} \<union> S\<close> and \<open>([\<^bold>\<diamond> Nom j], k) \<in>. S'\<close>
4118,4119c4507,4508
<       using inf ST_struct[where branch'=\<open>([\<^bold>\<diamond> Nom j], k) # (Nom k # ps, i) # (qs, i) # S''\<close>] \<open>\<turnstile> S'\<close>
<       by auto
---
>       using inf ST_struct[where branch'=\<open>([\<^bold>\<diamond> Nom j], k) # (Nom k # ps, i) # (qs, i) # S''\<close>] \<open>n \<turnstile> S'\<close>
>       by fastforce
4121c4510
<       using ps by (meson Nom' fm.simps(22) list.set_intros(1-2) on.simps)
---
>       using ps(2) by (meson Nom' fm.simps(22) list.set_intros(1-2) on.simps)
4125c4514
<       by (simp add: GoTo)
---
>       using GoTo by fast
4127c4516
<       using ps qs by (meson Nom' list.set_intros(1-2) on.simps)
---
>       using ps(2) qs(2) by (meson Nom' list.set_intros(1-2) on.simps)
4135,4136c4524,4525
<   assume ps: \<open>(ps, i) \<in> S\<close> \<open>(p \<^bold>\<or> q) on (ps, i)\<close>
<   show \<open>\<exists>qs. (qs, i) \<in> S \<and> (p on (qs, i) \<or> q on (qs, i))\<close>
---
>   assume ps: \<open>(ps, i) \<in> S\<close> \<open>(p \<^bold>\<or> q) on (ps, i)\<close> and *: \<open>\<not> q at i in' S\<close>
>   show \<open>p at i in' S\<close>
4138,4140c4527,4529
<     assume *: \<open>\<nexists>qs. (qs, i) \<in> S \<and> (p on (qs, i) \<or> q on (qs, i))\<close>
<     then obtain Sp' where
<       \<open>\<turnstile> Sp'\<close> and Sp': \<open>set Sp' \<subseteq> {(p # ps, i)} \<union> S\<close> and \<open>(p # ps, i) \<in>. Sp'\<close>
---
>     assume \<open>\<not> p at i in' S\<close>
>     then obtain Sp' np where
>       \<open>np \<turnstile> Sp'\<close> and Sp': \<open>set Sp' \<subseteq> {(p # ps, i)} \<union> S\<close> and \<open>(p # ps, i) \<in>. Sp'\<close>
4147c4536
<       using \<open>\<turnstile> Sp'\<close> inf ST_struct by blast
---
>       using \<open>np \<turnstile> Sp'\<close> inf ST_struct by blast
4149,4150c4538,4539
<     obtain Sq' where
<       \<open>\<turnstile> Sq'\<close> and Sq': \<open>set Sq' \<subseteq> {(q # ps, i)} \<union> S\<close> and \<open>(q # ps, i) \<in>. Sq'\<close>
---
>     obtain Sq' nq where
>       \<open>nq \<turnstile> Sq'\<close> and Sq': \<open>set Sq' \<subseteq> {(q # ps, i)} \<union> S\<close> and \<open>(q # ps, i) \<in>. Sq'\<close>
4157c4546
<       using \<open>\<turnstile> Sq'\<close> inf ST_struct by blast
---
>       using \<open>nq \<turnstile> Sq'\<close> inf ST_struct by blast
4168c4557
<       using ps by (meson DisP' list.set_intros(1))
---
>       using ps by (meson DisP'' list.set_intros(1))
4177c4566
<   show \<open>\<exists>qs. (qs, i) \<in> S \<and> (\<^bold>\<not> p) on (qs, i) \<and> (\<^bold>\<not> q) on (qs, i)\<close>
---
>   show \<open>(\<^bold>\<not> p) at i in' S\<close>
4179c4568,4594
<     assume \<open>\<nexists>qs. (qs, i) \<in> S \<and> (\<^bold>\<not> p) on (qs, i) \<and> (\<^bold>\<not> q) on (qs, i)\<close>
---
>     assume \<open>\<not> (\<^bold>\<not> p) at i in' S\<close>
>     then obtain S' where
>       \<open>\<turnstile> S'\<close> and
>       S': \<open>set S' \<subseteq> {((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i)} \<union> S\<close> and
>       \<open>((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i) \<in>. S'\<close>
>       using \<open>maximal S\<close> unfolding maximal_def consistent_def
>       by (metis (mono_tags, lifting) insert_is_Un insert_subset list.simps(15) on.simps
>           set_subset_Cons subset_insert)
>     then obtain S'' where S'':
>       \<open>set (((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i) # S'') = set S'\<close>
>       \<open>((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i) \<notin> set S''\<close>
>       using split_list[where x=\<open>((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i)\<close>] by blast
>     then have \<open>\<turnstile> ((\<^bold>\<not> q) # (\<^bold>\<not> p) # ps, i) # S''\<close>
>       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
>     then have \<open>\<turnstile> (ps, i) # S''\<close>
>       using ps by (meson DisN' list.set_intros(1))
>     moreover have \<open>set ((ps, i) # S'') \<subseteq> S\<close>
>       using S' S'' ps by auto
>     ultimately show False
>       using \<open>consistent S\<close> unfolding consistent_def by blast
>   qed
> next
>   fix p q i ps
>   assume ps: \<open>(ps, i) \<in> S\<close> \<open>(\<^bold>\<not> (p \<^bold>\<or> q)) on (ps, i)\<close>
>   show \<open>(\<^bold>\<not> q) at i in' S\<close>
>   proof (rule ccontr)
>     assume \<open>\<not> (\<^bold>\<not> q) at i in' S\<close>
4206,4207c4621,4622
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {(p # ps, i)} \<union> S\<close> and \<open>(p # ps, i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {(p # ps, i)} \<union> S\<close> and \<open>(p # ps, i) \<in>. S'\<close>
4214c4629
<       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>       using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
4228,4229c4643,4644
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([p], i)} \<union> S\<close> and \<open>([p], i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([p], i)} \<union> S\<close> and \<open>([p], i) \<in>. S'\<close>
4236c4651
<       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>       using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
4240c4655
<       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>       using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
4246c4661
<       by (simp add: GoTo)
---
>       using GoTo by fast
4258,4259c4673,4674
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<not> p], i)} \<union> S\<close> and \<open>([\<^bold>\<not> p], i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n \<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<not> p], i)} \<union> S\<close> and \<open>([\<^bold>\<not> p], i) \<in>. S'\<close>
4266c4681
<       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>       using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
4268c4683
<       using inf ST_struct[where branch'=\<open>([\<^bold>\<not> p], i) # _ # S''\<close>] \<open>\<turnstile> S'\<close>
---
>       using inf ST_struct[where branch'=\<open>([\<^bold>\<not> p], i) # _ # S''\<close>] \<open>n \<turnstile> S'\<close>
4275c4690
<       by (simp add: GoTo)
---
>       using GoTo by fast
4298,4299c4713,4714
<     then obtain S' where
<       \<open>\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<not> (\<^bold>@ j p)], i)} \<union> S\<close> and \<open>([\<^bold>\<not> (\<^bold>@ j p)], i) \<in>. S'\<close>
---
>     then obtain S' n where
>       \<open>n\<turnstile> S'\<close> and S': \<open>set S' \<subseteq> {([\<^bold>\<not> (\<^bold>@ j p)], i)} \<union> S\<close> and \<open>([\<^bold>\<not> (\<^bold>@ j p)], i) \<in>. S'\<close>
4306c4721
<       using inf ST_struct \<open>\<turnstile> S'\<close> by blast
---
>       using inf ST_struct \<open>n \<turnstile> S'\<close> by blast
4308c4723
<       using inf ST_struct[where branch'=\<open>([_], _) # (ps, i) # (qs, i) # S''\<close>] \<open>\<turnstile> S'\<close>
---
>       using inf ST_struct[where branch'=\<open>([_], _) # (ps, i) # (qs, i) # S''\<close>] \<open>n \<turnstile> S'\<close>
4311c4726
<       using ps qs by (meson DiaN' list.set_intros(1) set_subset_Cons subset_iff)
---
>       using ps(2) qs(2) by (meson DiaN' list.set_intros(1) set_subset_Cons subset_iff)
4315c4730
<       by (simp add: GoTo)
---
>       using GoTo by fast
4330,4353c4745,4778
<   shows \<open>\<turnstile> [([\<^bold>\<not> p], i)]\<close>
< proof (rule ccontr)
<   assume \<open>\<not> \<turnstile> [([\<^bold>\<not> p], i)]\<close>
<   then have *: \<open>consistent {([\<^bold>\<not> p], i)}\<close>
<     unfolding consistent_def using ST_struct inf by fastforce
< 
<   let ?S = \<open>Extend {([\<^bold>\<not> p], i)} from_nat\<close>
< 
<   have \<open>consistent ?S\<close>
<     using consistent_Extend inf * by blast
<   moreover have \<open>maximal ?S\<close>
<     using maximal_Extend inf * by fastforce
<   moreover have \<open>saturated ?S\<close>
<     using saturated_Extend inf * by fastforce
<   ultimately have \<open>hintikka ?S\<close>
<     using hintikka_Extend inf by blast
<   moreover have \<open>([\<^bold>\<not> p], i) \<in> ?S\<close>
<     using Extend_mem by blast
<   moreover have \<open>(\<^bold>\<not> p) on ([\<^bold>\<not> p], i)\<close>
<     by simp
<   ultimately have \<open>\<not> Model (reach ?S) (val ?S), assign ?S, assign ?S i \<Turnstile> p\<close>
<     using hintikka_model by fast
<   then show False
<     using valid by blast
---
>   shows \<open>1 \<turnstile> [([\<^bold>\<not> p], i)]\<close>
> proof -
>   have \<open>\<turnstile> [([\<^bold>\<not> p], i)]\<close>
>   proof (rule ccontr)
>     assume \<open>\<not> \<turnstile> [([\<^bold>\<not> p], i)]\<close>
>     then have *: \<open>consistent {([\<^bold>\<not> p], i)}\<close>
>       unfolding consistent_def using ST_struct inf
>       by (metis empty_set list.simps(15))
> 
>     let ?S = \<open>Extend {([\<^bold>\<not> p], i)} from_nat\<close>
>     have \<open>finite {([\<^bold>\<not> p], i)}\<close>
>       by simp
>     then have fin: \<open>finite (\<Union> (block_nominals ` {([\<^bold>\<not> p], i)}))\<close>
>       using finite_nominals_set by blast
> 
>     have \<open>consistent ?S\<close>
>       using consistent_Extend inf * fin by blast
>     moreover have \<open>maximal ?S\<close>
>       using maximal_Extend inf * fin by fastforce
>     moreover have \<open>saturated ?S\<close>
>       using saturated_Extend inf * fin by fastforce
>     ultimately have \<open>hintikka ?S\<close>
>       using hintikka_Extend inf by blast
>     moreover have \<open>([\<^bold>\<not> p], i) \<in> ?S\<close>
>       using Extend_mem by blast
>     moreover have \<open>(\<^bold>\<not> p) on ([\<^bold>\<not> p], i)\<close>
>       by simp
>     ultimately have \<open>\<not> Model (reach ?S) (val ?S), assign ?S, assign ?S i \<Turnstile> p\<close>
>       using hintikka_model by fast
>     then show False
>       using valid by blast
>   qed
>   then show ?thesis
>     using ST_one by blast
4370c4795
<   shows \<open>valid p \<longleftrightarrow> \<turnstile> [([\<^bold>\<not> p], i)]\<close>
---
>   shows \<open>valid p \<longleftrightarrow> 1 \<turnstile> [([\<^bold>\<not> p], i)]\<close>
4373c4798
<   then show \<open>\<turnstile> [([\<^bold>\<not> p], i)]\<close>
---
>   then show \<open>1 \<turnstile> [([\<^bold>\<not> p], i)]\<close>
4376c4801
<   assume \<open>\<turnstile> [([\<^bold>\<not> p], i)]\<close>
---
>   assume \<open>1 \<turnstile> [([\<^bold>\<not> p], i)]\<close>
==========
Hybrid_Systems_VCs
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/HS_ODEs.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/HS_ODEs.thy
192a193,257
> lemma diff_invariant_nleq_rule:
>   fixes \<mu>::"'a::banach \<Rightarrow> real"
>   shows "diff_invariant (\<lambda>s. \<not> \<nu> s \<le> \<mu> s) f T S t\<^sub>0 G \<longleftrightarrow> diff_invariant (\<lambda>s. \<nu> s > \<mu> s) f T S t\<^sub>0 G"
>   unfolding diff_invariant_eq apply safe
>   by (clarsimp, erule_tac x=s in allE, simp, erule_tac x=X in ballE, force, force)+
> 
> lemma diff_invariant_neq_rule [diff_invariant_rules]:
>   fixes \<mu>::"'a::banach \<Rightarrow> real"
>   assumes "diff_invariant (\<lambda>s. \<nu> s < \<mu> s) f T S t\<^sub>0 G"
>     and "diff_invariant (\<lambda>s. \<nu> s > \<mu> s) f T S t\<^sub>0 G"
>   shows "diff_invariant (\<lambda>s. \<nu> s \<noteq> \<mu> s) f T S t\<^sub>0 G"
> proof(unfold diff_invariant_eq, clarsimp)
>   fix s::'a and X::"real \<Rightarrow> 'a" and t::real
>   assume "\<nu> s \<noteq> \<mu> s" and Xhyp: "X \<in> Sols (\<lambda>t. f) T S t\<^sub>0 s" 
>      and thyp: "t \<in> T" and Ghyp: "\<forall>\<tau>. \<tau> \<in> T \<and> \<tau> \<le> t \<longrightarrow> G (X \<tau>)"
>   hence "\<nu> s < \<mu> s \<or> \<nu> s > \<mu> s"
>     by linarith
>   moreover have "\<nu> s < \<mu> s \<Longrightarrow> \<nu> (X t) < \<mu> (X t)"
>     using assms(1) Xhyp thyp Ghyp unfolding diff_invariant_eq by auto
>   moreover have "\<nu> s > \<mu> s \<Longrightarrow> \<nu> (X t) > \<mu> (X t)"
>     using assms(2) Xhyp thyp Ghyp unfolding diff_invariant_eq by auto
>   ultimately show "\<nu> (X t) = \<mu> (X t) \<Longrightarrow> False"
>     by auto
> qed
> 
> lemma diff_invariant_neq_rule_converse:
>   fixes \<mu>::"'a::banach \<Rightarrow> real"
>   assumes Thyp: "is_interval T" "t\<^sub>0 \<in> T" "\<forall>t\<in>T. t\<^sub>0 \<le> t"
>       and conts: "\<forall>X. (D X = (\<lambda>\<tau>. f (X \<tau>)) on T) \<longrightarrow> 
>   continuous_on (\<P> X T) \<nu> \<and> continuous_on (\<P> X T) \<mu>"
>       and dIhyp:"diff_invariant (\<lambda>s. \<nu> s \<noteq> \<mu> s) f T S t\<^sub>0 G"
>     shows "diff_invariant (\<lambda>s. \<nu> s < \<mu> s) f T S t\<^sub>0 G"
> proof(unfold diff_invariant_eq, clarsimp)
>   fix s::'a and X::"real \<Rightarrow> 'a" and t::real
>   assume ineq0: "\<nu> s < \<mu> s" and Xhyp: "X \<in> Sols (\<lambda>t. f) T S t\<^sub>0 s"
>     and Ghyp: "\<forall>\<tau>. \<tau> \<in> T \<and> \<tau> \<le> t \<longrightarrow> G (X \<tau>)" and thyp: "t\<in>T"
>   hence ineq1: "\<nu> (X t\<^sub>0) < \<mu> (X t\<^sub>0)"
>     by (auto simp: ivp_solsD)
>   have "t\<^sub>0 \<le> t" and "\<mu> (X t) \<noteq> \<nu> (X t)"
>     using \<open>t \<in> T\<close> Thyp dIhyp thyp Xhyp Ghyp ineq0 
>     unfolding diff_invariant_eq by force+
>   moreover
>   {assume ineq2:"\<nu> (X t) > \<mu> (X t)"
>     note continuous_on_compose[OF vderiv_on_continuous_on[OF ivp_solsD(1)[OF Xhyp]]]
>     hence "continuous_on T (\<nu> \<circ> X)" and "continuous_on T (\<mu> \<circ> X)"
>       using ivp_solsD(1)[OF Xhyp] conts by auto
>     also have "{t\<^sub>0--t} \<subseteq> T"
>       using Thyp thyp by (simp add: closed_segment_subset_interval)
>     ultimately have "continuous_on {t\<^sub>0--t} (\<lambda>\<tau>. \<nu> (X \<tau>))" 
>       and "continuous_on {t\<^sub>0--t} (\<lambda>\<tau>. \<mu> (X \<tau>))"
>       using continuous_on_subset by auto
>     then obtain \<tau> where "\<tau> \<in> {t\<^sub>0--t}" "\<mu> (X \<tau>) = \<nu> (X \<tau>)"
>       using IVT_two_functions_real_ivl[OF _ _ ineq1 ineq2] by force
>     hence "\<forall>r\<in>down T \<tau>. G (X r)" and "\<tau> \<in> T"
>       using Ghyp \<open>\<tau> \<in> {t\<^sub>0--t}\<close> \<open>t\<^sub>0 \<le> t\<close> \<open>{t\<^sub>0--t} \<subseteq> T\<close> 
>       by (auto simp: closed_segment_eq_real_ivl)
>     hence "\<mu> (X \<tau>) \<noteq> \<nu> (X \<tau>)"
>       using dIhyp Xhyp \<open>\<nu> s < \<mu> s\<close> 
>       unfolding diff_invariant_eq by force
>     hence "False"
>       using \<open>\<mu> (X \<tau>) = \<nu> (X \<tau>)\<close> by blast}
>   ultimately show "\<nu> (X t) < \<mu> (X t)"
>     by fastforce
> qed
> 
567c632
<   apply(rule_tac f'1="\<lambda> s. 0" and g'1="\<lambda> s. c" in derivative_intros(191))
---
>   apply(rule_tac f'1="\<lambda> s. 0" and g'1="\<lambda> s. c" in has_vderiv_on_add[THEN has_vderiv_on_eq_rhs])
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/HS_Preliminaries.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/HS_Preliminaries.thy
8c8
< text \<open>Hybrid systems combine continuous dynamics with discrete control. This section contains 
---
> text \<open>Hybrid systems combine continuous dynamics with discrete control. This section contains
18c18
< lemma abs_le_eq: 
---
> lemma abs_le_eq:
43,44c43,44
<   ultimately show "(x * cos t - y * sin t)\<^sup>2 + (x * sin t + y * cos t)\<^sup>2 = x\<^sup>2 + y\<^sup>2"  
<     by (simp add: Groups.mult_ac(2) Groups.mult_ac(3) right_diff_distrib sin_squared_eq) 
---
>   ultimately show "(x * cos t - y * sin t)\<^sup>2 + (x * sin t + y * cos t)\<^sup>2 = x\<^sup>2 + y\<^sup>2"
>     by (simp add: Groups.mult_ac(2) Groups.mult_ac(3) right_diff_distrib sin_squared_eq)
55a56,57
> thy_deps
> 
60,62c62,64
<     and derivative_intros(191) [poly_derivatives]
<     and derivative_intros(192) [poly_derivatives]
<     and derivative_intros(194) [poly_derivatives]
---
>     and has_vderiv_on_add[THEN has_vderiv_on_eq_rhs, poly_derivatives]
>     and has_vderiv_on_diff[THEN has_vderiv_on_eq_rhs, poly_derivatives]
>     and has_vderiv_on_mult[THEN has_vderiv_on_eq_rhs, poly_derivatives]
64,65c66,67
< lemma has_vderiv_on_compose_eq: 
<   assumes "D f = f' on g ` T" 
---
> lemma has_vderiv_on_compose_eq:
>   assumes "D f = f' on g ` T"
79c81
<   unfolding has_vderiv_on_def has_vector_derivative_def 
---
>   unfolding has_vderiv_on_def has_vector_derivative_def
81c83
<   apply(rule_tac f'1="\<lambda>t. t" and g'1="\<lambda> x. 0" in derivative_eq_intros(18))
---
>   apply(rule_tac f'1="\<lambda>t. t" and g'1="\<lambda> x. 0" in has_derivative_divide[THEN has_derivative_eq_rhs])
84,87c86,88
< lemma has_vderiv_on_power: "n \<ge> 1 \<Longrightarrow> D (\<lambda>t. t ^ n) = (\<lambda>t. n * (t ^ (n - 1))) on T" 
<   unfolding has_vderiv_on_def has_vector_derivative_def 
<   apply clarify
<   by(rule_tac f'1="\<lambda> t. t" in derivative_eq_intros(15)) auto
---
> lemma has_vderiv_on_power: "n \<ge> 1 \<Longrightarrow> D (\<lambda>t. t ^ n) = (\<lambda>t. n * (t ^ (n - 1))) on T"
>   unfolding has_vderiv_on_def has_vector_derivative_def
>   by (auto intro!: derivative_eq_intros)
92c93
< lemma has_vderiv_on_cos_comp: 
---
> lemma has_vderiv_on_cos_comp:
95c96
<   unfolding has_vderiv_on_def has_vector_derivative_def 
---
>   unfolding has_vderiv_on_def has_vector_derivative_def
99c100
< lemma has_vderiv_on_sin_comp: 
---
> lemma has_vderiv_on_sin_comp:
102c103
<   unfolding has_vderiv_on_def has_vector_derivative_def 
---
>   unfolding has_vderiv_on_def has_vector_derivative_def
106c107
< lemma has_vderiv_on_exp_comp: 
---
> lemma has_vderiv_on_exp_comp:
111c112
< lemma vderiv_uminus_intro [poly_derivatives]: 
---
> lemma vderiv_uminus_intro [poly_derivatives]:
126c127
<   using assms(1) 
---
>   using assms(1)
153c154
< lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. a5 * t^5 + a3 * (t^3 / c) - a2 * exp (t^2) + a1 * cos t + a0) = 
---
> lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. a5 * t^5 + a3 * (t^3 / c) - a2 * exp (t^2) + a1 * cos t + a0) =
157c158
< lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. - a3 * exp (t^3 / c) + a1 * sin t + a2 * t^2) = 
---
> lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. - a3 * exp (t^3 / c) + a1 * sin t + a2 * t^2) =
162c163
< lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. exp (a * sin (cos (t^4) / c))) = 
---
> lemma "c \<noteq> 0 \<Longrightarrow> D (\<lambda>t. exp (a * sin (cos (t^4) / c))) =
167a169,211
> subsection \<open> Intermediate Value Theorem \<close>
> 
> lemma IVT_two_functions:
>   fixes f :: "('a::{linear_continuum_topology, real_vector}) \<Rightarrow> 
>   ('b::{linorder_topology,real_normed_vector,ordered_ab_group_add})"
>   assumes conts: "continuous_on {a..b} f" "continuous_on {a..b} g"
>       and ahyp: "f a < g a" and bhyp: "g b < f b " and "a \<le> b"
>     shows "\<exists>x\<in>{a..b}. f x = g x"
> proof-
>   let "?h x" = "f x - g x"
>   have "?h a \<le> 0" and "?h b \<ge> 0"
>     using ahyp bhyp by simp_all
>   also have "continuous_on {a..b} ?h"
>     using conts continuous_on_diff by blast 
>   ultimately obtain x where "a \<le> x" "x \<le> b" and "?h x = 0"
>     using IVT'[of "?h"] \<open>a \<le> b\<close> by blast
>   thus ?thesis
>     using \<open>a \<le> b\<close> by auto
> qed
> 
> lemma IVT_two_functions_real_ivl:
>   fixes f :: "real \<Rightarrow> real"
>   assumes conts: "continuous_on {a--b} f" "continuous_on {a--b} g"
>       and ahyp: "f a < g a" and bhyp: "g b < f b "
>     shows "\<exists>x\<in>{a--b}. f x = g x"
> proof(cases "a \<le> b")
>   case True
>   then show ?thesis 
>     using IVT_two_functions assms 
>     unfolding closed_segment_eq_real_ivl by auto
> next
>   case False
>   hence "a \<ge> b"
>     by auto
>   hence "continuous_on {b..a} f" "continuous_on {b..a} g"
>     using conts False unfolding closed_segment_eq_real_ivl by auto
>   hence "\<exists>x\<in>{b..a}. g x = f x"
>     using IVT_two_functions[of b a g f] assms(3,4) False by auto
>   then show ?thesis  
>     using \<open>a \<ge> b\<close> unfolding closed_segment_eq_real_ivl by auto force
> qed
> 
> 
171c215
<   assumes "t \<in> interior T" and "T \<subseteq> S" 
---
>   assumes "t \<in> interior T" and "T \<subseteq> S"
176c220
< lemma netlimit_at_within_mono: 
---
> lemma netlimit_at_within_mono:
181c225
<   
---
> 
196c240
<   have obs: "\<forall>i. ?F (P i)" 
---
>   have obs: "\<forall>i. ?F (P i)"
214c258
<     unfolding eventually_def 
---
>     unfolding eventually_def
222c266
<   fixes f::"real \<Rightarrow> ('a::banach)^('m::finite)" and x::real and T::"real set" 
---
>   fixes f::"real \<Rightarrow> ('a::banach)^('m::finite)" and x::real and T::"real set"
227c271
<   fix \<epsilon>::real assume "0 < \<epsilon>" 
---
>   fix \<epsilon>::real assume "0 < \<epsilon>"
229c273
<   let "?P" = "\<lambda>i e y. inverse \<bar>?\<Delta> y\<bar> * (\<parallel>f y $ i - f x\<^sub>0 $ i - ?\<Delta> y *\<^sub>R f' x $ i\<parallel>) < e" 
---
>   let "?P" = "\<lambda>i e y. inverse \<bar>?\<Delta> y\<bar> * (\<parallel>f y $ i - f x\<^sub>0 $ i - ?\<Delta> y *\<^sub>R f' x $ i\<parallel>) < e"
231c275
<   have "0 < \<epsilon> / sqrt m" 
---
>   have "0 < \<epsilon> / sqrt m"
240c284
<     hence "\<forall>i. (?c *\<^sub>R (\<parallel>?u t i\<parallel>))\<^sup>2 < (\<epsilon> / sqrt m)\<^sup>2" 
---
>     hence "\<forall>i. (?c *\<^sub>R (\<parallel>?u t i\<parallel>))\<^sup>2 < (\<epsilon> / sqrt m)\<^sup>2"
242c286
<     hence "\<forall>i. ?c\<^sup>2 * ((\<parallel>?u t i\<parallel>))\<^sup>2 < \<epsilon>\<^sup>2 / m" 
---
>     hence "\<forall>i. ?c\<^sup>2 * ((\<parallel>?u t i\<parallel>))\<^sup>2 < \<epsilon>\<^sup>2 / m"
244c288
<     hence "\<forall>i. ?c\<^sup>2 * ((\<parallel>?u t i\<parallel>))\<^sup>2 < \<epsilon>\<^sup>2 / m" 
---
>     hence "\<forall>i. ?c\<^sup>2 * ((\<parallel>?u t i\<parallel>))\<^sup>2 < \<epsilon>\<^sup>2 / m"
246c290
<     also have "({}::'m set) \<noteq> UNIV \<and> finite (UNIV :: 'm set)" 
---
>     also have "({}::'m set) \<noteq> UNIV \<and> finite (UNIV :: 'm set)"
252c296
<     ultimately have "?c\<^sup>2 * (\<Sum>i\<in>UNIV. (\<parallel>?u t i\<parallel>)\<^sup>2) < \<epsilon>\<^sup>2" 
---
>     ultimately have "?c\<^sup>2 * (\<Sum>i\<in>UNIV. (\<parallel>?u t i\<parallel>)\<^sup>2) < \<epsilon>\<^sup>2"
256,257c300,301
<     also have "... = \<epsilon>" 
<       using \<open>0 < \<epsilon>\<close> by auto 
---
>     also have "... = \<epsilon>"
>       using \<open>0 < \<epsilon>\<close> by auto
259,260c303,304
<       by (simp add: real_sqrt_mult)   
<     ultimately show "?c * sqrt (\<Sum>i\<in>UNIV. (\<parallel>?u t i\<parallel>)\<^sup>2) < \<epsilon>" 
---
>       by (simp add: real_sqrt_mult)
>     ultimately show "?c * sqrt (\<Sum>i\<in>UNIV. (\<parallel>?u t i\<parallel>)\<^sup>2) < \<epsilon>"
264a309,320
> lemma tendsto_norm_bound:
>   "\<forall>x. \<parallel>G x - L\<parallel> \<le> \<parallel>F x - L\<parallel> \<Longrightarrow> (F \<longlongrightarrow> L) net \<Longrightarrow> (G \<longlongrightarrow> L) net"
>   apply(unfold tendsto_iff dist_norm, clarsimp)
>   apply(rule_tac P="\<lambda>x. \<parallel>F x - L\<parallel> < e" in eventually_mono, simp)
>   by (rename_tac e z) (erule_tac x=z in allE, simp)
> 
> lemma tendsto_zero_norm_bound:
>   "\<forall>x. \<parallel>G x\<parallel> \<le> \<parallel>F x\<parallel> \<Longrightarrow> (F \<longlongrightarrow> 0) net \<Longrightarrow> (G \<longlongrightarrow> 0) net"
>   apply(unfold tendsto_iff dist_norm, clarsimp)
>   apply(rule_tac P="\<lambda>x. \<parallel>F x\<parallel> < e" in eventually_mono, simp)
>   by (rename_tac e z) (erule_tac x=z in allE, simp)
> 
266,293c322,328
<   fixes f::"real \<Rightarrow> ('a::real_normed_vector)^'m" and x::real and T::"real set" 
<   defines "x\<^sub>0 \<equiv> netlimit (at x within T)"
<   assumes "((\<lambda>y. (f y - f x\<^sub>0 - (y - x\<^sub>0) *\<^sub>R f' x) /\<^sub>R (\<parallel>y - x\<^sub>0\<parallel>)) \<longlongrightarrow> 0) (at x within T)"
<   shows "((\<lambda>y. (f y $ i - f x\<^sub>0 $ i - (y - x\<^sub>0) *\<^sub>R f' x $ i) /\<^sub>R (\<parallel>y - x\<^sub>0\<parallel>)) \<longlongrightarrow> 0) (at x within T)"
< proof(unfold tendsto_iff dist_norm, clarify)
<   let "?\<Delta>" = "\<lambda>y. y - x\<^sub>0" and "?\<Delta>f" = "\<lambda>y. f y - f x\<^sub>0"
<   fix \<epsilon>::real assume "0 < \<epsilon>"
<   let "?P" = "\<lambda>y. \<parallel>(?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x) /\<^sub>R (\<parallel>?\<Delta> y\<parallel>) - 0\<parallel> < \<epsilon>"
<   and "?Q" = "\<lambda>y. \<parallel>(f y $ i - f x\<^sub>0 $ i - ?\<Delta> y *\<^sub>R f' x $ i) /\<^sub>R (\<parallel>?\<Delta> y\<parallel>) - 0\<parallel> < \<epsilon>"
<   have "eventually ?P (at x within T)" 
<     using \<open>0 < \<epsilon>\<close> assms unfolding tendsto_iff by auto
<   thus "eventually ?Q (at x within T)"
<   proof(rule_tac P="?P" in eventually_mono, simp_all)
<     fix y
<     let "?u i" = "f y $ i - f x\<^sub>0 $ i - ?\<Delta> y *\<^sub>R f' x $ i"
<     assume hyp:"inverse \<bar>?\<Delta> y\<bar> * (\<parallel>?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x\<parallel>) < \<epsilon>"
<     have "\<parallel>(?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x) $ i\<parallel> \<le> \<parallel>?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x\<parallel>"
<       using Finite_Cartesian_Product.norm_nth_le by blast
<     also have "\<parallel>?u i\<parallel> = \<parallel>(?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x) $ i\<parallel>" 
<       by simp
<     ultimately have "\<parallel>?u i\<parallel> \<le> \<parallel>?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x\<parallel>" 
<       by linarith
<     hence "inverse \<bar>?\<Delta> y\<bar> * (\<parallel>?u i\<parallel>) \<le> inverse \<bar>?\<Delta> y\<bar> * (\<parallel>?\<Delta>f y - ?\<Delta> y *\<^sub>R f' x\<parallel>)"
<       by (simp add: mult_left_mono)
<     thus "inverse \<bar>?\<Delta> y\<bar> * (\<parallel>f y $ i - f x\<^sub>0 $ i - ?\<Delta> y *\<^sub>R f' x $ i\<parallel>) < \<epsilon>"
<       using hyp by linarith
<   qed
< qed
---
>   fixes f::"real \<Rightarrow> ('a::real_normed_vector)^'m"
>   assumes "((\<lambda>x. (f x - f x\<^sub>0 - (x - x\<^sub>0) *\<^sub>R f' t) /\<^sub>R (\<parallel>x - x\<^sub>0\<parallel>)) \<longlongrightarrow> 0) (at t within T)"
>   shows "((\<lambda>x. (f x $ i - f x\<^sub>0 $ i - (x - x\<^sub>0) *\<^sub>R f' t $ i) /\<^sub>R (\<parallel>x - x\<^sub>0\<parallel>)) \<longlongrightarrow> 0) (at t within T)"
>   apply(rule_tac F="(\<lambda>x. (f x - f x\<^sub>0 - (x - x\<^sub>0) *\<^sub>R f' t) /\<^sub>R (\<parallel>x - x\<^sub>0\<parallel>))" in tendsto_zero_norm_bound)
>    apply(clarsimp, rule mult_left_mono)
>     apply (metis Finite_Cartesian_Product.norm_nth_le vector_minus_component vector_scaleR_component)
>   using assms by simp_all
308c343
<   using frechet_vec_nth[of x T f] assms unfolding has_derivative_def by auto
---
>   using frechet_vec_nth assms unfolding has_derivative_def by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/HS_VC_Examples.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/HS_VC_Examples.thy
8c8
< text \<open> We prove partial correctness specifications of some hybrid systems with our 
---
> text \<open> We prove partial correctness specifications of some hybrid systems with our
19c19
< text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of 
---
> text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
56,59c56,59
< text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with 
< the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the 
< constant acceleration due to gravity. The bounce is modelled with a variable assigntment that 
< flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"} 
---
> text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
> the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
> constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
> flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
63c63
< abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f") 
---
> abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f")
66c66
< abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>") 
---
> abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>")
73c73
< lemma inv_imp_pos_le[bb_real_arith]: 
---
> lemma inv_imp_pos_le[bb_real_arith]:
77c77
<   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g" 
---
>   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g"
79,82c79,82
<   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0" 
<     using left_diff_distrib mult.commute by (metis zero_le_square) 
<   hence "(v * v)/(2 * g) = (x - h)" 
<     by auto 
---
>   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0"
>     using left_diff_distrib mult.commute by (metis zero_le_square)
>   hence "(v * v)/(2 * g) = (x - h)"
>     by auto
84,85c84,85
<     using divide_nonneg_neg by fastforce 
<   ultimately have "h - x \<ge> 0" 
---
>     using divide_nonneg_neg by fastforce
>   ultimately have "h - x \<ge> 0"
90c90
< lemma bouncing_ball_inv: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
---
> lemma bouncing_ball_inv: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
93c93
<     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0) DINV (\<lambda>s. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ; 
---
>     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0) DINV (\<lambda>s. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ;
112c112
<     using invar by (simp add: monoid_mult_class.power2_eq_square) 
---
>     using invar by (simp add: monoid_mult_class.power2_eq_square)
114c114
<     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3) 
---
>     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3)
122c122
<   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) = 
---
>   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) =
125,127c125,126
<   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x" 
<     apply(subst Rat.sign_simps(18))+ 
<     by(auto simp: semiring_normalization_rules(29))
---
>   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x"
>     by(auto simp: algebra_simps semiring_normalization_rules(29))
131c130
<   moreover 
---
>   moreover
140c139
< lemma bouncing_ball_dyn: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
---
> lemma bouncing_ball_dyn: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
143c142
<     (EVOL (\<phi> g) (\<lambda> s. s$1 \<ge> 0) T) ; 
---
>     (EVOL (\<phi> g) (\<lambda> s. s$1 \<ge> 0) T) ;
157c156
< lemma bouncing_ball_flow: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
---
> lemma bouncing_ball_flow: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
160c159
<     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0)) ; 
---
>     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0)) ;
172,179c171,178
< text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater. 
< At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers 
< the room temperature, and it turns the heater on (or off) based on this reading. The temperature 
< follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater 
< is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature, 
< @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the 
< temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on 
< (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's 
---
> text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
> At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
> the room temperature, and it turns the heater on (or off) based on this reading. The temperature
> follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater
> is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
> @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
> temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
> (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
186c185
<   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else 
---
>   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
233c232
<     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T] 
---
>     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T]
240,241c239,240
<   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)" 
<     and "L - exp (-(a * t)) * (L - T) \<le> Tmax" 
---
>   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)"
>     and "L - exp (-(a * t)) * (L - T) \<le> Tmax"
266c265
< lemma thermostat: 
---
> lemma thermostat:
268,269c267,268
<   shows "(\<lambda>s. Tmin \<le> s$1 \<and> s$1 \<le> Tmax \<and> s$4 = 0) \<le> 
<   |LOOP 
---
>   shows "(\<lambda>s. Tmin \<le> s$1 \<and> s$1 \<le> Tmax \<and> s$4 = 0) \<le>
>   |LOOP
272c271
<     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE 
---
>     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE
275c274
<     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0) 
---
>     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/ModalKleeneAlgebra/HS_VC_MKA_Examples_ndfun.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/ModalKleeneAlgebra/HS_VC_MKA_Examples_ndfun.thy
8,10c8,10
< text \<open> We prove partial correctness specifications of some hybrid systems with our 
< recently described verification components. Notice that this is an exact copy of 
< the file @{text HS_VC_MKA_Examples}, meaning our components are truly modular and 
---
> text \<open> We prove partial correctness specifications of some hybrid systems with our
> recently described verification components. Notice that this is an exact copy of
> the file @{text HS_VC_MKA_Examples}, meaning our components are truly modular and
21c21
< text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of 
---
> text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
29c29
<   where "\<phi> t s \<equiv> (\<chi> i. if i = 1 then s$1 * cos t + s$2 * sin t 
---
>   where "\<phi> t s \<equiv> (\<chi> i. if i = 1 then s$1 * cos t + s$2 * sin t
62,65c62,65
< text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with 
< the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the 
< constant acceleration due to gravity. The bounce is modelled with a variable assigntment that 
< flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"} 
---
> text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
> the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
> constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
> flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
69c69
< abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f") 
---
> abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f")
72c72
< abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>") 
---
> abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>")
79c79
< lemma inv_imp_pos_le[bb_real_arith]: 
---
> lemma inv_imp_pos_le[bb_real_arith]:
83c83
<   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g" 
---
>   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g"
85,88c85,88
<   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0" 
<     using left_diff_distrib mult.commute by (metis zero_le_square) 
<   hence "(v * v)/(2 * g) = (x - h)" 
<     by auto 
---
>   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0"
>     using left_diff_distrib mult.commute by (metis zero_le_square)
>   hence "(v * v)/(2 * g) = (x - h)"
>     by auto
90,91c90,91
<     using divide_nonneg_neg by fastforce 
<   ultimately have "h - x \<ge> 0" 
---
>     using divide_nonneg_neg by fastforce
>   ultimately have "h - x \<ge> 0"
97,100c97,100
<   fixes h::real 
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> 
<   wp 
<     (LOOP 
---
>   fixes h::real
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le>
>   wp
>     (LOOP
102c102
<        (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
---
>        (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
120c120
<     using invar by (simp add: monoid_mult_class.power2_eq_square) 
---
>     using invar by (simp add: monoid_mult_class.power2_eq_square)
122c122
<     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3) 
---
>     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3)
130c130
<   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) = 
---
>   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) =
133,135c133,134
<   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x" 
<     apply(subst Rat.sign_simps(18))+ 
<     by(auto simp: semiring_normalization_rules(29))
---
>   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x"
>     by(auto simp: algebra_simps semiring_normalization_rules(29))
139c138
<   moreover 
---
>   moreover
149c148
<   fixes h::real 
---
>   fixes h::real
151,153c150,152
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp 
<     (LOOP 
---
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp
>     (LOOP
155,156c154,155
<       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
<     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2)) 
---
>       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
>     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2))
169c168
<   fixes h::real 
---
>   fixes h::real
171,173c170,172
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp 
<     (LOOP 
---
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp
>     (LOOP
175,176c174,175
<       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
<     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2)) 
---
>       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
>     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2))
186,193c185,192
< text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater. 
< At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers 
< the room temperature, and it turns the heater on (or off) based on this reading. The temperature 
< follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater 
< is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature, 
< @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the 
< temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on 
< (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's 
---
> text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
> At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
> the room temperature, and it turns the heater on (or off) based on this reading. The temperature
> follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater
> is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
> @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
> temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
> (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
200c199
<   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else 
---
>   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
223c222
<   using assms 
---
>   using assms
247c246
<     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T] 
---
>     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T]
254,255c253,254
<   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)" 
<     and "L - exp (-(a * t)) * (L - T) \<le> Tmax" 
---
>   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)"
>     and "L - exp (-(a * t)) * (L - T) \<le> Tmax"
280c279
< lemma thermostat: 
---
> lemma thermostat:
283c282
<   (LOOP 
---
>   (LOOP
286c285
<     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE 
---
>     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE
289c288
<     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0) 
---
>     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/ModalKleeneAlgebra/HS_VC_MKA_Examples_rel.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/ModalKleeneAlgebra/HS_VC_MKA_Examples_rel.thy
8c8
< text \<open> We prove partial correctness specifications of some hybrid systems with our 
---
> text \<open> We prove partial correctness specifications of some hybrid systems with our
19c19
< text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of 
---
> text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
27c27
<   where "\<phi> t s \<equiv> (\<chi> i. if i = 1 then s$1 * cos t + s$2 * sin t 
---
>   where "\<phi> t s \<equiv> (\<chi> i. if i = 1 then s$1 * cos t + s$2 * sin t
60,63c60,63
< text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with 
< the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the 
< constant acceleration due to gravity. The bounce is modelled with a variable assigntment that 
< flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"} 
---
> text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
> the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
> constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
> flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
67c67
< abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f") 
---
> abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f")
70c70
< abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>") 
---
> abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>")
77c77
< lemma inv_imp_pos_le[bb_real_arith]: 
---
> lemma inv_imp_pos_le[bb_real_arith]:
81c81
<   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g" 
---
>   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g"
83,86c83,86
<   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0" 
<     using left_diff_distrib mult.commute by (metis zero_le_square) 
<   hence "(v * v)/(2 * g) = (x - h)" 
<     by auto 
---
>   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0"
>     using left_diff_distrib mult.commute by (metis zero_le_square)
>   hence "(v * v)/(2 * g) = (x - h)"
>     by auto
88,89c88,89
<     using divide_nonneg_neg by fastforce 
<   ultimately have "h - x \<ge> 0" 
---
>     using divide_nonneg_neg by fastforce
>   ultimately have "h - x \<ge> 0"
95,98c95,98
<   fixes h::real 
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> 
<   wp 
<     (LOOP 
---
>   fixes h::real
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le>
>   wp
>     (LOOP
100c100
<        (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
---
>        (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
118c118
<     using invar by (simp add: monoid_mult_class.power2_eq_square) 
---
>     using invar by (simp add: monoid_mult_class.power2_eq_square)
120c120
<     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3) 
---
>     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3)
128c128
<   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) = 
---
>   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) =
131,133c131,132
<   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x" 
<     apply(subst Rat.sign_simps(18))+ 
<     by(auto simp: semiring_normalization_rules(29))
---
>   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x"
>     by(auto simp: algebra_simps semiring_normalization_rules(29))
137c136
<   moreover 
---
>   moreover
147c146
<   fixes h::real 
---
>   fixes h::real
149,151c148,150
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp 
<     (LOOP 
---
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp
>     (LOOP
153,154c152,153
<       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
<     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2)) 
---
>       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
>     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2))
167c166
<   fixes h::real 
---
>   fixes h::real
169,171c168,170
<   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp 
<     (LOOP 
---
>   shows "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   \<lceil>\<lambda>s. s$1 = h \<and> s$2 = 0\<rceil> \<le> wp
>     (LOOP
173,174c172,173
<       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip)) 
<     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2)) 
---
>       (IF (\<lambda> s. s$1 = 0) THEN (2 ::= (\<lambda>s. - s$2)) ELSE skip))
>     INV (\<lambda>s. 0 \<le> s$1 \<and> 2 * g * s$1 = 2 * g * h + s$2 * s$2))
184,191c183,190
< text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater. 
< At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers 
< the room temperature, and it turns the heater on (or off) based on this reading. The temperature 
< follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater 
< is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature, 
< @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the 
< temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on 
< (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's 
---
> text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
> At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
> the room temperature, and it turns the heater on (or off) based on this reading. The temperature
> follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater
> is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
> @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
> temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
> (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
198c197
<   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else 
---
>   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
221c220
<   using assms 
---
>   using assms
245c244
<     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T] 
---
>     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T]
252,253c251,252
<   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)" 
<     and "L - exp (-(a * t)) * (L - T) \<le> Tmax" 
---
>   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)"
>     and "L - exp (-(a * t)) * (L - T) \<le> Tmax"
278c277
< lemma thermostat: 
---
> lemma thermostat:
281c280
<   (LOOP 
---
>   (LOOP
284c283
<     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE 
---
>     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE
287c286
<     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0) 
---
>     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Hybrid_Systems_VCs/PredicateTransformers/HS_VC_PT_Examples.thy ../../AFPs/afp-2020/thys/Hybrid_Systems_VCs/PredicateTransformers/HS_VC_PT_Examples.thy
8c8
< text \<open> We prove partial correctness specifications of some hybrid systems with our 
---
> text \<open> We prove partial correctness specifications of some hybrid systems with our
19c19
< text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of 
---
> text \<open> The ODEs @{text "x' t = y t"} and {text "y' t = - x t"} describe the circular motion of
56,59c56,59
< text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with 
< the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the 
< constant acceleration due to gravity. The bounce is modelled with a variable assigntment that 
< flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"} 
---
> text \<open> A ball is dropped from rest at an initial height @{text "h"}. The motion is described with
> the free-fall equations @{text "x' t = v t"} and @{text "v' t = g"} where @{text "g"} is the
> constant acceleration due to gravity. The bounce is modelled with a variable assigntment that
> flips the velocity, thus it is a completely elastic collision with the ground. We use @{text "s$1"}
63c63
< abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f") 
---
> abbreviation fball :: "real \<Rightarrow> real^2 \<Rightarrow> real^2" ("f")
66c66
< abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>") 
---
> abbreviation ball_flow :: "real \<Rightarrow> real \<Rightarrow> real^2 \<Rightarrow> real^2" ("\<phi>")
73c73
< lemma inv_imp_pos_le[bb_real_arith]: 
---
> lemma inv_imp_pos_le[bb_real_arith]:
77c77
<   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g" 
---
>   have "v * v = 2 * g * x - 2 * g * h \<and> 0 > g"
79,82c79,82
<   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0" 
<     using left_diff_distrib mult.commute by (metis zero_le_square) 
<   hence "(v * v)/(2 * g) = (x - h)" 
<     by auto 
---
>   hence obs:"v * v = 2 * g * (x - h) \<and> 0 > g \<and> v * v \<ge> 0"
>     using left_diff_distrib mult.commute by (metis zero_le_square)
>   hence "(v * v)/(2 * g) = (x - h)"
>     by auto
84,85c84,85
<     using divide_nonneg_neg by fastforce 
<   ultimately have "h - x \<ge> 0" 
---
>     using divide_nonneg_neg by fastforce
>   ultimately have "h - x \<ge> 0"
90,91c90,91
< lemma bouncing_ball_inv: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F> 
---
> lemma bouncing_ball_inv: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F>
93c93
<     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0) DINV (\<lambda>s. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ; 
---
>     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0) DINV (\<lambda>s. 2 * g * s$1 - 2 * g * h - s$2 * s$2 = 0)) ;
114c114
<     using invar by (simp add: monoid_mult_class.power2_eq_square) 
---
>     using invar by (simp add: monoid_mult_class.power2_eq_square)
116c116
<     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3) 
---
>     apply(subst power2_sum) by (metis (no_types, hide_lams) Groups.add_ac(2, 3)
124c124
<   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) = 
---
>   shows "2 * g * (g * \<tau>\<^sup>2 / 2 + v * \<tau> + (x::real)) =
127,129c127,128
<   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x" 
<     apply(subst Rat.sign_simps(18))+ 
<     by(auto simp: semiring_normalization_rules(29))
---
>   have "?lhs = g\<^sup>2 * \<tau>\<^sup>2 + 2 * g * v * \<tau> + 2 * g * x"
>     by(auto simp: algebra_simps semiring_normalization_rules(29))
133c132
<   moreover 
---
>   moreover
142,143c141,142
< lemma bouncing_ball_dyn: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F> 
---
> lemma bouncing_ball_dyn: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F>
145c144
<     (EVOL (\<phi> g) (\<lambda> s. s$1 \<ge> 0) T) ; 
---
>     (EVOL (\<phi> g) (\<lambda> s. s$1 \<ge> 0) T) ;
159,160c158,159
< lemma bouncing_ball_flow: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow> 
<   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F> 
---
> lemma bouncing_ball_flow: "g < 0 \<Longrightarrow> h \<ge> 0 \<Longrightarrow>
>   {s. s$1 = h \<and> s$2 = 0} \<le> fb\<^sub>\<F>
162c161
<     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0)) ; 
---
>     (x\<acute>=(f g) & (\<lambda> s. s$1 \<ge> 0)) ;
174,181c173,180
< text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater. 
< At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers 
< the room temperature, and it turns the heater on (or off) based on this reading. The temperature 
< follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater 
< is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature, 
< @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the 
< temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on 
< (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's 
---
> text \<open> A thermostat has a chronometer, a thermometer and a switch to turn on and off a heater.
> At most every @{text "t"} minutes, it sets its chronometer to @{term "0::real"}, it registers
> the room temperature, and it turns the heater on (or off) based on this reading. The temperature
> follows the ODE @{text "T' = - a * (T - U)"} where @{text "U"} is @{text "L \<ge> 0"} when the heater
> is on, and @{text "0"} when it is off. We use @{term "1::4"} to denote the room's temperature,
> @{term "2::4"} is time as measured by the thermostat's chronometer, @{term "3::4"} is the
> temperature detected by the thermometer, and @{term "4::4"} states whether the heater is on
> (@{text "s$4 = 1"}) or off (@{text "s$4 = 0"}). We prove that the thermostat keeps the room's
188c187
<   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else 
---
>   where "\<phi> a L t s \<equiv> (\<chi> i. if i = 1 then - exp(-a * t) * (L - s$1) + L else
211c210
<   using assms 
---
>   using assms
235c234
<     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T] 
---
>     using Thyps mult_left_le_one_le[OF _ exp_ge_zero obs(2), of T]
242,243c241,242
<   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)" 
<     and "L - exp (-(a * t)) * (L - T) \<le> Tmax" 
---
>   shows "L - Tmax \<le> exp (-(a * t)) * (L - T)"
>     and "L - exp (-(a * t)) * (L - T) \<le> Tmax"
268c267
< lemma thermostat: 
---
> lemma thermostat:
270,271c269,270
<   shows "{s. Tmin \<le> s$1 \<and> s$1 \<le> Tmax \<and> s$4 = 0} \<le> fb\<^sub>\<F> 
<   (LOOP 
---
>   shows "{s. Tmin \<le> s$1 \<and> s$1 \<le> Tmax \<and> s$4 = 0} \<le> fb\<^sub>\<F>
>   (LOOP
274c273
<     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE 
---
>     (IF (\<lambda>s. s$4 = 0 \<and> s$3 \<le> Tmin + 1) THEN (4 ::= (\<lambda>s.1)) ELSE
277c276
<     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0) 
---
>     (IF (\<lambda>s. s$4 = 0) THEN (x\<acute>=(f a 0) & (\<lambda>s. s$2 \<le> - (ln (Tmin/s$3))/a) on {0..t} UNIV @ 0)
==========
IEEE_Floating_Point
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IEEE_Floating_Point/FP64.thy ../../AFPs/afp-2020/thys/IEEE_Floating_Point/FP64.thy
80a81,83
> lift_definition fp64_mul_add::"roundmode \<Rightarrow> fp64 \<Rightarrow> fp64 \<Rightarrow> fp64 \<Rightarrow> fp64" is
>   "fmul_add::roundmode\<Rightarrow>float64\<Rightarrow>float64\<Rightarrow>float64\<Rightarrow>float64" by simp
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IEEE_Floating_Point/IEEE_Properties.thy ../../AFPs/afp-2020/thys/IEEE_Floating_Point/IEEE_Properties.thy
320,321c320
<   unfolding float_defs
<   by (auto simp: sign_simps divide_simps power_gt1_lemma)
---
>   by (auto simp: float_defs field_simps power_gt1_lemma)
459,460c458,459
<       (auto simp: bitlen_le_iff_power bitlen_ge_iff_power nat_add_distrib abs_mult sign_simps
<         add_nonneg_pos normal_mantissa_def intro!: antisym)
---
>       (auto simp: bitlen_le_iff_power bitlen_ge_iff_power nat_add_distrib
>         normal_mantissa_def intro!: antisym)
610,611c609
<       (auto simp: bitlen_le_iff_power nat_add_distrib abs_mult sign_simps
<         add_nonneg_pos denormal_mantissa_def intro!: antisym)
---
>       (auto simp: bitlen_le_iff_power denormal_mantissa_def intro!: antisym)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IEEE_Floating_Point/IEEE.thy ../../AFPs/afp-2020/thys/IEEE_Floating_Point/IEEE.thy
207a208,218
> text \<open>Round, choosing between -0.0 or +0.0\<close>
> 
> definition float_round::"roundmode \<Rightarrow> bool \<Rightarrow> real \<Rightarrow> ('e, 'f) float"
>   where "float_round mode toneg r =
>       (let x = round mode r in
>          if is_zero x
>             then if toneg
>                     then minus_zero
>                  else 0
>          else x)"
> 
284a296,318
> 
> definition fmul_add :: "roundmode \<Rightarrow> ('t ,'w) float \<Rightarrow> ('t ,'w) float \<Rightarrow> ('t ,'w) float \<Rightarrow> ('t ,'w) float"
>   where "fmul_add mode x y z =
>       (let signP = if sign x = sign y then 0 else 1 in
>       let infP = is_infinity x  \<or> is_infinity y
>       in
>          if is_nan x \<or> is_nan y \<or> is_nan z then some_nan
>          else if is_infinity x \<and> is_zero y \<or>
>                  is_zero x \<and> is_infinity y \<or>
>                  is_infinity z \<and> infP \<and> signP \<noteq> sign z then
>             some_nan
>          else if is_infinity z \<and> (sign z = 0) \<or> infP \<and> (signP = 0)
>             then plus_infinity
>          else if is_infinity z \<and> (sign z = 1) \<or> infP \<and> (signP = 1)
>             then minus_infinity
>          else
>             let r1 = valof x * valof y;
>                 r2 = valof z
>             in
>               float_round mode
>                 (if (r1 = 0) \<and> (r2 = 0) \<and> (signP = sign z) then
>                    signP = 1
>                  else mode = To_ninfinity) (r1 + r2))"
==========
IMP2
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IMP2/automation/IMP2_Var_Abs.thy ../../AFPs/afp-2020/thys/IMP2/automation/IMP2_Var_Abs.thy
70c70
<         (((imp_var,isa_name),v), Variable.auto_fixes v ctxt )
---
>         (((imp_var,isa_name),v), Proof_Context.augment v ctxt )
==========
Incompleteness
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Coding_Predicates.thy ../../AFPs/afp-2020/thys/Incompleteness/Coding_Predicates.thy
52c52
< lemma is_Var_imp_decode_Var: "is_Var x \<Longrightarrow> x = \<lbrakk>\<lceil>Var (decode_Var x)\<rceil>\<rbrakk> e"
---
> lemma is_Var_imp_decode_Var: "is_Var x \<Longrightarrow> x = \<lbrakk>\<guillemotleft>Var (decode_Var x)\<guillemotright>\<rbrakk> e"
111c111
< lemma eval_Var_q: "\<lbrakk>\<lceil>Var i\<rceil>\<rbrakk> e = q_Var i"
---
> lemma eval_Var_q: "\<lbrakk>\<guillemotleft>Var i\<guillemotright>\<rbrakk> e = q_Var i"
114c114
< lemma is_Var_eval_Var [simp]: "is_Var \<lbrakk>\<lceil>Var i\<rceil>\<rbrakk>e"
---
> lemma is_Var_eval_Var [simp]: "is_Var \<lbrakk>\<guillemotleft>Var i\<guillemotright>\<rbrakk>e"
269c269
< corollary Term_quot_tm [iff]: fixes t :: tm  shows "Term \<lbrakk>\<lceil>t\<rceil>\<rbrakk>e"
---
> corollary Term_quot_tm [iff]: fixes t :: tm  shows "Term \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk>e"
293c293
< corollary Term_imp_is_tm: assumes "Term x" obtains t::tm where "x = \<lbrakk>\<lceil>t\<rceil>\<rbrakk> e"
---
> corollary Term_imp_is_tm: assumes "Term x" obtains t::tm where "x = \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk> e"
1254c1254
<   "AbstForm (q_Var i) 0 \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e"
---
>   "AbstForm (q_Var i) 0 \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e"
1258c1258
<   "\<lbrakk>x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk> e;  x' = \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e\<rbrakk> \<Longrightarrow> AbstForm (q_Var i) 0 x x'"
---
>   "\<lbrakk>x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk> e;  x' = \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e\<rbrakk> \<Longrightarrow> AbstForm (q_Var i) 0 x x'"
1296c1296
< lemma Form_quot_fm [iff]: fixes A :: fm  shows "Form \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e"
---
> lemma Form_quot_fm [iff]: fixes A :: fm  shows "Form \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e"
1345c1345
< lemma Form_imp_is_fm: assumes "Form x" obtains A::fm where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk> e"
---
> lemma Form_imp_is_fm: assumes "Form x" obtains A::fm where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk> e"
1349,1350c1349,1350
<   assumes "SubstForm v \<lbrakk>\<lceil>u\<rceil>\<rbrakk>e x x'" "Form x"
<   obtains A::fm where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk> e" "x' = \<lbrakk>\<lceil>A(decode_Var v::=u)\<rceil>\<rbrakk> e"
---
>   assumes "SubstForm v \<lbrakk>\<guillemotleft>u\<guillemotright>\<rbrakk>e x x'" "Form x"
>   obtains A::fm where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk> e" "x' = \<lbrakk>\<guillemotleft>A(decode_Var v::=u)\<guillemotright>\<rbrakk> e"
1358c1358
<             (\<exists>t::tm. y = \<lbrakk>\<lceil>t\<rceil>\<rbrakk>e \<and> (\<exists>A::fm. x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> x' = \<lbrakk>\<lceil>A(decode_Var v::=t)\<rceil>\<rbrakk>e))"
---
>             (\<exists>t::tm. y = \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk>e \<and> (\<exists>A::fm. x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> x' = \<lbrakk>\<guillemotleft>A(decode_Var v::=t)\<guillemotright>\<rbrakk>e))"
1366c1366
< lemma SubstForm_quot_unique: "SubstForm (q_Var i) \<lbrakk>\<lceil>t\<rceil>\<rbrakk>e \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e x' \<longleftrightarrow> x' = \<lbrakk>\<lceil>A(i::=t)\<rceil>\<rbrakk> e"
---
> lemma SubstForm_quot_unique: "SubstForm (q_Var i) \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e x' \<longleftrightarrow> x' = \<lbrakk>\<guillemotleft>A(i::=t)\<guillemotright>\<rbrakk> e"
1369c1369
< lemma SubstForm_quot: "SubstForm \<lbrakk>\<lceil>Var i\<rceil>\<rbrakk>e \<lbrakk>\<lceil>t\<rceil>\<rbrakk>e \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<lbrakk>\<lceil>A(i::=t)\<rceil>\<rbrakk>e"
---
> lemma SubstForm_quot: "SubstForm \<lbrakk>\<guillemotleft>Var i\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>A(i::=t)\<guillemotright>\<rbrakk>e"
1411c1411
<   assumes "VarNonOccForm v x"  obtains A::fm where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" "atom (decode_Var v) \<sharp> A"
---
>   assumes "VarNonOccForm v x"  obtains A::fm where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" "atom (decode_Var v) \<sharp> A"
1421c1421
<   fixes A::fm  shows "atom i \<sharp> A \<Longrightarrow> VarNonOccForm (q_Var i) \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e"
---
>   fixes A::fm  shows "atom i \<sharp> A \<Longrightarrow> VarNonOccForm (q_Var i) \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Coding.thy ../../AFPs/afp-2020/thys/Incompleteness/Coding.thy
527c527
<   fixes quot :: "'a \<Rightarrow> tm"  ("\<lceil>_\<rceil>")
---
>   fixes quot :: "'a \<Rightarrow> tm"  ("\<guillemotleft>_\<guillemotright>")
540c540
< lemma quot_tm_fresh [simp]: fixes t::tm shows "s \<sharp> \<lceil>t\<rceil>"
---
> lemma quot_tm_fresh [simp]: fixes t::tm shows "s \<sharp> \<guillemotleft>t\<guillemotright>"
543c543
< lemma quot_Zero [simp]: "\<lceil>Zero\<rceil> = Zero"
---
> lemma quot_Zero [simp]: "\<guillemotleft>Zero\<guillemotright> = Zero"
546c546
< lemma quot_Var: "\<lceil>Var x\<rceil> = SUCC (ORD_OF (nat_of_name x))"
---
> lemma quot_Var: "\<guillemotleft>Var x\<guillemotright> = SUCC (ORD_OF (nat_of_name x))"
549c549
< lemma quot_Eats: "\<lceil>Eats x y\<rceil> = HPair (HTuple 1) (HPair \<lceil>x\<rceil> \<lceil>y\<rceil>)"
---
> lemma quot_Eats: "\<guillemotleft>Eats x y\<guillemotright> = HPair (HTuple 1) (HPair \<guillemotleft>x\<guillemotright> \<guillemotleft>y\<guillemotright>)"
573c573
< lemma quot_fm_fresh [simp]: fixes A::fm shows "s \<sharp> \<lceil>A\<rceil>"
---
> lemma quot_fm_fresh [simp]: fixes A::fm shows "s \<sharp> \<guillemotleft>A\<guillemotright>"
576c576
< lemma quot_fm_permute [simp]: fixes A:: fm shows "p \<bullet> \<lceil>A\<rceil> = \<lceil>A\<rceil>"
---
> lemma quot_fm_permute [simp]: fixes A:: fm shows "p \<bullet> \<guillemotleft>A\<guillemotright> = \<guillemotleft>A\<guillemotright>"
579c579
< lemma quot_Mem: "\<lceil>x IN y\<rceil> = HPair (HTuple 0) (HPair (\<lceil>x\<rceil>) (\<lceil>y\<rceil>))"
---
> lemma quot_Mem: "\<guillemotleft>x IN y\<guillemotright> = HPair (HTuple 0) (HPair (\<guillemotleft>x\<guillemotright>) (\<guillemotleft>y\<guillemotright>))"
582c582
< lemma quot_Eq: "\<lceil>x EQ y\<rceil> = HPair (HTuple 2) (HPair (\<lceil>x\<rceil>) (\<lceil>y\<rceil>))"
---
> lemma quot_Eq: "\<guillemotleft>x EQ y\<guillemotright> = HPair (HTuple 2) (HPair (\<guillemotleft>x\<guillemotright>) (\<guillemotleft>y\<guillemotright>))"
585c585
< lemma quot_Disj: "\<lceil>A OR B\<rceil> = HPair (HTuple 3) (HPair (\<lceil>A\<rceil>) (\<lceil>B\<rceil>))"
---
> lemma quot_Disj: "\<guillemotleft>A OR B\<guillemotright> = HPair (HTuple 3) (HPair (\<guillemotleft>A\<guillemotright>) (\<guillemotleft>B\<guillemotright>))"
588c588
< lemma quot_Neg: "\<lceil>Neg A\<rceil> = HPair (HTuple 4) (\<lceil>A\<rceil>)"
---
> lemma quot_Neg: "\<guillemotleft>Neg A\<guillemotright> = HPair (HTuple 4) (\<guillemotleft>A\<guillemotright>)"
591c591
< lemma quot_Ex: "\<lceil>Ex i A\<rceil> = HPair (HTuple 5) (quot_dbfm (trans_fm [i] A))"
---
> lemma quot_Ex: "\<guillemotleft>Ex i A\<guillemotright> = HPair (HTuple 5) (quot_dbfm (trans_fm [i] A))"
594c594
< lemma eval_quot_fm_ignore: fixes A:: fm shows "\<lbrakk>\<lceil>A\<rceil>\<rbrakk>e = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e'"
---
> lemma eval_quot_fm_ignore: fixes A:: fm shows "\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e'"
619c619
< lemma quot_Succ: "\<lceil>SUCC x\<rceil> = Q_Succ \<lceil>x\<rceil>"
---
> lemma quot_Succ: "\<guillemotleft>SUCC x\<guillemotright> = Q_Succ \<guillemotleft>x\<guillemotright>"
686c686
< lemma quot_subst_eq: "\<lceil>A(i::=t)\<rceil> = quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))"
---
> lemma quot_subst_eq: "\<guillemotleft>A(i::=t)\<guillemotright> = quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))"
697c697
< lemma eval_tm_inject [simp]: fixes t::tm shows "\<lbrakk>\<lceil>t\<rceil>\<rbrakk> e = \<lbrakk>\<lceil>u\<rceil>\<rbrakk> e \<longleftrightarrow> t=u"
---
> lemma eval_tm_inject [simp]: fixes t::tm shows "\<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk> e = \<lbrakk>\<guillemotleft>u\<guillemotright>\<rbrakk> e \<longleftrightarrow> t=u"
715c715
< lemma eval_fm_inject [simp]: fixes A::fm shows "\<lbrakk>\<lceil>A\<rceil>\<rbrakk> e = \<lbrakk>\<lceil>B\<rceil>\<rbrakk> e \<longleftrightarrow> A=B"
---
> lemma eval_fm_inject [simp]: fixes A::fm shows "\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk> e = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk> e \<longleftrightarrow> A=B"
762c762
< lemma quot_fm_coding: fixes A::fm shows "coding_tm \<lceil>A\<rceil>"
---
> lemma quot_fm_coding: fixes A::fm shows "coding_tm \<guillemotleft>A\<guillemotright>"
828c828
< lemma vquot_tm_empty [simp]: fixes t::tm shows "\<lfloor>t\<rfloor>{} = \<lceil>t\<rceil>"
---
> lemma vquot_tm_empty [simp]: fixes t::tm shows "\<lfloor>t\<rfloor>{} = \<guillemotleft>t\<guillemotright>"
847c847
< lemma vquot_fm_empty [simp]: fixes A::fm shows "\<lfloor>A\<rfloor>{} = \<lceil>A\<rceil>"
---
> lemma vquot_fm_empty [simp]: fixes A::fm shows "\<lfloor>A\<rfloor>{} = \<guillemotleft>A\<guillemotright>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Functions.thy ../../AFPs/afp-2020/thys/Incompleteness/Functions.thy
123c123
<     \<comment> \<open>case 1, both sides equal "v"\<close>
---
>     \<comment> \<open>case 1, both sides equal @{term v}\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Goedel_II.thy ../../AFPs/afp-2020/thys/Incompleteness/Goedel_II.thy
40c40
<   "\<lbrakk>{} \<turnstile> \<alpha> IMP \<beta>; ground_fm \<alpha>; ground_fm \<beta>\<rbrakk> \<Longrightarrow> {PfP \<lceil>\<alpha>\<rceil>} \<turnstile> PfP \<lceil>\<beta>\<rceil>"
---
>   "\<lbrakk>{} \<turnstile> \<alpha> IMP \<beta>; ground_fm \<alpha>; ground_fm \<beta>\<rbrakk> \<Longrightarrow> {PfP \<guillemotleft>\<alpha>\<guillemotright>} \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>"
44c44
< lemma PfP_quot_contra: "ground_fm \<alpha> \<Longrightarrow> {} \<turnstile> PfP \<lceil>\<alpha>\<rceil> IMP PfP \<lceil>Neg \<alpha>\<rceil> IMP PfP \<lceil>Fls\<rceil>"
---
> lemma PfP_quot_contra: "ground_fm \<alpha> \<Longrightarrow> {} \<turnstile> PfP \<guillemotleft>\<alpha>\<guillemotright> IMP PfP \<guillemotleft>Neg \<alpha>\<guillemotright> IMP PfP \<guillemotleft>Fls\<guillemotright>"
49,53c49,50
< text\<open>Gdel's second incompleteness theorem:
<       If consistent, our theory cannot prove its own consistency.\<close>
< theorem Goedel_II:
<   assumes "\<not> {} \<turnstile> Fls"
<     shows "\<not> {} \<turnstile> Neg (PfP \<lceil>Fls\<rceil>)"
---
> text\<open>Gdel's second incompleteness theorem: Our theory cannot prove its own consistency.\<close>
> theorem Goedel_II: "\<not> {} \<turnstile> Neg (PfP \<guillemotleft>Fls\<guillemotright>)"
55,59c52,54
<   from assms Goedel_I obtain \<delta> 
<     where diag: "{} \<turnstile> \<delta> IFF Neg (PfP \<lceil>\<delta>\<rceil>)"  "\<not> {} \<turnstile> \<delta>"
<       and gnd:  "ground_fm \<delta>"
<     by metis
<   have "{PfP \<lceil>\<delta>\<rceil>} \<turnstile> PfP \<lceil>PfP \<lceil>\<delta>\<rceil>\<rceil>"
---
>   obtain \<delta> where diag: "{} \<turnstile> \<delta> IFF Neg (PfP \<guillemotleft>\<delta>\<guillemotright>)"  "\<not> {} \<turnstile> \<delta>" and gnd:  "ground_fm \<delta>"
>     by (metis Goedel_I)
>   have "{PfP \<guillemotleft>\<delta>\<guillemotright>} \<turnstile> PfP \<guillemotleft>PfP \<guillemotleft>\<delta>\<guillemotright>\<guillemotright>"
61c56
<   moreover have "{PfP \<lceil>\<delta>\<rceil>} \<turnstile> PfP \<lceil>Neg (PfP \<lceil>\<delta>\<rceil>)\<rceil>"
---
>   moreover have "{PfP \<guillemotleft>\<delta>\<guillemotright>} \<turnstile> PfP \<guillemotleft>Neg (PfP \<guillemotleft>\<delta>\<guillemotright>)\<guillemotright>"
66c61
<   moreover have "ground_fm (PfP \<lceil>\<delta>\<rceil>)"
---
>   moreover have "ground_fm (PfP \<guillemotleft>\<delta>\<guillemotright>)"
68c63
<   ultimately have "{PfP \<lceil>\<delta>\<rceil>} \<turnstile> PfP \<lceil>Fls\<rceil>" using PfP_quot_contra  
---
>   ultimately have "{PfP \<guillemotleft>\<delta>\<guillemotright>} \<turnstile> PfP \<guillemotleft>Fls\<guillemotright>" using PfP_quot_contra  
70c65
<   thus "\<not> {} \<turnstile> Neg (PfP \<lceil>Fls\<rceil>)"
---
>   thus "\<not> {} \<turnstile> Neg (PfP \<guillemotleft>Fls\<guillemotright>)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Goedel_I.thy ../../AFPs/afp-2020/thys/Incompleteness/Goedel_I.thy
122c122
< lemma WR_ord_of: "WR (ord_of i) \<lbrakk>\<lceil>ORD_OF i\<rceil>\<rbrakk>e"
---
> lemma WR_ord_of: "WR (ord_of i) \<lbrakk>\<guillemotleft>ORD_OF i\<guillemotright>\<rbrakk>e"
126c126
< lemma WR_quot_Var: "WR \<lbrakk>\<lceil>Var x\<rceil>\<rbrakk>e \<lbrakk>\<lceil>\<lceil>Var x\<rceil>\<rceil>\<rbrakk>e"
---
> lemma WR_quot_Var: "WR \<lbrakk>\<guillemotleft>Var x\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>\<guillemotleft>Var x\<guillemotright>\<guillemotright>\<rbrakk>e"
133c133
< lemma prove_WRP:  "{} \<turnstile> WRP \<lceil>Var x\<rceil> \<lceil>\<lceil>Var x\<rceil>\<rceil>"
---
> lemma prove_WRP:  "{} \<turnstile> WRP \<guillemotleft>Var x\<guillemotright> \<guillemotleft>\<guillemotleft>Var x\<guillemotright>\<guillemotright>"
242c242
< lemma W_ord_of [simp]: "W (ord_of i) = \<lceil>ORD_OF i\<rceil>"
---
> lemma W_ord_of [simp]: "W (ord_of i) = \<guillemotleft>ORD_OF i\<guillemotright>"
557c557
< lemma HF_quot_coding_tm: "coding_tm t \<Longrightarrow> HF \<lbrakk>t\<rbrakk>e = \<lceil>t\<rceil>"
---
> lemma HF_quot_coding_tm: "coding_tm t \<Longrightarrow> HF \<lbrakk>t\<rbrakk>e = \<guillemotleft>t\<guillemotright>"
560c560
< lemma HR_quot_fm: fixes A::fm shows "HR \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<lbrakk>\<lceil>\<lceil>A\<rceil>\<rceil>\<rbrakk>e"
---
> lemma HR_quot_fm: fixes A::fm shows "HR \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<lbrakk>\<guillemotleft>\<guillemotleft>A\<guillemotright>\<guillemotright>\<rbrakk>e"
563c563
< lemma prove_HRP: fixes A::fm shows "{} \<turnstile> HRP \<lceil>A\<rceil> \<lceil>\<lceil>A\<rceil>\<rceil>"
---
> lemma prove_HRP: fixes A::fm shows "{} \<turnstile> HRP \<guillemotleft>A\<guillemotright> \<guillemotleft>\<guillemotleft>A\<guillemotright>\<guillemotright>"
595c595
< lemma prove_SubstFormP: "{} \<turnstile> SubstFormP \<lceil>Var i\<rceil> \<lceil>\<lceil>A\<rceil>\<rceil> \<lceil>A\<rceil> \<lceil>A(i::=\<lceil>A\<rceil>)\<rceil>"
---
> lemma prove_SubstFormP: "{} \<turnstile> SubstFormP \<guillemotleft>Var i\<guillemotright> \<guillemotleft>\<guillemotleft>A\<guillemotright>\<guillemotright> \<guillemotleft>A\<guillemotright> \<guillemotleft>A(i::=\<guillemotleft>A\<guillemotright>)\<guillemotright>"
598c598
< lemma prove_KRP: "{} \<turnstile> KRP \<lceil>Var i\<rceil> \<lceil>A\<rceil> \<lceil>A(i::=\<lceil>A\<rceil>)\<rceil>"
---
> lemma prove_KRP: "{} \<turnstile> KRP \<guillemotleft>Var i\<guillemotright> \<guillemotleft>A\<guillemotright> \<guillemotleft>A(i::=\<guillemotleft>A\<guillemotright>)\<guillemotright>"
600c600
<            intro!: Ex_I [where x="\<lceil>\<lceil>A\<rceil>\<rceil>"] prove_HRP prove_SubstFormP)
---
>            intro!: Ex_I [where x="\<guillemotleft>\<guillemotleft>A\<guillemotright>\<guillemotright>"] prove_HRP prove_SubstFormP)
612c612
< lemma KRP_subst_fm: "{KRP \<lceil>Var i\<rceil> \<lceil>\<beta>\<rceil> (Var j)} \<turnstile> Var j EQ \<lceil>\<beta>(i::=\<lceil>\<beta>\<rceil>)\<rceil>"
---
> lemma KRP_subst_fm: "{KRP \<guillemotleft>Var i\<guillemotright> \<guillemotleft>\<beta>\<guillemotright> (Var j)} \<turnstile> Var j EQ \<guillemotleft>\<beta>(i::=\<guillemotleft>\<beta>\<guillemotright>)\<guillemotright>"
619c619
<   obtains \<delta> where "{} \<turnstile> \<delta> IFF \<alpha>(i::=\<lceil>\<delta>\<rceil>)"  "supp \<delta> = supp \<alpha> - {atom i}"
---
>   obtains \<delta> where "{} \<turnstile> \<delta> IFF \<alpha>(i::=\<guillemotleft>\<delta>\<guillemotright>)"  "supp \<delta> = supp \<alpha> - {atom i}"
624,625c624,625
<   define \<beta> where "\<beta> = Ex j (KRP \<lceil>Var i\<rceil> (Var i) (Var j) AND \<alpha>(i ::= Var j))"
<   hence 1: "{} \<turnstile> \<beta>(i ::= \<lceil>\<beta>\<rceil>) IFF (Ex j (KRP \<lceil>Var i\<rceil> (Var i) (Var j) AND \<alpha>(i ::= Var j)))(i ::= \<lceil>\<beta>\<rceil>)"
---
>   define \<beta> where "\<beta> = Ex j (KRP \<guillemotleft>Var i\<guillemotright> (Var i) (Var j) AND \<alpha>(i ::= Var j))"
>   hence 1: "{} \<turnstile> \<beta>(i ::= \<guillemotleft>\<beta>\<guillemotright>) IFF (Ex j (KRP \<guillemotleft>Var i\<guillemotright> (Var i) (Var j) AND \<alpha>(i ::= Var j)))(i ::= \<guillemotleft>\<beta>\<guillemotright>)"
627,628c627,628
<   have 2: "{} \<turnstile> (Ex j (KRP \<lceil>Var i\<rceil> (Var i) (Var j) AND \<alpha>(i ::= Var j)))(i ::= \<lceil>\<beta>\<rceil>) IFF
<                 Ex j (Var j EQ \<lceil>\<beta>(i::=\<lceil>\<beta>\<rceil>)\<rceil> AND \<alpha>(i::=Var j))"
---
>   have 2: "{} \<turnstile> (Ex j (KRP \<guillemotleft>Var i\<guillemotright> (Var i) (Var j) AND \<alpha>(i ::= Var j)))(i ::= \<guillemotleft>\<beta>\<guillemotright>) IFF
>                 Ex j (Var j EQ \<guillemotleft>\<beta>(i::=\<guillemotleft>\<beta>\<guillemotright>)\<guillemotright> AND \<alpha>(i::=Var j))"
634c634
<   have 3: "{} \<turnstile> Ex j (Var j EQ \<lceil>\<beta>(i::=\<lceil>\<beta>\<rceil>)\<rceil> AND \<alpha>(i::=Var j)) IFF \<alpha>(i::=\<lceil>\<beta>(i::=\<lceil>\<beta>\<rceil>)\<rceil>)"
---
>   have 3: "{} \<turnstile> Ex j (Var j EQ \<guillemotleft>\<beta>(i::=\<guillemotleft>\<beta>\<guillemotright>)\<guillemotright> AND \<alpha>(i::=Var j)) IFF \<alpha>(i::=\<guillemotleft>\<beta>(i::=\<guillemotleft>\<beta>\<guillemotright>)\<guillemotright>)"
638c638
<     apply (auto intro: Ex_I [where x="\<lceil>\<beta>(i::=\<lceil>\<beta>\<rceil>)\<rceil>"])
---
>     apply (auto intro: Ex_I [where x="\<guillemotleft>\<beta>(i::=\<guillemotleft>\<beta>\<guillemotright>)\<guillemotright>"])
640c640
<   have "supp (\<beta>(i ::= \<lceil>\<beta>\<rceil>)) = supp \<alpha> - {atom i}" using atoms
---
>   have "supp (\<beta>(i ::= \<guillemotleft>\<beta>\<guillemotright>)) = supp \<alpha> - {atom i}" using atoms
646c646
< text\<open>Gdel's first incompleteness theorem: If consistent, our theory is incomplete.\<close>
---
> text\<open>Gdel's first incompleteness theorem: Our theory is incomplete. NB it is provably consistent\<close>
648,649c648
<   assumes "\<not> {} \<turnstile> Fls"
<   obtains \<delta> where "{} \<turnstile> \<delta> IFF Neg (PfP \<lceil>\<delta>\<rceil>)"  "\<not> {} \<turnstile> \<delta>"  "\<not> {} \<turnstile> Neg \<delta>"  
---
>   obtains \<delta> where "{} \<turnstile> \<delta> IFF Neg (PfP \<guillemotleft>\<delta>\<guillemotright>)"  "\<not> {} \<turnstile> \<delta>"  "\<not> {} \<turnstile> Neg \<delta>"  
653c652
<   obtain \<delta> where        "{} \<turnstile> \<delta> IFF Neg ((PfP (Var i))(i::=\<lceil>\<delta>\<rceil>))"
---
>   obtain \<delta> where        "{} \<turnstile> \<delta> IFF Neg ((PfP (Var i))(i::=\<guillemotleft>\<delta>\<guillemotright>))"
656c655
<   then have diag: "{} \<turnstile> \<delta> IFF Neg (PfP \<lceil>\<delta>\<rceil>)"
---
>   then have diag: "{} \<turnstile> \<delta> IFF Neg (PfP \<guillemotleft>\<delta>\<guillemotright>)"
659c658
<     by (metis Iff_MP_same NegNeg_D Neg_D Neg_cong assms proved_iff_proved_PfP)
---
>     by (metis Iff_MP_same NegNeg_D Neg_D Neg_cong consistent proved_iff_proved_PfP)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/II_Prelims.thy ../../AFPs/afp-2020/thys/Incompleteness/II_Prelims.thy
9c9
< lemma VarP_Var [intro]: "H \<turnstile> VarP \<lceil>Var i\<rceil>"
---
> lemma VarP_Var [intro]: "H \<turnstile> VarP \<guillemotleft>Var i\<guillemotright>"
11c11
<   have "{} \<turnstile> VarP \<lceil>Var i\<rceil>"
---
>   have "{} \<turnstile> VarP \<guillemotleft>Var i\<guillemotright>"
1693c1693
< corollary SubstTermP_Zero: "{TermP t} \<turnstile> SubstTermP \<lceil>Var v\<rceil> t Zero Zero"
---
> corollary SubstTermP_Zero: "{TermP t} \<turnstile> SubstTermP \<guillemotleft>Var v\<guillemotright> t Zero Zero"
1945c1945
< lemma SeqConstP_imp_SubstTermP: "{SeqConstP s kk c, TermP t} \<turnstile> SubstTermP \<lceil>Var w\<rceil> t c c" (*<*)
---
> lemma SeqConstP_imp_SubstTermP: "{SeqConstP s kk c, TermP t} \<turnstile> SubstTermP \<guillemotleft>Var w\<guillemotright> t c c" (*<*)
1953c1953
<   have "{ OrdP (Var k), TermP t } \<turnstile> All j (SeqConstP s (Var k) (Var j) IMP SubstTermP \<lceil>Var w\<rceil> t (Var j) (Var j))"
---
>   have "{ OrdP (Var k), TermP t } \<turnstile> All j (SeqConstP s (Var k) (Var j) IMP SubstTermP \<guillemotleft>Var w\<guillemotright> t (Var j) (Var j))"
1978c1978
<   hence "{OrdP (Var k), TermP t} \<turnstile> (SeqConstP s (Var k) (Var j) IMP SubstTermP \<lceil>Var w\<rceil> t (Var j) (Var j))(j::=c)"
---
>   hence "{OrdP (Var k), TermP t} \<turnstile> (SeqConstP s (Var k) (Var j) IMP SubstTermP \<guillemotleft>Var w\<guillemotright> t (Var j) (Var j))(j::=c)"
1980c1980
<   hence "{TermP t} \<turnstile> (SeqConstP s (Var k) c IMP SubstTermP \<lceil>Var w\<rceil> t c c)"
---
>   hence "{TermP t} \<turnstile> (SeqConstP s (Var k) c IMP SubstTermP \<guillemotleft>Var w\<guillemotright> t c c)"
1982c1982
<   hence "{TermP t} \<turnstile> (SeqConstP s (Var k) c IMP SubstTermP \<lceil>Var w\<rceil> t c c)(k::=kk)"
---
>   hence "{TermP t} \<turnstile> (SeqConstP s (Var k) c IMP SubstTermP \<guillemotleft>Var w\<guillemotright> t c c)(k::=kk)"
1988c1988
< theorem SubstTermP_Const: "{ConstP c, TermP t} \<turnstile> SubstTermP \<lceil>Var w\<rceil> t c c"
---
> theorem SubstTermP_Const: "{ConstP c, TermP t} \<turnstile> SubstTermP \<guillemotleft>Var w\<guillemotright> t c c"
2796c2796
< corollary PfP_implies_ModPon_PfP_quot: "\<lbrakk>H \<turnstile> PfP \<lceil>\<alpha> IMP \<beta>\<rceil>; H \<turnstile> PfP \<lceil>\<alpha>\<rceil>\<rbrakk> \<Longrightarrow> H \<turnstile> PfP \<lceil>\<beta>\<rceil>" 
---
> corollary PfP_implies_ModPon_PfP_quot: "\<lbrakk>H \<turnstile> PfP \<guillemotleft>\<alpha> IMP \<beta>\<guillemotright>; H \<turnstile> PfP \<guillemotleft>\<alpha>\<guillemotright>\<rbrakk> \<Longrightarrow> H \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>" 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Pf_Predicates.thy ../../AFPs/afp-2020/thys/Incompleteness/Pf_Predicates.thy
51c51
<  "Equality_ax \<equiv> { \<lbrakk>\<lceil>refl_ax\<rceil>\<rbrakk>e0, \<lbrakk>\<lceil>eq_cong_ax\<rceil>\<rbrakk>e0, \<lbrakk>\<lceil>mem_cong_ax\<rceil>\<rbrakk>e0, \<lbrakk>\<lceil>eats_cong_ax\<rceil>\<rbrakk>e0 }"
---
>  "Equality_ax \<equiv> { \<lbrakk>\<guillemotleft>refl_ax\<guillemotright>\<rbrakk>e0, \<lbrakk>\<guillemotleft>eq_cong_ax\<guillemotright>\<rbrakk>e0, \<lbrakk>\<guillemotleft>mem_cong_ax\<guillemotright>\<rbrakk>e0, \<lbrakk>\<guillemotleft>eats_cong_ax\<guillemotright>\<rbrakk>e0 }"
55c55
<     x EQ \<lceil>refl_ax\<rceil> OR x EQ \<lceil>eq_cong_ax\<rceil> OR x EQ \<lceil>mem_cong_ax\<rceil> OR x EQ \<lceil>eats_cong_ax\<rceil>"
---
>     x EQ \<guillemotleft>refl_ax\<guillemotright> OR x EQ \<guillemotleft>eq_cong_ax\<guillemotright> OR x EQ \<guillemotleft>mem_cong_ax\<guillemotright> OR x EQ \<guillemotleft>eats_cong_ax\<guillemotright>"
67c67
<   "HF_ax \<equiv> {\<lbrakk>\<lceil>HF1\<rceil>\<rbrakk>e0, \<lbrakk>\<lceil>HF2\<rceil>\<rbrakk>e0}"
---
>   "HF_ax \<equiv> {\<lbrakk>\<guillemotleft>HF1\<guillemotright>\<rbrakk>e0, \<lbrakk>\<guillemotleft>HF2\<guillemotright>\<rbrakk>e0}"
70c70
<   where "HF_axP x = x EQ \<lceil>HF1\<rceil> OR x EQ \<lceil>HF2\<rceil>"
---
>   where "HF_axP x = x EQ \<guillemotleft>HF1\<guillemotright> OR x EQ \<guillemotleft>HF2\<guillemotright>"
123c123
<   assumes "x \<in> Special_ax" shows "\<exists>A. x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> A \<in> special_axioms"
---
>   assumes "x \<in> Special_ax" shows "\<exists>A. x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> A \<in> special_axioms"
127c127
<   obtain fm::fm and u::tm where fm: "x = \<lbrakk>\<lceil>fm\<rceil>\<rbrakk>e" and  u: "y = \<lbrakk>\<lceil>u\<rceil>\<rbrakk>e"
---
>   obtain fm::fm and u::tm where fm: "x = \<lbrakk>\<guillemotleft>fm\<guillemotright>\<rbrakk>e" and  u: "y = \<lbrakk>\<guillemotleft>u\<guillemotright>\<rbrakk>e"
147c147
< lemma special_axioms_into_Special_ax: "A \<in> special_axioms \<Longrightarrow> \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<in> Special_ax"
---
> lemma special_axioms_into_Special_ax: "A \<in> special_axioms \<Longrightarrow> \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<in> Special_ax"
150c150
<   have "\<lbrakk>\<lceil>A(i::=t) IMP SyntaxN.Ex i A\<rceil>\<rbrakk>e =
---
>   have "\<lbrakk>\<guillemotleft>A(i::=t) IMP SyntaxN.Ex i A\<guillemotright>\<rbrakk>e =
162c162
< corollary Special_ax_eq_special_axioms: "Special_ax = (\<Union>A \<in> special_axioms. { \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e })"
---
> corollary Special_ax_eq_special_axioms: "Special_ax = (\<Union>A \<in> special_axioms. { \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e })"
232c232
<   assumes "x \<in> Induction_ax" shows "\<exists>A. x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> A \<in> induction_axioms"
---
>   assumes "x \<in> Induction_ax" shows "\<exists>A. x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> A \<in> induction_axioms"
239c239
<   obtain A::fm where A: "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" and wfresh: "atom (decode_Var w) \<sharp> A"
---
>   obtain A::fm where A: "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" and wfresh: "atom (decode_Var w) \<sharp> A"
241c241
<   then obtain A' A'' where A': "q_Imp (\<lbrakk>\<lceil>A\<rceil>\<rbrakk>e) (q_Imp xw xevw) = \<lbrakk>quot_dbfm A'\<rbrakk>e"
---
>   then obtain A' A'' where A': "q_Imp (\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e) (q_Imp xw xevw) = \<lbrakk>quot_dbfm A'\<rbrakk>e"
246c246
<   have x0: "x0 = \<lbrakk>\<lceil>A(decode_Var v::=Zero)\<rceil>\<rbrakk>e"  using I SubstForm_imp_subst_fm 
---
>   have x0: "x0 = \<lbrakk>\<guillemotleft>A(decode_Var v::=Zero)\<guillemotright>\<rbrakk>e"  using I SubstForm_imp_subst_fm 
248c248
<   have xw: "xw = \<lbrakk>\<lceil>Aw\<rceil>\<rbrakk>e"  using I SubstForm_imp_subst_fm
---
>   have xw: "xw = \<lbrakk>\<guillemotleft>Aw\<guillemotright>\<rbrakk>e"  using I SubstForm_imp_subst_fm
250c250
<   have "SubstForm v (\<lbrakk>\<lceil>Eats (Var (decode_Var v)) (Var (decode_Var w))\<rceil>\<rbrakk>e) x xevw"
---
>   have "SubstForm v (\<lbrakk>\<guillemotleft>Eats (Var (decode_Var v)) (Var (decode_Var w))\<guillemotright>\<rbrakk>e) x xevw"
252c252
<   hence xevw: "xevw = \<lbrakk>\<lceil>Ae\<rceil>\<rbrakk>e"
---
>   hence xevw: "xevw = \<lbrakk>\<guillemotleft>Ae\<guillemotright>\<rbrakk>e"
282c282
<   "A \<in> induction_axioms \<Longrightarrow> \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<in> Induction_ax"
---
>   "A \<in> induction_axioms \<Longrightarrow> \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<in> Induction_ax"
285c285
<   hence eq: "\<lbrakk>\<lceil>A(i::=Zero) IMP All i (All j (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j)))) IMP All i A\<rceil>\<rbrakk>e =
---
>   hence eq: "\<lbrakk>\<guillemotleft>A(i::=Zero) IMP All i (All j (A IMP A(i::=Var j) IMP A(i::=Eats (Var i) (Var j)))) IMP All i A\<guillemotright>\<rbrakk>e =
298c298
<     show "SubstForm (q_Var i) 0 \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e
---
>     show "SubstForm (q_Var i) 0 \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e
302c302
<     show "SubstForm (q_Var i) (q_Var j) \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\<rbrakk>e"
---
>     show "SubstForm (q_Var i) (q_Var j) \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<lbrakk>quot_dbfm (subst_dbfm (DBVar j) i (trans_fm [] A))\<rbrakk>e"
306c306
<     show "SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j)) \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e
---
>     show "SubstForm (q_Var i) (q_Eats (q_Var i) (q_Var j)) \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e
312c312
<            (q_Imp \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e
---
>            (q_Imp \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e
330c330
<     show "AbstForm (q_Var i) 0 (\<lbrakk>\<lceil>A\<rceil>\<rbrakk>e) \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e"
---
>     show "AbstForm (q_Var i) 0 (\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e) \<lbrakk>quot_dbfm (trans_fm [i] A)\<rbrakk>e"
336c336
<     show "VarNonOccForm (q_Var j) (\<lbrakk>\<lceil>A\<rceil>\<rbrakk>e)"
---
>     show "VarNonOccForm (q_Var j) (\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e)"
343c343
<   "Induction_ax = (\<Union>A \<in> induction_axioms. {\<lbrakk>\<lceil>A\<rceil>\<rbrakk>e})"
---
>   "Induction_ax = (\<Union>A \<in> induction_axioms. {\<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e})"
350c350
<  "Extra_ax \<equiv> {\<lbrakk>\<lceil>extra_axiom\<rceil>\<rbrakk>e0}"
---
>  "Extra_ax \<equiv> {\<lbrakk>\<guillemotleft>extra_axiom\<guillemotright>\<rbrakk>e0}"
356c356
<   where "AxiomP x \<equiv> x EQ \<lceil>extra_axiom\<rceil> OR SentP x OR Equality_axP x OR
---
>   where "AxiomP x \<equiv> x EQ \<guillemotleft>extra_axiom\<guillemotright> OR SentP x OR Equality_axP x OR
445c445
<   shows "\<exists>A B i. p = \<lbrakk>\<lceil>A IMP B\<rceil>\<rbrakk>e \<and> q = \<lbrakk>\<lceil>(Ex i A) IMP B\<rceil>\<rbrakk>e \<and> atom i \<sharp> B"
---
>   shows "\<exists>A B i. p = \<lbrakk>\<guillemotleft>A IMP B\<guillemotright>\<rbrakk>e \<and> q = \<lbrakk>\<guillemotleft>(Ex i A) IMP B\<guillemotright>\<rbrakk>e \<and> atom i \<sharp> B"
454c454
<   then obtain B::fm where B: "y = \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e" and vfresh: "atom (decode_Var v) \<sharp> B"
---
>   then obtain B::fm where B: "y = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e" and vfresh: "atom (decode_Var v) \<sharp> B"
456c456
<   obtain A::fm where A: "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" 
---
>   obtain A::fm where A: "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" 
460c460
<            "p = \<lbrakk>\<lceil>A IMP B\<rceil>\<rbrakk>e" using p A B
---
>            "p = \<lbrakk>\<guillemotleft>A IMP B\<guillemotright>\<rbrakk>e" using p A B
462c462
<   have "q = \<lbrakk>\<lceil>(Ex (decode_Var v) A) IMP B\<rceil>\<rbrakk>e" using q A B ax
---
>   have "q = \<lbrakk>\<guillemotleft>(Ex (decode_Var v) A) IMP B\<guillemotright>\<rbrakk>e" using q A B ax
468c468
< lemma Exists_intro: "atom i \<sharp> B \<Longrightarrow> Exists (\<lbrakk>\<lceil>A IMP B\<rceil>\<rbrakk>e) \<lbrakk>\<lceil>(Ex i A) IMP B\<rceil>\<rbrakk>e"
---
> lemma Exists_intro: "atom i \<sharp> B \<Longrightarrow> Exists (\<lbrakk>\<guillemotleft>A IMP B\<guillemotright>\<rbrakk>e) \<lbrakk>\<guillemotleft>(Ex i A) IMP B\<guillemotright>\<rbrakk>e"
474c474
<   "Exists p q \<longleftrightarrow> (\<exists>A B i. p = \<lbrakk>\<lceil>A IMP B\<rceil>\<rbrakk>e \<and> q = \<lbrakk>\<lceil>(Ex i A) IMP B\<rceil>\<rbrakk>e \<and> atom i \<sharp> B)"
---
>   "Exists p q \<longleftrightarrow> (\<exists>A B i. p = \<lbrakk>\<guillemotleft>A IMP B\<guillemotright>\<rbrakk>e \<and> q = \<lbrakk>\<guillemotleft>(Ex i A) IMP B\<guillemotright>\<rbrakk>e \<and> atom i \<sharp> B)"
522c522
<   shows "\<exists>A::fm. \<exists>i t. p = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> q = \<lbrakk>\<lceil>A(i::=t)\<rceil>\<rbrakk>e"
---
>   shows "\<exists>A::fm. \<exists>i t. p = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> q = \<lbrakk>\<guillemotleft>A(i::=t)\<guillemotright>\<rbrakk>e"
526c526
<   then obtain t::tm where substt: "SubstForm v \<lbrakk>\<lceil>t\<rceil>\<rbrakk>e p q"
---
>   then obtain t::tm where substt: "SubstForm v \<lbrakk>\<guillemotleft>t\<guillemotright>\<rbrakk>e p q"
529c529
<   obtain A where "p = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e"  "q = \<lbrakk>\<lceil>A(decode_Var v::=t)\<rceil>\<rbrakk>e"
---
>   obtain A where "p = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e"  "q = \<lbrakk>\<guillemotleft>A(decode_Var v::=t)\<guillemotright>\<rbrakk>e"
634c634
< lemma extra_axiom_imp_Pf: "Pf \<lbrakk>\<lceil>extra_axiom\<rceil>\<rbrakk>e"
---
> lemma extra_axiom_imp_Pf: "Pf \<lbrakk>\<guillemotleft>extra_axiom\<guillemotright>\<rbrakk>e"
636c636
<   have "\<lbrakk>\<lceil>extra_axiom\<rceil>\<rbrakk>e \<in> Extra_ax"
---
>   have "\<lbrakk>\<guillemotleft>extra_axiom\<guillemotright>\<rbrakk>e \<in> Extra_ax"
643c643
<   assumes "\<alpha> \<in> boolean_axioms" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
>   assumes "\<alpha> \<in> boolean_axioms" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
645c645
<   have "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<in> Sent" using assms
---
>   have "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<in> Sent" using assms
653c653
<   assumes "\<alpha> \<in> equality_axioms" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
>   assumes "\<alpha> \<in> equality_axioms" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
655c655
<   have "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<in> Equality_ax" using assms [unfolded equality_axioms_def]
---
>   have "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<in> Equality_ax" using assms [unfolded equality_axioms_def]
662c662
<   assumes "\<alpha> \<in> HF_axioms" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
>   assumes "\<alpha> \<in> HF_axioms" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
664c664
<   have "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<in> HF_ax" using assms [unfolded HF_axioms_def]
---
>   have "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<in> HF_ax" using assms [unfolded HF_axioms_def]
671c671
<   assumes "\<alpha> \<in> special_axioms" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
>   assumes "\<alpha> \<in> special_axioms" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
673c673
<   have "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<in> Special_ax"
---
>   have "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<in> Special_ax"
680c680
<   assumes "\<alpha> \<in> induction_axioms" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
>   assumes "\<alpha> \<in> induction_axioms" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
682c682
<   have "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<in> Induction_ax"
---
>   have "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<in> Induction_ax"
691c691
< lemma quot_ModPon_imp_Pf: "\<lbrakk>Pf \<lbrakk>\<lceil>\<alpha> IMP \<beta>\<rceil>\<rbrakk>e; Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e\<rbrakk> \<Longrightarrow> Pf \<lbrakk>\<lceil>\<beta>\<rceil>\<rbrakk>e"
---
> lemma quot_ModPon_imp_Pf: "\<lbrakk>Pf \<lbrakk>\<guillemotleft>\<alpha> IMP \<beta>\<guillemotright>\<rbrakk>e; Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e\<rbrakk> \<Longrightarrow> Pf \<lbrakk>\<guillemotleft>\<beta>\<guillemotright>\<rbrakk>e"
694c694
< lemma quot_Exists_imp_Pf: "\<lbrakk>Pf \<lbrakk>\<lceil>\<alpha> IMP \<beta>\<rceil>\<rbrakk>e; atom i \<sharp> \<beta>\<rbrakk> \<Longrightarrow> Pf \<lbrakk>\<lceil>Ex i \<alpha> IMP \<beta>\<rceil>\<rbrakk>e"
---
> lemma quot_Exists_imp_Pf: "\<lbrakk>Pf \<lbrakk>\<guillemotleft>\<alpha> IMP \<beta>\<guillemotright>\<rbrakk>e; atom i \<sharp> \<beta>\<rbrakk> \<Longrightarrow> Pf \<lbrakk>\<guillemotleft>Ex i \<alpha> IMP \<beta>\<guillemotright>\<rbrakk>e"
698c698
< lemma proved_imp_Pf: assumes "H \<turnstile> \<alpha>" "H={}" shows "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e"
---
> lemma proved_imp_Pf: assumes "H \<turnstile> \<alpha>" "H={}" shows "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e"
729c729
< corollary proved_imp_proved_PfP: "{} \<turnstile> \<alpha> \<Longrightarrow> {} \<turnstile> PfP \<lceil>\<alpha>\<rceil>"
---
> corollary proved_imp_proved_PfP: "{} \<turnstile> \<alpha> \<Longrightarrow> {} \<turnstile> PfP \<guillemotleft>\<alpha>\<guillemotright>"
736c736
<   assumes "x \<in> Sent" shows "\<exists>A. x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   assumes "x \<in> Sent" shows "\<exists>A. x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
741c741
<          where A: "y = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" and B: "z = \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e" and C: "w = \<lbrakk>\<lceil>C\<rceil>\<rbrakk>e"
---
>          where A: "y = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" and B: "z = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e" and C: "w = \<lbrakk>\<guillemotleft>C\<guillemotright>\<rbrakk>e"
743c743
<   have "\<exists>A. q_Imp y y = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   have "\<exists>A. q_Imp y y = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
745c745
<   moreover have "\<exists>A. q_Imp y (q_Disj y z) = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   moreover have "\<exists>A. q_Imp y (q_Disj y z) = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
748c748
<   moreover have "\<exists>A. q_Imp (q_Disj y y) y = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   moreover have "\<exists>A. q_Imp (q_Disj y y) y = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
751c751
<   moreover have "\<exists>A. q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   moreover have "\<exists>A. q_Imp (q_Disj y (q_Disj z w)) (q_Disj (q_Disj y z) w) = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
754c754
<   moreover have "\<exists>A. q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   moreover have "\<exists>A. q_Imp (q_Disj y z) (q_Imp (q_Disj (q_Neg y) w) (q_Disj z w)) = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
762c762
<   assumes "x \<in> Extra_ax" obtains A where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   assumes "x \<in> Extra_ax" obtains A where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
767c767
<   assumes "x \<in> Equality_ax" obtains A where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   assumes "x \<in> Equality_ax" obtains A where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
772c772
<   assumes "x \<in> HF_ax" obtains A where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
>   assumes "x \<in> HF_ax" obtains A where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
777c777
<   assumes "x \<in> Special_ax" obtains A where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" "{} \<turnstile> A"
---
>   assumes "x \<in> Special_ax" obtains A where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" "{} \<turnstile> A"
781c781
<   assumes "x \<in> Induction_ax" obtains A where "x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" "{} \<turnstile> A"
---
>   assumes "x \<in> Induction_ax" obtains A where "x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" "{} \<turnstile> A"
784c784
< lemma Exists_imp_hfthm: "\<lbrakk>Exists \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e y; {} \<turnstile> A\<rbrakk> \<Longrightarrow> \<exists>B. y = \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e \<and> {} \<turnstile> B"
---
> lemma Exists_imp_hfthm: "\<lbrakk>Exists \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e y; {} \<turnstile> A\<rbrakk> \<Longrightarrow> \<exists>B. y = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> B"
787c787
< lemma Subst_imp_hfthm:  "\<lbrakk>Subst \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e y; {} \<turnstile> A\<rbrakk> \<Longrightarrow> \<exists>B. y = \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e \<and> {} \<turnstile> B"
---
> lemma Subst_imp_hfthm:  "\<lbrakk>Subst \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e y; {} \<turnstile> A\<rbrakk> \<Longrightarrow> \<exists>B. y = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> B"
790c790
< lemma eval_Neg_imp_Neg: "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e = q_Neg x \<Longrightarrow> \<exists>A. \<alpha> = Neg A \<and> \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e = x" 
---
> lemma eval_Neg_imp_Neg: "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e = q_Neg x \<Longrightarrow> \<exists>A. \<alpha> = Neg A \<and> \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e = x" 
793c793
< lemma eval_Disj_imp_Disj: "\<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e = q_Disj x y \<Longrightarrow> \<exists>A B. \<alpha> = A OR B \<and> \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e = x \<and> \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e = y"
---
> lemma eval_Disj_imp_Disj: "\<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e = q_Disj x y \<Longrightarrow> \<exists>A B. \<alpha> = A OR B \<and> \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e = x \<and> \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e = y"
796c796
< lemma Prf_imp_proved: assumes "Prf s k x" shows "\<exists>A. x = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e \<and> {} \<turnstile> A"
---
> lemma Prf_imp_proved: assumes "Prf s k x" shows "\<exists>A. x = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e \<and> {} \<turnstile> A"
804c804
<   then obtain A::fm and B::fm where "y = \<lbrakk>\<lceil>A\<rceil>\<rbrakk>e" "{} \<turnstile> A" "z = \<lbrakk>\<lceil>B\<rceil>\<rbrakk>e" "{} \<turnstile> B"
---
>   then obtain A::fm and B::fm where "y = \<lbrakk>\<guillemotleft>A\<guillemotright>\<rbrakk>e" "{} \<turnstile> A" "z = \<lbrakk>\<guillemotleft>B\<guillemotright>\<rbrakk>e" "{} \<turnstile> B"
810c810
< corollary Pf_quot_imp_is_proved: "Pf \<lbrakk>\<lceil>\<alpha>\<rceil>\<rbrakk>e \<Longrightarrow> {} \<turnstile> \<alpha>"
---
> corollary Pf_quot_imp_is_proved: "Pf \<lbrakk>\<guillemotleft>\<alpha>\<guillemotright>\<rbrakk>e \<Longrightarrow> {} \<turnstile> \<alpha>"
814c814
< theorem proved_iff_proved_PfP: "{} \<turnstile> \<alpha> \<longleftrightarrow> {} \<turnstile> PfP \<lceil>\<alpha>\<rceil>"
---
> theorem proved_iff_proved_PfP: "{} \<turnstile> \<alpha> \<longleftrightarrow> {} \<turnstile> PfP \<guillemotleft>\<alpha>\<guillemotright>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Pseudo_Coding.thy ../../AFPs/afp-2020/thys/Incompleteness/Pseudo_Coding.thy
15c15
< lemma NEQ_quot_tm: "i\<noteq>j \<Longrightarrow> {} \<turnstile> \<lceil>Var i\<rceil> NEQ \<lceil>Var j\<rceil>"
---
> lemma NEQ_quot_tm: "i\<noteq>j \<Longrightarrow> {} \<turnstile> \<guillemotleft>Var i\<guillemotright> NEQ \<guillemotleft>Var j\<guillemotright>"
19c19
< lemma EQ_quot_tm_Fls: "i\<noteq>j \<Longrightarrow> insert (\<lceil>Var i\<rceil> EQ \<lceil>Var j\<rceil>) H \<turnstile> Fls"
---
> lemma EQ_quot_tm_Fls: "i\<noteq>j \<Longrightarrow> insert (\<guillemotleft>Var i\<guillemotright> EQ \<guillemotleft>Var j\<guillemotright>) H \<turnstile> Fls"
206c206
<   fixes t::tm shows "finite V \<Longrightarrow> ssubst \<lceil>t\<rceil> V F = \<lceil>t\<rceil>"
---
>   fixes t::tm shows "finite V \<Longrightarrow> ssubst \<guillemotleft>t\<guillemotright> V F = \<guillemotleft>t\<guillemotright>"
210c210
<   fixes A::fm shows "finite V \<Longrightarrow> ssubst \<lceil>A\<rceil> V F = \<lceil>A\<rceil>"
---
>   fixes A::fm shows "finite V \<Longrightarrow> ssubst \<guillemotleft>A\<guillemotright> V F = \<guillemotleft>A\<guillemotright>"
224c224
<    \<turnstile> SubstTermP \<lceil>Var w\<rceil> (F w) 
---
>    \<turnstile> SubstTermP \<guillemotleft>Var w\<guillemotright> (F w) 
267c267
<    \<turnstile> SubstFormP \<lceil>Var w\<rceil> (F w)
---
>    \<turnstile> SubstFormP \<guillemotleft>Var w\<guillemotright> (F w)
295c295
<    \<turnstile> SubstFormP \<lceil>Var w\<rceil> (F w) 
---
>    \<turnstile> SubstFormP \<guillemotleft>Var w\<guillemotright> (F w) 
308c308
<   assumes \<beta>: "{} \<turnstile> PfP \<lceil>\<beta>\<rceil>"
---
>   assumes \<beta>: "{} \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/Quote.thy ../../AFPs/afp-2020/thys/Incompleteness/Quote.thy
521c521
<   have "{} \<turnstile> PfP \<lceil>\<beta>\<rceil>"
---
>   have "{} \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>"
1409c1409
<     shows "{\<alpha>} \<turnstile> PfP \<lceil>\<alpha>\<rceil>"
---
>     shows "{\<alpha>} \<turnstile> PfP \<guillemotleft>\<alpha>\<guillemotright>"
1413c1413
<   hence "{\<beta>} \<turnstile> PfP \<lceil>\<beta>\<rceil>" using star [of \<beta> 0 "{}"]
---
>   hence "{\<beta>} \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>" using star [of \<beta> 0 "{}"]
1415c1415
<   then have "{\<alpha>} \<turnstile> PfP \<lceil>\<beta>\<rceil>" using \<beta>
---
>   then have "{\<alpha>} \<turnstile> PfP \<guillemotleft>\<beta>\<guillemotright>" using \<beta>
1417c1417
<   moreover have "{} \<turnstile> PfP \<lceil>\<beta> IMP \<alpha>\<rceil>" using \<beta>
---
>   moreover have "{} \<turnstile> PfP \<guillemotleft>\<beta> IMP \<alpha>\<guillemotright>" using \<beta>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Incompleteness/SyntaxN.thy ../../AFPs/afp-2020/thys/Incompleteness/SyntaxN.thy
1329c1329
< subsection\<open>The Formula @{term Fls}\<close>
---
> subsection\<open>The Formula @{term Fls}; Consistency of the Calculus\<close>
1387a1388,1392
> 
> text\<open>Thanks to Andrei Popescu for pointing out that consistency was provable here.\<close>
> proposition consistent: "\<not> {} \<turnstile> Fls"
>   by (meson empty_iff eval_fm.simps(4) hfthm_sound truth_provable)
> 
==========
IP_Addresses
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IP_Addresses/CIDR_Split.thy ../../AFPs/afp-2020/thys/IP_Addresses/CIDR_Split.thy
364,365c364,365
<         pt && ~~ pfxm_mask x = pfxm_prefix x;
<         pt && ~~ pfxm_mask xa = pfxm_prefix xa
---
>         pt && ~~ (pfxm_mask x) = pfxm_prefix x;
>         pt && ~~ (pfxm_mask xa) = pfxm_prefix xa
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IP_Addresses/IP_Address.thy ../../AFPs/afp-2020/thys/IP_Addresses/IP_Address.thy
104c104
<            ipset_from_netmask base (NOT mask (LENGTH('i) - len))"
---
>            ipset_from_netmask base (NOT (mask (LENGTH('i) - len)))"
118c118
<       "((mask l << LENGTH('i) - l) :: 'i::len word) = NOT mask (LENGTH('i) - l)"
---
>       "((mask l << LENGTH('i) - l) :: 'i::len word) = NOT (mask (LENGTH('i) - l))"
120c120
<     have *: "base AND NOT mask (LENGTH('i) - l) = base"
---
>     have *: "base AND NOT (mask (LENGTH('i) - l)) = base"
122c122
<     hence **: "base AND NOT mask (LENGTH('i) - l) OR mask (LENGTH('i) - l) =
---
>     hence **: "base AND NOT (mask (LENGTH('i) - l)) OR mask (LENGTH('i) - l) =
124c124
<     have "ipset_from_netmask base (NOT mask (LENGTH('i) - l)) =
---
>     have "ipset_from_netmask base (NOT (mask (LENGTH('i) - l))) =
145,146c145,146
<     shows "ipset_from_netmask (base AND NOT mask (LENGTH('i) - m))
<                               (NOT mask (LENGTH('i) - m))
---
>     shows "ipset_from_netmask (base AND NOT (mask (LENGTH('i) - m)))
>                               (NOT (mask (LENGTH('i) - m)))
148c148
<              ipset_from_netmask base (NOT mask (LENGTH('i) - m))"
---
>              ipset_from_netmask base (NOT (mask (LENGTH('i) - m)))"
156c156
<       {j . i AND NOT mask (LENGTH('i) - r) = j AND NOT mask (LENGTH('i) - r)}"
---
>       {j . i AND NOT (mask (LENGTH('i) - r)) = j AND NOT (mask (LENGTH('i) - r))}"
164c164
<       "((mask len << LENGTH('a) - len) :: 'a::len word) = NOT mask (LENGTH('a) - len)"
---
>       "((mask len << LENGTH('a) - len) :: 'a::len word) = NOT (mask (LENGTH('a) - len))"
166c166
<     have 1: "mask (len - m) AND base AND NOT mask (len - m) = 0"
---
>     have 1: "mask (len - m) AND base AND NOT (mask (len - m)) = 0"
170,171c170,171
<            (a \<in> ipset_from_netmask pfxm_p (NOT mask (LENGTH('i) - len))) \<longleftrightarrow>
<            (pfxm_p = NOT mask (LENGTH('i) - len) AND a)" for a::"'i::len word" and pfxm_p
---
>            (a \<in> ipset_from_netmask pfxm_p (NOT (mask (LENGTH('i) - len)))) \<longleftrightarrow>
>            (pfxm_p = NOT (mask (LENGTH('i) - len)) AND a)" for a::"'i::len word" and pfxm_p
180,181c180,181
<       "(x \<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) \<longleftrightarrow>
<        (base && ~~ mask (LENGTH('i) - len) = x && ~~ mask (LENGTH('i) - len))" for x
---
>       "(x \<in> ipset_from_netmask base (~~ (mask (LENGTH('i) - len)))) \<longleftrightarrow>
>        (base && ~~ (mask (LENGTH('i) - len)) = x && ~~ (mask (LENGTH('i) - len)))" for x
183c183
<     unfolding word_bw_comms(1)[of _ " ~~ mask (LENGTH('i) - len)"] by simp
---
>     unfolding word_bw_comms(1)[of _ " ~~ (mask (LENGTH('i) - len))"] by simp
287,288c287,288
<       assumes "r2 \<le> r1" "i && ~~ mask r2 = x && ~~ mask r2"
<       shows "i && ~~ mask r1 = x && ~~ mask r1"
---
>       assumes "r2 \<le> r1" "i && ~~ (mask r2) = x && ~~ (mask r2)"
>       shows "i && ~~ (mask r1) = x && ~~ (mask r1)"
290c290
<       have "i AND NOT mask r1 = (i && ~~ mask r2) && ~~ mask r1" (is "_ = ?w && _")
---
>       have "i AND NOT (mask r1) = (i && ~~ (mask r2)) && ~~ (mask r1)" (is "_ = ?w && _")
292,293c292,293
<       also have "?w = x && ~~ mask r2" by fact
<       also have "\<dots> && ~~ mask r1 = x && ~~ mask r1"
---
>       also have "?w = x && ~~ (mask r2)" by fact
>       also have "\<dots> && ~~ (mask r1) = x && ~~ (mask r1)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IP_Addresses/IPv6.thy ../../AFPs/afp-2020/thys/IP_Addresses/IPv6.thy
473c473
<        have "\<And>w n wa. ((w::'a::len word) && ~~ mask n) && (wa << n) = (w >> n) && wa << n"
---
>        have "\<And>w n wa. ((w::'a::len word) && ~~ (mask n)) && (wa << n) = (w >> n) && wa << n"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/IP_Addresses/Prefix_Match.thy ../../AFPs/afp-2020/thys/IP_Addresses/Prefix_Match.thy
38c38
<   shows "valid_prefix (PrefixMatch (base AND NOT mask (len_of TYPE ('a) - len)) len)"
---
>   shows "valid_prefix (PrefixMatch (base AND NOT (mask (len_of TYPE ('a) - len))) len)"
40c40
<   have "mask (len - m) AND base AND NOT mask (len - m) = 0"
---
>   have "mask (len - m) AND base AND NOT (mask (len - m)) = 0"
105c105
<     "prefix_match_semantics m a \<equiv> pfxm_prefix m = (NOT pfxm_mask m) AND a"
---
>     "prefix_match_semantics m a \<equiv> pfxm_prefix m = NOT (pfxm_mask m) AND a"
143c143
<     shows "ipset_from_netmask (pfxm_prefix pfx) (NOT pfxm_mask pfx) =
---
>     shows "ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =
152c152
<             a \<in> ipset_from_netmask (pfxm_prefix pfx) (NOT pfxm_mask pfx)"
---
>             a \<in> ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))"
173c173
<            "(prefix_to_wordset pfx) = ipset_from_netmask (pfxm_prefix pfx) (NOT pfxm_mask pfx)"
---
>            "(prefix_to_wordset pfx) = ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))"
178c178
<         have *: "pfxm_prefix pfx AND NOT pfxm_mask pfx = pfxm_prefix pfx"
---
>         have *: "pfxm_prefix pfx AND NOT (pfxm_mask pfx) = pfxm_prefix pfx"
181c181
<         hence **: "pfxm_prefix pfx AND NOT pfxm_mask pfx OR pfxm_mask pfx =
---
>         hence **: "pfxm_prefix pfx AND NOT (pfxm_mask pfx) OR pfxm_mask pfx =
186c186
<       have "((mask len)::'a::len word) << LENGTH('a) - len = ~~ mask (LENGTH('a) - len)"
---
>       have "((mask len)::'a::len word) << LENGTH('a) - len = ~~ (mask (LENGTH('a) - len))"
190c190
<           NOT pfxm_mask pfx"
---
>           NOT (pfxm_mask pfx)"
194c194
<         "ipset_from_netmask (pfxm_prefix pfx) (NOT pfxm_mask pfx) =
---
>         "ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =
==========
Iptables_Semantics
Only in ../../AFPs/afp-2020/thys/Iptables_Semantics: Code_haskell.thy
Only in ../../AFPs/afp-2019/thys/Iptables_Semantics/Examples: Code_haskell.thy
Only in ../../AFPs/afp-2019/thys/Iptables_Semantics/Examples: Example_Semantics.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Iptables_Semantics/Examples/Parser_Test/Parser6_Test.thy ../../AFPs/afp-2020/thys/Iptables_Semantics/Examples/Parser_Test/Parser6_Test.thy
2c2
< imports "../../Primitive_Matchers/Parser6"
---
> imports Iptables_Semantics.Parser6
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Iptables_Semantics/Examples/Synology_Diskstation_DS414/Analyze_Synology_Diskstation.thy ../../AFPs/afp-2020/thys/Iptables_Semantics/Examples/Synology_Diskstation_DS414/Analyze_Synology_Diskstation.thy
4c4
<   "../../Primitive_Matchers/Parser6"
---
>   Iptables_Semantics.Parser6
Only in ../../AFPs/afp-2020/thys/Iptables_Semantics: Examples_Big
Only in ../../AFPs/afp-2020/thys/Iptables_Semantics: Example_Semantics.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Iptables_Semantics/Primitive_Matchers/Parser6.thy ../../AFPs/afp-2020/thys/Iptables_Semantics/Primitive_Matchers/Parser6.thy
3c3
< imports Iptables_Semantics.Code_Interface
---
> imports Code_Interface
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Iptables_Semantics/Semantics.thy ../../AFPs/afp-2020/thys/Iptables_Semantics/Semantics.thy
496c496
<     ("_\<turnstile>' \<langle>_, _\<rangle> \<Rightarrow> _"  [60,20,98,98] 89)
---
>     ("_\<turnstile>'' \<langle>_, _\<rangle> \<Rightarrow> _"  [60,20,98,98] 89)
==========
Irrationality_J_Hancl
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy ../../AFPs/afp-2020/thys/Irrationality_J_Hancl/Irrationality_J_Hancl.thy
438c438,439
<     by (smt linordered_field_class.sign_simps(44))
---
>       zero_less_mult_pos [of B "Max (ff ` {s..Suc t})"]
>     by simp
713,714c714
<         apply (simp add: powr_half_sqrt [symmetric])
<         by (simp add: powr_half_sqrt [symmetric] linordered_field_class.sign_simps(24) powr_powr)
---
>         by (simp add: powr_half_sqrt [symmetric] powr_powr ac_simps)
722c722
<         by (auto simp add:powr_divide inverse_eq_divide sqrt_divide_self_eq)
---
>         by (auto simp add:powr_divide less_imp_le inverse_eq_divide sqrt_divide_self_eq)
791,793c791
<     apply (elim Lim_transform_eventually[rotated])
<     apply (rule eventuallyI)
<     using a b by (auto simp add:divide_simps abs_of_pos)
---
>     using a b by (force simp add:divide_simps abs_of_pos intro: Lim_transform_eventually)
1039,1041c1037
<           apply (subst powr_divide)
<             apply (simp_all add:n1_def n2_def)
<           by (smt divide_nonneg_nonneg zero_le_power)
---
>           by (simp add:n1_def n2_def powr_divide)
1043,1044c1039
<           apply (subst powr_powr)
<           by simp
---
>           by (simp add: powr_powr)
1051c1046
<             using \<open>x\<ge>1\<close> by (auto simp add:power_Suc[symmetric] simp del:power_Suc)
---
>             using \<open>x\<ge>1\<close> by (auto simp flip:power_Suc)
==========
Isabelle_C
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Isabelle_C/C11-FrontEnd/C_Appendices.thy ../../AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/C_Appendices.thy
41c41
<           "Isar_Ref.Base"
---
>           Isar_Ref.Base
358c358
< \<^file>\<open>$ISABELLE_HOME/doc/isar-ref.pdf\<close>.
---
> \<^url>\<open>https://isabelle.in.tum.de/doc/isar-ref.pdf\<close>.
376c376
< Note that since Isabelle2019, Isabelle uses a virtual file-system. This has the consequence, that
---
> Note that since Isabelle2019, Isabelle/C uses a virtual file-system. This has the consequence, that
800c800
<   \<^url>\<open>https://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_integrated.thy\<close>, where the
---
>   \<^url>\<open>https://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_TEC.thy\<close>, where the
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Isabelle_C/C11-FrontEnd/examples/C0.thy ../../AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/examples/C0.thy
46a47,48
> subsection \<open>Comments, Keywords and Pragmas\<close>
> 
106a109,110
> subsection \<open>Scala/jEdit Latency on Multiple Bindings\<close>
> 
128a133,143
> 
> text \<open> Select inside the ball, experience the latency.
> A special keyboard combination ``Ctrl-like key\<^footnote>\<open>on Apple: Cmd\<close> + Shift +
> Enter'' lets Isabelle/Scala/jEdit enter in a mode where the selected bound occurrences can be all
> simultaneously replaced by new input characters typed on the keyboard. (The ``select-entity'' action
> exists since Isabelle2016-1, see the respective section ``Prover IDE -- Isabelle/Scala/jEdit'' in
> the NEWS.)\<close>
> 
> subsection \<open>Lexing and Parsing Obfuscated Sources\<close>
> 
> text \<open>Another lexer/parser - stress test: parsing an obfuscated C source.\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Isabelle_C/C11-FrontEnd/examples/C_paper.thy ../../AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/examples/C_paper.thy
146c146
< \<comment> \<open>See also: \<^url>\<open>https://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_integrated.thy\<close>\<close>
---
> \<comment> \<open>See also: \<^url>\<open>https://gitlri.lri.fr/ftuong/isabelle_c/blob/C/C11-BackEnds/AutoCorres_wrapper/examples/IsPrime_TEC.thy\<close>\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Isabelle_C/C11-FrontEnd/src/C_Command.thy ../../AFPs/afp-2020/thys/Isabelle_C/C11-FrontEnd/src/C_Command.thy
560c560
<     val ctxt' = Variable.auto_fixes t ctxt;
---
>     val ctxt' = Proof_Context.augment t ctxt;
==========
Jacobson_Basic_Algebra
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Jacobson_Basic_Algebra/Group_Theory.thy ../../AFPs/afp-2020/thys/Jacobson_Basic_Algebra/Group_Theory.thy
1324,1325c1324,1325
< notation target.invertible ("invertible' _" [100] 100)
< notation target.inverse ("inverse' _" [100] 100)
---
> notation target.invertible ("invertible'' _" [100] 100)
> notation target.inverse ("inverse'' _" [100] 100)
==========
Jinja
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Jinja/BV/JVM_SemiType.thy ../../AFPs/afp-2020/thys/Jinja/BV/JVM_SemiType.thy
57c57
<     ("_ \<turnstile> _ \<le>' _" [71,71,71] 70)
---
>     ("_ \<turnstile> _ \<le>'' _" [71,71,71] 70)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Jinja/J/Progress.thy ../../AFPs/afp-2020/thys/Jinja/J/Progress.thy
34c34
<         ("_,_,_ \<turnstile> _ :' _"   [51,51,51]50)
---
>         ("_,_,_ \<turnstile> _ :'' _"   [51,51,51]50)
==========
JinjaThreads
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/BV/JVM_SemiType.thy ../../AFPs/afp-2020/thys/JinjaThreads/BV/JVM_SemiType.thy
59c59
<   ("_ \<turnstile> _ \<le>' _" [71,71,71] 70)
---
>   ("_ \<turnstile> _ \<le>'' _" [71,71,71] 70)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/Compiler/J1JVMBisim.thy ../../AFPs/afp-2020/thys/JinjaThreads/Compiler/J1JVMBisim.thy
523c523
<   ("_,_,_,_ \<turnstile>' _ \<leftrightarrow> _" [50, 0, 0, 0, 0, 50] 100)
---
>   ("_,_,_,_ \<turnstile>'' _ \<leftrightarrow> _" [50, 0, 0, 0, 0, 50] 100)
528c528
<   ("_,_,_,_ \<turnstile>' _ [\<leftrightarrow>] _" [50, 0, 0, 0, 0, 50] 100)
---
>   ("_,_,_,_ \<turnstile>'' _ [\<leftrightarrow>] _" [50, 0, 0, 0, 0, 50] 100)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/J/Annotate.thy ../../AFPs/afp-2020/thys/JinjaThreads/J/Annotate.thy
233c233
< definition Anno_code :: "'addr J_prog \<Rightarrow> env \<Rightarrow> 'addr expr \<Rightarrow> 'addr expr \<Rightarrow> bool" ("_,_ \<turnstile> _ \<leadsto>' _"   [51,0,0,51]50)
---
> definition Anno_code :: "'addr J_prog \<Rightarrow> env \<Rightarrow> 'addr expr \<Rightarrow> 'addr expr \<Rightarrow> bool" ("_,_ \<turnstile> _ \<leadsto>'' _"   [51,0,0,51]50)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/J/WellType.thy ../../AFPs/afp-2020/thys/JinjaThreads/J/WellType.thy
363c363
< definition WT_code :: "'addr J_prog \<Rightarrow> env \<Rightarrow> 'addr expr \<Rightarrow> ty \<Rightarrow> bool" ("_,_ \<turnstile> _ ::' _" [51,51,51] 50)
---
> definition WT_code :: "'addr J_prog \<Rightarrow> env \<Rightarrow> 'addr expr \<Rightarrow> ty \<Rightarrow> bool" ("_,_ \<turnstile> _ ::'' _" [51,51,51] 50)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/MM/JMM_Type2.thy ../../AFPs/afp-2020/thys/JinjaThreads/MM/JMM_Type2.thy
143c143
< abbreviation jmm'_hext :: "'m prog \<Rightarrow> JMM_heap \<Rightarrow> JMM_heap \<Rightarrow> bool" ("_ \<turnstile> _ \<unlhd>jmm' _" [51,51,51] 50)
---
> abbreviation jmm'_hext :: "'m prog \<Rightarrow> JMM_heap \<Rightarrow> JMM_heap \<Rightarrow> bool" ("_ \<turnstile> _ \<unlhd>jmm'' _" [51,51,51] 50)
147c147
<   ("_,_ \<turnstile>jmm' _ :\<le> _"  [51,51,51,51] 50)
---
>   ("_,_ \<turnstile>jmm'' _ :\<le> _"  [51,51,51,51] 50)
151c151
<   ("_,_ \<turnstile>jmm' _@_ : _" [50, 50, 50, 50, 50] 51)
---
>   ("_,_ \<turnstile>jmm'' _@_ : _" [50, 50, 50, 50, 50] 51)
155c155
<   ("_,_ \<turnstile>jmm' _ [:\<le>] _"  [51,51,51,51] 50)
---
>   ("_,_ \<turnstile>jmm'' _ [:\<le>] _"  [51,51,51,51] 50)
158c158
< abbreviation jmm'_tconf :: "'m prog \<Rightarrow> JMM_heap \<Rightarrow> addr \<Rightarrow> bool" ("_,_ \<turnstile>jmm' _ \<surd>t" [51,51,51] 50)
---
> abbreviation jmm'_tconf :: "'m prog \<Rightarrow> JMM_heap \<Rightarrow> addr \<Rightarrow> bool" ("_,_ \<turnstile>jmm'' _ \<surd>t" [51,51,51] 50)
389c389
< notation jmm'.external_WT' ("_,_ \<turnstile>jmm' (_\<bullet>_'(_')) : _" [50,0,0,0,50] 60)
---
> notation jmm'.external_WT' ("_,_ \<turnstile>jmm'' (_\<bullet>_'(_')) : _" [50,0,0,0,50] 60)
401c401
<   ("_,_ \<turnstile>jmm' (\<langle>(_\<bullet>_'(_')),/_\<rangle>) -_\<rightarrow>ext (\<langle>(_),/(_)\<rangle>)" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)
---
>   ("_,_ \<turnstile>jmm'' (\<langle>(_\<bullet>_'(_')),/_\<rangle>) -_\<rightarrow>ext (\<langle>(_),/(_)\<rangle>)" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/JinjaThreads/MM/JMM_Type.thy ../../AFPs/afp-2020/thys/JinjaThreads/MM/JMM_Type.thy
86,90c86,90
< notation jmm'.hext ("_ \<unlhd>jmm' _" [51,51] 50)
< notation jmm'.conf ("_,_ \<turnstile>jmm' _ :\<le> _"  [51,51,51,51] 50)
< notation jmm'.addr_loc_type ("_,_ \<turnstile>jmm' _@_ : _" [50, 50, 50, 50, 50] 51)
< notation jmm'.confs ("_,_ \<turnstile>jmm' _ [:\<le>] _"  [51,51,51,51] 50)
< notation jmm'.tconf ("_,_ \<turnstile>jmm' _ \<surd>t" [51,51,51] 50)
---
> notation jmm'.hext ("_ \<unlhd>jmm'' _" [51,51] 50)
> notation jmm'.conf ("_,_ \<turnstile>jmm'' _ :\<le> _"  [51,51,51,51] 50)
> notation jmm'.addr_loc_type ("_,_ \<turnstile>jmm'' _@_ : _" [50, 50, 50, 50, 50] 51)
> notation jmm'.confs ("_,_ \<turnstile>jmm'' _ [:\<le>] _"  [51,51,51,51] 50)
> notation jmm'.tconf ("_,_ \<turnstile>jmm'' _ \<surd>t" [51,51,51] 50)
144c144
< abbreviation (input) jmm'_hconf :: "'m prog \<Rightarrow> 'addr JMM_heap \<Rightarrow> bool" ("_ \<turnstile>jmm' _ \<surd>" [51,51] 50)
---
> abbreviation (input) jmm'_hconf :: "'m prog \<Rightarrow> 'addr JMM_heap \<Rightarrow> bool" ("_ \<turnstile>jmm'' _ \<surd>" [51,51] 50)
316c316
< notation jmm'.external_WT' ("_,_ \<turnstile>jmm' (_\<bullet>_'(_')) : _" [50,0,0,0,50] 60)
---
> notation jmm'.external_WT' ("_,_ \<turnstile>jmm'' (_\<bullet>_'(_')) : _" [50,0,0,0,50] 60)
328c328
<   ("_,_ \<turnstile>jmm' (\<langle>(_\<bullet>_'(_')),/_\<rangle>) -_\<rightarrow>ext (\<langle>(_),/(_)\<rangle>)" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)
---
>   ("_,_ \<turnstile>jmm'' (\<langle>(_\<bullet>_'(_')),/_\<rangle>) -_\<rightarrow>ext (\<langle>(_),/(_)\<rangle>)" [50, 0, 0, 0, 0, 0, 0, 0, 0] 51)
==========
Jordan_Normal_Form
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Jordan_Normal_Form/Determinant_Impl.thy ../../AFPs/afp-2020/thys/Jordan_Normal_Form/Determinant_Impl.thy
956c956
< definition det_field_poly :: "'a :: {field,euclidean_ring_gcd} poly mat \<Rightarrow> 'a poly" where
---
> definition det_field_poly :: "'a :: {field,field_gcd} poly mat \<Rightarrow> 'a poly" where
==========
KD_Tree
Only in ../../AFPs/afp-2019/thys/KD_Tree: Balanced.thy
Only in ../../AFPs/afp-2020/thys/KD_Tree: Build.thy
Only in ../../AFPs/afp-2020/thys/KD_Tree: KD_Tree.thy
Only in ../../AFPs/afp-2019/thys/KD_Tree: KDTree.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/KD_Tree/Nearest_Neighbors.thy ../../AFPs/afp-2020/thys/KD_Tree/Nearest_Neighbors.thy
6c6
< section "Nearest Neighbor Search on the \<open>k\<close>-d Tree"
---
> section \<open>Nearest Neighbor Search on the \<open>k\<close>-d Tree\<close>
9,10c9,10
< imports 
<   KDTree
---
> imports
>   KD_Tree
14,18c14,16
<   Verifying nearest neighbor search on the k-d tree.
<   Given a \<open>k\<close>-d tree and a point \<open>p\<close>, which might not be in the tree, find the points \<open>ms\<close> which are
<   closest to \<open>p\<close> by some metric.
<   The chosen metric is the euclidean distance between two points.
<   To avoid working with roots I will work with the squared euclidean distance.
---
>   Verifying nearest neighbor search on the k-d tree. Given a \<open>k\<close>-d tree and a point \<open>p\<close>,
>   which might not be in the tree, find the points \<open>ps\<close> that are closest to \<open>p\<close> using the
>   Euclidean metric.
21,207c19
< subsection "Definition of the Squared Euclidean Distance"
< 
< definition sqed' :: "real \<Rightarrow> real \<Rightarrow> real" where
<   "sqed' x y = (x - y) ^ 2"
< 
< fun sqed :: "point \<Rightarrow> point \<Rightarrow> real" where
<   "sqed [] [] = 0"
< | "sqed (x # xs) (y # ys) = sqed' x y + sqed xs ys"
< | "sqed _ _ = undefined"
< 
< definition min_by_sqed :: "point \<Rightarrow> point \<Rightarrow> point \<Rightarrow> point" where
<   "min_by_sqed p\<^sub>0 p\<^sub>1 q = (
<     if sqed p\<^sub>0 q \<le> sqed p\<^sub>1 q then p\<^sub>0 else p\<^sub>1
<   )"
< 
< lemma sqed'_ge_0:
<   "0 \<le> sqed' x y"
<   by (simp add: sqed'_def)
< 
< lemma sqed'_eq_0[simp]:
<   "sqed' x y = 0 \<longleftrightarrow> x = y"
<   by (simp add: sqed'_def)
< 
< lemma sqed'_com:
<   "sqed' x y = sqed' y x"
<   by (simp add: sqed'_def power2_commute)
< 
< lemma inequality:
<   assumes "(x::real) \<le> 0" "y \<le> 0"
<   shows "x\<^sup>2 + y\<^sup>2 \<le> (x + y)\<^sup>2"
< proof -
<   have "x\<^sup>2 + y\<^sup>2 \<le> x\<^sup>2 + 2 * x * y + y\<^sup>2"
<     using assms by (simp add: zero_le_mult_iff)
<   also have "... = (x + y)\<^sup>2"
<     by algebra
<   finally show ?thesis .
< qed
< 
< lemma sqed'_split:
<   "x \<le> s \<Longrightarrow> s \<le> y \<Longrightarrow> sqed' x s + sqed' s y \<le> sqed' x y"
<   using inequality[of "x - s" "s - y"] sqed'_def by simp
< 
< lemma sqed_ge_0:
<   "dim p\<^sub>0 = dim p\<^sub>1 \<Longrightarrow> 0 \<le> sqed p\<^sub>0 p\<^sub>1"
<   by (induction p\<^sub>0 p\<^sub>1 rule: sqed.induct) (auto simp add: sqed'_ge_0)
< 
< lemma sqed_eq_0[simp]:
<   "p\<^sub>0 = p\<^sub>1 \<Longrightarrow> sqed p\<^sub>0 p\<^sub>1 = 0"
<   by (induction p\<^sub>0 p\<^sub>1 rule: sqed.induct) auto
< 
< lemma sqed_eq_0_rev:
<   "dim p\<^sub>0 = dim p\<^sub>1 \<Longrightarrow> sqed p\<^sub>0 p\<^sub>1 = 0 \<Longrightarrow> p\<^sub>0 = p\<^sub>1"
<   by (induction p\<^sub>0 p\<^sub>1 rule: sqed.induct) (auto simp add: add_nonneg_eq_0_iff sqed'_ge_0 sqed_ge_0)
< 
< lemma sqed_com:
<   "sqed p\<^sub>0 p\<^sub>1 = sqed p\<^sub>1 p\<^sub>0"
<   by (induction p\<^sub>0 p\<^sub>1 rule: sqed.induct) (auto simp add: sqed'_com)
< 
< 
< subsection "The recursive Nearest Neighbor Algorithm"
< 
< fun nearest_nbors :: "nat \<Rightarrow> point list \<Rightarrow> point \<Rightarrow> kdt \<Rightarrow> point list" where
<   "nearest_nbors m ns p (Leaf p') = (
<     take m (insort_key (\<lambda>q. sqed q p) p' ns)
<   )"
< | "nearest_nbors m ns p (Node a s l r) = (
<     if p!a \<le> s then
<       let candidates = nearest_nbors m ns p l in
<       if length candidates = m \<and> sqed p (last candidates) \<le> sqed' s (p!a) then
<         candidates
<       else
<         nearest_nbors m candidates p r
<     else
<       let candidates = nearest_nbors m ns p r in
<       if length candidates = m \<and> sqed p (last candidates) \<le> sqed' s (p!a) then
<         candidates
<       else
<         nearest_nbors m candidates p l
<   )"
< 
< 
< text \<open>
<   Some intuition about the following auxiliary lemmas.
< 
<   Scenario A:
< 
<   We are searching for the nearest neighbor of point \<open>p\<close> and have found candidate \<open>c\<close> at axis \<open>a\<close>.
<   Since @{term "sqed c p \<le> sqed' s (p!a)"} we do not need to check the right side.
< 
< \begin{alltt}
<                                 s
<           c                     |
<                                 |
<                p                |
<                                 |
<                                 |  q
<                                 |
< \end{alltt}
< 
<   Scenario B:
<   We are searching for the nearest neighbor of point \<open>p\<close> and have found candidate \<open>c\<close> at axis \<open>a\<close>.
<   Since @{term "sqed' s (p!a) < sqed c p"} we do need to check the right side.
< 
< \begin{alltt}
<                                 s
<           c                     |
<                                 |
<                           p     |  q'
<                                 |
<                                 |  q
<                                 |
< \end{alltt}
< 
<   The minimize sqed lemma moves \<open>q\<close> to \<open>q'\<close> by setting all coordinates of \<open>q'\<close> (except the current axis \<open>a\<close>)
<   to the coordinates of \<open>p\<close> and minimizes subsequently the distance between \<open>p\<close> and \<open>q'\<close>.
< \<close>
< 
< lemma minimize_sqed:
<   assumes "dim p\<^sub>0 = k" "dim p\<^sub>1 = k" "a < k"
<   shows "sqed' (p\<^sub>0!a) (p\<^sub>0[a := (p\<^sub>1!a)]!a) \<le> sqed p\<^sub>0 p\<^sub>1"
<   using assms
<   apply (induction p\<^sub>0 p\<^sub>1 arbitrary: a k rule: sqed.induct)
<   apply (auto simp add: sqed_ge_0 split: nat.splits)
<   by (meson dual_order.trans le_add_same_cancel2 sqed'_ge_0)
< 
< lemma cutoff_r:
<   assumes "invar k (Node a s l r)" "dim p = k"
<   assumes "p!a \<le> s" "sqed p c \<le> sqed' (p!a) s"
<   shows "\<forall>q \<in> set_kdt r. sqed p c \<le> sqed p q"
< proof standard
<   fix q
<   assume *: "q \<in> set_kdt r"
< 
<   let ?q' = "p[a := (q!a)]"
< 
<   have 0: "s \<le> q!a"
<     using * assms(1) invar_r_ge_a by blast
<   have 1: "sqed' (p!a) (?q'!a) \<le> sqed p q"
<     using * minimize_sqed assms(1,2) invar_axis_lt_d invar_dim invar_r by blast
< 
<   have "sqed p c \<le> sqed' (p!a) s"
<     using assms(4) by blast
<   also have "... \<le> sqed' (p!a) s + sqed' s (q!a)"
<     using sqed'_ge_0 by simp
<   also have "... \<le> sqed' (p!a) (q!a)"
<     using 0 sqed'_split assms(3) by simp
<   also have "... \<le> sqed p q"
<     using 1 assms(1,2) by simp
<   finally show "sqed p c \<le> sqed p q" .
< qed
< 
< lemma cutoff_l:
<   assumes "invar k (Node a s l r)" "dim p = k"
<   assumes "s \<le> p!a" "sqed p c \<le> sqed' s (p!a)"
<   shows "\<forall>q \<in> set_kdt l. sqed p c \<le> sqed p q"
< proof standard
<   fix q
<   assume *: "q \<in> set_kdt l"
< 
<   let ?q' = "p[a := (q!a)]"
< 
<   have 0: "q!a \<le> s"
<     using * assms(1) invar_l_le_a by blast
<   have 1: "sqed' (p!a) (?q'!a) \<le> sqed p q"
<     using * minimize_sqed assms(1,2) invar_axis_lt_d invar_dim invar_l by blast
< 
<   have "sqed p c \<le> sqed' s (p!a)"
<     using assms(4) by blast
<   also have "... \<le> sqed' s (p!a) + sqed' (q!a) s"
<     using sqed'_ge_0 by simp
<   also have "... \<le> sqed' (p!a) (q!a)"
<     using 0 sqed'_split assms(3) by (metis add.commute sqed'_com)
<   also have "... \<le> sqed p q"
<     using 1 assms(1,2) by simp
<   finally show "sqed p c \<le> sqed p q" .
< qed
< 
< 
< subsection "Auxiliary Lemmas abount \<open>sorted_wrt\<close>"
< 
< definition sorted_sqed :: "point \<Rightarrow> point list \<Rightarrow> bool" where
<   "sorted_sqed p \<equiv> sorted_wrt (\<lambda>p\<^sub>0 p\<^sub>1. sqed p\<^sub>0 p \<le> sqed p\<^sub>1 p)"
< 
< definition insort_sqed :: "point \<Rightarrow> point \<Rightarrow> point list \<Rightarrow> point list" where
<   "insort_sqed p \<equiv> insort_key (\<lambda>q. sqed q p)"
< 
< declare sorted_sqed_def[simp] insort_sqed_def[simp]
---
> subsection \<open>Auxiliary Lemmas about \<open>sorted_wrt\<close>\<close>
214c26
<   have "sorted_wrt f (take n xs @ drop n xs)" 
---
>   have "sorted_wrt f (take n xs @ drop n xs)"
220,234c32,33
< lemma sorted_insort_sqed:
<   "sorted_sqed p ms \<Longrightarrow> sorted_sqed p (insort_sqed p p' ms)"
<   apply (induction ms)
<   apply (auto)
<   by (metis insert_iff le_cases set_insort_key)
< 
< lemma sorted_sqed_take_insort:
<   assumes "sorted_sqed p ms"
<   shows "sorted_sqed p (take m (insort_sqed p p' ms))"
< proof -
<   have "sorted_sqed p (insort_sqed p p' ms)"
<     using assms sorted_insort_sqed by blast
<   thus ?thesis 
<     using sorted_wrt_take by auto
< qed
---
> definition sorted_wrt_dist :: "('k::finite) point \<Rightarrow> 'k point list \<Rightarrow> bool" where
>   "sorted_wrt_dist p \<equiv> sorted_wrt (\<lambda>p\<^sub>0 p\<^sub>1. dist p\<^sub>0 p \<le> dist p\<^sub>1 p)"
236,243c35,56
< lemma sorted_sqed_take_drop:
<   assumes "sorted_sqed p ps"
<   shows "\<forall>p\<^sub>0 \<in> set (take n ps). \<forall>p\<^sub>1 \<in> set (drop n ps). sqed p\<^sub>0 p \<le> sqed p\<^sub>1 p"
<   using assms sorted_wrt_append[of _ "take n ps" "drop n ps"] by simp
< 
< lemma sorted_sqed_last:
<   assumes "sorted_sqed p ps"
<   shows "\<forall>n \<in> set ps. sqed n p \<le> sqed (last ps) p"
---
> lemma sorted_wrt_dist_insort_key:
>   "sorted_wrt_dist p ps \<Longrightarrow> sorted_wrt_dist p (insort_key (\<lambda>q. dist q p) q ps)"
>   by (induction ps) (auto simp: sorted_wrt_dist_def set_insort_key)
> 
> lemma sorted_wrt_dist_take_drop:
>   assumes "sorted_wrt_dist p ps"
>   shows "\<forall>p\<^sub>0 \<in> set (take n ps). \<forall>p\<^sub>1 \<in> set (drop n ps). dist p\<^sub>0 p \<le> dist p\<^sub>1 p"
>   using assms sorted_wrt_append[of _ "take n ps" "drop n ps"] by (simp add: sorted_wrt_dist_def)
> 
> lemma sorted_wrt_dist_last_take_mono:
>   assumes "sorted_wrt_dist p ps" "n \<le> length ps" "0 < n"
>   shows "dist (last (take n ps)) p \<le> dist (last ps) p"
>   using assms unfolding sorted_wrt_dist_def by (induction ps arbitrary: n) (auto simp add: take_Cons')
> 
> lemma sorted_wrt_dist_last_insort_key_eq:
>   assumes "sorted_wrt_dist p ps" "insort_key (\<lambda>q. dist q p) q ps \<noteq> ps @ [q]"
>   shows "last (insort_key (\<lambda>q. dist q p) q ps) = last ps"
>   using assms unfolding sorted_wrt_dist_def by (induction ps) (auto)
> 
> lemma sorted_wrt_dist_last:
>   assumes "sorted_wrt_dist p ps"
>   shows "\<forall>q \<in> set ps. dist q p \<le> dist (last ps) p"
251c64
<   hence "sorted_sqed p (ps' @ [p'])"
---
>   hence "sorted_wrt_dist p (ps' @ [p'])"
254c67,83
<     using sorted_wrt_append[of _ ps' "[p']"] by simp
---
>     unfolding sorted_wrt_dist_def using sorted_wrt_append[of _ ps' "[p']"] by simp
> qed
> 
> 
> subsection \<open>Neighbors Sorted wrt. Distance\<close>
> 
> definition upd_nbors :: "nat \<Rightarrow> ('k::finite) point \<Rightarrow> 'k point \<Rightarrow> 'k point list \<Rightarrow> 'k point list" where
>   "upd_nbors n p q ps = take n (insort_key (\<lambda>q. dist q p) q ps)"
> 
> lemma sorted_wrt_dist_nbors:
>   assumes "sorted_wrt_dist p ps"
>   shows "sorted_wrt_dist p (upd_nbors n p q ps)"
> proof -
>   have "sorted_wrt_dist p (insort_key (\<lambda>q. dist q p) q ps)"
>     using assms sorted_wrt_dist_insort_key by blast
>   thus ?thesis
>     by (simp add: sorted_wrt_dist_def sorted_wrt_take upd_nbors_def)
257,259c86,88
< lemma sorted_sqed_take_insort_mono:
<   assumes "sorted_sqed p ms"
<   shows "\<forall>n \<in> set ms \<union> {p'} - set (take m (insort_sqed p p' ms)). \<forall>n' \<in> set (take m (insort_sqed p p' ms)). sqed n' p \<le> sqed n p"
---
> lemma sorted_wrt_dist_nbors_diff:
>   assumes "sorted_wrt_dist p ps"
>   shows "\<forall>r \<in> set ps \<union> {q} - set (upd_nbors n p q ps). \<forall>s \<in> set (upd_nbors n p q ps). dist s p \<le> dist r p"
261,262c90,91
<   let ?ms' = "insort_sqed p p' ms"
<   have "set ms \<union> {p'} = set ?ms'"
---
>   let ?ps' = "insort_key (\<lambda>q. dist q p) q ps"
>   have "set ps \<union> { q } = set ?ps'"
264c93
<   moreover have "set ?ms' = set (take m ?ms') \<union> set (drop m ?ms')"
---
>   moreover have "set ?ps' = set (take n ?ps') \<union> set (drop n ?ps')"
266c95
<   ultimately have "set ms \<union> {p'} - set (take m ?ms') \<subseteq> set (drop m ?ms')"
---
>   ultimately have "set ps \<union> { q } - set (take n ?ps') \<subseteq> set (drop n ?ps')"
268,269c97,98
<   moreover have "sorted_sqed p ?ms'"
<     using assms sorted_insort_sqed by blast
---
>   moreover have "sorted_wrt_dist p ?ps'"
>     using assms sorted_wrt_dist_insort_key by blast
271c100
<     using sorted_sqed_take_drop by blast
---
>     unfolding upd_nbors_def using sorted_wrt_dist_take_drop by blast
274,302c103,118
< lemma sorted_sqed_last_take_mono:
<   assumes "sorted_sqed p ms" "m \<le> length ms" "0 < m"
<   shows "sqed (last (take m ms)) p \<le> sqed (last ms) p"
<   using assms by (induction ms arbitrary: m) (auto simp add: take_Cons')
< 
< lemma sorted_sqed_last_insort_eq:
<   assumes "sorted_sqed p ms" "insort_sqed p p' ms \<noteq> ms @ [p']"
<   shows "last (insort_sqed p p' ms) = last ms"
<   using assms by (induction ms) (auto)
< 
< lemma sorted_sqed_last_take_insort_mono:
<   assumes "sorted_sqed p ms" "m \<le> length ms" "0 < m"
<   shows "sqed (last (take m (insort_sqed p p' ms))) p \<le> sqed (last ms) p"
< proof -
<   let ?ms' = "insort_sqed p p' ms"
<   show "sqed (last (take m ?ms')) p \<le> sqed (last ms) p"
<   proof (cases "?ms' = ms @ [p']")
<     case True
<     thus ?thesis
<       using assms sorted_sqed_last_take_mono by auto
<   next
<     case False
<     hence EQ: "last ?ms' = last ms"
<       using sorted_sqed_last_insort_eq assms by simp
<     have "sqed (last (take m ?ms')) p \<le> sqed (last ?ms') p"
<       using assms sorted_sqed_last_take_mono sorted_insort_sqed by simp
<     thus ?thesis
<       using EQ by simp
<   qed
---
> lemma sorted_wrt_dist_last_upd_nbors_mono:
>   assumes "sorted_wrt_dist p ps" "n \<le> length ps" "0 < n"
>   shows "dist (last (upd_nbors n p q ps)) p \<le> dist (last ps) p"
> proof (cases "insort_key (\<lambda>q. dist q p) q ps = ps @ [q]")
>   case True
>   thus ?thesis
>     unfolding upd_nbors_def using assms sorted_wrt_dist_last_take_mono by auto
> next
>   case False
>   hence "last (insort_key (\<lambda>q. dist q p) q ps) = last ps"
>     using sorted_wrt_dist_last_insort_key_eq assms by blast
>   moreover have "dist (last (upd_nbors  n p q ps)) p \<le> dist (last (insort_key (\<lambda>q. dist q p) q ps)) p"
>     unfolding upd_nbors_def using assms sorted_wrt_dist_last_take_mono[of p "insort_key (\<lambda>q. dist q p) q ps"]
>     by (simp add: sorted_wrt_dist_insort_key)
>   ultimately show ?thesis
>     by simp
306c122
< subsection "The Main Theorems"
---
> subsection \<open>The Recursive Nearest Neighbor Algorithm\<close>
308,347c124,139
< lemma mnn_length:
<   "length (nearest_nbors m ms p kdt) = min m (size_kdt kdt + length ms)"
<   by (induction kdt arbitrary: ms) (auto simp add: Let_def)
< 
< lemma mnn_length_gt_0:
<   assumes "0 < m"
<   shows "0 < length (nearest_nbors m ms p kdt)"
<   using assms by (induction kdt arbitrary: ms) (auto simp add: Let_def)
< 
< lemma mnn_length_gt_eq_m:
<   assumes "(set_kdt kdt \<union> set ms) - set (nearest_nbors m ms p kdt) \<noteq> {}"
<   shows "length (nearest_nbors m ms p kdt) = m"
<   using assms mnn_length set_insort_key
<   apply (induction kdt arbitrary: ms)
<   apply (auto simp add: min_def Let_def)
<   by fastforce+
< 
< lemma mnn_sorted:
<   assumes "sorted_sqed p ms"
<   shows "sorted_sqed p (nearest_nbors m ms p kdt)"
<   using assms sorted_sqed_take_insort
<   by (induction kdt arbitrary: ms) (auto simp add: Let_def)
< 
< lemma mnn_set:
<   shows "set (nearest_nbors m ms p kdt) \<subseteq> set_kdt kdt \<union> set ms"
<   using set_insort_key in_set_takeD
<   apply (induction kdt arbitrary: ms)
<   apply (auto simp add: Let_def)
<   by fastforce
< 
< lemma mnn_distinct:
<   assumes "invar k kdt" "dim p = k" "distinct ms" "set ms \<inter> set_kdt kdt = {}"
<   shows "distinct (nearest_nbors m ms p kdt)"
<   using assms
< proof (induction kdt arbitrary: ms)
<   case (Leaf p')
<   thus ?case
<     by (simp add: distinct_insort)
< next
<   case (Node a s l r)
---
> fun nearest_nbors :: "nat \<Rightarrow> ('k::finite) point list \<Rightarrow> 'k point \<Rightarrow> 'k kdt \<Rightarrow> 'k point list" where
>   "nearest_nbors n ps p (Leaf q) = upd_nbors n p q ps"
> | "nearest_nbors n ps p (Node k v l r) = (
>     if p$k \<le> v then
>       let candidates = nearest_nbors n ps p l in
>       if length candidates = n \<and> dist p (last candidates) \<le> dist v (p$k) then
>         candidates
>       else
>         nearest_nbors n candidates p r
>     else
>       let candidates = nearest_nbors n ps p r in
>       if length candidates = n \<and> dist p (last candidates) \<le> dist v (p$k) then
>         candidates
>       else
>         nearest_nbors n candidates p l
>   )"
349,350d140
<   let ?cl = "nearest_nbors m ms p l"
<   let ?cr = "nearest_nbors m ms p r"
352,360c142
<   have "set ms \<inter> set_kdt l = {} \<and> set ms \<inter> set_kdt r = {}"
<     using Node.prems(4) by auto
<   hence DCLR: "distinct ?cl \<and> distinct ?cr"
<     using Node.IH(1,2) Node.prems(1,2,3) invar_l invar_r by blast
< 
<   have "set ?cl \<inter> set_kdt r = {} \<and> set ?cr \<inter> set_kdt l = {}"
<     using Node.prems(1,4) mnn_set invar_distinct by fastforce
<   hence "distinct (nearest_nbors m ?cl p r) \<and> distinct (nearest_nbors m ?cr p l)"
<     using Node.IH(1,2) Node.prems(1,2) DCLR invar_l invar_r by blast
---
> subsection \<open>Auxiliary Lemmas\<close>
362,363c144,159
<   thus ?case 
<     using DCLR by (auto simp add: Let_def)
---
> lemma cutoff_r:
>   assumes "invar (Node k v l r)"
>   assumes "p$k \<le> v" "dist p c \<le> dist (p$k) v"
>   shows "\<forall>q \<in> set_kdt r. dist p c \<le> dist p q"
> proof standard
>   fix q
>   assume *: "q \<in> set_kdt r"
>   have "dist p c \<le> dist (p$k) v"
>     using assms(3) by blast
>   also have "... \<le> dist (p$k) v + dist v (q$k)"
>     by simp
>   also have "... = dist (p$k) (q$k)"
>     using * assms(1,2) dist_real_def by auto
>   also have "... \<le> dist p q"
>     using dist_vec_nth_le by blast
>   finally show "dist p c \<le> dist p q" .
366,371c162,178
< lemma mnn_le_last_ms:
<   assumes "invar k kdt" "dim p = k" "sorted_sqed p ms" "m \<le> length ms" "0 < m"
<   shows "sqed (last (nearest_nbors m ms p kdt)) p \<le> sqed (last ms) p"
<   using assms
< proof (induction kdt arbitrary: ms)
<   case (Leaf p')
---
> lemma cutoff_l:
>   assumes "invar (Node k v l r)"
>   assumes "v \<le> p$k" "dist p c \<le> dist v (p$k)"
>   shows "\<forall>q \<in> set_kdt l. dist p c \<le> dist p q"
> proof standard
>   fix q
>   assume *: "q \<in> set_kdt l"
>   have "dist p c \<le> dist v (p$k)"
>     using assms(3) by blast
>   also have "... \<le> dist v (p$k) + dist (q$k) v"
>     by simp
>   also have "... = dist (p$k) (q$k)"
>     using * assms(1,2) dist_real_def by auto
>   also have "... \<le> dist p q"
>     using dist_vec_nth_le by blast
>   finally show "dist p c \<le> dist p q" .
> qed
373d179
<   let ?ms' = "take m (insort_sqed p p' ms)"
375,384c181
<   have "sorted_sqed p ?ms'"
<     using Leaf.prems(3) sorted_sqed_take_insort by simp
<   hence "\<forall>n \<in> set ?ms'. sqed n p \<le> sqed (last ?ms') p"
<     using sorted_sqed_last by blast
<   hence "\<forall>n \<in> set ?ms'. sqed n p \<le> sqed (last ms) p"
<     using Leaf.prems(3,4,5) sorted_sqed_last_take_insort_mono[of p ms m p'] order_trans by blast
<   thus ?case
<     using Leaf.prems(5) by simp
< next
<   case (Node a s l r)
---
> subsection \<open>The Main Theorems\<close>
386,387c183,187
<   let ?cl = "nearest_nbors m ms p l"
<   let ?cr = "nearest_nbors m ms p r"
---
> lemma set_nns:
>   "set (nearest_nbors n ps p kdt) \<subseteq> set_kdt kdt \<union> set ps"
>   apply (induction kdt arbitrary: ps)
>   apply (auto simp: Let_def upd_nbors_def set_insort_key)
>   using in_set_takeD set_insort_key by fastforce
389,401c189,191
<   have "m \<le> length ?cl"
<     using mnn_length Node.prems(4) by auto
<   hence "sqed (last (nearest_nbors m ?cl p r)) p \<le> sqed (last ?cl) p"
<     using mnn_sorted Node.IH(2) Node.prems(1,2,3,5) invar_r by blast
<   hence IHLR: "sqed (last (nearest_nbors m ?cl p r)) p \<le> sqed (last ms) p"
<     using Node.IH(1)[of ms] Node.prems invar_l mnn_length_gt_0 by (meson order_trans)
< 
<   have "m \<le> length ?cr"
<     using mnn_length Node.prems(4) by auto
<   hence "sqed (last (nearest_nbors m ?cr p l)) p \<le> sqed (last ?cr) p"
<     using mnn_sorted Node.IH(1) Node.prems(1,2,3,5) invar_l by blast
<   hence IHRL: "sqed (last (nearest_nbors m ?cr p l)) p \<le> sqed (last ms) p"
<     using Node.IH(2)[of ms] Node.prems invar_r mnn_length_gt_0 by (meson order_trans)
---
> lemma length_nns:
>   "length (nearest_nbors n ps p kdt) = min n (size_kdt kdt + length ps)"
>   by (induction kdt arbitrary: ps) (auto simp: Let_def upd_nbors_def)
403,405c193,195
<   show ?case 
<     using Node IHLR IHRL by (auto simp add: Let_def)
< qed
---
> lemma length_nns_gt_0:
>   "0 < n \<Longrightarrow> 0 < length (nearest_nbors n ps p kdt)"
>   by (induction kdt arbitrary: ps) (auto simp: Let_def upd_nbors_def)
407,410c197,199
< theorem mnn_sqed:
<   assumes "invar k kdt" "dim p = k"
<   assumes "sorted_sqed p ms" "set ms \<inter> set_kdt kdt = {}" "distinct ms" "0 < m"
<   shows "\<forall>q \<in> set_kdt kdt \<union> set ms - set (nearest_nbors m ms p kdt). sqed (last (nearest_nbors m ms p kdt)) p \<le> sqed q p"
---
> lemma length_nns_n:
>   assumes "(set_kdt kdt \<union> set ps) - set (nearest_nbors n ps p kdt) \<noteq> {}"
>   shows "length (nearest_nbors n ps p kdt) = n"
412,413c201,209
< proof (induction kdt arbitrary: ms)
<   case (Leaf p')
---
> proof (induction kdt arbitrary: ps)
>   case (Node k v l r)
>   let ?nnsl = "nearest_nbors n ps p l"
>   let ?nnsr = "nearest_nbors n ps p r"
>   consider (A) "p$k \<le> v \<and> length ?nnsl = n \<and> dist p (last ?nnsl) \<le> dist v (p$k)"
>          | (B) "p$k \<le> v \<and> \<not>(length ?nnsl = n \<and> dist p (last ?nnsl) \<le> dist v (p$k))"
>          | (C) "v < p$k \<and> length ?nnsr = n \<and> dist p (last ?nnsr) \<le> dist v (p$k)"
>          | (D) "v < p$k \<and> \<not>(length ?nnsr = n \<and> dist p (last ?nnsr) \<le> dist v (p$k))"
>     by argo
415,417c211,258
<     using sorted_sqed_take_insort_mono by simp
< next
<   case (Node a s l r)
---
>   proof cases
>     case B
>     let ?nns = "nearest_nbors n ?nnsl p r"
>     have "length ?nnsl \<noteq> n \<longrightarrow> (set_kdt l \<union> set ps - set (nearest_nbors n ps p l) = {})"
>       using Node.IH(1) by blast
>     hence "length ?nnsl \<noteq> n \<longrightarrow> (set_kdt r \<union> set ?nnsl - set ?nns \<noteq> {})"
>       using B Node.prems by auto
>     moreover have "length ?nnsl = n \<longrightarrow> ?thesis"
>       using B by (auto simp: length_nns)
>     ultimately show ?thesis
>       using B Node.IH(2) by force
>   next
>     case D
>     let ?nns = "nearest_nbors n ?nnsr p l"
>     have "length ?nnsr \<noteq> n \<longrightarrow> (set_kdt r \<union> set ps - set (nearest_nbors n ps p r) = {})"
>       using Node.IH(2) by blast
>     hence "length ?nnsr \<noteq> n \<longrightarrow> (set_kdt l \<union> set ?nnsr - set ?nns \<noteq> {})"
>       using D Node.prems by auto
>     moreover have "length ?nnsr = n \<longrightarrow> ?thesis"
>       using D by (auto simp: length_nns)
>     ultimately show ?thesis
>       using D Node.IH(1) by force
>   qed auto
> qed (auto simp: upd_nbors_def min_def set_insort_key)
> 
> lemma sorted_nns:
>   "sorted_wrt_dist p ps \<Longrightarrow> sorted_wrt_dist p (nearest_nbors n ps p kdt)"
>   using sorted_wrt_dist_nbors by (induction kdt arbitrary: ps) (auto simp: Let_def)
> 
> lemma distinct_nns:
>   assumes "invar kdt" "distinct ps" "set ps \<inter> set_kdt kdt = {}"
>   shows "distinct (nearest_nbors n ps p kdt)"
>   using assms
> proof (induction kdt arbitrary: ps)
>   case (Node k v l r)
>   let ?nnsl = "nearest_nbors n ps p l"
>   let ?nnsr = "nearest_nbors n ps p r"
>   have "set ps \<inter> set_kdt l = {}" "set ps \<inter> set_kdt r = {}"
>     using Node.prems(3) by auto
>   hence DCLR: "distinct ?nnsl" "distinct ?nnsr"
>     using Node invar_l invar_r by blast+
>   have "set ?nnsl \<inter> set_kdt r = {}" "set ?nnsr \<inter> set_kdt l = {}"
>     using Node.prems(1,3) set_nns by fastforce+
>   hence "distinct (nearest_nbors n ?nnsl p r)" "distinct (nearest_nbors n ?nnsr p l)"
>     using Node.IH(1,2) Node.prems(1,2) DCLR invar_l invar_r by blast+
>   thus ?case
>     using DCLR by (auto simp add: Let_def)
> qed (auto simp: upd_nbors_def distinct_insort)
419,420c260,285
<   let ?cl = "nearest_nbors m ms p l"
<   let ?cr = "nearest_nbors m ms p r"
---
> lemma last_nns_mono:
>   assumes "invar kdt" "sorted_wrt_dist p ps" "n \<le> length ps" "0 < n"
>   shows "dist (last (nearest_nbors n ps p kdt)) p \<le> dist (last ps) p"
>   using assms
> proof (induction kdt arbitrary: ps)
>   case (Node k v l r)
>   let ?nnsl = "nearest_nbors n ps p l"
>   let ?nnsr = "nearest_nbors n ps p r"
>   have "n \<le> length ?nnsl" "n \<le> length ?nnsr"
>     using Node.prems(3) by (simp_all add: length_nns)
>   hence "dist (last (nearest_nbors n ?nnsl p r)) p \<le> dist (last ?nnsl) p"
>         "dist (last (nearest_nbors n ?nnsr p l)) p \<le> dist (last ?nnsr) p"
>     using sorted_nns Node invar_l invar_r by blast+
>   hence "dist (last (nearest_nbors n ?nnsl p r)) p \<le> dist (last ps) p"
>         "dist (last (nearest_nbors n ?nnsr p l)) p \<le> dist (last ps) p"
>     using Node.IH(1)[of ps] Node.IH(2)[of ps] Node.prems invar_l length_nns_gt_0 by auto
>   thus ?case
>     using Node by (auto simp add: Let_def)
> qed (auto simp: sorted_wrt_dist_last_upd_nbors_mono)
> 
> theorem dist_nns:
>   assumes "invar kdt" "sorted_wrt_dist p ps" "set ps \<inter> set_kdt kdt = {}" "distinct ps" "0 < n"
>   shows "\<forall>q \<in> set_kdt kdt \<union> set ps - set (nearest_nbors n ps p kdt). dist (last (nearest_nbors n ps p kdt)) p \<le> dist q p"
>   using assms
> proof (induction kdt arbitrary: ps)
>   case (Node k v l r)
422,440c287,309
<   have IHL: "\<forall>q \<in> set_kdt l \<union> set ms - set ?cl. sqed (last ?cl) p \<le> sqed q p"
<     using Node.IH(1) Node.prems invar_l invar_set by blast
<   have IHR: "\<forall>q \<in> set_kdt r \<union> set ms - set ?cr. sqed (last ?cr) p \<le> sqed q p"
<     using Node.IH(2) Node.prems invar_r invar_set by blast
< 
<   have SORTED_L: "sorted_sqed p ?cl"
<     using mnn_sorted Node.prems(3) by blast
<   have SORTED_R: "sorted_sqed p ?cr"
<     using mnn_sorted Node.prems(3) by blast
< 
<   have DISTINCT_L: "distinct ?cl"
<     using Node.prems(1,2,4,5) mnn_distinct invar_set invar_l by blast
<   have DISTINCT_R: "distinct ?cr"
<     using Node.prems(1,2,4,5) mnn_distinct invar_set invar_r by blast
< 
<   consider (A) "p!a \<le> s \<and> length ?cl = m \<and> sqed p (last ?cl) \<le> sqed' s (p!a)"
<          | (B) "p!a \<le> s \<and> \<not>(length ?cl = m \<and> sqed p (last ?cl) \<le> sqed' s (p!a))"
<          | (C) "s < p!a \<and> length ?cr = m \<and> sqed p (last ?cr) \<le> sqed' s (p!a)"
<          | (D) "s < p!a \<and> \<not>(length ?cr = m \<and> sqed p (last ?cr) \<le> sqed' s (p!a))"
---
>   let ?nnsl = "nearest_nbors n ps p l"
>   let ?nnsr = "nearest_nbors n ps p r"
> 
>   have IHL: "\<forall>q \<in> set_kdt l \<union> set ps - set ?nnsl. dist (last ?nnsl) p \<le> dist q p"
>     using Node.IH(1) Node.prems invar_l invar_set by auto
>   have IHR: "\<forall>q \<in> set_kdt r \<union> set ps - set ?nnsr. dist (last ?nnsr) p \<le> dist q p"
>     using Node.IH(2) Node.prems invar_r invar_set by auto
> 
>   have SORTED_L: "sorted_wrt_dist p ?nnsl"
>     using sorted_nns Node.prems(2) by blast
>   have SORTED_R: "sorted_wrt_dist p ?nnsr"
>     using sorted_nns Node.prems(2) by blast
> 
>   have DISTINCT_L: "distinct ?nnsl"
>     using Node.prems distinct_nns invar_set invar_l by fastforce
>   have DISTINCT_R: "distinct ?nnsr"
>     using Node.prems distinct_nns invar_set invar_r
>     by (metis inf_bot_right inf_sup_absorb inf_sup_aci(3) sup.commute)
> 
>   consider (A) "p$k \<le> v \<and> length ?nnsl = n \<and> dist p (last ?nnsl) \<le> dist v (p$k)"
>          | (B) "p$k \<le> v \<and> \<not>(length ?nnsl = n \<and> dist p (last ?nnsl) \<le> dist v (p$k))"
>          | (C) "v < p$k \<and> length ?nnsr = n \<and> dist p (last ?nnsr) \<le> dist v (p$k)"
>          | (D) "v < p$k \<and> \<not>(length ?nnsr = n \<and> dist p (last ?nnsr) \<le> dist v (p$k))"
445,446c314,315
<     hence "\<forall>q \<in> set_kdt r. sqed (last ?cl) p \<le> sqed q p"
<       using Node.prems(1,2) cutoff_r by (metis sqed'_com sqed_com)
---
>     hence "\<forall>q \<in> set_kdt r. dist (last ?nnsl) p \<le> dist q p"
>       using Node.prems(1,2) cutoff_r by (metis dist_commute)
452c321
<     let ?mnn = "nearest_nbors m ?cl p r"
---
>     let ?nns = "nearest_nbors n ?nnsl p r"
454,457c323,328
<     have "set ?cl \<subseteq> set_kdt l \<union> set ms \<and> set ms \<inter> set_kdt r = {}"
<       using mnn_set Node.prems(1,4) by auto
<     hence IHLR: "\<forall>q \<in> set_kdt r \<union> set ?cl - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
<       using SORTED_L DISTINCT_L Node.IH(2) Node.prems(1,2,6) invar_r invar_distinct by blast
---
>     have "set ?nnsl \<subseteq> set_kdt l \<union> set ps" "set ps \<inter> set_kdt r = {}"
>       using set_nns Node.prems(1,3) by (simp add: set_nns disjoint_iff_not_equal)+
>     hence "set ?nnsl \<inter> set_kdt r = {}"
>       using Node.prems(1) by fastforce
>     hence IHLR: "\<forall>q \<in> set_kdt r \<union> set ?nnsl - set ?nns. dist (last ?nns) p \<le> dist q p"
>       using Node.IH(2)[OF _ SORTED_L _ DISTINCT_L Node.prems(5)] Node.prems(1) invar_r by blast
459c330
<     have "\<forall>n \<in> set ms - set ?cl. sqed (last ?mnn) p \<le> sqed n p"
---
>     have "\<forall>q \<in> set ps - set ?nnsl. dist (last ?nns) p \<le> dist q p"
461,462c332,333
<       fix n
<       assume *: "n \<in> set ms - set ?cl"
---
>       fix q
>       assume *: "q \<in> set ps - set ?nnsl"
464,468c335,339
<       hence "length ?cl = m"
<         using mnn_length_gt_eq_m by blast
<       hence LAST: "sqed (last ?mnn) p \<le> sqed (last ?cl) p"
<         using mnn_le_last_ms SORTED_L invar_r Node.prems(1,2,6) by (metis order_refl)
<       have "sqed (last ?cl) p \<le> sqed n p"
---
>       hence "length ?nnsl = n"
>         using length_nns_n by blast
>       hence LAST: "dist (last ?nns) p \<le> dist (last ?nnsl) p"
>         using last_nns_mono SORTED_L invar_r Node.prems(1,2,5) by (metis order_refl)
>       have "dist (last ?nnsl) p \<le> dist q p"
470c341
<       thus "sqed (last ?mnn) p \<le> sqed n p"
---
>       thus "dist (last ?nns) p \<le> dist q p"
473c344
<     hence R: "\<forall>q \<in> set_kdt r \<union> set ms - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
---
>     hence R: "\<forall>q \<in> set_kdt r \<union> set ps - set ?nns. dist (last ?nns) p \<le> dist q p"
476c347
<     have "\<forall>q \<in> set_kdt l - set ?cl. sqed (last ?mnn) p \<le> sqed q p"
---
>     have "\<forall>q \<in> set_kdt l - set ?nnsl. dist (last ?nns) p \<le> dist q p"
479c350
<       assume *: "q \<in> set_kdt l - set ?cl"
---
>       assume *: "q \<in> set_kdt l - set ?nnsl"
481,485c352,356
<       hence "length ?cl = m"
<         using mnn_length_gt_eq_m by blast
<       hence LAST: "sqed (last ?mnn) p \<le> sqed (last ?cl) p"
<         using mnn_le_last_ms SORTED_L invar_r Node.prems(1,2,6) by (metis order_refl)
<       have "sqed (last ?cl) p \<le> sqed q p"
---
>       hence "length ?nnsl = n"
>         using length_nns_n by blast
>       hence LAST: "dist (last ?nns) p \<le> dist (last ?nnsl) p"
>         using last_nns_mono SORTED_L invar_r Node.prems(1,2,5) by (metis order_refl)
>       have "dist (last ?nnsl) p \<le> dist q p"
487c358
<       thus "sqed (last ?mnn) p \<le> sqed q p"
---
>       thus "dist (last ?nns) p \<le> dist q p"
490c361
<     hence L: "\<forall>q \<in> set_kdt l - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
---
>     hence L: "\<forall>q \<in> set_kdt l - set ?nns. dist (last ?nns) p \<le> dist q p"
497,498c368,369
<     hence "\<forall>q \<in> set_kdt l. sqed (last ?cr) p \<le> sqed q p"
<       using Node.prems(1,2) cutoff_l[of k a s l r p "last ?cr"] sqed_com by fastforce
---
>     hence "\<forall>q \<in> set_kdt l. dist (last ?nnsr) p \<le> dist q p"
>       using Node.prems(1,2) cutoff_l by (metis dist_commute less_imp_le)
504c375
<     let ?mnn = "nearest_nbors m ?cr p l"
---
>     let ?nns = "nearest_nbors n ?nnsr p l"
506,509c377,382
<     have "set ?cr \<subseteq> set_kdt r \<union> set ms \<and> set ms \<inter> set_kdt l = {}"
<       using mnn_set Node.prems(1,4) by auto
<     hence IHRL: "\<forall>q \<in> set_kdt l \<union> set ?cr - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
<       using SORTED_R DISTINCT_R Node.IH(1) Node.prems(1,2,6) invar_l invar_distinct by blast
---
>     have "set ?nnsr \<subseteq> set_kdt r \<union> set ps" "set ps \<inter> set_kdt l = {}"
>       using set_nns Node.prems(1,3) by (simp add: set_nns disjoint_iff_not_equal)+
>     hence "set ?nnsr \<inter> set_kdt l = {}"
>       using Node.prems(1) by fastforce
>     hence IHRL: "\<forall>q \<in> set_kdt l \<union> set ?nnsr - set ?nns. dist (last ?nns) p \<le> dist q p"
>       using Node.IH(1)[OF _ SORTED_R _ DISTINCT_R Node.prems(5)] Node.prems(1) invar_l by blast
511c384
<     have "\<forall>n \<in> set ms - set ?cr. sqed (last ?mnn) p \<le> sqed n p"
---
>     have "\<forall>q \<in> set ps - set ?nnsr. dist (last ?nns) p \<le> dist q p"
513,514c386,387
<       fix n
<       assume *: "n \<in> set ms - set ?cr"
---
>       fix q
>       assume *: "q \<in> set ps - set ?nnsr"
516,520c389,393
<       hence "length ?cr = m"
<         using mnn_length_gt_eq_m by blast
<       hence LAST: "sqed (last ?mnn) p \<le> sqed (last ?cr) p"
<         using mnn_le_last_ms SORTED_R invar_l Node.prems(1,2,6) by (metis order_refl)
<       have "sqed (last ?cr) p \<le> sqed n p"
---
>       hence "length ?nnsr = n"
>         using length_nns_n by blast
>       hence LAST: "dist (last ?nns) p \<le> dist (last ?nnsr) p"
>         using last_nns_mono SORTED_R invar_l Node.prems(1,2,5) by (metis order_refl)
>       have "dist (last ?nnsr) p \<le> dist q p"
522c395
<       thus "sqed (last ?mnn) p \<le> sqed n p"
---
>       thus "dist (last ?nns) p \<le> dist q p"
525c398
<     hence R: "\<forall>q \<in> set_kdt l \<union> set ms - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
---
>     hence R: "\<forall>q \<in> set_kdt l \<union> set ps - set ?nns. dist (last ?nns) p \<le> dist q p"
528c401
<     have "\<forall>q \<in> set_kdt r - set ?cr. sqed (last ?mnn) p \<le> sqed q p"
---
>     have "\<forall>q \<in> set_kdt r - set ?nnsr. dist (last ?nns) p \<le> dist q p"
531c404
<       assume *: "q \<in> set_kdt r - set ?cr"
---
>       assume *: "q \<in> set_kdt r - set ?nnsr"
533,537c406,410
<       hence "length ?cr = m"
<         using mnn_length_gt_eq_m by blast
<       hence LAST: "sqed (last ?mnn) p \<le> sqed (last ?cr) p"
<         using mnn_le_last_ms SORTED_R invar_l Node.prems(1,2,6) by (metis order_refl)
<       have "sqed (last ?cr) p \<le> sqed q p"
---
>       hence "length ?nnsr = n"
>         using length_nns_n by blast
>       hence LAST: "dist (last ?nns) p \<le> dist (last ?nnsr) p"
>         using last_nns_mono SORTED_R invar_l Node.prems(1,2,5) by (metis order_refl)
>       have "dist (last ?nnsr) p \<le> dist q p"
539c412
<       thus "sqed (last ?mnn) p \<le> sqed q p" 
---
>       thus "dist (last ?nns) p \<le> dist q p"
542c415
<     hence L: "\<forall>q \<in> set_kdt r - set ?mnn. sqed (last ?mnn) p \<le> sqed q p"
---
>     hence L: "\<forall>q \<in> set_kdt r - set ?nns. dist (last ?nns) p \<le> dist q p"
545c418
<     show ?thesis 
---
>     show ?thesis
548c421,427
< qed
---
> qed (auto simp: sorted_wrt_dist_nbors_diff upd_nbors_def)
> 
> 
> subsection \<open>Nearest Neighbors Definition and Theorems\<close>
> 
> definition nearest_neighbors :: "nat \<Rightarrow> ('k::finite) point \<Rightarrow> 'k kdt \<Rightarrow> 'k point list" where
>   "nearest_neighbors n p kdt = nearest_nbors n [] p kdt"
549a429,431
> theorem length_nearest_neighbors:
>   "length (nearest_neighbors n p kdt) = min n (size_kdt kdt)"
>   by (simp add: length_nns nearest_neighbors_def)
551c433,435
< subsection "Nearest Neighbors Definition and Theorems"
---
> theorem sorted_wrt_dist_nearest_neighbors:
>   "sorted_wrt_dist p (nearest_neighbors n p kdt)"
>   using sorted_nns unfolding nearest_neighbors_def sorted_wrt_dist_def by force
553,554c437,439
< definition nearest_neighbors :: "nat \<Rightarrow> point \<Rightarrow> kdt \<Rightarrow> point list" where
<   "nearest_neighbors m p kdt = nearest_nbors m [] p kdt"
---
> theorem set_nearest_neighbors:
>   "set (nearest_neighbors n p kdt) \<subseteq> set_kdt kdt"
>   unfolding nearest_neighbors_def using set_nns by force
556,576c441,449
< theorem nearest_neighbors_length:
<   "length (nearest_neighbors m p kdt) = min m (size_kdt kdt)"
<   using mnn_length nearest_neighbors_def by simp
< 
< theorem nearest_neighbors_sorted:
<   "sorted_sqed p (nearest_neighbors m p kdt)"
<   using mnn_sorted nearest_neighbors_def by simp
< 
< theorem nearest_neighbors_set:
<   "set (nearest_neighbors m p kdt) \<subseteq> set_kdt kdt"
<   using mnn_set nearest_neighbors_def by fastforce
< 
< theorem nearest_neighbors_distinct:
<   assumes "invar k kdt" "dim p = k"
<   shows "distinct (nearest_neighbors m p kdt)"
<   using assms mnn_distinct nearest_neighbors_def by simp
< 
< theorem nearest_neighbors:
<   assumes "invar k kdt" "dim p = k" "nearest_neighbors m p kdt = mns"
<   shows "\<forall>q \<in> (set_kdt kdt - set mns). \<forall>n \<in> set mns. sqed n p \<le> sqed q p"
< proof (cases "0 < m")
---
> theorem distinct_nearest_neighbors:
>   assumes "invar kdt"
>   shows "distinct (nearest_neighbors n p kdt)"
>   using assms by (simp add: distinct_nns nearest_neighbors_def)
> 
> theorem dist_nearest_neighbors:
>   assumes "invar kdt" "nns = nearest_neighbors n p kdt"
>   shows "\<forall>q \<in> (set_kdt kdt - set nns). \<forall>r \<in> set nns. dist r p \<le> dist q p"
> proof (cases "0 < n")
578,581c451,455
<   hence "\<forall>q \<in> set_kdt kdt - set mns. sqed (last mns) p \<le> sqed q p"
<     using assms nearest_neighbors_def mnn_sqed by auto
<   hence "\<forall>q \<in> set_kdt kdt - set mns. \<forall>n \<in> set mns. sqed n p \<le> sqed q p"
<     using assms(3) nearest_neighbors_sorted[of p m kdt] sorted_sqed_last[of p mns] by force
---
>   have "\<forall>q \<in> set_kdt kdt - set nns. dist (last nns) p \<le> dist q p"
>     using nearest_neighbors_def dist_nns[OF assms(1), of p "[]", OF _ _ _ True] assms(2)
>     by (simp add: nearest_neighbors_def sorted_wrt_dist_def)
>   hence "\<forall>q \<in> set_kdt kdt - set nns. \<forall>n \<in> set nns. dist n p \<le> dist q p"
>     using assms(2) sorted_wrt_dist_nearest_neighbors[of p n kdt] sorted_wrt_dist_last[of p nns] by force
586,587c460,461
<   hence "m = 0"
<     by simp
---
>   hence "length nns = 0"
>     using assms(2) unfolding nearest_neighbors_def by (auto simp: length_nns)
589c463
<     using assms(3) nearest_neighbors_def mnn_length_gt_eq_m by fastforce
---
>     by simp
592c466
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/KD_Tree/Range_Search.thy ../../AFPs/afp-2020/thys/KD_Tree/Range_Search.thy
6c6
< section "Search Queries on the \<open>k\<close>-d Tree"
---
> section \<open>Range Searching\<close>
9,10c9,10
< imports 
<   KDTree
---
> imports
>   KD_Tree
14,17c14,15
<   Verifying k-dimensional searches on the k-d tree.
< 
<   Given two \<open>k\<close>-dimensional points \<open>p\<^sub>0\<close> and \<open>p\<^sub>1\<close> which bound the search space, the search should return
<   only the points which satisfy the following criteria:
---
>   Given two \<open>k\<close>-dimensional points \<open>p\<^sub>0\<close> and \<open>p\<^sub>1\<close> which bound the search space, the search should
>   return only the points which satisfy the following criteria:
20,21c18,19
<   \hspace{1cm}  For every axis @{term "a \<in> {0..k-1}"}: \newline
<   \hspace{2cm}    @{term "min (p\<^sub>0!a) (p\<^sub>1!a) <= p!a \<and> p!a <= max (p\<^sub>0!a) (p\<^sub>1!a)"} \newline
---
>   \hspace{1cm}  For every axis @{term "k"}: \newline
>   \hspace{2cm}    @{term "p\<^sub>0$k \<le> p$k \<and> p$k \<le> p\<^sub>1$k"} \newline
23c21
<   In a \<open>2\<close>-d tree a query corresponds to selecting all the points in the rectangle which
---
>   For a \<open>2\<close>-d tree a query corresponds to selecting all the points in the rectangle that
27,34c25
< text \<open>
<   Simplify the problem by assuming that the two given points \<open>p\<^sub>0\<close> and \<open>p\<^sub>1\<close> are the left lower
<   and the right upper point.
< 
<   For every point p in the resulting set: \newline
<   \hspace{1cm}  For every axis @{term "a \<in> {0..k-1}"}: \newline
<   \hspace{2cm}    @{term "p\<^sub>0!a <= p\<^sub>1!a"} \newline
< \<close>
---
> subsection \<open>Rectangle Definition\<close>
35a27,38
> lemma cbox_point_def:
>   fixes p\<^sub>0 :: "('k::finite) point"
>   shows "cbox p\<^sub>0 p\<^sub>1 = { p. \<forall>k. p\<^sub>0$k \<le> p$k \<and> p$k \<le> p\<^sub>1$k }"
> proof -
>   have "cbox p\<^sub>0 p\<^sub>1 = { p. \<forall>k. p\<^sub>0 \<bullet> axis k 1 \<le> p \<bullet> axis k 1 \<and> p \<bullet> axis k 1 \<le> p\<^sub>1 \<bullet> axis k 1 }"
>     unfolding cbox_def using axis_inverse by auto
>   also have "... = { p. \<forall>k. p\<^sub>0$k \<bullet> 1 \<le> p$k \<bullet> 1 \<and> p$k \<bullet> 1 \<le> p\<^sub>1$k \<bullet> 1 }"
>     using inner_axis[of _ _ 1] by (smt Collect_cong)
>   also have "... = { p. \<forall>k. p\<^sub>0$k \<le> p$k \<and> p$k \<le> p\<^sub>1$k }"
>     by simp
>   finally show ?thesis .
> qed
37,40d39
< subsection "Search Function and Auxiliary Definitions"
< 
< definition is_bounding_box :: "dimension \<Rightarrow> point \<Rightarrow> point \<Rightarrow> bool" where
<   "is_bounding_box k p\<^sub>0 p\<^sub>1 \<longleftrightarrow> dim p\<^sub>0 = k \<and> dim p\<^sub>1 = k \<and> (\<forall>i < k. p\<^sub>0!i \<le> p\<^sub>1!i)"
42,43c41
< definition in_bounding_box :: "dimension \<Rightarrow> point \<Rightarrow> point \<Rightarrow> point \<Rightarrow> bool" where
<   "in_bounding_box k p p\<^sub>0 p\<^sub>1 \<longleftrightarrow> (\<forall>i < k. p\<^sub>0!i \<le> p!i \<and> p!i \<le> p\<^sub>1!i)"
---
> subsection \<open>Search Function\<close>
45,51c43,49
< fun search_rec :: "dimension \<Rightarrow> point \<Rightarrow> point \<Rightarrow> kdt \<Rightarrow> point set" where
<   "search_rec k p\<^sub>0 p\<^sub>1 (Leaf p) = (if in_bounding_box k p p\<^sub>0 p\<^sub>1 then {p} else {})"
< | "search_rec k p\<^sub>0 p\<^sub>1 (Node a s l r) = (
<     if s < p\<^sub>0!a then
<       search_rec k p\<^sub>0 p\<^sub>1 r
<     else if p\<^sub>1!a < s then
<       search_rec k p\<^sub>0 p\<^sub>1 l
---
> fun search :: "('k::finite) point \<Rightarrow> 'k point \<Rightarrow> 'k kdt \<Rightarrow> 'k point set" where
>   "search p\<^sub>0 p\<^sub>1 (Leaf p) = (if p \<in> cbox p\<^sub>0 p\<^sub>1 then { p } else {})"
> | "search p\<^sub>0 p\<^sub>1 (Node k v l r) = (
>     if v < p\<^sub>0$k then
>       search p\<^sub>0 p\<^sub>1 r
>     else if p\<^sub>1$k < v then
>       search p\<^sub>0 p\<^sub>1 l
53c51
<       search_rec k p\<^sub>0 p\<^sub>1 l \<union> search_rec k p\<^sub>0 p\<^sub>1 r
---
>       search p\<^sub>0 p\<^sub>1 l \<union> search p\<^sub>0 p\<^sub>1 r
57c55
< subsection "Auxiliary Lemmas"
---
> subsection \<open>Auxiliary Lemmas\<close>
59,62c57,59
< lemma l_pibb_empty:
<   assumes "invar k (Node a s l r)" "s < p\<^sub>0!a"
<   shows "{ p \<in> set_kdt l. in_bounding_box k p p\<^sub>0 p\<^sub>1 } = {}"
<   using assms
---
> lemma l_empty:
>   assumes "invar (Node k v l r)" "v < p\<^sub>0$k"
>   shows "set_kdt l \<inter> cbox p\<^sub>0 p\<^sub>1 = {}"
64,69c61,64
<   have "\<forall>p \<in> set_kdt l. p!a < p\<^sub>0!a"
<     using invar_l_le_a assms(1,2) by auto
<   hence "\<forall>p \<in> set_kdt l. (\<exists>i < k. p!i < p\<^sub>0!i \<or> p\<^sub>1!i < p!i)"
<     using assms(1) invar_axis_lt_d by blast
<   hence "\<forall>p \<in> set_kdt l. \<not>in_bounding_box k p p\<^sub>0 p\<^sub>1"
<     using in_bounding_box_def by fastforce
---
>   have "\<forall>p \<in> set_kdt l. p$k < p\<^sub>0$k"
>     using assms by auto
>   hence "\<forall>p \<in> set_kdt l. p \<notin> cbox p\<^sub>0 p\<^sub>1"
>     using cbox_point_def leD by blast
73,76c68,70
< lemma r_pibb_empty:
<   assumes "invar k (Node a s l r)" "p\<^sub>1!a < s"
<   shows "{ p \<in> set_kdt r. in_bounding_box k p p\<^sub>0 p\<^sub>1 } = {}"
<   using assms
---
> lemma r_empty:
>   assumes "invar (Node k v l r)" "p\<^sub>1$k < v"
>   shows "set_kdt r \<inter> cbox p\<^sub>0 p\<^sub>1 = {}"
78,83c72,75
<   have "\<forall>p \<in> set_kdt r. p\<^sub>1!a < p!a"
<     using invar_r_ge_a assms(1,2) by auto
<   hence "\<forall>p \<in> set_kdt r. (\<exists>i < k. p!i < p\<^sub>0!i \<or> p\<^sub>1!i < p!i)"
<     using assms(1) invar_axis_lt_d by blast
<   hence "\<forall>p \<in> set_kdt r. \<not>in_bounding_box k p p\<^sub>0 p\<^sub>1"
<     using in_bounding_box_def by fastforce
---
>   have "\<forall>p \<in> set_kdt r. p\<^sub>1$k < p$k"
>     using assms by auto
>   hence "\<forall>p \<in> set_kdt r. p \<notin> cbox p\<^sub>0 p\<^sub>1"
>     using cbox_point_def leD by blast
88c80
< subsection "Simplified Main Theorem"
---
> subsection \<open>Main Theorem\<close>
90,164c82,85
< theorem search_rec:
<   assumes "invar k kdt"
<   shows "search_rec k p\<^sub>0 p\<^sub>1 kdt = { p \<in> set_kdt kdt. in_bounding_box k p p\<^sub>0 p\<^sub>1 }"
<   using assms l_pibb_empty r_pibb_empty
<   by (induction kdt) auto
< 
< 
< subsection "Search and Auxiliary Definitions"
< 
< definition to_bounding_box :: "point \<Rightarrow> point \<Rightarrow> point * point" where
<   "to_bounding_box p\<^sub>0 p\<^sub>1 = (
<     let is = zip p\<^sub>0 p\<^sub>1 in 
<     (map (\<lambda>(i, j). min i j) is, map (\<lambda>(i, j). max i j) is)
<   )"
< 
< definition search :: "point \<Rightarrow> point \<Rightarrow> kdt \<Rightarrow> point set" where
< "search q\<^sub>0 q\<^sub>1 kdt =
<   (let (p\<^sub>0, p\<^sub>1) = to_bounding_box q\<^sub>0 q\<^sub>1
<    in search_rec (dim q\<^sub>0) p\<^sub>0 p\<^sub>1 kdt)"
< 
< 
< subsection "Auxiliary Lemmas"
< 
< lemma to_bounding_box_is_bounding_box:
<   assumes "dim q\<^sub>0 = k" "dim q\<^sub>1 = k" "(p\<^sub>0 ,p\<^sub>1) = to_bounding_box q\<^sub>0 q\<^sub>1"
<   shows "is_bounding_box k p\<^sub>0 p\<^sub>1"
<   using assms by (auto simp add: to_bounding_box_def is_bounding_box_def Let_def)
< 
< lemma in_bounding_box:
<   assumes "dim q\<^sub>0 = k" "dim q\<^sub>1 = k" "(p\<^sub>0, p\<^sub>1) = to_bounding_box q\<^sub>0 q\<^sub>1"
<   shows "in_bounding_box k p p\<^sub>0 p\<^sub>1 \<longleftrightarrow> (\<forall>i < k. min (q\<^sub>0!i) (q\<^sub>1!i) \<le> p!i \<and> p!i \<le> max (q\<^sub>0!i) (q\<^sub>1!i))"
<   using assms by (auto simp add: min_def max_def to_bounding_box_def in_bounding_box_def Let_def)
< 
< 
< subsection "Main Theorem and Corollaries"
< 
< theorem search:
<   assumes "invar k kdt" "dim q\<^sub>0 = k" "dim q\<^sub>1 = k"
<   shows "search q\<^sub>0 q\<^sub>1 kdt = { x \<in> set_kdt kdt. \<forall>i < k. min (q\<^sub>0!i) (q\<^sub>1!i) \<le> x!i \<and> x!i \<le> max (q\<^sub>0!i) (q\<^sub>1!i) }"
<   using assms to_bounding_box_is_bounding_box in_bounding_box search_rec
<   by (auto simp add: search_def)
< 
< corollary search_subset:
<   assumes "invar k kdt" "dim q\<^sub>0 = k" "dim q\<^sub>1 = k"
<   shows "search q\<^sub>0 q\<^sub>1 kdt \<subseteq> set_kdt kdt"
<   using assms search by auto
< 
< corollary search_com:
<   assumes "invar k kdt" "dim q\<^sub>0 = k" "dim q\<^sub>1 = k"
<   shows "search q\<^sub>0 q\<^sub>1 kdt = search q\<^sub>1 q\<^sub>0 kdt"
<   using assms search by auto
< 
< corollary search_inverse:
<   assumes "invar k kdt" "dim q\<^sub>0 = k" "dim q\<^sub>1 = k" 
<   assumes "p \<in> set_kdt kdt" "\<forall>i < k. min (q\<^sub>0!i) (q\<^sub>1!i) \<le> p!i \<and> p!i \<le> max (q\<^sub>0!i) (q\<^sub>1!i)"
<   shows "p \<in> search q\<^sub>0 q\<^sub>1 kdt"
<   using assms search by blast
< 
< corollary search_singleton:
<   assumes "invar k kdt" "dim q\<^sub>0 = k" "q\<^sub>0 = q\<^sub>1" "q\<^sub>0 \<in> set_kdt kdt"
<   shows "search q\<^sub>0 q\<^sub>1 kdt = {q\<^sub>0}"
< proof -
<   have *: "search q\<^sub>0 q\<^sub>1 kdt = { x \<in> set_kdt kdt. \<forall>i < k. q\<^sub>0!i = x!i }"
<     using search assms(1,2,3) by auto
<   have 1: "{q\<^sub>0} \<subseteq> search q\<^sub>0 q\<^sub>1 kdt"
<     using * assms(4) by blast
<   have "\<forall>p \<in> search q\<^sub>0 q\<^sub>1 kdt. dim p = k"
<     using * assms(1) invar_dim by simp
<   moreover have "\<forall>p \<noteq> q\<^sub>0. dim p = k \<longrightarrow> (\<exists>i < k. q\<^sub>0!i \<noteq> p!i)"
<     using assms(2) nth_equalityI by fastforce
<   ultimately have 2: "search q\<^sub>0 q\<^sub>1 kdt \<subseteq> {q\<^sub>0}"
<     using * by blast
<   show ?thesis
<     using 1 2 by blast
< qed
---
> theorem search_cbox:
>   assumes "invar kdt"
>   shows "search p\<^sub>0 p\<^sub>1 kdt = set_kdt kdt \<inter> cbox p\<^sub>0 p\<^sub>1"
>   using assms l_empty r_empty by (induction kdt) (auto, blast+)
166c87
< end
\ No newline at end of file
---
> end
==========
Kruskal
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Kruskal/UGraph_Impl.thy ../../AFPs/afp-2020/thys/Kruskal/UGraph_Impl.thy
26c26
<   abbreviation "V \<equiv> (UNION E set_uprod)"
---
>   abbreviation "V \<equiv> \<Union> (set_uprod ` E)"
65,66c65,66
<   case (6 E1 E2 u v) 
<   then have "(u, v) \<in> (uconnected E1)" and uv: "u \<in> (UNION E set_uprod)" "v\<in>(UNION E set_uprod)"
---
>   case (6 E1 E2 u v)
>   then have "(u, v) \<in> (uconnected E1)" and uv: "u \<in> V" "v \<in> V"
83c83
<     then show "((u, v) \<notin> Restr (uconnected F) (UNION E set_uprod))" by auto
---
>     then show "((u, v) \<notin> Restr (uconnected F) V)" by auto
85c85
<     assume a: "(u, v) \<notin> Restr (uconnected F) (UNION E set_uprod)"
---
>     assume a: "(u, v) \<notin> Restr (uconnected F) V"
==========
Kuratowski_Closure_Complement
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy ../../AFPs/afp-2020/thys/Kuratowski_Closure_Complement/KuratowskiClosureComplementTheorem.thy
4c4,5
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
>   "HOL-Analysis.Continuum_Not_Denumerable"
==========
LambdaAuth
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LambdaAuth/Agreement.thy ../../AFPs/afp-2020/thys/LambdaAuth/Agreement.thy
111c111
<   using assms 
---
>   using assms
464c464
<     by (force simp add: fresh_at_base fresh_fmap_update fmap_reorder_neq_updates)
---
>     by (force simp add: fresh_at_base fresh_fmap_update fmupd_reorder_neq)
472c472
<     by (auto simp add: fresh_at_base fresh_Pair fresh_fmap_update fmap_reorder_neq_updates[of y x]
---
>     by (auto simp add: fresh_at_base fresh_Pair fresh_fmap_update fmupd_reorder_neq[of x y]
477c477
<     by (auto simp add: fresh_at_base fresh_Pair fresh_fmap_update fmap_reorder_neq_updates[of y x]
---
>     by (auto simp add: fresh_at_base fresh_Pair fresh_fmap_update fmupd_reorder_neq[of x y]
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LambdaAuth/FMap_Lemmas.thy ../../AFPs/afp-2020/thys/LambdaAuth/FMap_Lemmas.thy
94,101d93
< lemma fmap_reorder_neq_updates:
<   assumes "a \<noteq> b"
<   shows   "\<Gamma>(a $$:= x)(b $$:= y) = \<Gamma>(b $$:= y)(a $$:= x)"
<   using assms by transfer (auto simp: map_upd_def)
< 
< lemma fmap_upd_upd[simp]: "\<Gamma>(x $$:= y)(x $$:= z) = \<Gamma>(x $$:= z)"
<   by transfer (simp add: map_upd_def)
< 
108,110d99
< lemma fmmap_fmupd: "fmmap f F(x $$:= y) = (fmmap f F)(x $$:= f y)"
<   by transfer (auto simp: fun_eq_iff map_upd_def)
< 
154,156d142
< lemma fmdrop_fmupd: "fmdrop x F(y $$:= z) = (if x = y then fmdrop x F else (fmdrop x F)(y $$:= z))"
<   by transfer (auto simp: map_drop_def map_filter_def map_upd_def)
< 
161,166d146
< lemma fmdrop_idle: "x \<notin> fmdom' B \<Longrightarrow> fmdrop x B = B"
<   by transfer (auto simp: map_drop_def map_filter_def)
< 
< lemma fmdrop_fmupd_same: "fmdrop x B(x $$:= y) = fmdrop x B"
<   by transfer (auto simp: map_drop_def map_filter_def map_upd_def)
< 
184c164
<   using assms by (cases "y \<in> fmdom' B") (auto dest!: fresh_fmdrop_in_fmdom simp: fmdrop_idle)
---
>   using assms by (cases "y \<in> fmdom' B") (auto dest!: fresh_fmdrop_in_fmdom simp: fmdrop_idle')
191,193d170
< 
< lemma fmdrop_fset_fmdom[simp]: "fmdrop_fset (fmdom A) A = {$$}"
<   by (induct A) (simp_all add: fmap_ext fmdom_notD)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LambdaAuth/Results.thy ../../AFPs/afp-2020/thys/LambdaAuth/Results.thy
282c282
<     using agree_empty_fresh by (auto simp: fmap_reorder_neq_updates)
---
>     using agree_empty_fresh by (auto simp: fmupd_reorder_neq)
290c290
<     using agree_empty_fresh by (auto simp: fmap_reorder_neq_updates intro!: agree.a_Let[where x=y])
---
>     using agree_empty_fresh by (auto simp: fmupd_reorder_neq intro!: agree.a_Let[where x=y])
296,297c296,297
<     using a_Rec(9)[OF fmap_reorder_neq_updates]
<     by (auto simp: fmap_reorder_neq_updates intro!: agree.a_Rec[where x=y])
---
>     using a_Rec(9)[OF fmupd_reorder_neq]
>     by (auto simp: fmupd_reorder_neq intro!: agree.a_Rec[where x=y])
377c377
<             by (auto simp: fmap_reorder_neq_updates
---
>             by (auto simp: fmupd_reorder_neq
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LambdaAuth/Semantics.thy ../../AFPs/afp-2020/thys/LambdaAuth/Semantics.thy
116a117,120
> lemma map_fixed_idle_closed:
>   "closed t \<Longrightarrow> map_fixed undefined [] t = t"
>   by (rule map_fixed_idle) auto
> 
119c123,128
<   by (erule box_equals[OF _ map_fixed_idle map_fixed_idle]) auto
---
>   by (rule box_equals[OF _ map_fixed_idle_closed map_fixed_idle_closed])
> 
> lemma hash_eq_hash_real_closed:
>   assumes "closed t"
>   shows "hash t = hash_real t"
>   unfolding hash_def map_fixed_idle_closed[OF assms] ..
277c286
< lemma type_subst_subst: "atom y1 \<noteq> atom y2 \<Longrightarrow> atom y1 \<sharp> s2 \<Longrightarrow> 
---
> lemma type_subst_subst: "atom y1 \<noteq> atom y2 \<Longrightarrow> atom y1 \<sharp> s2 \<Longrightarrow>
1014c1023
<     by (auto simp add: fresh_at_base fmap_reorder_neq_updates fresh_fmap_update)
---
>     by (auto simp add: fresh_at_base fmupd_reorder_neq fresh_fmap_update)
1018c1027
<     by (force simp add: fresh_at_base fmap_reorder_neq_updates fresh_fmap_update)
---
>     by (force simp add: fresh_at_base fmupd_reorder_neq fresh_fmap_update)
1022c1031
<     by (auto simp add: fresh_at_base fmap_reorder_neq_updates fresh_fmap_update)
---
>     by (auto simp add: fresh_at_base fmupd_reorder_neq fresh_fmap_update)
1026c1035
<     by (auto simp add: fresh_at_base fmap_reorder_neq_updates fresh_fmap_update fresh_Pair)
---
>     by (auto simp add: fresh_at_base fmupd_reorder_neq fresh_fmap_update fresh_Pair)
1030c1039
<     by (fastforce simp add: fresh_at_base fmap_reorder_neq_updates fresh_fmap_update)
---
>     by (fastforce simp add: fresh_at_base fmupd_reorder_neq fresh_fmap_update)
1077c1086
<     by (fastforce simp: fmap_reorder_neq_updates)
---
>     by (fastforce simp: fmupd_reorder_neq)
1081c1090
<     by (fastforce simp: fmap_reorder_neq_updates)
---
>     by (fastforce simp: fmupd_reorder_neq)
1085c1094
<     by (fastforce simp: fmap_reorder_neq_updates)
---
>     by (fastforce simp: fmupd_reorder_neq)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LambdaAuth/Syntax.thy ../../AFPs/afp-2020/thys/LambdaAuth/Syntax.thy
69c69
<   "value (Hashed _ _)"
---
>   "value v \<Longrightarrow> value (Hashed _ v)"
90a91
> inductive_cases value_Hashed_inv[elim]: "value (Hashed h e)"
==========
Lambda_Free_EPO
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_EPO/Chop.thy ../../AFPs/afp-2020/thys/Lambda_Free_EPO/Chop.thy
31,41c31,33
< (* TODO: move? *)
< lemma size_apps: "size (apps t ts) = size t + sum_list (map size ts) + length ts"
<   by (induct ts arbitrary:t; simp)
< 
< (* TODO: move? *)
< lemma size_args_plus_num_args: "1 + sum_list (map size (args t)) + num_args t = size t"
<   by (metis One_nat_def size_apps tm.size(3) tm_collapse_apps)
< 
< lemma size_chop: "is_App t \<Longrightarrow> Suc (Suc (size (chop t))) = size t"
<   unfolding size_args_plus_num_args[of t, symmetric] chop_def size_apps
<   by (metis Nitpick.size_list_simp(1) ab_semigroup_add_class.add_ac(1) args_Nil_iff_is_Hd plus_1_eq_Suc size_list_conv_sum_list)
---
> lemma hsize_chop: "is_App t \<Longrightarrow> (Suc (hsize (chop t))) = hsize t"
>   unfolding hsize_args[of t, symmetric] chop_def hsize_apps
>   by (metis Nil_is_map_conv args_Nil_iff_is_Hd list.exhaust_sel list.map_sel(1) map_tl plus_1_eq_Suc sum_list.Cons)
43,44c35,36
< lemma size_chop_lt: "is_App t \<Longrightarrow> size (chop t) < size t"
<   by (simp add: Suc_le_lessD less_or_eq_imp_le size_chop)
---
> lemma hsize_chop_lt: "is_App t \<Longrightarrow> hsize (chop t) < hsize t"
>   by (simp add: Suc_le_lessD less_or_eq_imp_le hsize_chop)
275c267
<   by (metis Suc_n_not_le_n assms chop_emb_step_at lessI less_imp_le_nat position_if_emb_step_at size_chop)
---
>   by (metis Suc_n_not_le_n assms chop_emb_step_at lessI less_imp_le_nat position_if_emb_step_at hsize_chop)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_EPO/Embeddings.thy ../../AFPs/afp-2020/thys/Lambda_Free_EPO/Embeddings.thy
175c175
< lemma emb_step_size: "t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s \<Longrightarrow> size t > size s" 
---
> lemma emb_step_hsize: "t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s \<Longrightarrow> hsize t > hsize s" 
280c280
< lemma emb_size: "t \<unrhd>\<^sub>e\<^sub>m\<^sub>b s \<Longrightarrow> size t \<ge> size s" 
---
> lemma emb_hsize: "t \<unrhd>\<^sub>e\<^sub>m\<^sub>b s \<Longrightarrow> hsize t \<ge> hsize s" 
283c283
<   using emb_step_size by fastforce
---
>   using emb_step_hsize by fastforce
415c415
< lemma emb_size_neq:
---
> lemma emb_hsize_neq:
419,420c419,420
<     "size t > size s"
<   by (metis assms(1) assms(2) emb_cases_reverse emb_size emb_step_size leD le_imp_less_or_eq)
---
>     "hsize t > hsize s"
>   by (metis assms(1) assms(2) emb_cases_reverse emb_hsize emb_step_hsize leD le_imp_less_or_eq)
678c678
< proof (induct t rule:measure_induct_rule[of size])
---
> proof (induct t rule:measure_induct_rule[of hsize])
690,691c690,691
<     have "size (emb_step_at' (prio_emb_pos prio t s) t) < size t"
<       by (simp add: False emb_step_at_if_position emb_step_size less.prems(1) prio_emb_posI)
---
>     have "hsize (emb_step_at' (prio_emb_pos prio t s) t) < hsize t"
>       by (simp add: False emb_step_at_if_position emb_step_hsize less.prems(1) prio_emb_posI)
697c697
<       using less(1)[of "emb_step_at' (prio_emb_pos prio t s) t"] emb_step_size 
---
>       using less(1)[of "emb_step_at' (prio_emb_pos prio t s) t"] emb_step_hsize 
875c875
< proof (induct s rule:measure_induct_rule[of size])
---
> proof (induct s rule:measure_induct_rule[of hsize])
886c886
<       by (meson emb_step_is_emb emb_step_size emb_trans less.hyps less.prems(1))
---
>       by (meson emb_step_is_emb emb_step_hsize emb_trans less.hyps less.prems(1))
930,931c930,931
<         then show ?case using emb_size_neq
<           by (metis Suc.IH Suc.prems Suc_lessD emb_size emb_step_is_emb emb_trans leD)
---
>         then show ?case using emb_hsize_neq
>           by (metis Suc.IH Suc.prems Suc_lessD emb_hsize emb_step_is_emb emb_trans leD)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_EPO/Lambda_Free_EPO.thy ../../AFPs/afp-2020/thys/Lambda_Free_EPO/Lambda_Free_EPO.thy
9c9
< imports Chop
---
> imports Chop Nested_Multisets_Ordinals.Multiset_More
110c110
<     rule measure_induct_rule[of "\<lambda>(t, s). size t + size s"
---
>     rule measure_induct_rule[of "\<lambda>(t, s). hsize t + hsize s"
115c115
<     ih: "\<And>ta sa. size ta + size sa < size t + size s \<Longrightarrow> ta >\<^sub>t sa \<Longrightarrow> vars ta \<supseteq> vars sa" and
---
>     ih: "\<And>ta sa. hsize ta + hsize sa < hsize t + hsize s \<Longrightarrow> ta >\<^sub>t sa \<Longrightarrow> vars ta \<supseteq> vars sa" and
123c123
<       by (metis add_mono_thms_linordered_field(1) le_supI1 order_refl size_chop_lt vars_chop)
---
>       by (metis add_mono_thms_linordered_field(1) le_supI1 order_refl hsize_chop_lt vars_chop)
135c135
<         using App chkchop_def local.gt_diff(3) nat_add_left_cancel_less size_chop_lt tm.disc(2) by blast
---
>         using App chkchop_def local.gt_diff(3) nat_add_left_cancel_less hsize_chop_lt tm.disc(2) by blast
163c163
<             by (metis App add_mono_thms_linordered_field(5) args_Nil_iff_is_Hd extf_min_empty gt_hd_def gt_hd_irrefl local.gt_same(3) size_chop_lt tm.disc(2))
---
>             by (metis App add_mono_thms_linordered_field(5) args_Nil_iff_is_Hd extf_min_empty gt_hd_def gt_hd_irrefl local.gt_same(3) hsize_chop_lt tm.disc(2))
179c179
<               nat_add_left_cancel_less size_chop_lt tm.disc(2) vars_head_subseteq)
---
>               nat_add_left_cancel_less hsize_chop_lt tm.disc(2) vars_head_subseteq)
187c187
<     rule measure_induct_rule[of "\<lambda>(u, t, s). {#size u, size t, size s#}"
---
>     rule measure_induct_rule[of "\<lambda>(u, t, s). {#hsize u, hsize t, hsize s#}"
193c193
<     ih: "\<And>ua ta sa. {#size ua, size ta, size sa#} < {#size u, size t, size s#} \<Longrightarrow>
---
>     ih: "\<And>ua ta sa. {#hsize ua, hsize ta, hsize sa#} < {#hsize u, hsize t, hsize s#} \<Longrightarrow>
198c198
<     using ih[of "chop u" t s, simplified] t_gt_s gt_chop size_chop_lt ui_in by blast
---
>     using ih[of "chop u" t s, simplified] t_gt_s gt_chop hsize_chop_lt ui_in by blast
206c206
<       by (metis add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def ih size_chop_lt)
---
>       by (metis add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def ih hsize_chop_lt)
224c224
<         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def  gt_diff gt_diff_t_s(3) ih size_chop_lt u_gt_t
---
>         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def  gt_diff gt_diff_t_s(3) ih hsize_chop_lt u_gt_t
231c231
<         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_diff_t_s(3) ih size_chop_lt u_gt_t
---
>         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_diff_t_s(3) ih hsize_chop_lt u_gt_t
247c247
<         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_same_t_s ih size_chop_lt u_gt_t
---
>         using add_mset_lt_left_lt add_mset_lt_right_lt chkchop_def gt_diff gt_same_t_s ih hsize_chop_lt u_gt_t
265c265
<                size_in_args)+
---
>                hsize_in_args)+
300c300
<               by (metis App \<open>chop u >\<^sub>t chop t\<close> t_App add_mset_lt_lt_le less_imp_le mset_lt_single_iff size_chop_lt tm.disc(2))
---
>               by (metis App \<open>chop u >\<^sub>t chop t\<close> t_App add_mset_lt_lt_le less_imp_le mset_lt_single_iff hsize_chop_lt tm.disc(2))
317c317
<              by (metis App add_mset_lt_right_lt mset_lt_single_iff size_chop_lt tm.disc(2) u_gt_t)
---
>              by (metis App add_mset_lt_right_lt mset_lt_single_iff hsize_chop_lt tm.disc(2) u_gt_t)
333c333
< proof (standard, induct s rule: measure_induct_rule[of size])
---
> proof (standard, induct s rule: measure_induct_rule[of hsize])
342c342
<       by (metis gt.gt_chop gt_trans size_chop_lt)
---
>       by (metis gt.gt_chop gt_trans hsize_chop_lt)
354,355c354,355
<     have "size si < size s"
<       by (rule size_in_args[OF si_in_args])
---
>     have "hsize si < hsize s"
>       by (rule hsize_in_args[OF si_in_args])
398c398
<   apply (rule measure_induct_rule[of "\<lambda>(t, s). size t + size s"
---
>   apply (rule measure_induct_rule[of "\<lambda>(t, s). hsize t + hsize s"
403c403
<     and ih: "\<And>tt ss. size tt + size ss < size t + size s \<Longrightarrow> tt \<rightarrow>\<^sub>e\<^sub>m\<^sub>b ss \<Longrightarrow> tt >\<^sub>t ss"
---
>     and ih: "\<And>tt ss. hsize tt + hsize ss < hsize t + hsize s \<Longrightarrow> tt \<rightarrow>\<^sub>e\<^sub>m\<^sub>b ss \<Longrightarrow> tt >\<^sub>t ss"
438c438
<             by (metis \<open>is_App s\<close> \<open>is_App t\<close> \<open>t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s\<close> emb_step_equiv emb_step_size nat_neq_iff size_chop)
---
>             by (metis \<open>is_App s\<close> \<open>is_App t\<close> \<open>t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s\<close> emb_step_equiv emb_step_hsize nat_neq_iff hsize_chop)
469c469
<            add_less_mono size_chop_lt \<open>is_App s \<Longrightarrow> chop t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b chop s\<close> by metis
---
>            add_less_mono hsize_chop_lt \<open>is_App s \<Longrightarrow> chop t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b chop s\<close> by metis
473c473
<         using \<open>is_App t\<close> add_less_mono gt_chop ih size_chop_lt 
---
>         using \<open>is_App t\<close> add_less_mono gt_chop ih hsize_chop_lt 
484c484
<         by (metis Right True \<open>emb_step_at p d t = s\<close> \<open>is_App t\<close> \<open>position_of t (p @ [d])\<close> add_Suc gt_chop ih less_Suc_eq size_chop)
---
>         by (metis Right True \<open>emb_step_at p d t = s\<close> \<open>is_App t\<close> \<open>position_of t (p @ [d])\<close> add_Suc gt_chop ih less_Suc_eq hsize_chop)
528c528
<         by (metis \<open>is_App s\<close> \<open>is_App t\<close> \<open>t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s\<close> emb_step_size nat_less_le size_chop)
---
>         by (metis \<open>is_App s\<close> \<open>is_App t\<close> \<open>t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b s\<close> emb_step_hsize nat_less_le hsize_chop)
549c549
<         by (meson \<open>chop t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b chop s\<close> \<open>is_App s\<close> \<open>is_App t\<close> add_strict_mono size_chop_lt)
---
>         by (meson \<open>chop t \<rightarrow>\<^sub>e\<^sub>m\<^sub>b chop s\<close> \<open>is_App s\<close> \<open>is_App t\<close> add_strict_mono hsize_chop_lt)
556c556
<          less_Suc_eq size_chop t_gt_chop_t 
---
>          less_Suc_eq hsize_chop t_gt_chop_t 
571c571
<         by (metis \<open>num_args t = num_args s\<close> \<open>emb_step_at p d t = s\<close>  add_less_mono i_def(1) i_def(2) ih nth_mem size_in_args)
---
>         by (metis \<open>num_args t = num_args s\<close> \<open>emb_step_at p d t = s\<close>  add_less_mono i_def(1) i_def(2) ih nth_mem hsize_in_args)
633c633
< proof (induction rule:measure_induct_rule[of "\<lambda>(t, s). size t + size s" "\<lambda>(t, s). t' >\<^sub>t t \<longrightarrow> App s t' >\<^sub>t App s t" "(t,s)", 
---
> proof (induction rule:measure_induct_rule[of "\<lambda>(t, s). hsize t + hsize s" "\<lambda>(t, s). t' >\<^sub>t t \<longrightarrow> App s t' >\<^sub>t App s t" "(t,s)", 
638c638
<   assume ih:"\<And>ta sa. size ta + size sa < size t + size s \<Longrightarrow> t' >\<^sub>t ta \<Longrightarrow> App sa t' >\<^sub>t App sa ta"
---
>   assume ih:"\<And>ta sa. hsize ta + hsize sa < hsize t + hsize s \<Longrightarrow> t' >\<^sub>t ta \<Longrightarrow> App sa t' >\<^sub>t App sa ta"
659c659
<         by (metis nat_add_left_cancel_less size_chop_lt t'_gt_t tm.disc(2) tm.sel(4) tm.sel(6))
---
>         by (metis nat_add_left_cancel_less hsize_chop_lt t'_gt_t tm.disc(2) tm.sel(4) tm.sel(6))
677c677
< proof (simp only:atomize_imp,induction rule:measure_induct[of "\<lambda>(s',s,t). size s' + size s + size t" "\<lambda>(s',s,t). s' >\<^sub>t s \<longrightarrow> t' \<ge>\<^sub>t t \<longrightarrow> App s' t' >\<^sub>t App s t" "(s',s,t)", simplified prod.case],
---
> proof (simp only:atomize_imp,induction rule:measure_induct[of "\<lambda>(s',s,t). hsize s' + hsize s + hsize t" "\<lambda>(s',s,t). s' >\<^sub>t s \<longrightarrow> t' \<ge>\<^sub>t t \<longrightarrow> App s' t' >\<^sub>t App s t" "(s',s,t)", simplified prod.case],
680c680
<   assume ih:"\<And>ab ac ba. size ab + size ac + size ba < size s' + size s + size t \<Longrightarrow> ab >\<^sub>t ac \<Longrightarrow> t' \<ge>\<^sub>t ba \<Longrightarrow> App ab t' >\<^sub>t App ac ba" 
---
>   assume ih:"\<And>ab ac ba. hsize ab + hsize ac + hsize ba < hsize s' + hsize s + hsize t \<Longrightarrow> ab >\<^sub>t ac \<Longrightarrow> t' \<ge>\<^sub>t ba \<Longrightarrow> App ab t' >\<^sub>t App ac ba" 
684c684
<     fix s''::"('s,'v) tm" assume size_s'':"size s'' \<le> size s'"
---
>     fix s''::"('s,'v) tm" assume hsize_s'':"hsize s'' \<le> hsize s'"
694,695c694,695
<         using ih[of s'' "chop s" t] size_s''
<         by (metis \<open>t' \<ge>\<^sub>t t\<close> add_less_mono add_mono_thms_linordered_field(1) chop_fun le_eq_less_or_eq nat_add_left_cancel_less size_chop_lt tm.sel(4) tm.sel(6))
---
>         using ih[of s'' "chop s" t] hsize_s''
>         by (metis \<open>t' \<ge>\<^sub>t t\<close> add_less_mono add_mono_thms_linordered_field(1) chop_fun le_eq_less_or_eq nat_add_left_cancel_less hsize_chop_lt tm.sel(4) tm.sel(6))
707c707
<         by (metis add_strict_right_mono chop_fun ih size_chop_lt tm.disc(2) tm.sel(4) tm.sel(6))
---
>         by (metis add_strict_right_mono chop_fun ih hsize_chop_lt tm.disc(2) tm.sel(4) tm.sel(6))
715c715
<         using \<open>t' >\<^sub>t t\<close> gt_compat_fun local.gt_chop(1) local.gt_chop(2) size_chop_lt by fastforce
---
>         using \<open>t' >\<^sub>t t\<close> gt_compat_fun local.gt_chop(1) local.gt_chop(2) hsize_chop_lt by fastforce
758c758
<       size_chop_lt   epo.extf_min_empty[OF epo_axioms] gt.gt_same gt_antisym hd_s'_eq_s head_App 
---
>       hsize_chop_lt   epo.extf_min_empty[OF epo_axioms] gt.gt_same gt_antisym hd_s'_eq_s head_App 
803,817d802
< (* TODO: move ? *)
< lemma less_multiset_doubletons:
<   assumes
<     "y <  t \<or>  y <  s"  
<     "x <  t \<or>  x <  s" 
<   shows 
<     "{# y,  x#} < {# t,  s#}" 
<   unfolding less_multiset\<^sub>D\<^sub>M
< proof (intro exI)
<   let ?X = "{# t,  s#}"
<   let ?Y = "{#y, x#}"
<   show "?X \<noteq> {#} \<and> ?X \<subseteq># {#t, s#} \<and> {#y, x#} = {#t, s#} - ?X + ?Y \<and> (\<forall>k. k \<in># ?Y \<longrightarrow> (\<exists>a. a \<in># ?X \<and> k < a))"
<     using add_eq_conv_diff assms(1) assms(2) by auto
< qed
< 
822c807
< proof (simp only:atomize_imp,induction rule:measure_induct[of "\<lambda>(t,s). {# size t, size s #}" "\<lambda>(t,s). t >\<^sub>t s \<longrightarrow> subst \<rho> t >\<^sub>t subst \<rho> s" "(t,s)", simplified prod.case],
---
> proof (simp only:atomize_imp,induction rule:measure_induct[of "\<lambda>(t,s). {# hsize t, hsize s #}" "\<lambda>(t,s). t >\<^sub>t s \<longrightarrow> subst \<rho> t >\<^sub>t subst \<rho> s" "(t,s)", simplified prod.case],
826c811
<                {# size tt, size ss #} < {# size t, size s #} \<Longrightarrow>
---
>                {# hsize tt, hsize ss #} < {# hsize t, hsize s #} \<Longrightarrow>
834c819
<        emb_step_size gt_trans ih[of "chop t" s] by (metis add_mset_lt_left_lt)
---
>        emb_step_hsize gt_trans ih[of "chop t" s] by (metis add_mset_lt_left_lt)
850c835
<         using ih[of t "chop s"] chop_subst_Sym size_chop_lt tm.disc(2)
---
>         using ih[of t "chop s"] chop_subst_Sym hsize_chop_lt tm.disc(2)
863c848
<         by (metis Un_iff less_multiset_doubletons size_in_args ih)
---
>         by (metis Un_iff less_multiset_doubletons hsize_in_args ih)
877c862
<         assume "ground_heads (head u) \<subseteq> ground_heads (head t)" "size u \<le> size (subst \<rho> (Hd (head t)))"
---
>         assume "ground_heads (head u) \<subseteq> ground_heads (head t)" "hsize u \<le> hsize (subst \<rho> (Hd (head t)))"
879c864
<         proof (induct "size u" arbitrary:u rule:less_induct)
---
>         proof (induct "hsize u" arbitrary:u rule:less_induct)
900c885
<                 by (metis \<open>is_App t\<close> less_multiset_doubletons s_App size_chop_lt tm.disc(2))
---
>                 by (metis \<open>is_App t\<close> less_multiset_doubletons s_App hsize_chop_lt tm.disc(2))
931c916
<               using less.hyps[of "chop u"] size_chop_lt 
---
>               using less.hyps[of "chop u"] hsize_chop_lt 
958c943
<              size_chop_lt t_gt_s_same(1) tm.collapse(1) tm.simps(17))
---
>              hsize_chop_lt t_gt_s_same(1) tm.collapse(1) tm.simps(17))
973c958
<     rule measure_induct_rule[of "\<lambda>(t, s). size t + size s"
---
>     rule measure_induct_rule[of "\<lambda>(t, s). {# hsize t, hsize s #}"
978c963
<     ih: "\<And>ta sa. size ta + size sa < size t + size s \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
---
>     ih: "\<And>ta sa. {# hsize ta, hsize sa #} < {# hsize t, hsize s #} \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
985,986c970,971
<     unfolding chkchop_def tm.case_eq_if using ih[of t "fun s"] ih[of t "arg s"]
<     by (metis gr_s gr_t gt_chop gt_imp_vars ih nat_add_left_cancel_less size_chop_lt subset_empty)
---
>     unfolding chkchop_def tm.case_eq_if using ih[of t "chop s"]
>     by (metis (no_types, lifting) add_mset_commute add_mset_lt_left_lt gr_s gr_t ground_chop gt_chop hsize_chop_lt)
988,989c973,974
<     unfolding chkchop_def tm.case_eq_if using ih[of "fun t" s] ih[of "arg t" s]
<     by (metis add_less_cancel_right gr_s gr_t gt_chop gt_imp_vars ih size_chop_lt subset_empty)
---
>     unfolding chkchop_def tm.case_eq_if using ih[of "chop t" s]
>     by (metis add_mset_lt_left_lt gr_s gr_t ground_chop gt_chop.intros gt_iff_chop_diff_same hsize_chop_lt)
1045,1046c1030,1031
<           ext_total.total[OF extf_total, rule_format, of "set ?ts" "set ?ss" "(>\<^sub>t)" ?ts ?ss g]
<         by (metis add_strict_mono in_listsI size_in_args)
---
>           ext_total.total[OF extf_total, rule_format, of "set ?ts \<union> set ?ss" "(>\<^sub>t)" ?ts ?ss g]
>         using less_multiset_doubletons epo_axioms hsize_in_args in_listsI by (metis Un_iff)
1072c1057
<     let ?ff = "worst_chain (>\<^sub>t\<^sub>g) (\<lambda>t s. size t > size s)"
---
>     let ?ff = "worst_chain (>\<^sub>t\<^sub>g) (\<lambda>t s. hsize t > hsize s)"
1075c1060
<     note wf_sz = wf_app[OF wellorder_class.wf, of size, simplified]
---
>     note wf_sz = wf_app[OF wellorder_class.wf, of hsize, simplified]
1089,1090c1074,1075
<       have sz_u: "size u < size ?ti"
<         using emb_size_neq u_in by blast
---
>       have sz_u: "hsize u < hsize ?ti"
>         using emb_hsize_neq u_in by blast
1196c1181
<       using arg_emb CollectI arg_emb size_in_args by fast+
---
>       using arg_emb CollectI arg_emb hsize_in_args by fast+
==========
Lambda_Free_KBOs
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_KBOs/Lambda_Free_KBO_Basic.thy ../../AFPs/afp-2020/thys/Lambda_Free_KBOs/Lambda_Free_KBO_Basic.thy
88c88
<       by (auto intro!: gt_same simp: basic_wt_eq_wt[symmetric])
---
>       by (force intro!: gt_same simp: basic_wt_eq_wt[symmetric])
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_KBOs/Lambda_Free_KBO_Std.thy ../../AFPs/afp-2020/thys/Lambda_Free_KBOs/Lambda_Free_KBO_Std.thy
12c12
< imports Lambda_Free_KBO_Util
---
> imports Lambda_Free_KBO_Util Nested_Multisets_Ordinals.Multiset_More
953,961c953,963
<   assumes
<     extf_total: "\<And>f. ext_total (extf f)" and
<     gr_t: "ground t" and
<     gr_s: "ground s"
<   shows "t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
<   using gr_t gr_s
< proof (induct t arbitrary: s rule: tm_induct_apps)
<   case t: (apps \<xi> ts)
<   note ih = this(1) and gr_t = this(2) and gr_s = this(3)
---
>   assumes extf_total: "\<And>f. ext_total (extf f)"
>   shows "ground t \<Longrightarrow> ground s \<Longrightarrow> t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
> proof (simp only: atomize_imp,
>     rule measure_induct_rule[of "\<lambda>(t, s). {# size t, size s #}"
>       "\<lambda>(t, s). ground t \<longrightarrow> ground s \<longrightarrow> t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s" "(t, s)", simplified prod.case],
>     simp only: split_paired_all prod.case atomize_imp[symmetric])
>   fix t s :: "('s, 'v) tm"
>   assume
>     ih: "\<And>ta sa. {# size ta, size sa #} < {# size t, size s #} \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
>       ta >\<^sub>t sa \<or> sa >\<^sub>t ta \<or> ta = sa" and
>     gr_t: "ground t" and gr_s: "ground s"
963c965
<   let ?t = "apps (Hd \<xi>) ts"
---
>   let ?case = "t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
966,967c968,969
<     vars_t: "vars_mset ?t \<supseteq># vars_mset s" and
<     vars_s: "vars_mset s \<supseteq># vars_mset ?t"
---
>     vars_t: "vars_mset t \<supseteq># vars_mset s" and
>     vars_s: "vars_mset s \<supseteq># vars_mset t"
972c974
<   proof (cases "wt ?t = wt s")
---
>   proof (cases "wt t = wt s")
976,977c978,979
<       assume "wt ?t > wt s"
<       hence "?t >\<^sub>t s"
---
>       assume "wt t > wt s"
>       hence "t >\<^sub>t s"
982,983c984,985
<       assume "wt s > wt ?t"
<       hence "s >\<^sub>t ?t"
---
>       assume "wt s > wt t"
>       hence "s >\<^sub>t t"
992,998c994,997
<     show ?thesis
<     proof (cases s rule: tm_exhaust_apps)
<       case s: (apps \<zeta> ss)
<       obtain g where \<xi>: "\<xi> = Sym g"
<         by (metis ground_head[OF gr_t] hd.collapse(2) head_apps tm.sel(1))
<       obtain f where \<zeta>: "\<zeta> = Sym f"
<         using s by (metis ground_head[OF gr_s] hd.collapse(2) head_apps tm.sel(1))
---
>     obtain g where \<xi>: "head t = Sym g"
>       by (metis ground_head[OF gr_t] hd.collapse(2))
>     obtain f where \<zeta>: "head s = Sym f"
>       by (metis ground_head[OF gr_s] hd.collapse(2))
1000,1052c999,1053
<       {
<         assume g_gt_f: "g >\<^sub>s f"
<         have "?t >\<^sub>t s"
<           by (rule gt_diff[OF vars_t wt_t]) (simp add: \<xi> \<zeta> s g_gt_f gt_hd_def)
<       }
<       moreover
<       {
<         assume f_gt_g: "f >\<^sub>s g"
<         have "s >\<^sub>t ?t"
<           by (rule gt_diff[OF vars_s wt_s]) (simp add: \<xi> \<zeta> s f_gt_g gt_hd_def)
<       }
<       moreover
<       {
<         assume g_eq_f: "g = f"
<         hence hd_t: "head ?t = head s"
<           using \<xi> \<zeta> t s by force
<         note hd_s = hd_t[symmetric]
< 
<         have gr_ts: "\<forall>t \<in> set ts. ground t"
<           using gr_t by auto
<         have gr_ss: "\<forall>s \<in> set ss. ground s"
<           using gr_s s by auto
< 
<         have ?thesis
<         proof (cases "ts = ss")
<           case ts_eq_ss: True
<           show ?thesis
<             using s \<xi> \<zeta> g_eq_f ts_eq_ss by blast
<         next
<           case False
<           hence "extf g (>\<^sub>t) ts ss \<or> extf g (>\<^sub>t) ss ts"
<             using ih gr_ss gr_ts
<               ext_total.total[OF extf_total, rule_format, of "set ts" "set ss" "(>\<^sub>t)" ts ss g]
<             by blast
<           moreover
<           {
<             assume extf: "extf g (>\<^sub>t) ts ss"
<             have "?t >\<^sub>t s"
<               by (rule gt_same[OF vars_t wt_t hd_t]) (simp add: extf \<xi> s)
<           }
<           moreover
<           {
<             assume extf: "extf g (>\<^sub>t) ss ts"
<             have "s >\<^sub>t ?t"
<               by (rule gt_same[OF vars_s wt_s hd_s]) (simp add: extf[unfolded g_eq_f] \<zeta> s)
<           }
<           ultimately show ?thesis
<             by sat
<         qed
<       }
<       ultimately show ?thesis
<         using gt_sym_total by blast
<     qed
---
>     {
>       assume g_gt_f: "g >\<^sub>s f"
>       have "t >\<^sub>t s"
>         by (rule gt_diff[OF vars_t wt_t]) (simp add: \<xi> \<zeta> g_gt_f gt_hd_def)
>     }
>     moreover
>     {
>       assume f_gt_g: "f >\<^sub>s g"
>       have "s >\<^sub>t t"
>         by (rule gt_diff[OF vars_s wt_s]) (simp add: \<xi> \<zeta> f_gt_g gt_hd_def)
>     }
>     moreover
>     {
>       assume g_eq_f: "g = f"
>       hence hd_t: "head t = head s"
>         using \<xi> \<zeta> by force
>       note hd_s = hd_t[symmetric]
> 
>       have gr_ts: "\<forall>t \<in> set (args t). ground t"
>         using gr_t ground_args by auto
>       have gr_ss: "\<forall>s \<in> set (args s). ground s"
>         using gr_s ground_args by auto
> 
>       let ?ts = "args t"
>       let ?ss = "args s"
> 
>       have ?thesis
>       proof (cases "?ts = ?ss")
>         case ts_eq_ss: True
>         show ?thesis
>           using \<xi> \<zeta> g_eq_f ts_eq_ss by (simp add: tm_expand_apps)
>       next
>         case False
>         hence "extf g (>\<^sub>t) (args t) ?ss \<or> extf g (>\<^sub>t) ?ss ?ts"
>           using ih gr_ss gr_ts
>             ext_total.total[OF extf_total, rule_format, of "set ?ts \<union> set ?ss" "(>\<^sub>t)" ?ts ?ss g]
>           by (metis Un_commute Un_iff in_lists_iff_set less_multiset_doubletons size_in_args sup_ge2)
>         moreover
>         {
>           assume extf: "extf g (>\<^sub>t) ?ts ?ss"
>           have "t >\<^sub>t s"
>             by (rule gt_same[OF vars_t wt_t hd_t]) (simp add: extf \<xi>)
>         }
>         moreover
>         {
>           assume extf: "extf g (>\<^sub>t) ?ss ?ts"
>           have "s >\<^sub>t t"
>             by (rule gt_same[OF vars_s wt_s hd_s]) (simp add: extf[unfolded g_eq_f] \<zeta>)
>         }
>         ultimately show ?thesis
>           by sat
>       qed
>     }
>     ultimately show ?thesis
>       using gt_sym_total by blast
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_KBOs/Lambda_Free_TKBO_Coefs.thy ../../AFPs/afp-2020/thys/Lambda_Free_KBOs/Lambda_Free_TKBO_Coefs.thy
1668a1669
> 
1670,1678c1671,1681
<   assumes
<     extf_total: "\<And>f. ext_total (extf f)" and
<     gr_t: "ground t" and
<     gr_s: "ground s"
<   shows "t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
<   using gr_t gr_s
< proof (induct t arbitrary: s rule: tm_induct_apps)
<   case t: (apps \<xi> ts)
<   note ih = this(1) and gr_t = this(2) and gr_s = this(3)
---
>   assumes extf_total: "\<And>f. ext_total (extf f)"
>   shows "ground t \<Longrightarrow> ground s \<Longrightarrow> t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
> proof (simp only: atomize_imp,
>     rule measure_induct_rule[of "\<lambda>(t, s). {# size t, size s #}"
>       "\<lambda>(t, s). ground t \<longrightarrow> ground s \<longrightarrow> t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s" "(t, s)", simplified prod.case],
>     simp only: split_paired_all prod.case atomize_imp[symmetric])
>   fix t s :: "('s, 'v) tm"
>   assume
>     ih: "\<And>ta sa. {# size ta, size sa #} < {# size t, size s #} \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
>       ta >\<^sub>t sa \<or> sa >\<^sub>t ta \<or> ta = sa" and
>     gr_t: "ground t" and gr_s: "ground s"
1680c1683
<   let ?t = "apps (Hd \<xi>) ts"
---
>   let ?case = "t >\<^sub>t s \<or> s >\<^sub>t t \<or> t = s"
1683,1684c1686,1687
<     assume "wt ?t >\<^sub>p wt s"
<     hence "?t >\<^sub>t s"
---
>     assume "wt t >\<^sub>p wt s"
>     hence "t >\<^sub>t s"
1689,1690c1692,1693
<     assume "wt s >\<^sub>p wt ?t"
<     hence "s >\<^sub>t ?t"
---
>     assume "wt s >\<^sub>p wt t"
>     hence "s >\<^sub>t t"
1695,1696c1698,1699
<     assume "wt ?t =\<^sub>p wt s"
<     hence wt_t_ge_s: "wt ?t \<ge>\<^sub>p wt s" and wt_s_ge_t: "wt s \<ge>\<^sub>p wt ?t"
---
>     assume "wt t =\<^sub>p wt s"
>     hence wt_t_ge_s: "wt t \<ge>\<^sub>p wt s" and wt_s_ge_t: "wt s \<ge>\<^sub>p wt t"
1699,1759c1702,1761
<     have ?case
<     proof (cases s rule: tm_exhaust_apps)
<       case s: (apps \<zeta> ss)
<       obtain g where \<xi>: "\<xi> = Sym g"
<         by (metis ground_head[OF gr_t] hd.collapse(2) head_apps tm.sel(1))
<       obtain f where \<zeta>: "\<zeta> = Sym f"
<         using s by (metis ground_head[OF gr_s] hd.collapse(2) head_apps tm.sel(1))
< 
<       {
<         assume g_gt_f: "g >\<^sub>s f"
<         have "?t >\<^sub>t s"
<           by (rule gt_diff[OF wt_t_ge_s]) (simp add: \<xi> \<zeta> s g_gt_f gt_hd_def)
<       }
<       moreover
<       {
<         assume f_gt_g: "f >\<^sub>s g"
<         have "s >\<^sub>t ?t"
<           by (rule gt_diff[OF wt_s_ge_t]) (simp add: \<xi> \<zeta> s f_gt_g gt_hd_def)
<       }
<       moreover
<       {
<         assume g_eq_f: "g = f"
<         hence hd_t: "head ?t = head s"
<           using \<xi> \<zeta> t s by force
<         note hd_s = hd_t[symmetric]
< 
<         have gr_ts: "\<forall>t \<in> set ts. ground t"
<           using gr_t by auto
<         have gr_ss: "\<forall>s \<in> set ss. ground s"
<           using gr_s s by auto
< 
<         have ?thesis
<         proof (cases "ts = ss")
<           case ts_eq_ss: True
<           show ?thesis
<             using s \<xi> \<zeta> g_eq_f ts_eq_ss by blast
<         next
<           case False
<           hence "extf g (>\<^sub>t) ts ss \<or> extf g (>\<^sub>t) ss ts"
<             using ih gr_ss gr_ts
<               ext_total.total[OF extf_total, rule_format, of "set ts" "set ss" "(>\<^sub>t)" ts ss g]
<             by blast
<           moreover
<           {
<             assume extf: "extf g (>\<^sub>t) ts ss"
<             have "?t >\<^sub>t s"
<               by (rule gt_same[OF wt_t_ge_s hd_t]) (simp add: extf \<xi> s)
<           }
<           moreover
<           {
<             assume extf: "extf g (>\<^sub>t) ss ts"
<             have "s >\<^sub>t ?t"
<               by (rule gt_same[OF wt_s_ge_t hd_s]) (simp add: extf[unfolded g_eq_f] \<zeta> s)
<           }
<           ultimately show ?thesis
<             by sat
<         qed
<       }
<       ultimately show ?thesis
<         using gt_sym_total by blast
<     qed
---
>     obtain g where \<xi>: "head t = Sym g"
>       by (metis ground_head[OF gr_t] hd.collapse(2))
>     obtain f where \<zeta>: "head s = Sym f"
>       by (metis ground_head[OF gr_s] hd.collapse(2))
> 
>     {
>       assume g_gt_f: "g >\<^sub>s f"
>       have "t >\<^sub>t s"
>         by (rule gt_diff[OF wt_t_ge_s]) (simp add: \<xi> \<zeta> g_gt_f gt_hd_def)
>     }
>     moreover
>     {
>       assume f_gt_g: "f >\<^sub>s g"
>       have "s >\<^sub>t t"
>         by (rule gt_diff[OF wt_s_ge_t]) (simp add: \<xi> \<zeta> f_gt_g gt_hd_def)
>     }
>     moreover
>     {
>       assume g_eq_f: "g = f"
>       hence hd_t: "head t = head s"
>         using \<xi> \<zeta> by force
>       note hd_s = hd_t[symmetric]
> 
>       let ?ts = "args t"
>       let ?ss = "args s"
> 
>       have gr_ts: "\<forall>t \<in> set ?ts. ground t"
>         using gr_t ground_args by auto
>       have gr_ss: "\<forall>s \<in> set ?ss. ground s"
>         using gr_s ground_args by auto
> 
>       have ?case
>       proof (cases "?ts = ?ss")
>         case ts_eq_ss: True
>         show ?thesis
>           using \<xi> \<zeta> g_eq_f ts_eq_ss by (simp add: tm_expand_apps)
>       next
>         case False
>         hence "extf g (>\<^sub>t) ?ts ?ss \<or> extf g (>\<^sub>t) ?ss ?ts"
>           using ih gr_ss gr_ts less_multiset_doubletons
>             ext_total.total[OF extf_total, rule_format, of "set ?ts \<union> set ?ss" "(>\<^sub>t)" ?ts ?ss g]
>           by (metis Un_commute Un_iff in_lists_iff_set size_in_args sup_ge2)
>         moreover
>         {
>           assume extf: "extf g (>\<^sub>t) ?ts ?ss"
>           have "t >\<^sub>t s"
>             by (rule gt_same[OF wt_t_ge_s hd_t]) (simp add: extf \<xi>)
>         }
>         moreover
>         {
>           assume extf: "extf g (>\<^sub>t) ?ss ?ts"
>           have "s >\<^sub>t t"
>             by (rule gt_same[OF wt_s_ge_t hd_s]) (simp add: extf[unfolded g_eq_f] \<zeta>)
>         }
>         ultimately show ?thesis
>           by sat
>       qed
>     }
>     ultimately have ?case
>       using gt_sym_total by blast
==========
Lambda_Free_RPOs
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_RPOs/Extension_Orders.thy ../../AFPs/afp-2020/thys/Lambda_Free_RPOs/Extension_Orders.thy
109c109
<   assumes total: "(\<forall>y \<in> B. \<forall>x \<in> A. gt y x \<or> gt x y \<or> y = x) \<Longrightarrow> ys \<in> lists B \<Longrightarrow> xs \<in> lists A \<Longrightarrow>
---
>   assumes total: "(\<forall>y \<in> A. \<forall>x \<in> A. gt y x \<or> gt x y \<or> y = x) \<Longrightarrow> ys \<in> lists A \<Longrightarrow> xs \<in> lists A \<Longrightarrow>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_RPOs/Lambda_Free_RPO_Std.thy ../../AFPs/afp-2020/thys/Lambda_Free_RPOs/Lambda_Free_RPO_Std.thy
11c11
< imports Lambda_Free_Term Extension_Orders
---
> imports Lambda_Free_Term Extension_Orders Nested_Multisets_Ordinals.Multiset_More
523c523
<     rule measure_induct_rule[of "\<lambda>(t, s). size t + size s"
---
>     rule measure_induct_rule[of "\<lambda>(t, s). {# size t, size s #}"
528c528
<     ih: "\<And>ta sa. size ta + size sa < size t + size s \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
---
>     ih: "\<And>ta sa. {# size ta, size sa #} < {# size t, size s #} \<Longrightarrow> ground ta \<Longrightarrow> ground sa \<Longrightarrow>
535,536c535,536
<     unfolding chksubs_def tm.case_eq_if using ih[of t "fun s"] ih[of t "arg s"]
<     by (metis gt_sub add_less_cancel_left gr_s gr_t ground_arg ground_fun size_arg_lt size_fun_lt)
---
>     unfolding chksubs_def tm.case_eq_if using ih[of t "fun s"] ih[of t "arg s"] mset_lt_single_iff
>     by (metis add_mset_lt_right_lt gr_s gr_t ground_arg ground_fun gt_sub size_arg_lt size_fun_lt)
539c539
<     by (metis gt_sub add_less_cancel_right gr_s gr_t ground_arg ground_fun size_arg_lt size_fun_lt)
---
>     by (metis add_mset_lt_left_lt gr_s gr_t ground_arg ground_fun gt_sub size_arg_lt size_fun_lt)  
598,599c598,599
<           ext_total.total[OF extf_total, rule_format, of "set ?ts" "set ?ss" "(>\<^sub>t)" ?ts ?ss g]
<         by (metis add_strict_mono in_listsI size_in_args)
---
>           ext_total.total[OF extf_total, rule_format, of "set ?ts \<union> set ?ss" "(>\<^sub>t)" ?ts ?ss g]
>         by (metis Un_iff in_listsI less_multiset_doubletons size_in_args)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lambda_Free_RPOs/Lambda_Free_Term.thy ../../AFPs/afp-2020/thys/Lambda_Free_RPOs/Lambda_Free_Term.thy
36a37
> 
204a206,238
> 
> 
> subsection \<open>hsize\<close>
> 
> text \<open>The hsize of a term is the number of heads (Syms or Vars) in the term.\<close>
> 
> primrec hsize :: "('s, 'v) tm \<Rightarrow> nat" where
>   "hsize (Hd \<zeta>) = 1"
> | "hsize (App s t) = hsize s + hsize t"
> 
> lemma hsize_size: "hsize t * 2 = size t + 1"
>   by (induct t) auto
> 
> lemma hsize_pos[simp]: "hsize t > 0"
>   by (induction t; simp)
> 
> lemma hsize_fun_lt: "is_App s \<Longrightarrow> hsize (fun s) < hsize s"
>   by (cases s; simp)
> 
> lemma hsize_arg_lt: "is_App s \<Longrightarrow> hsize (arg s) < hsize s"
>   by (cases s; simp)
>   
> lemma hsize_ge_num_args: "hsize s \<ge> hsize s"
>   by (induct s) auto
> 
> lemma hsize_in_args: "s \<in> set (args t) \<Longrightarrow> hsize s < hsize t"
>   by (induct t) auto
> 
> lemma hsize_apps: "hsize (apps t ts) = hsize t + sum_list (map hsize ts)"
>   by (induct ts arbitrary:t; simp)
> 
> lemma hsize_args: "1 + sum_list (map hsize (args t)) = hsize t"
>   by (metis hsize.simps(1) hsize_apps tm_collapse_apps)
==========
Landau_Symbols
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Landau_Symbols/Landau_Real_Products.thy ../../AFPs/afp-2020/thys/Landau_Symbols/Landau_Real_Products.thy
1233c1233
< lemma reify_ln_chain_1:
---
> lemma reify_ln_chain1:
1243c1243
< lemma reify_monom_1:
---
> lemma reify_monom1:
1266c1266
< lemmas reify_monom = reify_monom_1 reify_monom_pow reify_monom_powr
---
> lemmas reify_monom = reify_monom1 reify_monom_pow reify_monom_powr
1286c1286
< lemmas reify_ln_chain = reify_ln_chain_1 reify_ln_chain_pow reify_ln_chain_powr
---
> lemmas reify_ln_chain = reify_ln_chain1 reify_ln_chain_pow reify_ln_chain_powr
==========
Laplace_Transform
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Laplace_Transform/Existence.thy ../../AFPs/afp-2020/thys/Laplace_Transform/Existence.thy
160c160
<       by (rule Lim_transform_eventually)
---
>       by (rule Lim_transform_eventually[rotated])
310,311c310,311
<   have limseq: "\<forall>x\<in>{c..}. (\<lambda>k. f k x) \<longlonglongrightarrow> exp (x *\<^sub>R - a)"
<     apply (auto intro!: Lim_transform_eventually[OF _ tendsto_const] simp: f_def)
---
>   have limseq: "\<And>x. x \<in>{c..} \<Longrightarrow> (\<lambda>k. f k x) \<longlonglongrightarrow> exp (x *\<^sub>R - a)"
>     apply (auto intro!: Lim_transform_eventually[OF tendsto_const] simp: f_def)
320a321,328
>   have "(\<lambda>k. exp (c *\<^sub>R -a)/a - exp (k *\<^sub>R -a)/a) \<longlonglongrightarrow> exp (c*\<^sub>R-a)/a - 0/a"
>     apply (intro tendsto_intros filterlim_compose[OF exp_at_bot]
>           filterlim_tendsto_neg_mult_at_bot[OF tendsto_const] filterlim_real_sequentially)+
>      apply (rule tendsto_norm_zero_cancel)
>     by (auto intro!: assms \<open>a \<noteq> 0\<close> filterlim_real_sequentially
>         filterlim_compose[OF exp_at_bot] filterlim_compose[OF filterlim_uminus_at_bot_at_top]
>         filterlim_at_top_mult_tendsto_pos[OF tendsto_const])
>   moreover
329,335d336
<   moreover have "(\<lambda>k. exp (c *\<^sub>R -a)/a - exp (k *\<^sub>R -a)/a) \<longlonglongrightarrow> exp (c*\<^sub>R-a)/a - 0/a"
<     apply (intro tendsto_intros filterlim_compose[OF exp_at_bot]
<           filterlim_tendsto_neg_mult_at_bot[OF tendsto_const] filterlim_real_sequentially)+
<      apply (rule tendsto_norm_zero_cancel)
<     by (auto intro!: assms \<open>a \<noteq> 0\<close> filterlim_real_sequentially
<         filterlim_compose[OF exp_at_bot] filterlim_compose[OF filterlim_uminus_at_bot_at_top]
<         filterlim_at_top_mult_tendsto_pos[OF tendsto_const])
459c460
<         using \<open>0 < x\<close> 
---
>         using \<open>0 < x\<close>
462c463
<         by (rule Lim_transform_eventually)
---
>         by (rule Lim_transform_eventually[rotated])
626c627
<       by (smt I has_integral_integrable integral_combine integral_unique t0(2) that)
---
>       by (smt I \<open>a \<le> t0\<close> \<open>f integrable_on {t0..t}\<close> has_integral_combine has_integral_integrable_integral that)
655c656
<   then show ?case 
---
>   then show ?case
685c686
<     have i_eq: "integral {a..y} f = integral {a..y} f1" if "y < i" for y 
---
>     have i_eq: "integral {a..y} f = integral {a..y} f1" if "y < i" for y
720c721
<     have i_eq: "integral {a..y} f = integral {a..i} f + integral {i..y} f2" if "i < y" "y \<le> b" for y 
---
>     have i_eq: "integral {a..y} f = integral {a..i} f + integral {i..y} f2" if "i < y" "y \<le> b" for y
726c727
<           apply (rule integral_combine[symmetric])
---
>           apply (rule Henstock_Kurzweil_Integration.integral_combine[symmetric])
729c730
<           subgoal 
---
>           subgoal
862c863
<         apply (subst integral_combine)
---
>         apply (subst Henstock_Kurzweil_Integration.integral_combine)
897c898
<         apply (subst integral_combine)
---
>         apply (subst Henstock_Kurzweil_Integration.integral_combine)
932c933
<         apply (subst integral_combine)
---
>         apply (subst Henstock_Kurzweil_Integration.integral_combine)
1030c1031
<   
---
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Laplace_Transform/Laplace_Transform_Library.thy ../../AFPs/afp-2020/thys/Laplace_Transform/Laplace_Transform_Library.thy
32c32
<   
---
> 
165c165
<     by (auto intro!: Lim_transform_eventually[OF _ tendsto_const] simp: indicator_def eventually_at_top_linorder)
---
>     by (auto intro!: Lim_transform_eventually[OF tendsto_const] simp: indicator_def eventually_at_top_linorder)
211c211
<         apply (auto simp: sign_simps not_less)
---
>         apply (auto simp: algebra_split_simps not_less)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Laplace_Transform/Piecewise_Continuous.thy ../../AFPs/afp-2020/thys/Laplace_Transform/Piecewise_Continuous.thy
304c304
<     by (rule Lim_transform_eventually) auto
---
>     by (rule Lim_transform_eventually[rotated]) auto
312c312
<     by (rule Lim_transform_eventually) auto
---
>     by (rule Lim_transform_eventually[rotated]) auto
339c339
<         greaterThanLessThan_iff)      
---
>         greaterThanLessThan_iff)
458c458
<       from insert.IH[OF this] show ?thesis 
---
>       from insert.IH[OF this] show ?thesis
548c548
<   if 
---
>   if
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Laplace_Transform/Uniqueness.thy ../../AFPs/afp-2020/thys/Laplace_Transform/Uniqueness.thy
14c14
<   assumes "t \<ge> 0" 
---
>   assumes "t \<ge> 0"
19c19
<     by (auto intro!: compact_imp_bounded compact_continuous_image cont_f intro: continuous_on_subset) 
---
>     by (auto intro!: compact_imp_bounded compact_continuous_image cont_f intro: continuous_on_subset)
81c81
<       have eq: "exp (t *\<^sub>R - complex_of_real (s0 + real (Suc n))) * f t = 
---
>       have eq: "exp (t *\<^sub>R - complex_of_real (s0 + real (Suc n))) * f t =
106c106
<       by (rule Lim_transform_eventually)
---
>       by (rule Lim_transform_eventually[rotated])
114c114
<     from Lim_transform_eventually[OF this 1]
---
>     from Lim_transform_eventually[OF 1 this]
==========
Linear_Inequalities
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Inequalities/Mixed_Integer_Solutions.thy ../../AFPs/afp-2020/thys/Linear_Inequalities/Mixed_Integer_Solutions.thy
42c42
< lemma small_mixed_integer_solution: fixes A\<^sub>1 :: "'a mat"
---
> lemma small_mixed_integer_solution_main: fixes A\<^sub>1 :: "'a mat"
221a222,290
> text \<open>We get rid of the max-1 operation, by showing that a smaller value of Bnd 
>   can only occur in very special cases where the theorem is trivially satisfied.\<close>
> 
> lemma small_mixed_integer_solution: fixes A\<^sub>1 :: "'a mat"
>   assumes A1: "A\<^sub>1 \<in> carrier_mat nr\<^sub>1 n"
>     and A2: "A\<^sub>2 \<in> carrier_mat nr\<^sub>2 n"
>     and b1: "b\<^sub>1 \<in> carrier_vec nr\<^sub>1"
>     and b2: "b\<^sub>2 \<in> carrier_vec nr\<^sub>2"
>     and A1Bnd: "A\<^sub>1 \<in> \<int>\<^sub>m \<inter> Bounded_mat Bnd"
>     and b1Bnd: "b\<^sub>1 \<in> \<int>\<^sub>v \<inter> Bounded_vec Bnd"
>     and A2Bnd: "A\<^sub>2 \<in> \<int>\<^sub>m \<inter> Bounded_mat Bnd"
>     and b2Bnd: "b\<^sub>2 \<in> \<int>\<^sub>v \<inter> Bounded_vec Bnd"
>     and x: "x \<in> carrier_vec n"
>     and xI: "x \<in> indexed_Ints_vec I"
>     and sol_nonstrict: "A\<^sub>1 *\<^sub>v x \<le> b\<^sub>1"
>     and sol_strict: "A\<^sub>2 *\<^sub>v x <\<^sub>v b\<^sub>2"
>     and non_degenerate: "nr\<^sub>1 \<noteq> 0 \<or> nr\<^sub>2 \<noteq> 0 \<or> Bnd \<ge> 0" 
>   shows "\<exists> x.
>   x \<in> carrier_vec n \<and>
>   x \<in> indexed_Ints_vec I \<and>
>   A\<^sub>1 *\<^sub>v x \<le> b\<^sub>1 \<and>
>   A\<^sub>2 *\<^sub>v x <\<^sub>v b\<^sub>2 \<and>
>   x \<in> Bounded_vec (fact (n+1) * Bnd^n)"
> proof (cases "Bnd \<ge> 1")
>   case True
>   hence "max 1 Bnd = Bnd" by auto
>   with small_mixed_integer_solution_main[OF assms(1-12)] True show ?thesis by auto
> next
>   case trivial: False
>   show ?thesis 
>   proof (cases "n = 0")
>     case True
>     with x have "x \<in> Bounded_vec (fact (n+1) * Bnd^n)" unfolding Bounded_vec_def by auto
>     with xI x sol_nonstrict sol_strict show ?thesis by blast
>   next
>     case n: False
>     {
>       fix A nr
>       assume A: "A \<in> carrier_mat nr n" and Bnd: "A \<in> \<int>\<^sub>m \<inter> Bounded_mat Bnd"
>       {
>         fix i j
>         assume "i < nr" "j < n" 
>         with Bnd A have *: "A $$ (i,j) \<in> \<int>" "abs (A $$ (i,j)) \<le> Bnd" 
>           unfolding Bounded_mat_def Ints_mat_def by auto
>         with trivial have "Bnd \<ge> 0" "A $$ (i,j) = 0" by (auto simp: Ints_nonzero_abs_less1)
>       } note main = this      
>       have A0: "A = 0\<^sub>m nr n" 
>         by (intro eq_matI, insert main A, auto)
>       have "nr \<noteq> 0 \<Longrightarrow> Bnd \<ge> 0" using main[of 0 0] n by auto
>       note A0 this
>     } note main = this
>     from main[OF A1 A1Bnd] have A1: "A\<^sub>1 = 0\<^sub>m nr\<^sub>1 n" and nr1: "nr\<^sub>1 \<noteq> 0 \<Longrightarrow> Bnd \<ge> 0" 
>       by auto
>     from main[OF A2 A2Bnd] have A2: "A\<^sub>2 = 0\<^sub>m nr\<^sub>2 n" and nr2: "nr\<^sub>2 \<noteq> 0 \<Longrightarrow> Bnd \<ge> 0" 
>       by auto
>     let ?x = "0\<^sub>v n" 
>     show ?thesis
>     proof (intro exI[of _ ?x] conjI)
>       show "A\<^sub>1 *\<^sub>v ?x \<le> b\<^sub>1" using sol_nonstrict x unfolding A1 by auto
>       show "A\<^sub>2 *\<^sub>v ?x <\<^sub>v b\<^sub>2" using sol_strict x unfolding A2 by auto
>       show "?x \<in> carrier_vec n" by auto
>       show "?x \<in> indexed_Ints_vec I" unfolding indexed_Ints_vec_def by auto
>       from nr1 nr2 non_degenerate have Bnd: "Bnd \<ge> 0" by auto
>       hence "fact (n + 1) * Bnd ^ n \<ge> 0" by simp
>       thus "?x \<in> Bounded_vec (fact (n + 1) * Bnd ^ n)" by (auto simp: Bounded_vec_def)
>     qed
>   qed
> qed      
> 
229a299
>     and non_degenerate: "nr \<noteq> 0 \<or> Bnd \<ge> 0" 
234c304
<   y \<in> Bounded_vec (fact (n+1) * (max 1 Bnd)^n)"
---
>   y \<in> Bounded_vec (fact (n+1) * Bnd^n)"
237a308
>   from non_degenerate have degen: "nr \<noteq> 0 \<or> (0 :: nat) \<noteq> 0 \<or> Bnd \<ge> 0" by auto
239c310
<   \<and> y \<in> Bounded_vec (fact (n + 1) * max 1 Bnd ^ n)"
---
>   \<and> y \<in> Bounded_vec (fact (n + 1) * Bnd ^ n)"
241c312
<           folded indexed_Ints_vec_UNIV], insert xI,
---
>           folded indexed_Ints_vec_UNIV], insert xI degen,
==========
LinearQuantifierElim
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LinearQuantifierElim/Thys/FRE.thy ../../AFPs/afp-2020/thys/LinearQuantifierElim/Thys/FRE.thy
174c174,175
<       from * have [simp]: "c * (c * (d * (d * 4))) > 0" by (auto simp add: sign_simps)
---
>       from * have [simp]: "c * (c * (d * (d * 4))) > 0"
>         by (simp add: algebra_split_simps)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LinearQuantifierElim/Thys/QEdlo_inf.thy ../../AFPs/afp-2020/thys/LinearQuantifierElim/Thys/QEdlo_inf.thy
81c81
<     by simp (metis linorder_antisym_conv1 linorder_neq_iff)
---
>     by simp (metis antisym_conv1 linorder_neq_iff)
88c88
<          (metis One_nat_def linorder_antisym_conv1 not_less_iff_gr_or_eq)
---
>          (metis One_nat_def antisym_conv1 not_less_iff_gr_or_eq)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LinearQuantifierElim/Thys/QElin_inf.thy ../../AFPs/afp-2020/thys/LinearQuantifierElim/Thys/QElin_inf.thy
118c118
<     by simp (metis linorder_antisym_conv1 linorder_neq_iff)
---
>     by simp (metis antisym_conv1 linorder_neq_iff)
==========
Linear_Recurrences
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Factorizations.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Factorizations.thy
153c153
<   fixes p :: "'a :: {field,factorial_ring_gcd} poly"
---
>   fixes p :: "'a :: field_gcd poly"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Linear_Homogenous_Recurrences.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Linear_Homogenous_Recurrences.thy
271c271
<   fixes   f :: "nat \<Rightarrow> 'a :: {field_char_0,factorial_ring_gcd}"
---
>   fixes   f :: "nat \<Rightarrow> 'a :: {field_char_0,field_gcd}"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Linear_Inhomogenous_Recurrences.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Linear_Inhomogenous_Recurrences.thy
169c169
< definition polyexp_ratfps :: "('a :: {field,factorial_ring_gcd}) polyexp \<Rightarrow> 'a ratfps" where
---
> definition polyexp_ratfps :: "('a :: field_gcd) polyexp \<Rightarrow> 'a ratfps" where
209c209
<     "'a :: {field,factorial_ring_gcd} list \<Rightarrow> 'a list \<Rightarrow> 'a polyexp \<Rightarrow> ('a ratfps) option" where
---
>     "'a :: field_gcd list \<Rightarrow> 'a list \<Rightarrow> 'a polyexp \<Rightarrow> ('a ratfps) option" where
217c217
<   fixes   f :: "nat \<Rightarrow> 'a :: {field,factorial_ring_gcd}"
---
>   fixes   f :: "nat \<Rightarrow> 'a :: field_gcd"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Linear_Recurrences_Misc.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Linear_Recurrences_Misc.thy
195c195
<   fixes c :: "'a :: {field,factorial_ring_gcd}"
---
>   fixes c :: "'a :: field_gcd"
210c210
<   fixes c :: "'a :: {field,factorial_ring_gcd,normalization_euclidean_semiring}"
---
>   fixes c :: "'a :: field_gcd"
Only in ../../AFPs/afp-2019/thys/Linear_Recurrences: Linear_Recurrences_Pretty.thy
Only in ../../AFPs/afp-2019/thys/Linear_Recurrences: Linear_Recurrences_Solver.thy
Only in ../../AFPs/afp-2019/thys/Linear_Recurrences: Linear_Recurrences_Test.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Partial_Fraction_Decomposition.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Partial_Fraction_Decomposition.thy
315c315
< definition normalise_decomp_poly :: "'a::field poly \<Rightarrow> 'a poly \<Rightarrow> nat \<Rightarrow> 'a poly \<times> 'a poly list" 
---
> definition normalise_decomp_poly :: "'a::field_gcd poly \<Rightarrow> 'a poly \<Rightarrow> nat \<Rightarrow> 'a poly \<times> 'a poly list" 
353c353
<   "map (map (\<lambda>c. [:c :: 'a :: {field,factorial_ring_gcd,normalization_euclidean_semiring}:])) (snd (poly_pfd_simple x cs)) = 
---
>   "map (map (\<lambda>c. [:c :: 'a :: field_gcd:])) (snd (poly_pfd_simple x cs)) = 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/RatFPS.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/RatFPS.thy
59c59
< abbreviation numerator :: "'a fract \<Rightarrow> 'a::{ring_gcd,idom_divide}"
---
> abbreviation numerator :: "'a fract \<Rightarrow> 'a::{ring_gcd,idom_divide,semiring_gcd_mult_normalize}"
62c62
< abbreviation denominator :: "'a fract \<Rightarrow> 'a::{ring_gcd,idom_divide}"
---
> abbreviation denominator :: "'a fract \<Rightarrow> 'a::{ring_gcd,idom_divide,semiring_gcd_mult_normalize}"
78c78
< typedef (overloaded) 'a :: "{field,factorial_ring_gcd}" ratfps = 
---
> typedef (overloaded) 'a :: field_gcd ratfps = 
84c84
< instantiation ratfps :: ("{field,factorial_ring_gcd}") idom
---
> instantiation ratfps :: (field_gcd) idom
119c119
< lift_definition ratfps_nth :: "'a :: {field,factorial_ring_gcd} ratfps \<Rightarrow> nat \<Rightarrow> 'a" is
---
> lift_definition ratfps_nth :: "'a :: field_gcd ratfps \<Rightarrow> nat \<Rightarrow> 'a" is
123c123
< lift_definition ratfps_subdegree :: "'a :: {field,factorial_ring_gcd} ratfps \<Rightarrow> nat" is
---
> lift_definition ratfps_subdegree :: "'a :: field_gcd ratfps \<Rightarrow> nat" is
143c143
< assumes "SORT_CONSTRAINT('a::{field,factorial_ring_gcd})"
---
> assumes "SORT_CONSTRAINT('a::field_gcd)"
201c201
< definition ratfps_cutoff :: "nat \<Rightarrow> 'a :: {field,factorial_ring_gcd} ratfps \<Rightarrow> 'a poly" where
---
> definition ratfps_cutoff :: "nat \<Rightarrow> 'a :: field_gcd ratfps \<Rightarrow> 'a poly" where
204c204
< definition ratfps_shift :: "nat \<Rightarrow> 'a :: {field,factorial_ring_gcd} ratfps \<Rightarrow> 'a ratfps" where
---
> definition ratfps_shift :: "nat \<Rightarrow> 'a :: field_gcd ratfps \<Rightarrow> 'a ratfps" where
227c227
< instantiation ratfps :: ("{field,factorial_ring_gcd}") inverse
---
> instantiation ratfps :: ("field_gcd") inverse
269c269
<   if "(snd x :: 'a :: {field, factorial_ring_gcd} poly) \<noteq> 0"
---
>   if "(snd x :: 'a :: field_gcd poly) \<noteq> 0"
281c281
<   if "coeff (snd x) 0 \<noteq> (0 :: 'a :: {field,factorial_ring_gcd})"
---
>   if "coeff (snd x) 0 \<noteq> (0 :: 'a :: field_gcd)"
284c284
< lift_definition fps_of_ratfps :: "'a :: {field,factorial_ring_gcd} ratfps \<Rightarrow> 'a fps" is
---
> lift_definition fps_of_ratfps :: "'a :: field_gcd ratfps \<Rightarrow> 'a fps" is
576c576
< instance ratfps :: ("{field,factorial_ring_gcd}") algebraic_semidom
---
> instance ratfps :: ("field_gcd") algebraic_semidom
612c612
< instantiation ratfps :: ("{field,factorial_ring_gcd}") normalization_semidom
---
> instantiation ratfps :: ("field_gcd") normalization_semidom
636,638c636,640
<   show "unit_factor (a * b) = unit_factor a * unit_factor b" for a b :: "'a ratfps"
<     by (rule ratfps_eqI, insert unit_factor_mult[of "fps_of_ratfps a" "fps_of_ratfps b"])
<        (simp del: fps_of_ratfps_eq_iff)
---
>   fix a b :: "'a ratfps"
>   assume "is_unit a" 
>   thus "unit_factor (a * b) = a * unit_factor b"
>     by (intro ratfps_eqI, unfold fps_of_ratfps_unit_factor fps_of_ratfps_mult,
>         subst unit_factor_mult_unit_left) (auto simp: ratfps_nth_altdef)
645c647,654
< instantiation ratfps :: ("{field,factorial_ring_gcd}") semidom_modulo
---
> instance ratfps :: ("field_gcd") normalization_semidom_multiplicative
> proof
>   show "unit_factor (a * b) = unit_factor a * unit_factor b" for a b :: "'a ratfps"
>     by (rule ratfps_eqI, insert unit_factor_mult[of "fps_of_ratfps a" "fps_of_ratfps b"])
>        (simp del: fps_of_ratfps_eq_iff)
> qed
> 
> instantiation ratfps :: ("field_gcd") semidom_modulo
662c671
< instantiation ratfps :: ("{field,factorial_ring_gcd}") euclidean_ring
---
> instantiation ratfps :: ("field_gcd") euclidean_ring
682c691
< instantiation ratfps :: ("{field,factorial_ring_gcd}") euclidean_ring_cancel
---
> instantiation ratfps :: ("field_gcd") euclidean_ring_cancel
707c716
<   "x dvd y \<longleftrightarrow> y = 0 \<or> ((x::'a::{field,factorial_ring_gcd} fps) \<noteq> 0 \<and> subdegree x \<le> subdegree y)"
---
>   "x dvd y \<longleftrightarrow> y = 0 \<or> ((x::'a::field_gcd fps) \<noteq> 0 \<and> subdegree x \<le> subdegree y)"
715c724
< instance ratfps :: ("{field,factorial_ring_gcd}") normalization_euclidean_semiring ..
---
> instance ratfps :: ("field_gcd") normalization_euclidean_semiring ..
717c726
< instantiation ratfps :: ("{field,factorial_ring_gcd}") euclidean_ring_gcd
---
> instantiation ratfps :: ("field_gcd") euclidean_ring_gcd
743c752
< lemma ratfps_gcd_altdef: "gcd (f :: 'a :: {field,factorial_ring_gcd} ratfps) g =
---
> lemma ratfps_gcd_altdef: "gcd (f :: 'a :: field_gcd ratfps) g =
757c766
< lemma ratfps_lcm_altdef: "lcm (f :: 'a :: {field,factorial_ring_gcd} ratfps) g =
---
> lemma ratfps_lcm_altdef: "lcm (f :: 'a :: field_gcd ratfps) g =
780c789
< lemma ratfps_Gcd_altdef: "Gcd (A :: 'a :: {field,factorial_ring_gcd} ratfps set) =
---
> lemma ratfps_Gcd_altdef: "Gcd (A :: 'a :: field_gcd ratfps set) =
808c817
<   "Lcm (A :: 'a :: {field,factorial_ring_gcd} ratfps set) =
---
>   "Lcm (A :: 'a :: field_gcd ratfps set) =
846c855
<   "fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,factorial_ring_gcd} poly,pCons (numeral n) y')) = 
---
>   "fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (numeral n) y')) = 
848c857
<   "fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,factorial_ring_gcd} poly,pCons (-numeral n) y')) = 
---
>   "fps_of_ratfps (quot_to_ratfps (x'::'a::{field_char_0,field_gcd} poly,pCons (-numeral n) y')) = 
878c887
<     "'a ::{field,factorial_ring_gcd,typerep} poly \<times> (unit \<Rightarrow> Code_Evaluation.term) \<Rightarrow> 
---
>     "'a ::{field_gcd, typerep} poly \<times> (unit \<Rightarrow> Code_Evaluation.term) \<Rightarrow> 
889c898
< instantiation ratfps :: ("{field,factorial_ring_gcd,random}") random
---
> instantiation ratfps :: ("{field_gcd,random}") random
920c929
< instantiation ratfps :: ("{field,factorial_ring_gcd,full_exhaustive}") full_exhaustive
---
> instantiation ratfps :: ("{field_gcd,full_exhaustive}") full_exhaustive
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Rational_FPS_Asymptotics.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Rational_FPS_Asymptotics.thy
8d7
<   "HOL-Analysis.Analysis"
231c230
<   assumes "poly p x = 0" and "poly q (x :: 'a :: {factorial_ring_gcd}) = 0"
---
>   assumes "poly p x = 0" and "poly q (x :: 'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize}) = 0"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Linear_Recurrences/Rational_FPS_Solver.thy ../../AFPs/afp-2020/thys/Linear_Recurrences/Rational_FPS_Solver.thy
83c83
<   fixes p :: "'a :: {field_char_0,factorial_ring_gcd,normalization_euclidean_semiring} poly" and cs :: "('a \<times> nat) list"
---
>   fixes p :: "'a :: {field_char_0,field_gcd} poly" and cs :: "('a \<times> nat) list"
169c169
<     "('a :: {field_char_0,factorial_ring_gcd,normalization_euclidean_semiring}) poly \<Rightarrow> ('a \<times> nat) list \<Rightarrow> 'a poly \<times> ('a poly \<times> 'a) list" where
---
>     "('a :: {field_char_0,field_gcd}) poly \<Rightarrow> ('a \<times> nat) list \<Rightarrow> 'a poly \<times> ('a poly \<times> 'a) list" where
192c192
<   fixes p :: "'a :: {field_char_0,factorial_ring_gcd,normalization_euclidean_semiring} poly" and cs :: "('a \<times> nat) list"
---
>   fixes p :: "'a :: {field_char_0,field_gcd} poly" and cs :: "('a \<times> nat) list"
Only in ../../AFPs/afp-2019/thys/Linear_Recurrences: Show_RatFPS.thy
Only in ../../AFPs/afp-2020/thys/Linear_Recurrences: Solver
==========
List_Update
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/List_Update/Comb.thy ../../AFPs/afp-2020/thys/List_Update/Comb.thy
180a181
>   fixes bit
==========
LLL_Basis_Reduction
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/Gram_Schmidt_2.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/Gram_Schmidt_2.thy
2200,2205c2200,2202
<   assumes "b \<noteq> 0" "of_int a / (of_int b :: 'a :: field_char_0) \<in> \<int>"
<   shows "b dvd a"
<   using assms apply(elim Ints_cases)
<   unfolding dvd_def
<   by (metis nonzero_mult_div_cancel_left of_int_0_eq_iff of_int_eq_iff of_int_simps(4) times_divide_eq_right)
< 
---
>   "b dvd a" if "of_int a / (of_int b :: 'a :: field_char_0) \<in> \<int>" "b \<noteq> 0"
>   using that by (cases rule: Ints_cases)
>     (simp add: field_simps flip: of_int_mult)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/LLL_Complexity.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/LLL_Complexity.thy
669c669
<   from LLL_inv_N_pos[OF LLL_inv_initial_state g_bound_fs_init m0] have N0: "N > 0" .
---
>   from LLL_inv_N_pos[OF LLL_inv_imp_w[OF LLL_inv_initial_state] g_bound_fs_init m0] have N0: "N > 0" .
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/LLL_Impl.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/LLL_Impl.thy
84c84
< lemma d_d\<mu>_add_row: assumes Linv: "LLL_invariant True i fs"
---
> lemma d_d\<mu>_add_row: assumes Linv: "LLL_invariant_weak fs"
100c100
<   interpret fs: fs_int' n m fs_init \<alpha> True i fs
---
>   interpret fs: fs_int' n m fs_init fs
103c103
<   interpret fs': fs_int' n m fs_init \<alpha> True i fs'
---
>   interpret fs': fs_int' n m fs_init fs'
109c109
<   note updates = add(5)[OF i' j'm]
---
>   note updates = add(7)[OF i' j'm]
121c121
<       using j' i'  LLL_invD[OF add(1)]  by (auto)
---
>       using j' i'  LLL_inv_wD[OF add(1)]  by (auto)
125c125
<       using j' i' LLL_invD[OF Linv]  by (auto)
---
>       using j' i' LLL_inv_wD[OF Linv]  by (auto)
129c129
<       using that j i LLL_invD[OF Linv]  by (auto)
---
>       using that j i LLL_inv_wD[OF Linv]  by (auto)
144c144,145
< lemma d_d\<mu>_swap: assumes inv: "LLL_invariant False k fs"
---
> lemma d_d\<mu>_swap: assumes invw: "LLL_invariant_weak fs"
>   and small: "LLL_invariant False k fs \<or> abs (\<mu> fs k (k - 1)) \<le> 1/2" 
169c170,172
<   note swap = basis_reduction_swap_main[OF inv k k0 norm_ineq fs'_def]
---
>   note swap = basis_reduction_swap_main[OF invw small k k0 norm_ineq fs'_def]
>   note invw2 = swap(1)
>   note swap = swap(1,3-)
171,175c174,178
<   from LLL_invD[OF inv] have len: "length fs = m" by auto
<   interpret fs: fs_int' n m fs_init \<alpha> False k fs
<     by standard (use inv in auto)
<   interpret fs': fs_int' n m fs_init \<alpha> False "k - 1" fs'
<     by standard (use swap(1) in auto)
---
>   from LLL_inv_wD[OF invw] have len: "length fs = m" by auto
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
>   interpret fs': fs_int' n m fs_init fs'
>     by standard (use invw2 in auto)
185c188
<   note inv' = LLL_invD[OF inv]
---
>   note inv' = LLL_inv_wD[OF invw]
196c199
<      using dmu'[of j i] LLL_invD[OF swap(1)] unfolding d\<mu>_def fs'.d\<mu>_def d_def fs'.d_def by auto
---
>      using dmu'[of j i] LLL_inv_wD[OF invw2] unfolding d\<mu>_def fs'.d\<mu>_def d_def fs'.d_def by auto
198c201
<      using dmu[of j i] LLL_invD[OF inv] unfolding d\<mu>_def fs.d\<mu>_def d_def fs.d_def by auto
---
>      using dmu[of j i] LLL_inv_wD[OF invw] unfolding d\<mu>_def fs.d\<mu>_def d_def fs.d_def by auto
200c203
<   from LLL_d_Suc[OF inv km1, unfolded sim1] 
---
>   from LLL_d_Suc[OF invw km1, unfolded sim1] 
202c205
<   note pos = Gramian_determinant[OF inv le_refl] 
---
>   note pos = Gramian_determinant[OF invw le_refl] 
205c208
<   note pos = Gramian_determinant[OF swap(1) le_refl] 
---
>   note pos = Gramian_determinant[OF invw2 le_refl] 
208,209c211,212
<   have dzero: "i \<le> m \<Longrightarrow> d fs i \<noteq> 0" for i using LLL_d_pos[OF inv, of i] by auto
<   have dzero': "i \<le> m \<Longrightarrow> d fs' i \<noteq> 0" for i using LLL_d_pos[OF swap(1), of i] by auto
---
>   have dzero: "i \<le> m \<Longrightarrow> d fs i \<noteq> 0" for i using LLL_d_pos[OF invw, of i] by auto
>   have dzero': "i \<le> m \<Longrightarrow> d fs' i \<noteq> 0" for i using LLL_d_pos[OF invw2, of i] by auto
242c245
<         unfolding LLL_d_Suc[OF inv km1, unfolded sim1] using dzero[of "k - 1"] k k0 by simp
---
>         unfolding LLL_d_Suc[OF invw km1, unfolded sim1] using dzero[of "k - 1"] k k0 by simp
249c252
<         unfolding LLL_d_Suc[OF inv k] by simp
---
>         unfolding LLL_d_Suc[OF invw k] by simp
336c339
<           also have "?n k * ?r (d fs k) = ?r (d fs (Suc k))" unfolding LLL_d_Suc[OF inv k] ..
---
>           also have "?n k * ?r (d fs k) = ?r (d fs (Suc k))" unfolding LLL_d_Suc[OF invw k] ..
632,633c635,637
<   interpret fs: fs_int' n m fs_init \<alpha> True i fs
<     by standard (use Linv in auto)
---
>   note Linvw = LLL_inv_imp_w[OF Linv]
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use Linvw in auto)
637,638c641,642
<   from LLL_d_pos[OF Linv] j i have dj: "d fs (Suc j) > 0" by auto
<   note updates = d_d\<mu>_add_row[OF Linv i j refl]
---
>   from LLL_d_pos[OF Linvw] j i have dj: "d fs (Suc j) > 0" by auto
>   note updates = d_d\<mu>_add_row[OF Linvw i j refl]
649c653
<     note step = Linv basis_reduction_add_row_main_0[OF Linv i j True Suc(4)]
---
>     note step = Linv basis_reduction_add_row_main_0[OF Linvw i j True Suc(4)]
660c664,666
<     note step = basis_reduction_add_row_main[OF Linv i j fs''[symmetric]]
---
>     note step = basis_reduction_add_row_main[OF Linvw i j fs''[symmetric]]
>     note Linvw2 = step(1)
>     note step = step(2)[OF Linv] step(3,5-)
805a812
>   note invw = LLL_inv_imp_w[OF inv]
821,826c828,835
<   let ?ds = "d_state state"
<   note swap = basis_reduction_swap_main[OF inv i i0 cond refl, unfolded fs'']
<   interpret fs: fs_int' n m fs_init \<alpha> False i fs
<     by standard (use inv in auto)
<   interpret fs'': fs_int' n m fs_init \<alpha> False "i - 1" fs''
<     by standard (use swap in auto)
---
>   let ?ds = "d_state state" 
>   note swap = basis_reduction_swap_main[OF invw disjI1[OF inv] i i0 cond refl, unfolded fs'']
>   note invw2 = swap(1)
>   note swap = swap(2)[OF inv] swap(3-)
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
>   interpret fs'': fs_int' n m fs_init fs''
>     by standard (use invw2 in auto)
849c858
<   from LLL_d_Suc[OF inv im1, unfolded sim1]
---
>   from LLL_d_Suc[OF invw im1, unfolded sim1]
857c866
<   note updates = d_d\<mu>_swap[OF inv i i0 cond fs''[symmetric]]
---
>   note updates = d_d\<mu>_swap[OF invw disjI1[OF inv] i i0 cond fs''[symmetric]]
958a968
>     note invw = LLL_inv_imp_w[OF inv]
963,964c973,974
<     interpret fs'': fs_int' n m fs_init \<alpha> False i fs''
<       by standard (use inv in auto)
---
>     interpret fs'': fs_int' n m fs_init fs''
>       by standard (use invw in auto)
969c979
<     note pos = LLL_d_pos[OF inv le(1)] LLL_d_pos[OF inv le(2)] quotient_of_denom_pos[OF quot]
---
>     note pos = LLL_d_pos[OF invw le(1)] LLL_d_pos[OF invw le(2)] quotient_of_denom_pos[OF quot]
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/LLL_Number_Bounds.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/LLL_Number_Bounds.thy
35a36,38
> definition g_bnd :: "rat \<Rightarrow> int vec list \<Rightarrow> bool" where 
>   "g_bnd B fs = (\<forall> i < m. sq_norm (gso fs i) \<le> B)" 
> 
166c169,171
<   note main = basis_reduction_add_row_main[OF Linv i j fs']
---
>   note Linvw = LLL_inv_imp_w[OF Linv]
>   note main = basis_reduction_add_row_main[OF Linvw i j fs']
>   note main = main(2)[OF Linv] main(3,5-)
284,285c289,291
<   interpret fs: fs_int' n m fs_init \<alpha> True i fs
<     by standard (use Linv in auto)
---
>   note Linvw = LLL_inv_imp_w[OF Linv]
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use Linvw in auto)
289c295
<   have N0: "N > 0" using LLL_inv_N_pos[OF Linv gbnd] i by auto
---
>   have N0: "N > 0" using LLL_inv_N_pos[OF Linvw gbnd] i by auto
299c305
<       by (rule mult_right_mono, insert ji i d_approx[OF Linv gbnd, of j], auto)
---
>       by (rule mult_right_mono, insert ji i d_approx[OF Linvw gbnd, of j], auto)
391a398
>   note Linvw = LLL_inv_imp_w[OF Linv]
395c402,403
<   note step' = basis_reduction_add_row_main(1,2,3)[OF Linv i j refl]
---
>   note step' = basis_reduction_add_row_main(2,3,5)[OF Linvw i j refl]
>   note step' = step'(1)[OF Linv] step'(2-)
433,436c441,444
< 
< lemma basis_reduction_swap_bound: assumes 
<   binv: "LLL_bound_invariant True False i fs" 
<   and res: "basis_reduction_swap i fs = (upw',i',fs')" 
---
> lemma g_bnd_swap:  
>   assumes i: "i < m" "i \<noteq> 0"
>   and Linv: "LLL_invariant_weak fs"
>   and mu_F1_i: "\<bar>\<mu> fs i (i-1)\<bar> \<le> 1 / 2"
438,446c446,450
<   and i: "i < m" "i \<noteq> 0" 
< shows "LLL_bound_invariant True upw' i' fs'" 
< proof (rule bound_invI)
<   note Linv = bound_invD(1)[OF binv]
<   from basis_reduction_swap[OF Linv res cond i]
<   show Linv': "LLL_invariant upw' i' fs'" by auto
<   from res[unfolded basis_reduction_swap_def]
<   have id: "i' = i - 1" "fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]" by auto
<   from LLL_invD(6)[OF Linv] i
---
>   and fs'_def: "fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]" 
>   and g_bnd: "g_bnd B fs" 
> shows "g_bnd B fs'" 
> proof -
>   note inv = LLL_inv_wD[OF Linv]
448,454c452
<     unfolding id by (cases "k = i"; cases "k = i - 1", auto) 
<   from bound_invD(2)[OF binv] i 
<   show "f_bound True i' fs'" unfolding id(1) f_bound_def
<   proof (intro allI impI, goal_cases)
<     case (1 k)
<     thus ?case using choice[of k] by auto
<   qed
---
>     unfolding fs'_def using i inv(6) by (cases "k = i"; cases "k = i - 1", auto) 
460,461c458
<   from bound_invD(3)[OF binv, unfolded g_bound_def]
<   have short: "\<And> k. k < m \<Longrightarrow> ?n1 k \<le> of_nat N" by auto
---
>   from g_bnd[unfolded g_bnd_def] have short: "\<And> k. k < m \<Longrightarrow> ?n1 k \<le> B" by auto
463,465c460,462
<   have short_im1: "?n1 (i - 1) \<le> of_nat N" by auto
<   note swap = basis_reduction_swap_main[OF Linv i cond id(2)]
<   note updates = swap(3,4)
---
>   have short_im1: "?n1 (i - 1) \<le> B" by auto
>   note swap = basis_reduction_swap_main[OF Linv disjI2[OF mu_F1_i] i cond fs'_def]
>   note updates = swap(4,5)
467,468c464,465
<   note inv' = LLL_invD[OF Linv']
<   note inv = LLL_invD[OF Linv]
---
>   note inv' = LLL_inv_wD[OF Linv']
>   note inv = LLL_inv_wD[OF Linv]
476,477c473
<   from LLL_invD[OF Linv] have "\<mu>_small fs i" by blast
<   from this[unfolded \<mu>_small_def] i have mu: "abs ?mu \<le> 1/2" by auto
---
>   have mu: "abs ?mu \<le> 1/2" using mu_F1_i .
492c488
<   show "g_bound fs'" unfolding g_bound_def
---
>   show "g_bnd B fs'" unfolding g_bnd_def
497c493
<     thus "?n2 k \<le> of_nat N"
---
>     thus "?n2 k \<le> B"
500c496
<       from short[OF km] have "?n1 k \<le> of_nat N" by auto
---
>       from short[OF km] have "?n1 k \<le> B" by auto
508c504
<       also have "\<dots> \<le> of_nat N" using short_im1 by auto
---
>       also have "\<dots> \<le> B" using short_im1 by auto
546c542
<           by (intro gs2.gso_oc_projection_span(2)) (auto)
---
>           by (intro gs2.gso_oc_projection_span(2)) auto
548c544
<           unfolding id(2) using inv(6) i by (auto)
---
>           unfolding fs'_def using inv(6) i by auto
555c551
<           using inv' \<open>i \<le> m\<close> unfolding gs.lin_indpt_list_def
---
>           using inv' \<open>i < m\<close> unfolding gs.lin_indpt_list_def
561c557
<         also have "\<dots> = U" unfolding U_def id(2) 
---
>         also have "\<dots> = U" unfolding U_def fs'_def 
570c566
<       also have "\<dots> \<le> of_nat N" by fact
---
>       also have "\<dots> \<le> B" by fact
575a572,603
> 
> lemma basis_reduction_swap_bound: assumes 
>   binv: "LLL_bound_invariant True False i fs" 
>   and res: "basis_reduction_swap i fs = (upw',i',fs')" 
>   and cond: "sq_norm (gso fs (i - 1)) > \<alpha> * sq_norm (gso fs i)" 
>   and i: "i < m" "i \<noteq> 0" 
> shows "LLL_bound_invariant True upw' i' fs'" 
> proof (rule bound_invI)
>   note Linv = bound_invD(1)[OF binv]
>   from basis_reduction_swap[OF Linv res cond i]
>   show Linv': "LLL_invariant upw' i' fs'" by auto
>   from res[unfolded basis_reduction_swap_def]
>   have id: "i' = i - 1" "fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]" by auto
>   from LLL_invD(6)[OF Linv] i
>   have choice: "fs' ! k = fs ! k \<or> fs' ! k = fs ! i \<or> fs' ! k = fs ! (i - 1)" for k 
>     unfolding id by (cases "k = i"; cases "k = i - 1", auto) 
>   from bound_invD(2)[OF binv] i 
>   show "f_bound True i' fs'" unfolding id(1) f_bound_def
>   proof (intro allI impI, goal_cases)
>     case (1 k)
>     thus ?case using choice[of k] by auto
>   qed
> 
>   from bound_invD(3)[OF binv, unfolded g_bound_def]
>   have gbnd: "g_bnd (of_nat N) fs" unfolding g_bnd_def .
>   from LLL_invD(11)[OF Linv, unfolded \<mu>_small_def] i 
>   have "abs (\<mu> fs i (i - 1)) \<le> 1/2" by auto
>   from g_bnd_swap[OF i LLL_inv_imp_w[OF Linv] this cond id(2) gbnd]
>   have "g_bnd (rat_of_nat N) fs'" .
>   thus "g_bound fs'" unfolding g_bnd_def g_bound_def .
> qed
> 
709c737,738
<   from LLL_inv_N_pos[OF inv gbnd] i have N0: "N > 0" by auto
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd] i have N0: "N > 0" by auto
751a781
>   note invw = LLL_inv_imp_w[OF inv]
753,755c783,785
<   interpret fs: fs_int' n m fs_init \<alpha> upw k fs
<     by standard (use inv in auto)
<   note d_approx[OF inv gbnd i, unfolded d_def]  
---
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
>   note d_approx[OF invw gbnd i, unfolded d_def]  
772c802
<     using less_le_trans[OF LLL_D_pos[OF inv] D_approx[OF inv gbnd]] by auto
---
>     using less_le_trans[OF LLL_D_pos[OF invw] D_approx[OF invw gbnd]] by auto
789c819
<     using quotient_of_bounds[OF quot l LLL_d_pos[OF inv] gs_bound] i by auto
---
>     using quotient_of_bounds[OF quot l LLL_d_pos[OF invw] gs_bound] i by auto
792c822
<   from d_approx[OF inv gbnd i] have d: "d fs i \<le> int (N ^ i)"
---
>   from d_approx[OF invw gbnd i] have d: "d fs i \<le> int (N ^ i)"
844c874,875
<   from LLL_inv_N_pos[OF inv gbnd] m have N: "N > 0" by auto 
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd] m have N: "N > 0" by auto 
846c877
<   from d_approx_main[OF inv gbnd i m] 
---
>   from d_approx_main[OF invw gbnd i m] 
853c884
<   with LLL_d_pos[OF inv i] one
---
>   with LLL_d_pos[OF invw i] one
866c897,898
<   from LLL_inv_N_pos[OF inv gbnd] i have N: "N > 0" by auto 
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd] i have N: "N > 0" by auto 
868,869c900,901
<   interpret fs: fs_int' n m fs_init \<alpha> upw k fs
<     by standard (use inv in auto)
---
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
872c904
<   from d_approx[OF inv gbnd jm]
---
>   from d_approx[OF invw gbnd jm]
915,917c947,950
<   interpret fs: fs_int' n m fs_init \<alpha> upw k fs
<     by standard (use inv in auto)
<   from LLL_inv_N_pos[OF inv gbnd] i have N: "N > 0" by auto 
---
>   note invw = LLL_inv_imp_w[OF inv]
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
>   from LLL_inv_N_pos[OF invw gbnd] i have N: "N > 0" by auto 
947c980,981
<   from LLL_inv_N_pos[OF inv gbnd] i have N: "N > 0" by auto 
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd] i have N: "N > 0" by auto 
949,950c983,984
<   interpret fs: fs_int' n m fs_init \<alpha> upw k fs
<     by standard (use inv in auto)
---
>   interpret fs: fs_int' n m fs_init fs
>     by standard (use invw in auto)
957c991
<     from LLL_d_pos[OF inv, of "Suc j"] i j have dsj: "0 < d fs (Suc j)" by auto
---
>     from LLL_d_pos[OF invw, of "Suc j"] i j have dsj: "0 < d fs (Suc j)" by auto
1037c1071,1072
<   from LLL_inv_N_pos[OF inv gbnd] i have N: "N > 0" by auto
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd] i have N: "N > 0" by auto
1136c1171,1172
<   from LLL_inv_N_pos[OF inv gbnd m] have N: "N > 0" by auto
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd m] have N: "N > 0" by auto
1163c1199,1200
<   from LLL_inv_N_pos[OF inv gbnd m] have N: "N > 0" by auto
---
>   note invw = LLL_inv_imp_w[OF inv]
>   from LLL_inv_N_pos[OF invw gbnd m] have N: "N > 0" by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/LLL.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/LLL.thy
81a82,113
> definition LLL_invariant_weak :: "int vec list \<Rightarrow> bool" where
>   "LLL_invariant_weak fs = (
>     gs.lin_indpt_list (RAT fs) \<and> 
>     lattice_of fs = L \<and>
>     length fs = m)"
> 
> lemma LLL_inv_wD: assumes "LLL_invariant_weak fs"
>   shows 
>   "lin_indep fs" 
>   "length (RAT fs) = m" 
>   "set fs \<subseteq> carrier_vec n"
>   "\<And> i. i < m \<Longrightarrow> fs ! i \<in> carrier_vec n" 
>   "\<And> i. i < m \<Longrightarrow> gso fs i \<in> carrier_vec n" 
>   "length fs = m"
>   "lattice_of fs = L" 
> proof (atomize (full), goal_cases)
>   case 1
>   interpret gs': gram_schmidt_fs_lin_indpt n "RAT fs"
>     by (standard) (use assms LLL_invariant_weak_def gs.lin_indpt_list_def in auto)
>   show ?case
>     using assms gs'.fs_carrier gs'.f_carrier gs'.gso_carrier
>     by (auto simp add: LLL_invariant_weak_def gram_schmidt_fs.reduced_def)
> qed
> 
> lemma LLL_inv_wI: assumes  
>   "set fs \<subseteq> carrier_vec n"
>   "length fs = m"
>   "lattice_of fs = L" 
>   "lin_indep fs" 
> shows "LLL_invariant_weak fs" 
>   unfolding LLL_invariant_weak_def Let_def using assms by auto
> 
91a124,126
> lemma LLL_inv_imp_w: "LLL_invariant upw i fs \<Longrightarrow> LLL_invariant_weak fs" 
>   unfolding LLL_invariant_def LLL_invariant_weak_def by blast 
> 
130,131c165,166
<   fixes n m fs_init \<alpha> upw i fs 
<   assumes LLL_inv: "LLL.LLL_invariant n m fs_init \<alpha> upw i fs"
---
>   fixes n m fs_init fs 
>   assumes LLL_inv: "LLL.LLL_invariant_weak n m fs_init fs"
134c169
<    using LLL_inv unfolding LLL.LLL_invariant_def by (unfold_locales) blast
---
>    using LLL_inv unfolding LLL.LLL_invariant_weak_def by (unfold_locales) blast
165,166c200,201
<   fixes upw i fs
<   assumes Linv: "LLL_invariant upw i fs"
---
>   fixes fs
>   assumes Linv: "LLL_invariant_weak fs"
169c204
< interpretation fs: fs_int' n m fs_init \<alpha> upw i fs
---
> interpretation fs: fs_int' n m fs_init fs
176c211
<   using assms fs.Gramian_determinant LLL_invD[OF Linv]  by auto
---
>   using assms fs.Gramian_determinant LLL_inv_wD[OF Linv]  by auto
180c215
<   unfolding d_def using fs.Gramian_determinant k LLL_invD[OF Linv] by auto
---
>   unfolding d_def using fs.Gramian_determinant k LLL_inv_wD[OF Linv] by auto
184c219
<   using assms fs.fs_int_d_Suc  LLL_invD[OF Linv] unfolding fs.d_def d_def by auto
---
>   using assms fs.fs_int_d_Suc  LLL_inv_wD[OF Linv] unfolding fs.d_def d_def by auto
188c223,224
<   using fs.fs_int_D_pos LLL_invD[OF Linv] unfolding D_def fs.D_def fs.d_def d_def by auto
---
>   using fs.fs_int_D_pos LLL_inv_wD[OF Linv] unfolding D_def fs.D_def fs.d_def d_def by auto
> end
192a229
>   assumes Linv: "LLL_invariant upw i fs"
214,215d250
< end
< 
220c255
< lemma basis_reduction_add_row_main: assumes Linv: "LLL_invariant True i fs"
---
> lemma basis_reduction_add_row_main: assumes Linv: "LLL_invariant_weak fs"
223c258,259
< shows "LLL_invariant True i fs'"
---
> shows "LLL_invariant_weak fs'" 
>   "LLL_invariant True i fs \<Longrightarrow> LLL_invariant True i fs'"
224a261
>   "c = round (\<mu> fs i j) \<Longrightarrow> abs (\<mu> fs' i j) \<le> 1/2" (* mu-value at position i j gets small *)
236c273
<   note inv = LLL_invD[OF Linv]
---
>   note inv = LLL_inv_wD[OF Linv]
240c277
<     and len: "length fs = m" and red: "weakly_reduced fs i"
---
>     and len: "length fs = m" 
315c352
<     by (standard) (use LLL_invD[OF assms(1)] gs.lin_indpt_list_def in auto)
---
>     by (standard) (use inv gs.lin_indpt_list_def in auto)
352c389
<     using \<open>i \<le> m\<close> len
---
>     using \<open>i < m\<close> len
355c392
<     using gs1.partial_span  \<open>i \<le> m\<close> id1 inv by auto
---
>     using gs1.partial_span  \<open>i < m\<close> id1 inv by auto
387c424
<   have red: "weakly_reduced fs' i" using red using eq_fs \<open>i < m\<close>
---
>   have red: "weakly_reduced fs i \<Longrightarrow> weakly_reduced fs' i" using eq_fs \<open>i < m\<close>
432d468
<   from inv have sred: "reduced fs i" by auto
475,481c511,526
<   have sred: "reduced fs' i"
<     unfolding gram_schmidt_fs.reduced_def 
<   proof (intro conjI[OF red] impI allI, goal_cases)
<     case (1 i' j)
<     with mu_no_change[of i' j] sred[unfolded gram_schmidt_fs.reduced_def, THEN conjunct2, rule_format, of i' j] i 
<     show ?case by auto
<   qed
---
>   {
>     assume "LLL_invariant True i fs"
>     from LLL_invD[OF this] have "weakly_reduced fs i" and sred: "reduced fs i" by auto
>     from red[OF this(1)] have red: "weakly_reduced fs' i" .
>     have sred: "reduced fs' i"
>       unfolding gram_schmidt_fs.reduced_def 
>     proof (intro conjI[OF red] impI allI, goal_cases)
>       case (1 i' j)
>       with mu_no_change[of i' j] sred[unfolded gram_schmidt_fs.reduced_def, THEN conjunct2, rule_format, of i' j] i 
>       show ?case by auto
>     qed
>     show "LLL_invariant True i fs'" 
>       by (intro LLL_invI[OF F1 lattice \<open>i \<le> m\<close> indep_F1 sred], auto)
>   } 
>   show Linv': "LLL_invariant_weak fs'" 
>     by (intro LLL_inv_wI[OF F1 lattice indep_F1])
489d533
<     assume mu_small: "\<mu>_small_row i fs (Suc j)" 
493c537,538
<     have mu'_2: "abs (?mu' i j) \<le> inverse 2" .
---
>     show mu'_2: "abs (?mu' i j) \<le> 1 / 2" by simp
>     assume mu_small: "\<mu>_small_row i fs (Suc j)" 
504,505d548
<   show Linv': "LLL_invariant True i fs'" 
<     by (intro LLL_invI[OF F1 lattice \<open>i \<le> m\<close> lin_indpt_list_fs sred], auto)
523c566
< lemma basis_reduction_add_row_main_0: assumes Linv: "LLL_invariant True i fs"
---
> lemma basis_reduction_add_row_main_0: assumes Linv: "LLL_invariant_weak fs"
529c572
<   note inv = LLL_invD[OF Linv]
---
>   note inv = LLL_inv_wD[OF Linv]
631c674,675
< lemma basis_reduction_swap_main: assumes Linv: "LLL_invariant False i fs"
---
> lemma basis_reduction_swap_main: assumes Linvw: "LLL_invariant_weak fs"
>   and small: "LLL_invariant False i fs \<or> abs (\<mu> fs i (i - 1)) \<le> 1/2" 
636c680,681
< shows "LLL_invariant False (i - 1) fs'" 
---
> shows "LLL_invariant_weak fs'" 
>   and "LLL_invariant False i fs \<Longrightarrow> LLL_invariant False (i - 1) fs'" 
669,671c714,716
<   note inv = LLL_invD[OF Linv]
<   interpret fs: fs_int' n m fs_init \<alpha> False i fs
<     by (standard) (use Linv in auto)
---
>   note inv = LLL_inv_wD[OF Linvw]
>   interpret fs: fs_int' n m fs_init fs
>     by (standard) (use Linvw in auto)
676,679c721,725
<   from inv(11)[unfolded \<mu>_small_def]
<   have mu_F1_i: "\<And> j. j<i \<Longrightarrow> \<bar>?mu1 i j\<bar> \<le> 1 / 2" by auto
<   from mu_F1_i[of "i-1"] have m12: "\<bar>?mu1 i (i - 1)\<bar> \<le> inverse 2" using i0
<     by auto
---
>   have m12: "\<bar>?mu1 i (i - 1)\<bar> \<le> inverse 2" using small
>   proof 
>     assume "LLL_invariant False i fs" 
>     from LLL_invD(11)[OF this] i0 show ?thesis unfolding \<mu>_small_def by auto
>   qed auto
682c728
<   note Gd12 = Gd[OF Linv]
---
>   note Gd12 = Gd[OF Linvw]
685,686c731
<   from inv have red: "weakly_reduced fs i" 
<     and len: "length fs = m" and HC: "set fs \<subseteq> carrier_vec n" 
---
>   from inv have len: "length fs = m" and HC: "set fs \<subseteq> carrier_vec n" 
727,730d771
<   from inv have "weakly_reduced fs i" by auto
<   hence "weakly_reduced fs (i - 1)" unfolding gram_schmidt_fs.weakly_reduced_def by auto
<   hence red: "weakly_reduced fs' (i - 1)"
<     unfolding gram_schmidt_fs.weakly_reduced_def using i G2_G by simp
1104,1113d1144
<   (* stay reduced *)
<   from inv have sred: "reduced fs i" by auto
<   have sred: "reduced fs' (i - 1)"
<     unfolding gram_schmidt_fs.reduced_def
<   proof (intro conjI[OF red] allI impI, goal_cases)
<     case (1 i' j)
<     with sred have "\<bar>?mu1 i' j\<bar> \<le> 1 / 2" unfolding gram_schmidt_fs.reduced_def by auto
<     thus ?case using mu'_mu_small_i[OF 1(1)] by simp
<   qed
< 
1135,1140c1166,1191
<   have mu_small: "\<mu>_small fs' (i - 1)" 
<     unfolding \<mu>_small_def
<   proof (intro allI impI, goal_cases)
<     case (1 j)
<     thus ?case using inv(11) unfolding mu'_mu_i_im1_j[OF 1] \<mu>_small_def by auto
<   qed      
---
>   {
>   (* stay reduced *)
>     assume "LLL_invariant False i fs" 
>     note inv = LLL_invD[OF this] 
>     from inv have "weakly_reduced fs i" by auto
>     hence "weakly_reduced fs (i - 1)" unfolding gram_schmidt_fs.weakly_reduced_def by auto
>     hence red: "weakly_reduced fs' (i - 1)"
>       unfolding gram_schmidt_fs.weakly_reduced_def using i G2_G by simp
>     from inv have sred: "reduced fs i" by auto
>     have sred: "reduced fs' (i - 1)"
>       unfolding gram_schmidt_fs.reduced_def
>     proof (intro conjI[OF red] allI impI, goal_cases)
>       case (1 i' j)
>       with sred have "\<bar>?mu1 i' j\<bar> \<le> 1 / 2" unfolding gram_schmidt_fs.reduced_def by auto
>       thus ?case using mu'_mu_small_i[OF 1(1)] by simp
>     qed
>     have mu_small: "\<mu>_small fs' (i - 1)" 
>       unfolding \<mu>_small_def
>     proof (intro allI impI, goal_cases)
>       case (1 j)
>       thus ?case using inv(11) unfolding mu'_mu_i_im1_j[OF 1] \<mu>_small_def by auto
>     qed      
>     show "LLL_invariant False (i - 1) fs'"
>       by (rule LLL_invI, insert lin_indpt_list_fs' conn2 mu_small span' lattice fs' sred i, auto)
>   } 
> 
1143,1144c1194,1195
<   show newInv: "LLL_invariant False (i - 1) fs'"
<     by (rule LLL_invI, insert lin_indpt_list_fs' conn2 mu_small span' lattice fs' sred i, auto)
---
>   show newInvw: "LLL_invariant_weak fs'"
>     by (rule LLL_inv_wI, insert lin_indpt_list_fs' conn2 span' lattice fs', auto)
1149c1200
<     from Gd[OF newInv, folded d_def, OF ile] 
---
>     from Gd[OF newInvw, folded d_def, OF ile] 
1163c1214
<     also have "\<dots> = ?R (d fs i)" unfolding d_def Gd[OF Linv ile]
---
>     also have "\<dots> = ?R (d fs i)" unfolding d_def Gd[OF Linvw ile]
1168c1219
<         insert LLL_d_pos[OF Linv] i, auto)  
---
>         insert LLL_d_pos[OF Linvw] i, auto)  
1177c1228
<     using LLL_d_pos[OF newInv, of k] by auto
---
>     using LLL_d_pos[OF newInvw, of k] by auto
1179c1230
<     using LLL_d_pos[OF newInv] by auto
---
>     using LLL_d_pos[OF newInvw] by auto
1181c1232
<     using LLL_d_pos[OF newInv] pos by auto
---
>     using LLL_d_pos[OF newInvw] pos by auto
1183c1234
<     using LLL_d_pos[OF newInv] pos by auto
---
>     using LLL_d_pos[OF newInvw] pos by auto
1185c1236
<     using LLL_d_pos[OF assms(1)] by auto
---
>     using LLL_d_pos[OF Linvw] by auto
1214c1265
<     note pos = LLL_D_pos[OF newInv] LLL_D_pos[OF assms(1)]
---
>     note pos = LLL_D_pos[OF newInvw] LLL_D_pos[OF Linvw]
1307c1358
< lemma LLL_mu_d_Z: assumes inv: "LLL_invariant upw i fs" 
---
> lemma LLL_mu_d_Z: assumes inv: "LLL_invariant_weak fs" 
1311c1362
<   interpret fs: fs_int' n m fs_init \<alpha> upw i fs
---
>   interpret fs: fs_int' n m fs_init fs
1314c1365
<     using assms fs.fs_int_mu_d_Z LLL_invD[OF inv] unfolding d_def fs.d_def by auto
---
>     using assms fs.fs_int_mu_d_Z LLL_inv_wD[OF inv] unfolding d_def fs.d_def by auto
1317,1318c1368,1369
< context fixes upw i fs
<   assumes Linv: "LLL_invariant upw i fs" and gbnd: "g_bound fs" 
---
> context fixes fs
>   assumes Linv: "LLL_invariant_weak fs" and gbnd: "g_bound fs" 
1322c1373
<   by (standard) (use Linv LLL_invariant_def gs.lin_indpt_list_def in auto)
---
>   by (standard) (use Linv LLL_invariant_weak_def gs.lin_indpt_list_def in auto)
1328c1379
<   note inv = LLL_invD[OF Linv]
---
>   note inv = LLL_inv_wD[OF Linv]
1348c1399
<   note inv = LLL_invD[OF Linv]
---
>   note inv = LLL_inv_wD[OF Linv]
1372c1423
<   note inv = LLL_invD[OF Linv]
---
>   note inv = LLL_inv_wD[OF Linv]
1396c1447
<   note invD = LLL_invD[OF Linv]  
---
>   note invD = LLL_inv_wD[OF Linv]  
1454c1505
<   using LLL_measure_approx[OF _ g_bound_fs_init] .
---
>   using LLL_measure_approx[OF LLL_inv_imp_w g_bound_fs_init] .
1558c1609
<     thus ?thesis using Suc(1)[OF Suc(2) basis_reduction_add_row_main_0[OF Suc(2) i j True Suc(3)]]
---
>     thus ?thesis using Suc(1)[OF Suc(2) basis_reduction_add_row_main_0[OF LLL_inv_imp_w[OF Suc(2)] i j True Suc(3)]]
1562,1563c1613,1615
<     note step = basis_reduction_add_row_main[OF Suc(2) i j refl]
<     show ?thesis using Suc(1)[OF step(1-2)] False Suc(2-) step(3) by auto
---
>     note step = basis_reduction_add_row_main(2-)[OF LLL_inv_imp_w[OF Suc(2)] i j refl]
>     note step = step(1)[OF Suc(2)] step(2-)
>     show ?thesis using Suc(1)[OF step(1-2)] False Suc(2-) step(4) by simp
1596a1649
>   note invw = LLL_inv_imp_w[OF inv]
1600c1653
<   from basis_reduction_swap_main(1-2)[OF inv i cond id(3)] show ?g1 ?g2 unfolding id by auto
---
>   from basis_reduction_swap_main(2-3)[OF invw _ i cond id(3)] inv show ?g1 ?g2 unfolding id by auto
1610a1664
>   note invw = LLL_inv_imp_w[OF inv]
1615c1669
<     from increase_i[OF inv i True] True
---
>     from increase_i[OF inv i] True
1625a1680
>     note invw = LLL_inv_imp_w[OF inv]
1629,1630c1684,1685
<       from increase_i[OF inv i _ True] True res meas
<       show ?thesis by auto
---
>       from increase_i[OF inv i] id True res meas
>       show ?thesis by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LLL_Basis_Reduction/Missing_Lemmas.thy ../../AFPs/afp-2020/thys/LLL_Basis_Reduction/Missing_Lemmas.thy
769c769
<   fixes a::"'a :: factorial_ring_gcd poly"
---
>   fixes a::"'a :: {factorial_ring_gcd,factorial_semiring_multiplicative} poly"
==========
LocalLexing
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LocalLexing/Limit.thy ../../AFPs/afp-2020/thys/LocalLexing/Limit.thy
448c448
< lemma continous_comp: 
---
> lemma continuous_comp: 
464c464
< using continous_comp f g regular_def setmonotone_comp by blast
---
> using continuous_comp f g regular_def setmonotone_comp by blast
==========
LOFT
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LOFT/LinuxRouter_OpenFlow_Translation.thy ../../AFPs/afp-2020/thys/LOFT/LinuxRouter_OpenFlow_Translation.thy
66c66,67
< 	sb = (\<lambda>p. (if npm p then [None] else if fst p \<le> snd p then map (Some \<circ> (\<lambda>pfx. (pfxm_prefix pfx, NOT pfxm_mask pfx))) (wordinterval_CIDR_split_prefixmatch (WordInterval (fst p) (snd p))) else []))
---
> 	sb = (\<lambda>p. (if npm p then [None] else if fst p \<le> snd p
>   then map (Some \<circ> (\<lambda>pfx. (pfxm_prefix pfx, NOT (pfxm_mask pfx)))) (wordinterval_CIDR_split_prefixmatch (WordInterval (fst p) (snd p))) else []))
238c239
< 		have dpm: "di = Some (PrefixMatch x1 x2) \<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1" for x1 x2
---
> 		have dpm: "di = Some (PrefixMatch x1 x2) \<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1" for x1 x2
240c241
<       have *: "di = Some (PrefixMatch x1 x2) \<Longrightarrow> prefix_match_semantics (the di) (p_dport p) \<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1"
---
>       have *: "di = Some (PrefixMatch x1 x2) \<Longrightarrow> prefix_match_semantics (the di) (p_dport p) \<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1"
245c246
<              \<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1"
---
>              \<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1"
248c249
<       thus "di = Some (PrefixMatch x1 x2) \<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1"  using di(1,2) by auto
---
>       thus "di = Some (PrefixMatch x1 x2) \<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1"  using di(1,2) by auto
250c251
< 		have spm: "si = Some (PrefixMatch x1 x2) \<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1" for x1 x2
---
> 		have spm: "si = Some (PrefixMatch x1 x2) \<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1" for x1 x2
253c254
<       have *: "si = Some (PrefixMatch x1 x2) \<Longrightarrow> prefix_match_semantics (the si) (p_sport p) \<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1"
---
>       have *: "si = Some (PrefixMatch x1 x2) \<Longrightarrow> prefix_match_semantics (the si) (p_sport p) \<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1"
258c259
<              \<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1"
---
>              \<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1"
261c262
<       thus "si = Some (PrefixMatch x1 x2) \<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1"  using si(1,2) by auto
---
>       thus "si = Some (PrefixMatch x1 x2) \<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1"  using si(1,2) by auto
300c301
< 	  have "\<lbrakk>pp && ~~ pfxm_mask xc = pfxm_prefix xc\<rbrakk>
---
> 	  have "\<lbrakk>pp && ~~ (pfxm_mask xc) = pfxm_prefix xc\<rbrakk>
306c307
< 	  moreover have "\<lbrakk>xc \<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc); prefix_match_semantics xc (pp)\<rbrakk> \<Longrightarrow> pp \<in> prefix_to_wordset xc"
---
> 	  moreover have "\<lbrakk>xc \<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ (pfxm_mask xc)); prefix_match_semantics xc (pp)\<rbrakk> \<Longrightarrow> pp \<in> prefix_to_wordset xc"
311,312c312,313
< 	  ultimately have "\<lbrakk>xc \<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);
<                pp && ~~ pfxm_mask xc = pfxm_prefix xc\<rbrakk>
---
> 	  ultimately have "\<lbrakk>xc \<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ (pfxm_mask xc));
>                pp && ~~ (pfxm_mask xc) = pfxm_prefix xc\<rbrakk>
527c528
<            then map (Some \<circ> (\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))
---
>            then map (Some \<circ> (\<lambda>pfx. (pfxm_prefix pfx, ~~ (pfxm_mask pfx))))
535c536
<     assume iw: "x \<in> wis" "y \<in> wis" and et: "(pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)"
---
>     assume iw: "x \<in> wis" "y \<in> wis" and et: "(pfxm_prefix x, ~~ (pfxm_mask x)) = (pfxm_prefix y, ~~ (pfxm_mask y))"
==========
Lower_Semicontinuous
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy ../../AFPs/afp-2020/thys/Lower_Semicontinuous/Lower_Semicontinuous.thy
8c8
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Multivariate_Analysis"
75c75
<   hence not: "~(f \<circ> x) \<longlonglongrightarrow> (f x0)" unfolding tendsto_explicit using X_def S_def by auto
---
>   hence not: "~(f \<circ> x) \<longlonglongrightarrow> (f x0)" unfolding lim_explicit using X_def S_def by auto
78c78
<        using r_def tendsto_explicit[of "f \<circ> x \<circ> r" l] S_def by auto
---
>        using r_def lim_explicit[of "f \<circ> x \<circ> r" l] S_def by auto
99c99
<      from this obtain N1 where "\<forall>n\<ge>N1. x n \<in> T" using x_def tendsto_explicit[of x x0] by auto
---
>      from this obtain N1 where "\<forall>n\<ge>N1. x n \<in> T" using x_def lim_explicit[of x x0] by auto
102c102
<         using tendsto_explicit[of "f \<circ> x" A] x_def by auto
---
>         using lim_explicit[of "f \<circ> x" A] x_def by auto
1306c1306
<   apply (subst convex_linear_image) using fst_linear linear_conv_bounded_linear by auto
---
>   apply (subst convex_linear_image) using linear_fst linear_conv_bounded_linear by auto
==========
Lp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Lp/Lp.thy ../../AFPs/afp-2020/thys/Lp/Lp.thy
628c628
<     then have "f \<in> borel_measurable borel" using borel_measurable_continuous_on1 by simp
---
>     then have "f \<in> borel_measurable borel" using borel_measurable_continuous_onI by simp
950c950
< lemma L_zero_space:
---
> lemma L_zero_space [simp]:
2074c2074
<       using *[OF that] unfolding eventually_sequentially[symmetric] by (simp add: Lim_eventually)
---
>       using *[OF that] unfolding eventually_sequentially[symmetric] by (simp add: tendsto_eventually)
==========
LTL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL/Disjunctive_Normal_Form.thy ../../AFPs/afp-2020/thys/LTL/Disjunctive_Normal_Form.thy
14,19c14,21
< text \<open>We use the propositional representation of LTL formulas to define
<       the minimal disjunctive normal form of our formulas. For this purpose
<       we define the minimal product $\otimes_m$ and union $\cup_m$.
<       In the end we show that for a set $\mathcal{A}$ of literals,
<       $\mathcal{A} \models \varphi$ if, and only if, there exists a subset
<       of $\mathcal{A}$ in the minimal DNF of $\varphi$.\<close>
---
> text \<open>
>   We use the propositional representation of LTL formulas to define
>   the minimal disjunctive normal form of our formulas. For this purpose
>   we define the minimal product \<open>\<otimes>\<^sub>m\<close> and union \<open>\<union>\<^sub>m\<close>.
>   In the end we show that for a set \<open>\<A>\<close> of literals,
>   @{term "\<A> \<Turnstile>\<^sub>P \<phi>"} if, and only if, there exists a subset
>   of \<open>\<A>\<close> in the minimal DNF of \<open>\<phi>\<close>.
> \<close>
21,22c23
< 
< subsection \<open>Definition on minimum sets\<close>
---
> subsection \<open>Definition of Minimum Sets\<close>
78,80d78
< definition min_product_set :: "'a fset set set \<Rightarrow> 'a fset set" ("\<Otimes>\<^sub>m")
<   where "\<Otimes>\<^sub>m X = Finite_Set.fold min_product {{||}} X"
< 
83a82,87
> definition product_set :: "'a fset set set \<Rightarrow> 'a fset set" ("\<Otimes>")
>   where "\<Otimes> X = Finite_Set.fold product {{||}} X"
> 
> definition min_product_set :: "'a fset set set \<Rightarrow> 'a fset set" ("\<Otimes>\<^sub>m")
>   where "\<Otimes>\<^sub>m X = Finite_Set.fold min_product {{||}} X"
> 
109,112d112
< lemma min_product_set_empty[simp]:
<   "\<Otimes>\<^sub>m {} = {{||}}"
<   by (simp add: min_product_set_def)
< 
122a123,155
> lemma product_singleton_singleton:
>   "A \<otimes> {{|x|}} = finsert x ` A"
>   "{{|x|}} \<otimes> A = finsert x ` A"
>   unfolding product_def by blast+
> 
> lemma product_mono:
>   "A \<subseteq> B \<Longrightarrow> A \<otimes> C \<subseteq> B \<otimes> C"
>   "B \<subseteq> C \<Longrightarrow> A \<otimes> B \<subseteq> A \<otimes> C"
>   unfolding product_def by auto
> 
> 
> 
> lemma product_finite:
>   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<otimes> B)"
>   by (simp add: product_def finite_image_set2)
> 
> lemma min_product_finite:
>   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<otimes>\<^sub>m B)"
>   by (metis min_product_def product_finite min_set_finite)
> 
> lemma min_union_finite:
>   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<union>\<^sub>m B)"
>   by (simp add: min_union_def min_set_finite)
> 
> 
> lemma product_set_infinite[simp]:
>   "infinite X \<Longrightarrow> \<Otimes> X = {{||}}"
>   by (simp add: product_set_def)
> 
> lemma min_product_set_infinite[simp]:
>   "infinite X \<Longrightarrow> \<Otimes>\<^sub>m X = {{||}}"
>   by (simp add: min_product_set_def)
> 
224d256
< 
244a277,285
> interpretation product_set_thms: Finite_Set.comp_fun_commute product
> proof unfold_locales
>   have "\<And>x y z. x \<otimes> (y \<otimes> z) = y \<otimes> (x \<otimes> z)"
>     by (simp only: product_assoc[symmetric]) (simp only: product_comm)
> 
>   then show "\<And>x y. (\<otimes>) y \<circ> (\<otimes>) x = (\<otimes>) x \<circ> (\<otimes>) y"
>     by fastforce
> qed
> 
276a318,341
> lemma product_set_empty[simp]:
>   "\<Otimes> {} = {{||}}"
>   "\<Otimes> {{}} = {}"
>   "\<Otimes> {{{||}}} = {{||}}"
>   by (simp_all add: product_set_def)
> 
> lemma min_product_set_empty[simp]:
>   "\<Otimes>\<^sub>m {} = {{||}}"
>   "\<Otimes>\<^sub>m {{}} = {}"
>   "\<Otimes>\<^sub>m {{{||}}} = {{||}}"
>   by (simp_all add: min_product_set_def)
> 
> lemma product_set_code[code]:
>   "\<Otimes> (set xs) = fold product (remdups xs) {{||}}"
>   by (simp add: product_set_def product_set_thms.fold_set_fold_remdups)
> 
> lemma min_product_set_code[code]:
>   "\<Otimes>\<^sub>m (set xs) = fold min_product (remdups xs) {{||}}"
>   by (simp add: min_product_set_def min_product_set_thms.fold_set_fold_remdups)
> 
> lemma product_set_insert[simp]:
>   "finite X \<Longrightarrow> \<Otimes> (insert x X) = x \<otimes> (\<Otimes> (X - {x}))"
>   unfolding product_set_def product_set_thms.fold_insert_remove ..
> 
288a354,357
> lemma min_set_product_set:
>   "\<Otimes>\<^sub>m A = min_set (\<Otimes> A)"
>   by (cases "finite A", induction A rule: finite_induct) (simp_all add: min_product_set_def product_set_def, metis min_product_def)
> 
294,297d362
< lemma min_product_set_min_set[simp]:
<   "finite X \<Longrightarrow> min_set (\<Otimes>\<^sub>m X) = \<Otimes>\<^sub>m X"
<   by (induction X rule: finite_induct) (auto simp add: min_product_set_def min_set_iff)
< 
301a367,373
> lemma min_product_set_min_set[simp]:
>   "finite X \<Longrightarrow> min_set (\<Otimes>\<^sub>m X) = \<Otimes>\<^sub>m X"
>   by (induction X rule: finite_induct, auto simp add: min_product_set_def min_set_iff)
> 
> lemma min_set_min_product_set[simp]:
>   "finite X \<Longrightarrow> \<Otimes>\<^sub>m (min_set ` X) = \<Otimes>\<^sub>m X"
>   by (induction X rule: finite_induct) simp_all
308,314c380,382
< lemma product_finite:
<   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<otimes> B)"
<   by (simp add: product_def finite_image_set2)
< 
< lemma min_product_finite:
<   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<otimes>\<^sub>m B)"
<   by (metis min_product_def product_finite min_set_finite)
---
> lemma product_set_finite:
>   "(\<And>x. x \<in> X \<Longrightarrow> finite x) \<Longrightarrow> finite (\<Otimes> X)"
>   by (cases "finite X", rotate_tac, induction X rule: finite_induct) (simp_all add: product_set_def, insert product_finite, blast)
317,318c385,386
<   "finite X \<Longrightarrow> (\<And>x. x \<in> X \<Longrightarrow> finite x) \<Longrightarrow> finite (\<Otimes>\<^sub>m X)"
<   by (induction X rule: finite_induct) (simp_all add: min_product_set_def, insert min_product_finite, blast)
---
>   "(\<And>x. x \<in> X \<Longrightarrow> finite x) \<Longrightarrow> finite (\<Otimes>\<^sub>m X)"
>   by (cases "finite X", rotate_tac, induction X rule: finite_induct) (simp_all add: min_product_set_def, insert min_product_finite, blast)
320,322d387
< lemma min_union_finite:
<   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<union>\<^sub>m B)"
<   by (simp add: min_union_def min_set_finite)
325,326c390
< 
< subsection \<open>Minimal Disjunctive Normal Form\<close>
---
> subsection \<open>Disjunctive Normal Form\<close>
365,366c429,430
<   "A \<in> dnf \<phi> \<Longrightarrow> fset A \<subseteq> prop_atoms \<phi>"
<   by (induction \<phi> arbitrary: A) (auto simp: product_def, blast+)
---
>   "\<Phi> \<in> dnf \<phi> \<Longrightarrow> fset \<Phi> \<subseteq> prop_atoms \<phi>"
>   by (induction \<phi> arbitrary: \<Phi>) (auto simp: product_def, blast+)
369,370c433,454
<   "A \<in> min_dnf \<phi> \<Longrightarrow> fset A \<subseteq> prop_atoms \<phi>"
<   by (induction \<phi> arbitrary: A) (simp_all add: min_product_iff min_union_iff, fastforce+)
---
>   "\<Phi> \<in> min_dnf \<phi> \<Longrightarrow> fset \<Phi> \<subseteq> prop_atoms \<phi>"
>   using dnf_min_set dnf_prop_atoms min_set_subset by blast
> 
> lemma min_dnf_atoms_dnf:
>   "\<Phi> \<in> min_dnf \<psi> \<Longrightarrow> \<phi> \<in> fset \<Phi> \<Longrightarrow> dnf \<phi> = {{|\<phi>|}}"
> proof (induction \<phi>)
>   case True_ltln
>   then show ?case
>     using min_dnf_prop_atoms prop_atoms_notin(1) by blast
> next
>   case False_ltln
>   then show ?case
>     using min_dnf_prop_atoms prop_atoms_notin(2) by blast
> next
>   case (And_ltln \<phi>1 \<phi>2)
>   then show ?case
>     using min_dnf_prop_atoms prop_atoms_notin(3) by force
> next
>   case (Or_ltln \<phi>1 \<phi>2)
>   then show ?case
>     using min_dnf_prop_atoms prop_atoms_notin(4) by force
> qed auto
459c543,545
< export_code dnf min_dnf checking
---
> lemma min_dnf_rep_abs[simp]:
>   "min_dnf (rep_ltln\<^sub>P (abs_ltln\<^sub>P \<phi>)) = min_dnf \<phi>"
>   by (simp add: ltl_prop_equiv_min_dnf[symmetric] Quotient3_ltln\<^sub>P rep_abs_rsp_left)
461a548
> subsection \<open>Folding of \<open>and\<^sub>n\<close> and \<open>or\<^sub>n\<close> over Finite Sets\<close>
463,465c550
< subsection \<open>DNF to LTL conversion\<close>
< 
< abbreviation And\<^sub>n :: "'a ltln list \<Rightarrow> 'a ltln"
---
> definition And\<^sub>n :: "'a ltln set \<Rightarrow> 'a ltln"
467c552
<   "And\<^sub>n xs \<equiv> foldr And_ltln xs true\<^sub>n"
---
>   "And\<^sub>n \<Phi> \<equiv> SOME \<phi>. fold_graph And_ltln True_ltln \<Phi> \<phi>"
469c554
< abbreviation Or\<^sub>n :: "'a ltln list \<Rightarrow> 'a ltln"
---
> definition Or\<^sub>n :: "'a ltln set \<Rightarrow> 'a ltln"
471c556,671
<   "Or\<^sub>n xs \<equiv> foldr Or_ltln xs false\<^sub>n"
---
>   "Or\<^sub>n \<Phi> \<equiv> SOME \<phi>. fold_graph Or_ltln False_ltln \<Phi> \<phi>"
> 
> lemma fold_graph_And\<^sub>n:
>   "finite \<Phi> \<Longrightarrow> fold_graph And_ltln True_ltln \<Phi> (And\<^sub>n \<Phi>)"
>   unfolding And\<^sub>n_def by (rule someI2_ex[OF finite_imp_fold_graph])
> 
> lemma fold_graph_Or\<^sub>n:
>   "finite \<Phi> \<Longrightarrow> fold_graph Or_ltln False_ltln \<Phi> (Or\<^sub>n \<Phi>)"
>   unfolding Or\<^sub>n_def by (rule someI2_ex[OF finite_imp_fold_graph])
> 
> lemma Or\<^sub>n_empty[simp]:
>   "Or\<^sub>n {} = False_ltln"
>   by (metis empty_fold_graphE finite.emptyI fold_graph_Or\<^sub>n)
> 
> lemma And\<^sub>n_empty[simp]:
>   "And\<^sub>n {} = True_ltln"
>   by (metis empty_fold_graphE finite.emptyI fold_graph_And\<^sub>n)
> 
> interpretation dnf_union_thms: Finite_Set.comp_fun_commute "\<lambda>\<phi>. (\<union>) (f \<phi>)"
>   by unfold_locales fastforce
> 
> interpretation dnf_product_thms: Finite_Set.comp_fun_commute "\<lambda>\<phi>. (\<otimes>) (f \<phi>)"
>   by unfold_locales (simp add: product_set_thms.comp_fun_commute)
> 
> \<comment> \<open>Copied from locale @{locale comp_fun_commute}\<close>
> lemma fold_graph_finite:
>   assumes "fold_graph f z A y"
>   shows "finite A"
>   using assms by induct simp_all
> 
> 
> text \<open>Taking the DNF of @{const And\<^sub>n} and @{const Or\<^sub>n} is the same as folding over the individual DNFs.\<close>
> 
> lemma And\<^sub>n_dnf:
>   "finite \<Phi> \<Longrightarrow> dnf (And\<^sub>n \<Phi>) = Finite_Set.fold (\<lambda>\<phi>. (\<otimes>) (dnf \<phi>)) {{||}} \<Phi>"
> proof (drule fold_graph_And\<^sub>n, induction rule: fold_graph.induct)
>   case (insertI x A y)
> 
>   then have "finite A"
>     using fold_graph_finite by fast
> 
>   then show ?case
>     using insertI by auto
> qed simp
> 
> lemma Or\<^sub>n_dnf:
>   "finite \<Phi> \<Longrightarrow> dnf (Or\<^sub>n \<Phi>) = Finite_Set.fold (\<lambda>\<phi>. (\<union>) (dnf \<phi>)) {} \<Phi>"
> proof (drule fold_graph_Or\<^sub>n, induction rule: fold_graph.induct)
>   case (insertI x A y)
> 
>   then have "finite A"
>     using fold_graph_finite by fast
> 
>   then show ?case
>     using insertI by auto
> qed simp
> 
> 
> text \<open>@{const And\<^sub>n} and @{const Or\<^sub>n} are injective on finite sets.\<close>
> 
> lemma And\<^sub>n_inj:
>   "inj_on And\<^sub>n {s. finite s}"
> proof (standard, simp)
>   fix x y :: "'a ltln set"
>   assume "finite x" and "finite y"
> 
>   then have 1: "fold_graph And_ltln True_ltln x (And\<^sub>n x)" and 2: "fold_graph And_ltln True_ltln y (And\<^sub>n y)"
>     using fold_graph_And\<^sub>n by blast+
> 
>   assume "And\<^sub>n x = And\<^sub>n y"
> 
>   with 1 show "x = y"
>   proof (induction rule: fold_graph.induct)
>     case emptyI
>     then show ?case
>       using 2 fold_graph.cases by force
>   next
>     case (insertI x A y)
>     with 2 show ?case
>     proof (induction arbitrary: x A y rule: fold_graph.induct)
>       case (insertI x A y)
>       then show ?case
>         by (metis fold_graph.cases insertI1 ltln.distinct(7) ltln.inject(3))
>     qed blast
>   qed
> qed
> 
> lemma Or\<^sub>n_inj:
>   "inj_on Or\<^sub>n {s. finite s}"
> proof (standard, simp)
>   fix x y :: "'a ltln set"
>   assume "finite x" and "finite y"
> 
>   then have 1: "fold_graph Or_ltln False_ltln x (Or\<^sub>n x)" and 2: "fold_graph Or_ltln False_ltln y (Or\<^sub>n y)"
>     using fold_graph_Or\<^sub>n by blast+
> 
>   assume "Or\<^sub>n x = Or\<^sub>n y"
> 
>   with 1 show "x = y"
>   proof (induction rule: fold_graph.induct)
>     case emptyI
>     then show ?case
>       using 2 fold_graph.cases by force
>   next
>     case (insertI x A y)
>     with 2 show ?case
>     proof (induction arbitrary: x A y rule: fold_graph.induct)
>       case (insertI x A y)
>       then show ?case
>         by (metis fold_graph.cases insertI1 ltln.distinct(27) ltln.inject(4))
>     qed blast
>   qed
> qed
> 
> 
> text \<open>The semantics of @{const And\<^sub>n} and @{const Or\<^sub>n} can be expressed using quantifiers.\<close>
474,475c674,681
<   "w \<Turnstile>\<^sub>n And\<^sub>n xs \<longleftrightarrow> (\<forall>x \<in> set xs. w \<Turnstile>\<^sub>n x)"
<   by (induction xs) auto
---
>   "finite \<Phi> \<Longrightarrow> w \<Turnstile>\<^sub>n And\<^sub>n \<Phi> \<longleftrightarrow> (\<forall>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
> proof -
>   assume "finite \<Phi>"
>   have "\<And>\<psi>. fold_graph And_ltln True_ltln \<Phi> \<psi> \<Longrightarrow> w \<Turnstile>\<^sub>n \<psi> \<longleftrightarrow> (\<forall>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
>     by (rule fold_graph.induct) auto
>   then show ?thesis
>     using fold_graph_And\<^sub>n[OF \<open>finite \<Phi>\<close>] by simp
> qed
478,479c684,881
<   "w \<Turnstile>\<^sub>n Or\<^sub>n xs \<longleftrightarrow> (\<exists>x \<in> set xs. w \<Turnstile>\<^sub>n x)"
<   by (induction xs) auto
---
>   "finite \<Phi> \<Longrightarrow> w \<Turnstile>\<^sub>n Or\<^sub>n \<Phi> \<longleftrightarrow> (\<exists>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
> proof -
>   assume "finite \<Phi>"
>   have "\<And>\<psi>. fold_graph Or_ltln False_ltln \<Phi> \<psi> \<Longrightarrow> w \<Turnstile>\<^sub>n \<psi> \<longleftrightarrow> (\<exists>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
>     by (rule fold_graph.induct) auto
>   then show ?thesis
>     using fold_graph_Or\<^sub>n[OF \<open>finite \<Phi>\<close>] by simp
> qed
> 
> lemma And\<^sub>n_prop_semantics:
>   "finite \<Phi> \<Longrightarrow> \<A> \<Turnstile>\<^sub>P And\<^sub>n \<Phi> \<longleftrightarrow> (\<forall>\<phi> \<in> \<Phi>. \<A> \<Turnstile>\<^sub>P \<phi>)"
> proof -
>   assume "finite \<Phi>"
>   have "\<And>\<psi>. fold_graph And_ltln True_ltln \<Phi> \<psi> \<Longrightarrow> \<A> \<Turnstile>\<^sub>P \<psi> \<longleftrightarrow> (\<forall>\<phi> \<in> \<Phi>. \<A> \<Turnstile>\<^sub>P \<phi>)"
>     by (rule fold_graph.induct) auto
>   then show ?thesis
>     using fold_graph_And\<^sub>n[OF \<open>finite \<Phi>\<close>] by simp
> qed
> 
> lemma Or\<^sub>n_prop_semantics:
>   "finite \<Phi> \<Longrightarrow> \<A> \<Turnstile>\<^sub>P Or\<^sub>n \<Phi> \<longleftrightarrow> (\<exists>\<phi> \<in> \<Phi>. \<A> \<Turnstile>\<^sub>P \<phi>)"
> proof -
>   assume "finite \<Phi>"
>   have "\<And>\<psi>. fold_graph Or_ltln False_ltln \<Phi> \<psi> \<Longrightarrow> \<A> \<Turnstile>\<^sub>P \<psi> \<longleftrightarrow> (\<exists>\<phi> \<in> \<Phi>. \<A> \<Turnstile>\<^sub>P \<phi>)"
>     by (rule fold_graph.induct) auto
>   then show ?thesis
>     using fold_graph_Or\<^sub>n[OF \<open>finite \<Phi>\<close>] by simp
> qed
> 
> lemma Or\<^sub>n_And\<^sub>n_image_semantics:
>   assumes "finite \<A>" and "\<And>\<Phi>. \<Phi> \<in> \<A> \<Longrightarrow> finite \<Phi>"
>   shows "w \<Turnstile>\<^sub>n Or\<^sub>n (And\<^sub>n ` \<A>) \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. \<forall>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
> proof -
>   have "w \<Turnstile>\<^sub>n Or\<^sub>n (And\<^sub>n ` \<A>) \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. w \<Turnstile>\<^sub>n And\<^sub>n \<Phi>)"
>     using Or\<^sub>n_semantics assms by auto
>   then show ?thesis
>     using And\<^sub>n_semantics assms by fast
> qed
> 
> lemma Or\<^sub>n_And\<^sub>n_image_prop_semantics:
>   assumes "finite \<A>" and "\<And>\<Phi>. \<Phi> \<in> \<A> \<Longrightarrow> finite \<Phi>"
>   shows "\<I> \<Turnstile>\<^sub>P Or\<^sub>n (And\<^sub>n ` \<A>) \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. \<forall>\<phi> \<in> \<Phi>. \<I> \<Turnstile>\<^sub>P \<phi>)"
> proof -
>   have "\<I> \<Turnstile>\<^sub>P Or\<^sub>n (And\<^sub>n ` \<A>) \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. \<I> \<Turnstile>\<^sub>P And\<^sub>n \<Phi>)"
>     using Or\<^sub>n_prop_semantics assms by blast
>   then show ?thesis
>     using And\<^sub>n_prop_semantics assms by metis
> qed
> 
> 
> subsection \<open>DNF to LTL conversion\<close>
> 
> definition ltln_of_dnf :: "'a ltln fset set \<Rightarrow> 'a ltln"
> where
>   "ltln_of_dnf \<A> = Or\<^sub>n (And\<^sub>n ` fset ` \<A>)"
> 
> lemma ltln_of_dnf_semantics:
>   assumes "finite \<A>"
>   shows "w \<Turnstile>\<^sub>n ltln_of_dnf \<A> \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. \<forall>\<phi>. \<phi> |\<in>| \<Phi> \<longrightarrow> w \<Turnstile>\<^sub>n \<phi>)"
> proof -
>   have "finite (fset ` \<A>)"
>     using assms by blast
> 
>   then have "w \<Turnstile>\<^sub>n ltln_of_dnf \<A> \<longleftrightarrow> (\<exists>\<Phi> \<in> fset ` \<A>. \<forall>\<phi> \<in> \<Phi>. w \<Turnstile>\<^sub>n \<phi>)"
>     unfolding ltln_of_dnf_def using Or\<^sub>n_And\<^sub>n_image_semantics by fastforce
> 
>   then show ?thesis
>     by (metis image_iff notin_fset)
> qed
> 
> lemma ltln_of_dnf_prop_semantics:
>   assumes "finite \<A>"
>   shows "\<I> \<Turnstile>\<^sub>P ltln_of_dnf \<A> \<longleftrightarrow> (\<exists>\<Phi> \<in> \<A>. \<forall>\<phi>. \<phi> |\<in>| \<Phi> \<longrightarrow> \<I> \<Turnstile>\<^sub>P \<phi>)"
> proof -
>   have "finite (fset ` \<A>)"
>     using assms by blast
> 
>   then have "\<I> \<Turnstile>\<^sub>P ltln_of_dnf \<A> \<longleftrightarrow> (\<exists>\<Phi> \<in> fset ` \<A>. \<forall>\<phi> \<in> \<Phi>. \<I> \<Turnstile>\<^sub>P \<phi>)"
>     unfolding ltln_of_dnf_def using Or\<^sub>n_And\<^sub>n_image_prop_semantics by fastforce
> 
>   then show ?thesis
>     by (metis image_iff notin_fset)
> qed
> 
> lemma ltln_of_dnf_prop_equiv:
>   "ltln_of_dnf (min_dnf \<phi>) \<sim>\<^sub>P \<phi>"
>   unfolding ltl_prop_equiv_def
> proof
>   fix \<A>
>   have "\<A> \<Turnstile>\<^sub>P ltln_of_dnf (min_dnf \<phi>) \<longleftrightarrow> (\<exists>\<Phi> \<in> min_dnf \<phi>. \<forall>\<phi>. \<phi> |\<in>| \<Phi> \<longrightarrow> \<A> \<Turnstile>\<^sub>P \<phi>)"
>     using ltln_of_dnf_prop_semantics min_dnf_finite by metis
>   also have "\<dots> \<longleftrightarrow> (\<exists>\<Phi> \<in> min_dnf \<phi>. fset \<Phi> \<subseteq> \<A>)"
>     by (metis min_dnf_prop_atoms prop_atoms_entailment_iff notin_fset subset_eq)
>   also have "\<dots> \<longleftrightarrow> \<A> \<Turnstile>\<^sub>P \<phi>"
>     using min_dnf_iff_prop_assignment_subset by blast
>   finally show "\<A> \<Turnstile>\<^sub>P ltln_of_dnf (min_dnf \<phi>) = \<A> \<Turnstile>\<^sub>P \<phi>" .
> qed
> 
> lemma min_dnf_ltln_of_dnf[simp]:
>   "min_dnf (ltln_of_dnf (min_dnf \<phi>)) = min_dnf \<phi>"
>   using ltl_prop_equiv_min_dnf ltln_of_dnf_prop_equiv by blast
> 
> 
> subsection \<open>Substitution in DNF formulas\<close>
> 
> definition subst_clause :: "'a ltln fset \<Rightarrow> ('a ltln \<rightharpoonup> 'a ltln) \<Rightarrow> 'a ltln fset set"
> where
>   "subst_clause \<Phi> m = \<Otimes>\<^sub>m {min_dnf (subst \<phi> m) | \<phi>. \<phi> \<in> fset \<Phi>}"
> 
> definition subst_dnf :: "'a ltln fset set \<Rightarrow> ('a ltln \<rightharpoonup> 'a ltln) \<Rightarrow> 'a ltln fset set"
> where
>   "subst_dnf \<A> m = (\<Union>\<Phi> \<in> \<A>. subst_clause \<Phi> m)"
> 
> lemma subst_clause_empty[simp]:
>   "subst_clause {||} m = {{||}}"
>   by (simp add: subst_clause_def)
> 
> lemma subst_dnf_empty[simp]:
>   "subst_dnf {} m = {}"
>   by (simp add: subst_dnf_def)
> 
> lemma subst_clause_inner_finite:
>   "finite {min_dnf (subst \<phi> m) | \<phi>. \<phi> \<in> \<Phi>}" if "finite \<Phi>"
>   using that by simp
> 
> lemma subst_clause_finite:
>   "finite (subst_clause \<Phi> m)"
>   unfolding subst_clause_def
>   by (auto intro: min_dnf_finite min_product_set_finite)
> 
> lemma subst_dnf_finite:
>   "finite \<A> \<Longrightarrow> finite (subst_dnf \<A> m)"
>   unfolding subst_dnf_def using subst_clause_finite by blast
> 
> lemma subst_dnf_mono:
>   "\<A> \<subseteq> \<B> \<Longrightarrow> subst_dnf \<A> m \<subseteq> subst_dnf \<B> m"
>   unfolding subst_dnf_def by blast
> 
> lemma subst_clause_min_set[simp]:
>   "min_set (subst_clause \<Phi> m) = subst_clause \<Phi> m"
>   unfolding subst_clause_def by simp
> 
> lemma subst_clause_finsert[simp]:
>   "subst_clause (finsert \<phi> \<Phi>) m = (min_dnf (subst \<phi> m)) \<otimes>\<^sub>m (subst_clause \<Phi> m)"
> proof -
>   have "{min_dnf (subst \<psi> m) | \<psi>. \<psi> \<in> fset (finsert \<phi> \<Phi>)}
>     = insert (min_dnf (subst \<phi> m)) {min_dnf (subst \<psi> m) | \<psi>. \<psi> \<in> fset \<Phi>}"
>     by auto
> 
>   then show ?thesis
>     by (simp add: subst_clause_def)
> qed
> 
> lemma subst_clause_funion[simp]:
>   "subst_clause (\<Phi> |\<union>| \<Psi>) m = (subst_clause \<Phi> m) \<otimes>\<^sub>m (subst_clause \<Psi> m)"
> proof (induction \<Psi>)
>   case (insert x F)
>   then show ?case
>     using min_product_set_thms.fun_left_comm by fastforce
> qed simp
> 
> 
> text \<open>For the proof of correctness, we redefine the @{const product} operator on lists.\<close>
> 
> definition list_product :: "'a list set \<Rightarrow> 'a list set \<Rightarrow> 'a list set" (infixl "\<otimes>\<^sub>l" 65)
> where
>   "A \<otimes>\<^sub>l B = {a @ b | a b. a \<in> A \<and> b \<in> B}"
> 
> lemma list_product_fset_of_list[simp]:
>   "fset_of_list ` (A \<otimes>\<^sub>l B) = (fset_of_list ` A) \<otimes> (fset_of_list ` B)"
>   unfolding list_product_def product_def image_def by fastforce
> 
> lemma list_product_finite:
>   "finite A \<Longrightarrow> finite B \<Longrightarrow> finite (A \<otimes>\<^sub>l B)"
>   unfolding list_product_def by (simp add: finite_image_set2)
> 
> lemma list_product_iff:
>   "x \<in> A \<otimes>\<^sub>l B \<longleftrightarrow> (\<exists>a b. a \<in> A \<and> b \<in> B \<and> x = a @ b)"
>   unfolding list_product_def by blast
> 
> lemma list_product_assoc[simp]:
>   "A \<otimes>\<^sub>l (B \<otimes>\<^sub>l C) = A \<otimes>\<^sub>l B \<otimes>\<^sub>l C"
>   unfolding set_eq_iff list_product_iff by fastforce
> 
> 
> text \<open>Furthermore, we introduct DNFs where the clauses are represented as lists.\<close>
> 
> fun list_dnf :: "'a ltln \<Rightarrow> 'a ltln list set"
> where
>   "list_dnf true\<^sub>n = {[]}"
> | "list_dnf false\<^sub>n = {}"
> | "list_dnf (\<phi> and\<^sub>n \<psi>) = (list_dnf \<phi>) \<otimes>\<^sub>l (list_dnf \<psi>)"
> | "list_dnf (\<phi> or\<^sub>n \<psi>) = (list_dnf \<phi>) \<union> (list_dnf \<psi>)"
> | "list_dnf \<phi> = {[\<phi>]}"
> 
> definition list_dnf_to_dnf :: "'a list set \<Rightarrow> 'a fset set"
> where
>   "list_dnf_to_dnf X = fset_of_list ` X"
481,487c883,1090
< lemma And\<^sub>n_prop_entailment:
<   "\<A> \<Turnstile>\<^sub>P And\<^sub>n xs \<longleftrightarrow> (\<forall>x \<in> set xs. \<A> \<Turnstile>\<^sub>P x)"
<   by (induction xs) auto
< 
< lemma Or\<^sub>n_prop_entailment:
<   "\<A> \<Turnstile>\<^sub>P Or\<^sub>n xs \<longleftrightarrow> (\<exists>x \<in> set xs. \<A> \<Turnstile>\<^sub>P x)"
<   by (induction xs) auto
---
> lemma list_dnf_to_dnf_list_dnf[simp]:
>   "list_dnf_to_dnf (list_dnf \<phi>) = dnf \<phi>"
>   by (induction \<phi>) (simp_all add: list_dnf_to_dnf_def image_Un)
> 
> lemma list_dnf_finite:
>   "finite (list_dnf \<phi>)"
>   by (induction \<phi>) (simp_all add: list_product_finite)
> 
> 
> text \<open>We use this to redefine @{const subst_clause} and @{const subst_dnf} on list DNFs.\<close>
> 
> definition subst_clause' :: "'a ltln list \<Rightarrow> ('a ltln \<rightharpoonup> 'a ltln) \<Rightarrow> 'a ltln list set"
> where
>   "subst_clause' \<Phi> m = fold (\<lambda>\<phi> acc. acc \<otimes>\<^sub>l list_dnf (subst \<phi> m)) \<Phi> {[]}"
> 
> definition subst_dnf' :: "'a ltln list set \<Rightarrow> ('a ltln \<rightharpoonup> 'a ltln) \<Rightarrow> 'a ltln list set"
> where
>   "subst_dnf' \<A> m = (\<Union>\<Phi> \<in> \<A>. subst_clause' \<Phi> m)"
> 
> lemma subst_clause'_finite:
>   "finite (subst_clause' \<Phi> m)"
>   by (induction \<Phi> rule: rev_induct) (simp_all add: subst_clause'_def list_dnf_finite list_product_finite)
> 
> lemma subst_clause'_nil[simp]:
>   "subst_clause' [] m = {[]}"
>   by (simp add: subst_clause'_def)
> 
> lemma subst_clause'_cons[simp]:
>   "subst_clause' (xs @ [x]) m = subst_clause' xs m \<otimes>\<^sub>l list_dnf (subst x m)"
>   by (simp add: subst_clause'_def)
> 
> lemma subst_clause'_append[simp]:
>   "subst_clause' (A @ B) m = subst_clause' A m \<otimes>\<^sub>l subst_clause' B m"
> proof (induction B rule: rev_induct)
>   case (snoc x xs)
>   then show ?case
>     by simp (metis append_assoc subst_clause'_cons)
> qed(simp add: list_product_def)
> 
> 
> lemma subst_dnf'_iff:
>   "x \<in> subst_dnf' A m \<longleftrightarrow> (\<exists>\<Phi> \<in> A. x \<in> subst_clause' \<Phi> m)"
>   by (simp add: subst_dnf'_def)
> 
> lemma subst_dnf'_product:
>   "subst_dnf' (A \<otimes>\<^sub>l B) m = (subst_dnf' A m) \<otimes>\<^sub>l (subst_dnf' B m)" (is "?lhs = ?rhs")
> proof (unfold set_eq_iff, safe)
>   fix x
>   assume "x \<in> ?lhs"
> 
>   then obtain \<Phi> where "\<Phi> \<in> A \<otimes>\<^sub>l B" and "x \<in> subst_clause' \<Phi> m"
>     unfolding subst_dnf'_iff by blast
> 
>   then obtain a b where "a \<in> A" and "b \<in> B" and "\<Phi> = a @ b"
>     unfolding list_product_def by blast
> 
>   then have "x \<in> (subst_clause' a m) \<otimes>\<^sub>l (subst_clause' b m)"
>     using \<open>x \<in> subst_clause' \<Phi> m\<close> by simp
> 
>   then obtain a' b' where "a' \<in> subst_clause' a m" and "b' \<in> subst_clause' b m" and "x = a' @ b'"
>     unfolding list_product_iff by blast
> 
>   then have "a' \<in> subst_dnf' A m" and "b' \<in> subst_dnf' B m"
>     unfolding subst_dnf'_iff using \<open>a \<in> A\<close> \<open>b \<in> B\<close> by auto
> 
>   then have "\<exists>a\<in>subst_dnf' A m. \<exists>b\<in>subst_dnf' B m. x = a @ b"
>     using \<open>x = a' @ b'\<close> by blast
> 
>   then show "x \<in> ?rhs"
>     unfolding list_product_iff by blast
> next
>   fix x
>   assume "x \<in> ?rhs"
> 
>   then obtain a b where "a \<in> subst_dnf' A m" and "b \<in> subst_dnf' B m" and "x = a @ b"
>     unfolding list_product_iff by blast
> 
>   then obtain a' b' where "a' \<in> A" and "b' \<in> B" and a: "a \<in> subst_clause' a' m" and b: "b \<in> subst_clause' b' m"
>     unfolding subst_dnf'_iff by blast
> 
>   then have "x \<in> (subst_clause' a' m) \<otimes>\<^sub>l (subst_clause' b' m)"
>     unfolding list_product_iff using \<open>x = a @ b\<close> by blast
> 
>   moreover
> 
>   have "a' @ b' \<in> A \<otimes>\<^sub>l B"
>     unfolding list_product_iff using \<open>a' \<in> A\<close> \<open>b' \<in> B\<close> by blast
> 
>   ultimately show "x \<in> ?lhs"
>     unfolding subst_dnf'_iff by force
> qed
> 
> lemma subst_dnf'_list_dnf:
>   "subst_dnf' (list_dnf \<phi>) m = list_dnf (subst \<phi> m)"
> proof (induction \<phi>)
>   case (And_ltln \<phi>1 \<phi>2)
>   then show ?case
>     by (simp add: subst_dnf'_product)
> qed (simp_all add: subst_dnf'_def subst_clause'_def list_product_def)
> 
> 
> lemma min_set_Union:
>   "finite X \<Longrightarrow> min_set (\<Union> (min_set ` X)) = min_set (\<Union> X)" for X :: "'a fset set set"
>   by (induction X rule: finite_induct) (force, metis Sup_insert image_insert min_set_min_union min_union_def)
> 
> lemma min_set_Union_image:
>   "finite X \<Longrightarrow> min_set (\<Union>x \<in> X. min_set (f x)) = min_set (\<Union>x \<in> X. f x)" for f :: "'b \<Rightarrow> 'a fset set"
> proof -
>   assume "finite X"
> 
>   then have *: "finite (f ` X)" by auto
> 
>   with min_set_Union show ?thesis
>     unfolding image_image by fastforce
> qed
> 
> lemma subst_clause_fset_of_list:
>   "subst_clause (fset_of_list \<Phi>) m = min_set (list_dnf_to_dnf (subst_clause' \<Phi> m))"
>   unfolding list_dnf_to_dnf_def subst_clause'_def
> proof (induction \<Phi> rule: rev_induct)
>   case (snoc x xs)
>   then show ?case
>     by simp (metis (no_types, lifting) dnf_min_set list_dnf_to_dnf_def list_dnf_to_dnf_list_dnf min_product_comm min_product_def min_set_min_product(1))
> qed simp
> 
> lemma min_set_list_dnf_to_dnf_subst_dnf':
>   "finite X \<Longrightarrow> min_set (list_dnf_to_dnf (subst_dnf' X m)) = min_set (subst_dnf (list_dnf_to_dnf X) m)"
>   by (simp add: subst_dnf'_def subst_dnf_def subst_clause_fset_of_list list_dnf_to_dnf_def min_set_Union_image image_Union)
> 
> lemma subst_dnf_dnf:
>   "min_set (subst_dnf (dnf \<phi>) m) = min_dnf (subst \<phi> m)"
>   unfolding dnf_min_set
>   unfolding list_dnf_to_dnf_list_dnf[symmetric]
>   unfolding subst_dnf'_list_dnf[symmetric]
>   unfolding min_set_list_dnf_to_dnf_subst_dnf'[OF list_dnf_finite]
>   by simp
> 
> 
> text \<open>This is almost the lemma we need. However, we need to show that the same holds for @{term "min_dnf \<phi>"}, too.\<close>
> 
> lemma fold_product:
>   "Finite_Set.fold (\<lambda>x. (\<otimes>) {{|x|}}) {{||}} (fset x) = {x}"
>   by (induction x) (simp_all add: notin_fset, simp add: product_singleton_singleton)
> 
> lemma fold_union:
>   "Finite_Set.fold (\<lambda>x. (\<union>) {x}) {} (fset x) = fset x"
>   by (induction x) (simp_all add: notin_fset comp_fun_idem.fold_insert_idem comp_fun_idem_insert)
> 
> lemma fold_union_fold_product:
>   assumes "finite X" and "\<And>\<Psi> \<psi>. \<Psi> \<in> X \<Longrightarrow> \<psi> \<in> fset \<Psi> \<Longrightarrow> dnf \<psi> = {{|\<psi>|}}"
>   shows "Finite_Set.fold (\<lambda>x. (\<union>) (Finite_Set.fold (\<lambda>\<phi>. (\<otimes>) (dnf \<phi>)) {{||}} (fset x))) {} X = X" (is "?lhs = X")
> proof -
>   from assms have "?lhs = Finite_Set.fold (\<lambda>x. (\<union>) (Finite_Set.fold (\<lambda>\<phi>. (\<otimes>) {{|\<phi>|}}) {{||}} (fset x))) {} X"
>   proof (induction X rule: finite_induct)
>     case (insert \<Phi> X)
> 
>     from insert.prems have 1: "\<And>\<Psi> \<psi>. \<lbrakk>\<Psi> \<in> X; \<psi> \<in> fset \<Psi>\<rbrakk> \<Longrightarrow> dnf \<psi> = {{|\<psi>|}}"
>       by force
> 
>     from insert.prems have "Finite_Set.fold (\<lambda>\<phi>. (\<otimes>) (dnf \<phi>)) {{||}} (fset \<Phi>) = Finite_Set.fold (\<lambda>\<phi>. (\<otimes>) {{|\<phi>|}}) {{||}} (fset \<Phi>)"
>       by (induction \<Phi>) (force simp: notin_fset)+
> 
>     with insert 1 show ?case
>       by simp
>   qed simp
> 
>   with \<open>finite X\<close> show ?thesis
>     unfolding fold_product by (metis fset_to_fset fold_union)
> qed
> 
> lemma dnf_ltln_of_dnf_min_dnf:
>   "dnf (ltln_of_dnf (min_dnf \<phi>)) = min_dnf \<phi>"
> proof -
>   have 1: "finite (And\<^sub>n ` fset ` min_dnf \<phi>)"
>     using min_dnf_finite by blast
> 
>   have 2: "inj_on And\<^sub>n (fset ` min_dnf \<phi>)"
>     by (metis (mono_tags, lifting) And\<^sub>n_inj f_inv_into_f fset inj_onI inj_on_contraD)
> 
>   have 3: "inj_on fset (min_dnf \<phi>)"
>     by (meson fset_inject inj_onI)
> 
>   show ?thesis
>     unfolding ltln_of_dnf_def
>     unfolding Or\<^sub>n_dnf[OF 1]
>     unfolding fold_image[OF 2]
>     unfolding fold_image[OF 3]
>     unfolding comp_def
>     unfolding And\<^sub>n_dnf[OF finite_fset]
>     by (metis fold_union_fold_product min_dnf_finite min_dnf_atoms_dnf)
> qed
> 
> lemma min_dnf_subst:
>   "min_set (subst_dnf (min_dnf \<phi>) m) = min_dnf (subst \<phi> m)" (is "?lhs = ?rhs")
> proof -
>   let ?\<phi>' = "ltln_of_dnf (min_dnf \<phi>)"
> 
>   have "?lhs = min_set (subst_dnf (dnf ?\<phi>') m)"
>     unfolding dnf_ltln_of_dnf_min_dnf ..
> 
>   also have "\<dots> = min_dnf (subst ?\<phi>' m)"
>     unfolding subst_dnf_dnf ..
> 
>   also have "\<dots> = min_dnf (subst \<phi> m)"
>     using ltl_prop_equiv_min_dnf ltln_of_dnf_prop_equiv subst_respects_ltl_prop_entailment(2) by blast
> 
>   finally show ?thesis .
> qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL/Equivalence_Relations.thy ../../AFPs/afp-2020/thys/LTL/Equivalence_Relations.thy
43d42
< 
62d60
< 
112d109
< 
160d156
< 
199d194
< 
268d262
< 
386a381,394
> lemma prop_atoms_notin[simp]:
>   "true\<^sub>n \<notin> prop_atoms \<phi>"
>   "false\<^sub>n \<notin> prop_atoms \<phi>"
>   "\<phi>\<^sub>1 and\<^sub>n \<phi>\<^sub>2 \<notin> prop_atoms \<phi>"
>   "\<phi>\<^sub>1 or\<^sub>n \<phi>\<^sub>2 \<notin> prop_atoms \<phi>"
>   by (induction \<phi>) auto
> 
> lemma nested_prop_atoms_notin[simp]:
>   "true\<^sub>n \<notin> nested_prop_atoms \<phi>"
>   "false\<^sub>n \<notin> nested_prop_atoms \<phi>"
>   "\<phi>\<^sub>1 and\<^sub>n \<phi>\<^sub>2 \<notin> nested_prop_atoms \<phi>"
>   "\<phi>\<^sub>1 or\<^sub>n \<phi>\<^sub>2 \<notin> nested_prop_atoms \<phi>"
>   by (induction \<phi>) auto
> 
395c403,407
< lemma prop_atoms_entailment:
---
> lemma prop_atoms_entailment_iff:
>   "\<phi> \<in> prop_atoms \<psi> \<Longrightarrow> \<A> \<Turnstile>\<^sub>P \<phi> \<longleftrightarrow> \<phi> \<in> \<A>"
>   by (induction \<phi>) auto
> 
> lemma prop_atoms_entailment_inter:
399c411
< lemma nested_prop_atoms_entailment:
---
> lemma nested_prop_atoms_entailment_inter:
417c429
<     by (simp add: prop_atoms_entailment ltl_prop_equiv_def)
---
>     by (simp add: prop_atoms_entailment_inter ltl_prop_equiv_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL/LTL.thy ../../AFPs/afp-2020/thys/LTL/LTL.thy
376a377,381
> lemma semantics_ltln_ite_simps[simp]:
>   "w \<Turnstile>\<^sub>n (if P then true\<^sub>n else false\<^sub>n) = P"
>   "w \<Turnstile>\<^sub>n (if P then false\<^sub>n else true\<^sub>n) = (\<not>P)"
>   by simp_all
> 
718,719c723,724
<   "w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<phi>) \<Longrightarrow> suffix i w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<phi>)"
<   by simp
---
>   "suffix i w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<psi>) \<longleftrightarrow> w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<psi>)"
>   by auto (metis ab_semigroup_add_class.add_ac(1) add.left_commute)
722,724c727,728
<   "w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<phi>) \<Longrightarrow> suffix i w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<phi>)"
<   by (auto simp: algebra_simps)
< 
---
>   "suffix i w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<psi>) \<longleftrightarrow> w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<psi>)"
>   by (auto simp: algebra_simps) (metis add.commute add.left_commute)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL/Rewriting.thy ../../AFPs/afp-2020/thys/LTL/Rewriting.thy
87c87
< definition mk_next_pow ("X\<^sub>n'")
---
> definition mk_next_pow ("X\<^sub>n''")
==========
LTL_Master_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/code/hoa.sml ../../AFPs/afp-2020/thys/LTL_Master_Theorem/code/hoa.sml
83c83
<       ^ "Acceptance: " ^ serialize_acceptance (acceptingei aut) ^ "\n"
---
>       ^ "Acceptance: " ^ serialize_acceptance (conditionei aut) ^ "\n"
118c118
<       ^ serialize_state_labels (acceptingei aut) (#1 (List.hd state)) ^ "\n"
---
>       ^ serialize_state_labels (conditionei aut) (#1 (List.hd state)) ^ "\n"
129c129
<       integer_of_nat (#1 y)) (List.rev (sort_transitions (transei aut)))
---
>       integer_of_nat (#1 y)) (List.rev (sort_transitions (transitionei aut)))
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/code/ltl_to_dra_cli.sml ../../AFPs/afp-2020/thys/LTL_Master_Theorem/code/ltl_to_dra_cli.sml
15,16c15,17
<     val phi = LtlParser.compile_from_string (hd (CommandLine.arguments ())) handle LtlParser.LtlError msg => (println_err ("LTL Error: " ^ msg); usage (); e ())
<     val aut = LTL.ltlc_to_draei_literals phi
---
>     val input = case CommandLine.arguments () of [] => valOf (TextIO.inputLine TextIO.stdIn) | x :: _ => x
>     val phi = LtlParser.compile_from_string input handle LtlParser.LtlError msg => (println_err ("LTL Error: " ^ msg); usage (); e ())
>     val aut = LTL.ltlc_to_draei_literals LTL.PropUnfold phi
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/Code_Export.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Code_Export.thy
10c10
<   "LTL_to_DRA/DRA_Implementation"
---
>   "LTL_to_DRA/DRA_Instantiation"
15c15
< subsection \<open>LTL to DRA\<close>
---
> subsection \<open>Hashing Sets\<close>
17,19c17,18
< lemma dgba_degen_code [code]:
<   "DGBA.degen A = dba (DGBA.alphabet A) (DGBA.initial A, 0) (DGBA.dexecute A) (DGBA.daccepting A)"
<   by (metis DGBA.degen_def DGBA.degen_simps(2) dba.sel(2))
---
> global_interpretation comp_fun_commute "plus o cube o hashcode :: ('a :: hashable) \<Rightarrow> hashcode \<Rightarrow> hashcode"
>   by unfold_locales (auto simp: cube_def)
21,23c20,34
< lemma dgca_degen_code [code]:
<   "DGCA.degen A = dca (DGCA.alphabet A) (DGCA.initial A, 0) (DGCA.dexecute A) (DGCA.drejecting A)"
<   by (metis DGCA.degen_def DGCA.degen_simps(2) dca.sel(2))
---
> lemma [code]:
>   "hashcode (set xs) = fold (plus o cube o hashcode) (remdups xs) (uint32_of_nat (length (remdups xs)))"
>   by (simp add: fold_set_fold_remdups length_remdups_card_conv)
> 
> lemma [code]:
>   "hashcode (abs_ltln\<^sub>P \<phi>) = hashcode (min_dnf \<phi>)"
>   by simp
> 
> lemma min_dnf_rep_abs[simp]:
>   "min_dnf (Unf (rep_ltln\<^sub>Q (abs_ltln\<^sub>Q \<phi>))) = min_dnf (Unf \<phi>)"
>   using Quotient3_ltln\<^sub>Q ltl_prop_equiv_min_dnf ltl_prop_unfold_equiv_def rep_abs_rsp by fastforce
> 
> lemma [code]:
>   "hashcode (abs_ltln\<^sub>Q \<phi>) = hashcode (min_dnf (Unf \<phi>))"
>   by simp
25d35
< export_code ltlc_to_draei checking
26a37
> subsection \<open>LTL to DRA\<close>
28,30c39,45
< declare ltl_to_dra.af_letter\<^sub>F_lifted_semantics [code]
< declare ltl_to_dra.af_letter\<^sub>G_lifted_semantics [code]
< declare ltl_to_dra.af_letter\<^sub>\<nu>_lifted_semantics [code]
---
> declare ltl_to_dra\<^sub>P.af_letter\<^sub>F_lifted_semantics [code]
> declare ltl_to_dra\<^sub>P.af_letter\<^sub>G_lifted_semantics [code]
> declare ltl_to_dra\<^sub>P.af_letter\<^sub>\<nu>_lifted_semantics [code]
> 
> declare ltl_to_dra\<^sub>Q.af_letter\<^sub>F_lifted_semantics [code]
> declare ltl_to_dra\<^sub>Q.af_letter\<^sub>G_lifted_semantics [code]
> declare ltl_to_dra\<^sub>Q.af_letter\<^sub>\<nu>_lifted_semantics [code]
36c51
< definition ltlc_to_draei_literals :: "String.literal ltlc \<Rightarrow> (String.literal set, nat) draei"
---
> definition ltlc_to_draei_literals :: "equiv \<Rightarrow> String.literal ltlc \<Rightarrow> (String.literal set, nat) draei"
44,45c59,60
< export_code True_ltlc Iff_ltlc ltlc_to_draei_literals
<   alphabetei initialei transei acceptingei
---
> export_code True_ltlc Iff_ltlc ltlc_to_draei_literals Prop PropUnfold
>   alphabetei initialei transitionei conditionei
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/Logical_Characterization/Advice.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization/Advice.thy
2a3
>     Author:   Salomon Sickert
80a82,116
> lemma GF_advice_monotone:
>   "X \<subseteq> Y \<Longrightarrow> w \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<nu> \<Longrightarrow> w \<Turnstile>\<^sub>n \<phi>[Y]\<^sub>\<nu>"
> proof (induction \<phi> arbitrary: w)
>   case (Until_ltln \<phi> \<psi>)
>   then show ?case
>     by (cases "\<phi> U\<^sub>n \<psi> \<in> X") (simp_all, blast)
> next
>   case (Release_ltln \<phi> \<psi>)
>   then show ?case by (simp, blast)
> next
>   case (WeakUntil_ltln \<phi> \<psi>)
>   then show ?case by (simp, blast)
> next
>   case (StrongRelease_ltln \<phi> \<psi>)
>   then show ?case
>     by (cases "\<phi> M\<^sub>n \<psi> \<in> X") (simp_all, blast)
> qed auto
> 
> lemma FG_advice_monotone:
>   "X \<subseteq> Y \<Longrightarrow> w \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<mu> \<Longrightarrow> w \<Turnstile>\<^sub>n \<phi>[Y]\<^sub>\<mu>"
> proof (induction \<phi> arbitrary: w)
>   case (Until_ltln \<phi> \<psi>)
>   then show ?case by (simp, blast)
> next
>   case (Release_ltln \<phi> \<psi>)
>   then show ?case
>     by (cases "\<phi> R\<^sub>n \<psi> \<in> X") (auto, blast)
> next
>   case (WeakUntil_ltln \<phi> \<psi>)
>   then show ?case
>     by (cases "\<phi> W\<^sub>n \<psi> \<in> X") (auto, blast)
> next
>   case (StrongRelease_ltln \<phi> \<psi>)
>   then show ?case by (simp, blast)
> qed auto
81a118,126
> lemma GF_advice_ite_simps[simp]:
>   "(if P then true\<^sub>n else false\<^sub>n)[X]\<^sub>\<nu> = (if P then true\<^sub>n else false\<^sub>n)"
>   "(if P then false\<^sub>n else true\<^sub>n)[X]\<^sub>\<nu> = (if P then false\<^sub>n else true\<^sub>n)"
>   by simp_all
> 
> lemma FG_advice_ite_simps[simp]:
>   "(if P then true\<^sub>n else false\<^sub>n)[Y]\<^sub>\<mu> = (if P then true\<^sub>n else false\<^sub>n)"
>   "(if P then false\<^sub>n else true\<^sub>n)[Y]\<^sub>\<mu> = (if P then false\<^sub>n else true\<^sub>n)"
>   by simp_all
118a164,171
> lemma nested_prop_atoms\<^sub>\<nu>_subset:
>   "nested_prop_atoms \<phi> \<subseteq> nested_prop_atoms \<psi> \<Longrightarrow> nested_prop_atoms\<^sub>\<nu> \<phi> X \<subseteq> nested_prop_atoms\<^sub>\<nu> \<psi> X"
>   unfolding nested_prop_atoms\<^sub>\<nu>_def by blast
> 
> lemma nested_prop_atoms\<^sub>\<mu>_subset:
>   "nested_prop_atoms \<phi> \<subseteq> nested_prop_atoms \<psi> \<Longrightarrow> nested_prop_atoms\<^sub>\<mu> \<phi> Y \<subseteq> nested_prop_atoms\<^sub>\<mu> \<psi> Y"
>   unfolding nested_prop_atoms\<^sub>\<mu>_def by blast
> 
447c500
< subsection \<open>Advice functions and the after function\<close>
---
> subsection \<open>Advice Functions and the ``after'' Function\<close>
484a538,573
> lemma FG_advice_af_letter:
>   "w \<Turnstile>\<^sub>n (af_letter \<phi> x)[Y]\<^sub>\<mu> \<Longrightarrow> (x ## w) \<Turnstile>\<^sub>n \<phi>[Y]\<^sub>\<mu>"
> proof (induction \<phi>)
>   case (Prop_ltln a)
>   then show ?case
>     using semantics_ltln.simps(3) by fastforce
> next
>   case (Until_ltln \<phi>1 \<phi>2)
>   then show ?case
>     unfolding af_letter.simps FG_advice.simps semantics_ltln.simps(5,6)
>     using af_letter_build apply (cases "w \<Turnstile>\<^sub>n af_letter \<phi>2 x[Y]\<^sub>\<mu>") apply force
>     by (metis af_letter.simps(8) semantics_ltln.simps(5) semantics_ltln.simps(6))
> next
>   case (Release_ltln \<phi>1 \<phi>2)
>   then show ?case
>     apply (cases "\<phi>1 R\<^sub>n \<phi>2 \<in> Y")
>     apply simp
>     unfolding af_letter.simps FG_advice.simps semantics_ltln.simps(5,6)
>     using af_letter_build  apply (cases "w \<Turnstile>\<^sub>n af_letter \<phi>1 x[Y]\<^sub>\<mu>") apply force
>     by (metis (full_types) af_letter.simps(11) semantics_ltln.simps(5) semantics_ltln.simps(6))
> next
>   case (WeakUntil_ltln \<phi>1 \<phi>2)
>   then show ?case
>     apply (cases "\<phi>1 W\<^sub>n \<phi>2 \<in> Y")
>     apply simp
>     unfolding af_letter.simps FG_advice.simps semantics_ltln.simps(5,6)
>     using af_letter_build  apply (cases "w \<Turnstile>\<^sub>n af_letter \<phi>2 x[Y]\<^sub>\<mu>") apply force
>     by (metis (full_types) af_letter.simps(8) semantics_ltln.simps(5) semantics_ltln.simps(6))
> next
>   case (StrongRelease_ltln \<phi>1 \<phi>2)
>   then show ?case
>     unfolding af_letter.simps FG_advice.simps semantics_ltln.simps(5,6)
>     using af_letter_build apply (cases "w \<Turnstile>\<^sub>n af_letter \<phi>1 x[Y]\<^sub>\<mu>") apply force
>     by (metis af_letter.simps(11) semantics_ltln.simps(5) semantics_ltln.simps(6))
> qed auto
> 
488a578,945
> lemma FG_advice_af:
>   "w' \<Turnstile>\<^sub>n (af \<phi> w)[X]\<^sub>\<mu> \<Longrightarrow> (w \<frown> w') \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<mu>"
>   by (induction w arbitrary: \<phi>) (simp, insert FG_advice_af_letter, fastforce)
> 
> lemma GF_advice_af_2:
>   "w \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<nu> \<Longrightarrow> suffix i w \<Turnstile>\<^sub>n (af \<phi> (prefix i w))[X]\<^sub>\<nu>"
>   using GF_advice_af by force
> 
> lemma FG_advice_af_2:
>   "suffix i w \<Turnstile>\<^sub>n (af \<phi> (prefix i w))[X]\<^sub>\<mu> \<Longrightarrow> w \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<mu>"
>   using FG_advice_af by force
> 
> (* TODO move to Omega_Words_Fun.thy ?? *)
> lemma prefix_suffix_subsequence: "prefix i (suffix j w) = (w [j \<rightarrow> i + j])"
>   by (simp add: add.commute)
> 
> text \<open>We show this generic lemma to prove the following theorems:\<close>
> 
> lemma GF_advice_sync:
>   fixes index :: "nat \<Rightarrow> nat"
>   fixes formula :: "nat \<Rightarrow> 'a ltln"
>   assumes "\<And>i. i < n \<Longrightarrow> \<exists>j. suffix ((index i) + j) w \<Turnstile>\<^sub>n af (formula i) (w [index i \<rightarrow> (index i) + j])[X]\<^sub>\<nu>"
>   shows "\<exists>k. (\<forall>i < n. k \<ge> index i \<and> suffix k w \<Turnstile>\<^sub>n af (formula i) (w [index i \<rightarrow> k])[X]\<^sub>\<nu>)"
>   using assms
> proof (induction n)
>   case (Suc n)
> 
>   obtain k1 where leq1: "\<And>i. i < n \<Longrightarrow> k1 \<ge> index i"
>     and suffix1: "\<And>i. i < n \<Longrightarrow> suffix k1 w \<Turnstile>\<^sub>n af (formula i) (w [(index i) \<rightarrow> k1])[X]\<^sub>\<nu>"
>     using Suc less_SucI by blast
> 
>   obtain k2 where leq2: "k2 \<ge> index n"
>     and suffix2: "suffix k2 w \<Turnstile>\<^sub>n af (formula n) (w [index n \<rightarrow> k2])[X]\<^sub>\<nu>"
>     using le_add1 Suc.prems by blast
> 
>   define k where "k \<equiv> k1 + k2"
> 
>   have "\<And>i. i < Suc n \<Longrightarrow> k \<ge> index i"
>     unfolding k_def by (metis leq1 leq2 less_SucE trans_le_add1 trans_le_add2)
> 
>   moreover
> 
>   {
>     have "\<And>i. i < n \<Longrightarrow> suffix k w \<Turnstile>\<^sub>n af (formula i) (w [(index i) \<rightarrow> k])[X]\<^sub>\<nu>"
>       unfolding k_def
>       by (metis GF_advice_af_2[OF suffix1, unfolded suffix_suffix prefix_suffix_subsequence] af_subsequence_append leq1 add.commute le_add1)
> 
>     moreover
> 
>     have "suffix k w \<Turnstile>\<^sub>n af (formula n) (w [index n \<rightarrow> k])[X]\<^sub>\<nu>"
>       unfolding k_def
>       by (metis GF_advice_af_2[OF suffix2, unfolded suffix_suffix prefix_suffix_subsequence] af_subsequence_append leq2 add.commute le_add1)
> 
>     ultimately
> 
>     have "\<And>i. i \<le> n \<Longrightarrow> suffix k w \<Turnstile>\<^sub>n af (formula i) (w [(index i) \<rightarrow> k])[X]\<^sub>\<nu>"
>       using nat_less_le by blast
>   }
> 
>   ultimately
> 
>   show ?case
>     by (meson less_Suc_eq_le)
> qed simp
> 
> lemma GF_advice_sync_and:
>   assumes "\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>"
>   assumes "\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<psi> (prefix i w)[X]\<^sub>\<nu>"
>   shows "\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu> \<and> suffix i w \<Turnstile>\<^sub>n af \<psi> (prefix i w)[X]\<^sub>\<nu>"
> proof -
>   let ?formula = "\<lambda>i :: nat. (if (i = 0) then \<phi> else \<psi>)"
> 
>   have assms: "\<And>i. i < 2 \<Longrightarrow> \<exists>j. suffix j w \<Turnstile>\<^sub>n af (?formula i) (w [0 \<rightarrow> j])[X]\<^sub>\<nu>"
>     using assms by simp
>   obtain k where k_def: "\<And>i :: nat. i < 2 \<Longrightarrow> suffix k w \<Turnstile>\<^sub>n af (if i = 0 then \<phi> else \<psi>) (prefix k w)[X]\<^sub>\<nu>"
>     using GF_advice_sync[of "2" "\<lambda>i. 0" w ?formula, simplified, OF assms, simplified] by blast
>   show ?thesis
>     using k_def[of 0] k_def[of 1] by auto
> qed
> 
> lemma GF_advice_sync_less:
>   assumes "\<And>i. i < n \<Longrightarrow> \<exists>j. suffix (i + j) w \<Turnstile>\<^sub>n af \<phi> (w [i \<rightarrow> j + i])[X]\<^sub>\<nu>"
>   assumes "\<exists>j. suffix (n + j) w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> j + n])[X]\<^sub>\<nu>"
>   shows "\<exists>k \<ge> n. (\<forall>j < n. suffix k w \<Turnstile>\<^sub>n af \<phi> (w [j \<rightarrow> k])[X]\<^sub>\<nu>) \<and> suffix k w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> k])[X]\<^sub>\<nu>"
> proof -
>   let ?index = "\<lambda>i. min i n"
>   let ?formula = "\<lambda>i. if (i < n) then \<phi> else \<psi>"
> 
>   {
>     fix i
>     assume "i < Suc n"
>     then have min_def: "min i n = i"
>       by simp
>     have "\<exists>j. suffix ((?index i) + j) w \<Turnstile>\<^sub>n af (?formula i) (w [?index i \<rightarrow> (?index i) + j])[X]\<^sub>\<nu>"
>       unfolding min_def
>       by (cases "i < n")
>          (metis (full_types) assms(1) add.commute, metis (full_types) assms(2) \<open>i < Suc n\<close> add.commute  less_SucE)
>   }
> 
>   then obtain k where leq: "(\<And>i. i < Suc n \<Longrightarrow> min i n \<le> k)"
>     and suffix: "\<And>i. i < Suc n \<Longrightarrow> suffix k w \<Turnstile>\<^sub>n af (if i < n then \<phi> else \<psi>) (w [min i n \<rightarrow> k])[X]\<^sub>\<nu>"
>     using GF_advice_sync[of "Suc n" ?index w ?formula X] by metis
> 
>   have "\<forall>j < n. suffix k w \<Turnstile>\<^sub>n af \<phi> (w [j \<rightarrow> k])[X]\<^sub>\<nu>"
>     using suffix by (metis (full_types) less_SucI min.strict_order_iff)
> 
>   moreover
> 
>   have "suffix k w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> k])[X]\<^sub>\<nu>"
>     using suffix[of n, simplified] by blast
> 
>   moreover
> 
>   have "k \<ge> n"
>     using leq by presburger
> 
>   ultimately
>   show ?thesis
>     by auto
> qed
> 
> lemma GF_advice_sync_lesseq:
>   assumes "\<And>i. i \<le> n \<Longrightarrow> \<exists>j. suffix (i + j) w \<Turnstile>\<^sub>n af \<phi> (w [i \<rightarrow> j + i])[X]\<^sub>\<nu>"
>   assumes "\<exists>j. suffix (n + j) w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> j + n])[X]\<^sub>\<nu>"
>   shows "\<exists>k \<ge> n. (\<forall>j \<le> n. suffix k w \<Turnstile>\<^sub>n af \<phi> (w [j \<rightarrow> k])[X]\<^sub>\<nu>) \<and> suffix k w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> k])[X]\<^sub>\<nu>"
> proof -
>   let ?index = "\<lambda>i. min i n"
>   let ?formula = "\<lambda>i. if (i \<le> n) then \<phi> else \<psi>"
> 
>   {
>     fix i
>     assume "i < Suc (Suc n)"
>     hence "\<exists>j. suffix ((?index i) + j) w \<Turnstile>\<^sub>n af (?formula i) (w [?index i \<rightarrow> (?index i) + j])[X]\<^sub>\<nu>"
>     proof (cases "i < Suc n")
>       case True
>       then have min_def: "min i n = i"
>         by simp
>       show ?thesis
>         unfolding min_def by (metis (full_types) assms(1) Suc_leI Suc_le_mono True add.commute)
>     next
>       case False
>       then have i_def: "i = Suc n"
>         using \<open>i < Suc (Suc n)\<close> less_antisym by blast
>       have min_def: "min i n = n"
>         unfolding i_def by simp
>       show ?thesis
>         using assms(2) False
>         by (simp add: min_def add.commute)
>     qed
>   }
> 
>   then obtain k where leq: "(\<And>i. i \<le> Suc n \<Longrightarrow> min i n \<le> k)"
>     and suffix: "\<And>i :: nat. i < Suc (Suc n) \<Longrightarrow> suffix k w \<Turnstile>\<^sub>n af (if i \<le> n then \<phi> else \<psi>) (w [min i n \<rightarrow> k])[X]\<^sub>\<nu>"
>     using GF_advice_sync[of "Suc (Suc n)" ?index w ?formula X]
>     by (metis (no_types, hide_lams) less_Suc_eq min_le_iff_disj)
> 
>   have "\<forall>j \<le> n. suffix k w \<Turnstile>\<^sub>n af \<phi> (w [j \<rightarrow> k])[X]\<^sub>\<nu>"
>     using suffix by (metis (full_types) le_SucI less_Suc_eq_le min.orderE)
> 
>   moreover
> 
>   have "suffix k w \<Turnstile>\<^sub>n af \<psi> (w [n \<rightarrow> k])[X]\<^sub>\<nu>"
>     using suffix[of "Suc n", simplified] by linarith
> 
>   moreover
> 
>   have "k \<ge> n"
>     using leq by presburger
> 
>   ultimately
>   show ?thesis
>     by auto
> qed
> 
> lemma af_subsequence_U_GF_advice:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [i \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   assumes "\<And>j. j < i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<phi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> U\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   then have A: "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [0 \<rightarrow> n]))[X]\<^sub>\<nu>)"
>     by blast
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF A, of 1] by simp
>   then show ?case
>     unfolding GF_advice.simps af_subsequence_U semantics_ltln.simps by blast
> next
>   case (Suc i)
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<phi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[OF zero_less_Suc, THEN GF_advice_af_2, unfolded suffix_suffix, of 1]
>     by simp
>   moreover
>   have B: "(Suc (n - 1)) = n"
>     using Suc by simp
>   note Suc.IH[of "n - 1" "suffix 1 w", unfolded suffix_suffix] Suc.prems
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> U\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono Suc_mono plus_1_eq_Suc subsequence_shift)
>   ultimately
>   show ?case
>     unfolding af_subsequence_U semantics_ltln.simps GF_advice.simps by blast
> qed
> 
> lemma af_subsequence_M_GF_advice:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n ((af \<phi> (w [i \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   assumes "\<And>j. j \<le> i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> M\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   then have A: "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [0 \<rightarrow> n]))[X]\<^sub>\<nu>)"
>     by blast
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF A, of 1] by simp
>   moreover
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<phi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF "0.prems"(2), of 1, unfolded suffix_suffix] by auto
>   ultimately
>   show ?case
>     unfolding af_subsequence_M GF_advice.simps semantics_ltln.simps by blast
> next
>   case (Suc i)
>   have "suffix 1 (suffix n w) \<Turnstile>\<^sub>n af (af \<psi> (prefix n w)) [suffix n w 0][X]\<^sub>\<nu>"
>     by (metis (no_types) GF_advice_af_2 Suc.prems(3) plus_1_eq_Suc subsequence_singleton suffix_0 suffix_suffix zero_le)
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[THEN GF_advice_af_2, unfolded suffix_suffix, of 1] by simp
>   moreover
>   have B: "(Suc (n - 1)) = n"
>     using Suc by simp
>   note Suc.IH[of _ "suffix 1 w", unfolded subsequence_shift suffix_suffix]
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> M\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono plus_1_eq_Suc Suc.prems)
>   ultimately
>   show ?case
>     unfolding af_subsequence_M semantics_ltln.simps GF_advice.simps by blast
> qed
> 
> lemma af_subsequence_R_GF_advice:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n ((af \<phi> (w [i \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   assumes "\<And>j. j \<le> i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> R\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   then have A: "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [0 \<rightarrow> n]))[X]\<^sub>\<nu>)"
>     by blast
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF A, of 1] by simp
>   moreover
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<phi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF "0.prems"(2), of 1, unfolded suffix_suffix] by auto
>   ultimately
>   show ?case
>     unfolding af_subsequence_R GF_advice.simps semantics_ltln.simps by blast
> next
>   case (Suc i)
>   have "suffix 1 (suffix n w) \<Turnstile>\<^sub>n af (af \<psi> (prefix n w)) [suffix n w 0][X]\<^sub>\<nu>"
>     by (metis (no_types) GF_advice_af_2 Suc.prems(3) plus_1_eq_Suc subsequence_singleton suffix_0 suffix_suffix zero_le)
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[THEN GF_advice_af_2, unfolded suffix_suffix, of 1] by simp
>   moreover
>   have B: "(Suc (n - 1)) = n"
>     using Suc by simp
>   note Suc.IH[of _ "suffix 1 w", unfolded subsequence_shift suffix_suffix]
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> R\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono plus_1_eq_Suc Suc.prems)
>   ultimately
>   show ?case
>     unfolding af_subsequence_R semantics_ltln.simps GF_advice.simps by blast
> qed
> 
> lemma af_subsequence_W_GF_advice:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [i \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   assumes "\<And>j. j < i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<phi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> W\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   then have A: "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [0 \<rightarrow> n]))[X]\<^sub>\<nu>)"
>     by blast
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF A, of 1] by simp
>   then show ?case
>     unfolding af_subsequence_W GF_advice.simps semantics_ltln.simps by blast
> next
>   case (Suc i)
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<phi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[OF zero_less_Suc, THEN GF_advice_af_2, unfolded suffix_suffix, of 1]
>     by simp
>   moreover
>   have B: "(Suc (n - 1)) = n"
>     using Suc by simp
>   note Suc.IH[of "n - 1" "suffix 1 w", unfolded suffix_suffix] Suc.prems
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> W\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono Suc_mono plus_1_eq_Suc subsequence_shift)
>   ultimately
>   show ?case
>     unfolding af_subsequence_W unfolding semantics_ltln.simps GF_advice.simps by simp
> qed
> 
> lemma af_subsequence_R_GF_advice_connect:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n af (\<phi> R\<^sub>n \<psi>) (w [i \<rightarrow> n])[X]\<^sub>\<nu>"
>   assumes "\<And>j. j \<le> i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> R\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   then have A: "suffix n w \<Turnstile>\<^sub>n ((af \<psi> (w [0 \<rightarrow> n]))[X]\<^sub>\<nu>)"
>     by blast
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF A, of 1] by simp
>   moreover
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> R\<^sub>n \<psi>) (w [0 \<rightarrow> Suc n]))[X]\<^sub>\<nu>"
>     using GF_advice_af_2[OF "0.prems"(2), of 1, unfolded suffix_suffix] by simp
>   ultimately
>   show ?case
>     unfolding af_subsequence_R GF_advice.simps semantics_ltln.simps by blast
> next
>   case (Suc i)
>   have "suffix 1 (suffix n w) \<Turnstile>\<^sub>n af (af \<psi> (prefix n w)) [suffix n w 0][X]\<^sub>\<nu>"
>     by (metis (no_types) GF_advice_af_2 Suc.prems(3) plus_1_eq_Suc subsequence_singleton suffix_0 suffix_suffix zero_le)
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<psi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[THEN GF_advice_af_2, unfolded suffix_suffix, of 1] by simp
>   moreover
>   have B: "(Suc (n - 1)) = n"
>     using Suc by simp
>   note Suc.IH[of _ "suffix 1 w", unfolded subsequence_shift suffix_suffix]
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> R\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono plus_1_eq_Suc Suc.prems)
>   ultimately
>   show ?case
>     unfolding af_subsequence_R semantics_ltln.simps GF_advice.simps by blast
> qed
> 
> lemma af_subsequence_W_GF_advice_connect:
>   assumes "i \<le> n"
>   assumes "suffix n w \<Turnstile>\<^sub>n af (\<phi> W\<^sub>n \<psi>) (w [i \<rightarrow> n])[X]\<^sub>\<nu>"
>   assumes "\<And>j. j < i \<Longrightarrow> suffix n w \<Turnstile>\<^sub>n ((af \<phi> (w [j \<rightarrow> n]))[X]\<^sub>\<nu>)"
>   shows "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> W\<^sub>n \<psi>) (prefix (Suc n) w))[X]\<^sub>\<nu>"
>   using assms
> proof (induction i arbitrary: w n)
>   case 0
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n af_letter (af (\<phi> W\<^sub>n \<psi>) (prefix n w)) (w n)[X]\<^sub>\<nu>"
>     by (simp add: "0.prems"(2) GF_advice_af_letter)
>   moreover
>   have "prefix (Suc n) w = prefix n w @ [w n]"
>     using subseq_to_Suc by blast
>   ultimately show ?case
>     by (metis (no_types) foldl.simps(1) foldl.simps(2) foldl_append)
> next
>   case (Suc i)
>   have "suffix (Suc n) w \<Turnstile>\<^sub>n (af \<phi> (prefix (Suc n) w))[X]\<^sub>\<nu>"
>     using Suc.prems(3)[OF zero_less_Suc, THEN GF_advice_af_2, unfolded suffix_suffix, of 1] by simp
>   moreover
>   have "n > 0" and B: "(Suc (n - 1)) = n"
>     using Suc by simp+
>   note Suc.IH[of "n - 1" "suffix 1 w", unfolded suffix_suffix] Suc.prems
>   then have "suffix (Suc n) w \<Turnstile>\<^sub>n (af (\<phi> W\<^sub>n \<psi>) (w [1 \<rightarrow> (Suc n)]))[X]\<^sub>\<nu>"
>     by (metis B One_nat_def Suc_le_mono Suc_mono plus_1_eq_Suc subsequence_shift)
>   ultimately
>   show ?case
>     unfolding af_subsequence_W unfolding semantics_ltln.simps GF_advice.simps by simp
> qed
528a986,988
> 
> subsection \<open>GF-advice with Equivalence Relations\<close>
> 
529a990,993
>   fixes
>     normalise :: "'a ltln \<Rightarrow> 'a ltln"
>   assumes
>     normalise_eq: "\<phi> \<sim> normalise \<phi>"
531c995,1000
<     GF_advice_congruent: "\<phi> \<sim> \<psi> \<Longrightarrow> \<phi>[X]\<^sub>\<nu> \<sim> \<psi>[X]\<^sub>\<nu>"
---
>     normalise_monotonic: "w \<Turnstile>\<^sub>n \<phi>[X]\<^sub>\<nu> \<Longrightarrow> w \<Turnstile>\<^sub>n (normalise \<phi>)[X]\<^sub>\<nu>"
>   assumes
>     normalise_eventually_equivalent:
>       "w \<Turnstile>\<^sub>n (normalise \<phi>)[X]\<^sub>\<nu> \<Longrightarrow> (\<exists>i. suffix i w \<Turnstile>\<^sub>n (af \<phi> (prefix i w))[X]\<^sub>\<nu>)"
>   assumes
>     GF_advice_congruent: "\<phi> \<sim> \<psi> \<Longrightarrow> (normalise \<phi>)[X]\<^sub>\<nu> \<sim> (normalise \<psi>)[X]\<^sub>\<nu>"
533a1003,1006
> lemma normalise_language_equivalent[simp]:
>   "w \<Turnstile>\<^sub>n normalise \<phi> \<longleftrightarrow> w \<Turnstile>\<^sub>n \<phi>"
>   using normalise_eq ltl_lang_equiv_def eq_implies_lang by blast
> 
536,537c1009,1010
< interpretation prop_GF_advice_compatible: GF_advice_congruent "(\<sim>\<^sub>P)"
<   by unfold_locales (simp add: GF_advice_prop_congruent(2))
---
> interpretation prop_GF_advice_compatible: GF_advice_congruent "(\<sim>\<^sub>P)" "id"
>   by unfold_locales (simp add: GF_advice_af GF_advice_prop_congruent(2))+
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/Logical_Characterization/After.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization/After.thy
9c9
< imports 
---
> imports
44a45,53
> lemma af_ite_simps[simp]:
>   "af (if P then true\<^sub>n else false\<^sub>n) w = (if P then true\<^sub>n else false\<^sub>n)"
>   "af (if P then false\<^sub>n else true\<^sub>n) w = (if P then false\<^sub>n else true\<^sub>n)"
>   by simp_all
> 
> lemma af_subsequence_append:
>   "i \<le> j \<Longrightarrow> j \<le> k \<Longrightarrow> af (af \<phi> (w [i \<rightarrow> j])) (w [j \<rightarrow> k]) = af \<phi> (w [i \<rightarrow> k])"
>   by (metis foldl_append le_Suc_ex map_append subsequence_def upt_add_eq_append)
> 
48a58,61
> lemma af_subsequence_U':
>   "af (\<phi> U\<^sub>n \<psi>) (a # xs) = (af \<psi> (a # xs)) or\<^sub>n ((af \<phi> (a # xs)) and\<^sub>n af (\<phi> U\<^sub>n \<psi>) xs)"
>   by (simp add: af_decompose)
> 
52a66,69
> lemma af_subsequence_R':
>   "af (\<phi> R\<^sub>n \<psi>) (a # xs) = (af \<psi> (a # xs)) and\<^sub>n ((af \<phi> (a # xs)) or\<^sub>n af (\<phi> R\<^sub>n \<psi>) xs)"
>   by (simp add: af_decompose)
> 
56a74,77
> lemma af_subsequence_W':
>   "af (\<phi> W\<^sub>n \<psi>) (a # xs) = (af \<psi> (a # xs)) or\<^sub>n ((af \<phi> (a # xs)) and\<^sub>n af (\<phi> W\<^sub>n \<psi>) xs)"
>   by (simp add: af_decompose)
> 
60a82,84
> lemma af_subsequence_M':
>   "af (\<phi> M\<^sub>n \<psi>) (a # xs) = (af \<psi> (a # xs)) and\<^sub>n ((af \<phi> (a # xs)) or\<^sub>n af (\<phi> M\<^sub>n \<psi>) xs)"
>   by (simp add: af_decompose)
Only in ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization: Extra_Equivalence_Relations.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/Logical_Characterization/Master_Theorem.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization/Master_Theorem.thy
305,308c305,309
<     (\<exists>X \<subseteq> subformulas\<^sub>\<mu> \<phi>. \<exists>Y \<subseteq> subformulas\<^sub>\<nu> \<phi>.
<       (\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>)
<       \<and> (\<forall>\<psi> \<in> X. w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<psi>[Y]\<^sub>\<mu>))
<       \<and> (\<forall>\<psi> \<in> Y. w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<psi>[X]\<^sub>\<nu>)))"
---
>     (\<exists>X \<subseteq> subformulas\<^sub>\<mu> \<phi>.
>       (\<exists>Y \<subseteq> subformulas\<^sub>\<nu> \<phi>.
>         (\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>)
>         \<and> (\<forall>\<psi> \<in> X. w \<Turnstile>\<^sub>n G\<^sub>n (F\<^sub>n \<psi>[Y]\<^sub>\<mu>))
>         \<and> (\<forall>\<psi> \<in> Y. w \<Turnstile>\<^sub>n F\<^sub>n (G\<^sub>n \<psi>[X]\<^sub>\<nu>))))"
Only in ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization: Restricted_Master_Theorem.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/Logical_Characterization/Syntactic_Fragments_and_Stability.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/Logical_Characterization/Syntactic_Fragments_and_Stability.thy
84,88d83
< abbreviation "ltln_U \<equiv> {\<phi> U\<^sub>n \<psi> | \<phi> \<psi>. True}"
< abbreviation "ltln_R \<equiv> {\<phi> R\<^sub>n \<psi> | \<phi> \<psi>. True}"
< abbreviation "ltln_W \<equiv> {\<phi> W\<^sub>n \<psi> | \<phi> \<psi>. True}"
< abbreviation "ltln_M \<equiv> {\<phi> M\<^sub>n \<psi> | \<phi> \<psi>. True}"
< 
90c85
<   "subformulas\<^sub>\<mu> \<phi> = subfrmlsn \<phi> \<inter> (ltln_U \<union> ltln_M)"
---
>   "subformulas\<^sub>\<mu> \<phi> = {\<psi> \<in> subfrmlsn \<phi>. \<exists>\<psi>\<^sub>1 \<psi>\<^sub>2. \<psi> = \<psi>\<^sub>1 U\<^sub>n \<psi>\<^sub>2 \<or> \<psi> = \<psi>\<^sub>1 M\<^sub>n \<psi>\<^sub>2}"
94c89
<   "subformulas\<^sub>\<nu> \<phi> = subfrmlsn \<phi> \<inter> (ltln_R \<union> ltln_W)"
---
>   "subformulas\<^sub>\<nu> \<phi> = {\<psi> \<in> subfrmlsn \<phi>. \<exists>\<psi>\<^sub>1 \<psi>\<^sub>2. \<psi> = \<psi>\<^sub>1 R\<^sub>n \<psi>\<^sub>2 \<or> \<psi> = \<psi>\<^sub>1 W\<^sub>n \<psi>\<^sub>2}"
143,249d137
< text \<open>The $\mu$- and $\nu$-subformulas as lists:\<close>
< 
< fun subformulas\<^sub>\<mu>_list :: "'a ltln \<Rightarrow> 'a ltln list"
< where
<   "subformulas\<^sub>\<mu>_list (\<phi> and\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
< | "subformulas\<^sub>\<mu>_list (\<phi> or\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
< | "subformulas\<^sub>\<mu>_list (X\<^sub>n \<phi>) = subformulas\<^sub>\<mu>_list \<phi>"
< | "subformulas\<^sub>\<mu>_list (\<phi> U\<^sub>n \<psi>) = List.insert (\<phi> U\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>))"
< | "subformulas\<^sub>\<mu>_list (\<phi> R\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
< | "subformulas\<^sub>\<mu>_list (\<phi> W\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
< | "subformulas\<^sub>\<mu>_list (\<phi> M\<^sub>n \<psi>) = List.insert (\<phi> M\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>))"
< | "subformulas\<^sub>\<mu>_list _ = []"
< 
< fun subformulas\<^sub>\<nu>_list :: "'a ltln \<Rightarrow> 'a ltln list"
< where
<   "subformulas\<^sub>\<nu>_list (\<phi> and\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
< | "subformulas\<^sub>\<nu>_list (\<phi> or\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
< | "subformulas\<^sub>\<nu>_list (X\<^sub>n \<phi>) = subformulas\<^sub>\<nu>_list \<phi>"
< | "subformulas\<^sub>\<nu>_list (\<phi> U\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
< | "subformulas\<^sub>\<nu>_list (\<phi> R\<^sub>n \<psi>) = List.insert (\<phi> R\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>))"
< | "subformulas\<^sub>\<nu>_list (\<phi> W\<^sub>n \<psi>) = List.insert (\<phi> W\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>))"
< | "subformulas\<^sub>\<nu>_list (\<phi> M\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
< | "subformulas\<^sub>\<nu>_list _ = []"
< 
< lemma subformulas\<^sub>\<mu>_list_set:
<   "set (subformulas\<^sub>\<mu>_list \<phi>) = subformulas\<^sub>\<mu> \<phi>"
<   by (induction \<phi>) auto
< 
< lemma subformulas\<^sub>\<nu>_list_set:
<   "set (subformulas\<^sub>\<nu>_list \<phi>) = subformulas\<^sub>\<nu> \<phi>"
<   by (induction \<phi>) auto
< 
< lemma subformulas\<^sub>\<mu>_list_distinct:
<   "distinct (subformulas\<^sub>\<mu>_list \<phi>)"
<   by (induction \<phi>) auto
< 
< lemma subformulas\<^sub>\<nu>_list_distinct:
<   "distinct (subformulas\<^sub>\<nu>_list \<phi>)"
<   by (induction \<phi>) auto
< 
< lemma subformulas\<^sub>\<mu>_list_length:
<   "length (subformulas\<^sub>\<mu>_list \<phi>) = card (subformulas\<^sub>\<mu> \<phi>)"
<   by (metis subformulas\<^sub>\<mu>_list_set subformulas\<^sub>\<mu>_list_distinct distinct_card)
< 
< lemma subformulas\<^sub>\<nu>_list_length:
<   "length (subformulas\<^sub>\<nu>_list \<phi>) = card (subformulas\<^sub>\<nu> \<phi>)"
<   by (metis subformulas\<^sub>\<nu>_list_set subformulas\<^sub>\<nu>_list_distinct distinct_card)
< 
< 
< 
< subsection \<open>List of Advice Sets\<close>
< 
< definition advice_sets :: "'a ltln \<Rightarrow> ('a ltln list \<times> 'a ltln list) list"
< where
<   "advice_sets \<phi> = List.product (subseqs (subformulas\<^sub>\<mu>_list \<phi>)) (subseqs (subformulas\<^sub>\<nu>_list \<phi>))"
< 
< lemma subset_subseq:
<   "X \<subseteq> set ys \<longleftrightarrow> (\<exists>xs. X = set xs \<and> subseq xs ys)"
<   by (metis (no_types, lifting) Pow_iff image_iff in_set_subseqs subseqs_powset)
< 
< lemma subseqs_subformulas\<^sub>\<mu>_list:
<   "X \<subseteq> subformulas\<^sub>\<mu> \<phi> \<longleftrightarrow> (\<exists>xs. X = set xs \<and> xs \<in> set (subseqs (subformulas\<^sub>\<mu>_list \<phi>)))"
<   by (metis subset_subseq subformulas\<^sub>\<mu>_list_set in_set_subseqs)
< 
< lemma subseqs_subformulas\<^sub>\<nu>_list:
<   "Y \<subseteq> subformulas\<^sub>\<nu> \<phi> \<longleftrightarrow> (\<exists>ys. Y = set ys \<and> ys \<in> set (subseqs (subformulas\<^sub>\<nu>_list \<phi>)))"
<   by (metis subset_subseq subformulas\<^sub>\<nu>_list_set in_set_subseqs)
< 
< lemma advice_sets_subformulas:
<   "X \<subseteq> subformulas\<^sub>\<mu> \<phi> \<and> Y \<subseteq> subformulas\<^sub>\<nu> \<phi> \<longleftrightarrow> (\<exists>xs ys. X = set xs \<and> Y = set ys \<and> (xs, ys) \<in> set (advice_sets \<phi>))"
<   unfolding advice_sets_def set_product subseqs_subformulas\<^sub>\<mu>_list subseqs_subformulas\<^sub>\<nu>_list by blast
< 
< (* TODO add to HOL/List.thy *)
< lemma subseqs_not_empty:
<   "subseqs xs \<noteq> []"
<   by (metis empty_iff list.set(1) subseqs_refl)
< 
< (* TODO add to HOL/List.thy *)
< lemma product_not_empty:
<   "xs \<noteq> [] \<Longrightarrow> ys \<noteq> [] \<Longrightarrow> List.product xs ys \<noteq> []"
<   by (induction xs) simp_all
< 
< lemma advice_sets_not_empty:
<   "advice_sets \<phi> \<noteq> []"
<   unfolding advice_sets_def using subseqs_not_empty product_not_empty by blast
< 
< lemma advice_sets_length:
<   "length (advice_sets \<phi>) \<le> 2 ^ card (subfrmlsn \<phi>)"
<   unfolding advice_sets_def length_product length_subseqs subformulas\<^sub>\<mu>_list_length subformulas\<^sub>\<nu>_list_length power_add[symmetric]
<   by (metis Suc_1 card_mono lessI power_increasing_iff subformulas\<^sub>\<mu>\<^sub>\<nu>_card subformulas\<^sub>\<mu>\<^sub>\<nu>_subfrmlsn subfrmlsn_finite)
< 
< lemma advice_sets_element_length:
<   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> length xs \<le> card (subfrmlsn \<phi>)"
<   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> length ys \<le> card (subfrmlsn \<phi>)"
<   unfolding advice_sets_def set_product
<   by (metis SigmaD1 card_mono in_set_subseqs list_emb_length order_trans subformulas\<^sub>\<mu>_list_length subformulas\<^sub>\<mu>_subfrmlsn subfrmlsn_finite)
<      (metis SigmaD2 card_mono in_set_subseqs list_emb_length order_trans subformulas\<^sub>\<nu>_list_length subformulas\<^sub>\<nu>_subfrmlsn subfrmlsn_finite)
< 
< lemma advice_sets_element_subfrmlsn:
<   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> set xs \<subseteq> subformulas\<^sub>\<mu> \<phi>"
<   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> set ys \<subseteq> subformulas\<^sub>\<nu> \<phi>"
<   unfolding advice_sets_def set_product
<   by (meson SigmaD1 subseqs_subformulas\<^sub>\<mu>_list)
<      (meson SigmaD2 subseqs_subformulas\<^sub>\<nu>_list)
< 
< 
< 
383a272,288
> lemma \<mu>_stable_subfrmlsn:
>   "\<mu>_stable \<phi> w \<Longrightarrow> \<psi> \<in> subfrmlsn \<phi> \<Longrightarrow> \<mu>_stable \<psi> w"
> proof -
>   assume a1: "\<psi> \<in> subfrmlsn \<phi>" and a2: "\<mu>_stable \<phi> w"
>   have "subformulas\<^sub>\<mu> \<psi> \<subseteq> subformulas\<^sub>\<mu> \<phi>"
>     using a1 by (simp add: subformulas\<^sub>\<mu>_subset)
>   moreover
>   have "\<G>\<F> \<phi> w = \<F> \<phi> w"
>     using a2 by (meson \<mu>_stable_def)
>   ultimately show ?thesis
>     by (metis (no_types) Un_commute \<F>_semantics' \<G>\<F>_semantics' \<mu>_stable_def inf_left_commute inf_sup_absorb sup.orderE)
> qed
> 
> lemma \<mu>_stable_suffix:
>   "\<mu>_stable \<phi> w \<Longrightarrow> \<mu>_stable \<phi> (suffix i w)"
>   by (metis \<F>_suffix \<G>\<F>_\<F>_subset \<G>\<F>_suffix \<mu>_stable_def subset_antisym)
> 
514a420,546
> 
> lemma \<nu>_stable_subfrmlsn:
>   "\<nu>_stable \<phi> w \<Longrightarrow> \<psi> \<in> subfrmlsn \<phi> \<Longrightarrow> \<nu>_stable \<psi> w"
> proof -
>   assume a1: "\<psi> \<in> subfrmlsn \<phi>" and a2: "\<nu>_stable \<phi> w"
>   have "subformulas\<^sub>\<nu> \<psi> \<subseteq> subformulas\<^sub>\<nu> \<phi>"
>     using a1 by (simp add: subformulas\<^sub>\<nu>_subset)
>   moreover
>   have "\<F>\<G> \<phi> w = \<G> \<phi> w"
>     using a2 by (meson \<nu>_stable_def)
>   ultimately show ?thesis
>     by (metis (no_types) Un_commute \<G>_semantics' \<F>\<G>_semantics' \<nu>_stable_def inf_left_commute inf_sup_absorb sup.orderE)
> qed
> 
> lemma \<nu>_stable_suffix:
>   "\<nu>_stable \<phi> w \<Longrightarrow> \<nu>_stable \<phi> (suffix i w)"
>   by (metis \<F>\<G>_suffix \<G>_\<F>\<G>_subset \<G>_suffix \<nu>_stable_def antisym_conv)
> 
> 
> subsection \<open>Definitions with Lists for Code Export\<close>
> 
> text \<open>The \<open>\<mu>\<close>- and \<open>\<nu>\<close>-subformulas as lists:\<close>
> 
> fun subformulas\<^sub>\<mu>_list :: "'a ltln \<Rightarrow> 'a ltln list"
> where
>   "subformulas\<^sub>\<mu>_list (\<phi> and\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
> | "subformulas\<^sub>\<mu>_list (\<phi> or\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
> | "subformulas\<^sub>\<mu>_list (X\<^sub>n \<phi>) = subformulas\<^sub>\<mu>_list \<phi>"
> | "subformulas\<^sub>\<mu>_list (\<phi> U\<^sub>n \<psi>) = List.insert (\<phi> U\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>))"
> | "subformulas\<^sub>\<mu>_list (\<phi> R\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
> | "subformulas\<^sub>\<mu>_list (\<phi> W\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>)"
> | "subformulas\<^sub>\<mu>_list (\<phi> M\<^sub>n \<psi>) = List.insert (\<phi> M\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<mu>_list \<phi>) (subformulas\<^sub>\<mu>_list \<psi>))"
> | "subformulas\<^sub>\<mu>_list _ = []"
> 
> fun subformulas\<^sub>\<nu>_list :: "'a ltln \<Rightarrow> 'a ltln list"
> where
>   "subformulas\<^sub>\<nu>_list (\<phi> and\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
> | "subformulas\<^sub>\<nu>_list (\<phi> or\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
> | "subformulas\<^sub>\<nu>_list (X\<^sub>n \<phi>) = subformulas\<^sub>\<nu>_list \<phi>"
> | "subformulas\<^sub>\<nu>_list (\<phi> U\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
> | "subformulas\<^sub>\<nu>_list (\<phi> R\<^sub>n \<psi>) = List.insert (\<phi> R\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>))"
> | "subformulas\<^sub>\<nu>_list (\<phi> W\<^sub>n \<psi>) = List.insert (\<phi> W\<^sub>n \<psi>) (List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>))"
> | "subformulas\<^sub>\<nu>_list (\<phi> M\<^sub>n \<psi>) = List.union (subformulas\<^sub>\<nu>_list \<phi>) (subformulas\<^sub>\<nu>_list \<psi>)"
> | "subformulas\<^sub>\<nu>_list _ = []"
> 
> lemma subformulas\<^sub>\<mu>_list_set:
>   "set (subformulas\<^sub>\<mu>_list \<phi>) = subformulas\<^sub>\<mu> \<phi>"
>   by (induction \<phi>) auto
> 
> lemma subformulas\<^sub>\<nu>_list_set:
>   "set (subformulas\<^sub>\<nu>_list \<phi>) = subformulas\<^sub>\<nu> \<phi>"
>   by (induction \<phi>) auto
> 
> lemma subformulas\<^sub>\<mu>_list_distinct:
>   "distinct (subformulas\<^sub>\<mu>_list \<phi>)"
>   by (induction \<phi>) auto
> 
> lemma subformulas\<^sub>\<nu>_list_distinct:
>   "distinct (subformulas\<^sub>\<nu>_list \<phi>)"
>   by (induction \<phi>) auto
> 
> lemma subformulas\<^sub>\<mu>_list_length:
>   "length (subformulas\<^sub>\<mu>_list \<phi>) = card (subformulas\<^sub>\<mu> \<phi>)"
>   by (metis subformulas\<^sub>\<mu>_list_set subformulas\<^sub>\<mu>_list_distinct distinct_card)
> 
> lemma subformulas\<^sub>\<nu>_list_length:
>   "length (subformulas\<^sub>\<nu>_list \<phi>) = card (subformulas\<^sub>\<nu> \<phi>)"
>   by (metis subformulas\<^sub>\<nu>_list_set subformulas\<^sub>\<nu>_list_distinct distinct_card)
> 
> 
> text \<open>
>   We define the list of advice sets as the product of all subsequences
>   of the \<open>\<mu>\<close>- and \<open>\<nu>\<close>-subformulas of a formula.
> \<close>
> 
> definition advice_sets :: "'a ltln \<Rightarrow> ('a ltln list \<times> 'a ltln list) list"
> where
>   "advice_sets \<phi> = List.product (subseqs (subformulas\<^sub>\<mu>_list \<phi>)) (subseqs (subformulas\<^sub>\<nu>_list \<phi>))"
> 
> lemma subset_subseq:
>   "X \<subseteq> set ys \<longleftrightarrow> (\<exists>xs. X = set xs \<and> subseq xs ys)"
>   by (metis (no_types, lifting) Pow_iff image_iff in_set_subseqs subseqs_powset)
> 
> lemma subseqs_subformulas\<^sub>\<mu>_list:
>   "X \<subseteq> subformulas\<^sub>\<mu> \<phi> \<longleftrightarrow> (\<exists>xs. X = set xs \<and> xs \<in> set (subseqs (subformulas\<^sub>\<mu>_list \<phi>)))"
>   by (metis subset_subseq subformulas\<^sub>\<mu>_list_set in_set_subseqs)
> 
> lemma subseqs_subformulas\<^sub>\<nu>_list:
>   "Y \<subseteq> subformulas\<^sub>\<nu> \<phi> \<longleftrightarrow> (\<exists>ys. Y = set ys \<and> ys \<in> set (subseqs (subformulas\<^sub>\<nu>_list \<phi>)))"
>   by (metis subset_subseq subformulas\<^sub>\<nu>_list_set in_set_subseqs)
> 
> lemma advice_sets_subformulas:
>   "X \<subseteq> subformulas\<^sub>\<mu> \<phi> \<and> Y \<subseteq> subformulas\<^sub>\<nu> \<phi> \<longleftrightarrow> (\<exists>xs ys. X = set xs \<and> Y = set ys \<and> (xs, ys) \<in> set (advice_sets \<phi>))"
>   unfolding advice_sets_def set_product subseqs_subformulas\<^sub>\<mu>_list subseqs_subformulas\<^sub>\<nu>_list by blast
> 
> (* TODO add to HOL/List.thy *)
> lemma subseqs_not_empty:
>   "subseqs xs \<noteq> []"
>   by (metis empty_iff list.set(1) subseqs_refl)
> 
> (* TODO add to HOL/List.thy *)
> lemma product_not_empty:
>   "xs \<noteq> [] \<Longrightarrow> ys \<noteq> [] \<Longrightarrow> List.product xs ys \<noteq> []"
>   by (induction xs) simp_all
> 
> lemma advice_sets_not_empty:
>   "advice_sets \<phi> \<noteq> []"
>   unfolding advice_sets_def using subseqs_not_empty product_not_empty by blast
> 
> lemma advice_sets_length:
>   "length (advice_sets \<phi>) \<le> 2 ^ card (subfrmlsn \<phi>)"
>   unfolding advice_sets_def length_product length_subseqs subformulas\<^sub>\<mu>_list_length subformulas\<^sub>\<nu>_list_length power_add[symmetric]
>   by (metis Suc_1 card_mono lessI power_increasing_iff subformulas\<^sub>\<mu>\<^sub>\<nu>_card subformulas\<^sub>\<mu>\<^sub>\<nu>_subfrmlsn subfrmlsn_finite)
> 
> lemma advice_sets_element_length:
>   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> length xs \<le> card (subfrmlsn \<phi>)"
>   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> length ys \<le> card (subfrmlsn \<phi>)"
>   unfolding advice_sets_def set_product
>   by (metis SigmaD1 card_mono in_set_subseqs list_emb_length order_trans subformulas\<^sub>\<mu>_list_length subformulas\<^sub>\<mu>_subfrmlsn subfrmlsn_finite)
>      (metis SigmaD2 card_mono in_set_subseqs list_emb_length order_trans subformulas\<^sub>\<nu>_list_length subformulas\<^sub>\<nu>_subfrmlsn subfrmlsn_finite)
> 
> lemma advice_sets_element_subfrmlsn:
>   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> set xs \<subseteq> subformulas\<^sub>\<mu> \<phi>"
>   "(xs, ys) \<in> set (advice_sets \<phi>) \<Longrightarrow> set ys \<subseteq> subformulas\<^sub>\<nu> \<phi>"
>   unfolding advice_sets_def set_product
>   by (meson SigmaD1 subseqs_subformulas\<^sub>\<mu>_list)
>      (meson SigmaD2 subseqs_subformulas\<^sub>\<nu>_list)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Construction.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Construction.thy
14a15,16
>     "HOL-Library.Log_Nat"
> 
15a18
>     "../Logical_Characterization/Restricted_Master_Theorem"
25c28
< locale dra_construction = transition_functions eq + quotient eq Rep Abs
---
> locale dra_construction = transition_functions eq normalise + quotient eq Rep Abs
28a32,33
>     normalise :: "'a ltln \<Rightarrow> 'a ltln"
>   and
97,104d101
< lemma af\<^sub>F_lifted_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (\<up>af\<^sub>F \<phi> (Abs \<psi>)) \<subseteq>  {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
<   using af\<^sub>F_lifted_semantics af\<^sub>F_nested_prop_atoms by blast
< 
< lemma af\<^sub>G_lifted_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (\<up>af\<^sub>G \<phi> (Abs \<psi>)) \<subseteq>  {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
<   using af\<^sub>G_lifted_semantics af\<^sub>G_nested_prop_atoms by blast
< 
144,145c141
<   "DBA.run (dba UNIV p \<delta> \<alpha>) (to_stream w) p"
<   unfolding DBA.run_def by (rule transition_system.snth_run) fastforce
---
>   "DBA.run (dba UNIV p \<delta> \<alpha>) (to_stream w) p" unfolding dba.run_alt_def by simp
148,149c144
<   "DCA.run (dca UNIV p \<delta> \<alpha>) (to_stream w) p"
<   unfolding DCA.run_def by (rule transition_system.snth_run) fastforce
---
>   "DCA.run (dca UNIV p \<delta> \<alpha>) (to_stream w) p" unfolding dca.run_alt_def by simp
164c159
<     by (simp add: infs_snth \<AA>\<^sub>\<mu>_def DBA.succ_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)
---
>     by (simp add: infs_snth \<AA>\<^sub>\<mu>_def DBA.transition_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)
167,168c162
<     unfolding \<AA>\<^sub>\<mu>_def dba.initial_def dba.accepting_def
<     by (metis dba_run DBA.language DBA.language_elim dba.sel(2) dba.sel(4))
---
>     unfolding \<AA>\<^sub>\<mu>_def dba.initial_def dba.accepting_def by (auto simp: dba_run)
190c184
<     by (simp add: infs_snth \<AA>\<^sub>\<mu>_GF_def DBA.succ_def af\<^sub>F_lifted_semantics Abs_eq[symmetric] af_letter\<^sub>F_lifted_semantics)
---
>     by (simp add: infs_snth \<AA>\<^sub>\<mu>_GF_def DBA.transition_def af\<^sub>F_lifted_semantics Abs_eq[symmetric] af_letter\<^sub>F_lifted_semantics)
193,194c187
<     unfolding \<AA>\<^sub>\<mu>_GF_def dba.initial_def dba.accepting_def
<     by (metis dba_run DBA.language DBA.language_elim dba.sel(2) dba.sel(4))
---
>     unfolding \<AA>\<^sub>\<mu>_GF_def dba.initial_def dba.accepting_def by (auto simp: dba_run)
211,212c204,205
<   also have "\<dots> \<longleftrightarrow> \<not> infs (\<lambda>\<psi>. \<psi> = \<up>false\<^sub>n) (DCA.trace (\<AA>\<^sub>\<nu> \<phi>) (to_stream w) (Abs \<phi>))"
<     by (simp add: infs_snth \<AA>\<^sub>\<nu>_def DBA.succ_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)
---
>   also have "\<dots> \<longleftrightarrow> fins (\<lambda>\<psi>. \<psi> = \<up>false\<^sub>n) (DCA.trace (\<AA>\<^sub>\<nu> \<phi>) (to_stream w) (Abs \<phi>))"
>     by (simp add: infs_snth \<AA>\<^sub>\<nu>_def DBA.transition_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)
215,216c208
<     unfolding \<AA>\<^sub>\<nu>_def dca.initial_def dca.rejecting_def
<     by (metis dca_run DCA.language DCA.language_elim dca.sel(2) dca.sel(4))
---
>     unfolding \<AA>\<^sub>\<nu>_def dca.initial_def dca.rejecting_def by (auto simp: dca_run)
237,238c229,230
<   also have "\<dots> \<longleftrightarrow> \<not> infs (\<lambda>\<psi>. \<psi> = \<up>false\<^sub>n) (DCA.trace (\<AA>\<^sub>\<nu>_FG \<phi>) (to_stream w) (Abs (G\<^sub>n \<phi>)))"
<     by (simp add: infs_snth \<AA>\<^sub>\<nu>_FG_def DBA.succ_def af\<^sub>G_lifted_semantics Abs_eq[symmetric] af_letter\<^sub>G_lifted_semantics)
---
>   also have "\<dots> \<longleftrightarrow> fins (\<lambda>\<psi>. \<psi> = \<up>false\<^sub>n) (DCA.trace (\<AA>\<^sub>\<nu>_FG \<phi>) (to_stream w) (Abs (G\<^sub>n \<phi>)))"
>     by (simp add: infs_snth \<AA>\<^sub>\<nu>_FG_def DBA.transition_def af\<^sub>G_lifted_semantics Abs_eq[symmetric] af_letter\<^sub>G_lifted_semantics)
241,242c233
<     unfolding \<AA>\<^sub>\<nu>_FG_def dca.initial_def dca.rejecting_def
<     by (metis dca_run DCA.language DCA.language_elim dca.sel(2) dca.sel(4))
---
>     unfolding \<AA>\<^sub>\<nu>_FG_def dca.initial_def dca.rejecting_def by (auto simp: dca_run)
249,270d239
< lemma \<AA>\<^sub>\<mu>_nodes:
<   "DBA.nodes (\<AA>\<^sub>\<mu> \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
<   unfolding \<AA>\<^sub>\<mu>_def transition_system_initial.nodes_alt_def
<   using af_lifted_semantics af_nested_prop_atoms by fastforce
< 
< lemma \<AA>\<^sub>\<mu>_GF_nodes:
<   "DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
<   unfolding \<AA>\<^sub>\<mu>_GF_def DBA.nodes_def transition_system_initial.nodes_alt_def transition_system.reachable_alt_def
<   using af\<^sub>F_nested_prop_atoms[of "F\<^sub>n \<phi>"] by (auto simp: af\<^sub>F_lifted_semantics)
< 
< lemma \<AA>\<^sub>\<nu>_nodes:
<   "DCA.nodes (\<AA>\<^sub>\<nu> \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
<   unfolding \<AA>\<^sub>\<nu>_def transition_system_initial.nodes_alt_def
<   using af_lifted_semantics af_nested_prop_atoms by fastforce
< 
< lemma \<AA>\<^sub>\<nu>_FG_nodes:
<   "DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
<   unfolding \<AA>\<^sub>\<nu>_FG_def DCA.nodes_def transition_system_initial.nodes_alt_def transition_system.reachable_alt_def
<   using af\<^sub>G_nested_prop_atoms[of "G\<^sub>n \<phi>"] by (auto simp: af\<^sub>G_lifted_semantics)
< 
< 
< 
274c243
<   "\<CC> \<phi> X = dca UNIV (Abs \<phi>, Abs (\<phi>[X]\<^sub>\<nu>)) (\<up>afletter\<^sub>\<nu> X) (\<lambda>p. snd p = \<up>false\<^sub>n)"
---
>   "\<CC> \<phi> X = dca UNIV (Abs \<phi>, Abs ((normalise \<phi>)[X]\<^sub>\<nu>)) (\<up>afletter\<^sub>\<nu> X) (\<lambda>p. snd p = \<up>false\<^sub>n)"
281c250
<         \<longleftrightarrow> (\<exists>m. \<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n)"
---
>         \<longleftrightarrow> (\<exists>m. \<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n)"
284,285c253,254
<   also have "\<dots> \<longleftrightarrow> \<not> infs (\<lambda>p. snd p = \<up>false\<^sub>n) (DCA.trace (\<CC> \<phi> X) (to_stream w) (Abs \<phi>, Abs (\<phi>[X]\<^sub>\<nu>)))"
<     by(simp add: infs_snth \<CC>_def DCA.succ_def af\<^sub>\<nu>_lifted_semantics af_letter\<^sub>\<nu>_lifted_semantics Abs_eq)
---
>   also have "\<dots> \<longleftrightarrow> fins (\<lambda>p. snd p = \<up>false\<^sub>n) (DCA.trace (\<CC> \<phi> X) (to_stream w) (Abs \<phi>, Abs ((normalise \<phi>)[X]\<^sub>\<nu>)))"
>     by(simp add: infs_snth \<CC>_def DCA.transition_def af\<^sub>\<nu>_lifted_semantics af_letter\<^sub>\<nu>_lifted_semantics Abs_eq)
288c257
<     by (simp add: \<CC>_def dca.initial_def dca.rejecting_def DCA.language_def dca_run)
---
>     by (simp add: \<CC>_def dca.initial_def dca.rejecting_def dca.language_def dca_run)
295,303d263
< lemma \<CC>_nodes:
<   "DCA.nodes (\<CC> \<phi> X) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>} \<times> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
<   unfolding \<CC>_def DCA.nodes_def transition_system_initial.nodes_alt_def transition_system.reachable_alt_def
<   apply (auto simp add: af\<^sub>\<nu>_lifted_semantics af_letter\<^sub>\<nu>_lifted_semantics)
<   using af\<^sub>\<nu>_fst_nested_prop_atoms apply force
<   using GF_advice_nested_prop_atoms\<^sub>\<nu> af\<^sub>\<nu>_snd_nested_prop_atoms dra_construction_axioms by fastforce
< 
< 
< 
308c268
<   by (metis (mono_tags, lifting) Collect_cong DBA.language_def mem_Collect_eq to_stream_to_omega)
---
>   by (metis (mono_tags, lifting) Collect_cong dba.language_def mem_Collect_eq to_stream_to_omega)
312c272
<   by (metis (mono_tags, lifting) Collect_cong DCA.language_def mem_Collect_eq to_stream_to_omega)
---
>   by (metis (mono_tags, lifting) Collect_cong dca.language_def mem_Collect_eq to_stream_to_omega)
328c288
<   "\<AA>\<^sub>2 xs ys = dbail (map (\<lambda>\<psi>. \<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)) xs)"
---
>   "\<AA>\<^sub>2 xs ys = DBA_Combine.intersect_list (map (\<lambda>\<psi>. \<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)) xs)"
336c296
<   by (simp add: \<AA>\<^sub>2_def \<AA>\<^sub>\<mu>_GF_def dbail_def dbgail_def DGBA.degen_def)
---
>   by (simp add: \<AA>\<^sub>2_def \<AA>\<^sub>\<mu>_GF_def)
340c300
<   "\<AA>\<^sub>3 xs ys = dcail (map (\<lambda>\<psi>. \<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>)) ys)"
---
>   "\<AA>\<^sub>3 xs ys = DCA_Combine.intersect_list (map (\<lambda>\<psi>. \<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>)) ys)"
348c308
<   by (simp add: \<AA>\<^sub>3_def \<AA>\<^sub>\<nu>_FG_def dcail_def)
---
>   by (simp add: \<AA>\<^sub>3_def \<AA>\<^sub>\<nu>_FG_def)
351c311
< definition "\<AA>' \<phi> xs ys = dbcrai (\<AA>\<^sub>2 xs ys) (dcai (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys))"
---
> definition "\<AA>' \<phi> xs ys = intersect_bc (\<AA>\<^sub>2 xs ys) (DCA_Combine.intersect (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys))"
359c319
<   by (simp add: \<AA>'_def dbcrai_def dcai_def \<AA>\<^sub>1_alphabet \<AA>\<^sub>2_alphabet \<AA>\<^sub>3_alphabet)
---
>   by (simp add: \<AA>'_def \<AA>\<^sub>1_alphabet \<AA>\<^sub>2_alphabet \<AA>\<^sub>3_alphabet)
365c325,330
< definition "ltl_to_dra \<phi> = draul (map (\<lambda>(xs, ys). \<AA>' \<phi> xs ys) (advice_sets \<phi>))"
---
> text \<open>
>   This is the final constant constructing a deterministic Rabin automaton
>   using the pure version of the  @{thm master_theorem}.
> \<close>
> 
> definition "ltl_to_dra \<phi> = DRA_Combine.union_list (map (\<lambda>(xs, ys). \<AA>' \<phi> xs ys) (advice_sets \<phi>))"
370,372c335,340
<   have 1: "INTER (set (map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>))) dra.alphabet = UNION (set (map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>))) dra.alphabet"
<     by (induction "advice_sets \<phi>") (metis advice_sets_not_empty, simp add: \<AA>'_alphabet split_def advice_sets_not_empty)
< 
---
>   have "(\<Inter>(a, b)\<in>set (advice_sets \<phi>). dra.alphabet (\<AA>' \<phi> a b)) =
>     (\<Union>(a, b)\<in>set (advice_sets \<phi>). dra.alphabet (\<AA>' \<phi> a b))"
>     using advice_sets_not_empty by (simp add: \<AA>'_alphabet)
>   then have *: "DRA.language (DRA_Combine.union_list (map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>))) =
>     \<Union> (DRA.language ` set (map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>)))"
>     by (simp add: split_def)
380c348
<     unfolding ltl_to_dra_def draul_language[OF 1] by auto
---
>     using * by (auto simp add: ltl_to_dra_def)
385,386c353,382
<   by (auto simp: ltl_to_dra_def draul_def \<AA>'_alphabet split: prod.split)
<      (insert advice_sets_subformulas, blast)
---
>   by (auto simp: ltl_to_dra_def \<AA>'_alphabet)
> 
> 
> subsection \<open>A DRA for @{term "L(\<phi>)"} with Restricted Advice Sets\<close>
> 
> text \<open>
>   The following constant uses the @{thm master_theorem_restricted} to reduce
>   the size of the resulting automaton.
> \<close>
> 
> definition "ltl_to_dra_restricted \<phi> = DRA_Combine.union_list (map (\<lambda>(xs, ys). \<AA>' \<phi> xs ys) (restricted_advice_sets \<phi>))"
> 
> lemma ltl_to_dra_restricted_language:
>   "to_omega ` DRA.language (ltl_to_dra_restricted \<phi>) = language_ltln \<phi>"
> proof -
>   have "(\<Inter>(a, b)\<in>set (restricted_advice_sets \<phi>). dra.alphabet (\<AA>' \<phi> a b)) =
>     (\<Union>(a, b)\<in>set (restricted_advice_sets \<phi>). dra.alphabet (\<AA>' \<phi> a b))"
>     using restricted_advice_sets_not_empty by (simp add: \<AA>'_alphabet)
>   then have *: "DRA.language (DRA_Combine.union_list (map (\<lambda>(x, y). \<AA>' \<phi> x y) (restricted_advice_sets \<phi>))) =
>     \<Union> (DRA.language ` set (map (\<lambda>(x, y). \<AA>' \<phi> x y) (restricted_advice_sets \<phi>)))"
>     by (simp add: split_def)
>   have "language_ltln \<phi> = \<Union> {(L\<^sub>1 \<phi> X \<inter> L\<^sub>2 X Y \<inter> L\<^sub>3 X Y) | X Y. X \<subseteq> subformulas\<^sub>\<mu> \<phi> \<inter> restricted_subformulas \<phi> \<and> Y \<subseteq> subformulas\<^sub>\<nu> \<phi> \<inter> restricted_subformulas \<phi>}"
>     unfolding master_theorem_restricted_language by auto
>   also have "\<dots> = \<Union> {L\<^sub>1 \<phi> (set xs) \<inter> L\<^sub>2 (set xs) (set ys) \<inter> L\<^sub>3 (set xs) (set ys) | xs ys. (xs, ys) \<in> set (restricted_advice_sets \<phi>)}"
>     unfolding restricted_advice_sets_subformulas by (metis (no_types, lifting))
>   also have "\<dots> = \<Union> {to_omega ` DRA.language (\<AA>' \<phi> xs ys) | xs ys. (xs, ys) \<in> set (restricted_advice_sets \<phi>)}"
>     by (simp add: \<AA>'_language)
>   finally show ?thesis
>     using * by (auto simp add: ltl_to_dra_restricted_def)
> qed
387a384,386
> lemma ltl_to_dra_restricted_alphabet:
>   "alphabet (ltl_to_dra_restricted \<phi>) = UNIV"
>   by (auto simp: ltl_to_dra_restricted_def \<AA>'_alphabet)
390c389,395
< subsection \<open>Setting the Alphabet of a DRA\<close>
---
> subsection \<open>A DRA for @{term "L(\<phi>)"} with a finite alphabet\<close>
> 
> text \<open>
>   Until this point, we use @{term UNIV} as the alphabet in all places.
>   To explore the automaton, however, we need a way to fix the alphabet
>   to some finite set.
> \<close>
394c399
<   "dra_set_alphabet \<AA> \<Sigma> = dra \<Sigma> (initial \<AA>) (succ \<AA>) (accepting \<AA>)"
---
>   "dra_set_alphabet \<AA> \<Sigma> = dra \<Sigma> (initial \<AA>) (transition \<AA>) (condition \<AA>)"
398c403
<   by (auto simp add: dra_set_alphabet_def language_def set_eq_iff DRA.run_alt_def)
---
>   by (auto simp add: dra_set_alphabet_def dra.language_def set_eq_iff dra.run_alt_def streams_iff_sset)
406,408c411,412
<   unfolding dra_set_alphabet_def DRA.nodes_def transition_system_initial.nodes_alt_def transition_system.reachable_alt_def
<   by auto (metis DRA.path_alt_def DRA.path_def dra.sel(1) dra.sel(3) subset_trans)
< 
---
>   unfolding dra_set_alphabet_def dra.nodes_alt_def dra.reachable_alt_def dra.path_alt_def
>   by auto
411,413c415
< subsection \<open>A DRA for @{term "L(\<phi>)"} with a finite alphabet\<close>
< 
< definition "ltl_to_dra_alphabet \<phi> Ap = dra_set_alphabet (ltl_to_dra \<phi>) (Pow Ap)"
---
> definition "ltl_to_dra_alphabet \<phi> Ap = dra_set_alphabet (ltl_to_dra_restricted \<phi>) (Pow Ap)"
421,422c423,424
<   have 1: "Pow Ap \<subseteq> alphabet (ltl_to_dra \<phi>)"
<     unfolding ltl_to_dra_alphabet by simp
---
>   have 1: "Pow Ap \<subseteq> alphabet (ltl_to_dra_restricted \<phi>)"
>     unfolding ltl_to_dra_restricted_alphabet by simp
426c428
<     by (simp add: ltl_to_dra_language sset_range) force
---
>     by (simp add: ltl_to_dra_restricted_language sset_range) force
434c436
<   "DRA.nodes (ltl_to_dra_alphabet \<phi> Ap) \<subseteq> DRA.nodes (ltl_to_dra \<phi>)"
---
>   "DRA.nodes (ltl_to_dra_alphabet \<phi> Ap) \<subseteq> DRA.nodes (ltl_to_dra_restricted \<phi>)"
436c438,902
<   by (rule dra_set_alphabet_nodes) (simp add: ltl_to_dra_alphabet)
---
>   by (rule dra_set_alphabet_nodes) (simp add: ltl_to_dra_restricted_alphabet)
> 
> end
> 
> 
> subsection \<open>Verified Bounds for Number of Nodes\<close>
> 
> text \<open>
>   Using two additional assumptions, we can show a double-exponential size bound
>   for the constructed automaton.
> \<close>
> 
> (* TODO add to HOL/Groups_List.thy *)
> lemma list_prod_mono:
>   "f \<le> g \<Longrightarrow> (\<Prod>x\<leftarrow>xs. f x) \<le> (\<Prod>x\<leftarrow>xs. g x)" for f g :: "'a \<Rightarrow> nat"
>   by (induction xs) (auto simp: le_funD mult_le_mono)
> 
> (* TODO add to HOL/Groups_List.thy *)
> lemma list_prod_const:
>   "(\<And>x. x \<in> set xs \<Longrightarrow> f x \<le> c) \<Longrightarrow> (\<Prod>x\<leftarrow>xs. f x) \<le> c ^ length xs" for f :: "'a \<Rightarrow> nat"
>   by (induction xs) (auto simp: mult_le_mono)
> 
> (* TODO add to HOL/Finite_Set.thy *)
> lemma card_insert_Suc:
>   "card (insert x S) \<le> Suc (card S)"
>   by (metis Suc_n_not_le_n card.infinite card_insert_if finite_insert linear)
> 
> (* TODO add to HOL/Power.thy *)
> lemma nat_power_le_imp_le:
>   "0 < a \<Longrightarrow> a \<le> b \<Longrightarrow> x ^ a \<le> x ^ b" for x :: nat
>   by (metis leD linorder_le_less_linear nat_power_less_imp_less neq0_conv power_eq_0_iff)
> 
> (* TODO add to HOL/Power.thy *)
> lemma const_less_power:
>   "n < x ^ n" if "x > 1"
>   using that by (induction n) (auto simp: less_trans_Suc)
> 
> (* TODO add to HOL-Library/Log_Nat.thy *)
> lemma floorlog_le_const:
>   "floorlog x n \<le> n"
>   by (induction n) (simp add: floorlog_eq_zero_iff, metis Suc_lessI floorlog_le_iff le_SucI power_inject_exp)
> 
> 
> locale dra_construction_size = dra_construction + transition_functions_size +
>   assumes
>     equiv_finite: "finite P \<Longrightarrow> finite {Abs \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> P}"
>   assumes
>     equiv_card: "finite P \<Longrightarrow> card {Abs \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> P} \<le> 2 ^ 2 ^ card P"
> begin
> 
> lemma af\<^sub>F_lifted_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (\<up>af\<^sub>F \<phi> (Abs \<psi>)) \<subseteq>  {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
>   using af\<^sub>F_lifted_semantics af\<^sub>F_nested_prop_atoms by blast
> 
> lemma af\<^sub>G_lifted_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (\<up>af\<^sub>G \<phi> (Abs \<psi>)) \<subseteq>  {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
>   using af\<^sub>G_lifted_semantics af\<^sub>G_nested_prop_atoms by blast
> 
> 
> lemma \<AA>\<^sub>\<mu>_nodes:
>   "DBA.nodes (\<AA>\<^sub>\<mu> \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
>   unfolding \<AA>\<^sub>\<mu>_def
>   using af_lifted_semantics af_nested_prop_atoms by fastforce
> 
> lemma \<AA>\<^sub>\<mu>_GF_nodes:
>   "DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
>   unfolding \<AA>\<^sub>\<mu>_GF_def dba.nodes_alt_def dba.reachable_alt_def
>   using af\<^sub>F_nested_prop_atoms[of "F\<^sub>n \<phi>"] by (auto simp: af\<^sub>F_lifted_semantics)
> 
> lemma \<AA>\<^sub>\<nu>_nodes:
>   "DCA.nodes (\<AA>\<^sub>\<nu> \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
>   unfolding \<AA>\<^sub>\<nu>_def
>   using af_lifted_semantics af_nested_prop_atoms by fastforce
> 
> lemma \<AA>\<^sub>\<nu>_FG_nodes:
>   "DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
>   unfolding \<AA>\<^sub>\<nu>_FG_def dca.nodes_alt_def dca.reachable_alt_def
>   using af\<^sub>G_nested_prop_atoms[of "G\<^sub>n \<phi>"] by (auto simp: af\<^sub>G_lifted_semantics)
> 
> lemma \<CC>_nodes_normalise:
>   "DCA.nodes (\<CC> \<phi> X) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>} \<times> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> (normalise \<phi>) X}"
>   unfolding \<CC>_def dca.nodes_alt_def dca.reachable_alt_def
>   apply (auto simp add: af\<^sub>\<nu>_lifted_semantics af_letter\<^sub>\<nu>_lifted_semantics)
>   using af\<^sub>\<nu>_fst_nested_prop_atoms apply force
>   by (metis GF_advice_nested_prop_atoms\<^sub>\<nu> af\<^sub>\<nu>_snd_nested_prop_atoms Abs_eq af\<^sub>\<nu>_lifted_semantics fst_conv normalise_eq snd_conv sup.absorb_iff1)
> 
> lemma \<CC>_nodes:
>   "DCA.nodes (\<CC> \<phi> X) \<subseteq> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>} \<times> {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
>   unfolding \<CC>_def dca.nodes_alt_def dca.reachable_alt_def
>   apply (auto simp add: af\<^sub>\<nu>_lifted_semantics af_letter\<^sub>\<nu>_lifted_semantics)
>   using af\<^sub>\<nu>_fst_nested_prop_atoms apply force
>   by (metis (no_types, hide_lams) GF_advice_nested_prop_atoms\<^sub>\<nu> af\<^sub>\<nu>_snd_nested_prop_atoms fst_eqD nested_prop_atoms\<^sub>\<nu>_subset normalise_nested_propos order_refl order_trans snd_eqD sup.order_iff)
> 
> 
> 
> lemma equiv_subset:
>   "{Abs \<psi> |\<psi>. nested_prop_atoms \<psi> \<subseteq> P} \<subseteq> {Abs \<psi> |\<psi>. prop_atoms \<psi> \<subseteq> P}"
>   using prop_atoms_nested_prop_atoms by blast
> 
> lemma equiv_finite':
>   "finite P \<Longrightarrow> finite {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> P}"
>   using equiv_finite equiv_subset finite_subset by fast
> 
> lemma equiv_card':
>   "finite P \<Longrightarrow> card {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> P} \<le> 2 ^ 2 ^ card P"
>   by (metis (mono_tags, lifting) equiv_card equiv_subset equiv_finite card_mono le_trans)
> 
> 
> lemma nested_prop_atoms_finite:
>   "finite {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
>   using equiv_finite'[OF Equivalence_Relations.nested_prop_atoms_finite] .
> 
> lemma nested_prop_atoms_card:
>   "card {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>} \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>)"
>   using equiv_card'[OF Equivalence_Relations.nested_prop_atoms_finite] .
> 
> lemma nested_prop_atoms\<^sub>\<nu>_finite:
>   "finite {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
>   using equiv_finite'[OF nested_prop_atoms\<^sub>\<nu>_finite] by fast
> 
> lemma nested_prop_atoms\<^sub>\<nu>_card:
>   "card {Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X} \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>)" (is "?lhs \<le> ?rhs")
> proof -
>   have "finite {Abs \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
>     by (simp add: nested_prop_atoms\<^sub>\<nu>_finite Advice.nested_prop_atoms\<^sub>\<nu>_finite equiv_finite)
> 
>   then have "?lhs \<le> card {Abs \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> \<phi> X)}"
>     using card_mono equiv_subset by blast
> 
>   also have "\<dots> \<le> 2 ^ 2 ^ card (nested_prop_atoms\<^sub>\<nu> \<phi> X)"
>     using equiv_card[OF Advice.nested_prop_atoms\<^sub>\<nu>_finite] by fast
> 
>   also have "\<dots> \<le> ?rhs"
>     using nested_prop_atoms\<^sub>\<nu>_card by auto
> 
>   finally show ?thesis .
> qed
> 
> 
> lemma \<AA>\<^sub>\<mu>_GF_nodes_finite:
>   "finite (DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>))"
>   using finite_subset[OF \<AA>\<^sub>\<mu>_GF_nodes nested_prop_atoms_finite] .
> 
> lemma \<AA>\<^sub>\<nu>_FG_nodes_finite:
>   "finite (DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>))"
>   using finite_subset[OF \<AA>\<^sub>\<nu>_FG_nodes nested_prop_atoms_finite] .
> 
> lemma \<AA>\<^sub>\<mu>_GF_nodes_card:
>   "card (DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>)) \<le> 2 ^ 2 ^ card (nested_prop_atoms (F\<^sub>n \<phi>))"
>   using le_trans[OF card_mono[OF nested_prop_atoms_finite \<AA>\<^sub>\<mu>_GF_nodes] nested_prop_atoms_card] .
> 
> lemma \<AA>\<^sub>\<nu>_FG_nodes_card:
>   "card (DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>)) \<le> 2 ^ 2 ^ card (nested_prop_atoms (G\<^sub>n \<phi>))"
>   using le_trans[OF card_mono[OF nested_prop_atoms_finite \<AA>\<^sub>\<nu>_FG_nodes] nested_prop_atoms_card] .
> 
> 
> lemma \<AA>\<^sub>2_nodes_finite_helper:
>   "list_all (finite \<circ> DBA.nodes) (map (\<lambda>\<psi>. \<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)) xs)"
>   by (auto simp: list.pred_map list_all_iff \<AA>\<^sub>\<mu>_GF_nodes_finite)
> 
> lemma \<AA>\<^sub>2_nodes_finite:
>   "finite (DBA.nodes (\<AA>\<^sub>2 xs ys))"
>   unfolding \<AA>\<^sub>2_def using DBA_Combine.intersect_list_nodes_finite \<AA>\<^sub>2_nodes_finite_helper .
> 
> lemma \<AA>\<^sub>3_nodes_finite_helper:
>   "list_all (finite \<circ> DCA.nodes) (map (\<lambda>\<psi>. \<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>)) ys)"
>   by (auto simp: list.pred_map list_all_iff \<AA>\<^sub>\<nu>_FG_nodes_finite)
> 
> lemma \<AA>\<^sub>3_nodes_finite:
>   "finite (DCA.nodes (\<AA>\<^sub>3 xs ys))"
>   unfolding \<AA>\<^sub>3_def using DCA_Combine.intersect_list_nodes_finite \<AA>\<^sub>3_nodes_finite_helper .
> 
> lemma \<AA>\<^sub>2_nodes_card:
>   assumes
>     "length xs \<le> n"
>   and
>     "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>   shows
>     "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)"
> proof -
>   have 1: "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms (F\<^sub>n \<psi>[set ys]\<^sub>\<mu>)) \<le> Suc n"
>   proof -
>     fix \<psi>
>     assume "\<psi> \<in> set xs"
> 
>     have "card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>)))
>           \<le> Suc (card (nested_prop_atoms (\<psi>[set ys]\<^sub>\<mu>)))"
>       by (simp add: card_insert_Suc)
> 
>     also have "\<dots> \<le> Suc (card (nested_prop_atoms \<psi>))"
>       by (simp add: FG_advice_nested_prop_atoms_card)
> 
>     also have "\<dots> \<le> Suc n"
>       by (simp add: assms(2) \<open>\<psi> \<in> set xs\<close>)
> 
>     finally show "card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>))) \<le> Suc n" .
>   qed
> 
>   have "(\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>))))
>         \<le> (\<Prod>\<psi>\<leftarrow>xs. 2 ^ 2 ^ card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>))))"
>     by (rule list_prod_mono) (insert \<AA>\<^sub>\<mu>_GF_nodes_card le_fun_def, blast)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ length xs"
>     by (rule list_prod_const) (metis 1 Suc_leI nat_power_le_imp_le nat_power_eq_Suc_0_iff neq0_conv pos2 zero_less_power)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ n"
>     using assms(1) nat_power_le_imp_le by fastforce
> 
>   also have "\<dots> = 2 ^ (n * 2 ^ Suc n)"
>     by (metis Groups.mult_ac(2) power_mult)
> 
>   also have "\<dots> \<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)"
>     by (cases "n = 0") (auto simp: floorlog_bounds less_imp_le_nat)
> 
>   also have "\<dots> = 2 ^ 2 ^ (Suc n + floorlog 2 n)"
>     by (simp add: power_add)
> 
>   finally have 2: "(\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)))) \<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)" .
> 
>   have "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) \<le> max 1 (length xs) * (\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>))))"
>     using DBA_Combine.intersect_list_nodes_card[OF \<AA>\<^sub>2_nodes_finite_helper]
>     by (auto simp: \<AA>\<^sub>2_def comp_def)
> 
>   also have "\<dots> \<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)"
>     using assms(1) 2 by (simp add: mult_le_mono)
> 
>   also have "\<dots> \<le> 2 ^ (floorlog 2 n) * 2 ^ 2 ^ (Suc n + floorlog 2 n)"
>     by (cases "n = 0") (auto simp: floorlog_bounds less_imp_le_nat)
> 
>   also have "\<dots> = 2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))"
>     by (simp add: power_add)
> 
>   also have "\<dots> \<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))"
>     by (simp add: floorlog_le_const)
> 
>   also have "\<dots> \<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)"
>     by simp (metis const_less_power Suc_1 add_Suc_right add_leE lessI less_imp_le_nat power_Suc)
> 
>   finally show ?thesis .
> qed
> 
> 
> lemma \<AA>\<^sub>3_nodes_card:
>   assumes
>     "length ys \<le> n"
>   and
>     "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>   shows
>     "card (DCA.nodes (\<AA>\<^sub>3 xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)"
> proof -
>   have 1: "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (DCA.nodes (\<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>))) \<le> 2 ^ 2 ^ Suc n"
>   proof -
>     fix \<psi>
>     assume "\<psi> \<in> set ys"
> 
>     have "card (nested_prop_atoms (G\<^sub>n \<psi>[set xs]\<^sub>\<nu>))
>           \<le> Suc (card (nested_prop_atoms (\<psi>[set xs]\<^sub>\<nu>)))"
>       by (simp add: card_insert_Suc)
> 
>     also have "\<dots> \<le> Suc (card (nested_prop_atoms \<psi>))"
>       by (simp add: GF_advice_nested_prop_atoms_card)
> 
>     also have "\<dots> \<le> Suc n"
>       by (simp add: assms(2) \<open>\<psi> \<in> set ys\<close>)
> 
>     finally have 2: "card (nested_prop_atoms (G\<^sub>n \<psi>[set xs]\<^sub>\<nu>)) \<le> Suc n" .
> 
>     then show "?thesis \<psi>"
>       by (intro le_trans[OF \<AA>\<^sub>\<nu>_FG_nodes_card]) (meson one_le_numeral power_increasing)
>   qed
> 
> 
>   have "card (DCA.nodes (\<AA>\<^sub>3 xs ys)) \<le> (\<Prod>\<psi>\<leftarrow>ys. card (DCA.nodes (\<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>))))"
>     unfolding \<AA>\<^sub>3_def using DCA_Combine.intersect_list_nodes_card[OF \<AA>\<^sub>3_nodes_finite_helper]
>     by (auto simp: comp_def)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ length ys"
>     by (rule list_prod_const) (rule 1)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ n"
>     by (simp add: assms(1) power_increasing)
> 
>   also have "\<dots> \<le> 2 ^ (n * 2 ^ Suc n)"
>     by (metis le_refl mult.commute power_mult)
> 
>   also have "\<dots> \<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)"
>     by (cases \<open>n > 0\<close>) (simp_all add: floorlog_bounds less_imp_le_nat)
> 
>   also have "\<dots> = 2 ^ 2 ^ (n + floorlog 2 n + 1)"
>     by (simp add: power_add)
> 
>   finally show ?thesis .
> qed
> 
> 
> lemma \<AA>\<^sub>1_nodes_finite:
>   "finite (DCA.nodes (\<AA>\<^sub>1 \<phi> xs))"
>   unfolding \<AA>\<^sub>1_def
>   by (metis (no_types, lifting) finite_subset \<CC>_nodes finite_SigmaI nested_prop_atoms\<^sub>\<nu>_finite nested_prop_atoms_finite)
> 
> lemma \<AA>\<^sub>1_nodes_card:
>   assumes
>     "card (subfrmlsn \<phi>) \<le> n"
>   shows
>     "card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) \<le> 2 ^ 2 ^ (n + 1)"
> proof -
>   let ?fst = "{Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
>   let ?snd = "{Abs \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> (set xs)}"
> 
>   have 1: "card (nested_prop_atoms \<phi>) \<le> n"
>     by (meson card_mono[OF subfrmlsn_finite nested_prop_atoms_subfrmlsn] assms le_trans)
> 
> 
>   have "card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) \<le> card (?fst \<times> ?snd)"
>     unfolding \<AA>\<^sub>1_def
>     by (rule card_mono) (simp_all add: \<CC>_nodes nested_prop_atoms\<^sub>\<nu>_finite nested_prop_atoms_finite)
> 
>   also have "\<dots> = card ?fst * card ?snd"
>     using nested_prop_atoms\<^sub>\<nu>_finite card_cartesian_product by blast
> 
>   also have "\<dots> \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>) * 2 ^ 2 ^ card (nested_prop_atoms \<phi>)"
>     using nested_prop_atoms\<^sub>\<nu>_card nested_prop_atoms_card mult_le_mono by blast
> 
>   also have "\<dots> = 2 ^ 2 ^ (card (nested_prop_atoms \<phi>) + 1)"
>     by (simp add: semiring_normalization_rules(36))
> 
>   also have "\<dots> \<le> 2 ^ 2 ^ (n + 1)"
>     using assms 1 by simp
> 
>   finally show ?thesis .
> qed
> 
> 
> lemma \<AA>'_nodes_finite:
>   "finite (DRA.nodes (\<AA>' \<phi> xs ys))"
>   unfolding \<AA>'_def
>   using intersect_nodes_finite intersect_bc_nodes_finite
>   using \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>2_nodes_finite \<AA>\<^sub>3_nodes_finite
>   by fast
> 
> lemma \<AA>'_nodes_card:
>   assumes
>     "length xs \<le> n"
>   and
>     "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>   and
>     "length ys \<le> n"
>   and
>     "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>   and
>     "card (subfrmlsn \<phi>) \<le> n"
>   shows
>     "card (DRA.nodes (\<AA>' \<phi> xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)"
> proof -
>   have "n + 1 \<le> n + floorlog 2 n + 2"
>     by auto
> 
>   then have 1: "(2::nat) ^ (n + 1) \<le> 2 ^ (n + floorlog 2 n + 2)"
>     using one_le_numeral power_increasing by blast
> 
> 
>   have "card (DRA.nodes (\<AA>' \<phi> xs ys)) \<le> card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) * card (DBA.nodes (\<AA>\<^sub>2 xs ys)) * card (DCA.nodes (\<AA>\<^sub>3 xs ys))" (is "?lhs \<le> ?rhs")
>   proof (unfold \<AA>'_def)
>     have "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) * card (DCA.nodes (DCA_Combine.intersect (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys))) \<le> ?rhs"
>       by (simp add: intersect_nodes_card[OF \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>3_nodes_finite])
>     then show "card (DRA.nodes (intersect_bc (\<AA>\<^sub>2 xs ys) (DCA_Combine.intersect (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys)))) \<le> ?rhs"
>       by (meson intersect_bc_nodes_card[OF \<AA>\<^sub>2_nodes_finite intersect_nodes_finite[OF \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>3_nodes_finite]] basic_trans_rules(23))
>   qed
> 
>   also have "\<dots> \<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) * 2 ^ 2 ^ (n + floorlog 2 n + 1)"
>     using \<AA>\<^sub>1_nodes_card[OF assms(5)] \<AA>\<^sub>2_nodes_card[OF assms(1,2)] \<AA>\<^sub>3_nodes_card[OF assms(3,4)]
>     by (metis mult_le_mono)
> 
>   also have "\<dots> = 2 ^ (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))"
>     by (metis power_add)
> 
>   also have "\<dots> \<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))"
>     using 1 by auto
> 
>   finally show ?thesis
>     by (simp add: numeral.simps(2) power_add)
> qed
> 
> lemma subformula_nested_prop_atoms_subfrmlsn:
>   "\<psi> \<in> subfrmlsn \<phi> \<Longrightarrow> nested_prop_atoms \<psi> \<subseteq> subfrmlsn \<phi>"
>   using nested_prop_atoms_subfrmlsn subfrmlsn_subset by blast
> 
> 
> lemma ltl_to_dra_nodes_finite:
>   "finite (DRA.nodes (ltl_to_dra \<phi>))"
>   unfolding ltl_to_dra_def
>   apply (rule DRA_Combine.union_list_nodes_finite)
>   apply (simp add: split_def \<AA>'_alphabet advice_sets_not_empty)
>   apply (simp add: list.pred_set split_def \<AA>'_nodes_finite)
>   done
> 
> lemma ltl_to_dra_restricted_nodes_finite:
>   "finite (DRA.nodes (ltl_to_dra_restricted \<phi>))"
>   unfolding ltl_to_dra_restricted_def
>   apply (rule DRA_Combine.union_list_nodes_finite)
>   apply (simp add: split_def \<AA>'_alphabet advice_sets_not_empty)
>   apply (simp add: list.pred_set split_def \<AA>'_nodes_finite)
>   done
> 
> lemma ltl_to_dra_alphabet_nodes_finite:
>   "finite (DRA.nodes (ltl_to_dra_alphabet \<phi> AP))"
>   using ltl_to_dra_alphabet_nodes ltl_to_dra_restricted_nodes_finite finite_subset by fast
> 
> 
> lemma ltl_to_dra_nodes_card:
>   assumes
>     "card (subfrmlsn \<phi>) \<le> n"
>   shows
>     "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)"
> proof -
>   let ?map = "map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>)"
> 
>   have 1: "\<And>x::nat. x > 0 \<Longrightarrow> x ^ length (advice_sets \<phi>) \<le> x ^ 2 ^ card (subfrmlsn \<phi>)"
>     by (metis advice_sets_length linorder_not_less nat_power_less_imp_less)
> 
>   have "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> prod_list (map (card \<circ> DRA.nodes) ?map)"
>     unfolding ltl_to_dra_def
>     apply (rule DRA_Combine.union_list_nodes_card)
>     unfolding list.pred_set using \<AA>'_nodes_finite by auto
> 
>   also have "\<dots> = (\<Prod>(x, y)\<leftarrow>advice_sets \<phi>. card (DRA.nodes (\<AA>' \<phi> x y)))"
>     by (induction "advice_sets \<phi>") (auto, metis (no_types, lifting) comp_apply split_def)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \<phi>)"
>   proof (rule list_prod_const, unfold split_def, rule \<AA>'_nodes_card)
>     show "\<And>x. x \<in> set (advice_sets \<phi>) \<Longrightarrow> length (fst x) \<le> n"
>       using advice_sets_element_length assms by fastforce
> 
>     show "\<And>x \<psi>. \<lbrakk>x \<in> set (advice_sets \<phi>); \<psi> \<in> set (fst x)\<rbrakk> \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>       using advice_sets_element_subfrmlsn(1) assms subformula_nested_prop_atoms_subfrmlsn subformulas\<^sub>\<mu>_subfrmlsn
>       by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)
> 
>     show "\<And>x. x \<in> set (advice_sets \<phi>) \<Longrightarrow> length (snd x) \<le> n"
>       using advice_sets_element_length assms by fastforce
> 
>     show "\<And>x \<psi>. \<lbrakk>x \<in> set (advice_sets \<phi>); \<psi> \<in> set (snd x)\<rbrakk> \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
>       using advice_sets_element_subfrmlsn(2) assms subformula_nested_prop_atoms_subfrmlsn subformulas\<^sub>\<nu>_subfrmlsn
>       by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)
>   qed (insert assms, blast)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ card (subfrmlsn \<phi>))"
>     by (simp add: 1)
> 
>   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ n)"
>     by (simp add: assms power_increasing)
> 
>   also have "\<dots> = 2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))"
>     by (simp add: ac_simps power_mult [symmetric])
> 
>   also have "\<dots> = 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)"
>     by (simp add: power_add) (simp add: mult_2 power_add)
> 
>   finally show ?thesis .
> qed
> 
> text \<open>We verify the size bound of the automaton to be double exponential.\<close>
> 
> theorem ltl_to_dra_size:
>   "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> 2 ^ 2 ^ (2 * size \<phi> + floorlog 2 (size \<phi>) + 4)"
>   using ltl_to_dra_nodes_card subfrmlsn_card by blast
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Implementation.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Implementation.thy
10c10
<   DRA_Instantiation
---
>   DRA_Construction
15,18d14
< text \<open>We convert the implicit automaton to its explicit representation
<       and afterwards proof the final correctness theorem and the overall
<       size bound.\<close>
< 
20a17,22
> text \<open>
>   We convert the implicit automaton to its explicit representation
>   and afterwards proof the final correctness theorem and the overall
>   size bound.
> \<close>
> 
23c25
<   "dra_to_drai \<AA> \<Sigma> = drai \<Sigma> (initial \<AA>) (succ \<AA>) (accepting \<AA>)"
---
>   "dra_to_drai \<AA> \<Sigma> = drai \<Sigma> (initial \<AA>) (transition \<AA>) (condition \<AA>)"
29c31
< definition drai_to_draei :: "('a, 'b) drai \<Rightarrow> ('a, nat) draei"
---
> definition drai_to_draei :: "nat \<Rightarrow> ('a, 'b :: hashable) drai \<Rightarrow> ('a, nat) draei"
31c33,80
<   "drai_to_draei = to_draei_impl (=) bot 2"
---
>   "drai_to_draei hms = to_draei_impl (=) bounded_hashcode_nat hms"
> 
> 
> lemma dra_to_drai_rel:
>   assumes
>     "(\<Sigma>, alphabet A) \<in> \<langle>Id\<rangle> list_set_rel"
>   shows
>     "(dra_to_drai A \<Sigma>, A) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
> proof -
>   have "(A, A) \<in> \<langle>Id, Id\<rangle>dra_rel"
>     by simp
> 
>   then have "(dra_to_drai A \<Sigma>, dra (alphabet A) (initial A) (transition A) (condition A)) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
>     unfolding dra_to_drai_def using assms by parametricity
> 
>   then show ?thesis
>     by simp
> qed
> 
> lemma draei_language_rel:
>   fixes
>     A :: "('label, 'state :: hashable) dra"
>   assumes
>     "(\<Sigma>, alphabet A) \<in> \<langle>Id\<rangle> list_set_rel"
>   and
>     "finite (DRA.nodes A)"
>   and
>     "is_valid_def_hm_size TYPE('state) hms"
>   shows
>     "DRA.language (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \<Sigma>)))) = DRA.language A"
> proof -
>   have "(dra_to_drai A \<Sigma>, A) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
>     using dra_to_drai_rel assms by fast
> 
>   then have "(drai_to_draei hms (dra_to_drai A \<Sigma>), to_draei A) \<in> \<langle>Id_on (dra.alphabet A), rel (dra_to_drai A \<Sigma>) A (=) bounded_hashcode_nat hms\<rangle> draei_dra_rel"
>     unfolding drai_to_draei_def
>     using to_draei_impl_refine[unfolded autoref_tag_defs]
>     by parametricity (simp_all add: assms is_bounded_hashcode_def bounded_hashcode_nat_bounds)
> 
>   then have "(DRA.language ((drae_dra \<circ> draei_drae) (drai_to_draei hms (dra_to_drai A \<Sigma>))), DRA.language (id (to_draei A))) \<in> \<langle>\<langle>Id_on (dra.alphabet A)\<rangle> stream_rel\<rangle> set_rel"
>     by parametricity
> 
>   then show ?thesis
>     by (simp add: to_draei_def)
> qed
> 
> 
> subsection \<open>Defining the Alphabet\<close>
58c107
< definition ltl_alphabet :: "'a ltlc \<Rightarrow> 'a set list"
---
> definition ltl_alphabet :: "'a list \<Rightarrow> 'a set list"
60,64c109
<   "ltl_alphabet \<phi> = map set (subseqs (atoms_ltlc_list \<phi>))"
< 
< definition ltlc_to_draei :: "'a ltlc \<Rightarrow> ('a set, nat) draei"
< where
<   "ltlc_to_draei \<phi> = drai_to_draei (dra_to_drai (ltl_to_dra_alphabet (simplify Slow (ltlc_to_ltln \<phi>)) (atoms_ltlc \<phi>)) (ltl_alphabet \<phi>))"
---
>   "ltl_alphabet AP = map set (subseqs AP)"
66a112
> subsection \<open>The Final Constant\<close>
68c114,116
< subsection \<open>Final Proof of Correctness\<close>
---
> text \<open>
>   We require the quotient type to be hashable in order to efficiently explore the automaton.
> \<close>
70,101c118,121
< lemma dra_to_drai_rel:
<   assumes
<     "(\<Sigma>, alphabet A) \<in> \<langle>Id\<rangle> list_set_rel"
<   shows
<     "(dra_to_drai A \<Sigma>, A) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
< proof -
<   have "(A, A) \<in> \<langle>Id, Id\<rangle>dra_rel"
<     by simp
< 
<   then have "(dra_to_drai A \<Sigma>, dra (alphabet A) (initial A) (succ A) (accepting A)) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
<     unfolding dra_to_drai_def using assms by parametricity
< 
<   then show ?thesis
<     by simp
< qed
< 
< lemma draei_language:
<   assumes 1:
<     "(\<Sigma>, alphabet A) \<in> \<langle>Id\<rangle> list_set_rel"
<   and
<     "finite (DRA.nodes A)"
<   shows
<     "DRA.language (drae_dra (draei_drae (drai_to_draei (dra_to_drai A \<Sigma>)))) = DRA.language A"
< proof -
<   have "(dra_to_drai A \<Sigma>, A) \<in> \<langle>Id, Id\<rangle>drai_dra_rel"
<     using dra_to_drai_rel 1 by fast
< 
<   then have "(drai_to_draei (dra_to_drai A \<Sigma>), to_draei A) \<in> \<langle>Id_on (dra.alphabet A), rel (dra_to_drai A \<Sigma>) A (=) bot 2\<rangle> draei_dra_rel"
<     unfolding drai_to_draei_def
<     using to_draei_impl_refine[unfolded autoref_tag_defs]
<     apply parametricity
<     by (simp_all add: assms is_bounded_hashcode_def bot_nat_def is_valid_def_hm_size_def)
---
> locale dra_implementation = dra_construction_size _ _ _ Abs
>   for
>     Abs :: "'a ltln \<Rightarrow> 'ltlq :: hashable"
> begin
103,104c123,125
<   then have "(DRA.language ((drae_dra \<circ> draei_drae) (drai_to_draei (dra_to_drai A \<Sigma>))), DRA.language (id (to_draei A))) \<in> \<langle>\<langle>Id_on (dra.alphabet A)\<rangle> stream_rel\<rangle> set_rel"
<     by parametricity
---
> definition ltln_to_draei :: "'a list \<Rightarrow> 'a ltln \<Rightarrow> ('a set, nat) draei"
> where
>   "ltln_to_draei AP \<phi> = drai_to_draei (Suc (size \<phi>)) (dra_to_drai (ltl_to_dra_alphabet \<phi> (set AP)) (ltl_alphabet AP))"
106,108c127,129
<   then show ?thesis
<     by (simp add: to_draei_def)
< qed
---
> definition ltlc_to_draei :: "'a ltlc \<Rightarrow> ('a set, nat) draei"
> where
>   "ltlc_to_draei \<phi> = ltln_to_draei (atoms_ltlc_list \<phi>) (simplify Slow (ltlc_to_ltln \<phi>))"
112,118c133,135
<   "(ltl_alphabet \<phi>, alphabet (ltl_to_dra_alphabet \<psi> (atoms_ltlc \<phi>))) \<in> \<langle>Id\<rangle> list_set_rel"
<   unfolding ltl_to_dra.ltl_to_dra_alphabet_alphabet ltl_alphabet_def
<   by (simp add: list_set_rel_def atoms_ltlc_list_set atoms_ltlc_list_distinct in_br_conv subseqs_powset distinct_set_subseqs)
< 
< lemma ltl_to_dra_alphabet_nodes_finite:
<   "finite (DRA.nodes (ltl_to_dra_alphabet \<phi> Ap))"
<   using ltl_to_dra.ltl_to_dra_alphabet_nodes ltl_to_dra_nodes_finite finite_subset by fast
---
>   "distinct AP \<Longrightarrow> (ltl_alphabet AP, alphabet (ltl_to_dra_alphabet \<psi> (set AP))) \<in> \<langle>Id\<rangle> list_set_rel"
>   unfolding ltl_to_dra_alphabet_alphabet ltl_alphabet_def
>   by (simp add: list_set_rel_def in_br_conv subseqs_powset distinct_set_subseqs)
123a141,145
> lemma valid_def_hm_size:
>   "is_valid_def_hm_size TYPE('state) (Suc (size \<phi>))" for \<phi> :: "'a ltln"
>   unfolding is_valid_def_hm_size_def
>   using ltln.size_neq by auto
> 
127,129c149,152
<   unfolding ltlc_to_draei_def
<   unfolding draei_language[OF ltl_to_dra_alphabet_rel ltl_to_dra_alphabet_nodes_finite]
<   unfolding ltl_to_dra.ltl_to_dra_alphabet_language[OF ltlc_to_ltln_simplify_atoms]
---
>   unfolding ltlc_to_draei_def ltln_to_draei_def
>   unfolding draei_language_rel[OF ltl_to_dra_alphabet_rel[OF atoms_ltlc_list_distinct] ltl_to_dra_alphabet_nodes_finite valid_def_hm_size]
>   unfolding atoms_ltlc_list_set
>   unfolding ltl_to_dra_alphabet_language[OF ltlc_to_ltln_simplify_atoms]
130a154,155
> 
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Instantiation.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Instantiation.thy
10c10
<   DRA_Construction
---
>   DRA_Implementation
11a12,13
>   LTL.Disjunctive_Normal_Form
>   "../Logical_Characterization/Extra_Equivalence_Relations"
12a15
>   Deriving.Derive
15,16c18
< text \<open>We instantiate the construction locale with propositional equivalence
<       and obtain a function converting a formula into an abstract automaton.\<close>
---
> subsection \<open>Hash Functions for Quotient Types\<close>
18,63c20
< global_interpretation ltl_to_dra: dra_construction "(\<sim>\<^sub>P)" rep_ltln\<^sub>P abs_ltln\<^sub>P
<   defines ltl_to_dra = ltl_to_dra.ltl_to_dra
<     and ltl_to_dra_alphabet = ltl_to_dra.ltl_to_dra_alphabet
<     and \<AA>' = ltl_to_dra.\<AA>'
<     and \<AA>\<^sub>1 = ltl_to_dra.\<AA>\<^sub>1
<     and \<AA>\<^sub>2 = ltl_to_dra.\<AA>\<^sub>2
<     and \<AA>\<^sub>3 = ltl_to_dra.\<AA>\<^sub>3
<     and \<AA>\<^sub>\<nu>_FG = ltl_to_dra.\<AA>\<^sub>\<nu>_FG
<     and \<AA>\<^sub>\<mu>_GF = ltl_to_dra.\<AA>\<^sub>\<mu>_GF
<     and af_letter\<^sub>G = ltl_to_dra.af_letter\<^sub>G
<     and af_letter\<^sub>F = ltl_to_dra.af_letter\<^sub>F
<     and af_letter\<^sub>G_lifted = ltl_to_dra.af_letter\<^sub>G_lifted
<     and af_letter\<^sub>F_lifted = ltl_to_dra.af_letter\<^sub>F_lifted
<     and af_letter\<^sub>\<nu>_lifted = ltl_to_dra.af_letter\<^sub>\<nu>_lifted
<     and \<CC> = ltl_to_dra.\<CC>
<     and af_letter\<^sub>\<nu> = ltl_to_dra.af_letter\<^sub>\<nu>
<   by unfold_locales (meson Quotient_abs_rep Quotient_ltln\<^sub>P, simp add: Quotient_abs_rep Quotient_ltln\<^sub>P ltln\<^sub>P.abs_eq_iff)
< 
< text \<open>We obtain the following theorem:\<close>
< 
< thm ltl_to_dra.ltl_to_dra_language
< 
< 
< text \<open>Furthermore, we verify the size bound of the automaton to be double-exponential.\<close>
< 
< lemma prop_equiv_nested_prop_atoms_finite:
<   "finite {abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
<   using prop_equiv_finite'[OF nested_prop_atoms_finite] .
< 
< lemma prop_equiv_nested_prop_atoms_card:
<   "card {abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>} \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>)"
<   using prop_equiv_card'[OF nested_prop_atoms_finite] .
< 
< 
< lemma prop_equiv_nested_prop_atoms\<^sub>\<nu>_finite:
<   "finite {abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
<   using prop_equiv_finite'[OF nested_prop_atoms\<^sub>\<nu>_finite] by fast
< 
< lemma prop_equiv_nested_prop_atoms\<^sub>\<nu>_card:
<   "card {abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X} \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>)" (is "?lhs \<le> ?rhs")
< proof -
<   have "finite {abs_ltln\<^sub>P \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X}"
<     by (simp add: prop_equiv_nested_prop_atoms\<^sub>\<nu>_finite nested_prop_atoms\<^sub>\<nu>_finite prop_equiv_finite)
< 
<   then have "?lhs \<le> card {abs_ltln\<^sub>P \<psi> | \<psi>. prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> \<phi> X)}"
<     using card_mono prop_equiv_subset by blast
---
> derive hashable ltln
65,66c22
<   also have "\<dots> \<le> 2 ^ 2 ^ card (nested_prop_atoms\<^sub>\<nu> \<phi> X)"
<     using prop_equiv_card[OF nested_prop_atoms\<^sub>\<nu>_finite] by fast
---
> definition "cube a = a * a * a"
68,69d23
<   also have "\<dots> \<le> ?rhs"
<     using nested_prop_atoms\<^sub>\<nu>_card by auto
71,252c25,26
<   finally show ?thesis .
< qed
< 
< 
< lemma \<AA>\<^sub>\<mu>_GF_nodes_finite:
<   "finite (DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>))"
<   using finite_subset[OF ltl_to_dra.\<AA>\<^sub>\<mu>_GF_nodes prop_equiv_nested_prop_atoms_finite] .
< 
< lemma \<AA>\<^sub>\<nu>_FG_nodes_finite:
<   "finite (DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>))"
<   using finite_subset[OF ltl_to_dra.\<AA>\<^sub>\<nu>_FG_nodes prop_equiv_nested_prop_atoms_finite] .
< 
< lemma \<AA>\<^sub>\<mu>_GF_nodes_card:
<   "card (DBA.nodes (\<AA>\<^sub>\<mu>_GF \<phi>)) \<le> 2 ^ 2 ^ card (nested_prop_atoms (F\<^sub>n \<phi>))"
<   using le_trans[OF card_mono[OF prop_equiv_nested_prop_atoms_finite ltl_to_dra.\<AA>\<^sub>\<mu>_GF_nodes] prop_equiv_nested_prop_atoms_card] .
< 
< lemma \<AA>\<^sub>\<nu>_FG_nodes_card:
<   "card (DCA.nodes (\<AA>\<^sub>\<nu>_FG \<phi>)) \<le> 2 ^ 2 ^ card (nested_prop_atoms (G\<^sub>n \<phi>))"
<   using le_trans[OF card_mono[OF prop_equiv_nested_prop_atoms_finite ltl_to_dra.\<AA>\<^sub>\<nu>_FG_nodes] prop_equiv_nested_prop_atoms_card] .
< 
< 
< lemma \<AA>\<^sub>2_nodes_finite_helper:
<   "list_all (finite \<circ> DBA.nodes) (map (\<lambda>\<psi>. \<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)) xs)"
<   by (auto simp: list.pred_map list_all_iff \<AA>\<^sub>\<mu>_GF_nodes_finite)
< 
< lemma \<AA>\<^sub>2_nodes_finite:
<   "finite (DBA.nodes (\<AA>\<^sub>2 xs ys))"
<   unfolding ltl_to_dra.\<AA>\<^sub>2_def using dbail_nodes_finite \<AA>\<^sub>2_nodes_finite_helper .
< 
< lemma \<AA>\<^sub>3_nodes_finite_helper:
<   "list_all (finite \<circ> DCA.nodes) (map (\<lambda>\<psi>. \<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>)) ys)"
<   by (auto simp: list.pred_map list_all_iff \<AA>\<^sub>\<nu>_FG_nodes_finite)
< 
< lemma \<AA>\<^sub>3_nodes_finite:
<   "finite (DCA.nodes (\<AA>\<^sub>3 xs ys))"
<   unfolding ltl_to_dra.\<AA>\<^sub>3_def using dcail_finite \<AA>\<^sub>3_nodes_finite_helper .
< 
< (* TODO add to HOL/Groups_List.thy *)
< lemma list_prod_mono:
<   "f \<le> g \<Longrightarrow> (\<Prod>x\<leftarrow>xs. f x) \<le> (\<Prod>x\<leftarrow>xs. g x)" for f g :: "'a \<Rightarrow> nat"
<   by (induction xs) (auto simp: le_funD mult_le_mono)
< 
< (* TODO add to HOL/Groups_List.thy *)
< lemma list_prod_const:
<   "(\<And>x. x \<in> set xs \<Longrightarrow> f x \<le> c) \<Longrightarrow> (\<Prod>x\<leftarrow>xs. f x) \<le> c ^ length xs" for f :: "'a \<Rightarrow> nat"
<   by (induction xs) (auto simp: mult_le_mono)
< 
< (* TODO add to HOL/Finite_Set.thy *)
< lemma card_insert_Suc:
<   "card (insert x S) \<le> Suc (card S)"
<   by (metis Suc_n_not_le_n card.infinite card_insert_if finite_insert linear)
< 
< (* TODO add to HOL/Power.thy *)
< lemma nat_power_le_imp_le:
<   "0 < a \<Longrightarrow> a \<le> b \<Longrightarrow> x ^ a \<le> x ^ b" for x :: nat
<   by (metis leD linorder_le_less_linear nat_power_less_imp_less neq0_conv power_eq_0_iff)
< 
< (* TODO add to HOL/Power.thy *)
< lemma const_less_power:
<   "n < x ^ n" if "x > 1"
<   using that by (induction n) (auto simp: less_trans_Suc)
< 
< (* TODO add to HOL-Library/Log_Nat.thy *)
< lemma floorlog_le_const:
<   "floorlog x n \<le> n"
<   by (induction n) (simp add: floorlog_eq_zero_iff, metis Suc_lessI floorlog_le_iff le_SucI power_inject_exp)
< 
< lemma \<AA>\<^sub>2_nodes_card:
<   assumes
<     "length xs \<le> n"
<   and
<     "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<   shows
<     "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)"
< proof -
<   have 1: "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms (F\<^sub>n \<psi>[set ys]\<^sub>\<mu>)) \<le> Suc n"
<   proof -
<     fix \<psi>
<     assume "\<psi> \<in> set xs"
< 
<     have "card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>)))
<           \<le> Suc (card (nested_prop_atoms (\<psi>[set ys]\<^sub>\<mu>)))"
<       by (simp add: card_insert_Suc)
< 
<     also have "\<dots> \<le> Suc (card (nested_prop_atoms \<psi>))"
<       by (simp add: FG_advice_nested_prop_atoms_card)
< 
<     also have "\<dots> \<le> Suc n"
<       by (simp add: assms(2) \<open>\<psi> \<in> set xs\<close>)
< 
<     finally show "card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>))) \<le> Suc n" .
<   qed
< 
<   have "(\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>))))
<         \<le> (\<Prod>\<psi>\<leftarrow>xs. 2 ^ 2 ^ card (nested_prop_atoms (F\<^sub>n (\<psi>[set ys]\<^sub>\<mu>))))"
<     by (rule list_prod_mono) (insert \<AA>\<^sub>\<mu>_GF_nodes_card le_fun_def, blast)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ length xs"
<     by (rule list_prod_const) (metis 1 Suc_leI nat_power_le_imp_le nat_power_eq_Suc_0_iff neq0_conv pos2 zero_less_power)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ n"
<     using assms(1) nat_power_le_imp_le by fastforce
< 
<   also have "\<dots> = 2 ^ (n * 2 ^ Suc n)"
<     by (metis Groups.mult_ac(2) power_mult)
< 
<   also have "\<dots> \<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)"
<     by (cases "n = 0") (auto simp: floorlog_bounds less_imp_le_nat)
< 
<   also have "\<dots> = 2 ^ 2 ^ (Suc n + floorlog 2 n)"
<     by (simp add: power_add)
< 
<   finally have 2: "(\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>)))) \<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)" .
< 
<   have "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) \<le> max 1 (length xs) * (\<Prod>\<psi>\<leftarrow>xs. card (DBA.nodes (\<AA>\<^sub>\<mu>_GF (\<psi>[set ys]\<^sub>\<mu>))))"
<     using dbail_nodes_card[OF \<AA>\<^sub>2_nodes_finite_helper]
<     by (auto simp: ltl_to_dra.\<AA>\<^sub>2_def comp_def)
< 
<   also have "\<dots> \<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)"
<     using assms(1) 2 by (simp add: mult_le_mono)
< 
<   also have "\<dots> \<le> 2 ^ (floorlog 2 n) * 2 ^ 2 ^ (Suc n + floorlog 2 n)"
<     by (cases "n = 0") (auto simp: floorlog_bounds less_imp_le_nat)
< 
<   also have "\<dots> = 2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))"
<     by (simp add: power_add)
< 
<   also have "\<dots> \<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))"
<     by (simp add: floorlog_le_const)
< 
<   also have "\<dots> \<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)"
<     by simp (metis const_less_power Suc_1 add_Suc_right add_leE lessI less_imp_le_nat power_Suc)
< 
<   finally show ?thesis .
< qed
< 
< 
< lemma \<AA>\<^sub>3_nodes_card:
<   assumes
<     "length ys \<le> n"
<   and
<     "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<   shows
<     "card (DCA.nodes (\<AA>\<^sub>3 xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)"
< proof -
<   have 1: "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (DCA.nodes (\<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>))) \<le> 2 ^ 2 ^ Suc n"
<   proof -
<     fix \<psi>
<     assume "\<psi> \<in> set ys"
< 
<     have "card (nested_prop_atoms (G\<^sub>n \<psi>[set xs]\<^sub>\<nu>))
<           \<le> Suc (card (nested_prop_atoms (\<psi>[set xs]\<^sub>\<nu>)))"
<       by (simp add: card_insert_Suc)
< 
<     also have "\<dots> \<le> Suc (card (nested_prop_atoms \<psi>))"
<       by (simp add: GF_advice_nested_prop_atoms_card)
< 
<     also have "\<dots> \<le> Suc n"
<       by (simp add: assms(2) \<open>\<psi> \<in> set ys\<close>)
< 
<     finally have 2: "card (nested_prop_atoms (G\<^sub>n \<psi>[set xs]\<^sub>\<nu>)) \<le> Suc n" .
< 
<     then show "?thesis \<psi>"
<       by (intro le_trans[OF \<AA>\<^sub>\<nu>_FG_nodes_card]) (meson one_le_numeral power_increasing)
<   qed
< 
< 
<   have "card (DCA.nodes (\<AA>\<^sub>3 xs ys)) \<le> (\<Prod>\<psi>\<leftarrow>ys. card (DCA.nodes (\<AA>\<^sub>\<nu>_FG (\<psi>[set xs]\<^sub>\<nu>))))"
<     unfolding ltl_to_dra.\<AA>\<^sub>3_def using dcail_nodes_card[OF \<AA>\<^sub>3_nodes_finite_helper]
<     by (auto simp: comp_def)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ length ys"
<     by (rule list_prod_const) (rule 1)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ Suc n) ^ n"
<     by (simp add: assms(1) power_increasing)
< 
<   also have "\<dots> \<le> 2 ^ (n * 2 ^ Suc n)"
<     by (metis le_refl mult.commute power_mult)
< 
<   also have "\<dots> \<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)"
<     by (cases \<open>n > 0\<close>) (simp_all add: floorlog_bounds less_imp_le_nat)
---
> instantiation set :: (hashable) hashable
> begin
254,255c28,29
<   also have "\<dots> = 2 ^ 2 ^ (n + floorlog 2 n + 1)"
<     by (simp add: power_add)
---
> definition [simp]: "hashcode (x :: 'a set) = Finite_Set.fold (plus o cube o hashcode) (uint32_of_nat (card x)) x"
> definition "def_hashmap_size = (\<lambda>_ :: 'a set itself. 2 * def_hashmap_size TYPE('a))"
257c31,35
<   finally show ?thesis .
---
> instance
> proof
>   from def_hashmap_size[where ?'a = "'a"]
>   show "1 < def_hashmap_size TYPE('a set)"
>     by (simp add: def_hashmap_size_set_def)
260,276c38
< 
< lemma \<AA>\<^sub>1_nodes_finite:
<   "finite (DCA.nodes (\<AA>\<^sub>1 \<phi> xs))"
<   unfolding ltl_to_dra.\<AA>\<^sub>1_def
<   by (metis (no_types, lifting) finite_subset ltl_to_dra.\<CC>_nodes finite_SigmaI prop_equiv_nested_prop_atoms\<^sub>\<nu>_finite prop_equiv_nested_prop_atoms_finite)
< 
< lemma \<AA>\<^sub>1_nodes_card:
<   assumes
<     "card (subfrmlsn \<phi>) \<le> n"
<   shows
<     "card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) \<le> 2 ^ 2 ^ (n + 1)"
< proof -
<   let ?fst = "{abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms \<phi>}"
<   let ?snd = "{abs_ltln\<^sub>P \<psi> | \<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> (set xs)}"
< 
<   have 1: "card (nested_prop_atoms \<phi>) \<le> n"
<     by (meson card_mono[OF subfrmlsn_finite nested_prop_atoms_subfrmlsn] assms le_trans)
---
> end
279,290c41,42
<   have "card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) \<le> card (?fst \<times> ?snd)"
<     unfolding ltl_to_dra.\<AA>\<^sub>1_def
<     by (rule card_mono) (simp_all add: ltl_to_dra.\<CC>_nodes prop_equiv_nested_prop_atoms\<^sub>\<nu>_finite prop_equiv_nested_prop_atoms_finite)
< 
<   also have "\<dots> = card ?fst * card ?snd"
<     using prop_equiv_nested_prop_atoms\<^sub>\<nu>_finite card_cartesian_product by blast
< 
<   also have "\<dots> \<le> 2 ^ 2 ^ card (nested_prop_atoms \<phi>) * 2 ^ 2 ^ card (nested_prop_atoms \<phi>)"
<     using prop_equiv_nested_prop_atoms\<^sub>\<nu>_card prop_equiv_nested_prop_atoms_card mult_le_mono by blast
< 
<   also have "\<dots> = 2 ^ 2 ^ (card (nested_prop_atoms \<phi>) + 1)"
<     by (simp add: semiring_normalization_rules(36))
---
> instantiation fset :: (hashable) hashable
> begin
292,293c44,45
<   also have "\<dots> \<le> 2 ^ 2 ^ (n + 1)"
<     using assms 1 by simp
---
> definition [simp]: "hashcode (x :: 'a fset) = hashcode (fset x)"
> definition "def_hashmap_size = (\<lambda>_ :: 'a fset itself. 2 * def_hashmap_size TYPE('a))"
295c47,51
<   finally show ?thesis .
---
> instance
> proof
>   from def_hashmap_size[where ?'a = "'a"]
>   show "1 < def_hashmap_size TYPE('a fset)"
>     by (simp add: def_hashmap_size_fset_def)
297a54
> end
299,337d55
< lemma \<AA>'_nodes_finite:
<   "finite (DRA.nodes (\<AA>' \<phi> xs ys))"
<   unfolding ltl_to_dra.\<AA>'_def
<   using dcai_nodes_finite dbcrai_nodes_finite
<   using \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>2_nodes_finite \<AA>\<^sub>3_nodes_finite
<   by fast
< 
< lemma \<AA>'_nodes_card:
<   assumes
<     "length xs \<le> n"
<   and
<     "\<And>\<psi>. \<psi> \<in> set xs \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<   and
<     "length ys \<le> n"
<   and
<     "\<And>\<psi>. \<psi> \<in> set ys \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<   and
<     "card (subfrmlsn \<phi>) \<le> n"
<   shows
<     "card (DRA.nodes (\<AA>' \<phi> xs ys)) \<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)"
< proof -
<   have "n + 1 \<le> n + floorlog 2 n + 2"
<     by auto
< 
<   then have 1: "(2::nat) ^ (n + 1) \<le> 2 ^ (n + floorlog 2 n + 2)"
<     using one_le_numeral power_increasing by blast
< 
< 
<   have "card (DRA.nodes (\<AA>' \<phi> xs ys)) \<le> card (DCA.nodes (\<AA>\<^sub>1 \<phi> xs)) * card (DBA.nodes (\<AA>\<^sub>2 xs ys)) * card (DCA.nodes (\<AA>\<^sub>3 xs ys))" (is "?lhs \<le> ?rhs")
<   proof (unfold ltl_to_dra.\<AA>'_def)
<     have "card (DBA.nodes (\<AA>\<^sub>2 xs ys)) * card (DCA.nodes (dcai (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys))) \<le> ?rhs"
<       by (simp add: dcai_nodes_card[OF \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>3_nodes_finite])
<     then show "card (DRA.nodes (dbcrai (\<AA>\<^sub>2 xs ys) (dcai (\<AA>\<^sub>1 \<phi> xs) (\<AA>\<^sub>3 xs ys)))) \<le> ?rhs"
<       by (meson dbcrai_nodes_card[OF \<AA>\<^sub>2_nodes_finite dcai_nodes_finite[OF \<AA>\<^sub>1_nodes_finite \<AA>\<^sub>3_nodes_finite]] basic_trans_rules(23))
<   qed
< 
<   also have "\<dots> \<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) * 2 ^ 2 ^ (n + floorlog 2 n + 1)"
<     using \<AA>\<^sub>1_nodes_card[OF assms(5)] \<AA>\<^sub>2_nodes_card[OF assms(1,2)] \<AA>\<^sub>3_nodes_card[OF assms(3,4)]
<     by (metis mult_le_mono)
339,340c57,58
<   also have "\<dots> = 2 ^ (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))"
<     by (metis power_add)
---
> instantiation ltln\<^sub>P:: (hashable) hashable
> begin
342,343c60,61
<   also have "\<dots> \<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))"
<     using 1 by auto
---
> definition [simp]: "hashcode (\<phi> :: 'a ltln\<^sub>P) = hashcode (min_dnf (rep_ltln\<^sub>P \<phi>))"
> definition "def_hashmap_size = (\<lambda>_ :: 'a ltln\<^sub>P itself. def_hashmap_size TYPE('a ltln))"
345,346c63,67
<   finally show ?thesis
<     by (simp add: numeral.simps(2) power_add)
---
> instance
> proof
>   from def_hashmap_size[where ?'a = "'a"]
>   show "1 < def_hashmap_size TYPE('a ltln\<^sub>P)"
>     by (simp add: def_hashmap_size_ltln\<^sub>P_def def_hashmap_size_ltln_def)
349,404c70
< lemma subformula_nested_prop_atoms_subfrmlsn:
<   "\<psi> \<in> subfrmlsn \<phi> \<Longrightarrow> nested_prop_atoms \<psi> \<subseteq> subfrmlsn \<phi>"
<   using nested_prop_atoms_subfrmlsn subfrmlsn_subset by blast
< 
< 
< lemma ltl_to_dra_nodes_finite:
<   "finite (DRA.nodes (ltl_to_dra \<phi>))"
<   unfolding ltl_to_dra.ltl_to_dra_def
<   apply (rule draul_nodes_finite)
<   apply (simp add: split_def ltl_to_dra.\<AA>'_alphabet advice_sets_not_empty)
<   apply (simp add: list.pred_set split_def \<AA>'_nodes_finite)
<   done
< 
< lemma ltl_to_dra_nodes_card:
<   assumes
<     "card (subfrmlsn \<phi>) \<le> n"
<   shows
<     "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)"
< proof -
<   let ?map = "map (\<lambda>(x, y). \<AA>' \<phi> x y) (advice_sets \<phi>)"
< 
<   have 1: "\<And>x::nat. x > 0 \<Longrightarrow> x ^ length (advice_sets \<phi>) \<le> x ^ 2 ^ card (subfrmlsn \<phi>)"
<     by (metis advice_sets_length linorder_not_less nat_power_less_imp_less)
< 
<   have "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> prod_list (map (card \<circ> DRA.nodes) ?map)"
<     unfolding ltl_to_dra.ltl_to_dra_def
<     apply (rule draul_nodes_card)
<     unfolding set_map image_image split_def ltl_to_dra.\<AA>'_alphabet
<     apply (simp add: advice_sets_not_empty)
<     unfolding split_def list.pred_set using \<AA>'_nodes_finite by auto
< 
<   also have "\<dots> = (\<Prod>(x, y)\<leftarrow>advice_sets \<phi>. card (DRA.nodes (\<AA>' \<phi> x y)))"
<     by (induction "advice_sets \<phi>") (auto, metis (no_types, lifting) comp_apply split_def)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \<phi>)"
<   proof (rule list_prod_const, unfold split_def, rule \<AA>'_nodes_card)
<     show "\<And>x. x \<in> set (advice_sets \<phi>) \<Longrightarrow> length (fst x) \<le> n"
<       using advice_sets_element_length assms by fastforce
< 
<     show "\<And>x \<psi>. \<lbrakk>x \<in> set (advice_sets \<phi>); \<psi> \<in> set (fst x)\<rbrakk> \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<       using advice_sets_element_subfrmlsn(1) assms subformula_nested_prop_atoms_subfrmlsn subformulas\<^sub>\<mu>_subfrmlsn
<       by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)
< 
<     show "\<And>x. x \<in> set (advice_sets \<phi>) \<Longrightarrow> length (snd x) \<le> n"
<       using advice_sets_element_length assms by fastforce
< 
<     show "\<And>x \<psi>. \<lbrakk>x \<in> set (advice_sets \<phi>); \<psi> \<in> set (snd x)\<rbrakk> \<Longrightarrow> card (nested_prop_atoms \<psi>) \<le> n"
<       using advice_sets_element_subfrmlsn(2) assms subformula_nested_prop_atoms_subfrmlsn subformulas\<^sub>\<nu>_subfrmlsn
<       by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)
<   qed (insert assms, blast)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ card (subfrmlsn \<phi>))"
<     by (simp add: 1)
< 
<   also have "\<dots> \<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ n)"
<     by (simp add: assms power_increasing)
---
> end
406,407d71
<   also have "\<dots> = 2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))"
<     by (metis Rat.sign_simps(5) power_mult)
409,410c73,74
<   also have "\<dots> = 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)"
<     by (simp add: semiring_normalization_rules(26))
---
> instantiation ltln\<^sub>Q :: (hashable) hashable
> begin
412,413c76,77
<   finally show ?thesis .
< qed
---
> definition [simp]: "hashcode (\<phi> :: 'a ltln\<^sub>Q) = hashcode (min_dnf (Unf (rep_ltln\<^sub>Q \<phi>)))"
> definition "def_hashmap_size = (\<lambda>_ :: 'a ltln\<^sub>Q itself. def_hashmap_size TYPE('a ltln))"
415,417c79,161
< theorem ltl_to_dra_size:
<   "card (DRA.nodes (ltl_to_dra \<phi>)) \<le> 2 ^ 2 ^ (2 * size \<phi> + floorlog 2 (size \<phi>) + 4)"
<   using ltl_to_dra_nodes_card subfrmlsn_card by blast
---
> instance
> proof
>   from def_hashmap_size[where ?'a = "'a"]
>   show "1 < def_hashmap_size TYPE('a ltln\<^sub>Q)"
>     by (simp add: def_hashmap_size_ltln\<^sub>Q_def def_hashmap_size_ltln_def)
> qed
> 
> end
> 
> 
> subsection \<open>Interpretations with Equivalence Relations\<close>
> 
> text \<open>
>   We instantiate the construction locale with propositional equivalence
>   and obtain a function converting a formula into an abstract automaton.
> \<close>
> 
> global_interpretation ltl_to_dra\<^sub>P: dra_implementation "(\<sim>\<^sub>P)" id rep_ltln\<^sub>P abs_ltln\<^sub>P
>   defines ltl_to_dra\<^sub>P = ltl_to_dra\<^sub>P.ltl_to_dra
>     and ltl_to_dra_restricted\<^sub>P = ltl_to_dra\<^sub>P.ltl_to_dra_restricted
>     and ltl_to_dra_alphabet\<^sub>P = ltl_to_dra\<^sub>P.ltl_to_dra_alphabet
>     and \<AA>'\<^sub>P = ltl_to_dra\<^sub>P.\<AA>'
>     and \<AA>\<^sub>1\<^sub>P = ltl_to_dra\<^sub>P.\<AA>\<^sub>1
>     and \<AA>\<^sub>2\<^sub>P = ltl_to_dra\<^sub>P.\<AA>\<^sub>2
>     and \<AA>\<^sub>3\<^sub>P = ltl_to_dra\<^sub>P.\<AA>\<^sub>3
>     and \<AA>\<^sub>\<nu>_FG\<^sub>P = ltl_to_dra\<^sub>P.\<AA>\<^sub>\<nu>_FG
>     and \<AA>\<^sub>\<mu>_GF\<^sub>P = ltl_to_dra\<^sub>P.\<AA>\<^sub>\<mu>_GF
>     and af_letter\<^sub>G\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>G
>     and af_letter\<^sub>F\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>F
>     and af_letter\<^sub>G_lifted\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>G_lifted
>     and af_letter\<^sub>F_lifted\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>F_lifted
>     and af_letter\<^sub>\<nu>_lifted\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>\<nu>_lifted
>     and \<CC>\<^sub>P = ltl_to_dra\<^sub>P.\<CC>
>     and af_letter\<^sub>\<nu>\<^sub>P = ltl_to_dra\<^sub>P.af_letter\<^sub>\<nu>
>     and ltln_to_draei\<^sub>P = ltl_to_dra\<^sub>P.ltln_to_draei
>     and ltlc_to_draei\<^sub>P = ltl_to_dra\<^sub>P.ltlc_to_draei
>   by unfold_locales (meson Quotient_abs_rep Quotient_ltln\<^sub>P, simp_all add: Quotient_abs_rep Quotient_ltln\<^sub>P ltln\<^sub>P.abs_eq_iff prop_equiv_card prop_equiv_finite)
> 
> thm ltl_to_dra\<^sub>P.ltl_to_dra_language
> thm ltl_to_dra\<^sub>P.ltl_to_dra_size
> thm ltl_to_dra\<^sub>P.final_correctness
> 
> text \<open>
>   Similarly, we instantiate the locale with a different equivalence relation and obtain another
>   constant for translation of LTL to deterministic Rabin automata.
> \<close>
> 
> global_interpretation ltl_to_dra\<^sub>Q: dra_implementation "(\<sim>\<^sub>Q)" Unf rep_ltln\<^sub>Q abs_ltln\<^sub>Q
>   defines ltl_to_dra\<^sub>Q = ltl_to_dra\<^sub>Q.ltl_to_dra
>     and ltl_to_dra_restricted\<^sub>Q = ltl_to_dra\<^sub>Q.ltl_to_dra_restricted
>     and ltl_to_dra_alphabet\<^sub>Q = ltl_to_dra\<^sub>Q.ltl_to_dra_alphabet
>     and \<AA>'\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>'
>     and \<AA>\<^sub>1\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>\<^sub>1
>     and \<AA>\<^sub>2\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>\<^sub>2
>     and \<AA>\<^sub>3\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>\<^sub>3
>     and \<AA>\<^sub>\<nu>_FG\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>\<^sub>\<nu>_FG
>     and \<AA>\<^sub>\<mu>_GF\<^sub>Q = ltl_to_dra\<^sub>Q.\<AA>\<^sub>\<mu>_GF
>     and af_letter\<^sub>G\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>G
>     and af_letter\<^sub>F\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>F
>     and af_letter\<^sub>G_lifted\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>G_lifted
>     and af_letter\<^sub>F_lifted\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>F_lifted
>     and af_letter\<^sub>\<nu>_lifted\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>\<nu>_lifted
>     and \<CC>\<^sub>Q = ltl_to_dra\<^sub>Q.\<CC>
>     and af_letter\<^sub>\<nu>\<^sub>Q = ltl_to_dra\<^sub>Q.af_letter\<^sub>\<nu>
>     and ltln_to_draei\<^sub>Q = ltl_to_dra\<^sub>Q.ltln_to_draei
>     and ltlc_to_draei\<^sub>Q = ltl_to_dra\<^sub>Q.ltlc_to_draei
>   by unfold_locales (meson Quotient_abs_rep Quotient_ltln\<^sub>Q, simp_all add: Quotient_abs_rep Quotient_ltln\<^sub>Q ltln\<^sub>Q.abs_eq_iff nested_prop_atoms_Unf prop_unfold_equiv_finite prop_unfold_equiv_card)
> 
> thm ltl_to_dra\<^sub>Q.ltl_to_dra_language
> thm ltl_to_dra\<^sub>Q.ltl_to_dra_size
> thm ltl_to_dra\<^sub>Q.final_correctness
> 
> 
> text \<open>
>   We allow the user to choose one of the two equivalence relations.
> \<close>
> 
> datatype equiv = Prop | PropUnfold
> 
> fun ltlc_to_draei :: "equiv \<Rightarrow> ('a :: hashable) ltlc \<Rightarrow> ('a set, nat) draei"
> where
>   "ltlc_to_draei Prop = ltlc_to_draei\<^sub>P"
> | "ltlc_to_draei PropUnfold = ltlc_to_draei\<^sub>Q"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_Master_Theorem/LTL_to_DRA/Transition_Functions.thy ../../AFPs/afp-2020/thys/LTL_Master_Theorem/LTL_to_DRA/Transition_Functions.thy
14,15c14,17
< text \<open>This theory defines three functions based on the ``after''-function
<       which we use as transition functions for deterministic automata.\<close>
---
> text \<open>
>   This theory defines three functions based on the ``after''-function
>   which we use as transition functions for deterministic automata.
> \<close>
40,73d41
< lemma af_letter\<^sub>F_nested_prop_atoms:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af_letter\<^sub>F \<phi> \<psi> \<nu>) \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)"
<   by (induction \<psi>) (auto simp: af_letter\<^sub>F_def, insert af_letter_nested_prop_atoms, blast+)
< 
< lemma af\<^sub>F_nested_prop_atoms:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af\<^sub>F \<phi> \<psi> w) \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)"
<   by (induction w rule: rev_induct) (insert af_letter\<^sub>F_nested_prop_atoms, auto)
< 
< lemma af_letter\<^sub>F_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (af_letter\<^sub>F \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
<   using af_letter\<^sub>F_nested_prop_atoms by blast
< 
< lemma af\<^sub>F_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (af\<^sub>F \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
<   using af\<^sub>F_nested_prop_atoms by blast
< 
< 
< lemma af_letter\<^sub>G_nested_prop_atoms:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af_letter\<^sub>G \<phi> \<psi> \<nu>) \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)"
<   by (induction \<psi>) (auto simp: af_letter\<^sub>G_def, insert af_letter_nested_prop_atoms, blast+)
< 
< lemma af\<^sub>G_nested_prop_atoms:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af\<^sub>G \<phi> \<psi> w) \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)"
<   by (induction w rule: rev_induct) (insert af_letter\<^sub>G_nested_prop_atoms, auto)
< 
< lemma af_letter\<^sub>G_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (af_letter\<^sub>G \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
<   using af_letter\<^sub>G_nested_prop_atoms by blast
< 
< lemma af\<^sub>G_range:
<   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (af\<^sub>G \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
<   using af\<^sub>G_nested_prop_atoms by blast
< 
< 
240c208
<   obtain k where "k > j" and "af\<^sub>F \<phi> (F\<^sub>n \<phi>) (w [0 \<rightarrow> k]) \<sim> true\<^sub>n" 
---
>   obtain k where "k > j" and "af\<^sub>F \<phi> (F\<^sub>n \<phi>) (w [0 \<rightarrow> k]) \<sim> true\<^sub>n"
359c327
<     then (af_letter (fst p) \<nu>, (af_letter (fst p) \<nu>)[X]\<^sub>\<nu>)
---
>     then (af_letter (fst p) \<nu>, (normalise (af_letter (fst p) \<nu>))[X]\<^sub>\<nu>)
371c339
<   "snd p \<sim> false\<^sub>n \<Longrightarrow> snd (af_letter\<^sub>\<nu> X p \<nu>) = (af_letter (fst p) \<nu>)[X]\<^sub>\<nu>"
---
>   "snd p \<sim> false\<^sub>n \<Longrightarrow> snd (af_letter\<^sub>\<nu> X p \<nu>) = (normalise (af_letter (fst p) \<nu>))[X]\<^sub>\<nu>"
375,456d342
< lemma af_letter\<^sub>\<nu>_fst_nested_prop_atoms:
<   "nested_prop_atoms (fst (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms (fst p)"
<   by (simp add: af_letter_nested_prop_atoms)
< 
< lemma af_letter\<^sub>\<nu>_snd_nested_prop_atoms_helper:
<   "snd p \<sim> false\<^sub>n \<Longrightarrow> nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms\<^sub>\<nu> (fst p) X"
<   "\<not> snd p \<sim> false\<^sub>n \<Longrightarrow> nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms (snd p)"
<   by simp_all (insert GF_advice_nested_prop_atoms\<^sub>\<nu> af_letter_nested_prop_atoms nested_prop_atoms\<^sub>\<nu>_def, blast)
< 
< lemma af_letter\<^sub>\<nu>_snd_nested_prop_atoms:
<   "nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> (nested_prop_atoms (snd p))"
<   using af_letter\<^sub>\<nu>_snd_nested_prop_atoms_helper by blast
< 
< lemma af_letter\<^sub>\<nu>_fst_range:
<   "range (fst \<circ> af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)}"
<   using af_letter\<^sub>\<nu>_fst_nested_prop_atoms by force
< 
< lemma af_letter\<^sub>\<nu>_snd_range:
<   "range (snd \<circ> af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
<   using af_letter\<^sub>\<nu>_snd_nested_prop_atoms by force
< 
< lemma af_letter\<^sub>\<nu>_range:
<   "range (af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
< proof -
<   have "range (af_letter\<^sub>\<nu> X p) \<subseteq> range (fst \<circ> af_letter\<^sub>\<nu> X p) \<times> range (snd \<circ> af_letter\<^sub>\<nu> X p)"
<     by (simp add: image_subset_iff mem_Times_iff)
< 
<   also have "\<dots> \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
<     using af_letter\<^sub>\<nu>_fst_range af_letter\<^sub>\<nu>_snd_range by blast
< 
<   finally show ?thesis .
< qed
< 
< 
< lemma af\<^sub>\<nu>_fst_nested_prop_atoms:
<   "nested_prop_atoms (fst (af\<^sub>\<nu> X p w)) \<subseteq> nested_prop_atoms (fst p)"
<   by (induction w rule: rev_induct) (auto, insert af_letter_nested_prop_atoms, blast)
< 
< lemma af_letter_nested_prop_atoms\<^sub>\<nu>:
<   "nested_prop_atoms\<^sub>\<nu> (af_letter \<phi> \<nu>) X \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X"
<   by (induction \<phi>) (simp_all add: nested_prop_atoms\<^sub>\<nu>_def, blast+)
< 
< lemma af\<^sub>\<nu>_fst_nested_prop_atoms\<^sub>\<nu>:
<   "nested_prop_atoms\<^sub>\<nu> (fst (af\<^sub>\<nu> X p w)) X \<subseteq> nested_prop_atoms\<^sub>\<nu> (fst p) X"
<   by (induction w rule: rev_induct) (auto, insert af_letter_nested_prop_atoms\<^sub>\<nu>, blast)
< 
< lemma af\<^sub>\<nu>_snd_nested_prop_atoms:
<   "nested_prop_atoms (snd (af\<^sub>\<nu> X p w)) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> (nested_prop_atoms (snd p))"
< proof (induction w arbitrary: p rule: rev_induct)
<   case (snoc x xs)
< 
<   let ?p = "af\<^sub>\<nu> X p xs"
< 
<   have "nested_prop_atoms (snd (af\<^sub>\<nu> X p (xs @ [x]))) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst ?p) X) \<union> (nested_prop_atoms (snd ?p))"
<     by (simp add: af_letter\<^sub>\<nu>_snd_nested_prop_atoms)
< 
<   then show ?case
<     using snoc af\<^sub>\<nu>_fst_nested_prop_atoms\<^sub>\<nu> by blast
< qed (simp add: nested_prop_atoms\<^sub>\<nu>_def)
< 
< 
< lemma af\<^sub>\<nu>_fst_range:
<   "range (fst \<circ> af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)}"
<   using af\<^sub>\<nu>_fst_nested_prop_atoms by fastforce
< 
< lemma af\<^sub>\<nu>_snd_range:
<   "range (snd \<circ> af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
<   using af\<^sub>\<nu>_snd_nested_prop_atoms by fastforce
< 
< lemma af\<^sub>\<nu>_range:
<   "range (af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
< proof -
<   have "range (af\<^sub>\<nu> X p) \<subseteq> range (fst \<circ> af\<^sub>\<nu> X p) \<times> range (snd \<circ> af\<^sub>\<nu> X p)"
<     by (simp add: image_subset_iff mem_Times_iff)
< 
<   also have "\<dots> \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
<     using af\<^sub>\<nu>_fst_range af\<^sub>\<nu>_snd_range by blast
< 
<   finally show ?thesis .
< qed
< 
< 
470c356
<   "snd (af\<^sub>\<nu> X (\<xi>, \<zeta>) w) \<sim> false\<^sub>n \<Longrightarrow> snd (af\<^sub>\<nu> X (\<xi>, \<zeta>) (w @ [\<nu>])) = (af \<xi> (w @ [\<nu>]))[X]\<^sub>\<nu>"
---
>   "snd (af\<^sub>\<nu> X (\<xi>, \<zeta>) w) \<sim> false\<^sub>n \<Longrightarrow> snd (af\<^sub>\<nu> X (\<xi>, \<zeta>) (w @ [\<nu>])) = (normalise (af \<xi> (w @ [\<nu>])))[X]\<^sub>\<nu>"
480c366
<     "\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>"
---
>     "\<exists>i. suffix i w \<Turnstile>\<^sub>n (af \<phi> (prefix i w))[X]\<^sub>\<nu>"
482c368
<     "\<exists>m. \<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
---
>     "\<exists>m. \<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
484c370
<   define resets where "resets = {i. snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n}"
---
>   define resets where "resets = {i. snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n}"
487c373
<   from assms obtain i where 1: "suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>"
---
>   from assms obtain i where 1: "suffix i w \<Turnstile>\<^sub>n (af \<phi> (prefix i w))[X]\<^sub>\<nu>"
493c379
<     
---
> 
496,497c382,383
<     from 1 have "\<forall>n. suffix n (suffix i w) \<Turnstile>\<^sub>n af \<phi> (prefix i w @ prefix n (suffix i w))[X]\<^sub>\<nu>"
<       by (simp add: GF_advice_af)
---
>     from 1 have "\<forall>n. suffix n (suffix i w) \<Turnstile>\<^sub>n (normalise (af \<phi> (prefix i w @ prefix n (suffix i w))))[X]\<^sub>\<nu>"
>       using normalise_monotonic by (simp add: GF_advice_af)
499c385
<     then have "suffix (Suc j) w \<Turnstile>\<^sub>n af \<phi> (prefix (Suc j) w)[X]\<^sub>\<nu>"
---
>     then have "suffix (Suc j) w \<Turnstile>\<^sub>n (normalise (af \<phi> (prefix (Suc j) w)))[X]\<^sub>\<nu>"
502c388
<     then have "\<forall>k>j. \<not> af (af \<phi> (prefix (Suc j) w)[X]\<^sub>\<nu>) (w [Suc j \<rightarrow> k]) \<sim> false\<^sub>n"
---
>     then have "\<forall>k>j. \<not> af ((normalise (af \<phi> (prefix (Suc j) w)))[X]\<^sub>\<nu>) (w [Suc j \<rightarrow> k]) \<sim> false\<^sub>n"
505c391
<     then have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (?\<phi>, ?\<phi>[X]\<^sub>\<nu>) (w [Suc j \<rightarrow> k])) \<sim> false\<^sub>n"
---
>     then have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (?\<phi>, (normalise ?\<phi>)[X]\<^sub>\<nu>) (w [Suc j \<rightarrow> k])) \<sim> false\<^sub>n"
511c397
<       have "fst (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc j) w)) = ?\<phi>"
---
>       have "fst (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc j) w)) = ?\<phi>"
516c402
<       have "snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix j w)) \<sim> false\<^sub>n"
---
>       have "snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix j w)) \<sim> false\<^sub>n"
519c405
<       ultimately have "af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc j) w) = (?\<phi>, ?\<phi>[X]\<^sub>\<nu>)"
---
>       ultimately have "af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc j) w) = (?\<phi>, (normalise ?\<phi>)[X]\<^sub>\<nu>)"
523c409
<     ultimately have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) ((w [0 \<rightarrow> Suc j]) @ (w [Suc j \<rightarrow> k]))) \<sim> false\<^sub>n"
---
>     ultimately have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) ((w [0 \<rightarrow> Suc j]) @ (w [Suc j \<rightarrow> k]))) \<sim> false\<^sub>n"
526c412
<     then have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
---
>     then have "\<forall>k>j. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
536c422
<   then have "resets \<noteq> {} \<Longrightarrow> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Max resets) w)) \<sim> false\<^sub>n"
---
>   then have "resets \<noteq> {} \<Longrightarrow> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Max resets) w)) \<sim> false\<^sub>n"
539c425
<   then have "\<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
---
>   then have "\<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
542c428
<   then show "\<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
---
>   then show "\<forall>k\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
548c434
<     "\<exists>n. \<forall>k\<ge>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
---
>     "\<exists>n. \<forall>k\<ge>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
551,552c437,438
< proof
<   define resets where "resets = {i. snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n}"
---
> proof -
>   define resets where "resets = {i. snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n}"
555c441
<   from assms obtain n where "\<forall>k\<ge>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
---
>   from assms obtain n where "\<forall>k\<ge>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Suc k) w)) \<sim> false\<^sub>n"
558c444
<   then have "\<forall>k>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
---
>   then have "\<forall>k>n. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix k w)) \<sim> false\<^sub>n"
564c450
<   then have "\<forall>i\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n"
---
>   then have "\<forall>i\<ge>m. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix i w)) \<sim> false\<^sub>n"
567c453
<   then have "\<forall>i. \<not> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) ((w [0 \<rightarrow> m]) @ (w [m \<rightarrow> i]))) \<sim> false\<^sub>n"
---
>   then have "\<forall>i. \<not> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) ((w [0 \<rightarrow> m]) @ (w [m \<rightarrow> i]))) \<sim> false\<^sub>n"
574c460
<   have "resets \<noteq> {} \<Longrightarrow> snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix (Max resets) w)) \<sim> false\<^sub>n"
---
>   have "resets \<noteq> {} \<Longrightarrow> snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix (Max resets) w)) \<sim> false\<^sub>n"
577c463
<   then have prefix_\<phi>': "snd (af\<^sub>\<nu> X (\<phi>, \<phi>[X]\<^sub>\<nu>) (prefix m w)) = ?\<phi>[X]\<^sub>\<nu>"
---
>   then have prefix_\<phi>': "snd (af\<^sub>\<nu> X (\<phi>, (normalise \<phi>)[X]\<^sub>\<nu>) (prefix m w)) = (normalise ?\<phi>)[X]\<^sub>\<nu>"
580c466
<   ultimately have "\<forall>i. \<not> snd (af\<^sub>\<nu> X (?\<phi>, ?\<phi>[X]\<^sub>\<nu>) (w [m \<rightarrow> i])) \<sim> false\<^sub>n"
---
>   ultimately have "\<forall>i. \<not> snd (af\<^sub>\<nu> X (?\<phi>, (normalise ?\<phi>)[X]\<^sub>\<nu>) (w [m \<rightarrow> i])) \<sim> false\<^sub>n"
583c469
<   then have "\<forall>i. \<not> af (?\<phi>[X]\<^sub>\<nu>) (w [m \<rightarrow> i]) \<sim> false\<^sub>n"
---
>   then have "\<forall>i. \<not> af ((normalise ?\<phi>)[X]\<^sub>\<nu>) (w [m \<rightarrow> i]) \<sim> false\<^sub>n"
586c472
<   then show "suffix m w \<Turnstile>\<^sub>n af \<phi> (prefix m w)[X]\<^sub>\<nu>"
---
>   then have "suffix m w \<Turnstile>\<^sub>n (normalise (af \<phi> (prefix m w)))[X]\<^sub>\<nu>"
587a474,477
> 
>   from this[THEN normalise_eventually_equivalent]
>     show "\<exists>i. suffix i w \<Turnstile>\<^sub>n af \<phi> (prefix i w)[X]\<^sub>\<nu>"
>     by (metis add.commute af_subsequence_append le_add1 le_add_same_cancel1 prefix_suffix_subsequence suffix_suffix)
592c482,609
< end
\ No newline at end of file
---
> 
> subsection \<open>Reachability Bounds\<close>
> 
> text \<open>
>   We show that the reach of each after-function is bounded by the atomic
>   propositions of the input formula.
> \<close>
> 
> locale transition_functions_size = transition_functions +
>   assumes
>     normalise_nested_propos: "nested_prop_atoms \<phi> \<supseteq> nested_prop_atoms (normalise \<phi>)"
> begin
> 
> lemma af_letter\<^sub>F_nested_prop_atoms:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af_letter\<^sub>F \<phi> \<psi> \<nu>) \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)"
>   by (induction \<psi>) (auto simp: af_letter\<^sub>F_def, insert af_letter_nested_prop_atoms, blast+)
> 
> lemma af\<^sub>F_nested_prop_atoms:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af\<^sub>F \<phi> \<psi> w) \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)"
>   by (induction w rule: rev_induct) (insert af_letter\<^sub>F_nested_prop_atoms, auto)
> 
> lemma af_letter\<^sub>F_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (af_letter\<^sub>F \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
>   using af_letter\<^sub>F_nested_prop_atoms by blast
> 
> lemma af\<^sub>F_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>) \<Longrightarrow> range (af\<^sub>F \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (F\<^sub>n \<phi>)}"
>   using af\<^sub>F_nested_prop_atoms by blast
> 
> lemma af_letter\<^sub>G_nested_prop_atoms:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af_letter\<^sub>G \<phi> \<psi> \<nu>) \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)"
>   by (induction \<psi>) (auto simp: af_letter\<^sub>G_def, insert af_letter_nested_prop_atoms, blast+)
> 
> lemma af\<^sub>G_nested_prop_atoms:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> nested_prop_atoms (af\<^sub>G \<phi> \<psi> w) \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)"
>   by (induction w rule: rev_induct) (insert af_letter\<^sub>G_nested_prop_atoms, auto)
> 
> lemma af_letter\<^sub>G_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (af_letter\<^sub>G \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
>   using af_letter\<^sub>G_nested_prop_atoms by blast
> 
> lemma af\<^sub>G_range:
>   "nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>) \<Longrightarrow> range (af\<^sub>G \<phi> \<psi>) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (G\<^sub>n \<phi>)}"
>   using af\<^sub>G_nested_prop_atoms by blast
> 
> lemma af_letter\<^sub>\<nu>_snd_nested_prop_atoms_helper:
>   "snd p \<sim> false\<^sub>n \<Longrightarrow> nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms\<^sub>\<nu> (fst p) X"
>   "\<not> snd p \<sim> false\<^sub>n \<Longrightarrow> nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms (snd p)"
>   by (simp_all add: af_letter_nested_prop_atoms nested_prop_atoms\<^sub>\<nu>_def)
>      (metis GF_advice_nested_prop_atoms\<^sub>\<nu> af_letter_nested_prop_atoms nested_prop_atoms\<^sub>\<nu>_subset dual_order.trans nested_prop_atoms\<^sub>\<nu>_def normalise_nested_propos)
> 
> lemma af_letter\<^sub>\<nu>_fst_nested_prop_atoms:
>   "nested_prop_atoms (fst (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> nested_prop_atoms (fst p)"
>   by (simp add: af_letter_nested_prop_atoms)
> 
> lemma af_letter\<^sub>\<nu>_snd_nested_prop_atoms:
>   "nested_prop_atoms (snd (af_letter\<^sub>\<nu> X p \<nu>)) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> (nested_prop_atoms (snd p))"
>   using af_letter\<^sub>\<nu>_snd_nested_prop_atoms_helper by blast
> 
> lemma af_letter\<^sub>\<nu>_fst_range:
>   "range (fst \<circ> af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)}"
>   using af_letter\<^sub>\<nu>_fst_nested_prop_atoms by force
> 
> lemma af_letter\<^sub>\<nu>_snd_range:
>   "range (snd \<circ> af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
>   using af_letter\<^sub>\<nu>_snd_nested_prop_atoms by force
> 
> lemma af_letter\<^sub>\<nu>_range:
>   "range (af_letter\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
> proof -
>   have "range (af_letter\<^sub>\<nu> X p) \<subseteq> range (fst \<circ> af_letter\<^sub>\<nu> X p) \<times> range (snd \<circ> af_letter\<^sub>\<nu> X p)"
>     by (simp add: image_subset_iff mem_Times_iff)
> 
>   also have "\<dots> \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
>     using af_letter\<^sub>\<nu>_fst_range af_letter\<^sub>\<nu>_snd_range by blast
> 
>   finally show ?thesis .
> qed
> 
> lemma af\<^sub>\<nu>_fst_nested_prop_atoms:
>   "nested_prop_atoms (fst (af\<^sub>\<nu> X p w)) \<subseteq> nested_prop_atoms (fst p)"
>   by (induction w rule: rev_induct) (auto, insert af_letter_nested_prop_atoms, blast)
> 
> lemma af_letter_nested_prop_atoms\<^sub>\<nu>:
>   "nested_prop_atoms\<^sub>\<nu> (af_letter \<phi> \<nu>) X \<subseteq> nested_prop_atoms\<^sub>\<nu> \<phi> X"
>   by (induction \<phi>) (simp_all add: nested_prop_atoms\<^sub>\<nu>_def, blast+)
> 
> lemma af\<^sub>\<nu>_fst_nested_prop_atoms\<^sub>\<nu>:
>   "nested_prop_atoms\<^sub>\<nu> (fst (af\<^sub>\<nu> X p w)) X \<subseteq> nested_prop_atoms\<^sub>\<nu> (fst p) X"
>   by (induction w rule: rev_induct) (auto, insert af_letter_nested_prop_atoms\<^sub>\<nu>, blast)
> 
> lemma af\<^sub>\<nu>_fst_range:
>   "range (fst \<circ> af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)}"
>   using af\<^sub>\<nu>_fst_nested_prop_atoms by fastforce
> 
> lemma af\<^sub>\<nu>_snd_nested_prop_atoms:
>   "nested_prop_atoms (snd (af\<^sub>\<nu> X p w)) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> (nested_prop_atoms (snd p))"
> proof (induction w arbitrary: p rule: rev_induct)
>   case (snoc x xs)
> 
>   let ?p = "af\<^sub>\<nu> X p xs"
> 
>   have "nested_prop_atoms (snd (af\<^sub>\<nu> X p (xs @ [x]))) \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst ?p) X) \<union> (nested_prop_atoms (snd ?p))"
>     by (simp add: af_letter\<^sub>\<nu>_snd_nested_prop_atoms)
> 
>   then show ?case
>     using snoc af\<^sub>\<nu>_fst_nested_prop_atoms\<^sub>\<nu> by blast
> qed (simp add: nested_prop_atoms\<^sub>\<nu>_def)
> 
> lemma af\<^sub>\<nu>_snd_range:
>   "range (snd \<circ> af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
>   using af\<^sub>\<nu>_snd_nested_prop_atoms by fastforce
> 
> lemma af\<^sub>\<nu>_range:
>   "range (af\<^sub>\<nu> X p) \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
> proof -
>   have "range (af\<^sub>\<nu> X p) \<subseteq> range (fst \<circ> af\<^sub>\<nu> X p) \<times> range (snd \<circ> af\<^sub>\<nu> X p)"
>     by (simp add: image_subset_iff mem_Times_iff)
> 
>   also have "\<dots> \<subseteq> {\<psi>. nested_prop_atoms \<psi> \<subseteq> nested_prop_atoms (fst p)} \<times> {\<psi>. nested_prop_atoms \<psi> \<subseteq> (nested_prop_atoms\<^sub>\<nu> (fst p) X) \<union> nested_prop_atoms (snd p)}"
>     using af\<^sub>\<nu>_fst_range af\<^sub>\<nu>_snd_range by blast
> 
>   finally show ?thesis .
> qed
> 
> end
> 
> end
==========
LTL_to_GBA
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/LTL_to_GBA/All_Of_LTL_to_GBA.thy ../../AFPs/afp-2020/thys/LTL_to_GBA/All_Of_LTL_to_GBA.thy
3c3
< imports LTL_Stutter LTL_to_GBA LTL_to_GBA_impl
---
> imports LTL_to_GBA LTL_to_GBA_impl
Only in ../../AFPs/afp-2019/thys/LTL_to_GBA: LTL_Stutter.thy
==========
Markov_Models
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Markov_Models/Markov_Models_Auxiliary.thy ../../AFPs/afp-2020/thys/Markov_Models/Markov_Models_Auxiliary.thy
467c467
<   using continuous_on_eexp' by (rule borel_measurable_continuous_on1)
---
>   using continuous_on_eexp' by (rule borel_measurable_continuous_onI)
==========
Mason_Stothers
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Mason_Stothers/Mason_Stothers.thy ../../AFPs/afp-2020/thys/Mason_Stothers/Mason_Stothers.thy
151c151
<   fixes f p :: "'a :: {factorial_ring_gcd, field} poly"
---
>   fixes f p :: "'a :: field_gcd poly"
170c170
<   fixes p :: "'a :: {factorial_ring_gcd, field} poly"
---
>   fixes p :: "'a :: field_gcd poly"
205c205
<   fixes A B C :: "'a :: {factorial_ring_gcd, field} poly"
---
>   fixes A B C :: "'a :: field_gcd poly"
303c303
<   fixes A B C :: "'a :: {factorial_ring_gcd, field} poly"
---
>   fixes A B C :: "'a :: field_gcd poly"
324c324
<   fixes A B C :: "'a :: {factorial_ring_gcd, field_char_0} poly"
---
>   fixes A B C :: "'a :: {field_gcd, field_char_0} poly"
343c343
<   fixes A B C :: "'a :: {factorial_ring_gcd,field} poly"
---
>   fixes A B C :: "'a :: field_gcd poly"
373c373
<   fixes A B C :: "'a :: {factorial_ring_gcd,field_char_0} poly"
---
>   fixes A B C :: "'a :: {field_gcd,field_char_0} poly"
==========
MFOTL_Monitor
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/MFOTL_Monitor/Monitor_Code.thy ../../AFPs/afp-2020/thys/MFOTL_Monitor/Monitor_Code.thy
26c26
< lemma these_UNION: "Option.these (UNION A B) = UNION A (Option.these o B)"
---
> lemma these_UNION: "Option.these (\<Union> (B ` A)) = (\<Union> ((Option.these o B) ` A))"
==========
Minkowskis_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Minkowskis_Theorem/Minkowskis_Theorem.thy ../../AFPs/afp-2020/thys/Minkowskis_Theorem/Minkowskis_Theorem.thy
10c10
<   imports "HOL-Analysis.Analysis"
---
>   imports "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
==========
Monad_Memo_DP
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Monad_Memo_DP/transform/Transform.ML ../../AFPs/afp-2020/thys/Monad_Memo_DP/transform/Transform.ML
162c162
<    val lthy = Transform_Data.add_tmp_cmd_info (scope, tm, mem_locale_opt') lthy
---
>    val lthy = Transform_Data.add_tmp_cmd_info (Binding.reset_pos scope, tm, mem_locale_opt') lthy
==========
MonoidalCategory
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/MonoidalCategory/FreeMonoidalCategory.thy ../../AFPs/afp-2020/thys/MonoidalCategory/FreeMonoidalCategory.thy
2396c2396
<     interpretation \<F>\<^sub>SC: full_subcategory comp "\<lambda>f. ide f \<and> Diag (DOM f)"
---
>     interpretation \<F>\<^sub>SC: full_subcategory comp \<open>\<lambda>f. ide f \<and> Diag (DOM f)\<close>
2570c2570
<     interpretation S: full_inclusion_functor comp "\<lambda>f. ide f \<and> Diag (DOM f)" ..
---
>     interpretation S: full_inclusion_functor comp \<open>\<lambda>f. ide f \<and> Diag (DOM f)\<close> ..
2576c2576
<                         comp comp map SoD.map "\<lambda>a. mkarr (DOM a\<^bold>\<down>)"
---
>                         comp comp map SoD.map \<open>\<lambda>a. mkarr (DOM a\<^bold>\<down>)\<close>
2655c2655
<                         \<F>\<^sub>SC.comp \<F>\<^sub>SC.comp DoS.map \<F>\<^sub>SC.map "\<lambda>a. a"
---
>                         \<F>\<^sub>SC.comp \<F>\<^sub>SC.comp DoS.map \<F>\<^sub>SC.map \<open>\<lambda>a. a\<close>
2867c2867
<     interpretation EMC: elementary_monoidal_category comp tensor\<^sub>S \<I> "\<lambda>a. a" "\<lambda>a. a" assoc\<^sub>S
---
>     interpretation EMC: elementary_monoidal_category comp tensor\<^sub>S \<I> \<open>\<lambda>a. a\<close> \<open>\<lambda>a. a\<close> assoc\<^sub>S
3431c3431
<                        \<F>C.comp \<F>C.T\<^sub>F\<^sub>M\<^sub>C \<F>C.\<alpha> \<F>C.\<iota> D T\<^sub>D \<alpha>\<^sub>D \<iota>\<^sub>D "F o \<F>C.D"
---
>                        \<F>C.comp \<F>C.T\<^sub>F\<^sub>M\<^sub>C \<F>C.\<alpha> \<F>C.\<iota> D T\<^sub>D \<alpha>\<^sub>D \<iota>\<^sub>D \<open>F o \<F>C.D\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/MonoidalCategory/MonoidalCategory.thy ../../AFPs/afp-2020/thys/MonoidalCategory/MonoidalCategory.thy
296c296
<       interpret L: equivalence_of_categories C C F "\<lambda>f. \<I> \<otimes> f" \<eta> \<epsilon>
---
>       interpret L: equivalence_of_categories C C F \<open>\<lambda>f. \<I> \<otimes> f\<close> \<eta> \<epsilon>
389c389
<       interpret R: equivalence_of_categories C C F "\<lambda>f. f \<otimes> \<I>" \<eta> \<epsilon>
---
>       interpret R: equivalence_of_categories C C F \<open>\<lambda>f. f \<otimes> \<I>\<close> \<eta> \<epsilon>
539c539
<       interpret \<ll>: transformation_by_components C C L map "\<lambda>a. \<l>[a]"
---
>       interpret \<ll>: transformation_by_components C C L map \<open>\<lambda>a. \<l>[a]\<close>
554c554
<       interpret \<rho>: transformation_by_components C C R map "\<lambda>a. \<r>[a]"
---
>       interpret \<rho>: transformation_by_components C C R map \<open>\<lambda>a. \<r>[a]\<close>
1532c1532
<       interpret \<ll>: transformation_by_components C C L\<^sub>E\<^sub>M\<^sub>C map "\<lambda>a. \<l>[a]"
---
>       interpret \<ll>: transformation_by_components C C L\<^sub>E\<^sub>M\<^sub>C map \<open>\<lambda>a. \<l>[a]\<close>
1549c1549
<       interpret \<rho>: transformation_by_components C C R\<^sub>E\<^sub>M\<^sub>C map "\<lambda>a. \<r>[a]"
---
>       interpret \<rho>: transformation_by_components C C R\<^sub>E\<^sub>M\<^sub>C map \<open>\<lambda>a. \<r>[a]\<close>
1608c1608
<       interpret L: equivalence_functor C C "\<lambda>f. T\<^sub>E\<^sub>M\<^sub>C (cod \<iota>, f)"
---
>       interpret L: equivalence_functor C C \<open>\<lambda>f. T\<^sub>E\<^sub>M\<^sub>C (cod \<iota>, f)\<close>
1614c1614
<       interpret R: equivalence_functor C C "\<lambda>f. T\<^sub>E\<^sub>M\<^sub>C (f, cod \<iota>)"
---
>       interpret R: equivalence_functor C C \<open>\<lambda>f. T\<^sub>E\<^sub>M\<^sub>C (f, cod \<iota>)\<close>
1848c1848
<     interpret L: equivalence_functor C C "\<lambda>f. T (C.cod \<iota>, f)"
---
>     interpret L: equivalence_functor C C \<open>\<lambda>f. T (C.cod \<iota>, f)\<close>
1850c1850
<     interpret R: equivalence_functor C C "\<lambda>f. T (f, C.cod \<iota>)"
---
>     interpret R: equivalence_functor C C \<open>\<lambda>f. T (f, C.cod \<iota>)\<close>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/MonoidalCategory/MonoidalFunctor.thy ../../AFPs/afp-2020/thys/MonoidalCategory/MonoidalFunctor.thy
118c118
<       interpret L: equivalence_functor D D "\<lambda>f. (D.cod \<iota>\<^sub>1) \<otimes>\<^sub>D f"
---
>       interpret L: equivalence_functor D D \<open>\<lambda>f. (D.cod \<iota>\<^sub>1) \<otimes>\<^sub>D f\<close>
120c120
<         interpret L: "functor" D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f"
---
>         interpret L: "functor" D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close>
122,123c122,123
<         interpret L: endofunctor D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f" ..
<         interpret \<psi>x: natural_transformation D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f" "\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f" "\<lambda>f. \<psi> \<otimes>\<^sub>D f"
---
>         interpret L: endofunctor D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close> ..
>         interpret \<psi>x: natural_transformation D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close> \<open>\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f\<close> \<open>\<lambda>f. \<psi> \<otimes>\<^sub>D f\<close>
125c125
<         interpret \<psi>x: natural_isomorphism D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f" "\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f" "\<lambda>f. \<psi> \<otimes>\<^sub>D f"
---
>         interpret \<psi>x: natural_isomorphism D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close> \<open>\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f\<close> \<open>\<lambda>f. \<psi> \<otimes>\<^sub>D f\<close>
127,129c127,129
<         interpret \<ll>\<^sub>Do\<psi>x: vertical_composite D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f" "\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f" D.map
<                                            "\<lambda>f. \<psi> \<otimes>\<^sub>D f" D.\<ll> ..
<         interpret \<ll>\<^sub>Do\<psi>x: natural_isomorphism D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f" D.map \<ll>\<^sub>Do\<psi>x.map
---
>         interpret \<ll>\<^sub>Do\<psi>x: vertical_composite D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close> \<open>\<lambda>f. \<I>\<^sub>D \<otimes>\<^sub>D f\<close> D.map
>                                            \<open>\<lambda>f. \<psi> \<otimes>\<^sub>D f\<close> D.\<ll> ..
>         interpret \<ll>\<^sub>Do\<psi>x: natural_isomorphism D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close> D.map \<ll>\<^sub>Do\<psi>x.map
132c132
<         interpret L: equivalence_functor D D "\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f"
---
>         interpret L: equivalence_functor D D \<open>\<lambda>f. (F \<I>\<^sub>C) \<otimes>\<^sub>D f\<close>
138c138
<       interpret R: equivalence_functor D D "\<lambda>f. T\<^sub>D (f, D.cod \<iota>\<^sub>1)"
---
>       interpret R: equivalence_functor D D \<open>\<lambda>f. T\<^sub>D (f, D.cod \<iota>\<^sub>1)\<close>
140c140
<         interpret R: "functor" D D "\<lambda>f. T\<^sub>D (f, F \<I>\<^sub>C)"
---
>         interpret R: "functor" D D \<open>\<lambda>f. T\<^sub>D (f, F \<I>\<^sub>C)\<close>
142,143c142,143
<         interpret R: endofunctor D "\<lambda>f. T\<^sub>D (f, F \<I>\<^sub>C)" ..
<         interpret x\<psi>: natural_transformation D D "\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)" "\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D" "\<lambda>f. f \<otimes>\<^sub>D \<psi>"
---
>         interpret R: endofunctor D \<open>\<lambda>f. T\<^sub>D (f, F \<I>\<^sub>C)\<close> ..
>         interpret x\<psi>: natural_transformation D D \<open>\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)\<close> \<open>\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D\<close> \<open>\<lambda>f. f \<otimes>\<^sub>D \<psi>\<close>
145c145
<         interpret x\<psi>: natural_isomorphism D D "\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)" "\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D" "\<lambda>f. f \<otimes>\<^sub>D \<psi>"
---
>         interpret x\<psi>: natural_isomorphism D D \<open>\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)\<close> \<open>\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D\<close> \<open>\<lambda>f. f \<otimes>\<^sub>D \<psi>\<close>
147,149c147,149
<         interpret \<rho>\<^sub>Dox\<psi>: vertical_composite D D "\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)" "\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D" D.map
<                                                 "\<lambda>f. f \<otimes>\<^sub>D \<psi>" D.\<rho> ..
<         interpret \<rho>\<^sub>Dox\<psi>: natural_isomorphism D D "\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)" D.map \<rho>\<^sub>Dox\<psi>.map
---
>         interpret \<rho>\<^sub>Dox\<psi>: vertical_composite D D \<open>\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)\<close> \<open>\<lambda>f. f \<otimes>\<^sub>D \<I>\<^sub>D\<close> D.map
>                                                 \<open>\<lambda>f. f \<otimes>\<^sub>D \<psi>\<close> D.\<rho> ..
>         interpret \<rho>\<^sub>Dox\<psi>: natural_isomorphism D D \<open>\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)\<close> D.map \<rho>\<^sub>Dox\<psi>.map
152c152
<         interpret R: equivalence_functor D D "\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)"
---
>         interpret R: equivalence_functor D D \<open>\<lambda>f. f \<otimes>\<^sub>D (F \<I>\<^sub>C)\<close>
485c485
<                                               "\<lambda>f. \<phi> (snd f, fst f)"
---
>                                               \<open>\<lambda>f. \<phi> (snd f, fst f)\<close>
488c488
<                                            "\<lambda>f. \<phi> (snd f, fst f)"
---
>                                            \<open>\<lambda>f. \<phi> (snd f, fst f)\<close>
490c490
<     interpretation F': monoidal_functor C C'.T C'.\<alpha> \<iota>\<^sub>C D D'.T D'.\<alpha> \<iota>\<^sub>D F "\<lambda>f. \<phi> (snd f, fst f)"
---
>     interpretation F': monoidal_functor C C'.T C'.\<alpha> \<iota>\<^sub>C D D'.T D'.\<alpha> \<iota>\<^sub>D F \<open>\<lambda>f. \<phi> (snd f, fst f)\<close>
==========
Multi_Party_Computation
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/ETP_OT.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/ETP_OT.thy
1c1
< subsection \<open>Oblivious transfer constructed from ETPs\<close>
---
> subsection \<open> Oblivious transfer constructed from ETPs \<close>
32,34c32,34
< locale ETP_base =
<   fixes I :: "('index \<times> 'trap) spmf"
<     and domain :: "'index \<Rightarrow> 'range set"
---
> locale ETP_base = etp: etp I domain range F F\<^sub>i\<^sub>n\<^sub>v B
>   for I :: "('index \<times> 'trap) spmf" \<comment> \<open>samples index and trapdoor\<close>
>     and domain :: "'index \<Rightarrow> 'range set" 
36,42c36,38
<     and f :: "'index \<Rightarrow> ('range \<Rightarrow> 'range)"
<     and B :: "'index \<Rightarrow> 'range \<Rightarrow> bool"
<   assumes dom_eq_ran: "y \<in> set_spmf I \<longrightarrow> domain (fst y) = range (fst y)"
<     and finite_range: "y \<in> set_spmf I \<longrightarrow> finite (range (fst y))" 
<     and non_empty_range: "y \<in> set_spmf I \<longrightarrow> range (fst y) \<noteq> {}" 
<     and bij_betw: "y \<in> set_spmf I \<longrightarrow>  bij_betw (f (fst y)) (domain (fst y)) (range (fst y))"
<     and lossless_I: "lossless_spmf I"
---
>     and B :: "'index \<Rightarrow> 'range \<Rightarrow> bool" \<comment> \<open>hard core predicate\<close>
>     and F :: "'index \<Rightarrow> 'range \<Rightarrow> 'range"
>     and F\<^sub>i\<^sub>n\<^sub>v :: "'index \<Rightarrow> 'trap \<Rightarrow> 'range \<Rightarrow> 'range"
45,47d40
< sublocale etp: etp I domain range f B 
<   unfolding etp_def using dom_eq_ran finite_range non_empty_range bij_betw lossless_I by simp
< 
56,58c49,51
<     let (y\<^sub>\<sigma> :: 'range) = etp.F \<alpha> x\<^sub>\<sigma>;
<     let (x\<^sub>\<sigma> :: 'range) = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
<     let (x\<^sub>\<sigma>' :: 'range) = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
---
>     let (y\<^sub>\<sigma> :: 'range) = F \<alpha> x\<^sub>\<sigma>;
>     let (x\<^sub>\<sigma> :: 'range) = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
>     let (x\<^sub>\<sigma>' :: 'range) = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
65c58
<   have "(B \<alpha> (etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>') = (B \<alpha> (etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>') = m1)) = m1" 
---
>   have "(B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>') = (B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>') = m1)) = m1" 
68c61
<     by(auto simp add: protocol_def funct_OT_12_def Let_def etp.B_F_inv_rewrite bind_spmf_const etp.lossless_S lossless_I lossless_weight_spmfD split_def cong: bind_spmf_cong)
---
>     by(auto simp add: protocol_def funct_OT_12_def Let_def etp.B_F_inv_rewrite bind_spmf_const etp.lossless_S local.etp.lossless_I lossless_weight_spmfD split_def cong: bind_spmf_cong)
71c64
< text \<open>Party 1 views\<close>
---
> text \<open> Party 1 views \<close>
79c72
<     let y\<^sub>\<sigma> = etp.F \<alpha> x\<^sub>\<sigma>;
---
>     let y\<^sub>\<sigma> = F \<alpha> x\<^sub>\<sigma>;
83c76
<   by(simp add: R1_def lossless_I split_def etp.lossless_S Let_def)
---
>   by(simp add: R1_def local.etp.lossless_I split_def etp.lossless_S Let_def)
94c87
<   by(simp add: S1_def lossless_I split_def etp.lossless_S)
---
>   by(simp add: S1_def local.etp.lossless_I split_def etp.lossless_S)
96c89
< text \<open>Party 2 views\<close>
---
> text \<open> Party 2 views \<close>
104,106c97,99
<     let y\<^sub>\<sigma> = etp.F \<alpha> x\<^sub>\<sigma>;
<     let x\<^sub>\<sigma> = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
<     let x\<^sub>\<sigma>' = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
---
>     let y\<^sub>\<sigma> = F \<alpha> x\<^sub>\<sigma>;
>     let x\<^sub>\<sigma> = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
>     let x\<^sub>\<sigma>' = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
112c105
<   by(simp add: R2_def split_def lossless_I etp.lossless_S)
---
>   by(simp add: R2_def split_def local.etp.lossless_I etp.lossless_S)
119c112
<     let x\<^sub>\<sigma>' = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
---
>     let x\<^sub>\<sigma>' = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
125c118
<   by(simp add: S2_def lossless_I etp.lossless_S split_def)
---
>   by(simp add: S2_def local.etp.lossless_I etp.lossless_S split_def)
127c120
< text \<open>Security for Party 1\<close>
---
> text \<open> Security for Party 1 \<close>
138c131
<     y\<^sub>\<sigma> \<leftarrow> map_spmf (\<lambda> x\<^sub>\<sigma>. etp.F \<alpha> x\<^sub>\<sigma>) (etp.S \<alpha>);
---
>     y\<^sub>\<sigma> \<leftarrow> map_spmf (\<lambda> x\<^sub>\<sigma>. F \<alpha> x\<^sub>\<sigma>) (etp.S \<alpha>);
153c146
< text \<open>The adversary used in proof of security for party 2\<close>
---
> text \<open> The adversary used in proof of security for party 2 \<close>
168,173d160
< end 
< 
< locale ETP_ot_12 = ETP_base +
<   fixes HCP_ad :: real
< begin
< 
190c177
< text \<open>To prove security for party 2 we split the proof on the cases on party 2's input\<close>
---
> text \<open> To prove security for party 2 we split the proof on the cases on party 2's input \<close>
194c181
<   shows "spmf (R2 (b0,b1) \<sigma> \<bind> (D2 :: (bool \<times> 'a \<times> bool \<times> bool) \<Rightarrow> bool spmf)) True 
---
>   shows "spmf (R2 (b0,b1) \<sigma> \<bind> (D2 :: (bool \<times> 'index \<times> bool \<times> bool) \<Rightarrow> bool spmf)) True 
200c187
<     by(auto simp add: R2_def S2_def split_def etp.F_def etp.F\<^sub>i\<^sub>n\<^sub>v_def assms funct_OT_12_def cong: bind_spmf_cong_simp) 
---
>     by(auto simp add: R2_def S2_def split_def local.etp.F_f_inv assms funct_OT_12_def cong: bind_spmf_cong_simp) 
227c214
<     let \<beta>\<^sub>\<sigma>' = B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x); 
---
>     let \<beta>\<^sub>\<sigma>' = B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x); 
230c217
<     let b = B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x);
---
>     let b = B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x);
237c224
<     let \<beta>\<^sub>\<sigma>' = \<not> B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x); 
---
>     let \<beta>\<^sub>\<sigma>' = \<not> B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x); 
240c227
<     let b = B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x);
---
>     let b = B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x);
249c236
<     return_spmf (B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x') = b')}"
---
>     return_spmf (B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x') = b')}"
254c241
<       let x\<^sub>\<sigma>' = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
---
>       let x\<^sub>\<sigma>' = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
264,266c251,253
<       let y\<^sub>\<sigma> = etp.F \<alpha> x\<^sub>\<sigma>;
<       let x\<^sub>\<sigma> = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
<       let x\<^sub>\<sigma>' = etp.F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
---
>       let y\<^sub>\<sigma> = F \<alpha> x\<^sub>\<sigma>;
>       let x\<^sub>\<sigma> = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>;
>       let x\<^sub>\<sigma>' = F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y\<^sub>\<sigma>';
276c263
<     let \<beta>\<^sub>\<sigma>' = B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x);
---
>     let \<beta>\<^sub>\<sigma>' = B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x);
284c271
<     let \<beta>\<^sub>\<sigma>' = \<not> B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x);
---
>     let \<beta>\<^sub>\<sigma>' = \<not> B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x);
288c275
<         apply(auto simp add: D_false_def lossless_D lossless_I) 
---
>         apply(auto simp add: D_false_def lossless_D local.etp.lossless_I) 
312c299
<           apply(cases "B r (etp.f\<^sub>i\<^sub>n\<^sub>v r \<tau>)") 
---
>           apply(cases "B r (F\<^sub>i\<^sub>n\<^sub>v r r\<^sub>\<sigma> \<tau>)") 
326c313
<           apply(cases "B r (etp.f\<^sub>i\<^sub>n\<^sub>v r \<tau>)") 
---
>           apply(cases " B r (F\<^sub>i\<^sub>n\<^sub>v r r\<^sub>\<sigma> \<tau>)") 
333,334c320,321
<         have "spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x)) \<bind> (\<lambda>d. return_spmf (\<not> d)))))) True 
<                 = spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x)))))) False"
---
>         have "spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x)) \<bind> (\<lambda>d. return_spmf (\<not> d)))))) True 
>                 = spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x)))))) False"
337c324
<           have "?lhs = spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (etp.f\<^sub>i\<^sub>n\<^sub>v \<alpha> x)) \<bind> (\<lambda>d. return_spmf (d)))))) False"
---
>           have "?lhs = spmf (I \<bind> (\<lambda>(\<alpha>, \<tau>). etp.S \<alpha> \<bind> (\<lambda>x\<^sub>\<sigma>. etp.S \<alpha> \<bind> (\<lambda>x. D2 (\<sigma>, \<alpha>, B \<alpha> x\<^sub>\<sigma> = (\<not> (if \<sigma> then b1 else b0)), \<not> B \<alpha> (F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> x)) \<bind> (\<lambda>d. return_spmf (d)))))) False"
348c335
<         apply(auto  simp add: etp.F\<^sub>i\<^sub>n\<^sub>v_def etp.f\<^sub>i\<^sub>n\<^sub>v_def etp.F_def S2D_def R2D_def D_true_def D_false_def  assms split_def cong: bind_spmf_cong_simp)
---
>         apply(auto  simp add: local.etp.F_f_inv S2D_def R2D_def D_true_def D_false_def  assms split_def cong: bind_spmf_cong_simp)
364,365c351,353
< sublocale OT_12: sim_det_def R1 S1 R2 S2 funct_OT_12 protocol
<   unfolding sim_det_def_def by(simp add: lossless_R1 lossless_S1 lossless_funct_OT_12 lossless_R2 lossless_S2)
---
> sublocale OT_12: sim_det_def R1 S1 R2 S2 funct_OT_12 protocol 
>   unfolding sim_det_def_def 
>   by(simp add: lossless_R1 lossless_S1 lossless_R2 lossless_S2 funct_OT_12_def)
371,372c359,360
< lemma P1_security: "OT_12.inf_theoretic_P1 m1 m2" 
<   unfolding OT_12.inf_theoretic_P1_def using P1_security by simp 
---
> lemma P1_security_inf_the: "OT_12.perfect_sec_P1 m1 m2" 
>   unfolding OT_12.perfect_sec_P1_def using P1_security by simp 
400c388
< text \<open>We also consider the asymptotic case for security proofs\<close>
---
> text \<open> We also consider the asymptotic case for security proofs \<close>
406a395,396
>     and F :: "'index \<Rightarrow> 'range \<Rightarrow> 'range"
>     and F\<^sub>i\<^sub>n\<^sub>v :: "'index \<Rightarrow> 'trap \<Rightarrow> 'range \<Rightarrow> 'range"
408,409c398
<     and etp_advantage :: "nat \<Rightarrow> real"
<   assumes ETP_base: "\<And> n. ETP_ot_12 (I n) domain range f"
---
>   assumes ETP_base: "\<And> n. ETP_base (I n) domain range F F\<^sub>i\<^sub>n\<^sub>v"
412,413c401,402
< sublocale ETP_ot_12 "(I n)" domain range f B "(etp_advantage n)"  
<   using local.ETP_base  by simp
---
> sublocale ETP_base "(I n)" domain range 
>   using ETP_base  by simp
418,419c407,408
< lemma P1_sec_asym: "OT_12.inf_theoretic_P1 n m1 m2"
<   using P1_security by simp 
---
> lemma P1_sec_asym: "OT_12.perfect_sec_P1 n m1 m2"
>   using P1_security_inf_the by simp                                                                
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/ETP_RSA_OT.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/ETP_RSA_OT.thy
1c1
< subsubsection \<open>RSA instantiation\<close>
---
> subsubsection \<open> RSA instantiation \<close>
10a11
>   Uniform_Sampling
43a45,49
> lemma sample_coprime_e_gt_1:
>   assumes "e \<in> set_spmf (sample_coprime N)"
>   shows "e > 1"
>   using assms by(simp add: sample_coprime_def coprime_set_def)
> 
67,74d72
< definition sample_primes_excl :: "nat set \<Rightarrow> nat spmf"
<   where "sample_primes_excl P = spmf_of_set (prime_set - P)"
< 
< lemma lossless_sample_primes_excl: 
<   shows "lossless_spmf (sample_primes_excl {P})"
<   apply(simp add: sample_primes_excl_def finite_prime_set) 
<   using prime_set_gt_2 subset_singletonD by fastforce
< 
88a87,110
> definition sample_primes_excl :: "nat set \<Rightarrow> nat spmf"
>   where "sample_primes_excl P = spmf_of_set (prime_set - P)"
> 
> lemma lossless_sample_primes_excl: 
>   shows "lossless_spmf (sample_primes_excl {P})"
>   apply(simp add: sample_primes_excl_def finite_prime_set) 
>   using prime_set_gt_2 subset_singletonD by fastforce
> 
> definition sample_set_excl :: "nat set \<Rightarrow> nat set \<Rightarrow> nat spmf"
>   where "sample_set_excl Q P = spmf_of_set (Q - P)"
> 
> lemma set_spmf_sample_set_excl [simp]: 
>   assumes "finite (Q - P)" 
>   shows "set_spmf (sample_set_excl Q P) = (Q - P)"
>   unfolding  sample_set_excl_def 
>   by (metis set_spmf_of_set assms)+
> 
> lemma lossless_sample_set_excl: 
>   assumes "finite Q" 
>     and "card Q > 2"
>   shows "lossless_spmf (sample_set_excl Q {P})"
>   unfolding sample_set_excl_def
>   using assms subset_singletonD by fastforce
> 
90,91c112,113
<   shows "x \<in> set_spmf (sample_primes_excl {y}) \<Longrightarrow> x > 2" 
<   apply(simp add: finite_prime_set sample_primes_excl_def  prime_set_ass ) 
---
>   shows "x \<in> set_spmf (sample_set_excl prime_set {y}) \<Longrightarrow> x > 2" 
>   apply(simp add: finite_prime_set sample_set_excl_def  prime_set_ass ) 
95,96c117,118
<   shows "x \<in> set_spmf (sample_primes_excl {y}) \<Longrightarrow> prime x" 
<   apply (simp add: finite_prime_set sample_primes_excl_def)
---
>   shows "x \<in> set_spmf (sample_set_excl prime_set {y}) \<Longrightarrow> prime x" 
>   apply (simp add: finite_prime_set sample_set_excl_def)
101c123
<     and " y \<in> set_spmf (sample_primes_excl {x}) "
---
>     and " y \<in> set_spmf (sample_set_excl prime_set {x}) "
122c144
<     Q \<leftarrow> sample_primes_excl {P};
---
>     Q \<leftarrow> sample_set_excl prime_set {P};
130c152
<   by(auto simp add: I_def lossless_sample_primes lossless_sample_primes_excl Let_def sample_coprime_lem)
---
>   by(auto simp add: I_def lossless_sample_primes lossless_sample_set_excl finite_prime_set prime_set_gt_2 Let_def sample_coprime_lem)
132c154
< lemma set_spmf_I: 
---
> lemma set_spmf_I_N:
134c156,161
<   obtains P Q where "N = P * Q" and "P \<noteq> Q"  and "prime P" and "prime Q" and "coprime e ((P - 1)*(Q - 1))"
---
>   obtains P Q where "N = P * Q" 
>     and "P \<noteq> Q"  
>     and "prime P" 
>     and "prime Q" 
>     and "coprime e ((P - 1)*(Q - 1))" 
>     and "d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))"
136c163
<   using finite_prime_set mem_samp_primes_prime rsa_base.sample_primes_excl_def rsa_base_axioms sample_primes_def 
---
>   using finite_prime_set mem_samp_primes_prime sample_set_excl_def rsa_base_axioms sample_primes_def 
138a166,172
> lemma set_spmf_I_e_d: 
>   assumes "((N,e),d) \<in> set_spmf I" 
>   shows "e > 1" and "d > 1" 
>   using assms sample_coprime_e_gt_1  
>    apply(auto simp add: I_def Let_def) 
>   by (smt Euclidean_Division.pos_mod_sign Num.of_nat_simps(5) Suc_diff_1 bezw_inverse cong_def coprime_imp_gcd_eq_1 gr0I less_1_mult less_numeral_extra(2) mem_Collect_eq mod_by_0 mod_less more_arith_simps(6) nat_0 nat_0_less_mult_iff nat_int nat_neq_iff numerals(2) of_nat_0_le_iff of_nat_1 rsa_base.mem_samp_primes_gt_2 rsa_base_axioms set_spmf_sample_coprime zero_less_diff)
> 
151,152c185,189
< definition f :: "index \<Rightarrow> (nat \<Rightarrow> nat)"
<   where "f index x = x ^ (snd index) mod (fst index)"
---
> definition F :: "index \<Rightarrow> (nat \<Rightarrow> nat)"
>   where "F index x = x ^ (snd index) mod (fst index)"
> 
> definition F\<^sub>i\<^sub>n\<^sub>v :: "index \<Rightarrow> trap \<Rightarrow> nat \<Rightarrow> nat"
>   where "F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y = y ^ \<tau> mod (fst \<alpha>)" 
154c191
< text \<open>We must prove the RSA function is a bijection\<close>
---
> text \<open> We must prove the RSA function is a bijection \<close>
459c496
<   shows "bij_betw (f ((P * Q), e)) (range ((P * Q), e)) (range ((P * Q), e))"
---
>   shows "bij_betw (F ((P * Q), e)) (range ((P * Q), e)) (range ((P * Q), e))"
471c508
<   unfolding bij_betw_def f_def range_def by blast
---
>   unfolding bij_betw_def F_def range_def by blast
476c513
<   shows " bij_betw (f ((N), e)) (range ((N), e)) (range ((N), e))"
---
>   shows "bij_betw (F ((N), e)) (range ((N), e)) (range ((N), e))"
478c515
<   obtain P Q where "N = P * Q" and "bij_betw (f ((P*Q), e)) (range ((P*Q), e)) (range ((P*Q), e))"
---
>   obtain P Q where "N = P * Q" and "bij_betw (F ((P*Q), e)) (range ((P*Q), e)) (range ((P*Q), e))"
481c518
<       using set_spmf_I assms by blast
---
>       using set_spmf_I_N assms by blast
488,493c525,626
< sublocale etp: etp I domain range f B 
<   by (auto simp add: etp_def dom_eq_ran finite_range bij_betw1 lossless_I; metis Iio_eq_empty_iff bot_nat_def fst_conv mult_eq_0_iff not_prime_0 range_def set_spmf_I)
< 
< sublocale etp: ETP_base I domain range f B
<   apply(auto simp add: ETP_base_def dom_eq_ran finite_range local.etp.non_empty_range lossless_I)
<   using dom_eq_ran local.etp.non_empty_range bij_betw1 by auto
---
> lemma 
>   assumes "P dvd x"
> shows "[x = 0] (mod P)"
>   using assms cong_def by force
> 
> lemma rsa_inv: 
>   assumes d: "d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))"
>     and coprime: "coprime e ((P-1)*(Q-1))"
>     and prime_P: "prime (P::nat)" 
>     and prime_Q: "prime Q"   
>     and P_neq_Q: "P \<noteq> Q" 
>     and e_gt_1: "e > 1"
>     and d_gt_1: "d > 1" 
>   shows "((((x) ^ e) mod (P*Q)) ^ d) mod (P*Q) = x mod (P*Q)"
> proof(cases "x = 0 \<or> x = 1")
>   case True
>   then show ?thesis 
>     by (metis assms(6) assms(7) le_simps(1) nat_power_eq_Suc_0_iff neq0_conv not_one_le_zero numeral_nat(7) power_eq_0_iff power_mod)
> next
>   case False
>   hence x_gt_1: "x > 1" by simp
>   define z where "z = (x ^ e) ^ d - x"
>   hence z_gt_0: "z > 0"
>   proof-
>     have "(x ^ e) ^ d - x = x ^ (e * d) - x"
>       by (simp add: power_mult)
>     also have "... > 0" 
>       by (metis x_gt_1 e_gt_1 d_gt_1 le_neq_implies_less less_one linorder_not_less n_less_m_mult_n not_less_zero numeral_nat(7) power_increasing_iff power_one_right zero_less_diff) 
>     ultimately  show ?thesis using z_def by argo
>   qed
>   hence "[z = 0] (mod P)" 
>   proof(cases "[x = 0] (mod P)")
>     case True
>     then show ?thesis 
>     proof -
>       have "0 \<noteq> d * e"
>         by (metis (no_types) assms assms mult_is_0 not_one_less_zero)
>       then show ?thesis
>         by (metis (no_types) Groups.add_ac(2) True add_diff_inverse_nat cong_def cong_dvd_iff cong_mult_self_right dvd_0_right dvd_def dvd_trans mod_add_self2 more_arith_simps(5) nat_diff_split power_eq_if power_mult semiring_normalization_rules(7) z_def)
>     qed
>   next
>     case False
>     have "[e * d = 1] (mod ((P - 1) * (Q - 1)))" 
>       by (metis d bezw_inverse coprime coprime_imp_gcd_eq_1 nat_int)
>     hence "[e * d = 1] (mod (P - 1))" 
>       using assms cong_modulus_mult_nat by blast
>     then obtain k where k: "e*d = 1 + k*(P-1)" 
>       using ex_k_mod assms by force
>     hence "x ^ (e * d) = x * ((x ^ (P - 1)) ^ k)" 
>       by (metis power_add power_one_right mult.commute power_mult)
>     hence "[x ^ (e * d) = x * ((x ^ (P - 1)) ^ k)] (mod P)" 
>       using cong_def by simp
>     moreover have "[x ^ (P - 1) = 1] (mod P)"
>         using prime_P fermat_theorem False
>         by (simp add: cong_0_iff)
>     moreover have "[x ^ (e * d) = x * ((1) ^ k)] (mod P)"
>       by (metis \<open>x ^ (e * d) = x * (x ^ (P - 1)) ^ k\<close> calculation(2) cong_pow cong_scalar_left)
>     hence "[x ^ (e * d) = x] (mod P)" by simp
>     thus ?thesis using z_def z_gt_0 
>       by (simp add: cong_diff_iff_cong_0_nat power_mult)
>   qed
>   moreover have "[z = 0] (mod Q)" 
>   proof(cases "[x = 0] (mod Q)")
>     case True
>     then show ?thesis 
>     proof -
>       have "0 \<noteq> d * e"
>         by (metis (no_types) assms mult_is_0 not_one_less_zero)
>       then show ?thesis
>         by (metis (no_types) Groups.add_ac(2) True add_diff_inverse_nat cong_def cong_dvd_iff cong_mult_self_right dvd_0_right dvd_def dvd_trans mod_add_self2 more_arith_simps(5) nat_diff_split power_eq_if power_mult semiring_normalization_rules(7) z_def)
>     qed
>   next
>     case False
>     have "[e * d = 1] (mod ((P - 1) * (Q - 1)))" 
>       by (metis d bezw_inverse coprime coprime_imp_gcd_eq_1 nat_int)
>     hence "[e * d = 1] (mod (Q - 1))" 
>       using assms cong_modulus_mult_nat mult.commute by metis
>     then obtain k where k: "e*d = 1 + k*(Q-1)" 
>       using ex_k_mod assms by force
>     hence "x ^ (e * d) = x * ((x ^ (Q - 1)) ^ k)" 
>       by (metis power_add power_one_right mult.commute power_mult)
>     hence "[x ^ (e * d) = x * ((x ^ (Q - 1)) ^ k)] (mod P)" 
>       using cong_def by simp
>     moreover have "[x ^ (Q - 1) = 1] (mod Q)"
>         using prime_Q fermat_theorem False
>         by (simp add: cong_0_iff)
>     moreover have "[x ^ (e * d) = x * ((1) ^ k)] (mod Q)"
>       by (metis \<open>x ^ (e * d) = x * (x ^ (Q - 1)) ^ k\<close> calculation(2) cong_pow cong_scalar_left)
>     hence "[x ^ (e * d) = x] (mod Q)" by simp
>     thus ?thesis using z_def z_gt_0 
>       by (simp add: cong_diff_iff_cong_0_nat power_mult)
>   qed
>   ultimately have "Q dvd (x ^ e) ^ d - x"
>                   "P dvd (x ^ e) ^ d - x" 
>     using z_def assms cong_0_iff by blast +
>   hence "P * Q dvd ((x ^ e) ^ d - x)" 
>     using assms divides_mult primes_coprime_nat by blast
>   hence "[(x ^ e) ^ d = x] (mod (P * Q))"
>     using z_gt_0 cong_altdef_nat z_def by auto
>   thus ?thesis 
>     by (simp add: cong_def power_mod)
> qed
495d627
< end 
497c629,652
< text\<open>After proving the RSA collection is an ETP the proofs of security come easily from the general proofs.\<close>
---
> lemma rsa_inv_set_spmf_I:
>   assumes "((N, e), d) \<in> set_spmf I"
>   shows "((((x::nat) ^ e) mod N) ^ d) mod N = x mod N"
> proof-
>   obtain P Q where "N = P * Q" and "d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))"  
>     and "prime P" 
>     and "prime Q" 
>     and "coprime e ((P - 1)*(Q - 1))" 
>     and "P \<noteq> Q"
>     using assms set_spmf_I_N 
>     by blast
>   moreover have "e > 1" and "d > 1" using set_spmf_I_e_d assms by auto
>   ultimately show ?thesis using rsa_inv by blast
> qed
>   
> sublocale etp_rsa: etp I domain range F F\<^sub>i\<^sub>n\<^sub>v 
>   unfolding etp_def apply(auto simp add: etp_def dom_eq_ran finite_range bij_betw1 lossless_I)
>    apply (metis fst_conv lessThan_iff mem_simps(2) nat_0_less_mult_iff prime_gt_0_nat range_def set_spmf_I_N)
>   apply(auto simp add: F_def F\<^sub>i\<^sub>n\<^sub>v_def) using rsa_inv_set_spmf_I 
>   by (simp add: range_def)
> 
> sublocale etp: ETP_base I domain range B F F\<^sub>i\<^sub>n\<^sub>v
>   unfolding ETP_base_def 
>   by (simp add: etp_rsa.etp_axioms)
499,501d653
< locale rsa_proof = rsa_base + 
<   fixes HCP_ad :: real
< begin
503,504c655
< sublocale etp_proof: ETP_ot_12 I domain range f 
<    by (auto simp add: etp.ETP_base_axioms ETP_ot_12_def)
---
> text\<open>After proving the RSA collection is an ETP the proofs of security come easily from the general proofs.\<close>
506,507c657,658
< lemma "sim_det_def.correctness funct_OT_12 etp.protocol m1 m2" 
<   by (metis etp.correctness etp_proof.OT_12.correctness_def surj_pair)
---
> lemma correctness_rsa: "etp.OT_12.correctness m1 m2"
>   by (rule local.etp.correct)
509,510c660,661
< lemma P1_sec: "sim_det_def.inf_theoretic_P1 etp.R1 etp.S1 funct_OT_12 m1 m2" 
<   using local.etp_proof.P1_security by auto
---
> lemma P1_security_rsa: "etp.OT_12.perfect_sec_P1 m1 m2" 
>   by(rule local.etp.P1_security_inf_the)
512c663
< lemma P2_sec:
---
> lemma P2_security_rsa:
514,516c665,667
<     and "\<And>b\<^sub>\<sigma>. local.etp.HCP_adv etp.\<A> m2 b\<^sub>\<sigma> D \<le> HCP_ad"
<   shows "sim_det_def.adv_P2 etp.R2 etp.S2 funct_OT_12 m1 m2 D \<le> 2 * HCP_ad"
<   using assms etp_proof.P2_security by blast
---
>     and "\<And>b\<^sub>\<sigma>. local.etp_rsa.HCP_adv etp.\<A> m2 b\<^sub>\<sigma> D \<le> HCP_ad"
>   shows "etp.OT_12.adv_P2 m1 m2 D \<le> 2 * HCP_ad"
>   by(simp add: local.etp.P2_security assms)
523,524c674
<     and hcp_advantage :: "nat \<Rightarrow> real"
<   assumes rsa_proof_assm: "\<And> n. rsa_proof (prime_set n)"
---
>   assumes rsa_proof_assm: "\<And> n. rsa_base (prime_set n)"
527c677
< sublocale rsa_proof "(prime_set n)" B "(hcp_advantage n)"  
---
> sublocale rsa_base "(prime_set n)" B  
530,531c680,685
< lemma P1_sec_asym: "sim_det_def.inf_theoretic_P1 (etp.R1 n) (etp.S1 n) funct_OT_12 m1 m2" 
<   using P1_sec by simp 
---
> lemma correctness_rsa_asymp: 
>   shows "etp.OT_12.correctness n m1 m2"
>   by(rule correctness_rsa)
> 
> lemma P1_sec_asymp: "etp.OT_12.perfect_sec_P1 n m1 m2" 
>   by(rule local.P1_security_rsa)
536,537c690,691
<     and hcp_adv_bound:  "\<forall>b\<^sub>\<sigma> n. local.etp.HCP_adv n etp.\<A> m2 b\<^sub>\<sigma> D \<le> hcp_advantage n"
<   shows "negligible (\<lambda> n. sim_det_def.adv_P2  (etp.R2 n) (etp.S2 n) funct_OT_12 m1 m2 D)"
---
>     and hcp_adv_bound:  "\<forall>b\<^sub>\<sigma> n. local.etp_rsa.HCP_adv n etp.\<A> m2 b\<^sub>\<sigma> D \<le> hcp_advantage n"
>   shows "negligible (\<lambda> n. etp.OT_12.adv_P2 n m1 m2 D)"
541,545c695,698
<   moreover have "\<bar>sim_det_def.adv_P2  (etp.R2 n) (etp.S2 n) funct_OT_12 m1 m2 D\<bar> 
<             = sim_det_def.adv_P2 (etp.R2 n) (etp.S2 n) funct_OT_12 m1 m2 D" 
<     for n unfolding sim_det_def.adv_P2_def etp_proof.OT_12.adv_P2_def by linarith
<   moreover have "sim_det_def.adv_P2 (etp.R2 n) (etp.S2 n) funct_OT_12 m1 m2 D \<le> 2 * hcp_advantage n" for n
<     using P2_sec assms by blast
---
>   moreover have "\<bar>etp.OT_12.adv_P2 n m1 m2 D\<bar> = etp.OT_12.adv_P2 n m1 m2 D" 
>     for n unfolding sim_det_def.adv_P2_def local.etp.OT_12.adv_P2_def by linarith
>   moreover have "etp.OT_12.adv_P2 n m1 m2 D \<le> 2 * hcp_advantage n" for n
>     using P2_security_rsa assms by blast
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/ETP.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/ETP.thy
1c1
< subsection \<open>ETP definitions\<close>
---
> subsection \<open> ETP definitions \<close>
3,4c3,4
< text \<open>We define Extended Trapdoor Permutations (ETPs) following \cite{DBLP:books/sp/17/Lindell17} and \cite{DBLP:books/cu/Goldreich2004}. 
< In particular we consider the property of Hard Core Predicates (HCPs).\<close>
---
> text \<open> We define Extended Trapdoor Permutations (ETPs) following \cite{DBLP:books/sp/17/Lindell17} and \cite{DBLP:books/cu/Goldreich2004}. 
> In particular we consider the property of Hard Core Predicates (HCPs). \<close>
18c18,19
<     and f :: "'index \<Rightarrow> ('range \<Rightarrow> 'range)" \<comment> \<open>permutation\<close>
---
>     and F :: "'index \<Rightarrow> ('range \<Rightarrow> 'range)" \<comment> \<open>permutation\<close>
>     and F\<^sub>i\<^sub>n\<^sub>v :: "'index \<Rightarrow> 'trap \<Rightarrow> 'range \<Rightarrow> 'range" \<comment> \<open>must be efficiently computable\<close>
23c24
<     and bij_betw: "y \<in> set_spmf I \<longrightarrow> bij_betw (f (fst y)) (domain (fst y)) (range (fst y))"
---
>     and bij_betw: "y \<in> set_spmf I \<longrightarrow> bij_betw (F (fst y)) (domain (fst y)) (range (fst y))"
24a26
>     and F_f_inv: "y \<in> set_spmf I \<longrightarrow> x \<in> range (fst y) \<longrightarrow> F\<^sub>i\<^sub>n\<^sub>v (fst y) (snd y) (F (fst y) x) = x"
36c38,39
< definition "f\<^sub>i\<^sub>n\<^sub>v \<alpha> = Hilbert_Choice.inv_into (range \<alpha>) (f \<alpha>)"
---
> lemma f_inj_on: "y \<in> set_spmf I \<longrightarrow> inj_on (F (fst y)) (range (fst y))" 
>   by(metis bij_betw_def bij_betw dom_eq_ran bij_betw_def bij_betw dom_eq_ran) 
38,41c41
< lemma f_inj_on: "y \<in> set_spmf I \<longrightarrow> inj_on (f (fst y)) (range (fst y))" 
<   by (metis bij_betw_def bij_betw dom_eq_ran bij_betw_def bij_betw dom_eq_ran)
< 
< lemma range_f: "y \<in> set_spmf I \<longrightarrow>  x \<in> range (fst y) \<longrightarrow> f (fst y) x \<in> range (fst y)" 
---
> lemma range_f: "y \<in> set_spmf I \<longrightarrow>  x \<in> range (fst y) \<longrightarrow> F (fst y) x \<in> range (fst y)" 
44,45c44,45
< lemma f_inv_f [simp]: "y \<in> set_spmf I \<longrightarrow> x \<in> range (fst y) \<longrightarrow> f\<^sub>i\<^sub>n\<^sub>v (fst y) (f (fst y) x) = x"
<   by (metis bij_betw bij_betw_inv_into_left dom_eq_ran f\<^sub>i\<^sub>n\<^sub>v_def)
---
> lemma f_inv_f [simp]: "y \<in> set_spmf I \<longrightarrow> x \<in> range (fst y) \<longrightarrow> F\<^sub>i\<^sub>n\<^sub>v (fst y) (snd y) (F (fst y) x) = x"
>   by (metis bij_betw bij_betw_inv_into_left dom_eq_ran F_f_inv)
47c47
< lemma f_inv_f' [simp]: "y \<in> set_spmf I \<longrightarrow> x \<in> range (fst y) \<longrightarrow> Hilbert_Choice.inv_into (range (fst y)) (f (fst y)) (f (fst y) x) = x" 
---
> lemma f_inv_f' [simp]: "y \<in> set_spmf I \<longrightarrow> x \<in> range (fst y) \<longrightarrow> Hilbert_Choice.inv_into (range (fst y)) (F (fst y)) (F (fst y) x) = x" 
49,61d48
<   
< definition F :: "'index \<Rightarrow> 'range \<Rightarrow> 'range"
<   where "F \<alpha> x = f \<alpha> x"
< 
< definition F\<^sub>i\<^sub>n\<^sub>v :: "'index \<Rightarrow> 'trap \<Rightarrow> 'range \<Rightarrow> 'range"
<   where "F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y = Hilbert_Choice.inv_into (range \<alpha>) (f \<alpha>) y"
< 
< lemma F_f_inv: "F\<^sub>i\<^sub>n\<^sub>v \<alpha> \<tau> y = f\<^sub>i\<^sub>n\<^sub>v \<alpha> y"
<   by(simp add: F\<^sub>i\<^sub>n\<^sub>v_def f\<^sub>i\<^sub>n\<^sub>v_def)
< 
< lemma F_invF [simp]: "x \<in> set_spmf I \<longrightarrow>  y \<in> range (fst x) \<longrightarrow> F (fst x) (F\<^sub>i\<^sub>n\<^sub>v (fst x) \<tau> y) = y"
<   apply(simp add: F_def F\<^sub>i\<^sub>n\<^sub>v_def)
<   by (metis bij_betw bij_betw_inv_into_right dom_eq_ran)
73c60
<   also have "map_spmf (\<lambda> x. f (fst y) x) (spmf_of_set (range (fst y))) = spmf_of_set ((\<lambda> x. f (fst y) x) ` (range (fst y)))"
---
>   also have "map_spmf (\<lambda> x. F (fst y) x) (spmf_of_set (range (fst y))) = spmf_of_set ((\<lambda> x. F (fst y) x) ` (range (fst y)))"
76c63
<   also have "(\<lambda> x. f (fst y) x) ` (range (fst y)) = range (fst y)"
---
>   also have "(\<lambda> x. F (fst y) x) ` (range (fst y)) = range (fst y)"
80c67
<   finally show ?thesis by(simp add: rhs F_def)
---
>   finally show ?thesis by(simp add: rhs)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/GMW.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/GMW.thy
29c29
<     and P2_OT_12_inf_theoretic: "sim_det_def.inf_theoretic_P2 R2_14_OT S2_14_OT funct_14_OT M C" \<comment> \<open>information theoretic security for party 2 in the 1-out-of-4 OT\<close>
---
>     and P2_OT_12_inf_theoretic: "sim_det_def.perfect_sec_P2 R2_14_OT S2_14_OT funct_14_OT M C" \<comment> \<open>information theoretic security for party 2 in the 1-out-of-4 OT\<close>
48c48
<   using P2_OT_12_inf_theoretic sim_det_def.inf_theoretic_P2_def OT_14_sim.inf_theoretic_P2_def by auto
---
>   using P2_OT_12_inf_theoretic sim_det_def.perfect_sec_P2_def OT_14_sim.perfect_sec_P2_def by auto
163,164c163,164
< lemma "xor_sim_det.inf_theoretic_P1 m1 m2"
<   by(simp add: xor_sim_det.inf_theoretic_P1_def P1_xor_inf_th)
---
> lemma "xor_sim_det.perfect_sec_P1 m1 m2"
>   by(simp add: xor_sim_det.perfect_sec_P1_def P1_xor_inf_th)
166,167c166,167
< lemma "xor_sim_det.inf_theoretic_P2 m1 m2"
<   by(simp add: xor_sim_det.inf_theoretic_P2_def P2_xor_inf_th)
---
> lemma "xor_sim_det.perfect_sec_P2 m1 m2"
>   by(simp add: xor_sim_det.perfect_sec_P2_def P2_xor_inf_th)
405c405
< lemma and_P2_security: "and_secret_sharing.inf_theoretic_P2 m1 m2"
---
> lemma and_P2_security: "and_secret_sharing.perfect_sec_P2 m1 m2"
414c414
<     by(simp add: and_secret_sharing.inf_theoretic_P2_def; metis  prod.collapse)
---
>     by(simp add: and_secret_sharing.perfect_sec_P2_def; metis  prod.collapse)
465,466c465,466
< lemma "xor_sim_det.inf_theoretic_P1 m1 m2" 
<   by (simp add: P1_xor_inf_th xor_sim_det.inf_theoretic_P1_def)
---
> lemma "xor_sim_det.perfect_sec_P1 m1 m2" 
>   by (simp add: P1_xor_inf_th xor_sim_det.perfect_sec_P1_def)
468,469c468,469
< lemma "xor_sim_det.inf_theoretic_P2 m1 m2"
<   by (simp add: P2_xor_inf_th xor_sim_det.inf_theoretic_P2_def)
---
> lemma "xor_sim_det.perfect_sec_P2 m1 m2"
>   by (simp add: P2_xor_inf_th xor_sim_det.perfect_sec_P2_def)
481c481
< lemma and_P2_security: "and_secret_sharing.inf_theoretic_P2 n m1 m2" 
---
> lemma and_P2_security: "and_secret_sharing.perfect_sec_P2 n m1 m2" 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/Malicious_Defs.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/Malicious_Defs.thy
82c82
< definition "inf_theoretic_mal_sec_P1 x y z S \<A> \<longleftrightarrow> (ideal_view_1 x y z S \<A> = P1_real_view x y z \<A>)"
---
> definition "perfect_sec_P1 x y z S \<A> \<longleftrightarrow> (ideal_view_1 x y z S \<A> = P1_real_view x y z \<A>)"
102c102
< definition "inf_theoretic_mal_sec_P2 x y z S \<A> \<longleftrightarrow> (ideal_view_2 x y z S \<A> = P2_real_view x y z \<A>)"
---
> definition "perfect_sec_P2 x y z S \<A> \<longleftrightarrow> (ideal_view_2 x y z S \<A> = P2_real_view x y z \<A>)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/Malicious_OT.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/Malicious_OT.thy
1406,1407c1406,1407
<   shows "mal_def.inf_theoretic_mal_sec_P2 (x0,x1) \<sigma> z (P2_S1, P2_S2) \<A>"
<   unfolding malicious_base.inf_theoretic_mal_sec_P2_def
---
>   shows "mal_def.perfect_sec_P2 (x0,x1) \<sigma> z (P2_S1, P2_S2) \<A>"
>   unfolding malicious_base.perfect_sec_P2_def
1537c1537
<   shows "mal_def.inf_theoretic_mal_sec_P2 n (x0,x1) \<sigma> z (P2_S1 n, P2_S2 n) \<A>"
---
>   shows "mal_def.perfect_sec_P2 n (x0,x1) \<sigma> z (P2_S1 n, P2_S2 n) \<A>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/Noar_Pinkas_OT.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/Noar_Pinkas_OT.thy
234c234
<   shows "sim_def.inf_theoretic_P2 (m0,m1) \<sigma>"
---
>   shows "sim_def.perfect_sec_P2 (m0,m1) \<sigma>"
324c324
<     by(simp add: sim_def.inf_theoretic_P2_def funct_OT_12_def)
---
>     by(simp add: sim_def.perfect_sec_P2_def funct_OT_12_def)
358c358
<   shows "sim_def.inf_theoretic_P2 \<eta> (m0,m1) \<sigma>"
---
>   shows "sim_def.perfect_sec_P2 \<eta> (m0,m1) \<sigma>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/OT14.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/OT14.thy
26c26
<     and inf_th_OT12_P2:  "sim_det_def.inf_theoretic_P2 R2_OT12 S2_OT12 funct_OT12 (m0,m1) \<sigma>" \<comment> \<open>information theoretic security for party 2\<close>
---
>     and inf_th_OT12_P2:  "sim_det_def.perfect_sec_P2 R2_OT12 S2_OT12 funct_OT12 (m0,m1) \<sigma>" \<comment> \<open>information theoretic security for party 2\<close>
57c57
<   using inf_th_OT12_P2 OT_12_sim.inf_theoretic_P2_def by blast
---
>   using inf_th_OT12_P2 OT_12_sim.perfect_sec_P2_def by blast
696,697c696,697
< lemma OT_14_P2_sec: "OT_14.inf_theoretic_P2 m1 m2"
<   unfolding OT_14.inf_theoretic_P2_def
---
> lemma OT_14_P2_sec: "OT_14.perfect_sec_P2 m1 m2"
>   unfolding OT_14.perfect_sec_P2_def
735c735
< theorem OT_14_P2_asym_sec: "OT_14.inf_theoretic_P2 R2_OT12 n m1 m2"
---
> theorem OT_14_P2_asym_sec: "OT_14.perfect_sec_P2 R2_OT12 n m1 m2"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/Secure_Multiplication.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/Secure_Multiplication.thy
320c320,321
<       by (metis add.commute add_lessD1 add_mult_distrib b left_diff_distrib' less_imp_le linordered_field_class.sign_simps(18) linordered_semidom_class.add_diff_inverse mult.commute not_less)
---
>       using b by (simp add: algebra_simps)
>         (metis add_diff_inverse_nat diff_diff_left diff_mult_distrib2 less_imp_add_positive mult.commute not_add_less1 zero_less_diff)
465c466
<   shows "sim_non_det_def.inf_theoretic_P2 x y"
---
>   shows "sim_non_det_def.perfect_sec_P2 x y"
560c561
<   then show ?thesis by(simp add: sim_non_det_def.inf_theoretic_P2_def)
---
>   then show ?thesis by(simp add: sim_non_det_def.perfect_sec_P2_def)
570c571
<   using assms 
---
>   using assms
706c707
<   shows "sim_non_det_def.inf_theoretic_P1 x y"
---
>   shows "sim_non_det_def.perfect_sec_P1 x y"
774c775
<   thus ?thesis by(simp add: sim_non_det_def.inf_theoretic_P1_def)
---
>   thus ?thesis by(simp add: sim_non_det_def.perfect_sec_P1_def)
789c790
<   shows "sim_non_det_def.inf_theoretic_P1 n x y"
---
>   shows "sim_non_det_def.perfect_sec_P1 n x y"
794c795
<   shows "sim_non_det_def.inf_theoretic_P2 n x y"
---
>   shows "sim_non_det_def.perfect_sec_P2 n x y"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Multi_Party_Computation/Semi_Honest_Def.thy ../../AFPs/afp-2020/thys/Multi_Party_Computation/Semi_Honest_Def.thy
37c37
< definition "inf_theoretic_P1 m1 m2 \<equiv> (R1 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). S1 m1 s1))"
---
> definition "perfect_sec_P1 m1 m2 \<equiv> (R1 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). S1 m1 s1))"
43c43
< definition "inf_theoretic_P2 m1 m2 \<equiv> (R2 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). S2 m2 s2))"
---
> definition "perfect_sec_P2 m1 m2 \<equiv> (R2 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). S2 m2 s2))"
158c158
< definition "inf_theoretic_P1 m1 m2 \<equiv> (R1 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). Ideal1 m1 m2 s1))"
---
> definition "perfect_sec_P1 m1 m2 \<equiv> (R1 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). Ideal1 m1 m2 s1))"
163c163
< definition "inf_theoretic_P2 m1 m2 \<equiv> (R2 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). Ideal2 m2 m1 s2))"
---
> definition "perfect_sec_P2 m1 m2 \<equiv> (R2 m1 m2 = funct m1 m2 \<bind> (\<lambda> (s1, s2). Ideal2 m2 m1 s2))"
==========
Nested_Multisets_Ordinals
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nested_Multisets_Ordinals/Multiset_More.thy ../../AFPs/afp-2020/thys/Nested_Multisets_Ordinals/Multiset_More.thy
969a970,985
> subsubsection \<open>More on multiset order\<close>
> 
> lemma less_multiset_doubletons:
>   assumes
>     "y <  t \<or>  y <  s"  
>     "x <  t \<or>  x <  s" 
>   shows 
>     "{# y,  x#} < {# t,  s#}" 
>   unfolding less_multiset\<^sub>D\<^sub>M
> proof (intro exI)
>   let ?X = "{# t,  s#}"
>   let ?Y = "{#y, x#}"
>   show "?X \<noteq> {#} \<and> ?X \<subseteq># {#t, s#} \<and> {#y, x#} = {#t, s#} - ?X + ?Y \<and> (\<forall>k. k \<in># ?Y \<longrightarrow> (\<exists>a. a \<in># ?X \<and> k < a))"
>     using add_eq_conv_diff assms(1) assms(2) by auto
> qed
> 
==========
Network_Security_Policy_Verification
Only in ../../AFPs/afp-2019/thys/Network_Security_Policy_Verification/Lib: ML_GraphViz_Config.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Network_Security_Policy_Verification/Lib/ML_GraphViz.thy ../../AFPs/afp-2020/thys/Network_Security_Policy_Verification/Lib/ML_GraphViz.thy
2c2
< imports ML_GraphViz_Config
---
> imports Main
5,11d4
< 
< ML_val\<open>
<   val _ = writeln ("using `"^Graphviz_Platform_Config.executable_pdf_viewer^"` as pdf viewer and `"^
<                    Graphviz_Platform_Config.executable_dot^"` to render graphs.");
< \<close>
< 
< 
43c36,37
< val open_viewer = Unsynchronized.ref OpenImmediately
---
> val open_viewer = (* FIXME avoid mutable state *)
>   Unsynchronized.ref (if getenv "ISABELLE_DOT" = "" then DoNothing else OpenImmediately)
47,53d40
< fun write_to_tmpfile (t: string): Path.T = 
<   let 
<     val p = Isabelle_System.create_tmp_path "graphviz" "graph_tmp.dot"
<   in
<     writeln ("using tmpfile " ^ Path.print p); File.write p (t^"\n"); p
<   end
< 
105,115c92,94
< 
<   (* viz is graphiz command, e.g. dot
<      viewer is a PDF viewer, e.g. xdg-open
<      retuns return code of bash command.
<      noticeable side effect: generated pdf file is not deleted (maybe still open in editor)*)
<   fun paint_graph (viewer: string) (viz: string) (f: Path.T) =
<     if (Isabelle_System.bash ("which "^viz)) <> 0 then
<       (*TODO: `which` on windows?*)
<       error "ML_GraphViz: Graphviz command not found"
<     else if (Isabelle_System.bash ("which "^viewer)) <> 0 then
<       error "ML_GraphViz: viewer command not found"
---
>   fun display_graph graph =
>     if getenv "ISABELLE_DOT" = "" then
>       error "Missing $ISABELLE_DOT settings variable (Graphviz \"dot\" executable)"
117,133c96,107
<       let
<         val base = Path.base f;
<         val base_pdf = base |> Path.ext "pdf";
<         (*First cd to the temp directory, then only call the commands with relative paths. 
<           This is a Windows workaround if the Windows (not cygwin) version of graphviz is installed:
<             It does not understand paths such as /tmp/isabelle/.., it wants C:\tmp\..
<           Hence, we cd to the tmp directory and only use relative filenames henceforth.*)
<         val cmd =
<           "cd " ^ File.bash_path (Path.dir f) ^ "; " ^
<           viz ^ " -o "^ File.bash_path base_pdf ^ " -Tpdf " ^ File.bash_path base ^
<           " && " ^ viewer ^ " " ^ File.bash_path base_pdf;
<       in
<         writeln ("executing: "^cmd);
<         Isabelle_System.bash cmd;
<         File.rm f (*cleanup dot file, PDF file will still exist*)
<         (*some pdf viewers do not like it if we delete the pdf file they are currently displaying*)
<       end
---
>       Isabelle_System.with_tmp_file "graphviz" "dot" (fn graph_file =>
>         let
>           val _ = File.write graph_file graph;
>           val pdf_file = Path.explode "$ISABELLE_HOME_USER/graphviz.pdf";
>           val _ =
>             (Isabelle_System.bash o cat_lines)
>              ["set -e",
>               "cd " ^ File.bash_path (Path.dir graph_file),
>               "\"$ISABELLE_DOT\" -o " ^ Bash_Syntax.string (File.platform_path pdf_file) ^
>                 " -Tpdf " ^ Bash_Syntax.string (File.platform_path graph_file),
>               "\"$PDF_VIEWER\" " ^ File.bash_path pdf_file ^ " &"];
>         in () end);
155,157c129
<       val execute_command = fn _ => apply_dot_header header formatted_edges
<           |> write_to_tmpfile
<           |> paint_graph Graphviz_Platform_Config.executable_pdf_viewer Graphviz_Platform_Config.executable_dot;
---
>       fun execute_command () = display_graph (apply_dot_header header formatted_edges);
==========
Neumann_Morgenstern_Utility
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Neumann_Morgenstern_Utility/PMF_Composition.thy ../../AFPs/afp-2020/thys/Neumann_Morgenstern_Utility/PMF_Composition.thy
148c148
<       by (simp add: linordered_field_class.sign_simps(37))
---
>       by (simp add: algebra_simps)
==========
Nominal2
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nominal2/nominal_dt_quot.ML ../../AFPs/afp-2020/thys/Nominal2/nominal_dt_quot.ML
210c210
<     val ctxt' = Variable.auto_fixes goal ctxt
---
>     val ctxt' = Proof_Context.augment goal ctxt
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nominal2/nominal_function_core.ML ../../AFPs/afp-2020/thys/Nominal2/nominal_function_core.ML
358c358
<       |> Thm.close_derivation
---
>       |> Thm.close_derivation \<^here>
385c385
<     |> map (Thm.close_derivation)
---
>     |> map (Thm.close_derivation \<^here>)
409c409
<     |> map (Thm.close_derivation)
---
>     |> map (Thm.close_derivation \<^here>)
590c590
<       |> Thm.close_derivation
---
>       |> Thm.close_derivation \<^here>
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nominal2/nominal_function.ML ../../AFPs/afp-2020/thys/Nominal2/nominal_function.ML
149c149
<           cont lthy (Thm.close_derivation proof)
---
>           cont lthy (Thm.close_derivation \<^here> proof)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nominal2/nominal_termination.ML ../../AFPs/afp-2020/thys/Nominal2/nominal_termination.ML
49c49
<           val totality = Thm.close_derivation totality
---
>           val totality = Thm.close_derivation \<^here> totality
75c75
<               |> Spec_Rules.add Spec_Rules.equational_recdef (fs, tsimps)
---
>               |> Spec_Rules.add Binding.empty Spec_Rules.equational_recdef fs tsimps
==========
Nullstellensatz
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Nullstellensatz/Nullstellensatz.thy ../../AFPs/afp-2020/thys/Nullstellensatz/Nullstellensatz.thy
74,75c74
<   by (metis (no_types, hide_lams) add_uminus_conv_diff linordered_field_class.sign_simps(5)
<       mult_minus_left poly_plus_rightE)
---
>   by (metis add_diff_cancel_right' diff_add_cancel poly_plus_rightE)
==========
Octonions
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Octonions/Cross_Product_7.thy ../../AFPs/afp-2020/thys/Octonions/Cross_Product_7.thy
7c7
<   imports "HOL-Analysis.Analysis" 
---
>   imports "HOL-Analysis.Multivariate_Analysis"
==========
Optics
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Algebra.thy ../../AFPs/afp-2020/thys/Optics/Lens_Algebra.thy
22c22
< definition lens_comp :: "('a \<Longrightarrow> 'b) \<Rightarrow> ('b \<Longrightarrow> 'c) \<Rightarrow> ('a \<Longrightarrow> 'c)" (infixr ";\<^sub>L" 80) where
---
> definition lens_comp :: "('a \<Longrightarrow> 'b) \<Rightarrow> ('b \<Longrightarrow> 'c) \<Rightarrow> ('a \<Longrightarrow> 'c)" (infixl ";\<^sub>L" 80) where
87,92d86
< text \<open>Lens override uses a lens to replace part of a source type with a given value for the
<   corresponding view.\<close>
< 
< definition lens_override :: "'a \<Rightarrow> 'a \<Rightarrow> ('b \<Longrightarrow> 'a) \<Rightarrow> 'a" ("_ \<oplus>\<^sub>L _ on _" [95,0,96] 95) where
< [lens_defs]: "S\<^sub>1 \<oplus>\<^sub>L S\<^sub>2 on X = put\<^bsub>X\<^esub> S\<^sub>1 (get\<^bsub>X\<^esub> S\<^sub>2)"
< 
157c151
< lemma plus_vwb_lens:
---
> lemma plus_vwb_lens [simp]:
201a196,201
> lemma inv_inv_lens: "bij_lens X \<Longrightarrow> inv\<^sub>L (inv\<^sub>L X) = X"
>   apply (cases X)
>   apply (auto simp add: lens_defs fun_eq_iff)
>   apply (metis (no_types) bij_lens.strong_get_put bij_lens_def select_convs(2) weak_lens.put_get)
>   done
> 
213c213
< lemma lens_comp_assoc: "(X ;\<^sub>L Y) ;\<^sub>L Z = X ;\<^sub>L (Y ;\<^sub>L Z)"
---
> lemma lens_comp_assoc: "X ;\<^sub>L (Y ;\<^sub>L Z) = (X ;\<^sub>L Y) ;\<^sub>L Z"
224a225,227
> lemma lens_comp_anhil_right [simp]: "wb_lens X \<Longrightarrow> X ;\<^sub>L 0\<^sub>L = 0\<^sub>L"
>   by (simp add: zero_lens_def lens_comp_def comp_def)
> 
325c328,336
< done
---
>   done
> 
> subsection \<open> Compatibility Laws \<close>
> 
> lemma zero_lens_compat [simp]: "0\<^sub>L ##\<^sub>L X"
>   by (auto simp add: zero_lens_def lens_override_def lens_compat_def)
> 
> lemma id_lens_compat [simp]: "vwb_lens X \<Longrightarrow> 1\<^sub>L ##\<^sub>L X"
>   by (auto simp add: id_lens_def lens_override_def lens_compat_def)
398c409,417
<     
---
> lemma lens_obs_eq_zero: "s\<^sub>1 \<simeq>\<^bsub>0\<^sub>L\<^esub> s\<^sub>2 = (s\<^sub>1 = s\<^sub>2)"
>   by (simp add: lens_defs)
> 
> lemma lens_obs_eq_one: "s\<^sub>1 \<simeq>\<^bsub>1\<^sub>L\<^esub> s\<^sub>2"
>   by (simp add: lens_defs)
> 
> lemma lens_obs_eq_as_override: "vwb_lens X \<Longrightarrow> s\<^sub>1 \<simeq>\<^bsub>X\<^esub> s\<^sub>2 \<longleftrightarrow> (s\<^sub>2 = s\<^sub>1 \<oplus>\<^sub>L s\<^sub>2 on X)"
>   by (auto simp add: lens_defs; metis vwb_lens.put_eq)
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lenses.thy ../../AFPs/afp-2020/thys/Optics/Lenses.thy
7a8
>     Lens_Symmetric
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Instances.thy ../../AFPs/afp-2020/thys/Optics/Lens_Instances.thy
4c4
<   imports Lens_Order "HOL-Eisbach.Eisbach"
---
>   imports Lens_Order Lens_Symmetric "HOL-Eisbach.Eisbach"
20c20
< lemma fun_wb_lens: "wb_lens (fun_lens x)"
---
> lemma fun_vwb_lens: "vwb_lens (fun_lens x)"
110c110
<     
---
> 
112c112
<   "list_augment (list_augment xs i u) j v = (list_pad_out xs (max i j))[i := u, j := v]"
---
>   "list_augment (list_augment xs i u) j v = (list_pad_out xs (max i j))[i:=u, j:=v]"
164c164
< abbreviation "hd_lens \<equiv> list_lens 0"
---
> abbreviation hd_lens ("hd\<^sub>L") where "hd_lens \<equiv> list_lens 0"
166c166
< definition tl_lens :: "'a list \<Longrightarrow> 'a list" where
---
> definition tl_lens :: "'a list \<Longrightarrow> 'a list" ("tl\<^sub>L") where
183c183
<   "mwb_lens tl_lens"
---
>   "mwb_lens tl\<^sub>L"
186c186
< lemma source_tail_lens: "\<S>\<^bsub>tl_lens\<^esub> = {xs. xs \<noteq> []}"
---
> lemma source_tail_lens: "\<S>\<^bsub>tl\<^sub>L\<^esub> = {xs. xs \<noteq> []}"
196c196
<   "hd_lens \<bowtie> tl_lens"
---
>   "hd\<^sub>L \<bowtie> tl\<^sub>L"
201c201
<   apply (metis Nitpick.size_list_simp(2) One_nat_def add_Suc_right append.simps(1) append_Nil2 diff_Suc_Suc diff_zero hd_Cons_tl list.inject list.size(4) list_augment_0 list_augment_def list_augment_same_twice list_pad_out_def nth_list_augment replicate.simps(1) replicate.simps(2) tl_Nil)
---
>   apply (metis One_nat_def diff_Suc_Suc diff_zero length_0_conv length_list_augment_1 length_tl linorder_not_less list.exhaust list.sel(2) list.sel(3) list_augment_0 not_less_zero)
203a204,206
> lemma hd_tl_lens_pbij: "pbij_lens (hd\<^sub>L +\<^sub>L tl\<^sub>L)"
>   by (unfold_locales, auto simp add: lens_defs)
> 
214,215c217,242
< syntax "_FLDLENS" :: "id \<Rightarrow> ('a \<Longrightarrow> 'r)"  ("FLDLENS _")
< translations "FLDLENS x" => "\<lparr> lens_get = x, lens_put = CONST fld_put (_update_name x) \<rparr>"
---
> syntax 
>   "_FLDLENS" :: "id \<Rightarrow> logic"  ("FLDLENS _")
> translations 
>   "FLDLENS x" => "\<lparr> lens_get = x, lens_put = CONST fld_put (_update_name x) \<rparr>"
> 
> text \<open> We also allow the extraction of the "base lens", which characterises all the fields added
>   by a record without the extension. \<close>
> 
> syntax
>   "_BASELENS" :: "id \<Rightarrow> logic"  ("BASELENS _")
> 
> abbreviation (input) "base_lens t e m \<equiv> \<lparr> lens_get = t, lens_put = \<lambda> s v. e v (m s) \<rparr>"
> 
> ML \<open>
>   fun baselens_tr [Free (name, _)] =
>     let
>       val extend = Free (name ^ ".extend", dummyT);
>       val truncate = Free (name ^ ".truncate", dummyT);
>       val more = Free (name ^ ".more", dummyT);
>     in
>       Const (@{const_syntax "base_lens"}, dummyT) $ truncate $ extend $ more
>     end
>   | baselens_tr _ = raise Match;
> \<close>
> 
> parse_translation \<open>[(@{syntax_const "_BASELENS"}, K baselens_tr)]\<close>  
228a256,277
> subsection \<open>Type Definition Lens\<close>
> 
> text \<open> Every type defined by a \<^bold>\<open>typedef\<close> command induces a partial bijective lens constructed
>   using the abstraction and representation functions. \<close>
> 
> context type_definition
> begin
> 
> definition typedef_lens :: "'b \<Longrightarrow> 'a" ("typedef\<^sub>L") where
> [lens_defs]: "typedef\<^sub>L = \<lparr> lens_get = Abs, lens_put = (\<lambda> s. Rep) \<rparr>"
> 
> lemma pbij_typedef_lens [simp]: "pbij_lens typedef\<^sub>L"
>   by (unfold_locales, simp_all add: lens_defs Rep_inverse)
> 
> lemma source_typedef_lens: "\<S>\<^bsub>typedef\<^sub>L\<^esub> = A"
>   using Rep_cases by (auto simp add: lens_source_def lens_defs Rep)
> 
> lemma bij_typedef_lens_UNIV: "A = UNIV \<Longrightarrow> bij_lens typedef\<^sub>L"
>   by (auto intro: pbij_vwb_is_bij_lens simp add: mwb_UNIV_src_is_vwb_lens source_typedef_lens)
> 
> end
> 
296c345
< end
\ No newline at end of file
---
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Laws.thy ../../AFPs/afp-2020/thys/Optics/Lens_Laws.thy
19a20,25
> text \<open> Alternative parameters ordering, inspired by Back and von Wright's refinement 
>   calculus~\cite{Back1998}, which similarly uses two functions to characterise updates to variables. \<close>
> 
> abbreviation (input) lens_set :: "('a \<Longrightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b \<Rightarrow> 'b" ("lset\<index>") where
> "lens_set \<equiv> (\<lambda> X v s. put\<^bsub>X\<^esub> s v)"
> 
40c46
< text \<open> \<open>lens_source\<close> gives the set of constructible sources; that is those that can be built
---
> text \<open> @{text lens_source} gives the set of constructible sources; that is those that can be built
53a60,80
>     
> definition lens_update :: "('a \<Longrightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a) \<Rightarrow> ('b \<Rightarrow> 'b)" ("update\<index>") where
> [lens_defs]: "lens_update X f \<sigma> = put\<^bsub>X\<^esub> \<sigma> (f (get\<^bsub>X\<^esub> \<sigma>))"
> 
> text \<open> The update function is analogous to the record update function which lifts a function
>   on a view type to one on the source type. \<close>
> 
> definition lens_obs_eq :: "('b \<Longrightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool" (infix "\<simeq>\<index>" 50) where
> [lens_defs]: "s\<^sub>1 \<simeq>\<^bsub>X\<^esub> s\<^sub>2 = (s\<^sub>1 = put\<^bsub>X\<^esub> s\<^sub>2 (get\<^bsub>X\<^esub> s\<^sub>1))"
> 
> text \<open> This relation states that two sources are equivalent outside of the region characterised
>   by lens $X$. \<close>
> 
> definition lens_override :: "('b \<Longrightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a" (infixl "\<triangleleft>\<index>" 95) where
> [lens_defs]: "S\<^sub>1 \<triangleleft>\<^bsub>X\<^esub> S\<^sub>2 = put\<^bsub>X\<^esub> S\<^sub>1 (get\<^bsub>X\<^esub> S\<^sub>2)"
> 
> abbreviation (input) lens_override' :: "'a \<Rightarrow> 'a \<Rightarrow> ('b \<Longrightarrow> 'a) \<Rightarrow> 'a" ("_ \<oplus>\<^sub>L _ on _" [95,0,96] 95) where
> "S\<^sub>1 \<oplus>\<^sub>L S\<^sub>2 on X \<equiv> S\<^sub>1 \<triangleleft>\<^bsub>X\<^esub> S\<^sub>2"
> 
> text \<open>Lens override uses a lens to replace part of a source type with a given value for the
>   corresponding view.\<close>
83,88d109
<   text \<open> The update function is analogous to the record update function which lifts a function
<     on a view type to one on the source type. \<close>
<     
<   definition update :: "('a \<Rightarrow> 'a) \<Rightarrow> ('b \<Rightarrow> 'b)" where
<   [lens_defs]: "update f \<sigma> = put \<sigma> (f (get \<sigma>))"
< 
90c111
<     by (simp add: put_get update_def)
---
>     by (simp add: put_get lens_update_def)
98a120
> 
142c164
<     by (simp add: put_get put_put update_def)
---
>     by (simp add: put_get put_put lens_update_def)
166a189,190
> abbreviation (input) "partial_lens \<equiv> mwb_lens"
> 
176c200,202
< text \<open>Very well-behaved lenses combine all three laws, as in the literature~\cite{Foster09,Fischer2015}.\<close>
---
> text \<open>Very well-behaved lenses combine all three laws, as in the literature~\cite{Foster09,Fischer2015}.
>   The same set of axioms can be found in Back and von Wright's refinement calculus~\cite{Back1998}, 
>   though with different names for the functions. \<close>
195a222,236
>   lemma get_surj: "surj get"
>     by (metis put_get surjI)
> 
>   text \<open> Observation equivalence is an equivalence relation. \<close>
> 
>   lemma lens_obs_equiv: "equivp (\<simeq>)"
>   proof (rule equivpI)
>     show "reflp (\<simeq>)"
>       by (rule reflpI, simp add: lens_obs_eq_def get_put)
>     show "symp (\<simeq>)"
>       by (rule sympI, simp add: lens_obs_eq_def, metis get_put put_put)
>     show "transp (\<simeq>)"
>       by (rule transpI, simp add: lens_obs_eq_def, metis put_put)
>   qed
> 
197a239,240
> abbreviation (input) "total_lens \<equiv> vwb_lens"
> 
203a247,257
> lemma mwb_UNIV_src_is_vwb_lens: 
>   "\<lbrakk> mwb_lens X; \<S>\<^bsub>X\<^esub> = UNIV \<rbrakk> \<Longrightarrow> vwb_lens X"
>   using vwb_lens_def wb_lens_axioms_def wb_lens_def by fastforce
> 
> text \<open> Alternative characterisation: a very well-behaved (i.e. total) lens is a mainly well-behaved
>   (i.e. partial) lens whose source is the universe set. \<close>
> 
> lemma vwb_lens_iff_mwb_UNIV_src: 
>   "vwb_lens X \<longleftrightarrow> (mwb_lens X \<and> \<S>\<^bsub>X\<^esub> = UNIV)"
>   by (meson mwb_UNIV_src_is_vwb_lens vwb_lens_def wb_lens.source_UNIV)
> 
229a284,315
> subsection \<open> Partially Bijective Lenses \<close>
> 
> locale pbij_lens = weak_lens +
>   assumes put_det: "put \<sigma> v = put \<rho> v"
> begin
> 
>   sublocale mwb_lens
>   proof
>     fix \<sigma> v u
>     show "put (put \<sigma> v) u = put \<sigma> u"
>       using put_det by blast
>   qed
>   
>   lemma put_is_create: "put \<sigma> v = create v"
>     by (simp add: lens_create_def put_det)
> 
>   lemma partial_get_put: "\<rho> \<in> \<S> \<Longrightarrow> put \<sigma> (get \<rho>) = \<rho>"
>     by (metis put_det weak_get_put)
> 
> end
> 
> lemma pbij_lens_weak [simp]:
>   "pbij_lens x \<Longrightarrow> weak_lens x"
>   by (simp_all add: pbij_lens_def)
> 
> lemma pbij_lens_mwb [simp]: "pbij_lens x \<Longrightarrow> mwb_lens x"
>   by (simp add: mwb_lens_axioms.intro mwb_lens_def pbij_lens.put_is_create)
> 
> lemma pbij_alt_intro:
>   "\<lbrakk> weak_lens X; \<And> s. s \<in> \<S>\<^bsub>X\<^esub> \<Longrightarrow> create\<^bsub>X\<^esub> (get\<^bsub>X\<^esub> s) = s \<rbrakk> \<Longrightarrow> pbij_lens X"
>   by (metis pbij_lens_axioms_def pbij_lens_def weak_lens.put_closure weak_lens.put_get)
> 
241a328,334
> sublocale pbij_lens
> proof
>   fix \<sigma> v \<rho>
>   show "put \<sigma> v = put \<rho> v"
>     by (metis put_get strong_get_put)
> qed
> 
247,248d339
<   show "put (put \<sigma> v) u = put \<sigma> u"
<     by (metis bij_lens.strong_get_put bij_lens_axioms put_get)
250c341
<     
---
> 
254,257c345
<   lemma put_is_create: "\<sigma> \<in> \<S> \<Longrightarrow> put \<sigma> v = create v"
<     by (metis create_get strong_get_put)
< 
<   lemma get_create: "\<sigma> \<in> \<S> \<Longrightarrow> create (get \<sigma>) = \<sigma>"
---
>   lemma get_create: "create (get \<sigma>) = \<sigma>"
268a357,360
> lemma bij_lens_pbij [simp]:
>   "bij_lens x \<Longrightarrow> pbij_lens x"
>   by (metis bij_lens.get_create bij_lens_def pbij_lens_axioms.intro pbij_lens_def weak_lens.put_get)
> 
271a364,374
> text \<open> Alternative characterisation: a bijective lens is a partial bijective lens that is also
>   very well-behaved (i.e. total). \<close>
> 
> lemma pbij_vwb_is_bij_lens:
>   "\<lbrakk> pbij_lens X; vwb_lens X \<rbrakk> \<Longrightarrow> bij_lens X"
>   by (unfold_locales, simp_all, meson pbij_lens.put_det vwb_lens.put_eq)
> 
> lemma bij_lens_iff_pbij_vwb:
>   "bij_lens X \<longleftrightarrow> (pbij_lens X \<and> vwb_lens X)"
>   using pbij_vwb_is_bij_lens by auto
> 
298,300c401,403
<   "\<lbrakk> \<And> u v \<sigma>. lens_put x (lens_put y \<sigma> v) u = lens_put y (lens_put x \<sigma> u) v;
<      \<And> v \<sigma>. lens_get x (lens_put y \<sigma> v) = lens_get x \<sigma>;
<      \<And> u \<sigma>. lens_get y (lens_put x \<sigma> u) = lens_get y \<sigma> \<rbrakk> \<Longrightarrow> x \<bowtie> y"
---
>   "\<lbrakk> \<And> u v \<sigma>. put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v;
>      \<And> v \<sigma>. get\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) = get\<^bsub>x\<^esub> \<sigma>;
>      \<And> u \<sigma>. get\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) = get\<^bsub>y\<^esub> \<sigma> \<rbrakk> \<Longrightarrow> x \<bowtie> y"
309c412
<   "x \<bowtie> y \<Longrightarrow> lens_put x (lens_put y \<sigma> v) u = lens_put y (lens_put x \<sigma> u) v"
---
>   "x \<bowtie> y \<Longrightarrow> put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v"
314c417
<   shows "lens_get x (lens_put y \<sigma> v) = lens_get x \<sigma>"
---
>   shows "get\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) = get\<^bsub>x\<^esub> \<sigma>"
315a419,459
> 
> text \<open> Characterisation of independence for two very well-behaved lenses \<close>
> 
> lemma lens_indep_vwb_iff:
>   assumes "vwb_lens x" "vwb_lens y"
>   shows "x \<bowtie> y \<longleftrightarrow> (\<forall> u v \<sigma>. put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v)"
> proof
>   assume "x \<bowtie> y"
>   thus "\<forall> u v \<sigma>. put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v"
>     by (simp add: lens_indep_comm)
> next
>   assume a: "\<forall> u v \<sigma>. put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v"
>   show "x \<bowtie> y"
>   proof (unfold_locales)
>     fix \<sigma> v u
>     from a show "put\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) u = put\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) v" 
>       by auto
>     show "get\<^bsub>x\<^esub> (put\<^bsub>y\<^esub> \<sigma> v) = get\<^bsub>x\<^esub> \<sigma>"
>       by (metis a assms(1) vwb_lens.put_eq vwb_lens_wb wb_lens_def weak_lens.put_get)
>     show "get\<^bsub>y\<^esub> (put\<^bsub>x\<^esub> \<sigma> u) = get\<^bsub>y\<^esub> \<sigma>"
>       by (metis a assms(2) vwb_lens.put_eq vwb_lens_wb wb_lens_def weak_lens.put_get)
>   qed
> qed
> 
> subsection \<open> Lens Compatibility \<close>
> 
> text \<open> Lens compatibility is a weaker notion than independence. It allows that two lenses can overlap
>   so long as they manipulate the source in the same way in that region. It is most easily defined
>   in terms of a function for copying a region from one source to another using a lens. \<close>
> 
> definition lens_compat (infix "##\<^sub>L" 50) where
> [lens_defs]: "lens_compat X Y = (\<forall>s\<^sub>1 s\<^sub>2. s\<^sub>1 \<triangleleft>\<^bsub>X\<^esub> s\<^sub>2 \<triangleleft>\<^bsub>Y\<^esub> s\<^sub>2 = s\<^sub>1 \<triangleleft>\<^bsub>Y\<^esub> s\<^sub>2 \<triangleleft>\<^bsub>X\<^esub> s\<^sub>2)"
> 
> lemma lens_compat_idem [simp]: "x ##\<^sub>L x"
>   by (simp add: lens_defs)
> 
> lemma lens_compat_sym: "x ##\<^sub>L y \<Longrightarrow> y ##\<^sub>L x"
>   by (simp add: lens_defs)
> 
> lemma lens_indep_compat [simp]: "x \<bowtie> y \<Longrightarrow> x ##\<^sub>L y"
>   by (simp add: lens_override_def lens_compat_def lens_indep_comm)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Order.thy ../../AFPs/afp-2020/thys/Optics/Lens_Order.thy
44c44
< text \<open>Sublens has a least element -- \<open>0\<^sub>L\<close> -- and a greatest element -- \<open>1\<^sub>L\<close>. 
---
> text \<open>Sublens has a least element -- @{text "0\<^sub>L"} -- and a greatest element -- @{text "1\<^sub>L"}. 
46c46
<   lens views, with \<open>0\<^sub>L\<close> observing the least, and \<open>1\<^sub>L\<close> observing the most.\<close>
---
>   lens views, with @{text "0\<^sub>L"} observing the least, and @{text "1\<^sub>L"} observing the most.\<close>
74a75,82
> lemma sublens_pres_indep':
>   "\<lbrakk> X \<subseteq>\<^sub>L Y; Z \<bowtie> Y \<rbrakk> \<Longrightarrow> Z \<bowtie> X"
>   by (meson lens_indep_sym sublens_pres_indep)
> 
> lemma sublens_compat: "\<lbrakk> vwb_lens X; vwb_lens Y; X \<subseteq>\<^sub>L Y \<rbrakk> \<Longrightarrow> X ##\<^sub>L Y"
>   unfolding lens_compat_def lens_override_def
>   by (metis (no_types, hide_lams) sublens_obs_get sublens_put_put vwb_lens_mwb vwb_lens_wb wb_lens.get_put)
> 
107a116,127
> lemma lens_equiv_pres_indep:
>   "\<lbrakk> X \<approx>\<^sub>L Y; Y \<bowtie> Z \<rbrakk> \<Longrightarrow> X \<bowtie> Z"
>   using lens_equiv_def sublens_pres_indep by blast
> 
> lemma lens_equiv_pres_indep':
>   "\<lbrakk> X \<approx>\<^sub>L Y; Z \<bowtie> Y \<rbrakk> \<Longrightarrow> Z \<bowtie> X"
>   using lens_equiv_def sublens_pres_indep' by blast
> 
> lemma lens_comp_cong_1: "X \<approx>\<^sub>L Y \<Longrightarrow> X ;\<^sub>L Z \<approx>\<^sub>L Y ;\<^sub>L Z"
>   unfolding lens_equiv_def
>   by (metis (no_types, lifting) lens_comp_assoc sublens_def)
> 
195a216,217
> 
> 
208,210c230,232
<    using comp_vwb_lens snd_vwb_lens apply blast
<   apply (simp add: lens_comp_assoc snd_lens_plus)
< done
---
>   using comp_vwb_lens snd_vwb_lens apply blast
>   apply (metis lens_comp_assoc snd_lens_plus vwb_lens_def)
>   done
220c242
< done
---
>   done
232c254,259
< text \<open>We can now also show that \<open>0\<^sub>L\<close> is the unit of lens plus\<close>
---
> lemma sublens_comp [simp]:
>   assumes "vwb_lens b" "c \<subseteq>\<^sub>L a"
>   shows "(b ;\<^sub>L c) \<subseteq>\<^sub>L a"
>   by (metis assms sublens_def sublens_trans)
> 
> text \<open>We can now also show that @{text "0\<^sub>L"} is the unit of lens plus\<close>
241,242d267
<    apply (rule plus_vwb_lens)
<      apply (simp_all)
383a409,412
> lemma bij_lens_cong:
>   "X \<approx>\<^sub>L Y \<Longrightarrow> bij_lens X = bij_lens Y"
>   by (meson bij_lens_equiv lens_equiv_sym)
> 
396c425
< text \<open>Consequently, if composition of two lenses $X$ and $Y$ yields \<open>1\<^sub>L\<close>, then both
---
> text \<open>Consequently, if composition of two lenses $X$ and $Y$ yields @{text "1\<^sub>L"}, then both
434d462
<   apply (simp add: bij_lens_inv_left lens_comp_assoc[THEN sym])
454a483,488
> lemma pbij_plus_commute:
>   "\<lbrakk> a \<bowtie> b; mwb_lens a; mwb_lens b; pbij_lens (b +\<^sub>L a) \<rbrakk> \<Longrightarrow> pbij_lens (a +\<^sub>L b)"
>   apply (unfold_locales, simp_all add:lens_defs lens_indep_sym prod.case_eq_if)
>   using lens_indep.lens_put_comm pbij_lens.put_det apply fastforce
>   done
> 
471a506,510
> lemma lens_override_irr:
>   assumes "X \<bowtie> Y"
>   shows "S\<^sub>1 \<oplus>\<^sub>L (S\<^sub>2 \<oplus>\<^sub>L S\<^sub>3 on Y) on X = S\<^sub>1 \<oplus>\<^sub>L S\<^sub>2 on X"
>   using assms by (simp add: lens_override_def)
> 
580a620,632
> 
> subsection \<open> Alternative Equivalence Characterisation \<close>
> 
> definition lens_equiv' :: "('a \<Longrightarrow> 'c) \<Rightarrow> ('b \<Longrightarrow> 'c) \<Rightarrow> bool" (infix "\<approx>\<^sub>L''" 51) where
> [lens_defs]: "lens_equiv' X Y = (\<forall> s\<^sub>1 s\<^sub>2. (s\<^sub>1 \<oplus>\<^sub>L s\<^sub>2 on X = s\<^sub>1 \<oplus>\<^sub>L s\<^sub>2 on Y))"
> 
> lemma lens_equiv_iff_lens_equiv':
>   assumes "vwb_lens X" "vwb_lens Y"
>   shows "X \<approx>\<^sub>L Y \<longleftrightarrow> X \<approx>\<^sub>L' Y"
>   apply (simp add: lens_equiv_def sublens_iff_sublens' assms)
>   apply (auto simp add: lens_defs assms)
>   apply (metis assms(2) mwb_lens.put_put vwb_lens_mwb vwb_lens_wb wb_lens.get_put)
>   done
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Record_Example.thy ../../AFPs/afp-2020/thys/Optics/Lens_Record_Example.thy
2c2
< imports Lens_Instances
---
>   imports Optics
10a11,30
> thm base_more_bij_lens
> thm indeps
> thm equivs
> thm sublenses
> thm quotients
> thm compositions
> 
> lemma mylens_composition: 
>   "x +\<^sub>L y +\<^sub>L more\<^sub>L \<approx>\<^sub>L 1\<^sub>L" (is "?P \<approx>\<^sub>L ?Q")
> proof -
>   have "?Q \<approx>\<^sub>L base\<^sub>L +\<^sub>L more\<^sub>L"
>     by (simp add: lens_equiv_sym)
>   also have "... \<approx>\<^sub>L (x +\<^sub>L y) +\<^sub>L more\<^sub>L"
>     by (simp add: lens_plus_eq_left)
>   also have "... \<approx>\<^sub>L x +\<^sub>L y +\<^sub>L more\<^sub>L"
>     by (simp add: lens_plus_assoc)
>   finally show ?thesis
>     using lens_equiv_sym by auto
> qed
> 
12,13c32,33
<   "bij_lens (x +\<^sub>L y +\<^sub>L mylens_child_lens)"
<   by (unfold_locales, simp_all add: lens_plus_def x_def y_def mylens_child_lens_def id_lens_def sublens_def lens_comp_def prod.case_eq_if)
---
>   "bij_lens (x +\<^sub>L y +\<^sub>L more\<^sub>L)"
>   using bij_lens_equiv_id mylens_composition by auto
18a39,45
> thm lens_defs
> 
> thm base_more_bij_lens
> thm indeps
> thm equivs
> thm sublenses
> 
21a49,53
> 
> thm base_more_bij_lens
> thm indeps
> thm equivs
> thm sublenses
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_Record.ML ../../AFPs/afp-2020/thys/Optics/Lens_Record.ML
16c16,21
< val child_lens_suffix = "_child_lens"
---
> val BASELENS = "BASELENS"
> val base_lensN = "base\<^sub>L"
> val child_lensN = "more\<^sub>L"
> val all_lensN = "all\<^sub>L"
> val base_moreN = "base_more"
> val bij_lens_suffix = "_bij_lens"
18,29c23,39
< val indeps_suffix = "_indeps"
< val pl_indeps_suffix = "_pl_indeps"
< val sublens_suffix = "_sublenses"
< val Trueprop = "HOL.Trueprop"
< val imp = "Pure.imp"
< val lens_laws_thy = "Lens_Laws"
< val lens_algebra_thy = "Lens_Algebra"
< val sublens_thy = "Lens_Order"
< val vwb_lens = lens_laws_thy ^ ".vwb_lens"
< val lens_indep = lens_laws_thy ^ ".lens_indep"
< val lens_comp = lens_algebra_thy ^ ".lens_comp"
< val sublens = sublens_thy ^ ".sublens"
---
> val sym_lens_suffix = "_sym_lens"
> val indepsN = "indeps"
> val sublensN = "sublenses"
> val quotientN = "quotients"
> val compositionN = "compositions"
> val Trueprop = @{const_name Trueprop}
> val HOLeq = @{const_name HOL.eq}
> val bij_lens = @{const_name bij_lens}
> val vwb_lens = @{const_name vwb_lens}
> val sym_lens = @{const_name sym_lens}
> val lens_indep = @{const_name lens_indep}
> val lens_plus = @{const_name lens_plus}
> val lens_quotient = @{const_name lens_quotient}
> val lens_comp = @{const_name lens_comp}
> val id_lens = @{const_name id_lens}
> val sublens = @{const_name sublens}
> val lens_equiv = @{const_name lens_equiv}
31,33c41,45
< val ext_suffix = "\<^sub>a"
< val lens_defs = (Binding.empty, [Token.make_src ("lens_defs", Position.none) []])
< val alpha_splits = [Token.make_src ("alpha_splits", Position.none) []]
---
> val lens_defsN = "lens_defs"
> val lens_defs = (Binding.empty, [Token.make_src (lens_defsN, Position.none) []])
> val alpha_splitsN = "alpha_splits"
> val alpha_splits = [Token.make_src (alpha_splitsN, Position.none) []]
> val equivN = "equivs"
34a47,50
> val defs_suffix = ".defs"
> val prod_case_eq_ifN = "prod.case_eq_if"
> val slens_view = "view"
> val slens_coview = "coview"
64c80,81
< fun lens_proof x thy =
---
> fun lens_proof tname x thy =
>   let open Simplifier; open Global_Theory in
69c86
<               $ (Const (vwb_lens, dummyT) $ Const (Context.theory_name thy ^ "." ^ x, dummyT))]))
---
>               $ (Const (vwb_lens, dummyT) $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT))]))
71,72c88,92
<          => EVERY [ Locale.intro_locales_tac {strict = true, eager = true} context []
<                   , PARALLEL_ALLGOALS (asm_simp_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def")) context))])
---
>                            => EVERY [ Locale.intro_locales_tac {strict = true, eager = true} context []
>                                     , PARALLEL_ALLGOALS (asm_simp_tac 
>                                                           (fold add_simp (get_thm thy (x ^ "_def") :: get_thms thy (tname ^ ".defs"))
>                                                                          context))])
>   end
74,75c94,144
< (* Child lenses correspond to the field where a record extension may reside. This function constructs 
<   a theorem that a given child lens field is very well-behaved *)
---
> fun lens_sym_proof tname thy =
>   let open Simplifier; open Global_Theory in
>       Goal.prove_global thy [] []
>       (hd (Type_Infer_Context.infer_types
>               (Proof_Context.init_global thy)
>               [ Const (Trueprop, dummyT)
>               $ (Const (sym_lens, dummyT) $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ all_lensN, dummyT))]))
>       (fn {context = context, prems = _}
>                            => EVERY [ Classical.rule_tac context [@{thm sym_lens.intro}] [] 1
>                                     , PARALLEL_ALLGOALS (asm_simp_tac 
>                                                           (fold add_simp (@{thms slens.defs} @ get_thms thy (tname ^ ".defs"))
>                                                                          context))])
>   end
> 
> 
> fun prove_lens_goal tname thy ctx =
>   let open Simplifier; open Global_Theory in
>   auto_tac (fold add_simp (get_thms thy lens_defsN @ 
>                            get_thms thy (tname ^ splits_suffix) @ 
>                            [get_thm thy prod_case_eq_ifN]) ctx)
> end
> 
> fun prove_indep tname thy = 
>   let open Simplifier; open Global_Theory in
>   (fn {context, prems = _} =>
>           EVERY [auto_tac (add_simp @{thm lens_indep_vwb_iff} context)
>                 ,prove_lens_goal tname thy context])
> end
> 
> fun prove_sublens tname thy = 
>   let open Simplifier; open Global_Theory in
>   (fn {context, prems = _} =>
>           EVERY [auto_tac (add_simp @{thm sublens_iff_sublens'} context)
>                 ,prove_lens_goal tname thy context])
> end
> 
> fun prove_quotient tname thy = 
>   let open Simplifier; open Global_Theory in
>   (fn {context, prems = _} =>
>           EVERY [prove_lens_goal tname thy context])
> end
> 
> 
> fun prove_equiv tname thy = 
>   let open Simplifier; open Global_Theory in
>   (fn {context, prems = _} =>
>           EVERY [auto_tac (add_simp @{thm lens_equiv_iff_lens_equiv'} context)
>                 ,prove_lens_goal tname thy context])
> end
>  
> (* Constrct a proof that base + more is a bijective lens *)
77c146,147
< fun lens_child_proof thy x =
---
> fun lens_bij_proof tname thy =
>   let open Simplifier; open Global_Theory in
82,85c152,159
<               $ (Const (vwb_lens, dummyT) $ Const (Context.theory_name thy ^ "." ^ x, dummyT))]))
<       (fn {context = context, prems = _} =>
<           EVERY [ PARALLEL_ALLGOALS
<                     (asm_simp_tac (Simplifier.add_simp @{thm comp_vwb_lens} (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def")) context)))])
---
>               $ (Const (bij_lens, dummyT) $ 
>                 (Const (lens_plus, dummyT) $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ base_lensN, dummyT)
>                                            $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ child_lensN, dummyT)))]))
>       (fn {context = context, prems = _}
>                            => EVERY [ Locale.intro_locales_tac {strict = true, eager = true} context []
>                                     , auto_tac (fold add_simp (get_thms thy lens_defsN @ [get_thm thy prod_case_eq_ifN])
>                                                                          context)])
>   end
93c167,168
< fun indep_proof thy (x, y) =
---
> fun indep_proof tname thy (x, y) =
>   let open Simplifier; open Global_Theory in
99,100c174,175
<                 $ Const (Context.theory_name thy ^ "." ^ x, dummyT)
<                 $ Const (Context.theory_name thy ^ "." ^ y, dummyT)
---
>                 $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                 $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ y, dummyT)
102,112c177,178
<       (fn {context = context, prems = _}
<          => EVERY [ Locale.intro_locales_tac {strict = true, eager = true} context []
<                   , PARALLEL_ALLGOALS
<                       (asm_simp_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def"))
<                                     (Simplifier.add_simp (Global_Theory.get_thm thy (y ^ "_def"))
<                        context)))])
< 
< (* The next function is similar, but does not unfold locales instead relying on existing independence
<    proofs. The reason for this is that we when invoking this we have already proved that the lenses
<    on the extension record are independent, here we just apply preservation of independence of 
<    the lenses through composition. *)
---
>       (prove_indep tname thy)
>   end
114c180,181
< fun pl_indep_proof thy (x, y) =
---
> fun equiv_more_proof tname pname thy fs =
>   let open Simplifier; open Global_Theory; open Context; open Term in
119,121c186,189
<               $ ( Const (lens_indep, dummyT)
<                 $ Const (Context.theory_name thy ^ "." ^ x, dummyT)
<                 $ Const (Context.theory_name thy ^ "." ^ y, dummyT)
---
>               $ ( Const (lens_equiv, dummyT)
>                 $ Const (pname ^ "." ^ child_lensN, dummyT)
>                 $ foldr1 (fn (x, y) => Const (lens_plus, dummyT) $ x $ y) 
>                          (map (fn n => Const (theory_name thy ^ "." ^ tname ^ "." ^ n, dummyT)) (fs @ [child_lensN]))
123,131c191,192
<       (fn {context = context, prems = _}
<                            => EVERY [ PARALLEL_ALLGOALS
<                                         (asm_simp_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def"))
<                                                       (Simplifier.add_simp (Global_Theory.get_thm thy (y ^ "_def"))
<                                          context)))])
< 
< (* The following two functions construct contigent independence proofs for the child lenses: if
<   two lenses are independent, then the composition of the two lenses with the child lens from
<   their parent must also be independent. *)
---
>       (prove_equiv tname thy)
>   end
133c194,195
< fun parent_indep_proof_1 thy y x =
---
> fun equiv_base_proof tname parent thy fs =
>   let open Simplifier; open Global_Theory; open Context; open Term in
137,154c199,207
<               [ Const ("Pure.all", dummyT) $ (Abs ("x", dummyT, (
<                 Const (imp, dummyT) $
<                 (Const (Trueprop, dummyT)
<                 $ ( Const (lens_indep, dummyT)
<                   $ Bound 0
<                   $ Const (y, dummyT)
<                   )
<                 )
<               $
<                 (Const (Trueprop, dummyT)
<                 $ ( Const (lens_indep, dummyT)
<                   $ Bound 0
<                   $ Const (Context.theory_name thy ^ "." ^ x, dummyT)
<                   )
<                 ))))
<               ]))
<       (fn {context = context, prems = _} =>
<           EVERY [(auto_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def")) context))])
---
>               [ Const (Trueprop, dummyT)
>               $ ( Const (lens_equiv, dummyT)
>                 $ Const (theory_name thy ^ "." ^ tname ^ "." ^ base_lensN, dummyT)
>                 $ foldr1 (fn (x, y) => Const (lens_plus, dummyT) $ x $ y) 
>                          ((case parent of NONE => [] | SOME (_, pname) => [Const (pname ^ "." ^ base_lensN, dummyT)]) @ 
>                           map (fn n => Const (theory_name thy ^ "." ^ tname ^ "." ^ n, dummyT)) fs)
>                 )]))
>       (prove_equiv tname thy)
>   end
156c209,210
< fun parent_indep_proof_2 thy y x =
---
> fun equiv_partition_proof tname thy =
>   let open Simplifier; open Global_Theory; open Context; open Term in
160,177c214,222
<               [ Const ("Pure.all", dummyT) $ (Abs ("x", dummyT, (
<                 Const (imp, dummyT) $
<                 (Const (Trueprop, dummyT)
<                 $ ( Const (lens_indep, dummyT)
<                   $ Const (y, dummyT)
<                   $ Bound 0
<                   )
<                 )
<               $
<                 (Const (Trueprop, dummyT)
<                 $ ( Const (lens_indep, dummyT)
<                   $ Const (Context.theory_name thy ^ "." ^ x, dummyT)
<                   $ Bound 0
<                   )
<                 ))))
<               ]))
<       (fn {context, prems = _} =>
<           EVERY [(auto_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def")) context))])
---
>               [ Const (Trueprop, dummyT)
>               $ ( Const (lens_equiv, dummyT)
>                 $ ( Const (lens_plus, dummyT) 
>                   $ Const (theory_name thy ^ "." ^ tname ^ "." ^ base_lensN, dummyT)
>                   $ Const (theory_name thy ^ "." ^ tname ^ "." ^ child_lensN, dummyT))
>                 $ Const (id_lens, dummyT)
>                 )]))
>       (prove_equiv tname thy)
>   end
181c226,227
< fun sublens_proof thy y x =
---
> fun sublens_proof tname pname thy y x =
>   let open Simplifier; open Global_Theory in
187,188c233,234
<                 $ Const (Context.theory_name thy ^ "." ^ x, dummyT)
<                 $ Const (y, dummyT)
---
>                 $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                 $ Const (pname ^ "." ^ y, dummyT)
190,192c236,270
<       (fn {context, prems = _} =>
<           EVERY [ PARALLEL_ALLGOALS
<                     (asm_simp_tac (Simplifier.add_simp (Global_Theory.get_thm thy (x ^ "_def")) context))])
---
>       (prove_sublens tname thy)
> end
> 
> fun quotient_proof tname thy x =
>   let open Simplifier; open Global_Theory in
>       Goal.prove_global thy [] []
>       (hd (Type_Infer_Context.infer_types
>               (Proof_Context.init_global thy)
>               [ Const (Trueprop, dummyT)
>               $ ( Const (HOLeq, dummyT)
>                 $ (Const (lens_quotient, dummyT) 
>                    $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                    $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ base_lensN, dummyT)
>                   )
>                 $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                 )]))
>       (prove_quotient tname thy)
> end
> 
> fun composition_proof tname thy x =
>   let open Simplifier; open Global_Theory in
>       Goal.prove_global thy [] []
>       (hd (Type_Infer_Context.infer_types
>               (Proof_Context.init_global thy)
>               [ Const (Trueprop, dummyT)
>               $ ( Const (HOLeq, dummyT)
>                 $ (Const (lens_comp, dummyT) 
>                    $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                    $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ base_lensN, dummyT)
>                   )
>                 $ Const (Context.theory_name thy ^ "." ^ tname ^ "." ^ x, dummyT)
>                 )]))
>       (prove_quotient tname thy)
> end
> 
204a283
>     open Simplifier; open Global_Theory
209,214c288,289
<     fun ldef_name x = if (raw_parent = NONE) then x else x ^ ext_suffix
<     val ldefs = map (fn x => (ldef_name x) ^ " = " ^ FLDLENS ^ " " ^ x ^ lens_suffix) lnames
<     val mpldef =
<       case parent of
<         SOME (_,r) => tname ^ child_lens_suffix ^ " = " ^ lens_comp ^ " " ^ tname ^ child_lens_suffix ^ ext_suffix ^ " " ^ r ^ child_lens_suffix |
<         NONE => ""
---
>     fun ldef x = (x, x ^ " = " ^ FLDLENS ^ " " ^ x ^ lens_suffix)
>     val pname = case parent of SOME (_,r) => r | NONE => "";
217c292
<         SOME (_, r) => r ^ child_lens_suffix |
---
>         SOME (_, _) => child_lensN |
219,225c294,299
<     val pldefs =
<       case parent of
<         SOME (_,r) => map (fn x => x ^ " = " ^ lens_comp ^ " " ^ x ^ ext_suffix ^ " " ^ r ^ child_lens_suffix) lnames @ [mpldef] |
<         NONE => [];
<     val mldef_name =  if (raw_parent = NONE) then tname ^ child_lens_suffix else tname ^ child_lens_suffix ^ ext_suffix
<     val mldef = mldef_name ^ " = " ^ FLDLENS ^ " more";
<     val plnames = if (raw_parent = NONE) then [] else lnames  @ [tname ^ child_lens_suffix];
---
>     val bldef = (base_lensN, base_lensN ^ " = " ^ BASELENS ^ " " ^ tname);
>     val mldef = (child_lensN, child_lensN ^ " = " ^ FLDLENS ^ " more"); 
>     val sldef = (all_lensN, all_lensN ^ " \<equiv> \<lparr> " ^ slens_view ^ " = " ^ base_lensN ^ ", " ^ slens_coview ^ " = " ^ child_lensN ^ " \<rparr>");
>     val plnames = if (raw_parent = NONE) then [] else lnames  @ [child_lensN];
>     fun pindeps thy = map (fn thm => @{thm sublens_pres_indep} OF [thm]) (get_thms thy sublensN)
>                     @ map (fn thm => @{thm sublens_pres_indep'} OF [thm]) (get_thms thy sublensN)
227c301,303
<          |> add_record_cmd {overloaded = false} (raw_params, binding) NONE fields
---
>          |> add_record_cmd {overloaded = false} (raw_params, binding) raw_parent fields
>             (* Add the record definition theorems to lens_defs *)
>          |> Named_Target.theory_map (snd o Specification.theorems_cmd "" [((Binding.empty, []), [(Facts.named (tname ^ defs_suffix), snd lens_defs)])] [] false)
230a307
>          |> Sign.qualified_path false binding
232,233c309,310
<               (fold (fn x => snd o Specification.definition_cmd NONE [] [] (lens_defs, x) true) (ldefs @ [mldef]))
<             (* Add definitions for each of the lenses corresponding to each record field augmented with the parent's child lens *)
---
>               (fold (fn (n, d) => snd o Specification.definition_cmd (SOME (Binding.make (n, Position.none), NONE, NoSyn)) [] [] (lens_defs, d) true) (map ldef lnames @ [bldef, mldef]))
>             (* Add definition of the underlying symmetric lens *)
235,237c312,322
<               (fold (fn x => snd o Specification.definition_cmd NONE [] [] (lens_defs, x) true) pldefs)
<             (* Add a vwb lens proof for each in-situ lens (i.e. on the record extension) *)
<          |> fold (fn x => fn thy => snd (Global_Theory.add_thm ((Binding.make (x ^ vwb_lens_suffix, Position.none), lens_proof x thy), [Simplifier.simp_add]) thy)) ((map ldef_name lnames) @ [mldef_name])
---
>               (fold (fn (n, d) => Specification.abbreviation_cmd Syntax.mode_default (SOME (Binding.make (n, Position.none), NONE, NoSyn)) [] d true) [sldef])
>             (* Add a vwb lens proof for each field lens *)
>          |> fold (fn x => fn thy => snd (add_thm ((Binding.make (x ^ vwb_lens_suffix, Position.none), lens_proof tname x thy), [Simplifier.simp_add]) thy)) (lnames @ [base_lensN, child_lensN])
>             (* Add a bij lens proof for the base and more lenses *)
>          |> (fn thy => snd (add_thm ((Binding.make (base_moreN ^ bij_lens_suffix, Position.none), lens_bij_proof tname thy), [Simplifier.simp_add]) thy))
>             (* Add sublens proofs *)
>          |> (fn thy => snd (add_thmss [((Binding.make (sublensN, Position.none), map (sublens_proof tname pname thy plchild) plnames @ map (sublens_proof tname (Context.theory_name thy ^ "." ^ tname) thy base_lensN) lnames), [Simplifier.simp_add])] thy))
>             (* Add quotient proofs *)
>          |> (fn thy => snd (add_thmss [((Binding.make (quotientN, Position.none), map (quotient_proof tname thy) lnames), [Simplifier.simp_add])] thy))
>             (* Add composition proofs *)
>          |> (fn thy => snd (add_thmss [((Binding.make (compositionN, Position.none), map (composition_proof tname thy) lnames), [Simplifier.simp_add])] thy))
239,244c324,331
<          |> (fn thy => snd (Global_Theory.add_thmss
<               [((Binding.make (Binding.name_of binding ^ indeps_suffix, Position.none), map (indep_proof thy) (pairings ((map ldef_name lnames) @ [mldef_name])) @ map (parent_indep_proof_1 thy plchild) plnames @ map (parent_indep_proof_2 thy plchild) plnames), [Simplifier.simp_add])] thy))
<          |> fold (fn x => fn thy => snd (Global_Theory.add_thm ((Binding.make (x ^ vwb_lens_suffix, Position.none), lens_child_proof thy x), [Simplifier.simp_add]) thy)) plnames
<          |> (fn thy => snd (Global_Theory.add_thmss
<               [((Binding.make (Binding.name_of binding ^ pl_indeps_suffix, Position.none), map (pl_indep_proof thy) (pairings (plnames))), [Simplifier.simp_add])] thy))
<          |> (fn thy => snd (Global_Theory.add_thmss [((Binding.make (Binding.name_of binding ^ sublens_suffix, Position.none), map (sublens_proof thy plchild) plnames), [Simplifier.simp_add])] thy))
---
>          |> (fn thy => snd (add_thmss
>               [((Binding.make (indepsN, Position.none), map (indep_proof tname thy) (pairings (lnames @ [child_lensN]) @ pairings [base_lensN, child_lensN]) (*@ map (parent_indep_proof_1 tname pname thy plchild) plnames @ map (parent_indep_proof_2 tname pname thy plchild) plnames *) @ pindeps thy), [Simplifier.simp_add])] thy))
>             (* Add equivalence properties *)
>          |> (fn thy => snd (add_thmss
>               [((Binding.make (equivN, Position.none), (if (raw_parent = NONE) then [] else [equiv_more_proof tname pname thy lnames]) @ [equiv_base_proof tname parent thy lnames, equiv_partition_proof tname thy]), [Simplifier.simp_add])] thy))
>             (* Add a symmetric lens proof for the base and more lenses *)
>          |> (fn thy => snd (add_thm ((Binding.make (all_lensN ^ sym_lens_suffix, Position.none), lens_sym_proof tname thy), [Simplifier.simp_add]) thy)) 
>          |> Sign.parent_path
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Lens_State.thy ../../AFPs/afp-2020/thys/Optics/Lens_State.thy
7a8
> 
68,70c69,71
< unfolding modify_def zoom_def update_def State_Monad.update_def State_Monad.get_def State_Monad.set_def State_Monad.bind_def
< by auto
< 
---
>   unfolding modify_def zoom_def lens_update_def State_Monad.update_def State_Monad.get_def State_Monad.set_def State_Monad.bind_def
>   by (auto)
>  
72c73
< unfolding update_def modify_alt_def
---
> unfolding lens_update_def modify_alt_def
Only in ../../AFPs/afp-2020/thys/Optics: Lens_Symmetric.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Scenes.thy ../../AFPs/afp-2020/thys/Optics/Scenes.thy
93a94,100
> definition scene_equiv :: "'a \<Rightarrow> 'a \<Rightarrow> ('a scene) \<Rightarrow> bool" ("_ \<approx>\<^sub>S _ on _" [65,0,66] 65) where
> [lens_defs]: "S\<^sub>1 \<approx>\<^sub>S S\<^sub>2 on X = (S\<^sub>1 \<oplus>\<^sub>S S\<^sub>2 on X = S\<^sub>1)"
> 
> lemma scene_equiv_region: "idem_scene X \<Longrightarrow> region X = {(S\<^sub>1, S\<^sub>2). S\<^sub>1 \<approx>\<^sub>S S\<^sub>2 on X}"
>   by (simp add: lens_defs, transfer, auto)
>      (metis idem_overrider.ovr_idem, metis overrider.ovr_overshadow_right)
> 
107c114
<                                                   
---
> 
138c145
<     "inf_scene X Y = - (sup (- X) (- Y))"
---
>     [lens_defs]: "inf_scene X Y = - (sup (- X) (- Y))"
177a185,190
> lemma scene_union_pres_compat: "\<lbrakk> A ##\<^sub>S B; A ##\<^sub>S C \<rbrakk> \<Longrightarrow> A ##\<^sub>S (B \<squnion>\<^sub>S C)"
>   by (transfer, auto)
> 
> lemma scene_indep_self_compl: "A \<bowtie>\<^sub>S -A"
>   by (transfer, simp)
> 
180a194,198
>   using assms by (transfer, auto)
> 
> lemma scene_inter_indep:
>   assumes "idem_scene X" "idem_scene Y" "X \<bowtie>\<^sub>S Y"
>   shows "X \<sqinter>\<^sub>S Y = \<bottom>\<^sub>S"
182c200,204
<   by (transfer, auto)
---
>   unfolding lens_defs
>   apply (transfer, auto)
>   apply (metis (no_types, hide_lams) idem_overrider.ovr_idem overrider.ovr_assoc overrider.ovr_overshadow_right)
>   apply (metis (no_types, hide_lams) idem_overrider.ovr_idem overrider.ovr_overshadow_right)
>   done
204a227,229
> lemma scene_compat_top: "idem_scene X \<Longrightarrow> X ##\<^sub>S \<top>\<^sub>S"
>   by (transfer, simp)
> 
210c235
<   "less_eq_scene X Y = (\<forall> s\<^sub>1 s\<^sub>2 s\<^sub>3. s\<^sub>1 \<oplus>\<^sub>S s\<^sub>2 on Y \<oplus>\<^sub>S s\<^sub>3 on X = s\<^sub>1 \<oplus>\<^sub>S (s\<^sub>2 \<oplus>\<^sub>S s\<^sub>3 on X) on Y)"
---
>   [lens_defs]: "less_eq_scene X Y = (\<forall> s\<^sub>1 s\<^sub>2 s\<^sub>3. s\<^sub>1 \<oplus>\<^sub>S s\<^sub>2 on Y \<oplus>\<^sub>S s\<^sub>3 on X = s\<^sub>1 \<oplus>\<^sub>S (s\<^sub>2 \<oplus>\<^sub>S s\<^sub>3 on X) on Y)"
212c237
<   "less_scene x y = (x \<le> y \<and> \<not> y \<le> x)"
---
>   [lens_defs]: "less_scene x y = (x \<le> y \<and> \<not> y \<le> x)"
245a271,277
> lemma scene_le_then_compat: "\<lbrakk> idem_scene X; idem_scene Y; X \<le> Y \<rbrakk> \<Longrightarrow> X ##\<^sub>S Y"
>   unfolding less_eq_scene_def
>   by (transfer, auto, metis (no_types, lifting) idem_overrider.ovr_idem overrider_def)
> 
> lemma indep_then_compl_in: "A \<bowtie>\<^sub>S B \<Longrightarrow> A \<le> -B"
>   unfolding less_eq_scene_def by (transfer, simp)
> 
264a297,299
> lemma lens_compat_scene: "\<lbrakk> mwb_lens X; mwb_lens Y \<rbrakk> \<Longrightarrow> X ##\<^sub>L Y \<longleftrightarrow> \<lbrakk>X\<rbrakk>\<^sub>\<sim> ##\<^sub>S \<lbrakk>Y\<rbrakk>\<^sub>\<sim>"
>   by (auto simp add: lens_scene.rep_eq scene_compat.rep_eq lens_defs)
> 
337c372,395
< text \<open> Hide implementation details for scenes \<close>
---
> subsection \<open> Function Domain Scene \<close>
> 
> lift_definition fun_dom_scene :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b) scene" ("fds") is
> "\<lambda> A f g. override_on f g A" by (unfold_locales, simp_all add: override_on_def fun_eq_iff)
> 
> lemma fun_dom_scene_empty: "fds({}) = \<bottom>\<^sub>S"
>   by (transfer, simp)
> 
> lemma fun_dom_scene_union: "fds(A \<union> B) = fds(A) \<squnion>\<^sub>S fds(B)"
>   by (transfer, auto simp add: fun_eq_iff override_on_def)
> 
> lemma fun_dom_scene_compl: "fds(- A) = - fds(A)"
>   by (transfer, auto simp add: fun_eq_iff override_on_def)
> 
> lemma fun_dom_scene_inter: "fds(A \<inter> B) = fds(A) \<sqinter>\<^sub>S fds(B)"
>   by (simp add: inf_scene_def fun_dom_scene_union[THEN sym] fun_dom_scene_compl[THEN sym])
> 
> lemma fun_dom_scene_UNIV: "fds(UNIV) = \<top>\<^sub>S"
>   by (transfer, auto simp add: fun_eq_iff override_on_def)
> 
> lemma fun_dom_scene_always_compat [simp]: "fds(A) ##\<^sub>S fds(B)"
>   by (transfer, simp add: override_on_def fun_eq_iff)
> 
> text \<open> Hide implementation details for scenes \<close>  
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Optics/Two.thy ../../AFPs/afp-2020/thys/Optics/Two.thy
1c1
< section \<open>Types of Cardinality 2 or Greater\<close>
---
> section {* Types of Cardinality 2 or Greater *}
7c7
< text \<open>The two class states that a type's carrier is either infinite, or else it has a finite 
---
> text {* The two class states that a type's carrier is either infinite, or else it has a finite 
9c9
<   elements.\<close>
---
>   elements. *}
==========
Order_Lattice_Props
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy ../../AFPs/afp-2020/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy
320c320
<   unfolding downset_prop by (simp add: Collect_ball_eq Inf_Sup)
---
>   unfolding downset_prop by (simp add: Collect_ball_eq Inf_eq_Sup)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Order_Lattice_Props/Order_Lattice_Props.thy ../../AFPs/afp-2020/thys/Order_Lattice_Props/Order_Lattice_Props.thy
501c501
<   unfolding downset_prop by (simp add: Collect_ball_eq Inf_Sup)
---
>   unfolding downset_prop by (simp add: Collect_ball_eq Inf_eq_Sup)
652c652
<   unfolding upset_prop by (simp add: Collect_ball_eq Sup_Inf)
---
>   unfolding upset_prop by (simp add: Collect_ball_eq Sup_eq_Inf)
==========
Ordinary_Differential_Equations
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex: ARCH_COMP
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Ex: Examples_ARCH_COMP.thy
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex/Lorenz: C0
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex/Lorenz: C1
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Ex/Lorenz/Lorenz_Approximation.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex/Lorenz/Lorenz_Approximation.thy
209c209
< definition "mig_aforms p x = real_of_float ((fst o the) ((approx p (Norm (map (Num o float_of o (mig_aform p)) x))) []))"
---
> definition "mig_aforms p x = real_of_float ((lower o the) ((approx p (Norm (map (Num o float_of o (mig_aform p)) x))) []))"
515c515
<   Some (map (real_of_float o fst) res, map (real_of_float o snd) res)
---
>   Some (map (real_of_float o lower) res, map (real_of_float o upper) res)
904,906c904,905
<     from this *(2)
<     have "((\<lambda>s. (lorenz.flow0 x0 (s + t))) \<longlongrightarrow> 0) at_top"
<       by (rule Lim_transform_eventually)
---
>     then have "((\<lambda>s. (lorenz.flow0 x0 (s + t))) \<longlongrightarrow> 0) at_top"
>       by (blast intro: * Lim_transform_eventually)
2575c2574
<         "lorenz.returns_to \<Sigma> x" "x \<in> \<Sigma>\<^sub>l\<^sub>e"
---
>         and "lorenz.returns_to \<Sigma> x" and "x \<in> \<Sigma>\<^sub>l\<^sub>e"
2582,2588d2580
<   have evret: "\<forall>\<^sub>F x in at x within \<Sigma>\<^sub>l\<^sub>e. (x::R3) returns_to \<Sigma>"
<     apply (rule lorenz.eventually_returns_to_continuousI[of \<Sigma> x \<Sigma>\<^sub>l\<^sub>e])
<     apply fact
<      apply (rule closed_\<Sigma>)
<     apply (rule has_derivative_continuous)
<     apply fact
<     done
2590c2582,2589
<   show ?thesis
---
>   have "\<forall>\<^sub>F x in at x within \<Sigma>\<^sub>l\<^sub>e. (x::R3) returns_to \<Sigma>"
>     by (blast intro: lorenz.eventually_returns_to_continuousI has_derivative_continuous assms)
>   then have "\<forall>\<^sub>F y in at x within \<Sigma>\<^sub>l\<^sub>e.
>                inverse (norm (y - x)) * (lorenz.return_time \<Sigma> y - lorenz.return_time \<Sigma> x - D (y - x))
>              = inverse (norm (lorenz_S y - lorenz_S x)) *
>                (lorenz.return_time \<Sigma> (lorenz_S y) - lorenz.return_time \<Sigma> (lorenz_S x) - D (y - x))"
>       by eventually_elim (auto simp: lorenz_S_return_time assms diff[symmetric])
>   then show ?thesis
2598,2602c2597
<     apply (rule Lim_transform_eventually) defer apply assumption
<     subgoal premises prems
<       using evret
<       apply (eventually_elim)
<       by (auto simp: lorenz_S_return_time assms diff[symmetric])
---
>     apply (blast intro: Lim_transform_eventually)
2633,2639d2627
<   have evret: "\<forall>\<^sub>F x in at x within \<Sigma>\<^sub>l\<^sub>e. (x::R3) returns_to \<Sigma>"
<     apply (rule lorenz.eventually_returns_to_continuousI[of \<Sigma> x \<Sigma>\<^sub>l\<^sub>e])
<     apply fact
<      apply (rule closed_\<Sigma>)
<     apply (rule has_derivative_continuous)
<     apply fact
<     done
2641c2629,2637
<   show ?thesis
---
>   have "\<forall>\<^sub>F x in at x within \<Sigma>\<^sub>l\<^sub>e. (x::R3) returns_to \<Sigma>"
>     by (blast intro: lorenz.eventually_returns_to_continuousI has_derivative_continuous assms)
>   then have "\<forall>\<^sub>F y in at x within \<Sigma>\<^sub>l\<^sub>e.
>                  (lorenz_S (lorenz.poincare_map \<Sigma> y) - lorenz_S (lorenz.poincare_map \<Sigma> x) - lorenz_S (D (y - x))) /\<^sub>R
>                  norm (y - x) 
>                = (lorenz.poincare_map \<Sigma> (lorenz_S y) - lorenz.poincare_map \<Sigma> (lorenz_S x) - lorenz_S (D (y - x))) /\<^sub>R
>                  norm (lorenz_S y - lorenz_S x)"
>     by eventually_elim (auto simp: lorenz_S_return_time lorenz_S_poincare_map assms diff[symmetric])
>   then show ?thesis
2650,2655c2646
<     apply (rule Lim_transform_eventually) defer apply assumption
<     subgoal premises prems
<       using evret
<       apply (eventually_elim)
<       apply (auto simp: lorenz_S_return_time lorenz_S_poincare_map assms diff[symmetric])
<       done
---
>     apply (blast intro: Lim_transform_eventually)
2701,2703c2692,2693
<   if "{0..} \<subseteq> lorenz.existence_ivl0 x"
<     "(lorenz.flow0 x \<longlongrightarrow> 0) at_top"
< proof -
---
>   if "{0..} \<subseteq> lorenz.existence_ivl0 x" "(lorenz.flow0 x \<longlongrightarrow> 0) at_top"
> proof (rule Lim_transform_eventually)
2706c2696
<   then have "\<forall>\<^sub>F s in at_top. lorenz_S (lorenz.flow0 x s) = lorenz.flow0 (lorenz_S x) s"
---
>   then show "\<forall>\<^sub>F s in at_top. lorenz_S (lorenz.flow0 x s) = lorenz.flow0 (lorenz_S x) s"
2708,2712c2698,2699
<   moreover have "((\<lambda>s. lorenz_S (lorenz.flow0 x s)) \<longlongrightarrow> 0) at_top"
<     unfolding Zfun_def[symmetric]
<       by (rule bounded_linear.tendsto_zero[OF bl_lorenz_S that(2)])
<   ultimately show "(lorenz.flow0 (lorenz_S x) \<longlongrightarrow> 0) at_top"
<     by (rule Lim_transform_eventually)
---
>   show "((\<lambda>s. lorenz_S (lorenz.flow0 x s)) \<longlongrightarrow> 0) at_top"
>     unfolding Zfun_def[symmetric] by (rule bounded_linear.tendsto_zero[OF bl_lorenz_S that(2)])
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Ex/Lorenz: Lorenz_C0.thy
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Ex/Lorenz: Lorenz_C1.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Ex/Lorenz/Result_Elements.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex/Lorenz/Result_Elements.thy
64c64
< definition "get_return_grids tlist upper fg =
---
> definition "get_return_grids tlist uppr fg =
66c66
<   in if upper then map mirror_upper ret else ret)"
---
>   in if uppr then map mirror_upper ret else ret)"
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Ex: ODE_Examples.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Cones.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Cones.thy
260c260
<   by (auto simp: divide_simps sign_simps)
---
>   by (auto simp: algebra_simps)
278c278
<   by (auto simp: vangle_def divide_simps sign_simps split: if_splits)
---
>   by (auto simp: vangle_def divide_simps algebra_split_simps split: if_splits)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Flow.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Flow.thy
1843a1844,1871
> lemma
>   flow_in_compact_right_existence:
>   assumes "\<And>t. 0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> K"
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "t \<ge> 0"
>   shows "t \<in> existence_ivl0 x"
> proof (rule ccontr)
>   assume "t \<notin> existence_ivl0 x"
>   have "bdd_above (existence_ivl0 x)"
>     by (rule bdd_above_is_intervalI[OF is_interval_existence_ivl \<open>0 \<le> t\<close> existence_ivl_zero]) fact+
>   from sup_existence_maximal[OF UNIV_I \<open>x \<in> X\<close> assms(1-3) this]
>   show False by auto
> qed
> 
> lemma
>   flow_in_compact_left_existence:
>   assumes "\<And>t. t \<le> 0 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> K"
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "t \<le> 0"
>   shows "t \<in> existence_ivl0 x"
> proof (rule ccontr)
>   assume "t \<notin> existence_ivl0 x"
>   have "bdd_below (existence_ivl0 x)"
>     by (rule bdd_below_is_intervalI[OF is_interval_existence_ivl \<open>t \<le> 0\<close> _ existence_ivl_zero]) fact+
>   from inf_existence_minimal[OF UNIV_I \<open>x \<in> X\<close> assms(1-3) this]
>   show False by auto
> qed
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Initial_Value_Problem.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Initial_Value_Problem.thy
888c888
<     "tmin \<le> t \<Longrightarrow> t \<le> tmax \<Longrightarrow> apply_bcontfun g t = P_inner (apply_bcontfun x) t"
---
>     "t \<in> {tmin .. tmax} \<Longrightarrow> apply_bcontfun g t = P_inner (apply_bcontfun x) t"
891c891
<     by (metis continuous_on_interval_bcontfunE[OF cont_P_inner_ivl[OF assms(1)]])
---
>     by (metis continuous_on_cbox_bcontfunE cont_P_inner_ivl[OF assms(1)] cbox_interval)
1150,1151c1150,1151
<   have "continuous_on {tmin .. tmax} x" by simp
<   from continuous_on_interval_bcontfunE[OF this]
---
>   have "continuous_on (cbox tmin tmax) x" by simp
>   from continuous_on_cbox_bcontfunE[OF this]
1153c1153
<     "tmin \<le> t \<Longrightarrow> t \<le> tmax \<Longrightarrow> apply_bcontfun g t = x t"
---
>     "t \<in> {tmin .. tmax} \<Longrightarrow> apply_bcontfun g t = x t"
1156c1156
<     by metis
---
>     by (metis interval_cbox)
1158c1158
<     by (metis (no_types, lifting) solves_ode_cong tmax(1) tmin(1))
---
>     by (metis (no_types, lifting) solves_ode_cong)
1165c1165
<     unfolding mem_PiC_iff
---
>     unfolding mem_PiC_iff atLeastAtMost_iff
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Poincare_Map.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Poincare_Map.thy
352,353c352
<   assumes "isCont f' a"
<   assumes "0 < e"
---
>   assumes "isCont f' a" "0 < e"
355,359c354,361
<   using assms
<   unfolding isCont_def
<   by (force dest!: tendstoD[OF _ \<open>0 < e\<close>]
<       simp: eventually_at dist_commute dist_norm norm_blinfun.rep_eq
<         blinfun.bilinear_simps[symmetric])
---
> proof -
>   have "\<forall>\<^sub>F x in at a. dist (f' x) (f' a) < e"
>     using assms isCont_def tendsto_iff by blast
>   then show ?thesis
>     using \<open>e > 0\<close> norm_eq_zero
>     by (force simp: eventually_at dist_commute dist_norm norm_blinfun.rep_eq
>         simp flip: blinfun.bilinear_simps)
> qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Reachability_Analysis.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Reachability_Analysis.thy
274c274
<   moreover have "S \<subseteq> ?X \<union> ?Y" "?X \<inter> ?Y \<inter> S = {}"
---
>   moreover have "?X \<inter> ?Y \<inter> S = {}" "S \<subseteq> ?X \<union> ?Y"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/IVP/Upper_Lower_Solution.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/IVP/Upper_Lower_Solution.thy
114c114
<       by (rule Lim_transform_eventually[THEN tendsto_eq_rhs]) auto
---
>       by (force intro: tendsto_eq_rhs Lim_transform_eventually)
345c345
<         using f1 calculation by blast
---
>         using f1 calculation by meson
438c438
<         using f1 calculation by blast
---
>         using f1 calculation by meson
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Library/Interval_Integral_HK.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Library/Interval_Integral_HK.thy
221,226c221,226
<       integral_combine[of a b c f]
<       integral_combine[of a c b f]
<       integral_combine[of b a c f]
<       integral_combine[of b c a f]
<       integral_combine[of c a b f]
<       integral_combine[of c b a f]
---
>       Henstock_Kurzweil_Integration.integral_combine[of a b c f]
>       Henstock_Kurzweil_Integration.integral_combine[of a c b f]
>       Henstock_Kurzweil_Integration.integral_combine[of b a c f]
>       Henstock_Kurzweil_Integration.integral_combine[of b c a f]
>       Henstock_Kurzweil_Integration.integral_combine[of c a b f]
>       Henstock_Kurzweil_Integration.integral_combine[of c b a f]
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Library: Transfer_Analysis.thy
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Library: Transfer_ODE.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Abstract_Reachability_Analysis_C1.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Abstract_Reachability_Analysis_C1.thy
367,368c367,369
<       of Some (h'', _) \<Rightarrow>
<         let _ = trace_set1 (ST ''increase step: stepsize = '' @ show (lfloat10 h'')) (None::'n eucl1 set option)
---
>       of Some ivl_h'' \<Rightarrow>
>         let h'' = lower ivl_h'';
>             _ = trace_set1 (ST ''increase step: stepsize = '' @ show (lfloat10 h'')) (None::'n eucl1 set option)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Abstract_Reachability_Analysis.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Abstract_Reachability_Analysis.thy
1126,1128c1126,1129
< definition "adapt_stepsize_fa rtol mid e h' =
<   floatarith.Num (float_of h') * floatarith.Powr (floatarith.Num (float_of (rtol)) / floatarith.Num (float_of e))
<                                 (inverse (floatarith.Num (float_of (real_of_nat mid) + 1)))"
---
> definition "adapt_stepsize_fa rtol m e h' =
>   floatarith.Num (float_of h') *
>   floatarith.Powr (floatarith.Num (float_of (rtol)) / floatarith.Num (float_of e))
>     (inverse (floatarith.Num (float_of (real_of_nat m) + 1)))"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Concrete_Reachability_Analysis_C1.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Concrete_Reachability_Analysis_C1.thy
676a677,680
> lemma lower_impl[autoref_rules]: "(lower, lower) \<in> Id \<rightarrow> Id"
>   and upper_impl[autoref_rules]: "(lower, lower) \<in> Id \<rightarrow> Id"
>   by auto
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Concrete_Reachability_Analysis.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Concrete_Reachability_Analysis.thy
441c441
<   "(approx, approx) \<in> nat_rel \<rightarrow> Id \<rightarrow> \<langle>\<langle>Id \<times>\<^sub>r Id\<rangle>option_rel\<rangle>list_rel \<rightarrow> \<langle>Id \<times>\<^sub>r Id\<rangle>option_rel"
---
>   "(approx, approx) \<in> nat_rel \<rightarrow> Id \<rightarrow> \<langle>\<langle>Id\<rangle>option_rel\<rangle>list_rel \<rightarrow> \<langle>Id\<rangle>option_rel"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Example_Utilities.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Example_Utilities.thy
1538c1538
<   "approx prec fa [] = Some (fst (the (approx prec fa [])), snd (the (approx prec fa [])))"
---
>   "approx prec fa [] = Some (the (approx prec fa []))"
1543,1544c1543,1544
< definition [simp]: "approx1 p f xs = real_of_float (fst (the (approx p f xs)))"
< definition [simp]: "approx2 p f xs = real_of_float (snd (the (approx p f xs)))"
---
> definition [simp]: "approx1 p f xs = real_of_float (lower (the (approx p f xs)))"
> definition [simp]: "approx2 p f xs = real_of_float (upper (the (approx p f xs)))"
1549c1549
<   (case approxs p f xs of Some y \<Rightarrow> (map (real_of_float o fst) y) | None \<Rightarrow> replicate (length f) 0)"
---
>   (case approxs p f xs of Some y \<Rightarrow> (map (real_of_float o lower) y) | None \<Rightarrow> replicate (length f) 0)"
1551c1551
<   (case approxs p f xs of Some y \<Rightarrow> (map (real_of_float o snd) y) | None \<Rightarrow> replicate (length f) 0)"
---
>   (case approxs p f xs of Some y \<Rightarrow> (map (real_of_float o upper) y) | None \<Rightarrow> replicate (length f) 0)"
1564,1565c1564
<   by (auto dest: approx_emptyD)
< 
---
>   by (force dest: approx_emptyD simp: set_of_eq)
1574c1573
<   by (auto dest: approx_emptyD)
---
>   by (force dest: approx_emptyD simp: set_of_eq)
1582c1581
<   "interpret_floatarith (fas ! ia) xs \<in> {real_of_float (fst (ys ! ia)) .. (snd (ys ! ia))}"
---
>   "interpret_floatarith (fas ! ia) xs \<in> {real_of_float (lower (ys ! ia)) .. (upper (ys ! ia))}"
1589c1588
<   from ex[of ia] that obtain l u where lu: "Some (l, u) = approx prec (fas ! ia) XS" by auto
---
>   from ex[of ia] that obtain ivl where ivl: "approx prec (fas ! ia) XS = Some ivl" by auto
1591c1590
<   have "real_of_float l \<le> interpret_floatarith (fas ! ia) xs \<and> interpret_floatarith (fas ! ia) xs \<le> real_of_float u"
---
>   have "interpret_floatarith (fas ! ia) xs \<in>\<^sub>r ivl"
1594c1593
<   have "ys ! ia = (l, u)"
---
>   have "ys ! ia = ivl"
1599c1598
<     using lu[symmetric] by simp
---
>     using ivl by simp
1602c1601
<     by (auto simp: approxs_eq_Some_lengthD split: prod.splits)
---
>     by (auto simp: approxs_eq_Some_lengthD set_of_eq split: prod.splits)
1610c1609
<     {eucl_of_list (map fst ys) .. eucl_of_list (map snd ys)::'a::executable_euclidean_space}"
---
>     {eucl_of_list (map lower ys) .. eucl_of_list (map upper ys)::'a::executable_euclidean_space}"
1624c1623
<   subgoal for a fas aa b
---
>   subgoal for a fas aa
2100,2101c2099,2100
<     "Nil::(float \<times> float) option list"
<     "Cons::_\<Rightarrow>_\<Rightarrow>(float \<times> float) option list"
---
>     "Nil::(float interval) option list"
>     "Cons::_\<Rightarrow>_\<Rightarrow>(float interval) option list"
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics: ODE_Numerics.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Refine_Reachability_Analysis_C1.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Refine_Reachability_Analysis_C1.thy
2469,2477c2469,2478
<   have "\<forall>\<^sub>F x in at_top. x > max t 0"
<     by (simp add: max_def)
<   then have "\<forall>\<^sub>F x in at_top. flow0 (flow0 x0 t) x = flow0 x0 (t + x)"
<     apply eventually_elim
<     apply (subst flow_trans)
<     using 2
<     by auto
<   from this 2(3) have "((\<lambda>s. flow0 x0 (t + s)) \<longlongrightarrow> trap) (at_top)"
<     by (rule Lim_transform_eventually)
---
>   have "((\<lambda>s. flow0 x0 (t + s)) \<longlongrightarrow> trap) (at_top)"
>   proof (rule Lim_transform_eventually)
>     have "\<forall>\<^sub>F x in at_top. x > max t 0"
>       by (simp add: max_def)
>     then show "\<forall>\<^sub>F x in at_top. flow0 (flow0 x0 t) x = flow0 x0 (t + x)"
>       apply eventually_elim
>       apply (subst flow_trans)
>       using 2
>       by auto
>   qed (use 2 in auto)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Refine_Reachability_Analysis.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Refine_Reachability_Analysis.thy
857c857
<       subgoal by (force simp: ncc_def nonempty_def)\<comment> \<open>unnecessarily slow\<close>
---
>       subgoal by (auto simp: ncc_def nonempty_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Refine_Rigorous_Numerics_Aform.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Refine_Rigorous_Numerics_Aform.thy
706c706
< lemma approx_un_ne_None: "approx_un p (\<lambda>l u. Some (f l u)) (Some r) \<noteq> None"
---
> lemma approx_un_ne_None: "approx_un p (\<lambda>ivl. Some (f ivl)) (Some r) \<noteq> None"
710,712c710,711
<   "approx_un p (\<lambda>l u. Some (f l u)) (Some r) = Some s \<longleftrightarrow>
<   s = ivl_err ((fst (f (Inf_aform_err p r) (Sup_aform_err p r))))
<         ((snd (f (Inf_aform_err p r) (Sup_aform_err p r))))"
---
>   "approx_un p (\<lambda>ivl. Some (f ivl)) (Some r) = Some s \<longleftrightarrow>
>   s = ivl_err (real_interval (f (ivl_of_aform_err p r)))"
753c752
<   assumes "ivl_err (x1) (x2) = ((a, b), c)" "is_float x1" "is_float x2"
---
>   assumes "ivl_err x = ((a, b), c)" "is_float (lower x)" "is_float (upper x)"
755a755,756
>   define x1 where "x1 = lower x"
>   define x2 where "x2 = upper x"
757c758
<     using assms by (auto simp: ivl_err_def)
---
>     using assms by (auto simp: ivl_err_def x1_def x2_def)
760c761
<     by (auto simp: is_float_def)
---
>     by (auto simp: is_float_def x1_def x2_def)
797,798c798,799
<   subgoal by (auto simp: bind_eq_Some_conv uminus_aform_def Let_def is_float_min_range
<         is_float_ivl_err
---
>   subgoal apply (auto simp: bind_eq_Some_conv uminus_aform_def Let_def is_float_min_range
>         is_float_ivl_err set_of_eq real_interval_abs
799a801,802
>     apply (metis is_float_ivl_err(1) is_float_simps(3) lower_real_interval real_interval_abs upper_real_interval)
>     by (metis is_float_ivl_err(2) is_float_simps(3) lower_real_interval real_interval_abs upper_real_interval)
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics: Transfer_Analysis.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/Numerics/Transfer_Euclidean_Space_Vector.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics/Transfer_Euclidean_Space_Vector.thy
4c4
<   "../Library/Transfer_ODE"
---
>   Transfer_ODE
Only in ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/Numerics: Transfer_ODE.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations/ODE_Auxiliarities.thy ../../AFPs/afp-2020/thys/Ordinary_Differential_Equations/ODE_Auxiliarities.thy
117a118,123
> lemma bdd_above_is_intervalI: "bdd_above I" if "is_interval I" "a \<le> b" "a \<in> I" "b \<notin> I" for I::"real set"
>   by (meson bdd_above_def is_interval_1 le_cases that)
> 
> lemma bdd_below_is_intervalI: "bdd_below I" if "is_interval I" "a \<le> b" "a \<notin> I" "b \<in> I" for I::"real set"
>   by (meson bdd_below_def is_interval_1 le_cases that)
> 
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations: ODE_Examples.thy
Only in ../../AFPs/afp-2019/thys/Ordinary_Differential_Equations: ODE_Numerics.thy
==========
Pairing_Heap
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Pairing_Heap/Pairing_Heap_List1.thy ../../AFPs/afp-2020/thys/Pairing_Heap/Pairing_Heap_List1.thy
71a72,75
> fun mset_heap :: "'a heap \<Rightarrow>'a multiset" where
> "mset_heap Empty = {#}" |
> "mset_heap (Hp x hs) = {#x#} + Union_mset(mset(map mset_heap hs))"
> 
74c78
< "pheap (Hp x hs) = (\<forall>h \<in> set hs. (\<forall>y \<in> set_heap h. x \<le> y) \<and> pheap h)"
---
> "pheap (Hp x hs) = (\<forall>h \<in> set hs. (\<forall>y \<in># mset_heap h. x \<le> y) \<and> pheap h)"
94,100d97
< fun mset_heap :: "'a heap \<Rightarrow>'a multiset" where
< "mset_heap Empty = {#}" |
< "mset_heap (Hp x hs) = {#x#} + Union_mset(mset(map mset_heap hs))"
< 
< lemma set_mset_mset_heap: "set_mset (mset_heap h) = set_heap h"
< by(induction h) auto
< 
104c101
< lemma get_min_in: "h \<noteq> Empty \<Longrightarrow> get_min h \<in> set_heap(h)"
---
> lemma get_min_in: "h \<noteq> Empty \<Longrightarrow> get_min h \<in># mset_heap(h)"
107c104
< lemma get_min_min: "\<lbrakk> h \<noteq> Empty; pheap h; x \<in> set_heap(h) \<rbrakk> \<Longrightarrow> get_min h \<le> x"
---
> lemma get_min_min: "\<lbrakk> h \<noteq> Empty; pheap h; x \<in># mset_heap(h) \<rbrakk> \<Longrightarrow> get_min h \<le> x"
111c108
< by (metis Min_eqI finite_set_mset get_min_in get_min_min set_mset_mset_heap)
---
> by (metis Min_eqI finite_set_mset get_min_in get_min_min )
==========
Partial_Function_MR
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Partial_Function_MR/partial_function_mr.ML ../../AFPs/afp-2020/thys/Partial_Function_MR/partial_function_mr.ML
318c318
<           Spec_Rules.add Spec_Rules.equational_recdef ([f], simps)
---
>           Spec_Rules.add Binding.empty Spec_Rules.equational_recdef [f] simps
==========
Partial_Order_Reduction
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Partial_Order_Reduction/Basics/Stuttering.thy ../../AFPs/afp-2020/thys/Partial_Order_Reduction/Basics/Stuttering.thy
51,52c51,52
<       nth_least s k < i \<longrightarrow> i < nth_least s (Suc k) \<longrightarrow> w ? i = w ? nth_least s k) \<and>
<       (\<forall> i. enat i < llength w \<longrightarrow> finite s \<longrightarrow> Max s < i \<longrightarrow> w ? i = w ? Max s)"
---
>       nth_least s k < i \<longrightarrow> i < nth_least s (Suc k) \<longrightarrow> w ?! i = w ?! nth_least s k) \<and>
>       (\<forall> i. enat i < llength w \<longrightarrow> finite s \<longrightarrow> Max s < i \<longrightarrow> w ?! i = w ?! Max s)"
57,58c57,58
<       nth_least s k < i \<Longrightarrow> i < nth_least s (Suc k) \<Longrightarrow> w ? i = w ? nth_least s k"
<     assumes "\<And> i. enat i < llength w \<Longrightarrow> finite s \<Longrightarrow> Max s < i \<Longrightarrow> w ? i = w ? Max s"
---
>       nth_least s k < i \<Longrightarrow> i < nth_least s (Suc k) \<Longrightarrow> w ?! i = w ?! nth_least s k"
>     assumes "\<And> i. enat i < llength w \<Longrightarrow> finite s \<Longrightarrow> Max s < i \<Longrightarrow> w ?! i = w ?! Max s"
69c69
<     shows "w ? i = w ? nth_least s k"
---
>     shows "w ?! i = w ?! nth_least s k"
74c74
<     shows "w ? i = w ? Max s"
---
>     shows "w ?! i = w ?! Max s"
87c87
<     show "w ? i = w ? nth_least_ext s k"
---
>     show "w ?! i = w ?! nth_least_ext s k"
90c90
<       have "w ? i = w ? nth_least s k"
---
>       have "w ?! i = w ?! nth_least s k"
98c98
<       also have "w ? nth_least s k = w ? nth_least_ext s k" using less by auto
---
>       also have "w ?! nth_least s k = w ?! nth_least_ext s k" using less by auto
104c104
<       have 4: "\<And> i. i > Max s \<Longrightarrow> w ? i = w ? Max s" using assms 3 by auto
---
>       have 4: "\<And> i. i > Max s \<Longrightarrow> w ?! i = w ?! Max s" using assms 3 by auto
110,111c110,111
<       have "w ? i = w ? Max s" using 1(1) 4 6 by auto
<       also have "\<dots> = w ? nth_least_ext s k" unfolding 6 by rule
---
>       have "w ?! i = w ?! Max s" using 1(1) 4 6 by auto
>       also have "\<dots> = w ?! nth_least_ext s k" unfolding 6 by rule
117,120c117,120
<       have 4: "\<And> i. i > Max s \<Longrightarrow> w ? i = w ? Max s" using assms 3 by auto
<       have "w ? i = w ? Max s" using 1(1) 2 4 by auto 
<       also have "\<dots> = w ? Suc (Max s + (k - card s))" using 4 by simp
<       also have "\<dots> = w ? nth_least_ext s k" using 2 by simp
---
>       have 4: "\<And> i. i > Max s \<Longrightarrow> w ?! i = w ?! Max s" using assms 3 by auto
>       have "w ?! i = w ?! Max s" using 1(1) 2 4 by auto 
>       also have "\<dots> = w ?! Suc (Max s + (k - card s))" using 4 by simp
>       also have "\<dots> = w ?! nth_least_ext s k" using 2 by simp
138c138
<       show "u ? nth_least_ext s i = v ? nth_least_ext t i" 
---
>       show "u ?! nth_least_ext s i = v ?! nth_least_ext t i" 
143,148c143,148
<         have "u ? nth_least_ext s i = u ? nth_least s i" using True by simp
<         also have "\<dots> = lselect s u ? i" using 3(1) by simp
<         also have "\<dots> = lselect t v ? i" unfolding assms(5) by rule
<         also have "\<dots> = v ? nth_least t i" using 3(2) by simp
<         also have "\<dots> = v ? nth_least_ext t i" using True unfolding 2 by simp
<         finally show "u ? nth_least_ext s i = v ? nth_least_ext t i" by this
---
>         have "u ?! nth_least_ext s i = u ?! nth_least s i" using True by simp
>         also have "\<dots> = lselect s u ?! i" using 3(1) by simp
>         also have "\<dots> = lselect t v ?! i" unfolding assms(5) by rule
>         also have "\<dots> = v ?! nth_least t i" using 3(2) by simp
>         also have "\<dots> = v ?! nth_least_ext t i" using True unfolding 2 by simp
>         finally show "u ?! nth_least_ext s i = v ?! nth_least_ext t i" by this
153,154c153,154
<         have 5: "\<And> i. i > Max s \<Longrightarrow> u ? i = u ? Max s" using assms(1, 3) 4(1) by auto
<         have 6: "\<And> i. i > Max t \<Longrightarrow> v ? i = v ? Max t" using assms(2, 4) 4(2) by auto
---
>         have 5: "\<And> i. i > Max s \<Longrightarrow> u ?! i = u ?! Max s" using assms(1, 3) 4(1) by auto
>         have 6: "\<And> i. i > Max t \<Longrightarrow> v ?! i = v ?! Max t" using assms(2, 4) 4(2) by auto
161,170c161,170
<         have "u ? nth_least_ext s i = u ? Suc (Max s + (i - card s))" using False by simp
<         also have "\<dots> = u ? Max s" using 5 by simp
<         also have "\<dots> = u ? nth_least s (card s - 1)" using nth_least_Max 4(1) 3(1) by force
<         also have "\<dots> = lselect s u ? (card s - 1)" using lselect_lnth 9 by simp
<         also have "\<dots> = lselect s u ? (card t - 1)" using 2 4 by simp
<         also have "\<dots> = lselect t v ? (card t - 1)" unfolding assms(5) by rule
<         also have "\<dots> = v ? nth_least t (card t - 1)" using lselect_lnth 10 by simp
<         also have "\<dots> = v ? Max t" using nth_least_Max 4(2) 3(2) by force
<         also have "\<dots> = v ? Suc (Max t + (i - card t))" using 6 by simp
<         also have "\<dots> = v ? nth_least_ext t i" using 2 False by simp
---
>         have "u ?! nth_least_ext s i = u ?! Suc (Max s + (i - card s))" using False by simp
>         also have "\<dots> = u ?! Max s" using 5 by simp
>         also have "\<dots> = u ?! nth_least s (card s - 1)" using nth_least_Max 4(1) 3(1) by force
>         also have "\<dots> = lselect s u ?! (card s - 1)" using lselect_lnth 9 by simp
>         also have "\<dots> = lselect s u ?! (card t - 1)" using 2 4 by simp
>         also have "\<dots> = lselect t v ?! (card t - 1)" unfolding assms(5) by rule
>         also have "\<dots> = v ?! nth_least t (card t - 1)" using lselect_lnth 10 by simp
>         also have "\<dots> = v ?! Max t" using nth_least_Max 4(2) 3(2) by force
>         also have "\<dots> = v ?! Suc (Max t + (i - card t))" using 6 by simp
>         also have "\<dots> = v ?! nth_least_ext t i" using 2 False by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Partial_Order_Reduction/Extensions/Coinductive_List_Extensions.thy ../../AFPs/afp-2020/thys/Partial_Order_Reduction/Extensions/Coinductive_List_Extensions.thy
44c44
<   notation lnth (infixl "?" 100)
---
>   notation lnth (infixl "?!" 100)
147c147
<     shows "llast (ltake (enat (Suc k)) w) = w ? k"
---
>     shows "llast (ltake (enat (Suc k)) w) = w ?! k"
150c150
<     have "llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ? k"
---
>     have "llast (ltake (enat (Suc k)) w) = ltake (enat (Suc k)) w ?! k"
152c152
<     also have "\<dots> = w ? k" by (rule lnth_ltake, simp)
---
>     also have "\<dots> = w ?! k" by (rule lnth_ltake, simp)
163c163
<     assumes "\<And> i. enat i < llength u \<Longrightarrow> enat i < llength v \<Longrightarrow> u ? i = v ? i"
---
>     assumes "\<And> i. enat i < llength u \<Longrightarrow> enat i < llength v \<Longrightarrow> u ?! i = v ?! i"
169c169
<     have 11: "\<And> i. enat i < llength u \<Longrightarrow>  enat i < llength v \<Longrightarrow> u ? i = v ? i"
---
>     have 11: "\<And> i. enat i < llength u \<Longrightarrow>  enat i < llength v \<Longrightarrow> u ?! i = v ?! i"
187c187
<       have 41: "u ? Suc i = v ? Suc i"
---
>       have 41: "u ?! Suc i = v ?! Suc i"
192c192
<       show "ltl u ? i = ltl v ? i" using lnth_ltl 40(1-2) 41 by metis
---
>       show "ltl u ?! i = ltl v ?! i" using lnth_ltl 40(1-2) 41 by metis
325c325
<       where "liset A w \<equiv> {i. enat i < llength w \<and> w ? i \<in> A}"
---
>       where "liset A w \<equiv> {i. enat i < llength w \<and> w ?! i \<in> A}"
328c328
<       assumes "enat i < llength w" "w ? i \<in> A"
---
>       assumes "enat i < llength w" "w ?! i \<in> A"
333c333
<       shows "enat i < llength w" "w ? i \<in> A"
---
>       shows "enat i < llength w" "w ?! i \<in> A"
349,350c349,350
<       have "liset A (a % w) = {i. enat i < llength (a % w) \<and> (a % w) ? i \<in> A}" by auto
<       also have "\<dots> = Suc ` {i. enat (Suc i) < llength (a % w) \<and> (a % w) ? Suc i \<in> A}"
---
>       have "liset A (a % w) = {i. enat i < llength (a % w) \<and> (a % w) ?! i \<in> A}" by auto
>       also have "\<dots> = Suc ` {i. enat (Suc i) < llength (a % w) \<and> (a % w) ?! Suc i \<in> A}"
352c352
<       also have "\<dots> = Suc ` {i. enat i < llength w \<and> w ? i \<in> A}" using Suc_ile_eq by simp
---
>       also have "\<dots> = Suc ` {i. enat i < llength w \<and> w ?! i \<in> A}" using Suc_ile_eq by simp
360,361c360,361
<       have "liset A (a % w) = {i. enat i < llength (a % w) \<and> (a % w) ? i \<in> A}" by auto
<       also have "\<dots> = {0} \<union> Suc ` {i. enat (Suc i) < llength (a % w) \<and> (a % w) ? Suc i \<in> A}"
---
>       have "liset A (a % w) = {i. enat i < llength (a % w) \<and> (a % w) ?! i \<in> A}" by auto
>       also have "\<dots> = {0} \<union> Suc ` {i. enat (Suc i) < llength (a % w) \<and> (a % w) ?! Suc i \<in> A}"
363c363
<       also have "\<dots> = {0} \<union> Suc ` {i. enat i < llength w \<and> w ? i \<in> A}" using Suc_ile_eq by simp
---
>       also have "\<dots> = {0} \<union> Suc ` {i. enat i < llength w \<and> w ?! i \<in> A}" using Suc_ile_eq by simp
373c373
<       have 1: "v ? i \<in> A" using assms(1) by auto
---
>       have 1: "v ?! i \<in> A" using assms(1) by auto
375c375
<       show "u ? i \<in> A" using lprefix_lnthD assms(2, 3) 1 by force
---
>       show "u ?! i \<in> A" using lprefix_lnthD assms(2, 3) 1 by force
382c382
<       have 1: "enat i < llength u" "u ? i \<in> A" using assms(1) by auto
---
>       have 1: "enat i < llength u" "u ?! i \<in> A" using assms(1) by auto
384c384
<       show "v ? i \<in> A" using lprefix_lnthD assms(2) 1 by force
---
>       show "v ?! i \<in> A" using lprefix_lnthD assms(2) 1 by force
392c392
<       have 3: "ltake (enat k) w ? i = w ? i" using lnth_ltake 2 by this
---
>       have 3: "ltake (enat k) w ?! i = w ?! i" using lnth_ltake 2 by this
398c398
<       have 3: "ltake (enat k) w ? i = w ? i" using lnth_ltake 2 by this
---
>       have 3: "ltake (enat k) w ?! i = w ?! i" using lnth_ltake 2 by this
469c469
<       have 1: "\<And> i. enat i < llength w \<Longrightarrow> (w \<bar>\<bar> iterates Suc 0) ? i = (w ? i, i)"
---
>       have 1: "\<And> i. enat i < llength w \<Longrightarrow> (w \<bar>\<bar> iterates Suc 0) ?! i = (w ?! i, i)"
472c472
<       have 2: "{i. enat i < llength w \<and> (w \<bar>\<bar> iterates Suc 0) ? i \<in> UNIV \<times> s} =
---
>       have 2: "{i. enat i < llength w \<and> (w \<bar>\<bar> iterates Suc 0) ?! i \<in> UNIV \<times> s} =
476c476
<       also have "\<dots> = esize {i. enat i < llength w \<and> (w \<bar>\<bar> iterates Suc 0) ? i \<in> UNIV \<times> s}"
---
>       also have "\<dots> = esize {i. enat i < llength w \<and> (w \<bar>\<bar> iterates Suc 0) ?! i \<in> UNIV \<times> s}"
528c528
<       shows "lselect s w = w ? least s % lselect (s - {least s}) w"
---
>       shows "lselect s w = w ?! least s % lselect (s - {least s}) w"
541c541
<       also have "\<dots> = lselect (s - {least s}) (ltake (enat (least s)) w) $ <w ? least s> $
---
>       also have "\<dots> = lselect (s - {least s}) (ltake (enat (least s)) w) $ <w ?! least s> $
544c544
<       also have "\<dots> = <w ? least s> $
---
>       also have "\<dots> = <w ?! least s> $
547c547
<       also have "\<dots> = w ? (least s) % lselect (s - {least s}) w" unfolding 7 by simp
---
>       also have "\<dots> = w ?! (least s) % lselect (s - {least s}) w" unfolding 7 by simp
553c553
<       shows "lselect s w ? i = w ? nth_least s i"
---
>       shows "lselect s w ?! i = w ?! nth_least s i"
562c562
<       have 2: "lselect s w = w ? least s % lselect (s - {least s}) w" using lselect_least 1 by this
---
>       have 2: "lselect s w = w ?! least s % lselect (s - {least s}) w" using lselect_least 1 by this
565,568c565,568
<       have "lselect s w ? Suc i = (w ? least s % lselect (s - {least s}) w) ? Suc i" using 2 by simp
<       also have "\<dots> = lselect (s - {least s}) w ? i" by simp
<       also have "\<dots> = w ? nth_least (s - {least s}) i" using Suc(1) 4 by simp
<       also have "\<dots> = w ? nth_least s (Suc i)" by simp
---
>       have "lselect s w ?! Suc i = (w ?! least s % lselect (s - {least s}) w) ?! Suc i" using 2 by simp
>       also have "\<dots> = lselect (s - {least s}) w ?! i" by simp
>       also have "\<dots> = w ?! nth_least (s - {least s}) i" using Suc(1) 4 by simp
>       also have "\<dots> = w ?! nth_least s (Suc i)" by simp
573c573
<       shows "lproject A w ? i = w ? nth_least (liset A w) i"
---
>       shows "lproject A w ?! i = w ?! nth_least (liset A w) i"
617,618c617,618
<       have "lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ? i =
<         ltake (enat (Suc (nth_least (liset A w) k'))) w ?
---
>       have "lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =
>         ltake (enat (Suc (nth_least (liset A w) k'))) w ?!
621c621
<       also have "\<dots> = ltake (enat (Suc (nth_least (liset A w) k'))) w ? nth_least (liset A w) i"
---
>       also have "\<dots> = ltake (enat (Suc (nth_least (liset A w) k'))) w ?! nth_least (liset A w) i"
623,627c623,627
<       also have "\<dots> = w ? nth_least (liset A w) i" using 7 by simp
<       also have "\<dots> = lproject A w ? i" using 2 by simp
<       also have "\<dots> = ltake (enat k) (lproject A w) ? i" using 2 by simp
<       finally show "lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ? i =
<         ltake (enat k) (lproject A w) ? i" by this
---
>       also have "\<dots> = w ?! nth_least (liset A w) i" using 7 by simp
>       also have "\<dots> = lproject A w ?! i" using 2 by simp
>       also have "\<dots> = ltake (enat k) (lproject A w) ?! i" using 2 by simp
>       finally show "lproject A (ltake (enat (nth_least (lift (liset A w)) k)) w) ?! i =
>         ltake (enat k) (lproject A w) ?! i" by this
656,660c656,660
<       have "lselect t (lselect s w) ? i = lselect s w ? nth_least t i" using 1 by simp
<       also have "\<dots> = w ? nth_least s (nth_least t i)" using assms(2) 3 by simp
<       also have "\<dots> = w ? nth_least (nth_least s ` t) i" using 3 4 by simp
<       also have "\<dots> = lselect (nth_least s ` t) w ? i" using 2 by simp
<       finally show "lselect t (lselect s w) ? i = lselect (nth_least s ` t) w ? i" by this
---
>       have "lselect t (lselect s w) ?! i = lselect s w ?! nth_least t i" using 1 by simp
>       also have "\<dots> = w ?! nth_least s (nth_least t i)" using assms(2) 3 by simp
>       also have "\<dots> = w ?! nth_least (nth_least s ` t) i" using 3 4 by simp
>       also have "\<dots> = lselect (nth_least s ` t) w ?! i" using 2 by simp
>       finally show "lselect t (lselect s w) ?! i = lselect (nth_least s ` t) w ?! i" by this
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Partial_Order_Reduction/Transition_System_Interpreted_Traces.thy ../../AFPs/afp-2020/thys/Partial_Order_Reduction/Transition_System_Interpreted_Traces.thy
95c95
<       show "llist_of_stream (smap int (p ## trace u p)) ? i = llist_of_stream (smap int (p ## trace u p)) ?
---
>       show "llist_of_stream (smap int (p ## trace u p)) ?! i = llist_of_stream (smap int (p ## trace u p)) ?!
121c121
<       show "llist_of_stream (smap int (p ## trace u p)) ? i = llist_of_stream (smap int (p ## trace u p)) ?
---
>       show "llist_of_stream (smap int (p ## trace u p)) ?! i = llist_of_stream (smap int (p ## trace u p)) ?!
192c192
<           have "lselect (lift (liset visible (llist_of_stream u))) (llist_of_stream (smap int (q ## trace u q))) ? i =
---
>           have "lselect (lift (liset visible (llist_of_stream u))) (llist_of_stream (smap int (q ## trace u q))) ?! i =
220c220
<             (llist_of_stream (smap int (q ## trace v q))) ? i"
---
>             (llist_of_stream (smap int (q ## trace v q))) ?! i"
223,224c223,224
<             (llist_of_stream (smap int (q ## trace u q))) ? i = lselect (lift (liset visible (llist_of_stream v)))
<             (llist_of_stream (smap int (q ## trace v q))) ? i" by this
---
>             (llist_of_stream (smap int (q ## trace u q))) ?! i = lselect (lift (liset visible (llist_of_stream v)))
>             (llist_of_stream (smap int (q ## trace v q))) ?! i" by this
==========
Perron_Frobenius
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Perron_Frobenius/Spectral_Radius_Largest_Jordan_Block.thy ../../AFPs/afp-2020/thys/Perron_Frobenius/Spectral_Radius_Largest_Jordan_Block.thy
12a13
>   "HOL-Real_Asymp.Real_Asymp"
375,400c376,377
<           show "(\<lambda>x. c / real x ^ (m - 1)) \<longlonglongrightarrow> (if m - 1 = 0 then c else 0)" (is "_ \<longlonglongrightarrow> ?f")
<           proof (cases "m - 1", force)
<             case (Suc k)
<             hence f: "?f = 0" by auto
<             have inve:"c / real x ^ Suc k = inverse (inverse c * real x ^ Suc k)"
<               for x using divide_real_def by auto
<             show ?thesis unfolding f unfolding Suc inve
<             proof(rule LIMSEQ_inverse_zero,standard,standard,standard)
<               fix r::real fix x::nat
<               let ?v = "ceiling c * ceiling (abs r)"
<               have inv_pos:"inverse c > 0" using c_gt_0 by simp
<               have c_int':"real_of_int \<lceil>c\<rceil> = c" using Ints_cases[OF c_int] by fastforce
<               assume "nat ?v + 1 \<le> x"
<               hence vr:"?v < real x" and "real x \<ge> 1" by linarith+
<               hence "real x ^ k \<ge> 1" "real x \<ge> 1" using one_le_power by blast+
<               hence x:"inverse c * real x \<le> inverse c * real x * real x ^ k"
<                 using inv_pos by simp
<               have "inverse c * c * \<bar>r\<bar> \<le> inverse c * real_of_int (\<lceil>c\<rceil> * \<lceil>\<bar>r\<bar>\<rceil>)"
<                 using inv_pos c_int'
<                 by (metis c0 le_of_int_ceiling left_inverse mult.assoc mult_cancel_right2 of_int_mult)
<               with mult_strict_left_mono[OF vr inv_pos]
<               have "inverse c * c * (abs r) < inverse c * real x" by argo
<               hence "r < inverse c * real x" using c_gt_0 by simp
<               thus "r < inverse c * real x ^ Suc k" using x by simp
<             qed
<           qed
---
>           show "(\<lambda>x. c / real x ^ (m - 1)) \<longlonglongrightarrow> (if m - 1 = 0 then c else 0)"
>             by (cases "m - 1"; real_asymp)
==========
pGCL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/Algebra.thy ../../AFPs/afp-2020/thys/pGCL/Algebra.thy
361c361,362
<     hence "\<And>s. 0 \<le> ?Pc s" by(auto simp:sign_simps)
---
>     hence "\<And>s. 0 \<le> ?Pc s"
>       by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/Continuity.thy ../../AFPs/afp-2020/thys/pGCL/Continuity.thy
301c301,302
<       from up show "0 \<le> 1 - p s" by(auto simp:sign_simps)
---
>       from up show "0 \<le> 1 - p s"
>         by auto
360c361,362
<     moreover from up have "0 \<le> (1 - p s)" by(auto simp:sign_simps)
---
>     moreover from up have "0 \<le> (1 - p s)"
>       by auto
374c376,377
<       moreover from up have "0 \<le> 1 - p s" by(auto simp:sign_simps)
---
>       moreover from up have "0 \<le> 1 - p s"
>         by auto
440c443,444
<     moreover from up have "0 \<le> p s" "0 \<le> 1 - p s" by(auto simp:sign_simps)
---
>     moreover from up have "0 \<le> p s" "0 \<le> 1 - p s"
>       by auto
451c455,456
<     moreover from up have "\<And>s. 0 \<le> p s" "\<And>s. 0 \<le> 1 - p s" by(auto simp:sign_simps)
---
>     moreover from up have "\<And>s. 0 \<le> p s" "\<And>s. 0 \<le> 1 - p s"
>       by auto
698c703,704
<           from up have "0 \<le> p y" "0 \<le> 1 - p x" by(auto simp:sign_simps)
---
>           from up have "0 \<le> p y" "0 \<le> 1 - p x"
>             by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/Healthiness.thy ../../AFPs/afp-2020/thys/pGCL/Healthiness.thy
114c114,115
<     from uP have "0 \<le> 1 - P s" by(auto simp:sign_simps)
---
>     from uP have "0 \<le> 1 - P s"
>       by auto
127c128,129
<     have "wp g Q s \<le> b" and "0 \<le> 1 - P s" by(auto simp:sign_simps)
---
>     have "wp g Q s \<le> b" and "0 \<le> 1 - P s"
>       by auto
147c149,150
<     moreover from uP have "0 \<le> 1 - P s" by(auto simp:sign_simps)
---
>     moreover from uP have "0 \<le> 1 - P s"
>       by auto
179c182,183
<   from uP have nnP: "0 \<le> P s" "0 \<le> 1 - P s" by(auto simp:sign_simps)
---
>   from uP have nnP: "0 \<le> P s" "0 \<le> 1 - P s"
>     by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/Misc.thy ../../AFPs/afp-2020/thys/pGCL/Misc.thy
12c12
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/Sublinearity.thy ../../AFPs/afp-2020/thys/pGCL/Sublinearity.thy
98c98
<         by(auto simp:sign_simps)
---
>         by auto
117c117
<       by(auto simp:sign_simps)
---
>       by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/pGCL/WellDefined.thy ../../AFPs/afp-2020/thys/pGCL/WellDefined.thy
335c335
<     using uP by(auto simp:sign_simps)
---
>     using uP by auto
==========
Planarity_Certificates
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Planarity_Certificates/Planarity/Digraph_Map_Impl.thy ../../AFPs/afp-2020/thys/Planarity_Certificates/Planarity/Digraph_Map_Impl.thy
371c371
<   unfolding comb_planar_impl_def Let_def genus_impl_def by (cases G) (simp add:  sign_simps)
---
>   unfolding comb_planar_impl_def Let_def genus_impl_def by (cases G) (simp add: algebra_simps)
408c408
<     unfolding comb_planar_impl_def genus_impl_def Let_def by (simp add: \<open>G = (V,A)\<close> sign_simps)
---
>     unfolding comb_planar_impl_def genus_impl_def Let_def by (simp add: \<open>G = (V,A)\<close> algebra_simps)
==========
Poincare_Bendixson
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Affine_Arithmetic_Misc.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Affine_Arithmetic_Misc.thy
5d4
< 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Analysis_Misc.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Analysis_Misc.thy
1,1138c1,1135
< section \<open>Additions to HOL-Analysis\<close>
< theory Analysis_Misc
<   imports 
<     Ordinary_Differential_Equations.ODE_Analysis
< begin
< 
< subsection \<open>Unsorted Lemmas (TODO: sort!)\<close>
< 
< lemma uminus_uminus_image: "uminus ` uminus ` S = S"
<   for S::"'r::ab_group_add set"
<   by (auto simp: image_image)
< 
< lemma in_uminus_image_iff[simp]: "x \<in> uminus ` S \<longleftrightarrow> - x \<in> S"
<   for S::"'r::ab_group_add set"
<   by force
< 
< lemma closed_subsegmentI:
<   "w + t *\<^sub>R (z - w) \<in> {x--y}"
<   if "w \<in> {x -- y}" "z \<in> {x -- y}" and t: "0 \<le> t" "t\<le> 1"
< proof -
<   from that obtain u v where
<     w_def: "w = (1 - u) *\<^sub>R x + u *\<^sub>R y" and u: "0 \<le> u" "u \<le> 1"
<     and z_def: "z = (1 - v) *\<^sub>R x + v *\<^sub>R y" and v: "0 \<le> v" "v \<le> 1"
<     by (auto simp: in_segment)
<   have "w + t *\<^sub>R (z - w) =
<     (1 - (u - t * (u - v))) *\<^sub>R x + (u - t * (u - v)) *\<^sub>R y"
<     by (simp add: algebra_simps w_def z_def)
<   also have "\<dots> \<in> {x -- y}"
<     apply (rule closed_segmentI[OF _ refl])
<     using t u v 
<     apply auto
<      apply (metis (full_types) diff_0_right diff_left_mono linear mult_left_le_one_le mult_nonneg_nonpos order.trans)
<     by (smt mult_left_le_one_le mult_nonneg_nonneg vector_space_over_itself.scale_right_diff_distrib)
<   finally show ?thesis .
< qed
< 
< lemma tendsto_minus_cancel_right: "((\<lambda>x. -g x) \<longlongrightarrow> l) F \<longleftrightarrow> (g \<longlongrightarrow> -l) F"
<   \<comment> \<open>cf @{thm tendsto_minus_cancel_left}\<close>
<   for g::"_ \<Rightarrow> 'b::topological_group_add"
<   by (simp add: tendsto_minus_cancel_left)
< 
< lemma tendsto_nhds_continuousI: "(f \<longlongrightarrow> l) (nhds x)" if "(f \<longlongrightarrow> l) (at x)" "f x = l"
<   \<comment> \<open>TODO: the assumption is continuity of f at x\<close>
< proof (rule topological_tendstoI)
<   fix S::"'b set" assume "open S" "l \<in> S"
<   from topological_tendstoD[OF that(1) this]
<   have "\<forall>\<^sub>F x in at x. f x \<in> S" .
<   then show "\<forall>\<^sub>F x in nhds x. f x \<in> S"
<     unfolding eventually_at_filter
<     by eventually_elim (auto simp: that \<open>l \<in> S\<close>)
< qed
< 
< lemma inj_composeD:
<   assumes "inj (\<lambda>x. g (t x))"
<   shows "inj t"
<   using assms
<   by (auto simp: inj_def)
< 
< lemma compact_sequentialE:
<   fixes S T::"'a::first_countable_topology set"
<   assumes "compact S"
<   assumes "infinite T"
<   assumes "T \<subseteq> S"
<   obtains t::"nat \<Rightarrow> 'a" and l::'a
<   where "\<And>n. t n \<in> T" "\<And>n. t n \<noteq> l" "t \<longlonglongrightarrow> l" "l \<in> S"
< proof -
<   from Heine_Borel_imp_Bolzano_Weierstrass[OF assms]
<   obtain l where "l \<in> S" "l islimpt T" by metis
<   then obtain t where "t n \<in> T" "t n \<noteq> l" "t \<longlonglongrightarrow> l" "l \<in> S" for n unfolding islimpt_sequential
<     by auto
<   then show ?thesis ..
< qed
< 
< lemma infinite_countable_subsetE:
<   fixes S::"'a set"
<   assumes "infinite S"
<   obtains g::"nat\<Rightarrow>'a" where "inj g" "range g \<subseteq> S"
<   using assms
<   by atomize_elim (simp add: infinite_countable_subset)
< 
< lemma real_quad_ge: "2 * (an * bn) \<le> an * an + bn * bn" for an bn::real
<   by (sos "(((A<0 * R<1) + (R<1 * (R<1 * [an + ~1*bn]^2))))")
< 
< lemma inner_quad_ge: "2 * (a \<bullet> b) \<le> a \<bullet> a + b \<bullet> b"
<   for a b::"'a::euclidean_space"\<comment> \<open>generalize?\<close>
< proof -
<   show ?thesis
<     by (subst (1 2 3) euclidean_inner)
<       (auto simp add: sum.distrib[symmetric] sum_distrib_left intro!: sum_mono real_quad_ge)
< qed
< 
< lemma inner_quad_gt: "2 * (a \<bullet> b) < a \<bullet> a + b \<bullet> b"
<   if "a \<noteq> b"
<   for a b::"'a::euclidean_space"\<comment> \<open>generalize?\<close>
< proof -
<   from that obtain i where "i \<in> Basis" "a \<bullet> i \<noteq> b \<bullet> i"
<     by (auto simp: euclidean_eq_iff[where 'a='a])
<   then have "2 * (a \<bullet> i * (b \<bullet> i)) < a \<bullet> i * (a \<bullet> i) + b \<bullet> i * (b \<bullet> i)"
<     using sum_sqs_eq[of "a\<bullet>i" "b\<bullet>i"]
<     by (auto intro!: le_neq_trans real_quad_ge)
<   then show ?thesis
<     by (subst (1 2 3) euclidean_inner)
<       (auto simp add: \<open>i \<in> Basis\<close> sum.distrib[symmetric] sum_distrib_left
<         intro!: sum_strict_mono_ex1 real_quad_ge)
< qed
< 
< lemma closed_segment_line_hyperplanes:
<   "{a -- b} = range (\<lambda>u. a + u *\<^sub>R (b - a)) \<inter> {x. a \<bullet> (b - a) \<le> x \<bullet> (b - a) \<and> x \<bullet> (b - a) \<le> b \<bullet> (b - a)}"
<   if "a \<noteq> b"
<   for a b::"'a::euclidean_space"
< proof safe
<   fix x assume x: "x \<in> {a--b}"
<   then obtain u where u: "0 \<le> u" "u \<le> 1" and x_eq: "x = a + u *\<^sub>R (b - a)"
<     by (auto simp add: in_segment algebra_simps)
<   show "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))" using x_eq by auto
<   have "2 * (a \<bullet> b) \<le> a \<bullet> a + b \<bullet> b"
<     by (rule inner_quad_ge)
<   then have "u * (2 * (a \<bullet> b) - a \<bullet> a - b \<bullet> b) \<le> 0"
<     "0 \<le> (1 - u) * (a \<bullet> a + b \<bullet> b - a \<bullet> b * 2)"
<     by (simp_all add: mult_le_0_iff u)
<   then show " a \<bullet> (b - a) \<le> x \<bullet> (b - a)" "x \<bullet> (b - a) \<le> b \<bullet> (b - a)"
<     by (auto simp: x_eq algebra_simps power2_eq_square inner_commute)
< next
<   fix u assume
<     "a \<bullet> (b - a) \<le> (a + u *\<^sub>R (b - a)) \<bullet> (b - a)"
<     "(a + u *\<^sub>R (b - a)) \<bullet> (b - a) \<le> b \<bullet> (b - a)"
<   then have "0 \<le> u * ((b - a) \<bullet> (b - a))" "0 \<le> (1 - u) * ((b - a) \<bullet> (b - a))"
<     by (auto simp: algebra_simps)
<   then have "0 \<le> u" "u \<le> 1"
<     using inner_ge_zero[of "(b - a)"] that
<     by (auto simp add: zero_le_mult_iff)
<   then show "a + u *\<^sub>R (b - a) \<in> {a--b}"
<     by (auto simp: in_segment algebra_simps)
< qed
< 
< lemma open_segment_line_hyperplanes:
<   "{a <--< b} = range (\<lambda>u. a + u *\<^sub>R (b - a)) \<inter> {x. a \<bullet> (b - a) < x \<bullet> (b - a) \<and> x \<bullet> (b - a) < b \<bullet> (b - a)}"
<   if "a \<noteq> b"
<   for a b::"'a::euclidean_space"
< proof safe
<   fix x assume x: "x \<in> {a<--<b}"
<   then obtain u where u: "0 < u" "u < 1" and x_eq: "x = a + u *\<^sub>R (b - a)"
<     by (auto simp add: in_segment algebra_simps)
<   show "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))" using x_eq by auto
<   have "2 * (a \<bullet> b) < a \<bullet> a + b \<bullet> b" using that
<     by (rule inner_quad_gt)
<   then have "u * (2 * (a \<bullet> b) - a \<bullet> a - b \<bullet> b) < 0"
<     "0 < (1 - u) * (a \<bullet> a + b \<bullet> b - a \<bullet> b * 2)"
<     by (simp_all add: mult_less_0_iff u)
<   then show " a \<bullet> (b - a) < x \<bullet> (b - a)" "x \<bullet> (b - a) < b \<bullet> (b - a)"
<     by (auto simp: x_eq algebra_simps power2_eq_square inner_commute)
< next
<   fix u assume
<     "a \<bullet> (b - a) < (a + u *\<^sub>R (b - a)) \<bullet> (b - a)"
<     "(a + u *\<^sub>R (b - a)) \<bullet> (b - a) < b \<bullet> (b - a)"
<   then have "0 < u * ((b - a) \<bullet> (b - a))" "0 < (1 - u) * ((b - a) \<bullet> (b - a))"
<     by (auto simp: algebra_simps)
<   then have "0 < u" "u < 1"
<     using inner_ge_zero[of "(b - a)"] that
<     by (auto simp add: zero_less_mult_iff)
<   then show "a + u *\<^sub>R (b - a) \<in> {a<--<b}"
<     by (auto simp: in_segment algebra_simps that)
< qed
< 
< lemma at_within_interior: "NO_MATCH UNIV S \<Longrightarrow> x \<in> interior S \<Longrightarrow> at x within S = at x"
<   by (auto intro: at_within_interior)
< 
< lemma tendsto_at_topI:
<   "(f \<longlongrightarrow> l) at_top" if "\<And>e. 0 < e \<Longrightarrow> \<exists>x0. \<forall>x\<ge>x0. dist (f x) l < e"
< for f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   using that
<   apply (intro tendstoI)
<   unfolding eventually_at_top_linorder
<   by auto
< 
< lemma tendsto_at_topE:
<   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   assumes "(f \<longlongrightarrow> l) at_top"
<   assumes "e > 0"
<   obtains x0 where "\<And>x. x \<ge> x0 \<Longrightarrow> dist (f x) l < e"
< proof -
<   from assms(1)[THEN tendstoD, OF assms(2)]
<   have "\<forall>\<^sub>F x in at_top. dist (f x) l < e" .
<   then show ?thesis
<     unfolding eventually_at_top_linorder
<     by (auto intro: that)
< qed
< lemma tendsto_at_top_iff: "(f \<longlongrightarrow> l) at_top \<longleftrightarrow> (\<forall>e>0. \<exists>x0. \<forall>x\<ge>x0. dist (f x) l < e)"
<   for f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   by (auto intro!: tendsto_at_topI elim!: tendsto_at_topE)
< 
< lemma tendsto_at_top_eq_left:
<   fixes f g::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   assumes "(f \<longlongrightarrow> l) at_top"
<   assumes "\<And>x. x \<ge> x0 \<Longrightarrow> f x = g x"
<   shows "(g \<longlongrightarrow> l) at_top"
<   unfolding tendsto_at_top_iff
<   by (metis (no_types, hide_lams) assms(1) assms(2) linear order_trans tendsto_at_topE)
< 
< lemma lim_divide_n: "(\<lambda>x. e / real x) \<longlonglongrightarrow> 0"
< proof -
<   have "(\<lambda>x. e * inverse (real x)) \<longlonglongrightarrow> 0"
<     by (auto intro: tendsto_eq_intros lim_inverse_n)
<   then show ?thesis by (simp add: inverse_eq_divide)
< qed
< 
< definition at_top_within :: "('a::order) set \<Rightarrow> 'a filter"
<   where "at_top_within s = (INF k \<in> s. principal ({k ..} \<inter> s)) "
< 
< lemma at_top_within_at_top[simp]:
<   shows "at_top_within UNIV = at_top"
<   unfolding at_top_within_def at_top_def
<   by (auto)
< 
< lemma at_top_within_empty[simp]:
<   shows "at_top_within {} = top"
<   unfolding at_top_within_def
<   by (auto)
< 
< definition "nhds_set X = (INF S\<in>{S. open S \<and> X \<subseteq> S}. principal S)"
< 
< lemma eventually_nhds_set:
<   "(\<forall>\<^sub>F x in nhds_set X. P x) \<longleftrightarrow> (\<exists>S. open S \<and> X \<subseteq> S \<and> (\<forall>x\<in>S. P x))"
<   unfolding nhds_set_def by (subst eventually_INF_base) (auto simp: eventually_principal)
< 
< term "filterlim f (nhds_set (frontier X)) F" \<comment> \<open>f tends to the boundary of X?\<close>
< 
< 
< text \<open>somewhat inspired by @{thm islimpt_range_imp_convergent_subsequence} and its dependencies.
< The class constraints seem somewhat arbitrary, perhaps this can be generalized in some way.
< \<close>
< lemma limpt_closed_imp_exploding_subsequence:\<comment>\<open>TODO: improve name?!\<close>
<   fixes f::"'a::{heine_borel,real_normed_vector} \<Rightarrow> 'b::{first_countable_topology, t2_space}"
<   assumes cont[THEN continuous_on_compose2, continuous_intros]: "continuous_on T f"
<   assumes closed: "closed T"
<   assumes bound: "\<And>t. t \<in> T \<Longrightarrow> f t \<noteq> l"
<   assumes limpt: "l islimpt (f ` T)"
<   obtains s where
<     "(f \<circ> s) \<longlonglongrightarrow> l"
<     "\<And>i. s i \<in> T"
<     "\<And>C. compact C \<Longrightarrow> C \<subseteq> T \<Longrightarrow> \<forall>\<^sub>F i in sequentially. s i \<notin> C"
< proof -
<   from countable_basis_at_decseq[of l]
<   obtain A where A: "\<And>i. open (A i)" "\<And>i. l \<in> A i"
<     and evA: "\<And>S. open S \<Longrightarrow> l \<in> S \<Longrightarrow> eventually (\<lambda>i. A i \<subseteq> S) sequentially"
<     by blast
< 
<   from closed_Union_compact_subsets[OF closed]
<   obtain C
<     where C: "(\<And>n. compact (C n))" "(\<And>n. C n \<subseteq> T)" "(\<And>n. C n \<subseteq> C (Suc n))" "\<Union> (range C) = T"
<       and evC: "(\<And>K. compact K \<Longrightarrow> K \<subseteq> T \<Longrightarrow> \<forall>\<^sub>F i in sequentially. K \<subseteq> C i)"
<     by (metis eventually_sequentially)
< 
<   have AC: "l \<in> A i - f ` C i" "open (A i - f ` C i)" for i
<     using C bound
<     by (fastforce intro!: open_Diff A compact_imp_closed compact_continuous_image continuous_intros)+
< 
<   from islimptE[OF limpt AC] have "\<exists>t\<in>T. f t \<in> A i - f ` C i \<and> f t \<noteq> l" for i by blast  
<   then obtain t where t: "\<And>i. t i \<in> T" "\<And>i. f (t i) \<in> A i - f ` C i" "\<And>i. f (t i) \<noteq> l"
<     by metis
< 
<   have "(f o t) \<longlonglongrightarrow> l"
<     using t
<     by (auto intro!: topological_tendstoI dest!: evA elim!: eventually_mono)
<   moreover
<   have "\<And>i. t i \<in> T" by fact
<   moreover
<   have "\<forall>\<^sub>F i in sequentially. t i \<notin> K" if "compact K" "K \<subseteq> T" for K
<     using evC[OF that]
<     by eventually_elim (use t in auto)
<   ultimately show ?thesis ..
< qed  
< 
< lemma Inf_islimpt: "bdd_below S \<Longrightarrow> Inf S \<notin> S \<Longrightarrow> S \<noteq> {} \<Longrightarrow> Inf S islimpt S" for S::"real set"
<   by (auto simp: islimpt_in_closure intro!: closure_contains_Inf)
< 
< context linorder
< begin
< 
< text \<open>HOL-analysis doesn't seem to have these, maybe they were never needed.
<   Some variants are around @{thm Int_atLeastAtMost}, but with old-style naming conventions.
<   Change to the "modern" I.. convention there?\<close>
< 
< lemma Int_Ico[simp]:
<   shows "{a..} \<inter> {b..} = {max a b ..}"
<   by (auto)
< 
< lemma Int_Ici_Ico[simp]:
<   shows "{a..} \<inter> {b..<c} = {max a b ..<c}"
<   by auto
< 
< lemma Int_Ico_Ici[simp]:
<   shows "{a..<c} \<inter> {b..} = {max a b ..<c}"
<   by auto
< 
< lemma subset_Ico_iff[simp]:
<   "{a..<b} \<subseteq> {c..<b} \<longleftrightarrow> b \<le> a \<or> c \<le> a"
<   unfolding atLeastLessThan_def
<   by auto
< 
< lemma Ico_subset_Ioo_iff[simp]:
<   "{a..<b} \<subseteq> {c<..<b} \<longleftrightarrow> b \<le> a \<or> c < a"
<   unfolding greaterThanLessThan_def atLeastLessThan_def
<   by auto
< 
< lemma Icc_Un_Ici[simp]:
<   shows "{a..b} \<union> {b..} = {min a b..}"
<   unfolding atLeastAtMost_def atLeast_def atMost_def min_def
<   by auto
< 
< end
< 
< lemma at_top_within_at_top_unbounded_right:
<   fixes a::"'a::linorder"
<   shows "at_top_within {a..} = at_top"
<   unfolding at_top_within_def at_top_def
<   apply (auto intro!: INF_eq)
<   by (metis linorder_class.linear linorder_class.max.cobounded1 linorder_class.max.idem ord_class.atLeast_iff)
< 
< lemma at_top_within_at_top_unbounded_rightI:
<   fixes a::"'a::linorder"
<   assumes "{a..} \<subseteq> s"
<   shows "at_top_within s = at_top"
<   unfolding at_top_within_def at_top_def
<   apply (auto intro!: INF_eq)
<    apply (meson Ici_subset_Ioi_iff Ioi_le_Ico assms dual_order.refl dual_order.trans leI)
<   by (metis assms atLeast_iff atLeast_subset_iff inf.cobounded1 linear subsetD)
< 
< lemma at_top_within_at_top_bounded_right:
<   fixes a b::"'a::{dense_order,linorder_topology}"
<   assumes "a < b"
<   shows "at_top_within {a..<b} = at_left b"
<   unfolding at_top_within_def at_left_eq[OF assms(1)]
<   apply (auto intro!: INF_eq)
<    apply (smt atLeastLessThan_iff greaterThanLessThan_iff le_less lessThan_iff max.absorb1 subset_eq)
<   by (metis assms atLeastLessThan_iff dense linear max.absorb1 not_less order_trans)
< 
< lemma at_top_within_at_top_bounded_right':
<   fixes a b::"'a::{dense_order,linorder_topology}"
<   assumes "a < b"
<   shows "at_top_within {..<b} = at_left b"
<   unfolding at_top_within_def at_left_eq[OF assms(1)]
<   apply (auto intro!: INF_eq)
<    apply (meson atLeast_iff greaterThanLessThan_iff le_less lessThan_iff subset_eq)
<   by (metis Ico_subset_Ioo_iff atLeastLessThan_def dense lessThan_iff)
< 
< lemma eventually_at_top_within_linorder:
<   assumes sn:"s \<noteq> {}"
<   shows "eventually P (at_top_within s) \<longleftrightarrow> (\<exists>x0::'a::{linorder_topology} \<in> s. \<forall>x \<ge> x0. x\<in> s \<longrightarrow> P x)"
<   unfolding at_top_within_def
<   apply (subst eventually_INF_base)
<     apply (auto simp:eventually_principal sn)
<   by (metis atLeast_subset_iff inf.coboundedI2 inf_commute linear)
< 
< lemma tendsto_at_top_withinI:
<   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   assumes "s \<noteq> {}"
<   assumes "\<And>e. 0 < e \<Longrightarrow> \<exists>x0 \<in> s. \<forall>x \<in> {x0..} \<inter> s. dist (f x) l < e"
<   shows  "(f \<longlongrightarrow> l) (at_top_within s)"
<   apply(intro tendstoI)
<   unfolding at_top_within_def apply (subst eventually_INF_base)
<     apply (auto simp:eventually_principal assms)
<   by (metis atLeast_subset_iff inf.coboundedI2 inf_commute linear)
< 
< lemma tendsto_at_top_withinE:
<   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   assumes "s \<noteq> {}"
<   assumes "(f \<longlongrightarrow> l) (at_top_within s)"
<   assumes "e > 0"
<   obtains x0 where "x0 \<in> s" "\<And>x. x \<in> {x0..} \<inter> s \<Longrightarrow> dist (f x) l < e"
< proof -
<   from assms(2)[THEN tendstoD, OF assms(3)]
<   have "\<forall>\<^sub>F x in at_top_within s. dist (f x) l < e" .
<   then show ?thesis unfolding eventually_at_top_within_linorder[OF \<open>s \<noteq> {}\<close>] 
<     by (auto intro: that)
< qed
< 
< lemma tendsto_at_top_within_iff:
<   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
<   assumes "s \<noteq> {}"
<   shows "(f \<longlongrightarrow> l) (at_top_within s) \<longleftrightarrow> (\<forall>e>0. \<exists>x0 \<in> s. \<forall>x \<in> {x0..} \<inter> s. dist (f x) l < e)"
<   by (auto intro!: tendsto_at_top_withinI[OF \<open>s \<noteq> {}\<close>] elim!: tendsto_at_top_withinE[OF \<open>s \<noteq> {}\<close>])
< 
< lemma filterlim_at_top_at_top_within_bounded_right:
<   fixes a b::"'a::{dense_order,linorder_topology}"
<   fixes f::"'a \<Rightarrow> real"
<   assumes "a < b"
<   shows "filterlim f at_top (at_top_within {..<b}) = (f \<longlongrightarrow> \<infinity>) (at_left b)"
<   unfolding filterlim_at_top_dense
<     at_top_within_at_top_bounded_right'[OF assms(1)]
<     eventually_at_left[OF assms(1)]
<     tendsto_PInfty
<   by auto
< 
< text \<open>Extract a sequence (going to infinity) bounded away from l\<close>
< 
< lemma not_tendsto_frequentlyE:
<   assumes "\<not>((f \<longlongrightarrow> l) F)"
<   obtains S where "open S" "l \<in> S" "\<exists>\<^sub>F x in F. f x \<notin> S"
<   using assms
<   by (auto simp: tendsto_def not_eventually)
< 
< lemma not_tendsto_frequently_metricE:
<   assumes "\<not>((f \<longlongrightarrow> l) F)"
<   obtains e where "e > 0" "\<exists>\<^sub>F x in F. e \<le> dist (f x) l"
<   using assms
<   by (auto simp: tendsto_iff not_eventually not_less)
< 
< lemma eventually_frequently_conj: "frequently P F \<Longrightarrow> eventually Q F \<Longrightarrow> frequently (\<lambda>x. P x \<and> Q x) F"
<   unfolding frequently_def
<   apply (erule contrapos_nn)
<   subgoal premises prems
<     using prems by eventually_elim auto
<   done
< 
< lemma frequently_at_top:
<   "(\<exists>\<^sub>F t in at_top. P t) \<longleftrightarrow> (\<forall>t0. \<exists>t>t0. P t)"
<   for P::"'a::{linorder,no_top}\<Rightarrow>bool" 
<   by (auto simp: frequently_def eventually_at_top_dense)
< 
< lemma frequently_at_topE:
<   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_"
<   assumes freq[rule_format]: "\<forall>n. \<exists>\<^sub>F a in at_top. P n a"
<   obtains s::"nat\<Rightarrow>'a"
<   where "\<And>i. P i (s i)" "strict_mono s"
< proof -
<   have "\<exists>f. \<forall>n. P n (f n) \<and> f n < f (Suc n)"
<   proof (rule dependent_nat_choice)
<     from frequently_ex[OF freq[of 0]] show "\<exists>x. P 0 x" .
<     fix x n assume "P n x"
<     from freq[unfolded frequently_at_top, rule_format, of x "Suc n"]
<     obtain y where "P (Suc n) y" "y > x" by auto
<     then show "\<exists>y. P (Suc n) y \<and> x < y"
<       by auto
<   qed
<   then obtain s where "\<And>i. P i (s i)" "strict_mono s"
<     unfolding strict_mono_Suc_iff by auto
<   then show ?thesis ..
< qed
< 
< lemma frequently_at_topE':
<   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_"
<   assumes freq[rule_format]: "\<forall>n. \<exists>\<^sub>F a in at_top. P n a"
<     and g: "filterlim g at_top sequentially"
<   obtains s::"nat\<Rightarrow>'a"
<   where "\<And>i. P i (s i)" "strict_mono s" "\<And>n. g n \<le> s n"
< proof -
<   have "\<forall>n. \<exists>\<^sub>F a in at_top. P n a \<and> g n \<le> a"
<     using freq
<     by (auto intro!: eventually_frequently_conj)
<   from frequently_at_topE[OF this] obtain s where "\<And>i. P i (s i)" "strict_mono s" "\<And>n. g n \<le> s n"
<     by metis
<   then show ?thesis ..
< qed
< 
< lemma frequently_at_top_at_topE:
<   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_" and g::"nat\<Rightarrow>'a"
<   assumes "\<forall>n. \<exists>\<^sub>F a in at_top. P n a" "filterlim g at_top sequentially"
<   obtains s::"nat\<Rightarrow>'a"
<   where "\<And>i. P i (s i)" "filterlim s at_top sequentially"
< proof -
<   from frequently_at_topE'[OF assms]
<   obtain s where s: "(\<And>i. P i (s i))" "strict_mono s" "(\<And>n. g n \<le> s n)" by blast
<   have s_at_top: "filterlim s at_top sequentially"
<     by (rule filterlim_at_top_mono) (use assms s in auto)
<   with s(1) show ?thesis ..
< qed
< 
< (* Extract a strict monotone and sequence converging to something other than l *)
< lemma not_tendsto_convergent_seq:
<   fixes f::"real \<Rightarrow> 'a::metric_space"
<   assumes X: "compact (X::'a set)"
<   assumes im: "\<And>x. x \<ge> 0 \<Longrightarrow> f x \<in> X"
<   assumes nl: "\<not> ((f \<longlongrightarrow> (l::'a)) at_top)"
<   obtains s k where
<     "k \<in> X" "k \<noteq> l" "(f \<circ> s) \<longlonglongrightarrow> k" "strict_mono s" "\<forall>n. s n \<ge> n"
< proof -
<   from not_tendsto_frequentlyE[OF nl]
<   obtain S where "open S" "l \<in> S" "\<exists>\<^sub>F x in at_top. f x \<notin> S" .
<   have "\<forall>n. \<exists>\<^sub>F x in at_top. f x \<notin> S \<and> real n \<le> x"
<     apply (rule allI)
<     apply (rule eventually_frequently_conj)
<      apply fact
<     by (rule eventually_ge_at_top)
<   from frequently_at_topE[OF this]
<   obtain s where "\<And>i. f (s i) \<notin> S" and s: "strict_mono s" and s_ge: "(\<And>i. real i \<le> s i)" by metis
<   then have "0 \<le> s i" for i using dual_order.trans of_nat_0_le_iff by blast
<   then have "\<forall>n. (f \<circ> s) n \<in> X" using im by auto
<   from X[unfolded compact_def, THEN spec, THEN mp, OF this]
<   obtain k r where k: "k \<in> X" and r: "strict_mono r" and kLim: "(f \<circ> s \<circ> r) \<longlonglongrightarrow> k" by metis
<   have "k \<in> X - S"
<     by (rule Lim_in_closed_set[of "X - S", OF _ _ _ kLim])
<       (auto simp: im \<open>0 \<le> s _\<close>  \<open>\<And>i. f (s i) \<notin> S\<close> intro!: \<open>open S\<close> X intro: compact_imp_closed)
< 
<   note k
<   moreover have "k \<noteq> l" using \<open>k \<in> X - S\<close> \<open>l \<in> S\<close> by auto
<   moreover have "(f \<circ> (s \<circ> r)) \<longlonglongrightarrow> k" using kLim by (simp add: o_assoc)
<   moreover have "strict_mono (s \<circ> r)" using s r by (rule strict_mono_o)
<   moreover have "\<forall>n. (s \<circ> r) n \<ge> n" using s_ge r
<     by (metis comp_apply dual_order.trans of_nat_le_iff seq_suble)
<   ultimately show ?thesis ..
< qed
< 
< lemma harmonic_bound:
<   shows "1 / 2 ^(Suc n) < 1 / real (Suc n)"
< proof (induction n)
<   case 0
<   then show ?case by auto
< next
<   case (Suc n)
<   then show ?case
<     by (smt frac_less2 of_nat_0_less_iff of_nat_less_two_power zero_less_Suc)
< qed
< 
< lemma INF_bounded_imp_convergent_seq:
<   fixes f::"real \<Rightarrow> real"
<   assumes cont: "continuous_on {a..} f"
<   assumes bound: "\<And>t. t \<ge> a \<Longrightarrow> f t > l"
<   assumes inf: "(INF t\<in>{a..}. f t) = l"
<   obtains s where
<     "(f \<circ> s) \<longlonglongrightarrow> l"
<     "\<And>i. s i \<in> {a..}"
<     "filterlim s at_top sequentially"
< proof -
<   have bound': "t \<in> {a..} \<Longrightarrow> f t \<noteq> l" for t using bound[of t] by auto
<   have limpt: "l islimpt f ` {a..}"
<   proof -
<     have "Inf (f ` {a..}) islimpt f ` {a..}"
<       by (rule Inf_islimpt) (auto simp: inf intro!: bdd_belowI2[where m=l] dest: bound)
<     then show ?thesis by (simp add: inf)
<   qed
<   from limpt_closed_imp_exploding_subsequence[OF cont closed_atLeast bound' limpt]
<   obtain s where s: "(f \<circ> s) \<longlonglongrightarrow> l"
<     "\<And>i. s i \<in> {a..}"
<     "compact C \<Longrightarrow> C \<subseteq> {a..} \<Longrightarrow> \<forall>\<^sub>F i in sequentially. s i \<notin> C" for C
<     by metis
<   have "\<forall>\<^sub>F i in sequentially. s i \<ge> n" for n
<     using s(3)[of "{a..n}"] s(2)
<     by (auto elim!: eventually_mono)
<   then have "filterlim s at_top sequentially"
<     unfolding filterlim_at_top
<     by auto
<   from s(1) s(2) this
<   show ?thesis ..
< qed
< 
< (* Generalizes to other combinations of strict_mono and filterlim *)
< lemma filterlim_at_top_strict_mono:
<   fixes s :: "_ \<Rightarrow> 'a::linorder"
<   fixes r :: "nat \<Rightarrow> _"
<   assumes "strict_mono s"
<   assumes "strict_mono r"
<   assumes "filterlim s at_top F"
<   shows "filterlim (s \<circ> r) at_top F"
<   apply (rule filterlim_at_top_mono[OF assms(3)])
<   by (simp add: assms(1) assms(2) seq_suble strict_mono_leD)
< 
< lemma LIMSEQ_lb:
<   assumes fl: "s \<longlonglongrightarrow> (l::real)"
<   assumes u: "l < u"
<   shows "\<exists>n0. \<forall>n\<ge>n0. s n < u"
< proof -
<   from fl have "\<exists>no>0. \<forall>n\<ge>no. dist (s n) l < u-l" unfolding LIMSEQ_iff_nz using u
<     by simp
<   thus ?thesis using dist_real_def by fastforce
< qed
< 
< (* Used to sharpen a tendsto with additional information*)
< lemma filterlim_at_top_choose_lower:
<   assumes "filterlim s at_top sequentially"
<   assumes "(f \<circ> s) \<longlonglongrightarrow> l"
<   obtains t where
<     "filterlim t at_top sequentially"
<     "(f \<circ> t) \<longlonglongrightarrow> l"
<     "\<forall>n. t n \<ge> (b::real)"
< proof -
<   obtain k where k: "\<forall>n \<ge> k. s n \<ge> b" using assms(1)
<     unfolding filterlim_at_top eventually_sequentially by blast
<   define t where "t = (\<lambda>n. s (n+k))"
<   then have "\<forall>n. t n \<ge> b" using k by simp
<   have "filterlim t at_top sequentially" using assms(1)
<     unfolding filterlim_at_top eventually_sequentially t_def
<     by (metis (full_types) add.commute trans_le_add2)
<   from LIMSEQ_ignore_initial_segment[OF assms(2), of "k"]
<   have "(\<lambda>n. (f \<circ> s) (n + k)) \<longlonglongrightarrow> l" .
<   then have "(f \<circ> t) \<longlonglongrightarrow> l" unfolding t_def o_def by simp
<   show ?thesis
<     using \<open>(f \<circ> t) \<longlonglongrightarrow> l\<close> \<open>\<forall>n. b \<le> t n\<close> \<open>filterlim t at_top sequentially\<close> that by blast
< qed
< 
< lemma frequently_at_top_realE:
<   fixes P::"nat \<Rightarrow> real \<Rightarrow> bool"
<   assumes "\<forall>n. \<exists>\<^sub>F t in at_top. P n t"
<   obtains s::"nat\<Rightarrow>real"
<   where "\<And>i. P i (s i)" "filterlim s at_top at_top"
<   by (metis assms frequently_at_top_at_topE[OF _ filterlim_real_sequentially])
< 
< lemma approachable_sequenceE:
<   fixes f::"real \<Rightarrow> 'a::metric_space"
<   assumes "\<And>t e. 0 \<le> t \<Longrightarrow> 0 < e \<Longrightarrow> \<exists>tt\<ge>t. dist (f tt) p < e"
<   obtains s where "filterlim s at_top sequentially" "(f \<circ> s) \<longlonglongrightarrow> p"
< proof -
<   have "\<forall>n. \<exists>\<^sub>F i in at_top. dist (f i) p < 1/real (Suc n)"
<     unfolding frequently_at_top
<     apply (auto )
<     subgoal for n m
<       using assms[of "max 0 (m+1)" "1/(Suc n)"]
<       by force
<     done
<   from frequently_at_top_realE[OF this]
<   obtain s where s: "\<And>i. dist (f (s i)) p < 1 / real (Suc i)" "filterlim s at_top sequentially"
<     by metis
<   note this(2)
<   moreover
<   have "(f o s) \<longlonglongrightarrow> p"
<   proof (rule tendstoI)
<     fix e::real assume "e > 0"
<     have "\<forall>\<^sub>F i in sequentially. 1 / real (Suc i) < e"
<       apply (rule order_tendstoD[OF _ \<open>0 < e\<close>])
<       apply (rule real_tendsto_divide_at_top)
<        apply (rule tendsto_intros)
<       by (rule filterlim_compose[OF filterlim_real_sequentially filterlim_Suc])
<     then show "\<forall>\<^sub>F x in sequentially. dist ((f \<circ> s) x) p < e"
<       by eventually_elim (use dual_order.strict_trans s \<open>e > 0\<close> in auto)
<   qed
<   ultimately show ?thesis ..
< qed
< 
< lemma mono_inc_bdd_above_has_limit_at_topI:
<   fixes f::"real \<Rightarrow> real"
<   assumes "mono f"
<   assumes "\<And>x. f x \<le> u"
<   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
< proof -
<   define l where "l = Sup (range (\<lambda>n. f (real n)))"
<   have t:"(\<lambda>n. f (real n)) \<longlonglongrightarrow> l" unfolding l_def
<     apply (rule LIMSEQ_incseq_SUP)
<      apply (meson assms(2) bdd_aboveI2)
<     by (meson assms(1) mono_def of_nat_mono)
<   from tendsto_at_topI_sequentially_real[OF assms(1) t]
<   have "(f \<longlongrightarrow> l) at_top" .
<   thus ?thesis by blast  
< qed
< 
< lemma gen_mono_inc_bdd_above_has_limit_at_topI:
<   fixes f::"real \<Rightarrow> real"
<   assumes "\<And>x y. x \<ge> b \<Longrightarrow> x \<le> y \<Longrightarrow> f x \<le> f y"
<   assumes "\<And>x. x \<ge> b \<Longrightarrow> f x \<le> u"
<   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
< proof -
<   define ff where "ff = (\<lambda>x. if x \<ge> b then f x else f b)"
<   have m1:"mono ff" unfolding ff_def mono_def using assms(1) by simp
<   have m2:"\<And>x. ff x \<le> u" unfolding ff_def using assms(2) by simp
<   from mono_inc_bdd_above_has_limit_at_topI[OF m1 m2]
<   obtain l where "(ff \<longlongrightarrow> l) at_top" by blast
<   thus ?thesis
<     by (meson \<open>(ff \<longlongrightarrow> l) at_top\<close> ff_def tendsto_at_top_eq_left)
< qed
< 
< lemma gen_mono_dec_bdd_below_has_limit_at_topI:
<   fixes f::"real \<Rightarrow> real"
<   assumes "\<And>x y. x \<ge> b \<Longrightarrow> x \<le> y \<Longrightarrow> f x \<ge> f y"
<   assumes "\<And>x. x \<ge> b \<Longrightarrow> f x \<ge> u"
<   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
< proof -
<   define ff where "ff = (\<lambda>x. if x \<ge> b then f x else f b)"
<   have m1:"mono (-ff)" unfolding ff_def mono_def using assms(1) by simp
<   have m2:"\<And>x. (-ff) x \<le> -u" unfolding ff_def using assms(2) by simp
<   from mono_inc_bdd_above_has_limit_at_topI[OF m1 m2]
<   obtain l where "(-ff \<longlongrightarrow> l) at_top" by blast
<   then have "(ff \<longlongrightarrow> -l) at_top"
<     using tendsto_at_top_eq_left tendsto_minus_cancel_left by fastforce  
<   thus ?thesis
<     by (meson \<open>(ff \<longlongrightarrow> -l) at_top\<close> ff_def tendsto_at_top_eq_left)
< qed
< 
< lemma infdist_closed:
<   shows "closed ({z. infdist z S \<ge> e})"
<   by (auto intro!:closed_Collect_le simp add:continuous_on_infdist)
< 
< (* TODO: this is a copy of LIMSEQ_norm_0 where the sequence
<   is bounded above in norm by a geometric series *)
< lemma LIMSEQ_norm_0_pow:
<   assumes "k > 0" "b > 1"
<   assumes  "\<And>n::nat. norm (s n) \<le> k / b^n"
<   shows "s \<longlonglongrightarrow> 0"
< proof (rule metric_LIMSEQ_I)
<   fix e
<   assume "e > (0::real)"
<   then have "k / e > 0" using assms(1) by auto
<   obtain N where N: "b^(N::nat) > k / e" using assms(2)
<     using Elementary_Topology.real_arch_pow by blast
<   then have "norm (s n) < e" if "n \<ge> N" for n
<   proof -
<     have "k / b^n \<le> k / b^N"
<       by (smt assms(1) assms(2) frac_le leD power_less_imp_less_exp that zero_less_power)
<     also have " ... < e" using N
<       by (metis \<open>0 < e\<close> assms(2) less_trans mult.commute pos_divide_less_eq zero_less_one zero_less_power)
<     finally show ?thesis
<       by (meson assms less_eq_real_def not_le order_trans)
<   qed
<   then show "\<exists>no. \<forall>n\<ge>no. dist (s n) 0 < e"
<     by auto
< qed
< 
< lemma filterlim_apply_filtermap:
<   assumes g: "filterlim g G F"
<   shows "filterlim (\<lambda>x. m (g x)) (filtermap m G) F"
<   by (metis filterlim_def filterlim_filtermap filtermap_mono g)
< 
< lemma eventually_at_right_field_le:
<   "eventually P (at_right x) \<longleftrightarrow> (\<exists>b>x. \<forall>y>x. y \<le> b \<longrightarrow> P y)"
<   for x :: "'a::{linordered_field, linorder_topology}"
<   by (smt dense eventually_at_right_field le_less_trans less_le_not_le order.strict_trans1)
< 
< subsection \<open>indexing euclidean space with natural numbers\<close>
< 
< definition  nth_eucl :: "'a::executable_euclidean_space \<Rightarrow> nat \<Rightarrow> real" where
<   "nth_eucl x i = x \<bullet> (Basis_list ! i)"
<   \<comment> \<open>TODO: why is that and some sort of \<open>lambda_eucl\<close> nowhere available?\<close>
< definition lambda_eucl :: "(nat \<Rightarrow> real) \<Rightarrow> 'a::executable_euclidean_space" where
<   "lambda_eucl (f::nat\<Rightarrow>real) = (\<Sum>i<DIM('a). f i *\<^sub>R Basis_list ! i)"
< 
< lemma eucl_eq_iff: "x = y \<longleftrightarrow> (\<forall>i<DIM('a). nth_eucl x i = nth_eucl y i)"
<   for x y::"'a::executable_euclidean_space"
<   apply (auto simp: nth_eucl_def euclidean_eq_iff[where 'a='a])
<   by (metis eucl_of_list_list_of_eucl list_of_eucl_eq_iff)
< 
< bundle eucl_notation begin
< notation nth_eucl (infixl "$\<^sub>e" 90)
< end
< bundle no_eucl_notation begin
< no_notation nth_eucl (infixl "$\<^sub>e" 90)
< end
< 
< unbundle eucl_notation
< 
< lemma eucl_of_list_eucl_nth:
<   "(eucl_of_list xs::'a) $\<^sub>e i = xs ! i"
<   if "length xs = DIM('a::executable_euclidean_space)"
<     "i < DIM('a)"
<   using that
<   apply (auto simp: nth_eucl_def)
<   by (metis list_of_eucl_eucl_of_list list_of_eucl_nth)
< 
< lemma eucl_of_list_inner:
<   "(eucl_of_list xs::'a) \<bullet> eucl_of_list ys = (\<Sum>(x,y)\<leftarrow>zip xs ys. x * y)"
<   if "length xs = DIM('a::executable_euclidean_space)"
<     "length ys = DIM('a::executable_euclidean_space)"
<   using that
<   by (auto simp: nth_eucl_def eucl_of_list_inner_eq inner_lv_rel_def)
< 
< lemma self_eq_eucl_of_list: "x = eucl_of_list (map (\<lambda>i. x $\<^sub>e i) [0..<DIM('a)])"
<   for x::"'a::executable_euclidean_space"
<   by (auto simp: eucl_eq_iff[where 'a='a] eucl_of_list_eucl_nth)
< 
< lemma inner_nth_eucl: "x \<bullet> y = (\<Sum>i<DIM('a). x $\<^sub>e i * y $\<^sub>e i)"
<   for x y::"'a::executable_euclidean_space"
<   apply (subst self_eq_eucl_of_list[where x=x])
<   apply (subst self_eq_eucl_of_list[where x=y])
<   apply (subst eucl_of_list_inner)
<   by (auto simp: map2_map_map atLeast_upt interv_sum_list_conv_sum_set_nat)
< 
< lemma norm_nth_eucl: "norm x = L2_set (\<lambda>i. x $\<^sub>e i) {..<DIM('a)}"
<   for x::"'a::executable_euclidean_space"
<   unfolding norm_eq_sqrt_inner inner_nth_eucl L2_set_def
<   by (auto simp: power2_eq_square)
< 
< 
< lemma plus_nth_eucl: "(x + y) $\<^sub>e i = x $\<^sub>e i + y $\<^sub>e i"
<   and minus_nth_eucl: "(x - y) $\<^sub>e i = x $\<^sub>e i - y $\<^sub>e i"
<   and uminus_nth_eucl: "(-x) $\<^sub>e i = - x $\<^sub>e i"
<   and scaleR_nth_eucl: "(c *\<^sub>R x) $\<^sub>e i = c *\<^sub>R (x $\<^sub>e i)"
<   by (auto simp: nth_eucl_def algebra_simps)
< 
< lemma inf_nth_eucl: "inf x y $\<^sub>e i = min (x $\<^sub>e i) (y $\<^sub>e i)"
<   if "i < DIM('a)"
<   for x::"'a::executable_euclidean_space"
<   by (auto simp: nth_eucl_def algebra_simps inner_Basis_inf_left that inf_min)
< lemma sup_nth_eucl: "sup x y $\<^sub>e i = max (x $\<^sub>e i) (y $\<^sub>e i)"
<   if "i < DIM('a)"
<   for x::"'a::executable_euclidean_space"
<   by (auto simp: nth_eucl_def algebra_simps inner_Basis_sup_left that sup_max)
< 
< lemma le_iff_le_nth_eucl: "x \<le> y \<longleftrightarrow> (\<forall>i<DIM('a). (x $\<^sub>e i) \<le> (y $\<^sub>e i))"
<   for x::"'a::executable_euclidean_space"
<   apply (auto simp: nth_eucl_def algebra_simps eucl_le[where 'a='a])
<   by (meson eucl_le eucl_le_Basis_list_iff)
< 
< lemma eucl_less_iff_less_nth_eucl: "eucl_less x y \<longleftrightarrow> (\<forall>i<DIM('a). (x $\<^sub>e i) < (y $\<^sub>e i))"
<   for x::"'a::executable_euclidean_space"
<   apply (auto simp: nth_eucl_def algebra_simps eucl_less_def[where 'a='a])
<   by (metis Basis_zero eucl_eq_iff inner_not_same_Basis inner_zero_left length_Basis_list
<       nth_Basis_list_in_Basis nth_eucl_def)
< 
< lemma continuous_on_nth_eucl[continuous_intros]:
<   "continuous_on X (\<lambda>x. f x $\<^sub>e i)"
<   if "continuous_on X f"
<   by (auto simp: nth_eucl_def intro!: continuous_intros that)
< 
< 
< subsection \<open>derivatives\<close>
< 
< lemma eventually_at_ne[intro, simp]: "\<forall>\<^sub>F x in at x0. x \<noteq> x0"
<   by (auto simp: eventually_at_filter)
< 
< lemma has_vector_derivative_withinD:
<   fixes f::"real \<Rightarrow> 'b::euclidean_space"
<   assumes "(f has_vector_derivative f') (at x0 within S)"
<   shows "((\<lambda>x. (f x - f x0) /\<^sub>R (x - x0)) \<longlongrightarrow> f') (at x0 within S)"
<   apply (rule LIM_zero_cancel)
<   apply (rule tendsto_norm_zero_cancel)
<   apply (rule Lim_transform_eventually)
< proof -
<   show "\<forall>\<^sub>F x in at x0 within S. norm ((f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0)) =
<     norm ((f x - f x0) /\<^sub>R (x - x0) - f')"
<     (is "\<forall>\<^sub>F x in _. ?th x")
<     unfolding eventually_at_filter
<   proof (safe intro!: eventuallyI)
<     fix x assume x: "x \<noteq> x0"
<     then have "norm ((f x - f x0) /\<^sub>R (x - x0) - f') = norm (sgn (x - x0) *\<^sub>R ((f x - f x0) /\<^sub>R (x - x0) - f'))"
<       by simp
<     also have "sgn (x - x0) *\<^sub>R ((f x - f x0) /\<^sub>R (x - x0) - f') = ((f x - f x0) /\<^sub>R norm (x - x0) - (x - x0) *\<^sub>R f' /\<^sub>R norm (x - x0))"
<       by (auto simp add: algebra_simps sgn_div_norm divide_simps)
<         (metis add.commute add_divide_distrib diff_add_cancel scaleR_add_left)
<     also have "\<dots> = (f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0)" by (simp add: algebra_simps)
<     finally show "?th x" ..
<   qed
<   show "((\<lambda>x. norm ((f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0))) \<longlongrightarrow> 0) (at x0 within S)"
<     by (rule tendsto_norm_zero)
<       (use assms in \<open>auto simp: has_vector_derivative_def has_derivative_at_within\<close>)
< qed
< 
< text \<open>A \<open>path_connected\<close> set \<open>S\<close> entering both \<open>T\<close> and \<open>-T\<close>
<       must cross the frontier of \<open>T\<close> \<close>
< lemma path_connected_frontier:
<   fixes S :: "'a::real_normed_vector set"
<   assumes "path_connected S"
<   assumes "S \<inter> T \<noteq> {}"
<   assumes "S \<inter> -T \<noteq> {}"
<   obtains s where "s \<in> S" "s \<in> frontier T"
< proof -
<   obtain st where st:"st \<in> S \<inter> T" using assms(2) by blast
<   obtain sn where sn:"sn \<in> S \<inter> -T" using assms(3) by blast
<   obtain g where g: "path g" "path_image g \<subseteq> S"
<     "pathstart g = st" "pathfinish g = sn"
<     using assms(1) st sn unfolding path_connected_def by blast
<   have a1:"pathstart g \<in> closure T" using st g(3) closure_Un_frontier by fastforce
<   have a2:"pathfinish g \<notin> T" using sn g(4) by auto
<   from exists_path_subpath_to_frontier[OF g(1) a1 a2]
<   obtain h where "path_image h \<subseteq> path_image g" "pathfinish h \<in> frontier T" by metis
<   thus ?thesis using g(2)
<     by (meson in_mono pathfinish_in_path_image that) 
< qed
< 
< lemma path_connected_not_frontier_subset:
<   fixes S :: "'a::real_normed_vector set"
<   assumes "path_connected S"
<   assumes "S \<inter> T \<noteq> {}"
<   assumes "S \<inter> frontier T = {}"
<   shows "S \<subseteq> T"
<   using path_connected_frontier assms by auto  
< 
< lemma compact_attains_bounds:
<   fixes f::"'a::topological_space \<Rightarrow> 'b::linorder_topology"
<   assumes compact: "compact S"
<   assumes ne: "S \<noteq> {}"
<   assumes cont: "continuous_on S f"
<   obtains l u where "l \<in> S" "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<in> {f l .. f u}"
< proof -
<   from compact_continuous_image[OF cont compact]
<   have compact_image: "compact (f ` S)" .
<   have ne_image: "f ` S \<noteq> {}" using ne by simp
<   from compact_attains_inf[OF compact_image ne_image]
<   obtain l where "l \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f l \<le> f x" by auto
<   moreover
<   from compact_attains_sup[OF compact_image ne_image]
<   obtain u where "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<le> f u" by auto
<   ultimately
<   have "l \<in> S" "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<in> {f l .. f u}" by auto
<   then show ?thesis ..
< qed
< 
< lemma uniform_limit_const[uniform_limit_intros]:
<   "uniform_limit S (\<lambda>x y. f x) (\<lambda>_. l) F" if "(f \<longlongrightarrow> l) F"
<   apply (auto simp: uniform_limit_iff)
<   subgoal for e
<     using tendstoD[OF that(1), of e]
<     by (auto simp: eventually_mono)
<   done
< 
< subsection \<open>Segments\<close>
< 
< text \<open>\<open>closed_segment\<close> throws away the order that our intuition keeps\<close>
< 
< definition line::"'a::real_vector \<Rightarrow> 'a \<Rightarrow> real \<Rightarrow> 'a"
<   ("{_ -- _}\<^bsub>_\<^esub>")
<   where "{a -- b}\<^bsub>u\<^esub> = a + u *\<^sub>R (b - a)"
< 
< abbreviation "line_image a b U \<equiv>(\<lambda>u. {a -- b}\<^bsub>u\<^esub>) ` U"
< notation line_image ("{_ -- _}\<^bsub>`_\<^esub>")
< 
< lemma in_closed_segment_iff_line: "x \<in> {a -- b} \<longleftrightarrow> (\<exists>c\<in>{0..1}. x = line a b c)"
<   by (auto simp: in_segment line_def algebra_simps)
< 
< lemma in_open_segment_iff_line: "x \<in> {a <--< b} \<longleftrightarrow> (\<exists>c\<in>{0<..<1}. a \<noteq> b \<and> x = line a b c)"
<   by (auto simp: in_segment line_def algebra_simps)
< 
< lemma line_convex_combination1: "(1 - u) *\<^sub>R line a b i + u *\<^sub>R b = line a b (i + u - i * u)"
<   by (auto simp: line_def algebra_simps)
< 
< lemma line_convex_combination2: "(1 - u) *\<^sub>R a + u *\<^sub>R line a b i = line a b (i*u)"
<   by (auto simp: line_def algebra_simps)
< 
< lemma line_convex_combination12: "(1 - u) *\<^sub>R line a b i + u *\<^sub>R line a b j = line a b (i + u * (j - i))"
<   by (auto simp: line_def algebra_simps)
< 
< lemma mult_less_one_less_self: "0 < x \<Longrightarrow> i < 1 \<Longrightarrow> i * x < x" for i x::real
<   by auto
< 
< lemma plus_times_le_one_lemma: "i + u - i * u \<le> 1" if "i \<le> 1" "u \<le> 1" for i u::real
<   by (simp add: diff_le_eq sum_le_prod1 that)
< 
< lemma plus_times_less_one_lemma: "i + u - i * u < 1" if "i < 1" "u < 1" for i u::real
< proof -
<   have "u * (1 - i) < 1 - i"
<     using that by force
<   then show ?thesis by (simp add: algebra_simps)
< qed
< 
< lemma line_eq_endpoint_iff[simp]:
<   "line a b i = b \<longleftrightarrow> (a = b \<or> i = 1)"
<   "a = line a b i \<longleftrightarrow> (a = b \<or> i = 0)"
<   by (auto simp: line_def algebra_simps)
< 
< lemma line_eq_iff[simp]: "line a b x = line a b y \<longleftrightarrow> (x = y \<or> a = b)"
<   by (auto simp: line_def)
< 
< lemma line_open_segment_iff:
<   "{line a b i<--<b} = line a b ` {i<..<1}"
<   if "i < 1" "a \<noteq> b"
<   using that
<   apply (auto simp: in_segment line_convex_combination1 plus_times_less_one_lemma)
<   subgoal for j
<     apply (rule exI[where x="(j - i)/(1 - i)"])
<     apply (auto simp: divide_simps algebra_simps)
<     by (metis add_diff_cancel less_numeral_extra(4) mult_2_right plus_times_less_one_lemma that(1))
<   done
< 
< lemma open_segment_line_iff:
<   "{a<--<line a b i} = line a b ` {0<..<i}"
<   if "0 < i" "a \<noteq> b"
<   using that
<   apply (auto simp: in_segment line_convex_combination2 plus_times_less_one_lemma)
<   subgoal for j
<     apply (rule exI[where x="j/i"])
<     by (auto simp: )
<   done
< 
< lemma line_closed_segment_iff:
<   "{line a b i--b} = line a b ` {i..1}"
<   if "i \<le> 1" "a \<noteq> b"
<   using that
<   apply (auto simp: in_segment line_convex_combination1 mult_le_cancel_right2 plus_times_le_one_lemma)
<   subgoal for j
<     apply (rule exI[where x="(j - i)/(1 - i)"])
<     apply (auto simp: divide_simps algebra_simps)
<     by (metis add_diff_cancel less_numeral_extra(4) mult_2_right plus_times_less_one_lemma that(1))
<   done
< 
< lemma closed_segment_line_iff:
<   "{a--line a b i} = line a b ` {0..i}"
<   if "0 < i" "a \<noteq> b"
<   using that
<   apply (auto simp: in_segment line_convex_combination2 plus_times_less_one_lemma)
<   subgoal for j
<     apply (rule exI[where x="j/i"])
<     by (auto simp: )
<   done
< 
< lemma closed_segment_line_line_iff: "{line a b i1--line a b i2} = line a b ` {i1..i2}" if "i1 \<le> i2"
<   using that
<   apply (auto simp: in_segment line_convex_combination12 intro!: imageI)
<    apply (smt mult_left_le_one_le)
<   subgoal for u
<     by (rule exI[where x="(u - i1)/(i2-i1)"]) auto
<   done
< 
< lemma line_line1: "line (line a b c) b x = line a b (c + x - c * x)"
<   by (simp add: line_def algebra_simps)
< 
< lemma line_line2: "line a (line a b c) x = line a b (c*x)"
<   by (simp add: line_def algebra_simps)
< 
< lemma line_in_subsegment:
<   "i1 < 1 \<Longrightarrow> i2 < 1 \<Longrightarrow> a \<noteq> b \<Longrightarrow> line a b i1 \<in> {line a b i2<--<b} \<longleftrightarrow> i2 < i1"
<   by (auto simp: line_open_segment_iff intro!: imageI)
< 
< lemma line_in_subsegment2:
<   "0 < i2 \<Longrightarrow> 0 < i1 \<Longrightarrow> a \<noteq> b \<Longrightarrow> line a b i1 \<in> {a<--<line a b i2} \<longleftrightarrow> i1 < i2"
<   by (auto simp: open_segment_line_iff intro!: imageI)
< 
< lemma line_in_open_segment_iff[simp]:
<   "line a b i \<in> {a<--<b} \<longleftrightarrow> (a \<noteq> b \<and> 0 < i \<and> i < 1)"
<   by (auto simp: in_open_segment_iff_line)
< 
< subsection \<open>Open Segments\<close>
< 
< lemma open_segment_subsegment:
<   assumes "x1 \<in> {x0<--<x3}"
<     "x2 \<in> {x1<--<x3}"
<   shows "x1 \<in> {x0<--<x2}"
<   using assms
< proof -\<comment> \<open>TODO: use \<open>line\<close>\<close>
<   from assms obtain u v::real where
<     ne: "x0 \<noteq> x3" "(1 - u) *\<^sub>R x0 + u *\<^sub>R x3 \<noteq> x3"
<     and x1_def: "x1 = (1 - u) *\<^sub>R x0 + u *\<^sub>R x3"
<     and x2_def: "x2 = (1 - v) *\<^sub>R ((1 - u) *\<^sub>R x0 + u *\<^sub>R x3) + v *\<^sub>R x3"
<     and uv: \<open>0 < u\<close> \<open>0 < v\<close> \<open>u < 1\<close> \<open>v < 1\<close>
<     by (auto simp: in_segment)
<   let ?d = "(u + v - u * v)"
<   have "?d > 0" using uv
<     by (auto simp: add_nonneg_pos pos_add_strict)
<   with \<open>x0 \<noteq> x3\<close> have "0 \<noteq> ?d *\<^sub>R (x3 - x0)" by simp
<   moreover
<   define ua where "ua = u / ?d"
<   have "ua * (u * v - u - v) - - u = 0"
<     by (auto simp: ua_def algebra_simps divide_simps)
<       (metis uv add_less_same_cancel1 add_strict_mono mult.right_neutral
<         mult_less_cancel_left_pos not_real_square_gt_zero vector_space_over_itself.scale_zero_left)
<   then have "(ua * (u * v - u - v) - - u) *\<^sub>R (x3 - x0) = 0"
<     by simp
<   moreover
<   have "0 < ua" "ua < 1"
<     using \<open>0 < u\<close> \<open>0 < v\<close> \<open>u < 1\<close> \<open>v < 1\<close>
<     by (auto simp: ua_def pos_add_strict intro!: divide_pos_pos)
<   ultimately show ?thesis
<     unfolding x1_def x2_def
<     by (auto intro!: exI[where x=ua] simp: algebra_simps in_segment)
< qed
< 
< 
< subsection \<open>Syntax\<close>
< 
< abbreviation sequentially_at_top::"(nat\<Rightarrow>real)\<Rightarrow>bool"
<   ("_ \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>") \<comment> \<open>the \<open>\<^bsub>\<^esub>\<close> is to disambiguate syntax...\<close>
<   where "s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>  \<equiv> filterlim s at_top sequentially"
< 
< abbreviation sequentially_at_bot::"(nat\<Rightarrow>real)\<Rightarrow>bool"
<   ("_ \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>")
<   where "s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>  \<equiv> filterlim s at_bot sequentially"
< 
< 
< subsection \<open>Paths\<close>
< 
< text \<open>@{thm subpath_linear_image} is too specific\<close>
< lemma subpath_image: "subpath u v (g \<circ> h) = g \<circ> subpath u v h"
<   by (rule ext) (simp add: subpath_def)
< 
< lemma subpath0_linepath:
<   shows "subpath 0 u (linepath t t') = linepath t (t + u * (t' - t))"
<   unfolding subpath_def linepath_def
<   apply (rule ext)
<   apply auto
< proof -
<   fix x :: real
<   have f1: "\<And>r ra rb rc. (r::real) + ra * rb - ra * rc = r - ra * (rc - rb)"
<     by (simp add: right_diff_distrib')
<   have f2: "\<And>r ra. (r::real) - r * ra = r * (1 - ra)"
<     by (simp add: right_diff_distrib')
<   have f3: "\<And>r ra rb. (r::real) - ra + rb + ra - r = rb"
<     by auto
<   have f4: "\<And>r. (r::real) + (1 - 1) = r"
<     by linarith
<   have f5: "\<And>r ra. (r::real) + ra = ra + r"
<     by force
<   have f6: "\<And>r ra. (r::real) + (1 - (r + 1) + ra) = ra"
<     by linarith
<   have "t - x * (t - (t + u * (t' - t))) = t' * (u * x) + (t - t * (u * x))"
<     by (simp add: right_diff_distrib')
<   then show "(1 - u * x) * t + u * x * t' = (1 - x) * t + x * (t + u * (t' - t))"
<     using f6 f5 f4 f3 f2 f1 by (metis (no_types) mult.commute)
< qed
< 
< lemma linepath_image0_right_open_real:
<   assumes "t < (t'::real)"
<   shows "linepath t t' ` {0..<1} = {t..<t'}"
<   unfolding linepath_def
<   apply auto
<     apply (metis add.commute add_diff_cancel_left' assms diff_diff_eq2 diff_le_eq less_eq_real_def mult.commute mult.right_neutral mult_right_mono right_diff_distrib')
<    apply (smt assms comm_semiring_class.distrib mult_diff_mult semiring_normalization_rules(2) zero_le_mult_iff)
< proof -
<   fix x
<   assume "t \<le> x" "x < t'"
<   let ?u = "(x-t)/(t'-t)"
<   have "?u \<ge> 0"
<     using \<open>t \<le> x\<close> assms by auto
<   moreover have "?u < 1"
<     by (simp add: \<open>x < t'\<close> assms)
<   moreover have "x = (1-?u) * t + ?u*t'"
<   proof -
<     have f1: "\<forall>r ra. (ra::real) * - r = r * - ra"
<       by simp
<     have "t + (t' + - t) * ((x + - t) / (t' + - t)) = x"
<       using assms by force
<     then have "t' * ((x + - t) / (t' + - t)) + t * (1 + - ((x + - t) / (t' + - t))) = x"
<       using f1 by (metis (no_types) add.left_commute distrib_left mult.commute mult.right_neutral)
<     then show ?thesis
<       by (simp add: mult.commute)
<   qed
<   ultimately show "x \<in> (\<lambda>x. (1 - x) * t + x * t') ` {0..<1}"
<     using atLeastLessThan_iff by blast 
< qed
< 
< lemma oriented_subsegment_scale:
<   assumes "x1 \<in> {a<--<b}"
<   assumes "x2 \<in> {x1<--<b}"
<   obtains e where "e > 0" "b-a = e *\<^sub>R (x2-x1)"
< proof -
<   from assms(1) obtain u where u : "u > 0" "u < 1" "x1 = (1 - u) *\<^sub>R a + u *\<^sub>R b"
<     unfolding in_segment by blast
<   from assms(2) obtain v where v: "v > 0" "v < 1" "x2 = (1 - v) *\<^sub>R x1 + v *\<^sub>R b"
<     unfolding in_segment by blast
<   have "x2-x1 = -v *\<^sub>R x1 + v *\<^sub>R b" using v
<     by (metis add.commute add_diff_cancel_right diff_minus_eq_add scaleR_collapse scaleR_left.minus)
<   also have "... = (-v) *\<^sub>R ((1 - u) *\<^sub>R a + u *\<^sub>R b)  + v *\<^sub>R b" using u by auto
<   also have "... = v *\<^sub>R ((1-u)*\<^sub>R b - (1-u)*\<^sub>R a )"
<     by (smt add_diff_cancel diff_diff_add diff_minus_eq_add minus_diff_eq scaleR_collapse scale_minus_left scale_right_diff_distrib)
<   finally have x2x1:"x2-x1 = (v *(1-u)) *\<^sub>R (b - a)"
<     by (metis scaleR_scaleR scale_right_diff_distrib)
<   have "v * (1-u) > 0"  using u(2) v(1) by simp
<   then have "(x2-x1)/\<^sub>R (v * (1-u)) = (b-a)" unfolding x2x1
<     by (smt field_class.field_inverse scaleR_one scaleR_scaleR) 
<   thus ?thesis
<     using \<open>0 < v * (1 - u)\<close> positive_imp_inverse_positive that by fastforce
< qed
< 
< end
---
> section \<open>Additions to HOL-Analysis\<close>
> theory Analysis_Misc
>   imports 
>     Ordinary_Differential_Equations.ODE_Analysis
> begin
> 
> subsection \<open>Unsorted Lemmas (TODO: sort!)\<close>
> 
> lemma uminus_uminus_image: "uminus ` uminus ` S = S"
>   for S::"'r::ab_group_add set"
>   by (auto simp: image_image)
> 
> lemma in_uminus_image_iff[simp]: "x \<in> uminus ` S \<longleftrightarrow> - x \<in> S"
>   for S::"'r::ab_group_add set"
>   by force
> 
> lemma closed_subsegmentI:
>   "w + t *\<^sub>R (z - w) \<in> {x--y}"
>   if "w \<in> {x -- y}" "z \<in> {x -- y}" and t: "0 \<le> t" "t\<le> 1"
> proof -
>   from that obtain u v where
>     w_def: "w = (1 - u) *\<^sub>R x + u *\<^sub>R y" and u: "0 \<le> u" "u \<le> 1"
>     and z_def: "z = (1 - v) *\<^sub>R x + v *\<^sub>R y" and v: "0 \<le> v" "v \<le> 1"
>     by (auto simp: in_segment)
>   have "w + t *\<^sub>R (z - w) =
>     (1 - (u - t * (u - v))) *\<^sub>R x + (u - t * (u - v)) *\<^sub>R y"
>     by (simp add: algebra_simps w_def z_def)
>   also have "\<dots> \<in> {x -- y}"
>     unfolding closed_segment_image_interval
>     apply (rule imageI)
>     using t u v
>     apply auto
>      apply (metis (full_types) diff_0_right diff_left_mono linear mult_left_le_one_le mult_nonneg_nonpos order.trans)
>     by (smt mult_left_le_one_le mult_nonneg_nonneg vector_space_over_itself.scale_right_diff_distrib)
>   finally show ?thesis .
> qed
> 
> lemma tendsto_minus_cancel_right: "((\<lambda>x. -g x) \<longlongrightarrow> l) F \<longleftrightarrow> (g \<longlongrightarrow> -l) F"
>   \<comment> \<open>cf @{thm tendsto_minus_cancel_left}\<close>
>   for g::"_ \<Rightarrow> 'b::topological_group_add"
>   by (simp add: tendsto_minus_cancel_left)
> 
> lemma tendsto_nhds_continuousI: "(f \<longlongrightarrow> l) (nhds x)" if "(f \<longlongrightarrow> l) (at x)" "f x = l"
>   \<comment> \<open>TODO: the assumption is continuity of f at x\<close>
> proof (rule topological_tendstoI)
>   fix S::"'b set" assume "open S" "l \<in> S"
>   from topological_tendstoD[OF that(1) this]
>   have "\<forall>\<^sub>F x in at x. f x \<in> S" .
>   then show "\<forall>\<^sub>F x in nhds x. f x \<in> S"
>     unfolding eventually_at_filter
>     by eventually_elim (auto simp: that \<open>l \<in> S\<close>)
> qed
> 
> lemma inj_composeD:
>   assumes "inj (\<lambda>x. g (t x))"
>   shows "inj t"
>   using assms
>   by (auto simp: inj_def)
> 
> lemma compact_sequentialE:
>   fixes S T::"'a::first_countable_topology set"
>   assumes "compact S"
>   assumes "infinite T"
>   assumes "T \<subseteq> S"
>   obtains t::"nat \<Rightarrow> 'a" and l::'a
>   where "\<And>n. t n \<in> T" "\<And>n. t n \<noteq> l" "t \<longlonglongrightarrow> l" "l \<in> S"
> proof -
>   from Heine_Borel_imp_Bolzano_Weierstrass[OF assms]
>   obtain l where "l \<in> S" "l islimpt T" by metis
>   then obtain t where "t n \<in> T" "t n \<noteq> l" "t \<longlonglongrightarrow> l" "l \<in> S" for n unfolding islimpt_sequential
>     by auto
>   then show ?thesis ..
> qed
> 
> lemma infinite_countable_subsetE:
>   fixes S::"'a set"
>   assumes "infinite S"
>   obtains g::"nat\<Rightarrow>'a" where "inj g" "range g \<subseteq> S"
>   using assms
>   by atomize_elim (simp add: infinite_countable_subset)
> 
> lemma real_quad_ge: "2 * (an * bn) \<le> an * an + bn * bn" for an bn::real
>   by (sos "(((A<0 * R<1) + (R<1 * (R<1 * [an + ~1*bn]^2))))")
> 
> lemma inner_quad_ge: "2 * (a \<bullet> b) \<le> a \<bullet> a + b \<bullet> b"
>   for a b::"'a::euclidean_space"\<comment> \<open>generalize?\<close>
> proof -
>   show ?thesis
>     by (subst (1 2 3) euclidean_inner)
>       (auto simp add: sum.distrib[symmetric] sum_distrib_left intro!: sum_mono real_quad_ge)
> qed
> 
> lemma inner_quad_gt: "2 * (a \<bullet> b) < a \<bullet> a + b \<bullet> b"
>   if "a \<noteq> b"
>   for a b::"'a::euclidean_space"\<comment> \<open>generalize?\<close>
> proof -
>   from that obtain i where "i \<in> Basis" "a \<bullet> i \<noteq> b \<bullet> i"
>     by (auto simp: euclidean_eq_iff[where 'a='a])
>   then have "2 * (a \<bullet> i * (b \<bullet> i)) < a \<bullet> i * (a \<bullet> i) + b \<bullet> i * (b \<bullet> i)"
>     using sum_sqs_eq[of "a\<bullet>i" "b\<bullet>i"]
>     by (auto intro!: le_neq_trans real_quad_ge)
>   then show ?thesis
>     by (subst (1 2 3) euclidean_inner)
>       (auto simp add: \<open>i \<in> Basis\<close> sum.distrib[symmetric] sum_distrib_left
>         intro!: sum_strict_mono_ex1 real_quad_ge)
> qed
> 
> lemma closed_segment_line_hyperplanes:
>   "{a -- b} = range (\<lambda>u. a + u *\<^sub>R (b - a)) \<inter> {x. a \<bullet> (b - a) \<le> x \<bullet> (b - a) \<and> x \<bullet> (b - a) \<le> b \<bullet> (b - a)}"
>   if "a \<noteq> b"
>   for a b::"'a::euclidean_space"
> proof safe
>   fix x assume x: "x \<in> {a--b}"
>   then obtain u where u: "0 \<le> u" "u \<le> 1" and x_eq: "x = a + u *\<^sub>R (b - a)"
>     by (auto simp add: in_segment algebra_simps)
>   show "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))" using x_eq by auto
>   have "2 * (a \<bullet> b) \<le> a \<bullet> a + b \<bullet> b"
>     by (rule inner_quad_ge)
>   then have "u * (2 * (a \<bullet> b) - a \<bullet> a - b \<bullet> b) \<le> 0"
>     "0 \<le> (1 - u) * (a \<bullet> a + b \<bullet> b - a \<bullet> b * 2)"
>     by (simp_all add: mult_le_0_iff u)
>   then show " a \<bullet> (b - a) \<le> x \<bullet> (b - a)" "x \<bullet> (b - a) \<le> b \<bullet> (b - a)"
>     by (auto simp: x_eq algebra_simps power2_eq_square inner_commute)
> next
>   fix u assume
>     "a \<bullet> (b - a) \<le> (a + u *\<^sub>R (b - a)) \<bullet> (b - a)"
>     "(a + u *\<^sub>R (b - a)) \<bullet> (b - a) \<le> b \<bullet> (b - a)"
>   then have "0 \<le> u * ((b - a) \<bullet> (b - a))" "0 \<le> (1 - u) * ((b - a) \<bullet> (b - a))"
>     by (auto simp: algebra_simps)
>   then have "0 \<le> u" "u \<le> 1"
>     using inner_ge_zero[of "(b - a)"] that
>     by (auto simp add: zero_le_mult_iff)
>   then show "a + u *\<^sub>R (b - a) \<in> {a--b}"
>     by (auto simp: in_segment algebra_simps)
> qed
> 
> lemma open_segment_line_hyperplanes:
>   "{a <--< b} = range (\<lambda>u. a + u *\<^sub>R (b - a)) \<inter> {x. a \<bullet> (b - a) < x \<bullet> (b - a) \<and> x \<bullet> (b - a) < b \<bullet> (b - a)}"
>   if "a \<noteq> b"
>   for a b::"'a::euclidean_space"
> proof safe
>   fix x assume x: "x \<in> {a<--<b}"
>   then obtain u where u: "0 < u" "u < 1" and x_eq: "x = a + u *\<^sub>R (b - a)"
>     by (auto simp add: in_segment algebra_simps)
>   show "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))" using x_eq by auto
>   have "2 * (a \<bullet> b) < a \<bullet> a + b \<bullet> b" using that
>     by (rule inner_quad_gt)
>   then have "u * (2 * (a \<bullet> b) - a \<bullet> a - b \<bullet> b) < 0"
>     "0 < (1 - u) * (a \<bullet> a + b \<bullet> b - a \<bullet> b * 2)"
>     by (simp_all add: mult_less_0_iff u)
>   then show " a \<bullet> (b - a) < x \<bullet> (b - a)" "x \<bullet> (b - a) < b \<bullet> (b - a)"
>     by (auto simp: x_eq algebra_simps power2_eq_square inner_commute)
> next
>   fix u assume
>     "a \<bullet> (b - a) < (a + u *\<^sub>R (b - a)) \<bullet> (b - a)"
>     "(a + u *\<^sub>R (b - a)) \<bullet> (b - a) < b \<bullet> (b - a)"
>   then have "0 < u * ((b - a) \<bullet> (b - a))" "0 < (1 - u) * ((b - a) \<bullet> (b - a))"
>     by (auto simp: algebra_simps)
>   then have "0 < u" "u < 1"
>     using inner_ge_zero[of "(b - a)"] that
>     by (auto simp add: zero_less_mult_iff)
>   then show "a + u *\<^sub>R (b - a) \<in> {a<--<b}"
>     by (auto simp: in_segment algebra_simps that)
> qed
> 
> lemma at_within_interior: "NO_MATCH UNIV S \<Longrightarrow> x \<in> interior S \<Longrightarrow> at x within S = at x"
>   by (auto intro: at_within_interior)
> 
> lemma tendsto_at_topI:
>   "(f \<longlongrightarrow> l) at_top" if "\<And>e. 0 < e \<Longrightarrow> \<exists>x0. \<forall>x\<ge>x0. dist (f x) l < e"
> for f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   using that
>   apply (intro tendstoI)
>   unfolding eventually_at_top_linorder
>   by auto
> 
> lemma tendsto_at_topE:
>   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   assumes "(f \<longlongrightarrow> l) at_top"
>   assumes "e > 0"
>   obtains x0 where "\<And>x. x \<ge> x0 \<Longrightarrow> dist (f x) l < e"
> proof -
>   from assms(1)[THEN tendstoD, OF assms(2)]
>   have "\<forall>\<^sub>F x in at_top. dist (f x) l < e" .
>   then show ?thesis
>     unfolding eventually_at_top_linorder
>     by (auto intro: that)
> qed
> lemma tendsto_at_top_iff: "(f \<longlongrightarrow> l) at_top \<longleftrightarrow> (\<forall>e>0. \<exists>x0. \<forall>x\<ge>x0. dist (f x) l < e)"
>   for f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   by (auto intro!: tendsto_at_topI elim!: tendsto_at_topE)
> 
> lemma tendsto_at_top_eq_left:
>   fixes f g::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   assumes "(f \<longlongrightarrow> l) at_top"
>   assumes "\<And>x. x \<ge> x0 \<Longrightarrow> f x = g x"
>   shows "(g \<longlongrightarrow> l) at_top"
>   unfolding tendsto_at_top_iff
>   by (metis (no_types, hide_lams) assms(1) assms(2) linear order_trans tendsto_at_topE)
> 
> lemma lim_divide_n: "(\<lambda>x. e / real x) \<longlonglongrightarrow> 0"
> proof -
>   have "(\<lambda>x. e * inverse (real x)) \<longlonglongrightarrow> 0"
>     by (auto intro: tendsto_eq_intros lim_inverse_n)
>   then show ?thesis by (simp add: inverse_eq_divide)
> qed
> 
> definition at_top_within :: "('a::order) set \<Rightarrow> 'a filter"
>   where "at_top_within s = (INF k \<in> s. principal ({k ..} \<inter> s)) "
> 
> lemma at_top_within_at_top[simp]:
>   shows "at_top_within UNIV = at_top"
>   unfolding at_top_within_def at_top_def
>   by (auto)
> 
> lemma at_top_within_empty[simp]:
>   shows "at_top_within {} = top"
>   unfolding at_top_within_def
>   by (auto)
> 
> definition "nhds_set X = (INF S\<in>{S. open S \<and> X \<subseteq> S}. principal S)"
> 
> lemma eventually_nhds_set:
>   "(\<forall>\<^sub>F x in nhds_set X. P x) \<longleftrightarrow> (\<exists>S. open S \<and> X \<subseteq> S \<and> (\<forall>x\<in>S. P x))"
>   unfolding nhds_set_def by (subst eventually_INF_base) (auto simp: eventually_principal)
> 
> term "filterlim f (nhds_set (frontier X)) F" \<comment> \<open>f tends to the boundary of X?\<close>
> 
> 
> text \<open>somewhat inspired by @{thm islimpt_range_imp_convergent_subsequence} and its dependencies.
> The class constraints seem somewhat arbitrary, perhaps this can be generalized in some way.
> \<close>
> lemma limpt_closed_imp_exploding_subsequence:\<comment>\<open>TODO: improve name?!\<close>
>   fixes f::"'a::{heine_borel,real_normed_vector} \<Rightarrow> 'b::{first_countable_topology, t2_space}"
>   assumes cont[THEN continuous_on_compose2, continuous_intros]: "continuous_on T f"
>   assumes closed: "closed T"
>   assumes bound: "\<And>t. t \<in> T \<Longrightarrow> f t \<noteq> l"
>   assumes limpt: "l islimpt (f ` T)"
>   obtains s where
>     "(f \<circ> s) \<longlonglongrightarrow> l"
>     "\<And>i. s i \<in> T"
>     "\<And>C. compact C \<Longrightarrow> C \<subseteq> T \<Longrightarrow> \<forall>\<^sub>F i in sequentially. s i \<notin> C"
> proof -
>   from countable_basis_at_decseq[of l]
>   obtain A where A: "\<And>i. open (A i)" "\<And>i. l \<in> A i"
>     and evA: "\<And>S. open S \<Longrightarrow> l \<in> S \<Longrightarrow> eventually (\<lambda>i. A i \<subseteq> S) sequentially"
>     by blast
> 
>   from closed_Union_compact_subsets[OF closed]
>   obtain C
>     where C: "(\<And>n. compact (C n))" "(\<And>n. C n \<subseteq> T)" "(\<And>n. C n \<subseteq> C (Suc n))" "\<Union> (range C) = T"
>       and evC: "(\<And>K. compact K \<Longrightarrow> K \<subseteq> T \<Longrightarrow> \<forall>\<^sub>F i in sequentially. K \<subseteq> C i)"
>     by (metis eventually_sequentially)
> 
>   have AC: "l \<in> A i - f ` C i" "open (A i - f ` C i)" for i
>     using C bound
>     by (fastforce intro!: open_Diff A compact_imp_closed compact_continuous_image continuous_intros)+
> 
>   from islimptE[OF limpt AC] have "\<exists>t\<in>T. f t \<in> A i - f ` C i \<and> f t \<noteq> l" for i by blast  
>   then obtain t where t: "\<And>i. t i \<in> T" "\<And>i. f (t i) \<in> A i - f ` C i" "\<And>i. f (t i) \<noteq> l"
>     by metis
> 
>   have "(f o t) \<longlonglongrightarrow> l"
>     using t
>     by (auto intro!: topological_tendstoI dest!: evA elim!: eventually_mono)
>   moreover
>   have "\<And>i. t i \<in> T" by fact
>   moreover
>   have "\<forall>\<^sub>F i in sequentially. t i \<notin> K" if "compact K" "K \<subseteq> T" for K
>     using evC[OF that]
>     by eventually_elim (use t in auto)
>   ultimately show ?thesis ..
> qed  
> 
> lemma Inf_islimpt: "bdd_below S \<Longrightarrow> Inf S \<notin> S \<Longrightarrow> S \<noteq> {} \<Longrightarrow> Inf S islimpt S" for S::"real set"
>   by (auto simp: islimpt_in_closure intro!: closure_contains_Inf)
> 
> context linorder
> begin
> 
> text \<open>HOL-analysis doesn't seem to have these, maybe they were never needed.
>   Some variants are around @{thm Int_atLeastAtMost}, but with old-style naming conventions.
>   Change to the "modern" I.. convention there?\<close>
> 
> lemma Int_Ico[simp]:
>   shows "{a..} \<inter> {b..} = {max a b ..}"
>   by (auto)
> 
> lemma Int_Ici_Ico[simp]:
>   shows "{a..} \<inter> {b..<c} = {max a b ..<c}"
>   by auto
> 
> lemma Int_Ico_Ici[simp]:
>   shows "{a..<c} \<inter> {b..} = {max a b ..<c}"
>   by auto
> 
> lemma subset_Ico_iff[simp]:
>   "{a..<b} \<subseteq> {c..<b} \<longleftrightarrow> b \<le> a \<or> c \<le> a"
>   unfolding atLeastLessThan_def
>   by auto
> 
> lemma Ico_subset_Ioo_iff[simp]:
>   "{a..<b} \<subseteq> {c<..<b} \<longleftrightarrow> b \<le> a \<or> c < a"
>   unfolding greaterThanLessThan_def atLeastLessThan_def
>   by auto
> 
> lemma Icc_Un_Ici[simp]:
>   shows "{a..b} \<union> {b..} = {min a b..}"
>   unfolding atLeastAtMost_def atLeast_def atMost_def min_def
>   by auto
> 
> end
> 
> lemma at_top_within_at_top_unbounded_right:
>   fixes a::"'a::linorder"
>   shows "at_top_within {a..} = at_top"
>   unfolding at_top_within_def at_top_def
>   apply (auto intro!: INF_eq)
>   by (metis linorder_class.linear linorder_class.max.cobounded1 linorder_class.max.idem ord_class.atLeast_iff)
> 
> lemma at_top_within_at_top_unbounded_rightI:
>   fixes a::"'a::linorder"
>   assumes "{a..} \<subseteq> s"
>   shows "at_top_within s = at_top"
>   unfolding at_top_within_def at_top_def
>   apply (auto intro!: INF_eq)
>    apply (meson Ici_subset_Ioi_iff Ioi_le_Ico assms dual_order.refl dual_order.trans leI)
>   by (metis assms atLeast_iff atLeast_subset_iff inf.cobounded1 linear subsetD)
> 
> lemma at_top_within_at_top_bounded_right:
>   fixes a b::"'a::{dense_order,linorder_topology}"
>   assumes "a < b"
>   shows "at_top_within {a..<b} = at_left b"
>   unfolding at_top_within_def at_left_eq[OF assms(1)]
>   apply (auto intro!: INF_eq)
>    apply (smt atLeastLessThan_iff greaterThanLessThan_iff le_less lessThan_iff max.absorb1 subset_eq)
>   by (metis assms atLeastLessThan_iff dense linear max.absorb1 not_less order_trans)
> 
> lemma at_top_within_at_top_bounded_right':
>   fixes a b::"'a::{dense_order,linorder_topology}"
>   assumes "a < b"
>   shows "at_top_within {..<b} = at_left b"
>   unfolding at_top_within_def at_left_eq[OF assms(1)]
>   apply (auto intro!: INF_eq)
>    apply (meson atLeast_iff greaterThanLessThan_iff le_less lessThan_iff subset_eq)
>   by (metis Ico_subset_Ioo_iff atLeastLessThan_def dense lessThan_iff)
> 
> lemma eventually_at_top_within_linorder:
>   assumes sn:"s \<noteq> {}"
>   shows "eventually P (at_top_within s) \<longleftrightarrow> (\<exists>x0::'a::{linorder_topology} \<in> s. \<forall>x \<ge> x0. x\<in> s \<longrightarrow> P x)"
>   unfolding at_top_within_def
>   apply (subst eventually_INF_base)
>     apply (auto simp:eventually_principal sn)
>   by (metis atLeast_subset_iff inf.coboundedI2 inf_commute linear)
> 
> lemma tendsto_at_top_withinI:
>   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   assumes "s \<noteq> {}"
>   assumes "\<And>e. 0 < e \<Longrightarrow> \<exists>x0 \<in> s. \<forall>x \<in> {x0..} \<inter> s. dist (f x) l < e"
>   shows  "(f \<longlongrightarrow> l) (at_top_within s)"
>   apply(intro tendstoI)
>   unfolding at_top_within_def apply (subst eventually_INF_base)
>     apply (auto simp:eventually_principal assms)
>   by (metis atLeast_subset_iff inf.coboundedI2 inf_commute linear)
> 
> lemma tendsto_at_top_withinE:
>   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   assumes "s \<noteq> {}"
>   assumes "(f \<longlongrightarrow> l) (at_top_within s)"
>   assumes "e > 0"
>   obtains x0 where "x0 \<in> s" "\<And>x. x \<in> {x0..} \<inter> s \<Longrightarrow> dist (f x) l < e"
> proof -
>   from assms(2)[THEN tendstoD, OF assms(3)]
>   have "\<forall>\<^sub>F x in at_top_within s. dist (f x) l < e" .
>   then show ?thesis unfolding eventually_at_top_within_linorder[OF \<open>s \<noteq> {}\<close>] 
>     by (auto intro: that)
> qed
> 
> lemma tendsto_at_top_within_iff:
>   fixes f::"'a::linorder_topology \<Rightarrow> 'b::metric_space"
>   assumes "s \<noteq> {}"
>   shows "(f \<longlongrightarrow> l) (at_top_within s) \<longleftrightarrow> (\<forall>e>0. \<exists>x0 \<in> s. \<forall>x \<in> {x0..} \<inter> s. dist (f x) l < e)"
>   by (auto intro!: tendsto_at_top_withinI[OF \<open>s \<noteq> {}\<close>] elim!: tendsto_at_top_withinE[OF \<open>s \<noteq> {}\<close>])
> 
> lemma filterlim_at_top_at_top_within_bounded_right:
>   fixes a b::"'a::{dense_order,linorder_topology}"
>   fixes f::"'a \<Rightarrow> real"
>   assumes "a < b"
>   shows "filterlim f at_top (at_top_within {..<b}) = (f \<longlongrightarrow> \<infinity>) (at_left b)"
>   unfolding filterlim_at_top_dense
>     at_top_within_at_top_bounded_right'[OF assms(1)]
>     eventually_at_left[OF assms(1)]
>     tendsto_PInfty
>   by auto
> 
> text \<open>Extract a sequence (going to infinity) bounded away from l\<close>
> 
> lemma not_tendsto_frequentlyE:
>   assumes "\<not>((f \<longlongrightarrow> l) F)"
>   obtains S where "open S" "l \<in> S" "\<exists>\<^sub>F x in F. f x \<notin> S"
>   using assms
>   by (auto simp: tendsto_def not_eventually)
> 
> lemma not_tendsto_frequently_metricE:
>   assumes "\<not>((f \<longlongrightarrow> l) F)"
>   obtains e where "e > 0" "\<exists>\<^sub>F x in F. e \<le> dist (f x) l"
>   using assms
>   by (auto simp: tendsto_iff not_eventually not_less)
> 
> lemma eventually_frequently_conj: "frequently P F \<Longrightarrow> eventually Q F \<Longrightarrow> frequently (\<lambda>x. P x \<and> Q x) F"
>   unfolding frequently_def
>   apply (erule contrapos_nn)
>   subgoal premises prems
>     using prems by eventually_elim auto
>   done
> 
> lemma frequently_at_top:
>   "(\<exists>\<^sub>F t in at_top. P t) \<longleftrightarrow> (\<forall>t0. \<exists>t>t0. P t)"
>   for P::"'a::{linorder,no_top}\<Rightarrow>bool" 
>   by (auto simp: frequently_def eventually_at_top_dense)
> 
> lemma frequently_at_topE:
>   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_"
>   assumes freq[rule_format]: "\<forall>n. \<exists>\<^sub>F a in at_top. P n a"
>   obtains s::"nat\<Rightarrow>'a"
>   where "\<And>i. P i (s i)" "strict_mono s"
> proof -
>   have "\<exists>f. \<forall>n. P n (f n) \<and> f n < f (Suc n)"
>   proof (rule dependent_nat_choice)
>     from frequently_ex[OF freq[of 0]] show "\<exists>x. P 0 x" .
>     fix x n assume "P n x"
>     from freq[unfolded frequently_at_top, rule_format, of x "Suc n"]
>     obtain y where "P (Suc n) y" "y > x" by auto
>     then show "\<exists>y. P (Suc n) y \<and> x < y"
>       by auto
>   qed
>   then obtain s where "\<And>i. P i (s i)" "strict_mono s"
>     unfolding strict_mono_Suc_iff by auto
>   then show ?thesis ..
> qed
> 
> lemma frequently_at_topE':
>   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_"
>   assumes freq[rule_format]: "\<forall>n. \<exists>\<^sub>F a in at_top. P n a"
>     and g: "filterlim g at_top sequentially"
>   obtains s::"nat\<Rightarrow>'a"
>   where "\<And>i. P i (s i)" "strict_mono s" "\<And>n. g n \<le> s n"
> proof -
>   have "\<forall>n. \<exists>\<^sub>F a in at_top. P n a \<and> g n \<le> a"
>     using freq
>     by (auto intro!: eventually_frequently_conj)
>   from frequently_at_topE[OF this] obtain s where "\<And>i. P i (s i)" "strict_mono s" "\<And>n. g n \<le> s n"
>     by metis
>   then show ?thesis ..
> qed
> 
> lemma frequently_at_top_at_topE:
>   fixes P::"nat \<Rightarrow> 'a::{linorder,no_top}\<Rightarrow>_" and g::"nat\<Rightarrow>'a"
>   assumes "\<forall>n. \<exists>\<^sub>F a in at_top. P n a" "filterlim g at_top sequentially"
>   obtains s::"nat\<Rightarrow>'a"
>   where "\<And>i. P i (s i)" "filterlim s at_top sequentially"
> proof -
>   from frequently_at_topE'[OF assms]
>   obtain s where s: "(\<And>i. P i (s i))" "strict_mono s" "(\<And>n. g n \<le> s n)" by blast
>   have s_at_top: "filterlim s at_top sequentially"
>     by (rule filterlim_at_top_mono) (use assms s in auto)
>   with s(1) show ?thesis ..
> qed
> 
> (* Extract a strict monotone and sequence converging to something other than l *)
> lemma not_tendsto_convergent_seq:
>   fixes f::"real \<Rightarrow> 'a::metric_space"
>   assumes X: "compact (X::'a set)"
>   assumes im: "\<And>x. x \<ge> 0 \<Longrightarrow> f x \<in> X"
>   assumes nl: "\<not> ((f \<longlongrightarrow> (l::'a)) at_top)"
>   obtains s k where
>     "k \<in> X" "k \<noteq> l" "(f \<circ> s) \<longlonglongrightarrow> k" "strict_mono s" "\<forall>n. s n \<ge> n"
> proof -
>   from not_tendsto_frequentlyE[OF nl]
>   obtain S where "open S" "l \<in> S" "\<exists>\<^sub>F x in at_top. f x \<notin> S" .
>   have "\<forall>n. \<exists>\<^sub>F x in at_top. f x \<notin> S \<and> real n \<le> x"
>     apply (rule allI)
>     apply (rule eventually_frequently_conj)
>      apply fact
>     by (rule eventually_ge_at_top)
>   from frequently_at_topE[OF this]
>   obtain s where "\<And>i. f (s i) \<notin> S" and s: "strict_mono s" and s_ge: "(\<And>i. real i \<le> s i)" by metis
>   then have "0 \<le> s i" for i using dual_order.trans of_nat_0_le_iff by blast
>   then have "\<forall>n. (f \<circ> s) n \<in> X" using im by auto
>   from X[unfolded compact_def, THEN spec, THEN mp, OF this]
>   obtain k r where k: "k \<in> X" and r: "strict_mono r" and kLim: "(f \<circ> s \<circ> r) \<longlonglongrightarrow> k" by metis
>   have "k \<in> X - S"
>     by (rule Lim_in_closed_set[of "X - S", OF _ _ _ kLim])
>       (auto simp: im \<open>0 \<le> s _\<close>  \<open>\<And>i. f (s i) \<notin> S\<close> intro!: \<open>open S\<close> X intro: compact_imp_closed)
> 
>   note k
>   moreover have "k \<noteq> l" using \<open>k \<in> X - S\<close> \<open>l \<in> S\<close> by auto
>   moreover have "(f \<circ> (s \<circ> r)) \<longlonglongrightarrow> k" using kLim by (simp add: o_assoc)
>   moreover have "strict_mono (s \<circ> r)" using s r by (rule strict_mono_o)
>   moreover have "\<forall>n. (s \<circ> r) n \<ge> n" using s_ge r
>     by (metis comp_apply dual_order.trans of_nat_le_iff seq_suble)
>   ultimately show ?thesis ..
> qed
> 
> lemma harmonic_bound:
>   shows "1 / 2 ^(Suc n) < 1 / real (Suc n)"
> proof (induction n)
>   case 0
>   then show ?case by auto
> next
>   case (Suc n)
>   then show ?case
>     by (smt frac_less2 of_nat_0_less_iff of_nat_less_two_power zero_less_Suc)
> qed
> 
> lemma INF_bounded_imp_convergent_seq:
>   fixes f::"real \<Rightarrow> real"
>   assumes cont: "continuous_on {a..} f"
>   assumes bound: "\<And>t. t \<ge> a \<Longrightarrow> f t > l"
>   assumes inf: "(INF t\<in>{a..}. f t) = l"
>   obtains s where
>     "(f \<circ> s) \<longlonglongrightarrow> l"
>     "\<And>i. s i \<in> {a..}"
>     "filterlim s at_top sequentially"
> proof -
>   have bound': "t \<in> {a..} \<Longrightarrow> f t \<noteq> l" for t using bound[of t] by auto
>   have limpt: "l islimpt f ` {a..}"
>   proof -
>     have "Inf (f ` {a..}) islimpt f ` {a..}"
>       by (rule Inf_islimpt) (auto simp: inf intro!: bdd_belowI2[where m=l] dest: bound)
>     then show ?thesis by (simp add: inf)
>   qed
>   from limpt_closed_imp_exploding_subsequence[OF cont closed_atLeast bound' limpt]
>   obtain s where s: "(f \<circ> s) \<longlonglongrightarrow> l"
>     "\<And>i. s i \<in> {a..}"
>     "compact C \<Longrightarrow> C \<subseteq> {a..} \<Longrightarrow> \<forall>\<^sub>F i in sequentially. s i \<notin> C" for C
>     by metis
>   have "\<forall>\<^sub>F i in sequentially. s i \<ge> n" for n
>     using s(3)[of "{a..n}"] s(2)
>     by (auto elim!: eventually_mono)
>   then have "filterlim s at_top sequentially"
>     unfolding filterlim_at_top
>     by auto
>   from s(1) s(2) this
>   show ?thesis ..
> qed
> 
> (* Generalizes to other combinations of strict_mono and filterlim *)
> lemma filterlim_at_top_strict_mono:
>   fixes s :: "_ \<Rightarrow> 'a::linorder"
>   fixes r :: "nat \<Rightarrow> _"
>   assumes "strict_mono s"
>   assumes "strict_mono r"
>   assumes "filterlim s at_top F"
>   shows "filterlim (s \<circ> r) at_top F"
>   apply (rule filterlim_at_top_mono[OF assms(3)])
>   by (simp add: assms(1) assms(2) seq_suble strict_mono_leD)
> 
> lemma LIMSEQ_lb:
>   assumes fl: "s \<longlonglongrightarrow> (l::real)"
>   assumes u: "l < u"
>   shows "\<exists>n0. \<forall>n\<ge>n0. s n < u"
> proof -
>   from fl have "\<exists>no>0. \<forall>n\<ge>no. dist (s n) l < u-l" unfolding LIMSEQ_iff_nz using u
>     by simp
>   thus ?thesis using dist_real_def by fastforce
> qed
> 
> (* Used to sharpen a tendsto with additional information*)
> lemma filterlim_at_top_choose_lower:
>   assumes "filterlim s at_top sequentially"
>   assumes "(f \<circ> s) \<longlonglongrightarrow> l"
>   obtains t where
>     "filterlim t at_top sequentially"
>     "(f \<circ> t) \<longlonglongrightarrow> l"
>     "\<forall>n. t n \<ge> (b::real)"
> proof -
>   obtain k where k: "\<forall>n \<ge> k. s n \<ge> b" using assms(1)
>     unfolding filterlim_at_top eventually_sequentially by blast
>   define t where "t = (\<lambda>n. s (n+k))"
>   then have "\<forall>n. t n \<ge> b" using k by simp
>   have "filterlim t at_top sequentially" using assms(1)
>     unfolding filterlim_at_top eventually_sequentially t_def
>     by (metis (full_types) add.commute trans_le_add2)
>   from LIMSEQ_ignore_initial_segment[OF assms(2), of "k"]
>   have "(\<lambda>n. (f \<circ> s) (n + k)) \<longlonglongrightarrow> l" .
>   then have "(f \<circ> t) \<longlonglongrightarrow> l" unfolding t_def o_def by simp
>   show ?thesis
>     using \<open>(f \<circ> t) \<longlonglongrightarrow> l\<close> \<open>\<forall>n. b \<le> t n\<close> \<open>filterlim t at_top sequentially\<close> that by blast
> qed
> 
> lemma frequently_at_top_realE:
>   fixes P::"nat \<Rightarrow> real \<Rightarrow> bool"
>   assumes "\<forall>n. \<exists>\<^sub>F t in at_top. P n t"
>   obtains s::"nat\<Rightarrow>real"
>   where "\<And>i. P i (s i)" "filterlim s at_top at_top"
>   by (metis assms frequently_at_top_at_topE[OF _ filterlim_real_sequentially])
> 
> lemma approachable_sequenceE:
>   fixes f::"real \<Rightarrow> 'a::metric_space"
>   assumes "\<And>t e. 0 \<le> t \<Longrightarrow> 0 < e \<Longrightarrow> \<exists>tt\<ge>t. dist (f tt) p < e"
>   obtains s where "filterlim s at_top sequentially" "(f \<circ> s) \<longlonglongrightarrow> p"
> proof -
>   have "\<forall>n. \<exists>\<^sub>F i in at_top. dist (f i) p < 1/real (Suc n)"
>     unfolding frequently_at_top
>     apply (auto )
>     subgoal for n m
>       using assms[of "max 0 (m+1)" "1/(Suc n)"]
>       by force
>     done
>   from frequently_at_top_realE[OF this]
>   obtain s where s: "\<And>i. dist (f (s i)) p < 1 / real (Suc i)" "filterlim s at_top sequentially"
>     by metis
>   note this(2)
>   moreover
>   have "(f o s) \<longlonglongrightarrow> p"
>   proof (rule tendstoI)
>     fix e::real assume "e > 0"
>     have "\<forall>\<^sub>F i in sequentially. 1 / real (Suc i) < e"
>       apply (rule order_tendstoD[OF _ \<open>0 < e\<close>])
>       apply (rule real_tendsto_divide_at_top)
>        apply (rule tendsto_intros)
>       by (rule filterlim_compose[OF filterlim_real_sequentially filterlim_Suc])
>     then show "\<forall>\<^sub>F x in sequentially. dist ((f \<circ> s) x) p < e"
>       by eventually_elim (use dual_order.strict_trans s \<open>e > 0\<close> in auto)
>   qed
>   ultimately show ?thesis ..
> qed
> 
> lemma mono_inc_bdd_above_has_limit_at_topI:
>   fixes f::"real \<Rightarrow> real"
>   assumes "mono f"
>   assumes "\<And>x. f x \<le> u"
>   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
> proof -
>   define l where "l = Sup (range (\<lambda>n. f (real n)))"
>   have t:"(\<lambda>n. f (real n)) \<longlonglongrightarrow> l" unfolding l_def
>     apply (rule LIMSEQ_incseq_SUP)
>      apply (meson assms(2) bdd_aboveI2)
>     by (meson assms(1) mono_def of_nat_mono)
>   from tendsto_at_topI_sequentially_real[OF assms(1) t]
>   have "(f \<longlongrightarrow> l) at_top" .
>   thus ?thesis by blast  
> qed
> 
> lemma gen_mono_inc_bdd_above_has_limit_at_topI:
>   fixes f::"real \<Rightarrow> real"
>   assumes "\<And>x y. x \<ge> b \<Longrightarrow> x \<le> y \<Longrightarrow> f x \<le> f y"
>   assumes "\<And>x. x \<ge> b \<Longrightarrow> f x \<le> u"
>   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
> proof -
>   define ff where "ff = (\<lambda>x. if x \<ge> b then f x else f b)"
>   have m1:"mono ff" unfolding ff_def mono_def using assms(1) by simp
>   have m2:"\<And>x. ff x \<le> u" unfolding ff_def using assms(2) by simp
>   from mono_inc_bdd_above_has_limit_at_topI[OF m1 m2]
>   obtain l where "(ff \<longlongrightarrow> l) at_top" by blast
>   thus ?thesis
>     by (meson \<open>(ff \<longlongrightarrow> l) at_top\<close> ff_def tendsto_at_top_eq_left)
> qed
> 
> lemma gen_mono_dec_bdd_below_has_limit_at_topI:
>   fixes f::"real \<Rightarrow> real"
>   assumes "\<And>x y. x \<ge> b \<Longrightarrow> x \<le> y \<Longrightarrow> f x \<ge> f y"
>   assumes "\<And>x. x \<ge> b \<Longrightarrow> f x \<ge> u"
>   shows "\<exists>l. (f \<longlongrightarrow> l) at_top"
> proof -
>   define ff where "ff = (\<lambda>x. if x \<ge> b then f x else f b)"
>   have m1:"mono (-ff)" unfolding ff_def mono_def using assms(1) by simp
>   have m2:"\<And>x. (-ff) x \<le> -u" unfolding ff_def using assms(2) by simp
>   from mono_inc_bdd_above_has_limit_at_topI[OF m1 m2]
>   obtain l where "(-ff \<longlongrightarrow> l) at_top" by blast
>   then have "(ff \<longlongrightarrow> -l) at_top"
>     using tendsto_at_top_eq_left tendsto_minus_cancel_left by fastforce  
>   thus ?thesis
>     by (meson \<open>(ff \<longlongrightarrow> -l) at_top\<close> ff_def tendsto_at_top_eq_left)
> qed
> 
> lemma infdist_closed:
>   shows "closed ({z. infdist z S \<ge> e})"
>   by (auto intro!:closed_Collect_le simp add:continuous_on_infdist)
> 
> (* TODO: this is a copy of LIMSEQ_norm_0 where the sequence
>   is bounded above in norm by a geometric series *)
> lemma LIMSEQ_norm_0_pow:
>   assumes "k > 0" "b > 1"
>   assumes  "\<And>n::nat. norm (s n) \<le> k / b^n"
>   shows "s \<longlonglongrightarrow> 0"
> proof (rule metric_LIMSEQ_I)
>   fix e
>   assume "e > (0::real)"
>   then have "k / e > 0" using assms(1) by auto
>   obtain N where N: "b^(N::nat) > k / e" using assms(2)
>     using real_arch_pow by blast
>   then have "norm (s n) < e" if "n \<ge> N" for n
>   proof -
>     have "k / b^n \<le> k / b^N"
>       by (smt assms(1) assms(2) frac_le leD power_less_imp_less_exp that zero_less_power)
>     also have " ... < e" using N
>       by (metis \<open>0 < e\<close> assms(2) less_trans mult.commute pos_divide_less_eq zero_less_one zero_less_power)
>     finally show ?thesis
>       by (meson assms less_eq_real_def not_le order_trans)
>   qed
>   then show "\<exists>no. \<forall>n\<ge>no. dist (s n) 0 < e"
>     by auto
> qed
> 
> lemma filterlim_apply_filtermap:
>   assumes g: "filterlim g G F"
>   shows "filterlim (\<lambda>x. m (g x)) (filtermap m G) F"
>   by (metis filterlim_def filterlim_filtermap filtermap_mono g)
> 
> lemma eventually_at_right_field_le:
>   "eventually P (at_right x) \<longleftrightarrow> (\<exists>b>x. \<forall>y>x. y \<le> b \<longrightarrow> P y)"
>   for x :: "'a::{linordered_field, linorder_topology}"
>   by (smt dense eventually_at_right_field le_less_trans less_le_not_le order.strict_trans1)
> 
> subsection \<open>indexing euclidean space with natural numbers\<close>
> 
> definition  nth_eucl :: "'a::executable_euclidean_space \<Rightarrow> nat \<Rightarrow> real" where
>   "nth_eucl x i = x \<bullet> (Basis_list ! i)"
>   \<comment> \<open>TODO: why is that and some sort of \<open>lambda_eucl\<close> nowhere available?\<close>
> definition lambda_eucl :: "(nat \<Rightarrow> real) \<Rightarrow> 'a::executable_euclidean_space" where
>   "lambda_eucl (f::nat\<Rightarrow>real) = (\<Sum>i<DIM('a). f i *\<^sub>R Basis_list ! i)"
> 
> lemma eucl_eq_iff: "x = y \<longleftrightarrow> (\<forall>i<DIM('a). nth_eucl x i = nth_eucl y i)"
>   for x y::"'a::executable_euclidean_space"
>   apply (auto simp: nth_eucl_def euclidean_eq_iff[where 'a='a])
>   by (metis eucl_of_list_list_of_eucl list_of_eucl_eq_iff)
> 
> bundle eucl_notation begin
> notation nth_eucl (infixl "$\<^sub>e" 90)
> end
> bundle no_eucl_notation begin
> no_notation nth_eucl (infixl "$\<^sub>e" 90)
> end
> 
> unbundle eucl_notation
> 
> lemma eucl_of_list_eucl_nth:
>   "(eucl_of_list xs::'a) $\<^sub>e i = xs ! i"
>   if "length xs = DIM('a::executable_euclidean_space)"
>     "i < DIM('a)"
>   using that
>   apply (auto simp: nth_eucl_def)
>   by (metis list_of_eucl_eucl_of_list list_of_eucl_nth)
> 
> lemma eucl_of_list_inner:
>   "(eucl_of_list xs::'a) \<bullet> eucl_of_list ys = (\<Sum>(x,y)\<leftarrow>zip xs ys. x * y)"
>   if "length xs = DIM('a::executable_euclidean_space)"
>     "length ys = DIM('a::executable_euclidean_space)"
>   using that
>   by (auto simp: nth_eucl_def eucl_of_list_inner_eq inner_lv_rel_def)
> 
> lemma self_eq_eucl_of_list: "x = eucl_of_list (map (\<lambda>i. x $\<^sub>e i) [0..<DIM('a)])"
>   for x::"'a::executable_euclidean_space"
>   by (auto simp: eucl_eq_iff[where 'a='a] eucl_of_list_eucl_nth)
> 
> lemma inner_nth_eucl: "x \<bullet> y = (\<Sum>i<DIM('a). x $\<^sub>e i * y $\<^sub>e i)"
>   for x y::"'a::executable_euclidean_space"
>   apply (subst self_eq_eucl_of_list[where x=x])
>   apply (subst self_eq_eucl_of_list[where x=y])
>   apply (subst eucl_of_list_inner)
>   by (auto simp: map2_map_map atLeast_upt interv_sum_list_conv_sum_set_nat)
> 
> lemma norm_nth_eucl: "norm x = L2_set (\<lambda>i. x $\<^sub>e i) {..<DIM('a)}"
>   for x::"'a::executable_euclidean_space"
>   unfolding norm_eq_sqrt_inner inner_nth_eucl L2_set_def
>   by (auto simp: power2_eq_square)
> 
> 
> lemma plus_nth_eucl: "(x + y) $\<^sub>e i = x $\<^sub>e i + y $\<^sub>e i"
>   and minus_nth_eucl: "(x - y) $\<^sub>e i = x $\<^sub>e i - y $\<^sub>e i"
>   and uminus_nth_eucl: "(-x) $\<^sub>e i = - x $\<^sub>e i"
>   and scaleR_nth_eucl: "(c *\<^sub>R x) $\<^sub>e i = c *\<^sub>R (x $\<^sub>e i)"
>   by (auto simp: nth_eucl_def algebra_simps)
> 
> lemma inf_nth_eucl: "inf x y $\<^sub>e i = min (x $\<^sub>e i) (y $\<^sub>e i)"
>   if "i < DIM('a)"
>   for x::"'a::executable_euclidean_space"
>   by (auto simp: nth_eucl_def algebra_simps inner_Basis_inf_left that inf_min)
> lemma sup_nth_eucl: "sup x y $\<^sub>e i = max (x $\<^sub>e i) (y $\<^sub>e i)"
>   if "i < DIM('a)"
>   for x::"'a::executable_euclidean_space"
>   by (auto simp: nth_eucl_def algebra_simps inner_Basis_sup_left that sup_max)
> 
> lemma le_iff_le_nth_eucl: "x \<le> y \<longleftrightarrow> (\<forall>i<DIM('a). (x $\<^sub>e i) \<le> (y $\<^sub>e i))"
>   for x::"'a::executable_euclidean_space"
>   apply (auto simp: nth_eucl_def algebra_simps eucl_le[where 'a='a])
>   by (meson eucl_le eucl_le_Basis_list_iff)
> 
> lemma eucl_less_iff_less_nth_eucl: "eucl_less x y \<longleftrightarrow> (\<forall>i<DIM('a). (x $\<^sub>e i) < (y $\<^sub>e i))"
>   for x::"'a::executable_euclidean_space"
>   apply (auto simp: nth_eucl_def algebra_simps eucl_less_def[where 'a='a])
>   by (metis Basis_zero eucl_eq_iff inner_not_same_Basis inner_zero_left length_Basis_list
>       nth_Basis_list_in_Basis nth_eucl_def)
> 
> lemma continuous_on_nth_eucl[continuous_intros]:
>   "continuous_on X (\<lambda>x. f x $\<^sub>e i)"
>   if "continuous_on X f"
>   by (auto simp: nth_eucl_def intro!: continuous_intros that)
> 
> 
> subsection \<open>derivatives\<close>
> 
> lemma eventually_at_ne[intro, simp]: "\<forall>\<^sub>F x in at x0. x \<noteq> x0"
>   by (auto simp: eventually_at_filter)
> 
> lemma has_vector_derivative_withinD:
>   fixes f::"real \<Rightarrow> 'b::euclidean_space"
>   assumes "(f has_vector_derivative f') (at x0 within S)"
>   shows "((\<lambda>x. (f x - f x0) /\<^sub>R (x - x0)) \<longlongrightarrow> f') (at x0 within S)"
>   apply (rule LIM_zero_cancel)
>   apply (rule tendsto_norm_zero_cancel)
>   apply (rule Lim_transform_eventually)
> proof -
>   show "\<forall>\<^sub>F x in at x0 within S. norm ((f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0)) =
>     norm ((f x - f x0) /\<^sub>R (x - x0) - f')"
>     (is "\<forall>\<^sub>F x in _. ?th x")
>     unfolding eventually_at_filter
>   proof (safe intro!: eventuallyI)
>     fix x assume x: "x \<noteq> x0"
>     then have "norm ((f x - f x0) /\<^sub>R (x - x0) - f') = norm (sgn (x - x0) *\<^sub>R ((f x - f x0) /\<^sub>R (x - x0) - f'))"
>       by simp
>     also have "sgn (x - x0) *\<^sub>R ((f x - f x0) /\<^sub>R (x - x0) - f') = ((f x - f x0) /\<^sub>R norm (x - x0) - (x - x0) *\<^sub>R f' /\<^sub>R norm (x - x0))"
>       by (auto simp add: algebra_simps sgn_div_norm divide_simps)
>         (metis add.commute add_divide_distrib diff_add_cancel scaleR_add_left)
>     also have "\<dots> = (f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0)" by (simp add: algebra_simps)
>     finally show "?th x" ..
>   qed
>   show "((\<lambda>x. norm ((f x - f x0 - (x - x0) *\<^sub>R f') /\<^sub>R norm (x - x0))) \<longlongrightarrow> 0) (at x0 within S)"
>     by (rule tendsto_norm_zero)
>       (use assms in \<open>auto simp: has_vector_derivative_def has_derivative_at_within\<close>)
> qed
> 
> text \<open>A \<open>path_connected\<close> set \<open>S\<close> entering both \<open>T\<close> and \<open>-T\<close>
>       must cross the frontier of \<open>T\<close> \<close>
> lemma path_connected_frontier:
>   fixes S :: "'a::real_normed_vector set"
>   assumes "path_connected S"
>   assumes "S \<inter> T \<noteq> {}"
>   assumes "S \<inter> -T \<noteq> {}"
>   obtains s where "s \<in> S" "s \<in> frontier T"
> proof -
>   obtain st where st:"st \<in> S \<inter> T" using assms(2) by blast
>   obtain sn where sn:"sn \<in> S \<inter> -T" using assms(3) by blast
>   obtain g where g: "path g" "path_image g \<subseteq> S"
>     "pathstart g = st" "pathfinish g = sn"
>     using assms(1) st sn unfolding path_connected_def by blast
>   have a1:"pathstart g \<in> closure T" using st g(3) closure_Un_frontier by fastforce
>   have a2:"pathfinish g \<notin> T" using sn g(4) by auto
>   from exists_path_subpath_to_frontier[OF g(1) a1 a2]
>   obtain h where "path_image h \<subseteq> path_image g" "pathfinish h \<in> frontier T" by metis
>   thus ?thesis using g(2)
>     by (meson in_mono pathfinish_in_path_image that) 
> qed
> 
> lemma path_connected_not_frontier_subset:
>   fixes S :: "'a::real_normed_vector set"
>   assumes "path_connected S"
>   assumes "S \<inter> T \<noteq> {}"
>   assumes "S \<inter> frontier T = {}"
>   shows "S \<subseteq> T"
>   using path_connected_frontier assms by auto  
> 
> lemma compact_attains_bounds:
>   fixes f::"'a::topological_space \<Rightarrow> 'b::linorder_topology"
>   assumes compact: "compact S"
>   assumes ne: "S \<noteq> {}"
>   assumes cont: "continuous_on S f"
>   obtains l u where "l \<in> S" "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<in> {f l .. f u}"
> proof -
>   from compact_continuous_image[OF cont compact]
>   have compact_image: "compact (f ` S)" .
>   have ne_image: "f ` S \<noteq> {}" using ne by simp
>   from compact_attains_inf[OF compact_image ne_image]
>   obtain l where "l \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f l \<le> f x" by auto
>   moreover
>   from compact_attains_sup[OF compact_image ne_image]
>   obtain u where "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<le> f u" by auto
>   ultimately
>   have "l \<in> S" "u \<in> S" "\<And>x. x \<in> S \<Longrightarrow> f x \<in> {f l .. f u}" by auto
>   then show ?thesis ..
> qed
> 
> lemma uniform_limit_const[uniform_limit_intros]:
>   "uniform_limit S (\<lambda>x y. f x) (\<lambda>_. l) F" if "(f \<longlongrightarrow> l) F"
>   apply (auto simp: uniform_limit_iff)
>   subgoal for e
>     using tendstoD[OF that(1), of e]
>     by (auto simp: eventually_mono)
>   done
> 
> subsection \<open>Segments\<close>
> 
> text \<open>\<open>closed_segment\<close> throws away the order that our intuition keeps\<close>
> 
> definition line::"'a::real_vector \<Rightarrow> 'a \<Rightarrow> real \<Rightarrow> 'a"
>   ("{_ -- _}\<^bsub>_\<^esub>")
>   where "{a -- b}\<^bsub>u\<^esub> = a + u *\<^sub>R (b - a)"
> 
> abbreviation "line_image a b U \<equiv>(\<lambda>u. {a -- b}\<^bsub>u\<^esub>) ` U"
> notation line_image ("{_ -- _}\<^bsub>`_\<^esub>")
> 
> lemma in_closed_segment_iff_line: "x \<in> {a -- b} \<longleftrightarrow> (\<exists>c\<in>{0..1}. x = line a b c)"
>   by (auto simp: in_segment line_def algebra_simps)
> 
> lemma in_open_segment_iff_line: "x \<in> {a <--< b} \<longleftrightarrow> (\<exists>c\<in>{0<..<1}. a \<noteq> b \<and> x = line a b c)"
>   by (auto simp: in_segment line_def algebra_simps)
> 
> lemma line_convex_combination1: "(1 - u) *\<^sub>R line a b i + u *\<^sub>R b = line a b (i + u - i * u)"
>   by (auto simp: line_def algebra_simps)
> 
> lemma line_convex_combination2: "(1 - u) *\<^sub>R a + u *\<^sub>R line a b i = line a b (i*u)"
>   by (auto simp: line_def algebra_simps)
> 
> lemma line_convex_combination12: "(1 - u) *\<^sub>R line a b i + u *\<^sub>R line a b j = line a b (i + u * (j - i))"
>   by (auto simp: line_def algebra_simps)
> 
> lemma mult_less_one_less_self: "0 < x \<Longrightarrow> i < 1 \<Longrightarrow> i * x < x" for i x::real
>   by auto
> 
> lemma plus_times_le_one_lemma: "i + u - i * u \<le> 1" if "i \<le> 1" "u \<le> 1" for i u::real
>   by (simp add: diff_le_eq sum_le_prod1 that)
> 
> lemma plus_times_less_one_lemma: "i + u - i * u < 1" if "i < 1" "u < 1" for i u::real
> proof -
>   have "u * (1 - i) < 1 - i"
>     using that by force
>   then show ?thesis by (simp add: algebra_simps)
> qed
> 
> lemma line_eq_endpoint_iff[simp]:
>   "line a b i = b \<longleftrightarrow> (a = b \<or> i = 1)"
>   "a = line a b i \<longleftrightarrow> (a = b \<or> i = 0)"
>   by (auto simp: line_def algebra_simps)
> 
> lemma line_eq_iff[simp]: "line a b x = line a b y \<longleftrightarrow> (x = y \<or> a = b)"
>   by (auto simp: line_def)
> 
> lemma line_open_segment_iff:
>   "{line a b i<--<b} = line a b ` {i<..<1}"
>   if "i < 1" "a \<noteq> b"
>   using that
>   apply (auto simp: in_segment line_convex_combination1 plus_times_less_one_lemma)
>   subgoal for j
>     apply (rule exI[where x="(j - i)/(1 - i)"])
>     apply (auto simp: divide_simps algebra_simps)
>     by (metis add_diff_cancel less_numeral_extra(4) mult_2_right plus_times_less_one_lemma that(1))
>   done
> 
> lemma open_segment_line_iff:
>   "{a<--<line a b i} = line a b ` {0<..<i}"
>   if "0 < i" "a \<noteq> b"
>   using that
>   apply (auto simp: in_segment line_convex_combination2 plus_times_less_one_lemma)
>   subgoal for j
>     apply (rule exI[where x="j/i"])
>     by (auto simp: )
>   done
> 
> lemma line_closed_segment_iff:
>   "{line a b i--b} = line a b ` {i..1}"
>   if "i \<le> 1" "a \<noteq> b"
>   using that
>   apply (auto simp: in_segment line_convex_combination1 mult_le_cancel_right2 plus_times_le_one_lemma)
>   subgoal for j
>     apply (rule exI[where x="(j - i)/(1 - i)"])
>     apply (auto simp: divide_simps algebra_simps)
>     by (metis add_diff_cancel less_numeral_extra(4) mult_2_right plus_times_less_one_lemma that(1))
>   done
> 
> lemma closed_segment_line_iff:
>   "{a--line a b i} = line a b ` {0..i}"
>   if "0 < i" "a \<noteq> b"
>   using that
>   apply (auto simp: in_segment line_convex_combination2 plus_times_less_one_lemma)
>   subgoal for j
>     apply (rule exI[where x="j/i"])
>     by (auto simp: )
>   done
> 
> lemma closed_segment_line_line_iff: "{line a b i1--line a b i2} = line a b ` {i1..i2}" if "i1 \<le> i2"
>   using that
>   apply (auto simp: in_segment line_convex_combination12 intro!: imageI)
>    apply (smt mult_left_le_one_le)
>   subgoal for u
>     by (rule exI[where x="(u - i1)/(i2-i1)"]) auto
>   done
> 
> lemma line_line1: "line (line a b c) b x = line a b (c + x - c * x)"
>   by (simp add: line_def algebra_simps)
> 
> lemma line_line2: "line a (line a b c) x = line a b (c*x)"
>   by (simp add: line_def algebra_simps)
> 
> lemma line_in_subsegment:
>   "i1 < 1 \<Longrightarrow> i2 < 1 \<Longrightarrow> a \<noteq> b \<Longrightarrow> line a b i1 \<in> {line a b i2<--<b} \<longleftrightarrow> i2 < i1"
>   by (auto simp: line_open_segment_iff intro!: imageI)
> 
> lemma line_in_subsegment2:
>   "0 < i2 \<Longrightarrow> 0 < i1 \<Longrightarrow> a \<noteq> b \<Longrightarrow> line a b i1 \<in> {a<--<line a b i2} \<longleftrightarrow> i1 < i2"
>   by (auto simp: open_segment_line_iff intro!: imageI)
> 
> lemma line_in_open_segment_iff[simp]:
>   "line a b i \<in> {a<--<b} \<longleftrightarrow> (a \<noteq> b \<and> 0 < i \<and> i < 1)"
>   by (auto simp: in_open_segment_iff_line)
> 
> subsection \<open>Open Segments\<close>
> 
> lemma open_segment_subsegment:
>   assumes "x1 \<in> {x0<--<x3}"
>     "x2 \<in> {x1<--<x3}"
>   shows "x1 \<in> {x0<--<x2}"
>   using assms
> proof -\<comment> \<open>TODO: use \<open>line\<close>\<close>
>   from assms obtain u v::real where
>     ne: "x0 \<noteq> x3" "(1 - u) *\<^sub>R x0 + u *\<^sub>R x3 \<noteq> x3"
>     and x1_def: "x1 = (1 - u) *\<^sub>R x0 + u *\<^sub>R x3"
>     and x2_def: "x2 = (1 - v) *\<^sub>R ((1 - u) *\<^sub>R x0 + u *\<^sub>R x3) + v *\<^sub>R x3"
>     and uv: \<open>0 < u\<close> \<open>0 < v\<close> \<open>u < 1\<close> \<open>v < 1\<close>
>     by (auto simp: in_segment)
>   let ?d = "(u + v - u * v)"
>   have "?d > 0" using uv
>     by (auto simp: add_nonneg_pos pos_add_strict)
>   with \<open>x0 \<noteq> x3\<close> have "0 \<noteq> ?d *\<^sub>R (x3 - x0)" by simp
>   moreover
>   define ua where "ua = u / ?d"
>   have "ua * (u * v - u - v) - - u = 0"
>     by (auto simp: ua_def algebra_simps divide_simps)
>       (metis uv add_less_same_cancel1 add_strict_mono mult.right_neutral
>         mult_less_cancel_left_pos not_real_square_gt_zero vector_space_over_itself.scale_zero_left)
>   then have "(ua * (u * v - u - v) - - u) *\<^sub>R (x3 - x0) = 0"
>     by simp
>   moreover
>   have "0 < ua" "ua < 1"
>     using \<open>0 < u\<close> \<open>0 < v\<close> \<open>u < 1\<close> \<open>v < 1\<close>
>     by (auto simp: ua_def pos_add_strict intro!: divide_pos_pos)
>   ultimately show ?thesis
>     unfolding x1_def x2_def
>     by (auto intro!: exI[where x=ua] simp: algebra_simps in_segment)
> qed
> 
> 
> subsection \<open>Syntax\<close>
> 
> abbreviation sequentially_at_top::"(nat\<Rightarrow>real)\<Rightarrow>bool"
>   ("_ \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>") \<comment> \<open>the \<open>\<^bsub>\<^esub>\<close> is to disambiguate syntax...\<close>
>   where "s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>  \<equiv> filterlim s at_top sequentially"
> 
> abbreviation sequentially_at_bot::"(nat\<Rightarrow>real)\<Rightarrow>bool"
>   ("_ \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>")
>   where "s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>  \<equiv> filterlim s at_bot sequentially"
> 
> 
> subsection \<open>Paths\<close>
> 
> lemma subpath0_linepath:
>   shows "subpath 0 u (linepath t t') = linepath t (t + u * (t' - t))"
>   unfolding subpath_def linepath_def
>   apply (rule ext)
>   apply auto
> proof -
>   fix x :: real
>   have f1: "\<And>r ra rb rc. (r::real) + ra * rb - ra * rc = r - ra * (rc - rb)"
>     by (simp add: right_diff_distrib')
>   have f2: "\<And>r ra. (r::real) - r * ra = r * (1 - ra)"
>     by (simp add: right_diff_distrib')
>   have f3: "\<And>r ra rb. (r::real) - ra + rb + ra - r = rb"
>     by auto
>   have f4: "\<And>r. (r::real) + (1 - 1) = r"
>     by linarith
>   have f5: "\<And>r ra. (r::real) + ra = ra + r"
>     by force
>   have f6: "\<And>r ra. (r::real) + (1 - (r + 1) + ra) = ra"
>     by linarith
>   have "t - x * (t - (t + u * (t' - t))) = t' * (u * x) + (t - t * (u * x))"
>     by (simp add: right_diff_distrib')
>   then show "(1 - u * x) * t + u * x * t' = (1 - x) * t + x * (t + u * (t' - t))"
>     using f6 f5 f4 f3 f2 f1 by (metis (no_types) mult.commute)
> qed
> 
> lemma linepath_image0_right_open_real:
>   assumes "t < (t'::real)"
>   shows "linepath t t' ` {0..<1} = {t..<t'}"
>   unfolding linepath_def
>   apply auto
>     apply (metis add.commute add_diff_cancel_left' assms diff_diff_eq2 diff_le_eq less_eq_real_def mult.commute mult.right_neutral mult_right_mono right_diff_distrib')
>    apply (smt assms comm_semiring_class.distrib mult_diff_mult semiring_normalization_rules(2) zero_le_mult_iff)
> proof -
>   fix x
>   assume "t \<le> x" "x < t'"
>   let ?u = "(x-t)/(t'-t)"
>   have "?u \<ge> 0"
>     using \<open>t \<le> x\<close> assms by auto
>   moreover have "?u < 1"
>     by (simp add: \<open>x < t'\<close> assms)
>   moreover have "x = (1-?u) * t + ?u*t'"
>   proof -
>     have f1: "\<forall>r ra. (ra::real) * - r = r * - ra"
>       by simp
>     have "t + (t' + - t) * ((x + - t) / (t' + - t)) = x"
>       using assms by force
>     then have "t' * ((x + - t) / (t' + - t)) + t * (1 + - ((x + - t) / (t' + - t))) = x"
>       using f1 by (metis (no_types) add.left_commute distrib_left mult.commute mult.right_neutral)
>     then show ?thesis
>       by (simp add: mult.commute)
>   qed
>   ultimately show "x \<in> (\<lambda>x. (1 - x) * t + x * t') ` {0..<1}"
>     using atLeastLessThan_iff by blast 
> qed
> 
> lemma oriented_subsegment_scale:
>   assumes "x1 \<in> {a<--<b}"
>   assumes "x2 \<in> {x1<--<b}"
>   obtains e where "e > 0" "b-a = e *\<^sub>R (x2-x1)"
> proof -
>   from assms(1) obtain u where u : "u > 0" "u < 1" "x1 = (1 - u) *\<^sub>R a + u *\<^sub>R b"
>     unfolding in_segment by blast
>   from assms(2) obtain v where v: "v > 0" "v < 1" "x2 = (1 - v) *\<^sub>R x1 + v *\<^sub>R b"
>     unfolding in_segment by blast
>   have "x2-x1 = -v *\<^sub>R x1 + v *\<^sub>R b" using v
>     by (metis add.commute add_diff_cancel_right diff_minus_eq_add scaleR_collapse scaleR_left.minus)
>   also have "... = (-v) *\<^sub>R ((1 - u) *\<^sub>R a + u *\<^sub>R b)  + v *\<^sub>R b" using u by auto
>   also have "... = v *\<^sub>R ((1-u)*\<^sub>R b - (1-u)*\<^sub>R a )"
>     by (smt add_diff_cancel diff_diff_add diff_minus_eq_add minus_diff_eq scaleR_collapse scale_minus_left scale_right_diff_distrib)
>   finally have x2x1:"x2-x1 = (v *(1-u)) *\<^sub>R (b - a)"
>     by (metis scaleR_scaleR scale_right_diff_distrib)
>   have "v * (1-u) > 0"  using u(2) v(1) by simp
>   then have "(x2-x1)/\<^sub>R (v * (1-u)) = (b-a)" unfolding x2x1
>     by (smt field_class.field_inverse scaleR_one scaleR_scaleR) 
>   thus ?thesis
>     using \<open>0 < v * (1 - u)\<close> positive_imp_inverse_positive that by fastforce
> qed
> 
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Examples.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Examples.thy
1,461c1,461
< section \<open>Examples\<close>
< theory Examples
<   imports Poincare_Bendixson
<     "HOL-ODE-Numerics.ODE_Numerics"
<     Affine_Arithmetic_Misc
< begin
< 
< subsection \<open>Simple\<close>
< 
< context
< begin
< 
< text \<open>coordinate functions\<close>
< definition "cx x y = -y + x * (1 - x^2 - y^2)"
< definition "cy x y = x + y * (1 - x^2 - y^2)"
< 
< lemmas c_defs = cx_def cy_def
< 
< text \<open>partial derivatives\<close>
< definition C11::"real\<Rightarrow>real\<Rightarrow>real" where "C11 x y = 1 - 3 * x^2 - y^2"
< definition C12::"real\<Rightarrow>real\<Rightarrow>real" where "C12 x y = -1 - 2 * x * y"
< definition C21::"real\<Rightarrow>real\<Rightarrow>real" where "C21 x y = 1 - 2 * x * y"
< definition C22::"real\<Rightarrow>real\<Rightarrow>real" where "C22 x y = 1 - x^2 - 3 * y^2"
< 
< lemmas C_partials = C11_def C12_def C21_def C22_def
< 
< text \<open>Jacobian as linear map\<close>
< definition C :: "real \<Rightarrow> real \<Rightarrow> (real \<times> real) \<Rightarrow>\<^sub>L (real \<times> real)" where
<   "C x y = blinfun_of_matrix
<     ((\<lambda>_ _. 0)
<       ((1,0) := (\<lambda>_. 0)((1, 0):=C11 x y, (0, 1):=C12 x y),
<        (0, 1):= (\<lambda>_. 0)((1, 0):=C21 x y, (0, 1):=C22 x y)))"
< 
< lemma C_simp[simp]: "blinfun_apply (C x y) (dx, dy) =
<   (dx * C11 x y + dy * C12 x y,
<    dx * C21 x y + dy * C22 x y)"
<   by (auto simp: C_def blinfun_of_matrix_apply Basis_prod_def)
< 
< lemma C_continuous[continuous_intros]:
<   "continuous_on S (\<lambda>x. local.C (f x) (g x))"
<   if "continuous_on S f" "continuous_on S g"
<   unfolding C_def
<   by (auto intro!: continuous_on_blinfun_of_matrix continuous_intros that
<       simp: Basis_prod_def C_partials)
< 
< interpretation c: c1_on_open_R2 "\<lambda>(x::real, y::real). (cx x y, cy x y)::real*real"
<   "\<lambda>(x, y). C x y" UNIV
<   by unfold_locales
<     (auto intro!: derivative_eq_intros ext continuous_intros simp: split_beta algebra_simps
<       c_defs C_partials power2_eq_square)
< 
< definition "trapC = cball (0::real,0::real) 2 - ball (0::real,0::real) (1/2)"
< 
< lemma trapC_eq:
<   shows "trapC = {p. (fst p)^2 + (snd p)^2 - 4 \<le> 0} \<inter> {p. 1/4 - ((fst p)^2 + (snd p)^2) \<le> 0}"
<   unfolding trapC_def
<   apply (auto simp add: dist_Pair_Pair)
<   using real_sqrt_le_iff apply fastforce
<     apply (smt four_x_squared one_le_power real_sqrt_ge_0_iff real_sqrt_pow2)
<   using real_sqrt_le_mono apply fastforce
< proof -
<   fix a :: real and b :: real
<   assume a1: "sqrt (a\<^sup>2 + b\<^sup>2) * 2 < 1"
<   assume a2: "1 \<le> a\<^sup>2 * 4 + b\<^sup>2 * 4"
<   have "\<forall>r. 1 \<le> sqrt r \<or> \<not> 1 \<le> r"
<     by simp
<   then show False
<     using a2 a1 by (metis (no_types) Groups.mult_ac(2) distrib_left linorder_not_le real_sqrt_four real_sqrt_mult)
< qed
< 
< lemma x_in_trapC:
<   shows "(2,0) \<in> trapC"
<   unfolding trapC_def
<   by (auto simp add: dist_Pair_Pair)
< 
< lemma compact_trapC:
<   shows "compact trapC"
<   unfolding trapC_def
<   using compact_cball compact_diff by blast
< 
< lemma nonempty_trapC:
<   shows "trapC \<noteq> {}"
<   using x_in_trapC by auto
< 
< lemma origin_fixpoint:
<   assumes "(\<lambda>(x, y). (cx x y, cy x y)) (a,b) = 0"
<   shows "a = (0::real)" "b = (0::real)"
<   using assms unfolding cx_def cy_def zero_prod_def apply auto
<   apply (sos "((((A<0 * R<1) + (([28859/65536*a + 5089/8192*b + ~1/2] * A=0) + (([~5089/8192*a + 17219/65536*b + ~1/2] * A=1) + (R<1 * ((R<11853/65536 * [~16384/11853*a^2 + ~11585/11853*b^2 + 302/1317*a*b + a + 1940/3951*b]^2) + ((R<73630271/776798208 * [a^2 + 64177444/73630271*b^2 + 44531712/73630271*a*b + ~131061126/73630271*b]^2) + ((R<70211653911/4825433440256 * [~77895776116/70211653911*b^2 + 5825642465/10030236273*a*b + b]^2) + ((R<48375415273/657341564387328 * [~36776393918/48375415273*b^2 + a*b]^2) + (R<18852430195/11096159253659648 * [b^2]^2)))))))))) & (((A<0 * (A<0 * R<1)) + (([b] * A=0) + (([~1*a] * A=1) + (R<1 * (R<1 * [b]^2)))))))")
< proof -
<   assume a1: "a * (1 - a\<^sup>2 - b\<^sup>2) = b"
<   assume a2: "a + b * (1 - a\<^sup>2 - b\<^sup>2) = 0"
<   have f3: "\<forall>r ra. - (ra::real) * r = ra * - r"
<     by simp
<   have "- b * (1 - a\<^sup>2 - b\<^sup>2) = a"
<     using a2 by simp
<   then have "\<exists>r ra. b * b - ra * (r * (ra * - r)) = 0"
<     using f3 a1 by (metis (no_types) c.vec_simps(15) right_minus_eq)
<   then have "\<exists>r. b * b - r * - r = 0"
<     using f3 by (metis (no_types) c.vec_simps(14))
<   then show "b = 0"
<     by simp
< qed
< 
< lemma origin_not_trapC:
<   shows "0 \<notin> trapC"
<   unfolding trapC_def zero_prod_def 
<   by auto
< 
< lemma regular_trapC:
<   shows "0 \<notin> (\<lambda>(x, y). (cx x y, cy x y)) ` trapC"
<   using origin_fixpoint origin_not_trapC
<   by (smt UNIV_I UNIV_I UNIV_def case_prodE2 imageE c.flow_initial_time_if
<       c.rev.flow_initial_time_if mem_Collect_eq zero_prod_def)
< 
< lemma positively_invariant_outer:
<   shows "c.positively_invariant  {p. (\<lambda>p. (fst p)\<^sup>2 + (snd p)\<^sup>2 - 4) p \<le> 0}"
<   apply (rule c.positively_invariant_le[of "\<lambda>p.-2*((fst p)^2+(snd p)^2)" _  "\<lambda>x p. 2 * fst x * fst p + 2 * snd x * snd p" ])
<     apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding cx_def cy_def
<   by (sos "(((A<0 * R<1) + (R<1 * ((R<6 * [a]^2) + (R<6 * [b]^2)))))")
< 
< 
< lemma positively_invariant_inner:
<   shows "c.positively_invariant  {p. (\<lambda>p. 1/4 - ((fst p)\<^sup>2 + (snd p)\<^sup>2)) p \<le> 0}"
<   apply (rule c.positively_invariant_le[of "\<lambda>p.-2*((fst p)^2+(snd p)^2)" _ "\<lambda>x p. - 2 * fst x * fst p - 2 * snd x * snd p"])
<     apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding cx_def cy_def
<   by (sos "(((A<0 * R<1) + (R<1 * ((R<3/2 * [a]^2) + (R<3/2 * [b]^2)))))")
< 
< lemma positively_invariant_trapC:
<   shows "c.positively_invariant trapC"
<   unfolding trapC_eq
<   apply (rule c.positively_invariant_conj)
<   using positively_invariant_outer
<    apply (metis (no_types, lifting) Collect_cong case_prodE case_prodI2 case_prod_conv)
<   using positively_invariant_inner
<   by (metis (no_types, lifting) Collect_cong case_prodE case_prodI2 case_prod_conv)
< 
< theorem c_has_periodic_orbit:
<   obtains y where "c.periodic_orbit y" "c.flow0 y ` UNIV \<subseteq> trapC"
< proof -
<   from c.poincare_bendixson_applied[OF compact_trapC _ nonempty_trapC positively_invariant_trapC regular_trapC]
<   show ?thesis using that by blast
< qed
< 
< text \<open>Real-Arithmetic\<close>
< schematic_goal c_fas:
<   "[-(-(X!1) + (X!0) * (1 - (X!0)^2 - (X!1)^2)), -((X!0) + (X!1) * (1 - (X!0)^2 - (X!1)^2))] = interpret_floatariths ?fas X"
<   by (reify_floatariths)
< 
< concrete_definition c_fas uses c_fas
< 
< interpretation crev: ode_interpretation true_form UNIV c_fas
<   "-(\<lambda>(x, y). (cx x y, cy x y)::real*real)"
<   "d::2" for d
<   by unfold_locales (auto simp: c_fas_def less_Suc_eq_0_disj nth_Basis_list_prod Basis_list_real_def
<       cx_def cy_def eval_nat_numeral
<       mk_ode_ops_def eucl_of_list_prod power2_eq_square intro!: isFDERIV_I)
< 
< lemma crev: "t \<in> {1/8 .. 1/8} \<longrightarrow> (x, y) \<in> {(2, 0) .. (2, 0)} \<longrightarrow>
<    t \<in> c.rev.existence_ivl0 (x, y) \<and> c.rev.flow0 (x, y) t \<in> {(5.15, -0.651)..(5.18, -0.647)}"
<   by (tactic \<open>ode_bnds_tac @{thms c_fas_def} 30 20 7 12 [(0, 1, "0x000000")] (* "crev.out" *) "" @{context} 1\<close>)
< 
< theorem c_has_limit_cycle:
<   obtains y where "c.limit_cycle y" "range (c.flow0 y) \<subseteq> trapC"
< proof -
<   define E where "E = {(5.15, -0.651)..(5.18, -0.647)::real*real}"
<   from crev have "c.rev.flow0 (2, 0) (1/8) \<in> E"
<     by (auto simp: E_def)
<   moreover
<   have "E \<inter> trapC = {}"
<   proof -
<     have "norm x > 2" if "x \<in> E" for x
<       using that
<       apply (auto simp: norm_prod_def less_eq_prod_def E_def)
<       by (smt power2_less_eq_zero_iff real_less_rsqrt zero_compare_simps(9))
<     moreover have "norm x \<le> 2" if "x \<in> trapC" for x
<       using that
<       by (auto simp: trapC_def dist_prod_def norm_prod_def)
<     ultimately show ?thesis by force
<   qed
<   ultimately have "c.rev.flow0 (2, 0) (1 / 8) \<notin> trapC" by blast
<   from c.poincare_bendixson_limit_cycle[OF compact_trapC subset_UNIV x_in_trapC positively_invariant_trapC regular_trapC this] that
<   show ?thesis by blast
< qed
< 
< end
< 
< 
< subsection \<open>Glycolysis\<close>
< 
< text \<open>Strogatz, Example 7.3.2\<close>
< 
< context
< begin
< 
< text \<open>coordinate functions\<close>
< definition "gx x y = -x + 0.08 * y + x\<^sup>2 * y"
< definition "gy x y = 0.6 - 0.08 * y - x\<^sup>2 * y"
< 
< lemmas g_defs = gx_def gy_def
< 
< text \<open>partial derivatives\<close>
< definition A11::"real\<Rightarrow>real\<Rightarrow>real" where "A11 x y = -1 + 2 * x * y"
< definition A12::"real\<Rightarrow>real\<Rightarrow>real" where "A12 x y = (0.08 + x\<^sup>2)"
< definition A21::"real\<Rightarrow>real\<Rightarrow>real" where "A21 x y = -2*x*y"
< definition A22::"real\<Rightarrow>real\<Rightarrow>real" where "A22 x y = -(0.08 + x\<^sup>2)"
< 
< lemmas A_partials = A11_def A12_def A21_def A22_def
< 
< text \<open>Jacobian as linear map\<close>
< definition A :: "real \<Rightarrow> real \<Rightarrow> (real \<times> real) \<Rightarrow>\<^sub>L (real \<times> real)" where
<   "A x y = blinfun_of_matrix
<     ((\<lambda>_ _. 0)
<       ((1,0) := (\<lambda>_. 0)((1, 0):=A11 x y, (0, 1):=A12 x y),
<        (0, 1):= (\<lambda>_. 0)((1, 0):=A21 x y, (0, 1):=A22 x y)))"
< 
< lemma A_simp[simp]: "blinfun_apply (A x y) (dx, dy) =
<   (dx * A11 x y + dy * A12 x y,
<    dx * A21 x y + dy * A22 x y)"
<   by (auto simp: A_def blinfun_of_matrix_apply Basis_prod_def)
< 
< lemma A_continuous[continuous_intros]:
<   "continuous_on S (\<lambda>x. local.A (f x) (g x))"
<   if "continuous_on S f" "continuous_on S g"
<   unfolding A_def
<   by (auto intro!: continuous_on_blinfun_of_matrix continuous_intros that
<       simp: Basis_prod_def A_partials)
< 
< interpretation g: c1_on_open_R2 "\<lambda>(x::real, y::real). (gx x y, gy x y)::real*real"
<   "\<lambda>(x, y). A x y" UNIV
<   by unfold_locales
<     (auto intro!: derivative_eq_intros ext continuous_intros simp: split_beta algebra_simps
<       g_defs A_partials)
< 
< (*
<   The outer invariant is the convex set formed by the axes, y \<le> 7.51, and x+y\<le>8.12
< *)
< definition "(pos_quad::(real \<times> real) set) =  {p . - snd p \<le> 0} \<inter> {p . - fst p \<le> 0}"
< 
< definition "(trapG1::(real \<times> real) set) = pos_quad \<inter> ({p. (snd p) - 751/100 \<le> 0} \<inter> {p. (fst p) + (snd p) - 812/100 \<le> 0})"
< 
< lemma positively_invariant_y:
<   shows "g.positively_invariant {p . - snd p \<le> 0}"
<   apply (rule g.positively_invariant_le[of "\<lambda>p. -(0.08 + (fst p)^2)" _ "\<lambda>x p. - snd p"])
<     apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding gy_def
<   by (sos "()")
< 
< lemma positively_invariant_pos_quad:
<   shows "g.positively_invariant pos_quad"
<   unfolding pos_quad_def
<   apply (rule g.positively_invariant_le_domain[OF positively_invariant_y, of "\<lambda>p. fst p * snd p -1"])
<     apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding gx_def
<   by (sos "(((A<0 * R<1) + (((A<0 * R<1) * (R<11/14 * [1]^2)) + ((A<=0 * R<1) * (R<1/7 * [1]^2)))))")
< 
< lemma positively_invariant_y_upper:
<   shows "g.positively_invariant {p. (snd p) - 751/100 \<le> 0}"
<   apply (rule g.positively_invariant_barrier)
<     apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding gy_def
<   by (sos "((R<1 + ((R<1 * (R<18775/2 * [a]^2)) + ((A<=0 * R<1) * (R<1250 * [1]^2)))))")
< 
< lemma arith2:
<   shows "(y::real) \<le> 751/100 \<and> x + (y::real) = 812/100 \<Longrightarrow> 3/5 - (x::real) < 0"
<   by linarith
< 
< lemma positively_invariant_trapG1:
<   shows "g.positively_invariant trapG1"
<   unfolding trapG1_def
<   apply (rule g.positively_invariant_conj[OF positively_invariant_pos_quad])
<   apply (rule g.positively_invariant_barrier_domain[OF positively_invariant_y_upper])
<   apply (auto intro!: continuous_intros derivative_eq_intros)
<   unfolding gx_def gy_def by auto
< 
< (* Polynomial in invariant *)
< definition "p1 (x::real) (y::real) = -(21/34) - (69*x)/38 + (19*x^2)/15 - (9*x^3)/28 - (6*x^4)/43 + ( 14*y)/29 + (31*x*y)/21 + (182*x^2*y)/47 - (35*x^3*y)/16 - ( 3*y^2)/17 - (2*x*y^2)/9 - (31*x^2*y^2)/20 +y^3/102 + (x*y^3)/59"
< 
< definition "p1d x xa = 38 * (fst xa * fst x) / 15 - 69 * fst xa / 38 -
<           27 * (fst xa * (fst x)\<^sup>2) / 28 -
<           24 * (fst xa * fst x ^ 3) / 43 +
<           14 * snd xa / 29 +
<           (651 * (fst x * snd xa) +
<            651 * (fst xa * snd x)) /
<           441 +
<           (8554 * ((fst x)\<^sup>2 * snd xa) +
<            17108 * (fst xa * (fst x * snd x))) /
<           2209 -
<           (560 * (fst x ^ 3 * snd xa) +
<            1680 * (fst xa * ((fst x)\<^sup>2 * snd x))) /
<           256 -
<           6 * (snd xa * snd x) / 17 -
<           (36 * (fst x * (snd xa * snd x)) +
<            18 * (fst xa * (snd x)\<^sup>2)) /
<           81 -
<           (1240 * ((fst x)\<^sup>2 * (snd xa * snd x)) +
<            1240 * (fst xa * (fst x * (snd x)\<^sup>2))) /
<           400 +
<           snd xa * (snd x)\<^sup>2 / 34 +
<           (177 * (fst x * (snd xa * (snd x)\<^sup>2)) +
<            fst xa * snd x ^ 3 * 59) /
<           3481"
< 
< lemma p1_has_derivative:
<   shows "((\<lambda>x. p1 (fst x) (snd x)) has_derivative p1d x) (at x)"
<   unfolding p1_def p1d_def
<   by (auto intro!: continuous_intros derivative_eq_intros)
< 
< (* p1 excludes equilibria for free *)
< lemma p1_not_equil:
<   shows " p1 x y \<le> 0 \<Longrightarrow> gx x y \<noteq> 0 \<or> gy x y \<noteq> 0"
<   unfolding gx_def gy_def p1_def
<   by (sos "()")
< 
< definition "trapG = trapG1 \<inter> {p. p1 (fst p) (snd p) \<le> 0}"
< 
< text \<open>Real-Arithmetic\<close>
< definition "g_arith a b = (- (27 / 25) - a\<^sup>2 + 2 * a * b) * p1 a b - p1d (a, b) (gx a b, gy a b)"
< 
< schematic_goal g_arith_fas:
<   "[g_arith (X!0) (X!1)] = interpret_floatariths ?fas X"
<   unfolding g_arith_def p1_def p1d_def gx_def gy_def fst_conv snd_conv
<   by (reify_floatariths)
< 
< concrete_definition g_arith_fas uses g_arith_fas
< 
< lemma list_interval2: "list_interval [a, b] [c, d] = {[x, y] | x y. x \<in> {a .. c} \<and> y \<in> {b .. d}}"
<   apply (auto simp: list_interval_def)
<   subgoal for x
<     apply (cases x)
<     apply auto
<     subgoal for y zs
<       apply (cases zs)
<       by auto
<     done
<   done
< 
< lemma g_arith_nonneg: "g_arith a b \<ge> 0"
<   if a: "0 \<le> a" "a \<le> 8.24" and b: "0 \<le> b" "b \<le> 7.51"
< proof -
<   have "prove_nonneg [(0, 1, ''0x000000'')] 1000000 30 (slp_of_fas [hd g_arith_fas]) [aforms_of_ivls [0, 0]
<     [float_divr 30 824 100, float_divr 30 751 100]]"
<     by eval\<comment> \<open>slow: 60s\<close>
<   from prove_nonneg[OF this]
<   have "0 \<le> interpret_floatarith (hd g_arith_fas) [a, b]"
<     apply (auto simp: g_arith_fas)
<     apply (subst (asm) Joints_aforms_of_ivls)
<      apply (auto )
<       apply (smt divide_nonneg_nonneg float_divr float_numeral rel_simps(27))
<      apply (smt divide_nonneg_nonneg float_divr float_numeral rel_simps(27))
<     apply (subst (asm) list_interval2)
<     apply auto
<     apply (drule spec[where x="[a, b]"])
<     using a b
<     apply auto
<     subgoal by (rule order_trans[OF _ float_divr]) simp
<     subgoal by (rule order_trans[OF _ float_divr]) simp
<     done
<   also have "\<dots> = g_arith a b"
<     by (auto simp: g_arith_fas_def g_arith_def p1_def p1d_def gx_def gy_def)
<   finally show ?thesis .
< qed
< 
< lemma trap_arithmetic:
<   "p1d (a, b) (gx a b, gy a b) \<le> (- (27 / 25) - a\<^sup>2 + 2 * a * b) * p1 a b" if "(a, b) \<in> trapG1"
< proof -
<   from that
<   have b: "0 \<le> b" "b \<le> 7.51"
<     and a: "0 \<le> a" "a \<le> 8.24"
<     by (auto simp: trapG1_def pos_quad_def)
<   from g_arith_nonneg[OF a b] show ?thesis
<     by (simp add: g_arith_def)
< qed
< 
< lemma positively_invariant_trapG:
<   shows "g.positively_invariant trapG"
<   unfolding trapG_def
<   apply (rule g.positively_invariant_le_domain[OF positively_invariant_trapG1 _ p1_has_derivative,
<         of "\<lambda>p. -1.08 - (fst p)^2 + 2 * fst p * snd p"])
<   subgoal by (auto intro!: continuous_intros derivative_eq_intros simp add: pos_quad_def)
<   apply auto
<   by (rule trap_arithmetic)
< 
< lemma regular_trapG:
<   shows "0 \<notin> (\<lambda>(x, y). (gx x y, gy x y)) ` trapG"
<   unfolding trapG_def apply auto using p1_not_equil
<   by force
< 
< lemma arith:
<   "\<And>a b::real. 0 \<le> b \<Longrightarrow>
<            0 \<le> a \<Longrightarrow>
<            b * 100 \<le> 751 \<Longrightarrow>
<            a * 25 + b * 25 \<le> 203 \<Longrightarrow> norm a + norm b \<le> 20"
<   by auto
< 
< lemma trapG1_subset:
<   shows "trapG1 \<subseteq> cball (0::real \<times> real) 20"
<   unfolding trapG1_def pos_quad_def
<   apply auto
<   using arith norm_Pair_le
<   by smt
< 
< lemma compact_subset_closed:
<   assumes "compact S" "closed T"
<   assumes "T \<subseteq> S"
<   shows "compact T"
<   using compact_Int_closed[OF assms(1-2)] assms(3)
<   by (simp add: inf_absorb2)
< 
< lemma compact_trapG1:
<   shows "compact trapG1"
<   apply (auto intro!: compact_subset_closed[OF _ _ trapG1_subset])
<   unfolding trapG1_def pos_quad_def
<   by (auto intro!: closed_Collect_le continuous_intros)
< 
< lemma compact_trapG:
<   shows "compact trapG"
<   unfolding trapG_def
<   by (auto intro!: compact_Int_closed compact_trapG1 closed_Collect_le continuous_intros simp add: p1_def)
< 
< lemma x_in_trapG:
<   shows "(1,0) \<in> trapG"
<   unfolding trapG_def trapG1_def pos_quad_def p1_def
<   by (auto simp add: dist_Pair_Pair)
< 
< schematic_goal g_fas:
<   "[- (- (X!0) + 8 / 100 * (X!1) + (X!0)^2 * (X!1)),-( 6 / 10 - 8 / 100 * (X!1) - (X!0)^2 * (X!1))] = interpret_floatariths ?fas X"
<   by (reify_floatariths)
< 
< concrete_definition g_fas uses g_fas
< 
< interpretation grev: ode_interpretation true_form UNIV g_fas
<   "-(\<lambda>(x, y). (gx x y, gy x y)::real*real)"
<   "d::2" for d
<   by unfold_locales (auto simp: g_fas_def less_Suc_eq_0_disj nth_Basis_list_prod Basis_list_real_def
<       gx_def gy_def eval_nat_numeral
<       mk_ode_ops_def eucl_of_list_prod power2_eq_square intro!: isFDERIV_I)
< 
< lemma grev: "t \<in> {1/8 .. 1/8} \<longrightarrow> (x, y) \<in> {(1, 0) .. (1, 0)} \<longrightarrow>
<    t \<in> g.rev.existence_ivl0 (x, y) \<and> g.rev.flow0 (x, y) t \<in>
<     {(1.1, -0.09) .. (1.2, -0.08)}"
<   by (tactic \<open>ode_bnds_tac @{thms g_fas_def} 30 20 7 12 [(0, 1, "0x000000")] (* "grev.out" *) "" @{context} 1\<close>)
< 
< theorem g_has_limit_cycle:
<   obtains y where "g.limit_cycle y" "range (g.flow0 y) \<subseteq> trapG"
< proof -
<   define E::"(real*real) set" where "E = {(1.1, -0.09) .. (1.2, -0.08)}"
<   from grev have "g.rev.flow0 (1, 0) (1/8) \<in> E"
<     by (auto simp: E_def)
<   moreover
<   have "E \<inter> trapG = {}"
<     by (auto simp: trapG_def E_def trapG1_def pos_quad_def)
<   ultimately have "g.rev.flow0 (1, 0) (1 / 8) \<notin> trapG" by blast
<   from g.poincare_bendixson_limit_cycle[OF compact_trapG subset_UNIV x_in_trapG positively_invariant_trapG regular_trapG this] that
<   show ?thesis by blast
< qed
< 
< end
< 
---
> section \<open>Examples\<close>
> theory Examples
>   imports Poincare_Bendixson
>     "HOL-ODE-Numerics.ODE_Numerics"
>     Affine_Arithmetic_Misc
> begin
> 
> subsection \<open>Simple\<close>
> 
> context
> begin
> 
> text \<open>coordinate functions\<close>
> definition "cx x y = -y + x * (1 - x^2 - y^2)"
> definition "cy x y = x + y * (1 - x^2 - y^2)"
> 
> lemmas c_defs = cx_def cy_def
> 
> text \<open>partial derivatives\<close>
> definition C11::"real\<Rightarrow>real\<Rightarrow>real" where "C11 x y = 1 - 3 * x^2 - y^2"
> definition C12::"real\<Rightarrow>real\<Rightarrow>real" where "C12 x y = -1 - 2 * x * y"
> definition C21::"real\<Rightarrow>real\<Rightarrow>real" where "C21 x y = 1 - 2 * x * y"
> definition C22::"real\<Rightarrow>real\<Rightarrow>real" where "C22 x y = 1 - x^2 - 3 * y^2"
> 
> lemmas C_partials = C11_def C12_def C21_def C22_def
> 
> text \<open>Jacobian as linear map\<close>
> definition C :: "real \<Rightarrow> real \<Rightarrow> (real \<times> real) \<Rightarrow>\<^sub>L (real \<times> real)" where
>   "C x y = blinfun_of_matrix
>     ((\<lambda>_ _. 0)
>       ((1,0) := (\<lambda>_. 0)((1, 0):=C11 x y, (0, 1):=C12 x y),
>        (0, 1):= (\<lambda>_. 0)((1, 0):=C21 x y, (0, 1):=C22 x y)))"
> 
> lemma C_simp[simp]: "blinfun_apply (C x y) (dx, dy) =
>   (dx * C11 x y + dy * C12 x y,
>    dx * C21 x y + dy * C22 x y)"
>   by (auto simp: C_def blinfun_of_matrix_apply Basis_prod_def)
> 
> lemma C_continuous[continuous_intros]:
>   "continuous_on S (\<lambda>x. local.C (f x) (g x))"
>   if "continuous_on S f" "continuous_on S g"
>   unfolding C_def
>   by (auto intro!: continuous_on_blinfun_of_matrix continuous_intros that
>       simp: Basis_prod_def C_partials)
> 
> interpretation c: c1_on_open_R2 "\<lambda>(x::real, y::real). (cx x y, cy x y)::real*real"
>   "\<lambda>(x, y). C x y" UNIV
>   by unfold_locales
>     (auto intro!: derivative_eq_intros ext continuous_intros simp: split_beta algebra_simps
>       c_defs C_partials power2_eq_square)
> 
> definition "trapC = cball (0::real,0::real) 2 - ball (0::real,0::real) (1/2)"
> 
> lemma trapC_eq:
>   shows "trapC = {p. (fst p)^2 + (snd p)^2 - 4 \<le> 0} \<inter> {p. 1/4 - ((fst p)^2 + (snd p)^2) \<le> 0}"
>   unfolding trapC_def
>   apply (auto simp add: dist_Pair_Pair)
>   using real_sqrt_le_iff apply fastforce
>     apply (smt four_x_squared one_le_power real_sqrt_ge_0_iff real_sqrt_pow2)
>   using real_sqrt_le_mono apply fastforce
> proof -
>   fix a :: real and b :: real
>   assume a1: "sqrt (a\<^sup>2 + b\<^sup>2) * 2 < 1"
>   assume a2: "1 \<le> a\<^sup>2 * 4 + b\<^sup>2 * 4"
>   have "\<forall>r. 1 \<le> sqrt r \<or> \<not> 1 \<le> r"
>     by simp
>   then show False
>     using a2 a1 by (metis (no_types) Groups.mult_ac(2) distrib_left linorder_not_le real_sqrt_four real_sqrt_mult)
> qed
> 
> lemma x_in_trapC:
>   shows "(2,0) \<in> trapC"
>   unfolding trapC_def
>   by (auto simp add: dist_Pair_Pair)
> 
> lemma compact_trapC:
>   shows "compact trapC"
>   unfolding trapC_def
>   using compact_cball compact_diff by blast
> 
> lemma nonempty_trapC:
>   shows "trapC \<noteq> {}"
>   using x_in_trapC by auto
> 
> lemma origin_fixpoint:
>   assumes "(\<lambda>(x, y). (cx x y, cy x y)) (a,b) = 0"
>   shows "a = (0::real)" "b = (0::real)"
>   using assms unfolding cx_def cy_def zero_prod_def apply auto
>   apply (sos "((((A<0 * R<1) + (([28859/65536*a + 5089/8192*b + ~1/2] * A=0) + (([~5089/8192*a + 17219/65536*b + ~1/2] * A=1) + (R<1 * ((R<11853/65536 * [~16384/11853*a^2 + ~11585/11853*b^2 + 302/1317*a*b + a + 1940/3951*b]^2) + ((R<73630271/776798208 * [a^2 + 64177444/73630271*b^2 + 44531712/73630271*a*b + ~131061126/73630271*b]^2) + ((R<70211653911/4825433440256 * [~77895776116/70211653911*b^2 + 5825642465/10030236273*a*b + b]^2) + ((R<48375415273/657341564387328 * [~36776393918/48375415273*b^2 + a*b]^2) + (R<18852430195/11096159253659648 * [b^2]^2)))))))))) & (((A<0 * (A<0 * R<1)) + (([b] * A=0) + (([~1*a] * A=1) + (R<1 * (R<1 * [b]^2)))))))")
> proof -
>   assume a1: "a * (1 - a\<^sup>2 - b\<^sup>2) = b"
>   assume a2: "a + b * (1 - a\<^sup>2 - b\<^sup>2) = 0"
>   have f3: "\<forall>r ra. - (ra::real) * r = ra * - r"
>     by simp
>   have "- b * (1 - a\<^sup>2 - b\<^sup>2) = a"
>     using a2 by simp
>   then have "\<exists>r ra. b * b - ra * (r * (ra * - r)) = 0"
>     using f3 a1 by (metis (no_types) c.vec_simps(15) right_minus_eq)
>   then have "\<exists>r. b * b - r * - r = 0"
>     using f3 by (metis (no_types) c.vec_simps(14))
>   then show "b = 0"
>     by simp
> qed
> 
> lemma origin_not_trapC:
>   shows "0 \<notin> trapC"
>   unfolding trapC_def zero_prod_def 
>   by auto
> 
> lemma regular_trapC:
>   shows "0 \<notin> (\<lambda>(x, y). (cx x y, cy x y)) ` trapC"
>   using origin_fixpoint origin_not_trapC
>   by (smt UNIV_I UNIV_I UNIV_def case_prodE2 imageE c.flow_initial_time_if
>       c.rev.flow_initial_time_if mem_Collect_eq zero_prod_def)
> 
> lemma positively_invariant_outer:
>   shows "c.positively_invariant  {p. (\<lambda>p. (fst p)\<^sup>2 + (snd p)\<^sup>2 - 4) p \<le> 0}"
>   apply (rule c.positively_invariant_le[of "\<lambda>p.-2*((fst p)^2+(snd p)^2)" _  "\<lambda>x p. 2 * fst x * fst p + 2 * snd x * snd p" ])
>     apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding cx_def cy_def
>   by (sos "(((A<0 * R<1) + (R<1 * ((R<6 * [a]^2) + (R<6 * [b]^2)))))")
> 
> 
> lemma positively_invariant_inner:
>   shows "c.positively_invariant  {p. (\<lambda>p. 1/4 - ((fst p)\<^sup>2 + (snd p)\<^sup>2)) p \<le> 0}"
>   apply (rule c.positively_invariant_le[of "\<lambda>p.-2*((fst p)^2+(snd p)^2)" _ "\<lambda>x p. - 2 * fst x * fst p - 2 * snd x * snd p"])
>     apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding cx_def cy_def
>   by (sos "(((A<0 * R<1) + (R<1 * ((R<3/2 * [a]^2) + (R<3/2 * [b]^2)))))")
> 
> lemma positively_invariant_trapC:
>   shows "c.positively_invariant trapC"
>   unfolding trapC_eq
>   apply (rule c.positively_invariant_conj)
>   using positively_invariant_outer
>    apply (metis (no_types, lifting) Collect_cong case_prodE case_prodI2 case_prod_conv)
>   using positively_invariant_inner
>   by (metis (no_types, lifting) Collect_cong case_prodE case_prodI2 case_prod_conv)
> 
> theorem c_has_periodic_orbit:
>   obtains y where "c.periodic_orbit y" "c.flow0 y ` UNIV \<subseteq> trapC"
> proof -
>   from c.poincare_bendixson_applied[OF compact_trapC _ nonempty_trapC positively_invariant_trapC regular_trapC]
>   show ?thesis using that by blast
> qed
> 
> text \<open>Real-Arithmetic\<close>
> schematic_goal c_fas:
>   "[-(-(X!1) + (X!0) * (1 - (X!0)^2 - (X!1)^2)), -((X!0) + (X!1) * (1 - (X!0)^2 - (X!1)^2))] = interpret_floatariths ?fas X"
>   by (reify_floatariths)
> 
> concrete_definition c_fas uses c_fas
> 
> interpretation crev: ode_interpretation true_form UNIV c_fas
>   "-(\<lambda>(x, y). (cx x y, cy x y)::real*real)"
>   "d::2" for d
>   by unfold_locales (auto simp: c_fas_def less_Suc_eq_0_disj nth_Basis_list_prod Basis_list_real_def
>       cx_def cy_def eval_nat_numeral
>       mk_ode_ops_def eucl_of_list_prod power2_eq_square intro!: isFDERIV_I)
> 
> lemma crev: "t \<in> {1/8 .. 1/8} \<longrightarrow> (x, y) \<in> {(2, 0) .. (2, 0)} \<longrightarrow>
>    t \<in> c.rev.existence_ivl0 (x, y) \<and> c.rev.flow0 (x, y) t \<in> {(5.15, -0.651)..(5.18, -0.647)}"
>   by (tactic \<open>ode_bnds_tac @{thms c_fas_def} 30 20 7 12 [(0, 1, "0x000000")] (* "crev.out" *) "" @{context} 1\<close>)
> 
> theorem c_has_limit_cycle:
>   obtains y where "c.limit_cycle y" "range (c.flow0 y) \<subseteq> trapC"
> proof -
>   define E where "E = {(5.15, -0.651)..(5.18, -0.647)::real*real}"
>   from crev have "c.rev.flow0 (2, 0) (1/8) \<in> E"
>     by (auto simp: E_def)
>   moreover
>   have "E \<inter> trapC = {}"
>   proof -
>     have "norm x > 2" if "x \<in> E" for x
>       using that
>       apply (auto simp: norm_prod_def less_eq_prod_def E_def)
>       by (smt power2_less_eq_zero_iff real_less_rsqrt zero_compare_simps(9))
>     moreover have "norm x \<le> 2" if "x \<in> trapC" for x
>       using that
>       by (auto simp: trapC_def dist_prod_def norm_prod_def)
>     ultimately show ?thesis by force
>   qed
>   ultimately have "c.rev.flow0 (2, 0) (1 / 8) \<notin> trapC" by blast
>   from c.poincare_bendixson_limit_cycle[OF compact_trapC subset_UNIV x_in_trapC positively_invariant_trapC regular_trapC this] that
>   show ?thesis by blast
> qed
> 
> end
> 
> 
> subsection \<open>Glycolysis\<close>
> 
> text \<open>Strogatz, Example 7.3.2\<close>
> 
> context
> begin
> 
> text \<open>coordinate functions\<close>
> definition "gx x y = -x + 0.08 * y + x\<^sup>2 * y"
> definition "gy x y = 0.6 - 0.08 * y - x\<^sup>2 * y"
> 
> lemmas g_defs = gx_def gy_def
> 
> text \<open>partial derivatives\<close>
> definition A11::"real\<Rightarrow>real\<Rightarrow>real" where "A11 x y = -1 + 2 * x * y"
> definition A12::"real\<Rightarrow>real\<Rightarrow>real" where "A12 x y = (0.08 + x\<^sup>2)"
> definition A21::"real\<Rightarrow>real\<Rightarrow>real" where "A21 x y = -2*x*y"
> definition A22::"real\<Rightarrow>real\<Rightarrow>real" where "A22 x y = -(0.08 + x\<^sup>2)"
> 
> lemmas A_partials = A11_def A12_def A21_def A22_def
> 
> text \<open>Jacobian as linear map\<close>
> definition A :: "real \<Rightarrow> real \<Rightarrow> (real \<times> real) \<Rightarrow>\<^sub>L (real \<times> real)" where
>   "A x y = blinfun_of_matrix
>     ((\<lambda>_ _. 0)
>       ((1,0) := (\<lambda>_. 0)((1, 0):=A11 x y, (0, 1):=A12 x y),
>        (0, 1):= (\<lambda>_. 0)((1, 0):=A21 x y, (0, 1):=A22 x y)))"
> 
> lemma A_simp[simp]: "blinfun_apply (A x y) (dx, dy) =
>   (dx * A11 x y + dy * A12 x y,
>    dx * A21 x y + dy * A22 x y)"
>   by (auto simp: A_def blinfun_of_matrix_apply Basis_prod_def)
> 
> lemma A_continuous[continuous_intros]:
>   "continuous_on S (\<lambda>x. local.A (f x) (g x))"
>   if "continuous_on S f" "continuous_on S g"
>   unfolding A_def
>   by (auto intro!: continuous_on_blinfun_of_matrix continuous_intros that
>       simp: Basis_prod_def A_partials)
> 
> interpretation g: c1_on_open_R2 "\<lambda>(x::real, y::real). (gx x y, gy x y)::real*real"
>   "\<lambda>(x, y). A x y" UNIV
>   by unfold_locales
>     (auto intro!: derivative_eq_intros ext continuous_intros simp: split_beta algebra_simps
>       g_defs A_partials)
> 
> (*
>   The outer invariant is the convex set formed by the axes, y \<le> 7.51, and x+y\<le>8.12
> *)
> definition "(pos_quad::(real \<times> real) set) =  {p . - snd p \<le> 0} \<inter> {p . - fst p \<le> 0}"
> 
> definition "(trapG1::(real \<times> real) set) = pos_quad \<inter> ({p. (snd p) - 751/100 \<le> 0} \<inter> {p. (fst p) + (snd p) - 812/100 \<le> 0})"
> 
> lemma positively_invariant_y:
>   shows "g.positively_invariant {p . - snd p \<le> 0}"
>   apply (rule g.positively_invariant_le[of "\<lambda>p. -(0.08 + (fst p)^2)" _ "\<lambda>x p. - snd p"])
>     apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding gy_def
>   by (sos "()")
> 
> lemma positively_invariant_pos_quad:
>   shows "g.positively_invariant pos_quad"
>   unfolding pos_quad_def
>   apply (rule g.positively_invariant_le_domain[OF positively_invariant_y, of "\<lambda>p. fst p * snd p -1"])
>     apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding gx_def
>   by (sos "(((A<0 * R<1) + (((A<0 * R<1) * (R<11/14 * [1]^2)) + ((A<=0 * R<1) * (R<1/7 * [1]^2)))))")
> 
> lemma positively_invariant_y_upper:
>   shows "g.positively_invariant {p. (snd p) - 751/100 \<le> 0}"
>   apply (rule g.positively_invariant_barrier)
>     apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding gy_def
>   by (sos "((R<1 + ((R<1 * (R<18775/2 * [a]^2)) + ((A<=0 * R<1) * (R<1250 * [1]^2)))))")
> 
> lemma arith2:
>   shows "(y::real) \<le> 751/100 \<and> x + (y::real) = 812/100 \<Longrightarrow> 3/5 - (x::real) < 0"
>   by linarith
> 
> lemma positively_invariant_trapG1:
>   shows "g.positively_invariant trapG1"
>   unfolding trapG1_def
>   apply (rule g.positively_invariant_conj[OF positively_invariant_pos_quad])
>   apply (rule g.positively_invariant_barrier_domain[OF positively_invariant_y_upper])
>   apply (auto intro!: continuous_intros derivative_eq_intros)
>   unfolding gx_def gy_def by auto
> 
> (* Polynomial in invariant *)
> definition "p1 (x::real) (y::real) = -(21/34) - (69*x)/38 + (19*x^2)/15 - (9*x^3)/28 - (6*x^4)/43 + ( 14*y)/29 + (31*x*y)/21 + (182*x^2*y)/47 - (35*x^3*y)/16 - ( 3*y^2)/17 - (2*x*y^2)/9 - (31*x^2*y^2)/20 +y^3/102 + (x*y^3)/59"
> 
> definition "p1d x xa = 38 * (fst xa * fst x) / 15 - 69 * fst xa / 38 -
>           27 * (fst xa * (fst x)\<^sup>2) / 28 -
>           24 * (fst xa * fst x ^ 3) / 43 +
>           14 * snd xa / 29 +
>           (651 * (fst x * snd xa) +
>            651 * (fst xa * snd x)) /
>           441 +
>           (8554 * ((fst x)\<^sup>2 * snd xa) +
>            17108 * (fst xa * (fst x * snd x))) /
>           2209 -
>           (560 * (fst x ^ 3 * snd xa) +
>            1680 * (fst xa * ((fst x)\<^sup>2 * snd x))) /
>           256 -
>           6 * (snd xa * snd x) / 17 -
>           (36 * (fst x * (snd xa * snd x)) +
>            18 * (fst xa * (snd x)\<^sup>2)) /
>           81 -
>           (1240 * ((fst x)\<^sup>2 * (snd xa * snd x)) +
>            1240 * (fst xa * (fst x * (snd x)\<^sup>2))) /
>           400 +
>           snd xa * (snd x)\<^sup>2 / 34 +
>           (177 * (fst x * (snd xa * (snd x)\<^sup>2)) +
>            fst xa * snd x ^ 3 * 59) /
>           3481"
> 
> lemma p1_has_derivative:
>   shows "((\<lambda>x. p1 (fst x) (snd x)) has_derivative p1d x) (at x)"
>   unfolding p1_def p1d_def
>   by (auto intro!: continuous_intros derivative_eq_intros)
> 
> (* p1 excludes equilibria for free *)
> lemma p1_not_equil:
>   shows " p1 x y \<le> 0 \<Longrightarrow> gx x y \<noteq> 0 \<or> gy x y \<noteq> 0"
>   unfolding gx_def gy_def p1_def
>   by (sos "()")
> 
> definition "trapG = trapG1 \<inter> {p. p1 (fst p) (snd p) \<le> 0}"
> 
> text \<open>Real-Arithmetic\<close>
> definition "g_arith a b = (- (27 / 25) - a\<^sup>2 + 2 * a * b) * p1 a b - p1d (a, b) (gx a b, gy a b)"
> 
> schematic_goal g_arith_fas:
>   "[g_arith (X!0) (X!1)] = interpret_floatariths ?fas X"
>   unfolding g_arith_def p1_def p1d_def gx_def gy_def fst_conv snd_conv
>   by (reify_floatariths)
> 
> concrete_definition g_arith_fas uses g_arith_fas
> 
> lemma list_interval2: "list_interval [a, b] [c, d] = {[x, y] | x y. x \<in> {a .. c} \<and> y \<in> {b .. d}}"
>   apply (auto simp: list_interval_def)
>   subgoal for x
>     apply (cases x)
>     apply auto
>     subgoal for y zs
>       apply (cases zs)
>       by auto
>     done
>   done
> 
> lemma g_arith_nonneg: "g_arith a b \<ge> 0"
>   if a: "0 \<le> a" "a \<le> 8.24" and b: "0 \<le> b" "b \<le> 7.51"
> proof -
>   have "prove_nonneg [(0, 1, ''0x000000'')] 1000000 30 (slp_of_fas [hd g_arith_fas]) [aforms_of_ivls [0, 0]
>     [float_divr 30 824 100, float_divr 30 751 100]]"
>     by eval\<comment> \<open>slow: 60s\<close>
>   from prove_nonneg[OF this]
>   have "0 \<le> interpret_floatarith (hd g_arith_fas) [a, b]"
>     apply (auto simp: g_arith_fas)
>     apply (subst (asm) Joints_aforms_of_ivls)
>      apply (auto )
>       apply (smt divide_nonneg_nonneg float_divr float_numeral rel_simps(27))
>      apply (smt divide_nonneg_nonneg float_divr float_numeral rel_simps(27))
>     apply (subst (asm) list_interval2)
>     apply auto
>     apply (drule spec[where x="[a, b]"])
>     using a b
>     apply auto
>     subgoal by (rule order_trans[OF _ float_divr]) simp
>     subgoal by (rule order_trans[OF _ float_divr]) simp
>     done
>   also have "\<dots> = g_arith a b"
>     by (auto simp: g_arith_fas_def g_arith_def p1_def p1d_def gx_def gy_def)
>   finally show ?thesis .
> qed
> 
> lemma trap_arithmetic:
>   "p1d (a, b) (gx a b, gy a b) \<le> (- (27 / 25) - a\<^sup>2 + 2 * a * b) * p1 a b" if "(a, b) \<in> trapG1"
> proof -
>   from that
>   have b: "0 \<le> b" "b \<le> 7.51"
>     and a: "0 \<le> a" "a \<le> 8.24"
>     by (auto simp: trapG1_def pos_quad_def)
>   from g_arith_nonneg[OF a b] show ?thesis
>     by (simp add: g_arith_def)
> qed
> 
> lemma positively_invariant_trapG:
>   shows "g.positively_invariant trapG"
>   unfolding trapG_def
>   apply (rule g.positively_invariant_le_domain[OF positively_invariant_trapG1 _ p1_has_derivative,
>         of "\<lambda>p. -1.08 - (fst p)^2 + 2 * fst p * snd p"])
>   subgoal by (auto intro!: continuous_intros derivative_eq_intros simp add: pos_quad_def)
>   apply auto
>   by (rule trap_arithmetic)
> 
> lemma regular_trapG:
>   shows "0 \<notin> (\<lambda>(x, y). (gx x y, gy x y)) ` trapG"
>   unfolding trapG_def apply auto using p1_not_equil
>   by force
> 
> lemma arith:
>   "\<And>a b::real. 0 \<le> b \<Longrightarrow>
>            0 \<le> a \<Longrightarrow>
>            b * 100 \<le> 751 \<Longrightarrow>
>            a * 25 + b * 25 \<le> 203 \<Longrightarrow> norm a + norm b \<le> 20"
>   by auto
> 
> lemma trapG1_subset:
>   shows "trapG1 \<subseteq> cball (0::real \<times> real) 20"
>   unfolding trapG1_def pos_quad_def
>   apply auto
>   using arith norm_Pair_le
>   by smt
> 
> lemma compact_subset_closed:
>   assumes "compact S" "closed T"
>   assumes "T \<subseteq> S"
>   shows "compact T"
>   using compact_Int_closed[OF assms(1-2)] assms(3)
>   by (simp add: inf_absorb2)
> 
> lemma compact_trapG1:
>   shows "compact trapG1"
>   apply (auto intro!: compact_subset_closed[OF _ _ trapG1_subset])
>   unfolding trapG1_def pos_quad_def
>   by (auto intro!: closed_Collect_le continuous_intros)
> 
> lemma compact_trapG:
>   shows "compact trapG"
>   unfolding trapG_def
>   by (auto intro!: compact_Int_closed compact_trapG1 closed_Collect_le continuous_intros simp add: p1_def)
> 
> lemma x_in_trapG:
>   shows "(1,0) \<in> trapG"
>   unfolding trapG_def trapG1_def pos_quad_def p1_def
>   by (auto simp add: dist_Pair_Pair)
> 
> schematic_goal g_fas:
>   "[- (- (X!0) + 8 / 100 * (X!1) + (X!0)^2 * (X!1)),-( 6 / 10 - 8 / 100 * (X!1) - (X!0)^2 * (X!1))] = interpret_floatariths ?fas X"
>   by (reify_floatariths)
> 
> concrete_definition g_fas uses g_fas
> 
> interpretation grev: ode_interpretation true_form UNIV g_fas
>   "-(\<lambda>(x, y). (gx x y, gy x y)::real*real)"
>   "d::2" for d
>   by unfold_locales (auto simp: g_fas_def less_Suc_eq_0_disj nth_Basis_list_prod Basis_list_real_def
>       gx_def gy_def eval_nat_numeral
>       mk_ode_ops_def eucl_of_list_prod power2_eq_square intro!: isFDERIV_I)
> 
> lemma grev: "t \<in> {1/8 .. 1/8} \<longrightarrow> (x, y) \<in> {(1, 0) .. (1, 0)} \<longrightarrow>
>    t \<in> g.rev.existence_ivl0 (x, y) \<and> g.rev.flow0 (x, y) t \<in>
>     {(1.1, -0.09) .. (1.2, -0.08)}"
>   by (tactic \<open>ode_bnds_tac @{thms g_fas_def} 30 20 7 12 [(0, 1, "0x000000")] (* "grev.out" *) "" @{context} 1\<close>)
> 
> theorem g_has_limit_cycle:
>   obtains y where "g.limit_cycle y" "range (g.flow0 y) \<subseteq> trapG"
> proof -
>   define E::"(real*real) set" where "E = {(1.1, -0.09) .. (1.2, -0.08)}"
>   from grev have "g.rev.flow0 (1, 0) (1/8) \<in> E"
>     by (auto simp: E_def)
>   moreover
>   have "E \<inter> trapG = {}"
>     by (auto simp: trapG_def E_def trapG1_def pos_quad_def)
>   ultimately have "g.rev.flow0 (1, 0) (1 / 8) \<notin> trapG" by blast
>   from g.poincare_bendixson_limit_cycle[OF compact_trapG subset_UNIV x_in_trapG positively_invariant_trapG regular_trapG this] that
>   show ?thesis by blast
> qed
> 
> end
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Invariance.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Invariance.thy
1,298c1,298
< section \<open>Invariance\<close>
< theory Invariance
<   imports ODE_Misc
< begin
< 
< context auto_ll_on_open begin
< 
< definition "invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped x M)"
< 
< definition "positively_invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped_forward x M)"
< 
< definition "negatively_invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped_backward x M)"
< 
< lemma positively_invariant_iff:
<   "positively_invariant M \<longleftrightarrow>
<   (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x \<inter> {0..})) \<subseteq> M"
<   unfolding positively_invariant_def trapped_forward_def
<   by auto
< 
< lemma negatively_invariant_iff:
<   "negatively_invariant M \<longleftrightarrow>
<   (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x \<inter> {..0})) \<subseteq> M"
<   unfolding negatively_invariant_def trapped_backward_def
<   by auto
< 
< lemma invariant_iff_pos_and_neg_invariant:
<   "invariant M \<longleftrightarrow> positively_invariant M \<and> negatively_invariant M"
<   unfolding invariant_def trapped_def positively_invariant_def negatively_invariant_def
<   by blast
< 
< lemma invariant_iff:
<   "invariant M \<longleftrightarrow> (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x)) \<subseteq>  M"
<   unfolding invariant_iff_pos_and_neg_invariant positively_invariant_iff negatively_invariant_iff
<   by (metis (mono_tags) SUP_le_iff invariant_def invariant_iff_pos_and_neg_invariant negatively_invariant_iff positively_invariant_iff trapped_iff_on_existence_ivl0)
< 
< lemma positively_invariant_restrict_dom: "positively_invariant M = positively_invariant (M \<inter> X)"
<   unfolding positively_invariant_def trapped_forward_def
<   by (auto intro!: flow_in_domain dest: mem_existence_ivl_iv_defined)
< 
< lemma negatively_invariant_restrict_dom: "negatively_invariant M = negatively_invariant (M \<inter> X)"
<   unfolding negatively_invariant_def trapped_backward_def
<   by (auto intro!: flow_in_domain dest: mem_existence_ivl_iv_defined)
< 
< lemma invariant_restrict_dom: "invariant M = invariant (M \<inter> X)"
<   using invariant_iff_pos_and_neg_invariant
<     negatively_invariant_restrict_dom
<     positively_invariant_restrict_dom by auto
<     (*
< lemma positively_invariant_imp_subset:
<   "M \<subseteq> X" if "positively_invariant M"
<   using positively_invariant_iff that by blast
< 
< lemma negatively_invariant_imp_subset:
<   "M \<subseteq> X" if "negatively_invariant M"
<   using negatively_invariant_iff that by blast
< 
< lemma invariant_imp_subset:
<   "M \<subseteq> X" if "invariant M"
<   using invariant_iff that by blast
< *)
< 
< end context auto_ll_on_open begin
< 
< lemma positively_invariant_eq_rev: "positively_invariant M = rev.negatively_invariant M"
<   unfolding positively_invariant_def rev.negatively_invariant_def
<   by (simp add: rev.trapped_backward_iff_rev_trapped_forward)
< 
< lemma negatively_invariant_eq_rev: "negatively_invariant M = rev.positively_invariant M"
<   unfolding negatively_invariant_def rev.positively_invariant_def
<   by (simp add: trapped_backward_iff_rev_trapped_forward)
< 
< lemma invariant_eq_rev: "invariant M = rev.invariant M"
<   unfolding invariant_iff_pos_and_neg_invariant rev.invariant_iff_pos_and_neg_invariant
<     positively_invariant_eq_rev negatively_invariant_eq_rev by auto
< 
< lemma negatively_invariant_complI: "negatively_invariant (X-M)" if "positively_invariant M"
<   unfolding negatively_invariant_def trapped_backward_def
< proof clarsimp
<   fix x t
<   assume x: "x \<in> X" "x \<notin> M" "t \<in> existence_ivl0 x" "t \<le> 0"
<   have a1:"flow0 x t \<in> X" using x
<     using flow_in_domain by blast
<   have a2:"flow0 x t \<notin> M"
<   proof (rule ccontr)
<     assume "\<not> flow0 x t \<notin> M"
<     then have "trapped_forward (flow0 x t) M"
<       using positively_invariant_def that by auto
<     moreover have "flow0 (flow0 x t) (-t) = x"
<       using \<open>t \<in> existence_ivl0 x\<close> flows_reverse by auto
<     moreover have "-t \<in> existence_ivl0 (flow0 x t) \<inter> {0..}"
<       using existence_ivl_reverse x(3) x(4) by auto
<     ultimately have "x \<in> M" unfolding trapped_forward_def
<       by (metis image_subset_iff)
<     thus False using x(2) by auto
<   qed
<   show "flow0 x t \<in> X \<and> flow0 x t \<notin> M" using a1 a2 by auto
< qed
< 
< end context auto_ll_on_open begin
< 
< lemma negatively_invariant_complD: "positively_invariant M" if "negatively_invariant (X-M)"
< proof -
<   have "rev.positively_invariant (X-M)" using that
<     by (simp add: negatively_invariant_eq_rev)
<   then have "rev.negatively_invariant (X-(X-M))"
<     by (simp add: rev.negatively_invariant_complI)
<   then have "positively_invariant (X-(X-M))"
<     using rev.negatively_invariant_eq_rev by auto
<   thus ?thesis using Diff_Diff_Int
<     by (metis inf_commute positively_invariant_restrict_dom) 
< qed
< 
< lemma pos_invariant_iff_compl_neg_invariant: "positively_invariant M \<longleftrightarrow> negatively_invariant (X - M)"
<   by (safe intro!: negatively_invariant_complI dest!: negatively_invariant_complD)
< 
< lemma neg_invariant_iff_compl_pos_invariant:
<   shows "negatively_invariant M \<longleftrightarrow> positively_invariant (X - M)"
<   by (simp add: auto_ll_on_open.pos_invariant_iff_compl_neg_invariant negatively_invariant_eq_rev positively_invariant_eq_rev rev.auto_ll_on_open_axioms)
< 
< lemma invariant_iff_compl_invariant:
<   shows "invariant M \<longleftrightarrow> invariant (X - M)"
<   using invariant_iff_pos_and_neg_invariant neg_invariant_iff_compl_pos_invariant pos_invariant_iff_compl_neg_invariant by blast
< 
< lemma invariant_iff_pos_invariant_and_compl_pos_invariant:
<   shows "invariant M \<longleftrightarrow> positively_invariant M \<and> positively_invariant (X-M)"
<   by (simp add: invariant_iff_pos_and_neg_invariant neg_invariant_iff_compl_pos_invariant)
< 
< end
< 
< subsection \<open>Tools for proving invariance\<close>
< 
< context auto_ll_on_open begin
< 
< lemma positively_invariant_left_inter:
<   assumes "positively_invariant C"
<   assumes "\<forall>x \<in> C \<inter> D. trapped_forward x D"
<   shows "positively_invariant (C \<inter> D)"
<   using assms positively_invariant_def trapped_forward_def by auto
< 
< lemma trapped_forward_le:
<   fixes V :: "'a \<Rightarrow> real"
<   assumes "V x \<le> 0"
<   assumes contg: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) g"
<   assumes "\<And>x. (V has_derivative V' x) (at x)"
<   assumes "\<And>s. s \<in> existence_ivl0 x \<inter> {0..} \<Longrightarrow> V' (flow0 x s) (f (flow0 x s)) \<le> g (flow0 x s) * V (flow0 x s)"
<   shows "trapped_forward x {x. V x \<le> 0}"
<   unfolding trapped_forward_def
< proof clarsimp
<   fix t
<   assume t: "t \<in> existence_ivl0 x" "0 \<le> t"
<   then have ex:"{0..t} \<subseteq> existence_ivl0 x"
<     by (simp add: local.ivl_subset_existence_ivl)
<   have contV: "continuous_on UNIV V"
<     using assms(3) has_derivative_continuous_on by blast
<   have 1: "continuous_on {0..t} (g \<circ> flow0 x)"
<     apply (rule continuous_on_compose)
<     using continuous_on_subset ex local.flow_continuous_on apply blast
<     by (meson Int_subset_iff atLeastAtMost_iff atLeast_iff contg continuous_on_subset ex image_mono subsetI)
<   have 2: "(\<And>s. s \<in> {0..t} \<Longrightarrow>
<          (V \<circ> flow0 x has_real_derivative (V' (flow0 x s) \<circ> f \<circ> flow0 x) s) (at s))"
<     apply (auto simp add:o_def has_field_derivative_def)
<   proof -                              
<     fix s
<     assume "0 \<le> s" "s \<le> t"
<     then have "s \<in> existence_ivl0 x" using ex by auto
<     from flow_has_derivative[OF this] have
<       "(flow0 x has_derivative (\<lambda>i. i *\<^sub>R f (flow0 x s))) (at s)" .
<     from has_derivative_compose[OF this assms(3)]
<     have "((\<lambda>t. V (flow0 x t)) has_derivative (\<lambda>t. V' (flow0 x s)  (t *\<^sub>R f (flow0 x s)))) (at s)" .
<     moreover have "linear (V' (flow0 x s))"  using assms(3) has_derivative_linear by blast
<     ultimately 
<     have "((\<lambda>t. V (flow0 x t)) has_derivative (\<lambda>t. t *\<^sub>R V' (flow0 x s) (f (flow0 x s)))) (at s)" 
<       unfolding linear_cmul[OF \<open>linear (V' (flow0 x s))\<close>] by blast
<     thus "((\<lambda>t. V (flow0 x t)) has_derivative (*) (V' (flow0 x s) (f (flow0 x s)))) (at s)"
<       by (auto intro!: derivative_eq_intros simp add: mult_commute_abs)
<   qed
<   have 3: "(\<And>s. s \<in> {0..t} \<Longrightarrow>
<          (V' (flow0 x s)  \<circ> f \<circ> flow0 x) s \<le> (g \<circ> flow0 x) s *\<^sub>R (V \<circ> flow0 x) s)"
<     using ex by (auto intro!:assms(4))
<   from comparison_principle_le_linear[OF 1 2 _ 3] assms(1)
<   have "\<forall>s \<in> {0..t}. (V \<circ> flow0 x) s \<le> 0"
<     using local.mem_existence_ivl_iv_defined(2) t(1) by auto
<   thus " V (flow0 x t) \<le> 0"
<     by (simp add: t(2))
< qed
< 
< lemma positively_invariant_le_domain:
<   fixes V :: "'a \<Rightarrow> real"
<   assumes "positively_invariant D"
<   assumes contg: "continuous_on D g"
<   assumes "\<And>x. (V has_derivative V' x) (at x)" (* TODO: domain can be added here too ? *)
<   assumes "\<And>s. s \<in> D \<Longrightarrow> V' s (f s) \<le> g s * V s"
<   shows "positively_invariant (D \<inter> {x. V x \<le> 0})"
<   apply (auto intro!:positively_invariant_left_inter[OF assms(1)])
< proof -
<   fix x
<   assume "x \<in> D" "V x \<le> 0"
<   have "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) g"
<     by (meson \<open>x \<in> D\<close> assms(1) contg continuous_on_subset positively_invariant_def trapped_forward_def)
<   from trapped_forward_le[OF \<open>V x \<le> 0\<close> this assms(3)]
<   show "trapped_forward x {x. V x \<le> 0}" using assms(4)
<     using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
< qed
< 
< lemma positively_invariant_barrier_domain:
<   fixes V :: "'a \<Rightarrow> real"
<   assumes "positively_invariant D"
<   assumes "\<And>x. (V has_derivative V' x) (at x)"
<   assumes "continuous_on D (\<lambda>x. V' x (f x))"
<   assumes "\<And>s. s \<in> D \<Longrightarrow> V s = 0 \<Longrightarrow> V' s (f s) < 0"
<   shows "positively_invariant (D \<inter> {x. V x \<le> 0})"
<   apply (auto intro!:positively_invariant_left_inter[OF assms(1)])
< proof -
<   fix x
<   assume "x \<in> D" "V x \<le> 0"
<   have contV: "continuous_on UNIV V" using assms(2) has_derivative_continuous_on by blast
<   then have *: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) V"
<     using continuous_on_subset by blast
<   have sub: "flow0 x ` (existence_ivl0 x \<inter> {0..}) \<subseteq> D"
<     using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
<   then have contV': "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) (\<lambda>x. V' x (f x))"
<     by (metis assms(3) continuous_on_subset)
<   have nz: "\<And>i t. t \<in> existence_ivl0 x \<Longrightarrow>
<        0 \<le> t \<Longrightarrow>  max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0"
<   proof -
<     fix i t
<     assume "t \<in> existence_ivl0 x" "0 \<le> t"
<     then have "flow0 x t \<in> D"
<       using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
<     then have "V (flow0 x t) = 0 \<Longrightarrow> - V' (flow0 x t) (f (flow0 x t)) > 0" using assms(4) by simp
<     then have "(V (flow0 x t))^2 > 0 \<or> - V' (flow0 x t) (f (flow0 x t)) > 0" by simp
<     thus "max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0" unfolding less_max_iff_disj
<       by auto
<   qed
<   have *: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) (\<lambda>x. V' x (f x) * V x / max (- V' x (f x)) ((V x)^2))"
<     apply (auto intro!:continuous_intros continuous_on_max simp add: * contV')
<     using nz by fastforce
<   have "(\<And>t. t \<in> existence_ivl0 x \<inter> {0..} \<Longrightarrow>
<         V' (flow0 x t) (f (flow0 x t)) \<le>
<         (V' (flow0 x t) (f (flow0 x t)) * V (flow0 x t)
<         / max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)) * V (flow0 x t))"
<   proof clarsimp
<     fix t
<     assume "t \<in> existence_ivl0 x" "0 \<le> t"
<     then have p: "max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0" using nz by auto
<     have " V' (flow0 x t) (f (flow0 x t)) * max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)
<       \<le>  V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t))\<^sup>2"
<       by (smt mult_minus_left mult_minus_right power2_eq_square real_mult_le_cancel_iff2)
<     then have "V' (flow0 x t) (f (flow0 x t))
<       \<le>  V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t))\<^sup>2
<       / max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)"
<       using p pos_le_divide_eq by blast
<     thus " V' (flow0 x t) (f (flow0 x t))
<          \<le> V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t)) * V (flow0 x t) /
<            max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)"
<       by (simp add: power2_eq_square)
<   qed
<   from trapped_forward_le[OF \<open>V x \<le> 0\<close> * assms(2) this]
<   show "trapped_forward x {x. V x \<le> 0}" by auto
< qed
< 
< lemma positively_invariant_UNIV:
<   shows "positively_invariant UNIV"
<   using positively_invariant_iff by blast
< 
< lemma positively_invariant_conj:
<   assumes "positively_invariant C"
<   assumes "positively_invariant D"
<   shows "positively_invariant (C \<inter> D)"
<   using assms positively_invariant_def
<   using positively_invariant_left_inter by auto
< 
< lemma positively_invariant_le:
<   fixes V :: "'a \<Rightarrow> real"
<   assumes contg: "continuous_on UNIV g"
<   assumes "\<And>x. (V has_derivative V' x) (at x)"
<   assumes "\<And>s. V' s (f s) \<le> g s * V s"
<   shows "positively_invariant {x. V x \<le> 0}"
< proof -
<   from positively_invariant_le_domain[OF positively_invariant_UNIV assms]  
<   have "positively_invariant (UNIV \<inter> {x. V x \<le> 0})" .
<   thus ?thesis by auto
< qed
< 
< lemma positively_invariant_barrier:
<   fixes V :: "'a \<Rightarrow> real"
<   assumes "\<And>x. (V has_derivative V' x) (at x)"
<   assumes "continuous_on UNIV (\<lambda>x. V' x (f x))"
<   assumes "\<And>s. V s = 0 \<Longrightarrow> V' s (f s) < 0"
<   shows "positively_invariant {x. V x \<le> 0}"
< proof -
<   from positively_invariant_barrier_domain[OF positively_invariant_UNIV assms]  
<   have "positively_invariant (UNIV \<inter> {x. V x \<le> 0})" .
<   thus ?thesis by auto
< qed
< 
< end
< 
---
> section \<open>Invariance\<close>
> theory Invariance
>   imports ODE_Misc
> begin
> 
> context auto_ll_on_open begin
> 
> definition "invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped x M)"
> 
> definition "positively_invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped_forward x M)"
> 
> definition "negatively_invariant M \<longleftrightarrow> (\<forall>x\<in>M. trapped_backward x M)"
> 
> lemma positively_invariant_iff:
>   "positively_invariant M \<longleftrightarrow>
>   (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x \<inter> {0..})) \<subseteq> M"
>   unfolding positively_invariant_def trapped_forward_def
>   by auto
> 
> lemma negatively_invariant_iff:
>   "negatively_invariant M \<longleftrightarrow>
>   (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x \<inter> {..0})) \<subseteq> M"
>   unfolding negatively_invariant_def trapped_backward_def
>   by auto
> 
> lemma invariant_iff_pos_and_neg_invariant:
>   "invariant M \<longleftrightarrow> positively_invariant M \<and> negatively_invariant M"
>   unfolding invariant_def trapped_def positively_invariant_def negatively_invariant_def
>   by blast
> 
> lemma invariant_iff:
>   "invariant M \<longleftrightarrow> (\<Union>x\<in>M. flow0 x ` (existence_ivl0 x)) \<subseteq>  M"
>   unfolding invariant_iff_pos_and_neg_invariant positively_invariant_iff negatively_invariant_iff
>   by (metis (mono_tags) SUP_le_iff invariant_def invariant_iff_pos_and_neg_invariant negatively_invariant_iff positively_invariant_iff trapped_iff_on_existence_ivl0)
> 
> lemma positively_invariant_restrict_dom: "positively_invariant M = positively_invariant (M \<inter> X)"
>   unfolding positively_invariant_def trapped_forward_def
>   by (auto intro!: flow_in_domain dest: mem_existence_ivl_iv_defined)
> 
> lemma negatively_invariant_restrict_dom: "negatively_invariant M = negatively_invariant (M \<inter> X)"
>   unfolding negatively_invariant_def trapped_backward_def
>   by (auto intro!: flow_in_domain dest: mem_existence_ivl_iv_defined)
> 
> lemma invariant_restrict_dom: "invariant M = invariant (M \<inter> X)"
>   using invariant_iff_pos_and_neg_invariant
>     negatively_invariant_restrict_dom
>     positively_invariant_restrict_dom by auto
>     (*
> lemma positively_invariant_imp_subset:
>   "M \<subseteq> X" if "positively_invariant M"
>   using positively_invariant_iff that by blast
> 
> lemma negatively_invariant_imp_subset:
>   "M \<subseteq> X" if "negatively_invariant M"
>   using negatively_invariant_iff that by blast
> 
> lemma invariant_imp_subset:
>   "M \<subseteq> X" if "invariant M"
>   using invariant_iff that by blast
> *)
> 
> end context auto_ll_on_open begin
> 
> lemma positively_invariant_eq_rev: "positively_invariant M = rev.negatively_invariant M"
>   unfolding positively_invariant_def rev.negatively_invariant_def
>   by (simp add: rev.trapped_backward_iff_rev_trapped_forward)
> 
> lemma negatively_invariant_eq_rev: "negatively_invariant M = rev.positively_invariant M"
>   unfolding negatively_invariant_def rev.positively_invariant_def
>   by (simp add: trapped_backward_iff_rev_trapped_forward)
> 
> lemma invariant_eq_rev: "invariant M = rev.invariant M"
>   unfolding invariant_iff_pos_and_neg_invariant rev.invariant_iff_pos_and_neg_invariant
>     positively_invariant_eq_rev negatively_invariant_eq_rev by auto
> 
> lemma negatively_invariant_complI: "negatively_invariant (X-M)" if "positively_invariant M"
>   unfolding negatively_invariant_def trapped_backward_def
> proof clarsimp
>   fix x t
>   assume x: "x \<in> X" "x \<notin> M" "t \<in> existence_ivl0 x" "t \<le> 0"
>   have a1:"flow0 x t \<in> X" using x
>     using flow_in_domain by blast
>   have a2:"flow0 x t \<notin> M"
>   proof (rule ccontr)
>     assume "\<not> flow0 x t \<notin> M"
>     then have "trapped_forward (flow0 x t) M"
>       using positively_invariant_def that by auto
>     moreover have "flow0 (flow0 x t) (-t) = x"
>       using \<open>t \<in> existence_ivl0 x\<close> flows_reverse by auto
>     moreover have "-t \<in> existence_ivl0 (flow0 x t) \<inter> {0..}"
>       using existence_ivl_reverse x(3) x(4) by auto
>     ultimately have "x \<in> M" unfolding trapped_forward_def
>       by (metis image_subset_iff)
>     thus False using x(2) by auto
>   qed
>   show "flow0 x t \<in> X \<and> flow0 x t \<notin> M" using a1 a2 by auto
> qed
> 
> end context auto_ll_on_open begin
> 
> lemma negatively_invariant_complD: "positively_invariant M" if "negatively_invariant (X-M)"
> proof -
>   have "rev.positively_invariant (X-M)" using that
>     by (simp add: negatively_invariant_eq_rev)
>   then have "rev.negatively_invariant (X-(X-M))"
>     by (simp add: rev.negatively_invariant_complI)
>   then have "positively_invariant (X-(X-M))"
>     using rev.negatively_invariant_eq_rev by auto
>   thus ?thesis using Diff_Diff_Int
>     by (metis inf_commute positively_invariant_restrict_dom) 
> qed
> 
> lemma pos_invariant_iff_compl_neg_invariant: "positively_invariant M \<longleftrightarrow> negatively_invariant (X - M)"
>   by (safe intro!: negatively_invariant_complI dest!: negatively_invariant_complD)
> 
> lemma neg_invariant_iff_compl_pos_invariant:
>   shows "negatively_invariant M \<longleftrightarrow> positively_invariant (X - M)"
>   by (simp add: auto_ll_on_open.pos_invariant_iff_compl_neg_invariant negatively_invariant_eq_rev positively_invariant_eq_rev rev.auto_ll_on_open_axioms)
> 
> lemma invariant_iff_compl_invariant:
>   shows "invariant M \<longleftrightarrow> invariant (X - M)"
>   using invariant_iff_pos_and_neg_invariant neg_invariant_iff_compl_pos_invariant pos_invariant_iff_compl_neg_invariant by blast
> 
> lemma invariant_iff_pos_invariant_and_compl_pos_invariant:
>   shows "invariant M \<longleftrightarrow> positively_invariant M \<and> positively_invariant (X-M)"
>   by (simp add: invariant_iff_pos_and_neg_invariant neg_invariant_iff_compl_pos_invariant)
> 
> end
> 
> subsection \<open>Tools for proving invariance\<close>
> 
> context auto_ll_on_open begin
> 
> lemma positively_invariant_left_inter:
>   assumes "positively_invariant C"
>   assumes "\<forall>x \<in> C \<inter> D. trapped_forward x D"
>   shows "positively_invariant (C \<inter> D)"
>   using assms positively_invariant_def trapped_forward_def by auto
> 
> lemma trapped_forward_le:
>   fixes V :: "'a \<Rightarrow> real"
>   assumes "V x \<le> 0"
>   assumes contg: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) g"
>   assumes "\<And>x. (V has_derivative V' x) (at x)"
>   assumes "\<And>s. s \<in> existence_ivl0 x \<inter> {0..} \<Longrightarrow> V' (flow0 x s) (f (flow0 x s)) \<le> g (flow0 x s) * V (flow0 x s)"
>   shows "trapped_forward x {x. V x \<le> 0}"
>   unfolding trapped_forward_def
> proof clarsimp
>   fix t
>   assume t: "t \<in> existence_ivl0 x" "0 \<le> t"
>   then have ex:"{0..t} \<subseteq> existence_ivl0 x"
>     by (simp add: local.ivl_subset_existence_ivl)
>   have contV: "continuous_on UNIV V"
>     using assms(3) has_derivative_continuous_on by blast
>   have 1: "continuous_on {0..t} (g \<circ> flow0 x)"
>     apply (rule continuous_on_compose)
>     using continuous_on_subset ex local.flow_continuous_on apply blast
>     by (meson Int_subset_iff atLeastAtMost_iff atLeast_iff contg continuous_on_subset ex image_mono subsetI)
>   have 2: "(\<And>s. s \<in> {0..t} \<Longrightarrow>
>          (V \<circ> flow0 x has_real_derivative (V' (flow0 x s) \<circ> f \<circ> flow0 x) s) (at s))"
>     apply (auto simp add:o_def has_field_derivative_def)
>   proof -                              
>     fix s
>     assume "0 \<le> s" "s \<le> t"
>     then have "s \<in> existence_ivl0 x" using ex by auto
>     from flow_has_derivative[OF this] have
>       "(flow0 x has_derivative (\<lambda>i. i *\<^sub>R f (flow0 x s))) (at s)" .
>     from has_derivative_compose[OF this assms(3)]
>     have "((\<lambda>t. V (flow0 x t)) has_derivative (\<lambda>t. V' (flow0 x s)  (t *\<^sub>R f (flow0 x s)))) (at s)" .
>     moreover have "linear (V' (flow0 x s))"  using assms(3) has_derivative_linear by blast
>     ultimately 
>     have "((\<lambda>t. V (flow0 x t)) has_derivative (\<lambda>t. t *\<^sub>R V' (flow0 x s) (f (flow0 x s)))) (at s)" 
>       unfolding linear_cmul[OF \<open>linear (V' (flow0 x s))\<close>] by blast
>     thus "((\<lambda>t. V (flow0 x t)) has_derivative (*) (V' (flow0 x s) (f (flow0 x s)))) (at s)"
>       by (auto intro!: derivative_eq_intros simp add: mult_commute_abs)
>   qed
>   have 3: "(\<And>s. s \<in> {0..t} \<Longrightarrow>
>          (V' (flow0 x s)  \<circ> f \<circ> flow0 x) s \<le> (g \<circ> flow0 x) s *\<^sub>R (V \<circ> flow0 x) s)"
>     using ex by (auto intro!:assms(4))
>   from comparison_principle_le_linear[OF 1 2 _ 3] assms(1)
>   have "\<forall>s \<in> {0..t}. (V \<circ> flow0 x) s \<le> 0"
>     using local.mem_existence_ivl_iv_defined(2) t(1) by auto
>   thus " V (flow0 x t) \<le> 0"
>     by (simp add: t(2))
> qed
> 
> lemma positively_invariant_le_domain:
>   fixes V :: "'a \<Rightarrow> real"
>   assumes "positively_invariant D"
>   assumes contg: "continuous_on D g"
>   assumes "\<And>x. (V has_derivative V' x) (at x)" (* TODO: domain can be added here too ? *)
>   assumes "\<And>s. s \<in> D \<Longrightarrow> V' s (f s) \<le> g s * V s"
>   shows "positively_invariant (D \<inter> {x. V x \<le> 0})"
>   apply (auto intro!:positively_invariant_left_inter[OF assms(1)])
> proof -
>   fix x
>   assume "x \<in> D" "V x \<le> 0"
>   have "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) g"
>     by (meson \<open>x \<in> D\<close> assms(1) contg continuous_on_subset positively_invariant_def trapped_forward_def)
>   from trapped_forward_le[OF \<open>V x \<le> 0\<close> this assms(3)]
>   show "trapped_forward x {x. V x \<le> 0}" using assms(4)
>     using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
> qed
> 
> lemma positively_invariant_barrier_domain:
>   fixes V :: "'a \<Rightarrow> real"
>   assumes "positively_invariant D"
>   assumes "\<And>x. (V has_derivative V' x) (at x)"
>   assumes "continuous_on D (\<lambda>x. V' x (f x))"
>   assumes "\<And>s. s \<in> D \<Longrightarrow> V s = 0 \<Longrightarrow> V' s (f s) < 0"
>   shows "positively_invariant (D \<inter> {x. V x \<le> 0})"
>   apply (auto intro!:positively_invariant_left_inter[OF assms(1)])
> proof -
>   fix x
>   assume "x \<in> D" "V x \<le> 0"
>   have contV: "continuous_on UNIV V" using assms(2) has_derivative_continuous_on by blast
>   then have *: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) V"
>     using continuous_on_subset by blast
>   have sub: "flow0 x ` (existence_ivl0 x \<inter> {0..}) \<subseteq> D"
>     using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
>   then have contV': "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) (\<lambda>x. V' x (f x))"
>     by (metis assms(3) continuous_on_subset)
>   have nz: "\<And>i t. t \<in> existence_ivl0 x \<Longrightarrow>
>        0 \<le> t \<Longrightarrow>  max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0"
>   proof -
>     fix i t
>     assume "t \<in> existence_ivl0 x" "0 \<le> t"
>     then have "flow0 x t \<in> D"
>       using \<open>x \<in> D\<close> assms(1) positively_invariant_def trapped_forward_def by auto
>     then have "V (flow0 x t) = 0 \<Longrightarrow> - V' (flow0 x t) (f (flow0 x t)) > 0" using assms(4) by simp
>     then have "(V (flow0 x t))^2 > 0 \<or> - V' (flow0 x t) (f (flow0 x t)) > 0" by simp
>     thus "max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0" unfolding less_max_iff_disj
>       by auto
>   qed
>   have *: "continuous_on (flow0 x ` (existence_ivl0 x \<inter> {0..})) (\<lambda>x. V' x (f x) * V x / max (- V' x (f x)) ((V x)^2))"
>     apply (auto intro!:continuous_intros continuous_on_max simp add: * contV')
>     using nz by fastforce
>   have "(\<And>t. t \<in> existence_ivl0 x \<inter> {0..} \<Longrightarrow>
>         V' (flow0 x t) (f (flow0 x t)) \<le>
>         (V' (flow0 x t) (f (flow0 x t)) * V (flow0 x t)
>         / max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)) * V (flow0 x t))"
>   proof clarsimp
>     fix t
>     assume "t \<in> existence_ivl0 x" "0 \<le> t"
>     then have p: "max (-V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2) > 0" using nz by auto
>     have " V' (flow0 x t) (f (flow0 x t)) * max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)
>       \<le>  V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t))\<^sup>2"
>       by (smt mult_minus_left mult_minus_right power2_eq_square real_mult_le_cancel_iff2)
>     then have "V' (flow0 x t) (f (flow0 x t))
>       \<le>  V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t))\<^sup>2
>       / max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)"
>       using p pos_le_divide_eq by blast
>     thus " V' (flow0 x t) (f (flow0 x t))
>          \<le> V' (flow0 x t) (f (flow0 x t)) * (V (flow0 x t)) * V (flow0 x t) /
>            max (- V' (flow0 x t) (f (flow0 x t))) ((V (flow0 x t))\<^sup>2)"
>       by (simp add: power2_eq_square)
>   qed
>   from trapped_forward_le[OF \<open>V x \<le> 0\<close> * assms(2) this]
>   show "trapped_forward x {x. V x \<le> 0}" by auto
> qed
> 
> lemma positively_invariant_UNIV:
>   shows "positively_invariant UNIV"
>   using positively_invariant_iff by blast
> 
> lemma positively_invariant_conj:
>   assumes "positively_invariant C"
>   assumes "positively_invariant D"
>   shows "positively_invariant (C \<inter> D)"
>   using assms positively_invariant_def
>   using positively_invariant_left_inter by auto
> 
> lemma positively_invariant_le:
>   fixes V :: "'a \<Rightarrow> real"
>   assumes contg: "continuous_on UNIV g"
>   assumes "\<And>x. (V has_derivative V' x) (at x)"
>   assumes "\<And>s. V' s (f s) \<le> g s * V s"
>   shows "positively_invariant {x. V x \<le> 0}"
> proof -
>   from positively_invariant_le_domain[OF positively_invariant_UNIV assms]  
>   have "positively_invariant (UNIV \<inter> {x. V x \<le> 0})" .
>   thus ?thesis by auto
> qed
> 
> lemma positively_invariant_barrier:
>   fixes V :: "'a \<Rightarrow> real"
>   assumes "\<And>x. (V has_derivative V' x) (at x)"
>   assumes "continuous_on UNIV (\<lambda>x. V' x (f x))"
>   assumes "\<And>s. V s = 0 \<Longrightarrow> V' s (f s) < 0"
>   shows "positively_invariant {x. V x \<le> 0}"
> proof -
>   from positively_invariant_barrier_domain[OF positively_invariant_UNIV assms]  
>   have "positively_invariant (UNIV \<inter> {x. V x \<le> 0})" .
>   thus ?thesis by auto
> qed
> 
> end
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Limit_Set.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Limit_Set.thy
1,473c1,473
< section \<open>Limit Sets\<close>
< theory Limit_Set
<   imports Invariance
< begin
< 
< context auto_ll_on_open begin
< text \<open>Positive limit point, assuming \<open>{0..} \<subseteq> existence_ivl0 x\<close>\<close>
< 
< (* TODO: Perhaps a more intrinsic definition would be better here *)
< definition "\<omega>_limit_point x p \<longleftrightarrow>
<   {0..} \<subseteq> existence_ivl0 x \<and>
<   (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> p)"
< 
< text \<open> Also called the \<open>\<omega>\<close>-limit set of x \<close>
< definition "\<omega>_limit_set x = {p. \<omega>_limit_point x p}"
< 
< definition "\<alpha>_limit_point x p \<longleftrightarrow>
<   {..0} \<subseteq> existence_ivl0 x \<and>
<   (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> p)"
< 
< text \<open> Also called the \<open>\<alpha>\<close>-limit set of x \<close>
< definition "\<alpha>_limit_set x =
<   {p. \<alpha>_limit_point x p}"
< 
< end context auto_ll_on_open begin
< 
< lemma \<alpha>_limit_point_eq_rev: "\<alpha>_limit_point x p = rev.\<omega>_limit_point x p"
<   unfolding \<alpha>_limit_point_def rev.\<omega>_limit_point_def
<   apply (auto simp: rev_eq_flow[abs_def] o_def filterlim_uminus_at_bot rev_existence_ivl_eq0 subset_iff
<       intro: exI[where x="uminus o s" for s])
<   using neg_0_le_iff_le by fastforce
< 
< lemma \<alpha>_limit_set_eq_rev: "\<alpha>_limit_set x = rev.\<omega>_limit_set x"
<   unfolding \<alpha>_limit_set_def rev.\<omega>_limit_set_def \<alpha>_limit_point_eq_rev ..
< 
< lemma \<omega>_limit_pointE:
<   assumes "\<omega>_limit_point x p"
<   obtains s where
<     "filterlim s at_top sequentially"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>n. b \<le> s n"
<   using assms filterlim_at_top_choose_lower \<omega>_limit_point_def by blast
< 
< lemma \<omega>_limit_set_eq:
<   assumes "{0..} \<subseteq> existence_ivl0 x"
<   shows "\<omega>_limit_set x = (INF \<tau> \<in> {0..}. closure (flow0 x ` {\<tau>..}))"
<   unfolding \<omega>_limit_set_def
< proof safe
<   fix p t
<   assume pt: "0 \<le> (t::real)" "\<omega>_limit_point x p"
<   from \<omega>_limit_pointE[OF pt(2)]
<   obtain s where
<     "filterlim s at_top sequentially"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>n. t \<le> s n" by blast
<   thus "p \<in> closure (flow0 x ` {t..})" unfolding closure_sequential
<     by (metis atLeast_iff comp_apply imageI)
< next
<   fix p
<   assume "p \<in> (\<Inter>\<tau>\<in>{0..}. closure (flow0 x ` {\<tau>..}))"
<   then have "\<And>t. t \<ge>0 \<Longrightarrow> p \<in> closure (flow0 x ` {t..})" by blast
<   then have "\<And>t e. t \<ge>0 \<Longrightarrow> e > 0 \<Longrightarrow> (\<exists>tt \<ge> t. dist (flow0 x tt) p < e)"
<     unfolding closure_approachable
<     by fastforce
<   from approachable_sequenceE[OF this]
<   obtain s where "filterlim s at_top sequentially" "(flow0 x \<circ> s) \<longlonglongrightarrow> p" by auto
<   thus "\<omega>_limit_point x p" unfolding \<omega>_limit_point_def using assms by auto
< qed
< 
< lemma \<omega>_limit_set_empty:
<   assumes "\<not> ({0..} \<subseteq> existence_ivl0 x)"
<   shows "\<omega>_limit_set x = {}"
<   unfolding \<omega>_limit_set_def \<omega>_limit_point_def
<   by (simp add: assms)
< 
< lemma \<omega>_limit_set_closed: "closed (\<omega>_limit_set x)"
<   using \<omega>_limit_set_eq
<   by (metis \<omega>_limit_set_empty closed_INT closed_closure closed_empty)
< 
< (* TODO: Walter gives a more direct proof *)
< lemma \<omega>_limit_set_positively_invariant:
<   shows "positively_invariant (\<omega>_limit_set x)"
<   unfolding positively_invariant_def trapped_forward_def
< proof safe
<   fix dummy p t
<   assume xa: "p \<in> \<omega>_limit_set x"
<     "t \<in> existence_ivl0 p"
<     "0 \<le> t"
<   have "p \<in> X" using mem_existence_ivl_iv_defined(2) xa(2) by blast
<   have exist: "{0..} \<subseteq> existence_ivl0 x" using xa(1)
<     unfolding \<omega>_limit_set_def \<omega>_limit_point_def by auto
<   from xa(1)
<   obtain s where s:
<     "filterlim s at_top sequentially"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>n. 0 \<le> s n"
<     unfolding \<omega>_limit_set_def by (auto elim!:\<omega>_limit_pointE)
<   define r where "r = (\<lambda>n. t + s n)"
<   have rlim: "filterlim r at_top sequentially" unfolding r_def
<     by (auto intro: filterlim_tendsto_add_at_top[OF _ s(1)])
<   define dom where "dom = image (flow0 x) {0..} \<union> {p} "
<   have domin: "\<forall>n. (flow0 x \<circ> s) n \<in> dom" "p \<in> dom" unfolding dom_def o_def
<     using exist by(auto simp add: s(3))
<   have xt: "\<And>x. x \<in> dom \<Longrightarrow> t \<in> existence_ivl0 x" unfolding dom_def using xa(2)
<     apply auto
<     apply (rule existence_ivl_trans')
<     using exist xa(3) apply auto[1]
<     using exist  by auto
<   have cont: "continuous_on dom (\<lambda>x. flow0 x t)"
<     apply (rule flow_continuous_on_compose)
<        apply auto
<     using \<open>p \<in> X\<close>  exist local.dom_def local.flow_in_domain apply auto[1]
<     using xt .
<   then have f1: "((\<lambda>x. flow0 x t) \<circ> (flow0 x \<circ> s)) \<longlonglongrightarrow> flow0 p t" using domin s(2)
<     unfolding continuous_on_sequentially
<     by blast
<   have ff:"\<And>n. (flow0 x \<circ> r) n = ((\<lambda>x. flow0 x t) \<circ> (flow0 x \<circ> s)) n"
<     unfolding o_def r_def
<   proof -
<     fix n
<     have s:"s n \<in> existence_ivl0 x"
<       using s(3) exist by auto
<     then have t:"t \<in> existence_ivl0 (flow0 x (s n))"
<       using domin(1) xt by auto
<     from flow_trans[OF s t]
<     show "flow0 x (t + s n) = flow0 (flow0 x (s n)) t"
<       by (simp add: add.commute)
<   qed
<   have f2: "(flow0 x \<circ> r) \<longlonglongrightarrow> flow0 p t" using f1 unfolding ff .
<   show "flow0 p t \<in> \<omega>_limit_set x" using exist f2 rlim
<     unfolding \<omega>_limit_set_def \<omega>_limit_point_def
<     using flow_in_domain r_def s(3) xa(2) xa(3) by auto
< qed
< 
< lemma \<omega>_limit_set_invariant:
<   shows "invariant (\<omega>_limit_set x)"
<   unfolding invariant_iff_pos_invariant_and_compl_pos_invariant
< proof safe
<   show "positively_invariant (\<omega>_limit_set x)"
<     using \<omega>_limit_set_positively_invariant .
< next
<   show "positively_invariant (X - \<omega>_limit_set x)"
<     unfolding positively_invariant_def trapped_forward_def
<     apply safe
<     using local.flow_in_domain apply blast
<   proof -
<     fix dummy p t 
<     assume xa: "p \<in> X" "p \<notin> \<omega>_limit_set x"
<       "t \<in> existence_ivl0 p" "0 \<le> t"
<       and f: "flow0 p t \<in> \<omega>_limit_set x"
<     have exist: "{0..} \<subseteq> existence_ivl0 x" using f
<       unfolding \<omega>_limit_set_def \<omega>_limit_point_def by auto
<     from f
<     obtain s where s:
<       "filterlim s at_top sequentially"
<       "(flow0 x \<circ> s) \<longlonglongrightarrow> flow0 p t"
<       "\<forall>n. t \<le> s n"
<       unfolding \<omega>_limit_set_def by (auto elim!:\<omega>_limit_pointE)
<     define r where "r = (\<lambda>n. (-t) + s n)"
<     have "(\<lambda>x. -t) \<longlonglongrightarrow> -t" by simp
<     from filterlim_tendsto_add_at_top[OF this s(1)]
<     have rlim: "filterlim r at_top sequentially" unfolding r_def by simp
<     define dom where "dom = image (flow0 x) {t..} \<union> {flow0 p t} "
<     have domin: "\<forall>n. (flow0 x \<circ> s) n \<in> dom" "flow0 p t \<in> dom" unfolding dom_def o_def
<       using exist by(auto simp add: s(3))
<     have xt: "\<And>x. x \<in> dom \<Longrightarrow> -t \<in> existence_ivl0 x" unfolding dom_def using xa(2)
<       apply auto
<       using local.existence_ivl_reverse xa(3) apply auto[1]
<       by (metis exist atLeast_iff diff_conv_add_uminus diff_ge_0_iff_ge linordered_ab_group_add_class.zero_le_double_add_iff_zero_le_single_add local.existence_ivl_trans' order_trans subset_iff xa(4))
<     have cont: "continuous_on dom (\<lambda>x. flow0 x (-t))"
<       apply (rule flow_continuous_on_compose)
<          apply auto
<       using local.mem_existence_ivl_iv_defined(2) xt apply blast
<       by (simp add: xt)
<     then have f1: "((\<lambda>x. flow0 x (-t)) \<circ> (flow0 x \<circ> s)) \<longlonglongrightarrow> flow0 (flow0 p t) (-t)" using domin s(2)
<       unfolding continuous_on_sequentially
<       by blast
<     have ff:"\<And>n. (flow0 x \<circ> r) n = ((\<lambda>x. flow0 x (-t)) \<circ> (flow0 x \<circ> s)) n"
<       unfolding o_def r_def
<     proof -
<       fix n
<       have s:"s n \<in> existence_ivl0 x"
<         using s(3) exist \<open>0\<le> t\<close> by (meson atLeast_iff order_trans subset_eq)
<       then have t:"-t \<in> existence_ivl0 (flow0 x (s n))"
<         using domin(1) xt by auto
<       from flow_trans[OF s t]
<       show "flow0 x (-t + s n) = flow0 (flow0 x (s n)) (-t)"
<         by (simp add: add.commute)
<     qed
<     have "(flow0 x \<circ> r) \<longlonglongrightarrow> flow0 (flow0 p t) (-t)" using f1 unfolding ff .
<     then have f2: "(flow0 x \<circ> r) \<longlonglongrightarrow> p" using flows_reverse xa(3) by auto
<     then have "p \<in> \<omega>_limit_set x" unfolding \<omega>_limit_set_def \<omega>_limit_point_def
<       using rlim exist by auto
<     thus False using xa(2) by auto
<   qed
< qed
< 
< end context auto_ll_on_open begin
< 
< lemma \<alpha>_limit_set_eq:
<   assumes "{..0} \<subseteq> existence_ivl0 x"
<   shows "\<alpha>_limit_set x = (INF \<tau> \<in> {..0}. closure (flow0 x ` {..\<tau>}))"
<   using rev.\<omega>_limit_set_eq[of x, OF assms[folded infinite_rev_existence_ivl0_rewrites]]
<   unfolding \<alpha>_limit_set_eq_rev rev_flow_image_eq image_uminus_atLeast 
<   by (smt INT_extend_simps(10) Sup.SUP_cong image_uminus_atMost)
< 
< lemma \<alpha>_limit_set_closed:
<   shows "closed (\<alpha>_limit_set x)"
<   unfolding \<alpha>_limit_set_eq_rev by (rule rev.\<omega>_limit_set_closed)
< 
< lemma \<alpha>_limit_set_positively_invariant:
<   shows "negatively_invariant (\<alpha>_limit_set x)"
<   unfolding negatively_invariant_eq_rev \<alpha>_limit_set_eq_rev
<   by (simp add: rev.\<omega>_limit_set_positively_invariant)
< 
< lemma \<alpha>_limit_set_invariant:
<   shows "invariant (\<alpha>_limit_set x)"
<   unfolding invariant_eq_rev \<alpha>_limit_set_eq_rev
<   by (simp add: rev.\<omega>_limit_set_invariant)
< 
< text \<open> Fundamental properties of the positive limit set \<close>
< 
< context
<   fixes x K
<   assumes K: "compact K" "K \<subseteq> X"
<   assumes x: "x \<in> X" "trapped_forward x K"
< begin
< 
< text \<open>Bunch of facts for what's to come\<close>
< private lemma props:
<   shows "{0..} \<subseteq> existence_ivl0 x" "seq_compact K"
<    apply (rule trapped_sol_right)
<   using x K by (auto simp add: compact_imp_seq_compact)
< 
< private lemma flowimg:
<   shows "flow0 x ` (existence_ivl0 x \<inter> {0..}) = flow0 x ` {0..}"
<   using props(1) by auto
< 
< lemma \<omega>_limit_set_in_compact_subset:
<   shows "\<omega>_limit_set x \<subseteq> K"
<   unfolding \<omega>_limit_set_def
< proof safe
<   fix p s
<   assume "\<omega>_limit_point x p"
<   from \<omega>_limit_pointE[OF this]
<   obtain s where s:
<     "filterlim s at_top sequentially"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>n. 0 \<le> s n" by blast
<   then have fin: "\<forall>n. (flow0 x \<circ> s) n \<in> K" using s(3) x K props(1)
<     unfolding trapped_forward_def
<     by (simp add: subset_eq)
<   from seq_compactE[OF props(2) fin]
<   show "p \<in> K" using s(2)
<     by (metis LIMSEQ_subseq_LIMSEQ LIMSEQ_unique)
< qed
< 
< lemma \<omega>_limit_set_in_compact_compact:
<   shows "compact (\<omega>_limit_set x)"
< proof -
<   from \<omega>_limit_set_in_compact_subset 
<   have "bounded (\<omega>_limit_set x)"
<     using bounded_subset compact_imp_bounded
<     using K(1) by auto
<   thus ?thesis using \<omega>_limit_set_closed
<     by (simp add: compact_eq_bounded_closed)
< qed
< 
< lemma \<omega>_limit_set_in_compact_nonempty:
<   shows "\<omega>_limit_set x \<noteq> {}"
< proof -
<   have fin: "\<forall>n. (flow0 x \<circ> real) n \<in> K" using x K props(1)
<     by (simp add: flowimg image_subset_iff trapped_forward_def)
<   from seq_compactE[OF props(2) this]
<   obtain r l where "l \<in> K" "strict_mono r" "(flow0 x \<circ> real \<circ> r) \<longlonglongrightarrow> l" by blast
<   then have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1)
<     by (smt comp_def filterlim_sequentially_iff_filterlim_real filterlim_subseq tendsto_at_top_eq_left)
<   thus ?thesis unfolding \<omega>_limit_set_def by auto
< qed
< 
< lemma \<omega>_limit_set_in_compact_existence:
<   shows "\<And>y. y \<in> \<omega>_limit_set x \<Longrightarrow> existence_ivl0 y = UNIV"
< proof -
<   fix y
<   assume y: "y \<in> \<omega>_limit_set x"
<   then have "y \<in> X" using \<omega>_limit_set_in_compact_subset K by blast 
<   from \<omega>_limit_set_invariant
<   have "\<And>t. t \<in> existence_ivl0 y \<Longrightarrow> flow0 y t \<in> \<omega>_limit_set x"
<     unfolding invariant_def trapped_iff_on_existence_ivl0 using y by blast 
<   then have t: "\<And>t. t \<in> existence_ivl0 y \<Longrightarrow> flow0 y t \<in> K"
<     using \<omega>_limit_set_in_compact_subset by blast
<   thus "existence_ivl0 y = UNIV" 
<     by (meson \<open>y \<in> X\<close> existence_ivl_zero existence_ivl_initial_time_iff existence_ivl_subset mem_compact_implies_subset_existence_interval subset_antisym K)
< qed
< 
< lemma \<omega>_limit_set_in_compact_tendsto:
<   shows "((\<lambda>t. infdist (flow0 x t) (\<omega>_limit_set x)) \<longlongrightarrow> 0) at_top"
< proof (rule ccontr)
<   assume "\<not> ((\<lambda>t. infdist (flow0 x t) (\<omega>_limit_set x)) \<longlongrightarrow> 0) at_top"
<   from not_tendsto_frequentlyE[OF this]
<   obtain S where S: "open S" "0 \<in> S"
<     "\<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<notin> S" .
<   then obtain e where "e > 0" "ball 0 e \<subseteq> S" using openE by blast
<   then have "\<And>x. x \<ge>0 \<Longrightarrow> x \<notin> S \<Longrightarrow> x \<ge> e" by force
<   then have "\<forall>xa. infdist (flow0 x xa) (\<omega>_limit_set x) \<notin> S \<longrightarrow>
<         infdist (flow0 x xa) (\<omega>_limit_set x) \<ge> e" using infdist_nonneg by blast  
<   from frequently_mono[OF this S(3)]
<   have "\<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<ge> e" by blast
<   then have "\<forall>n. \<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<ge> e \<and> real n \<le> t"
<     by (auto intro!: eventually_frequently_conj)
<   from frequently_at_topE[OF this]
<   obtain s where s: "\<And>i. e \<le> infdist (flow0 x (s i)) (\<omega>_limit_set x)"
<     "\<And>i. real i \<le> s i" "strict_mono s" by force
<   then have sf: "filterlim s at_top sequentially"
<     using filterlim_at_top_mono filterlim_real_sequentially not_eventuallyD by blast 
<   have fin: "\<forall>n. (flow0 x \<circ> s) n \<in> K"  using x K props(1) s unfolding flowimg trapped_forward_def
<     by (metis atLeast_iff comp_apply image_subset_iff of_nat_0_le_iff order_trans)
<   from seq_compactE[OF props(2) this]
<   obtain r l where r:"strict_mono r" and l: "l \<in> K" "(flow0 x \<circ> s \<circ> r) \<longlonglongrightarrow> l" by blast
<   moreover from filterlim_at_top_strict_mono[OF s(3) r(1) sf]
<   have "filterlim (s \<circ> r) at_top sequentially" .
<   moreover have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1) calculation
<     by (metis comp_assoc)
<   ultimately have "infdist l (\<omega>_limit_set x) = 0" by (simp add: \<omega>_limit_set_def)
<   then have c1:"((\<lambda>y. infdist y (\<omega>_limit_set x)) \<circ> (flow0 x \<circ> s \<circ> r)) \<longlonglongrightarrow> 0"
<     using l(2) continuous_on_infdist
<     by (metis UNIV_I continuous_on_sequentially)
<   have c2: "\<And>i. e \<le> infdist (flow0 x ((s \<circ> r) i)) (\<omega>_limit_set x)" using s(1) by simp
<   show False using c1 c2 \<open>e > 0\<close> unfolding o_def
<     using Lim_bounded2 s(1) by fastforce
< qed
< 
< lemma \<omega>_limit_set_in_compact_connected:
<   shows "connected (\<omega>_limit_set x)"
<   unfolding connected_closed_set[OF \<omega>_limit_set_closed]
< proof clarsimp
<   fix Apre Bpre
<   assume pre: "closed Apre" "Apre \<union> Bpre = \<omega>_limit_set x" "closed Bpre"
<     "Apre \<noteq> {}" "Bpre \<noteq> {}" "Apre \<inter> Bpre = {}"
<     (* TODO: this move is very strange *)
<   then obtain A B where "Apre \<subseteq> A" "Bpre \<subseteq> B" "open A" "open B" and disj:"A \<inter> B = {}"
<     by (meson t4_space)
<   then have "\<omega>_limit_set x \<subseteq> A \<union> B"
<     "\<omega>_limit_set x \<inter> A \<noteq> {}" "\<omega>_limit_set x \<inter> B \<noteq> {}" using pre by auto
<   then obtain p q where
<     p: "\<omega>_limit_point x p" "p \<in> A"
<     and q: "\<omega>_limit_point x q" "q \<in> B"
<     using \<omega>_limit_set_def by auto
<   from \<omega>_limit_pointE[OF p(1)]
<   obtain ps where ps: "filterlim ps at_top sequentially"
<     "(flow0 x \<circ> ps) \<longlonglongrightarrow> p" "\<forall>n. 0 \<le> ps n" by blast
<   from \<omega>_limit_pointE[OF q(1)]
<   obtain qs where qs: "filterlim qs at_top sequentially"
<     "(flow0 x \<circ> qs) \<longlonglongrightarrow> q" "\<forall>n. 0 \<le> qs n" by blast
<   have "\<forall>n. \<exists>\<^sub>F t in at_top. flow0 x t \<notin> A \<and> flow0 x t \<notin> B" unfolding frequently_at_top
<   proof safe
<     fix dummy mpre
<     obtain m where "m \<ge> (0::real)" "m > mpre"
<       by (meson approximation_preproc_push_neg(1) gt_ex le_cases order_trans) 
<     from ps obtain a where a:"a > m" "(flow0 x a) \<in> A"
<       using \<open>open A\<close> p unfolding tendsto_explicit filterlim_at_top eventually_sequentially
<       by (metis approximation_preproc_push_neg(1) comp_apply gt_ex le_cases order_trans)
<     from qs obtain b where b:"b > a" "(flow0 x b) \<in> B"
<       using \<open>open B\<close> q unfolding tendsto_explicit filterlim_at_top eventually_sequentially
<       by (metis approximation_preproc_push_neg(1) comp_apply gt_ex le_cases order_trans)
<     have "continuous_on {a..b} (flow0 x)"
<       by (metis Icc_subset_Ici_iff \<open>0 \<le> m\<close> \<open>m < a\<close> approximation_preproc_push_neg(2) atMost_iff atMost_subset_iff continuous_on_subset le_cases local.flow_continuous_on props(1) subset_eq)
<     from connected_continuous_image[OF this connected_Icc]
<     have c:"connected (flow0 x ` {a..b})" .
<     have "\<exists>t\<in> {a..b}. flow0 x t \<notin> A \<and> flow0 x t \<notin> B"
<     proof (rule ccontr)
<       assume "\<not> (\<exists>t\<in>{a..b}. flow0 x t \<notin> A \<and> flow0 x t \<notin> B)"
<       then have "flow0 x ` {a..b} \<subseteq> A \<union> B" by blast
<       from connectedD[OF c \<open>open A\<close> \<open>open B\<close> this]
<       show False using a b disj by force
<     qed
<     thus "\<exists>n>mpre. flow0 x n \<notin> A \<and> flow0 x n \<notin> B"
<       by (smt \<open>mpre < m\<close> a(1) atLeastAtMost_iff) 
<   qed
<   from frequently_at_topE'[OF this filterlim_real_sequentially]
<   obtain s where s: "\<forall>i. flow0 x (s i) \<notin> A \<and> flow0 x (s i) \<notin> B"
<     "strict_mono s" "\<And>n. real n \<le> s n" by blast
<   then have "\<forall>n. (flow0 x \<circ> s) n \<in> K"
<     by (smt atLeast_iff comp_apply flowimg image_subset_iff of_nat_0_le_iff trapped_forward_def x(2))
<   from seq_compactE[OF props(2) this]
<   obtain r l where r: "l \<in> K" "strict_mono r" "(flow0 x \<circ> s \<circ> r) \<longlonglongrightarrow> l" by blast
<   have "filterlim s at_top sequentially"
<     using s filterlim_at_top_mono filterlim_real_sequentially not_eventuallyD by blast 
<   from filterlim_at_top_strict_mono[OF s(2) r(2) this]
<   have "filterlim (s \<circ> r) at_top sequentially" .
<   then have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1) r
<     by (metis comp_assoc)
<   moreover have "l \<notin> A" using s(1) r(3) \<open>open A\<close> unfolding tendsto_explicit by auto
<   moreover have "l \<notin> B" using s(1) r(3) \<open>open B\<close> unfolding tendsto_explicit by auto
<   ultimately show False using \<open>\<omega>_limit_set x \<subseteq> A \<union> B\<close> unfolding \<omega>_limit_set_def
<     by auto
< qed
< 
< lemma \<omega>_limit_set_in_compact_\<omega>_limit_set_contained:
<   shows "\<forall>y \<in> \<omega>_limit_set x. \<omega>_limit_set y \<subseteq> \<omega>_limit_set x"
< proof safe
<   fix y z
<   assume "y \<in> \<omega>_limit_set x" "z \<in> \<omega>_limit_set y"
<   then have "\<omega>_limit_point y z" unfolding \<omega>_limit_set_def by auto
<   from \<omega>_limit_pointE[OF this]
<   obtain s where s: "(flow0 y \<circ> s) \<longlonglongrightarrow> z" .
<   have "\<forall>n. (flow0 y \<circ> s) n \<in> \<omega>_limit_set x"
<     using \<open>y \<in> \<omega>_limit_set x\<close> invariant_def
<       \<omega>_limit_set_in_compact_existence \<omega>_limit_set_invariant trapped_iff_on_existence_ivl0
<     by force
<   thus "z \<in> \<omega>_limit_set x" using closed_sequential_limits s \<omega>_limit_set_closed
<     by blast
< qed
< 
< lemma \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained:
<   assumes zpx: "z \<in> \<omega>_limit_set x"
<   shows "\<alpha>_limit_set z \<subseteq> \<omega>_limit_set x"
< proof
<   fix w assume "w \<in> \<alpha>_limit_set z"
<   then obtain s where s: "(flow0 z \<circ> s) \<longlonglongrightarrow> w"
<     unfolding \<alpha>_limit_set_def \<alpha>_limit_point_def
<     by auto
<   from \<omega>_limit_set_invariant have "invariant (\<omega>_limit_set x)" .
<   then have "\<forall>n. (flow0 z \<circ> s) n \<in> \<omega>_limit_set x"
<     using \<omega>_limit_set_in_compact_existence[OF zpx] zpx
<     using invariant_def trapped_iff_on_existence_ivl0 by fastforce
<   from closed_sequentially[OF \<omega>_limit_set_closed this s]
<   show "w \<in> \<omega>_limit_set x" .
< qed
< 
< end
< 
< text \<open> Fundamental properties of the negative limit set \<close>
< 
< end context auto_ll_on_open begin
< 
< context
<   fixes x K
<   assumes x: "x \<in> X" "trapped_backward x K"
<   assumes K: "compact K" "K \<subseteq> X"
< begin
< 
< private lemma xrev: "x \<in> X" "rev.trapped_forward x K"
<   using trapped_backward_iff_rev_trapped_forward x(2) 
<   by (auto simp: rev_existence_ivl_eq0 rev_eq_flow x(1))
< 
< lemma \<alpha>_limit_set_in_compact_subset: "\<alpha>_limit_set x \<subseteq> K"
<   and \<alpha>_limit_set_in_compact_compact: "compact (\<alpha>_limit_set x)"
<   and \<alpha>_limit_set_in_compact_nonempty: "\<alpha>_limit_set x \<noteq> {}"
<   and \<alpha>_limit_set_in_compact_connected: "connected (\<alpha>_limit_set x)"
<   and \<alpha>_limit_set_in_compact_\<alpha>_limit_set_contained:
<   "\<forall>y \<in> \<alpha>_limit_set x. \<alpha>_limit_set y \<subseteq> \<alpha>_limit_set x"
<   and \<alpha>_limit_set_in_compact_tendsto: "((\<lambda>t. infdist (flow0 x t) (\<alpha>_limit_set x)) \<longlongrightarrow> 0) at_bot"
<   using rev.\<omega>_limit_set_in_compact_subset[OF K xrev]
<   using rev.\<omega>_limit_set_in_compact_compact[OF K xrev]
<   using rev.\<omega>_limit_set_in_compact_nonempty[OF K xrev]
<   using rev.\<omega>_limit_set_in_compact_connected[OF K xrev]
<   using rev.\<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF K xrev]
<   using rev.\<omega>_limit_set_in_compact_tendsto[OF K xrev]
<   unfolding invariant_eq_rev \<alpha>_limit_set_eq_rev existence_ivl_eq_rev flow_eq_rev0 filterlim_at_bot_mirror
<     minus_minus
<   .
< 
< lemma \<alpha>_limit_set_in_compact_existence:
<   shows "\<And>y. y \<in> \<alpha>_limit_set x \<Longrightarrow> existence_ivl0 y = UNIV"
<   using rev.\<omega>_limit_set_in_compact_existence[OF K xrev]
<   unfolding \<alpha>_limit_set_eq_rev existence_ivl_eq_rev0
<   by auto
< 
< end
< end
< 
< end
---
> section \<open>Limit Sets\<close>
> theory Limit_Set
>   imports Invariance
> begin
> 
> context auto_ll_on_open begin
> text \<open>Positive limit point, assuming \<open>{0..} \<subseteq> existence_ivl0 x\<close>\<close>
> 
> (* TODO: Perhaps a more intrinsic definition would be better here *)
> definition "\<omega>_limit_point x p \<longleftrightarrow>
>   {0..} \<subseteq> existence_ivl0 x \<and>
>   (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> p)"
> 
> text \<open> Also called the \<open>\<omega>\<close>-limit set of x \<close>
> definition "\<omega>_limit_set x = {p. \<omega>_limit_point x p}"
> 
> definition "\<alpha>_limit_point x p \<longleftrightarrow>
>   {..0} \<subseteq> existence_ivl0 x \<and>
>   (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> p)"
> 
> text \<open> Also called the \<open>\<alpha>\<close>-limit set of x \<close>
> definition "\<alpha>_limit_set x =
>   {p. \<alpha>_limit_point x p}"
> 
> end context auto_ll_on_open begin
> 
> lemma \<alpha>_limit_point_eq_rev: "\<alpha>_limit_point x p = rev.\<omega>_limit_point x p"
>   unfolding \<alpha>_limit_point_def rev.\<omega>_limit_point_def
>   apply (auto simp: rev_eq_flow[abs_def] o_def filterlim_uminus_at_bot rev_existence_ivl_eq0 subset_iff
>       intro: exI[where x="uminus o s" for s])
>   using neg_0_le_iff_le by fastforce
> 
> lemma \<alpha>_limit_set_eq_rev: "\<alpha>_limit_set x = rev.\<omega>_limit_set x"
>   unfolding \<alpha>_limit_set_def rev.\<omega>_limit_set_def \<alpha>_limit_point_eq_rev ..
> 
> lemma \<omega>_limit_pointE:
>   assumes "\<omega>_limit_point x p"
>   obtains s where
>     "filterlim s at_top sequentially"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>n. b \<le> s n"
>   using assms filterlim_at_top_choose_lower \<omega>_limit_point_def by blast
> 
> lemma \<omega>_limit_set_eq:
>   assumes "{0..} \<subseteq> existence_ivl0 x"
>   shows "\<omega>_limit_set x = (INF \<tau> \<in> {0..}. closure (flow0 x ` {\<tau>..}))"
>   unfolding \<omega>_limit_set_def
> proof safe
>   fix p t
>   assume pt: "0 \<le> (t::real)" "\<omega>_limit_point x p"
>   from \<omega>_limit_pointE[OF pt(2)]
>   obtain s where
>     "filterlim s at_top sequentially"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>n. t \<le> s n" by blast
>   thus "p \<in> closure (flow0 x ` {t..})" unfolding closure_sequential
>     by (metis atLeast_iff comp_apply imageI)
> next
>   fix p
>   assume "p \<in> (\<Inter>\<tau>\<in>{0..}. closure (flow0 x ` {\<tau>..}))"
>   then have "\<And>t. t \<ge>0 \<Longrightarrow> p \<in> closure (flow0 x ` {t..})" by blast
>   then have "\<And>t e. t \<ge>0 \<Longrightarrow> e > 0 \<Longrightarrow> (\<exists>tt \<ge> t. dist (flow0 x tt) p < e)"
>     unfolding closure_approachable
>     by fastforce
>   from approachable_sequenceE[OF this]
>   obtain s where "filterlim s at_top sequentially" "(flow0 x \<circ> s) \<longlonglongrightarrow> p" by auto
>   thus "\<omega>_limit_point x p" unfolding \<omega>_limit_point_def using assms by auto
> qed
> 
> lemma \<omega>_limit_set_empty:
>   assumes "\<not> ({0..} \<subseteq> existence_ivl0 x)"
>   shows "\<omega>_limit_set x = {}"
>   unfolding \<omega>_limit_set_def \<omega>_limit_point_def
>   by (simp add: assms)
> 
> lemma \<omega>_limit_set_closed: "closed (\<omega>_limit_set x)"
>   using \<omega>_limit_set_eq
>   by (metis \<omega>_limit_set_empty closed_INT closed_closure closed_empty)
> 
> (* TODO: Walter gives a more direct proof *)
> lemma \<omega>_limit_set_positively_invariant:
>   shows "positively_invariant (\<omega>_limit_set x)"
>   unfolding positively_invariant_def trapped_forward_def
> proof safe
>   fix dummy p t
>   assume xa: "p \<in> \<omega>_limit_set x"
>     "t \<in> existence_ivl0 p"
>     "0 \<le> t"
>   have "p \<in> X" using mem_existence_ivl_iv_defined(2) xa(2) by blast
>   have exist: "{0..} \<subseteq> existence_ivl0 x" using xa(1)
>     unfolding \<omega>_limit_set_def \<omega>_limit_point_def by auto
>   from xa(1)
>   obtain s where s:
>     "filterlim s at_top sequentially"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>n. 0 \<le> s n"
>     unfolding \<omega>_limit_set_def by (auto elim!:\<omega>_limit_pointE)
>   define r where "r = (\<lambda>n. t + s n)"
>   have rlim: "filterlim r at_top sequentially" unfolding r_def
>     by (auto intro: filterlim_tendsto_add_at_top[OF _ s(1)])
>   define dom where "dom = image (flow0 x) {0..} \<union> {p} "
>   have domin: "\<forall>n. (flow0 x \<circ> s) n \<in> dom" "p \<in> dom" unfolding dom_def o_def
>     using exist by(auto simp add: s(3))
>   have xt: "\<And>x. x \<in> dom \<Longrightarrow> t \<in> existence_ivl0 x" unfolding dom_def using xa(2)
>     apply auto
>     apply (rule existence_ivl_trans')
>     using exist xa(3) apply auto[1]
>     using exist  by auto
>   have cont: "continuous_on dom (\<lambda>x. flow0 x t)"
>     apply (rule flow_continuous_on_compose)
>        apply auto
>     using \<open>p \<in> X\<close>  exist local.dom_def local.flow_in_domain apply auto[1]
>     using xt .
>   then have f1: "((\<lambda>x. flow0 x t) \<circ> (flow0 x \<circ> s)) \<longlonglongrightarrow> flow0 p t" using domin s(2)
>     unfolding continuous_on_sequentially
>     by blast
>   have ff:"\<And>n. (flow0 x \<circ> r) n = ((\<lambda>x. flow0 x t) \<circ> (flow0 x \<circ> s)) n"
>     unfolding o_def r_def
>   proof -
>     fix n
>     have s:"s n \<in> existence_ivl0 x"
>       using s(3) exist by auto
>     then have t:"t \<in> existence_ivl0 (flow0 x (s n))"
>       using domin(1) xt by auto
>     from flow_trans[OF s t]
>     show "flow0 x (t + s n) = flow0 (flow0 x (s n)) t"
>       by (simp add: add.commute)
>   qed
>   have f2: "(flow0 x \<circ> r) \<longlonglongrightarrow> flow0 p t" using f1 unfolding ff .
>   show "flow0 p t \<in> \<omega>_limit_set x" using exist f2 rlim
>     unfolding \<omega>_limit_set_def \<omega>_limit_point_def
>     using flow_in_domain r_def s(3) xa(2) xa(3) by auto
> qed
> 
> lemma \<omega>_limit_set_invariant:
>   shows "invariant (\<omega>_limit_set x)"
>   unfolding invariant_iff_pos_invariant_and_compl_pos_invariant
> proof safe
>   show "positively_invariant (\<omega>_limit_set x)"
>     using \<omega>_limit_set_positively_invariant .
> next
>   show "positively_invariant (X - \<omega>_limit_set x)"
>     unfolding positively_invariant_def trapped_forward_def
>     apply safe
>     using local.flow_in_domain apply blast
>   proof -
>     fix dummy p t 
>     assume xa: "p \<in> X" "p \<notin> \<omega>_limit_set x"
>       "t \<in> existence_ivl0 p" "0 \<le> t"
>       and f: "flow0 p t \<in> \<omega>_limit_set x"
>     have exist: "{0..} \<subseteq> existence_ivl0 x" using f
>       unfolding \<omega>_limit_set_def \<omega>_limit_point_def by auto
>     from f
>     obtain s where s:
>       "filterlim s at_top sequentially"
>       "(flow0 x \<circ> s) \<longlonglongrightarrow> flow0 p t"
>       "\<forall>n. t \<le> s n"
>       unfolding \<omega>_limit_set_def by (auto elim!:\<omega>_limit_pointE)
>     define r where "r = (\<lambda>n. (-t) + s n)"
>     have "(\<lambda>x. -t) \<longlonglongrightarrow> -t" by simp
>     from filterlim_tendsto_add_at_top[OF this s(1)]
>     have rlim: "filterlim r at_top sequentially" unfolding r_def by simp
>     define dom where "dom = image (flow0 x) {t..} \<union> {flow0 p t} "
>     have domin: "\<forall>n. (flow0 x \<circ> s) n \<in> dom" "flow0 p t \<in> dom" unfolding dom_def o_def
>       using exist by(auto simp add: s(3))
>     have xt: "\<And>x. x \<in> dom \<Longrightarrow> -t \<in> existence_ivl0 x" unfolding dom_def using xa(2)
>       apply auto
>       using local.existence_ivl_reverse xa(3) apply auto[1]
>       by (metis exist atLeast_iff diff_conv_add_uminus diff_ge_0_iff_ge linordered_ab_group_add_class.zero_le_double_add_iff_zero_le_single_add local.existence_ivl_trans' order_trans subset_iff xa(4))
>     have cont: "continuous_on dom (\<lambda>x. flow0 x (-t))"
>       apply (rule flow_continuous_on_compose)
>          apply auto
>       using local.mem_existence_ivl_iv_defined(2) xt apply blast
>       by (simp add: xt)
>     then have f1: "((\<lambda>x. flow0 x (-t)) \<circ> (flow0 x \<circ> s)) \<longlonglongrightarrow> flow0 (flow0 p t) (-t)" using domin s(2)
>       unfolding continuous_on_sequentially
>       by blast
>     have ff:"\<And>n. (flow0 x \<circ> r) n = ((\<lambda>x. flow0 x (-t)) \<circ> (flow0 x \<circ> s)) n"
>       unfolding o_def r_def
>     proof -
>       fix n
>       have s:"s n \<in> existence_ivl0 x"
>         using s(3) exist \<open>0\<le> t\<close> by (meson atLeast_iff order_trans subset_eq)
>       then have t:"-t \<in> existence_ivl0 (flow0 x (s n))"
>         using domin(1) xt by auto
>       from flow_trans[OF s t]
>       show "flow0 x (-t + s n) = flow0 (flow0 x (s n)) (-t)"
>         by (simp add: add.commute)
>     qed
>     have "(flow0 x \<circ> r) \<longlonglongrightarrow> flow0 (flow0 p t) (-t)" using f1 unfolding ff .
>     then have f2: "(flow0 x \<circ> r) \<longlonglongrightarrow> p" using flows_reverse xa(3) by auto
>     then have "p \<in> \<omega>_limit_set x" unfolding \<omega>_limit_set_def \<omega>_limit_point_def
>       using rlim exist by auto
>     thus False using xa(2) by auto
>   qed
> qed
> 
> end context auto_ll_on_open begin
> 
> lemma \<alpha>_limit_set_eq:
>   assumes "{..0} \<subseteq> existence_ivl0 x"
>   shows "\<alpha>_limit_set x = (INF \<tau> \<in> {..0}. closure (flow0 x ` {..\<tau>}))"
>   using rev.\<omega>_limit_set_eq[of x, OF assms[folded infinite_rev_existence_ivl0_rewrites]]
>   unfolding \<alpha>_limit_set_eq_rev rev_flow_image_eq image_uminus_atLeast 
>   by (smt INT_extend_simps(10) Sup.SUP_cong image_uminus_atMost)
> 
> lemma \<alpha>_limit_set_closed:
>   shows "closed (\<alpha>_limit_set x)"
>   unfolding \<alpha>_limit_set_eq_rev by (rule rev.\<omega>_limit_set_closed)
> 
> lemma \<alpha>_limit_set_positively_invariant:
>   shows "negatively_invariant (\<alpha>_limit_set x)"
>   unfolding negatively_invariant_eq_rev \<alpha>_limit_set_eq_rev
>   by (simp add: rev.\<omega>_limit_set_positively_invariant)
> 
> lemma \<alpha>_limit_set_invariant:
>   shows "invariant (\<alpha>_limit_set x)"
>   unfolding invariant_eq_rev \<alpha>_limit_set_eq_rev
>   by (simp add: rev.\<omega>_limit_set_invariant)
> 
> text \<open> Fundamental properties of the positive limit set \<close>
> 
> context
>   fixes x K
>   assumes K: "compact K" "K \<subseteq> X"
>   assumes x: "x \<in> X" "trapped_forward x K"
> begin
> 
> text \<open>Bunch of facts for what's to come\<close>
> private lemma props:
>   shows "{0..} \<subseteq> existence_ivl0 x" "seq_compact K"
>    apply (rule trapped_sol_right)
>   using x K by (auto simp add: compact_imp_seq_compact)
> 
> private lemma flowimg:
>   shows "flow0 x ` (existence_ivl0 x \<inter> {0..}) = flow0 x ` {0..}"
>   using props(1) by auto
> 
> lemma \<omega>_limit_set_in_compact_subset:
>   shows "\<omega>_limit_set x \<subseteq> K"
>   unfolding \<omega>_limit_set_def
> proof safe
>   fix p s
>   assume "\<omega>_limit_point x p"
>   from \<omega>_limit_pointE[OF this]
>   obtain s where s:
>     "filterlim s at_top sequentially"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>n. 0 \<le> s n" by blast
>   then have fin: "\<forall>n. (flow0 x \<circ> s) n \<in> K" using s(3) x K props(1)
>     unfolding trapped_forward_def
>     by (simp add: subset_eq)
>   from seq_compactE[OF props(2) fin]
>   show "p \<in> K" using s(2)
>     by (metis LIMSEQ_subseq_LIMSEQ LIMSEQ_unique)
> qed
> 
> lemma \<omega>_limit_set_in_compact_compact:
>   shows "compact (\<omega>_limit_set x)"
> proof -
>   from \<omega>_limit_set_in_compact_subset 
>   have "bounded (\<omega>_limit_set x)"
>     using bounded_subset compact_imp_bounded
>     using K(1) by auto
>   thus ?thesis using \<omega>_limit_set_closed
>     by (simp add: compact_eq_bounded_closed)
> qed
> 
> lemma \<omega>_limit_set_in_compact_nonempty:
>   shows "\<omega>_limit_set x \<noteq> {}"
> proof -
>   have fin: "\<forall>n. (flow0 x \<circ> real) n \<in> K" using x K props(1)
>     by (simp add: flowimg image_subset_iff trapped_forward_def)
>   from seq_compactE[OF props(2) this]
>   obtain r l where "l \<in> K" "strict_mono r" "(flow0 x \<circ> real \<circ> r) \<longlonglongrightarrow> l" by blast
>   then have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1)
>     by (smt comp_def filterlim_sequentially_iff_filterlim_real filterlim_subseq tendsto_at_top_eq_left)
>   thus ?thesis unfolding \<omega>_limit_set_def by auto
> qed
> 
> lemma \<omega>_limit_set_in_compact_existence:
>   shows "\<And>y. y \<in> \<omega>_limit_set x \<Longrightarrow> existence_ivl0 y = UNIV"
> proof -
>   fix y
>   assume y: "y \<in> \<omega>_limit_set x"
>   then have "y \<in> X" using \<omega>_limit_set_in_compact_subset K by blast 
>   from \<omega>_limit_set_invariant
>   have "\<And>t. t \<in> existence_ivl0 y \<Longrightarrow> flow0 y t \<in> \<omega>_limit_set x"
>     unfolding invariant_def trapped_iff_on_existence_ivl0 using y by blast 
>   then have t: "\<And>t. t \<in> existence_ivl0 y \<Longrightarrow> flow0 y t \<in> K"
>     using \<omega>_limit_set_in_compact_subset by blast
>   thus "existence_ivl0 y = UNIV" 
>     by (meson \<open>y \<in> X\<close> existence_ivl_zero existence_ivl_initial_time_iff existence_ivl_subset mem_compact_implies_subset_existence_interval subset_antisym K)
> qed
> 
> lemma \<omega>_limit_set_in_compact_tendsto:
>   shows "((\<lambda>t. infdist (flow0 x t) (\<omega>_limit_set x)) \<longlongrightarrow> 0) at_top"
> proof (rule ccontr)
>   assume "\<not> ((\<lambda>t. infdist (flow0 x t) (\<omega>_limit_set x)) \<longlongrightarrow> 0) at_top"
>   from not_tendsto_frequentlyE[OF this]
>   obtain S where S: "open S" "0 \<in> S"
>     "\<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<notin> S" .
>   then obtain e where "e > 0" "ball 0 e \<subseteq> S" using openE by blast
>   then have "\<And>x. x \<ge>0 \<Longrightarrow> x \<notin> S \<Longrightarrow> x \<ge> e" by force
>   then have "\<forall>xa. infdist (flow0 x xa) (\<omega>_limit_set x) \<notin> S \<longrightarrow>
>         infdist (flow0 x xa) (\<omega>_limit_set x) \<ge> e" using infdist_nonneg by blast  
>   from frequently_mono[OF this S(3)]
>   have "\<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<ge> e" by blast
>   then have "\<forall>n. \<exists>\<^sub>F t in at_top. infdist (flow0 x t) (\<omega>_limit_set x) \<ge> e \<and> real n \<le> t"
>     by (auto intro!: eventually_frequently_conj)
>   from frequently_at_topE[OF this]
>   obtain s where s: "\<And>i. e \<le> infdist (flow0 x (s i)) (\<omega>_limit_set x)"
>     "\<And>i. real i \<le> s i" "strict_mono s" by force
>   then have sf: "filterlim s at_top sequentially"
>     using filterlim_at_top_mono filterlim_real_sequentially not_eventuallyD by blast 
>   have fin: "\<forall>n. (flow0 x \<circ> s) n \<in> K"  using x K props(1) s unfolding flowimg trapped_forward_def
>     by (metis atLeast_iff comp_apply image_subset_iff of_nat_0_le_iff order_trans)
>   from seq_compactE[OF props(2) this]
>   obtain r l where r:"strict_mono r" and l: "l \<in> K" "(flow0 x \<circ> s \<circ> r) \<longlonglongrightarrow> l" by blast
>   moreover from filterlim_at_top_strict_mono[OF s(3) r(1) sf]
>   have "filterlim (s \<circ> r) at_top sequentially" .
>   moreover have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1) calculation
>     by (metis comp_assoc)
>   ultimately have "infdist l (\<omega>_limit_set x) = 0" by (simp add: \<omega>_limit_set_def)
>   then have c1:"((\<lambda>y. infdist y (\<omega>_limit_set x)) \<circ> (flow0 x \<circ> s \<circ> r)) \<longlonglongrightarrow> 0"
>     by (auto intro!: tendsto_compose_at[OF l(2)] tendsto_eq_intros)
>   have c2: "\<And>i. e \<le> infdist (flow0 x ((s \<circ> r) i)) (\<omega>_limit_set x)" using s(1) by simp
>   show False using c1 c2 \<open>e > 0\<close> unfolding o_def
>     using Lim_bounded2
>     by (metis (no_types, lifting) ball_eq_empty centre_in_ball empty_iff)
> qed
> 
> lemma \<omega>_limit_set_in_compact_connected:
>   shows "connected (\<omega>_limit_set x)"
>   unfolding connected_closed_set[OF \<omega>_limit_set_closed]
> proof clarsimp
>   fix Apre Bpre
>   assume pre: "closed Apre" "Apre \<union> Bpre = \<omega>_limit_set x" "closed Bpre"
>     "Apre \<noteq> {}" "Bpre \<noteq> {}" "Apre \<inter> Bpre = {}"
>     (* TODO: this move is very strange *)
>   then obtain A B where "Apre \<subseteq> A" "Bpre \<subseteq> B" "open A" "open B" and disj:"A \<inter> B = {}"
>     by (meson t4_space)
>   then have "\<omega>_limit_set x \<subseteq> A \<union> B"
>     "\<omega>_limit_set x \<inter> A \<noteq> {}" "\<omega>_limit_set x \<inter> B \<noteq> {}" using pre by auto
>   then obtain p q where
>     p: "\<omega>_limit_point x p" "p \<in> A"
>     and q: "\<omega>_limit_point x q" "q \<in> B"
>     using \<omega>_limit_set_def by auto
>   from \<omega>_limit_pointE[OF p(1)]
>   obtain ps where ps: "filterlim ps at_top sequentially"
>     "(flow0 x \<circ> ps) \<longlonglongrightarrow> p" "\<forall>n. 0 \<le> ps n" by blast
>   from \<omega>_limit_pointE[OF q(1)]
>   obtain qs where qs: "filterlim qs at_top sequentially"
>     "(flow0 x \<circ> qs) \<longlonglongrightarrow> q" "\<forall>n. 0 \<le> qs n" by blast
>   have "\<forall>n. \<exists>\<^sub>F t in at_top. flow0 x t \<notin> A \<and> flow0 x t \<notin> B" unfolding frequently_at_top
>   proof safe
>     fix dummy mpre
>     obtain m where "m \<ge> (0::real)" "m > mpre"
>       by (meson approximation_preproc_push_neg(1) gt_ex le_cases order_trans) 
>     from ps obtain a where a:"a > m" "(flow0 x a) \<in> A"
>       using \<open>open A\<close> p unfolding tendsto_def filterlim_at_top eventually_sequentially
>       by (metis approximation_preproc_push_neg(1) comp_apply gt_ex le_cases order_trans)
>     from qs obtain b where b:"b > a" "(flow0 x b) \<in> B"
>       using \<open>open B\<close> q unfolding tendsto_def filterlim_at_top eventually_sequentially
>       by (metis approximation_preproc_push_neg(1) comp_apply gt_ex le_cases order_trans)
>     have "continuous_on {a..b} (flow0 x)"
>       by (metis Icc_subset_Ici_iff \<open>0 \<le> m\<close> \<open>m < a\<close> approximation_preproc_push_neg(2) atMost_iff atMost_subset_iff continuous_on_subset le_cases local.flow_continuous_on props(1) subset_eq)
>     from connected_continuous_image[OF this connected_Icc]
>     have c:"connected (flow0 x ` {a..b})" .
>     have "\<exists>t\<in> {a..b}. flow0 x t \<notin> A \<and> flow0 x t \<notin> B"
>     proof (rule ccontr)
>       assume "\<not> (\<exists>t\<in>{a..b}. flow0 x t \<notin> A \<and> flow0 x t \<notin> B)"
>       then have "flow0 x ` {a..b} \<subseteq> A \<union> B" by blast
>       from topological_space_class.connectedD[OF c \<open>open A\<close> \<open>open B\<close> _ this]
>       show False using a b disj by force
>     qed
>     thus "\<exists>n>mpre. flow0 x n \<notin> A \<and> flow0 x n \<notin> B"
>       by (smt \<open>mpre < m\<close> a(1) atLeastAtMost_iff)
>   qed
>   from frequently_at_topE'[OF this filterlim_real_sequentially]
>   obtain s where s: "\<forall>i. flow0 x (s i) \<notin> A \<and> flow0 x (s i) \<notin> B"
>     "strict_mono s" "\<And>n. real n \<le> s n" by blast
>   then have "\<forall>n. (flow0 x \<circ> s) n \<in> K"
>     by (smt atLeast_iff comp_apply flowimg image_subset_iff of_nat_0_le_iff trapped_forward_def x(2))
>   from seq_compactE[OF props(2) this]
>   obtain r l where r: "l \<in> K" "strict_mono r" "(flow0 x \<circ> s \<circ> r) \<longlonglongrightarrow> l" by blast
>   have "filterlim s at_top sequentially"
>     using s filterlim_at_top_mono filterlim_real_sequentially not_eventuallyD by blast 
>   from filterlim_at_top_strict_mono[OF s(2) r(2) this]
>   have "filterlim (s \<circ> r) at_top sequentially" .
>   then have "\<omega>_limit_point x l" unfolding \<omega>_limit_point_def using props(1) r
>     by (metis comp_assoc)
>   moreover have "l \<notin> A" using s(1) r(3) \<open>open A\<close> unfolding tendsto_def by auto
>   moreover have "l \<notin> B" using s(1) r(3) \<open>open B\<close> unfolding tendsto_def by auto
>   ultimately show False using \<open>\<omega>_limit_set x \<subseteq> A \<union> B\<close> unfolding \<omega>_limit_set_def
>     by auto
> qed
> 
> lemma \<omega>_limit_set_in_compact_\<omega>_limit_set_contained:
>   shows "\<forall>y \<in> \<omega>_limit_set x. \<omega>_limit_set y \<subseteq> \<omega>_limit_set x"
> proof safe
>   fix y z
>   assume "y \<in> \<omega>_limit_set x" "z \<in> \<omega>_limit_set y"
>   then have "\<omega>_limit_point y z" unfolding \<omega>_limit_set_def by auto
>   from \<omega>_limit_pointE[OF this]
>   obtain s where s: "(flow0 y \<circ> s) \<longlonglongrightarrow> z" .
>   have "\<forall>n. (flow0 y \<circ> s) n \<in> \<omega>_limit_set x"
>     using \<open>y \<in> \<omega>_limit_set x\<close> invariant_def
>       \<omega>_limit_set_in_compact_existence \<omega>_limit_set_invariant trapped_iff_on_existence_ivl0
>     by force
>   thus "z \<in> \<omega>_limit_set x" using closed_sequential_limits s \<omega>_limit_set_closed
>     by blast
> qed
> 
> lemma \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained:
>   assumes zpx: "z \<in> \<omega>_limit_set x"
>   shows "\<alpha>_limit_set z \<subseteq> \<omega>_limit_set x"
> proof
>   fix w assume "w \<in> \<alpha>_limit_set z"
>   then obtain s where s: "(flow0 z \<circ> s) \<longlonglongrightarrow> w"
>     unfolding \<alpha>_limit_set_def \<alpha>_limit_point_def
>     by auto
>   from \<omega>_limit_set_invariant have "invariant (\<omega>_limit_set x)" .
>   then have "\<forall>n. (flow0 z \<circ> s) n \<in> \<omega>_limit_set x"
>     using \<omega>_limit_set_in_compact_existence[OF zpx] zpx
>     using invariant_def trapped_iff_on_existence_ivl0 by fastforce
>   from closed_sequentially[OF \<omega>_limit_set_closed this s]
>   show "w \<in> \<omega>_limit_set x" .
> qed
> 
> end
> 
> text \<open> Fundamental properties of the negative limit set \<close>
> 
> end context auto_ll_on_open begin
> 
> context
>   fixes x K
>   assumes x: "x \<in> X" "trapped_backward x K"
>   assumes K: "compact K" "K \<subseteq> X"
> begin
> 
> private lemma xrev: "x \<in> X" "rev.trapped_forward x K"
>   using trapped_backward_iff_rev_trapped_forward x(2) 
>   by (auto simp: rev_existence_ivl_eq0 rev_eq_flow x(1))
> 
> lemma \<alpha>_limit_set_in_compact_subset: "\<alpha>_limit_set x \<subseteq> K"
>   and \<alpha>_limit_set_in_compact_compact: "compact (\<alpha>_limit_set x)"
>   and \<alpha>_limit_set_in_compact_nonempty: "\<alpha>_limit_set x \<noteq> {}"
>   and \<alpha>_limit_set_in_compact_connected: "connected (\<alpha>_limit_set x)"
>   and \<alpha>_limit_set_in_compact_\<alpha>_limit_set_contained:
>   "\<forall>y \<in> \<alpha>_limit_set x. \<alpha>_limit_set y \<subseteq> \<alpha>_limit_set x"
>   and \<alpha>_limit_set_in_compact_tendsto: "((\<lambda>t. infdist (flow0 x t) (\<alpha>_limit_set x)) \<longlongrightarrow> 0) at_bot"
>   using rev.\<omega>_limit_set_in_compact_subset[OF K xrev]
>   using rev.\<omega>_limit_set_in_compact_compact[OF K xrev]
>   using rev.\<omega>_limit_set_in_compact_nonempty[OF K xrev]
>   using rev.\<omega>_limit_set_in_compact_connected[OF K xrev]
>   using rev.\<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF K xrev]
>   using rev.\<omega>_limit_set_in_compact_tendsto[OF K xrev]
>   unfolding invariant_eq_rev \<alpha>_limit_set_eq_rev existence_ivl_eq_rev flow_eq_rev0 filterlim_at_bot_mirror
>     minus_minus
>   .
> 
> lemma \<alpha>_limit_set_in_compact_existence:
>   shows "\<And>y. y \<in> \<alpha>_limit_set x \<Longrightarrow> existence_ivl0 y = UNIV"
>   using rev.\<omega>_limit_set_in_compact_existence[OF K xrev]
>   unfolding \<alpha>_limit_set_eq_rev existence_ivl_eq_rev0
>   by auto
> 
> end
> end
> 
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/ODE_Misc.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/ODE_Misc.thy
1,1110c1,1110
< section \<open>Additions to the ODE Library\<close>
< theory ODE_Misc
<   imports
<     Ordinary_Differential_Equations.ODE_Analysis
<     Analysis_Misc
< begin
< 
< lemma local_lipschitz_compact_bicomposeE:
<   assumes ll: "local_lipschitz T X f"
<   assumes cf: "\<And>x. x \<in> X \<Longrightarrow> continuous_on I (\<lambda>t. f t x)"
<   assumes cI: "compact I"
<   assumes "I \<subseteq> T"
<   assumes cv: "continuous_on I v"
<   assumes cw: "continuous_on I w"
<   assumes v: "v ` I \<subseteq> X"
<   assumes w: "w ` I \<subseteq> X"
<   obtains L where "L > 0" "\<And>x. x \<in> I \<Longrightarrow> dist (f x (v x)) (f x (w x)) \<le> L * dist (v x) (w x)"
< proof -
<   from v w have "v ` I \<union> w ` I \<subseteq> X" by auto
<   with ll \<open>I \<subseteq> T\<close> have llI:"local_lipschitz I (v ` I \<union> w ` I) f"
<     by (rule local_lipschitz_subset)
<   have cvwI: "compact (v ` I \<union> w ` I)"
<     by (auto intro!: compact_continuous_image cv cw cI)    
< 
<   from local_lipschitz_compact_implies_lipschitz[OF llI cvwI \<open>compact I\<close> cf]
<   obtain L where L: "\<And>t. t \<in> I \<Longrightarrow> L-lipschitz_on (v ` I \<union> w ` I) (f t)"
<     using v w
<     by blast
<   define L' where "L' = max L 1"
<   with L have "L' > 0" "\<And>x. x \<in> I \<Longrightarrow> dist (f x (v x)) (f x (w x)) \<le> L' * dist (v x) (w x)"
<      apply (auto simp: lipschitz_on_def L'_def)
<     by (smt Un_iff image_eqI mult_right_mono zero_le_dist)
<   then show ?thesis ..
< qed
< 
< subsection \<open>Comparison Principle\<close>
< 
< lemma comparison_principle_le:
<   fixes f::"real \<Rightarrow> real \<Rightarrow> real"
<     and \<phi> \<psi>::"real \<Rightarrow> real"
<   assumes ll: "local_lipschitz X Y f"
<   assumes cf: "\<And>x. x \<in> Y \<Longrightarrow> continuous_on {a..b} (\<lambda>t. f t x)"
<   assumes abX: "{a .. b} \<subseteq> X"
<   assumes \<phi>': "\<And>x. x \<in> {a .. b} \<Longrightarrow> (\<phi> has_real_derivative \<phi>' x) (at x)"
<   assumes \<psi>': "\<And>x. x \<in> {a .. b} \<Longrightarrow> (\<psi> has_real_derivative \<psi>' x) (at x)"
<   assumes \<phi>_in: "\<phi> ` {a..b} \<subseteq> Y"
<   assumes \<psi>_in: "\<psi> ` {a..b} \<subseteq> Y"
<   assumes init: "\<phi> a \<le> \<psi> a"
<   assumes defect: "\<And>x. x \<in> {a .. b} \<Longrightarrow> \<phi>' x - f x (\<phi> x) \<le> \<psi>' x - f x (\<psi> x)"
<   shows "\<forall>x \<in> {a .. b}. \<phi> x \<le> \<psi> x" (is "?th1")
<     (*
<     "(\<forall>x \<in> {a .. b}. \<phi> x < \<psi> x) \<or> (\<exists>c\<in>{a..b}. (\<forall>x\<in>{a..c}. \<phi> x \<le> \<psi> x) \<and> (\<forall>x\<in>{c<..b}. \<phi> x < \<psi> x))"
<     (is "?th2")
< *)
<   unfolding atomize_conj
<   apply (cases "a \<le> b")
<    defer subgoal by simp
< proof -
<   assume "a \<le> b"
<   note \<phi>_cont = has_real_derivative_imp_continuous_on[OF \<phi>']
<   note \<psi>_cont = has_real_derivative_imp_continuous_on[OF \<psi>']
<   from local_lipschitz_compact_bicomposeE[OF ll cf compact_Icc abX \<phi>_cont \<psi>_cont \<phi>_in \<psi>_in]
<   obtain L where L: "L > 0" "\<And>x. x \<in> {a..b} \<Longrightarrow> dist (f x (\<phi> x)) (f x (\<psi> x)) \<le> L * dist (\<phi> x) (\<psi> x)" by blast
<   define w where "w x = \<psi> x - \<phi> x" for x
< 
<   have w'[derivative_intros]: "\<And>x. x \<in> {a .. b} \<Longrightarrow> (w has_real_derivative \<psi>' x - \<phi>' x) (at x)"
<     using \<phi>' \<psi>'
<     by (auto simp: has_vderiv_on_def w_def[abs_def] intro!: derivative_eq_intros)
<   note w_cont[continuous_intros] = has_real_derivative_imp_continuous_on[OF w', THEN continuous_on_compose2]
<   have "w d \<ge> 0" if "d \<in> {a .. b}" for d
<   proof (rule ccontr, unfold not_le)
<     assume "w d < 0"
<     let ?N = "(w -` {..0} \<inter> {a .. d})"
<     from \<open>w d < 0\<close> that have "d \<in> ?N" by auto
<     then have "?N \<noteq> {}" by auto
<     have "closed ?N"
<       unfolding compact_eq_bounded_closed
<       using that
<       by (intro conjI closed_vimage_Int) (auto intro!: continuous_intros)
< 
<     let ?N' = "{a0 \<in> {a .. d}. w ` {a0 .. d} \<subseteq> {..0}}"
<     from \<open>w d < 0\<close> that have "d \<in> ?N'" by simp
<     then have "?N' \<noteq> {}" by auto
<     have "compact ?N'"
<       unfolding compact_eq_bounded_closed
<     proof
<       have "?N' \<subseteq> {a .. d}" using that by auto
<       then show "bounded ?N'"
<         by (rule bounded_subset[rotated]) simp
<       have "w u \<le> 0" if "(\<forall>n. x n \<in> ?N')" "x \<longlonglongrightarrow> l" "l \<le> u" "u \<le> d" for x l u
<       proof cases
<         assume "l = u"
<         have "\<forall>n. x n \<in> ?N" using that(1) by force
<         from closed_sequentially[OF \<open>closed ?N\<close> this \<open>x \<longlonglongrightarrow> l\<close>]
<         show ?thesis by (auto simp: \<open>l = u\<close>)
<       next
<         assume "l \<noteq> u" with that have "l < u" by auto
<         from order_tendstoD(2)[OF \<open>x \<longlonglongrightarrow> l\<close> \<open>l < u\<close>] obtain n where "x n < u"
<           by (auto dest: eventually_happens)
<         with that show ?thesis using \<open>l < u\<close>
<           by (auto dest!: spec[where x=n] simp: image_subset_iff)
<       qed
<       then show "closed ?N'"
<         unfolding closed_sequential_limits
<         by (auto simp: Lim_bounded Lim_bounded2)
<     qed
< 
<     from compact_attains_inf[OF \<open>compact ?N'\<close> \<open>?N' \<noteq> {}\<close>]
<     obtain a0 where a0: "a \<le> a0" "a0 \<le> d" "w ` {a0..d} \<subseteq> {..0}"
<       and a0_least: "\<And>x. a \<le> x \<Longrightarrow> x \<le> d \<Longrightarrow> w ` {x..d} \<subseteq> {..0} \<Longrightarrow> a0 \<le> x"
<       by auto
<     have a0d: "{a0 .. d} \<subseteq> {a .. b}" using that a0
<       by auto
<     have L_w_bound: "L * w x \<le> \<psi>' x - \<phi>' x" if "x \<in> {a0 .. d}" for x
<     proof -
<       from set_mp[OF a0d that] have "x \<in> {a .. b}" .
<       from defect[OF this]
<       have "\<phi>' x - \<psi>' x \<le> dist (f x (\<phi> x)) (f x (\<psi> x))"
<         by (simp add: dist_real_def)
<       also have "\<dots> \<le> L * dist (\<phi> x) (\<psi> x)"
<         using \<open>x \<in> {a .. b}\<close>
<         by (rule L)
<       also have "\<dots> \<le> -L * w x"
<         using \<open>0 < L\<close> a0 that
<         by (force simp add: dist_real_def abs_real_def w_def sign_simps)
<       finally show ?thesis
<         by simp
<     qed
<     have mono: "mono_on (\<lambda>x. w x * exp(-L*x)) {a0..d}"
<       apply (rule mono_onI)
<       apply (rule DERIV_nonneg_imp_nondecreasing, assumption)
<       using a0d
<       by (auto intro!: exI[where x="(\<psi>' x - \<phi>' x) * exp (- (L * x)) - exp (- (L * x)) * L * w x" for x]
<           derivative_eq_intros L_w_bound simp: )
<     then have "w a0 * exp (-L * a0) \<le> w d * exp (-L * d)"
<       by (rule mono_onD) (use that a0 in auto)
<     also have "\<dots> < 0" using \<open>w d < 0\<close> by (simp add: sign_simps)
<     finally have "w a0 * exp (- L * a0) < 0" .
<     then have "w a0 < 0" by (simp add: sign_simps)
<     have "a0 \<le> a"
<     proof (rule ccontr, unfold not_le)
<       assume "a < a0"
<       have "continuous_on {a.. a0} w"
<         by (rule continuous_intros, assumption) (use a0 a0d in auto)
<       from continuous_on_Icc_at_leftD[OF this \<open>a < a0\<close>]
<       have "(w \<longlongrightarrow> w a0) (at_left a0)" .
<       from order_tendstoD(2)[OF this \<open>w a0 < 0\<close>] have "\<forall>\<^sub>F x in at_left a0. w x < 0" .
<       moreover have "\<forall>\<^sub>F x in at_left a0. a < x"
<         by (rule order_tendstoD) (auto intro!: \<open>a < a0\<close>)
<       ultimately have "\<forall>\<^sub>F x in at_left a0. a < x \<and> w x < 0" by eventually_elim auto
<       then obtain a1' where "a1'<a0" and a1_neg: "\<And>y. y > a1' \<Longrightarrow> y < a0 \<Longrightarrow> a < y \<and> w y < 0"
<         unfolding eventually_at_left_field by auto
<       define a1 where "a1 = (a1' + a0)/2"
<       have "a1 < a0" using \<open>a1' < a0\<close> by (auto simp: a1_def)
<       have "a \<le> a1"
<         using \<open>a < a0\<close> a1_neg by (force simp: a1_def)
<       moreover have "a1 \<le> d"
<         using \<open>a1' < a0\<close> a0(2) by (auto simp: a1_def)
<       moreover have "w ` {a1..a0} \<subseteq> {..0}"
<         using \<open>w a0 < 0\<close> a1_neg a0(3)
<         by (auto simp: a1_def) smt
<       moreover have "w ` {a0..d} \<subseteq> {..0}" using a0 by auto
<       ultimately
<       have "a0 \<le> a1"
<         apply (intro a0_least) apply assumption apply assumption
<         by (smt atLeastAtMost_iff image_subset_iff)
<       with \<open>a1<a0\<close> show False by simp
<     qed
<     then have "a0 = a" using \<open>a \<le> a0\<close> by simp
<     with \<open>w a0 < 0\<close> have "w a < 0" by simp
<     with init show False
<       by (auto simp: w_def)
<   qed
<   then show ?thesis
<     by (auto simp: w_def)
< qed
< 
< lemma local_lipschitz_mult:
<   shows "local_lipschitz  (UNIV::real set) (UNIV::real set) (*)"
<   apply (auto intro!: c1_implies_local_lipschitz[where f'="\<lambda>p. blinfun_mult_left (fst p)"])
<    apply (simp add: Complex_Analysis_Basics.has_derivative_mult_right mult_commute_abs)
<   by (auto intro!: continuous_intros)
< 
< lemma comparison_principle_le_linear:
<   fixes \<phi> :: "real \<Rightarrow> real"
<   assumes "continuous_on {a..b} g"
<   assumes "(\<And>t. t \<in> {a..b} \<Longrightarrow> (\<phi> has_real_derivative \<phi>' t) (at t))"
<   assumes "\<phi> a \<le> 0"
<   assumes "(\<And>t. t \<in> {a..b} \<Longrightarrow> \<phi>' t \<le> g t *\<^sub>R \<phi> t)"
<   shows "\<forall>t\<in>{a..b}. \<phi> t \<le> 0"
< proof -
<   have *: "\<And>x. continuous_on {a..b} (\<lambda>t. g t * x)"
<     using assms(1) continuous_on_mult_right by blast
<   then have "local_lipschitz (g`{a..b}) UNIV (*)"
<     using local_lipschitz_subset[OF local_lipschitz_mult] by blast 
<   from local_lipschitz_compose1[OF this assms(1)]
<   have "local_lipschitz {a..b} UNIV (\<lambda>t. (*) (g t))" .
<   from comparison_principle_le[OF this _ _ assms(2) _ _ _ assms(3), of b "\<lambda>t.0"] * assms(4)
<   show ?thesis by auto
< qed
< 
< subsection \<open>Locally Lipschitz ODEs\<close>
< 
< context ll_on_open_it begin
< 
< lemma flow_lipschitzE:
<   assumes "{a .. b} \<subseteq> existence_ivl t0 x"
<   obtains L where "L-lipschitz_on {a .. b} (flow t0 x)"
< proof -
<   have f': "(flow t0 x has_derivative (\<lambda>i. i *\<^sub>R f t (flow t0 x t))) (at t within {a .. b})" if "t \<in> {a .. b}" for t
<     using flow_has_derivative[of t x] assms that
<     by (auto simp: has_derivative_at_withinI)
< 
<   have "compact ((\<lambda>t. f t (flow t0 x t)) ` {a .. b})"
<     using assms
<     apply (auto intro!: compact_continuous_image continuous_intros)
<     using local.existence_ivl_empty2 apply fastforce
<      apply (meson atLeastAtMost_iff general.existence_ivl_subset in_mono)
<     by (simp add: general.flow_in_domain subset_iff)
<   then obtain C where "t \<in> {a .. b} \<Longrightarrow> norm (f t (flow t0 x t)) \<le> C" for t
<     by (force dest!: compact_imp_bounded simp: bounded_iff image_iff)
<   then have "t \<in> {a..b} \<Longrightarrow> onorm (\<lambda>i. i *\<^sub>R f t (flow t0 x t)) \<le> max 0 C" for t
<     apply (subst onorm_scaleR_left) 
<      apply (auto simp: onorm_id max_def)
<     by (metis diff_0_right diff_mono diff_self norm_ge_zero)
<   from bounded_derivative_imp_lipschitz[OF f' _ this]
<   have "(max 0 C)-lipschitz_on {a..b} (flow t0 x)"
<     by auto
<   then show ?thesis ..
< qed
< 
< lemma flow_undefined0: "t \<notin> existence_ivl t0 x \<Longrightarrow> flow t0 x t = 0"
<   unfolding flow_def by auto
< 
< lemma csols_undefined: "x \<notin> X \<Longrightarrow> csols t0 x = {}"
<   apply (auto simp: csols_def)
<   using general.existence_ivl_empty2 general.existence_ivl_maximal_segment
<   apply blast
<   done
< 
< lemmas existence_ivl_undefined = existence_ivl_empty2
< 
< end
< 
< subsection \<open>Reverse flow as Sublocale\<close>
< 
< lemma range_preflect_0[simp]: "range (preflect 0) = UNIV"
<   by (auto simp: preflect_def)
< lemma range_uminus[simp]: "range uminus = (UNIV::'a::ab_group_add set)"
<   by auto
< 
< context auto_ll_on_open begin
< 
< sublocale rev: auto_ll_on_open "-f" rewrites "-(-f) = f"
<    apply unfold_locales
<   using auto_local_lipschitz auto_open_domain
<   unfolding fun_Compl_def local_lipschitz_minus
<   by auto
< 
< lemma existence_ivl_eq_rev0: "existence_ivl0 y = uminus ` rev.existence_ivl0 y" for y
<   by (auto simp: existence_ivl_eq_rev rev.existence_ivl0_def preflect_def)
< 
< lemma rev_existence_ivl_eq0: "rev.existence_ivl0 y = uminus ` existence_ivl0 y" for y
<   using uminus_uminus_image[of "rev.existence_ivl0 y"]
<   by (simp add: existence_ivl_eq_rev0)
< 
< lemma flow_eq_rev0: "flow0 y t = rev.flow0 y (-t)" for y t
<   apply (cases "t \<in> existence_ivl0 y")
<   subgoal
<     apply (subst flow_eq_rev(2), assumption)
<     apply (subst rev.flow0_def)
<     by (simp add: preflect_def)
<   subgoal
<     apply (frule flow_undefined0)
<     by (auto simp: existence_ivl_eq_rev0 rev.flow_undefined0)
<   done
< 
< lemma rev_eq_flow: "rev.flow0 y t = flow0 y (-t)" for y t
<   apply (subst flow_eq_rev0)
<   using uminus_uminus_image[of "rev.existence_ivl0 y"]
<   apply -
<   apply (subst (asm) existence_ivl_eq_rev0[symmetric])
<   by auto
< 
< lemma rev_flow_image_eq: "rev.flow0 x ` S = flow0 x ` (uminus ` S)"
<   unfolding rev_eq_flow[abs_def]
<   by force
< 
< lemma flow_image_eq_rev: "flow0 x ` S = rev.flow0 x ` (uminus ` S)"
<   unfolding rev_eq_flow[abs_def]
<   by force
< 
< end
< 
< context c1_on_open begin
< 
< sublocale rev: c1_on_open "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
<   by (rule c1_on_open_rev) auto
< 
< end
< 
< context c1_on_open_euclidean begin
< 
< sublocale rev: c1_on_open_euclidean "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
<   by unfold_locales auto
< 
< end
< 
< 
< subsection \<open>Autonomous LL ODE : Existence Interval and trapping on the interval\<close>
< 
< lemma bdd_above_is_intervalI: "bdd_above I"
<   if "is_interval I" "a \<le> b" "a \<in> I" "b \<notin> I" for I::"real set"
<   by (meson bdd_above_def is_interval_1 le_cases that) 
< 
< lemma bdd_below_is_intervalI: "bdd_below I"
<   if "is_interval I" "a \<le> b" "a \<notin> I" "b \<in> I" for I::"real set"
<   by (meson bdd_below_def is_interval_1 le_cases that) 
< 
< context auto_ll_on_open begin
< 
< lemma open_existence_ivl0:
<   assumes x : "x \<in> X"
<   shows "\<exists>a b. a < 0 \<and> 0 < b \<and> {a..b} \<subseteq> existence_ivl0 x"
< proof -
<   have a1:"0 \<in> existence_ivl0 x"
<     by (simp add: x)
<   have a2: "open (existence_ivl0 x)"
<     by (simp add: x)
<   from a1 a2 obtain d where "d > 0" "ball 0 d \<subseteq> existence_ivl0 x"
<     using openE by blast
<   have "{-d/2..d/2} \<subseteq> ball 0 d"
<     using \<open>0 < d\<close> dist_norm mem_ball by auto
<   thus ?thesis
<     by (smt \<open>0 < d\<close> \<open>ball 0 d \<subseteq> existence_ivl0 x\<close> divide_minus_left half_gt_zero order_trans)
< qed
< 
< lemma open_existence_ivl':
<   assumes x : "x \<in> X"
<   obtains a where "a > 0"  "{-a..a} \<subseteq> existence_ivl0 x"
< proof -
<   from open_existence_ivl0[OF assms(1)]
<   obtain a b where ab: "a < 0" "0 < b" "{a..b} \<subseteq> existence_ivl0 x" by auto
<   then have "min (-a) b > 0" by linarith
<   have "{-min (-a) b .. min(-a) b} \<subseteq> {a..b}" by auto
<   thus ?thesis using ab(3) that[OF \<open>min (-a) b > 0\<close>] by blast
< qed
< 
< lemma open_existence_ivl_on_compact:
<   assumes C: "C \<subseteq> X" and "compact C" "C \<noteq> {}"
<   obtains a where "a > 0" "\<And>x. x \<in> C \<Longrightarrow> {-a..a} \<subseteq> existence_ivl0 x"
< proof -
<   from existence_ivl_cballs
<   have "\<forall>x\<in>C. \<exists>e>0. \<exists>t>0. \<forall>y\<in>cball x e. cball 0 t\<subseteq>existence_ivl0 y"
<     by (metis (full_types) C Int_absorb1 Int_iff UNIV_I)
<   then
<   obtain d' t' where *:
<     "\<forall>x\<in>C. 0 < d' x \<and> t' x > 0 \<and> (\<forall>y\<in>cball x (d' x). cball 0 (t' x) \<subseteq> existence_ivl0 y)"
<     by metis
<   with compactE_image[OF \<open>compact C\<close>, of C "\<lambda>x. ball x (d' x)"]
<   obtain C' where "C' \<subseteq> C" and [simp]: "finite C'" and C_subset: "C \<subseteq> (\<Union>c\<in>C'. ball c (d' c))"
<     by force
<   from C_subset \<open>C \<noteq> {}\<close> have [simp]: "C' \<noteq> {}" by auto
<   define d where "d = Min (d' ` C')"
<   define t where "t = Min (t' ` C')"
<   have "t > 0" using * \<open>C' \<subseteq> C\<close>
<     by (auto simp: t_def)
<   moreover have "{-t .. t} \<subseteq> existence_ivl0 x" if "x \<in> C" for x
<   proof -
<     from C_subset that \<open>C' \<subseteq> C\<close>
<     obtain c where c: "c \<in> C'" "x \<in> ball c (d' c)" "c \<in> C" by force
<     then have "{-t .. t} \<subseteq> cball 0 (t' c)"
<       by (auto simp: abs_real_def t_def minus_le_iff)
<     also
<     from c have "cball 0 (t' c) \<subseteq> existence_ivl0 x"
<       using *[rule_format, OF \<open>c \<in> C\<close>] by auto
<     finally show ?thesis .
<   qed
<   ultimately show ?thesis ..
< qed
< 
< definition "trapped_forward x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x \<inter> {0..}) \<subseteq> K)"
<   \<comment> \<open>TODO: use this for backwards trapped, invariant, and all assumptions\<close>
< 
< definition "trapped_backward x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x \<inter> {..0}) \<subseteq> K)"
< 
< definition "trapped x K \<longleftrightarrow> trapped_forward x K \<and> trapped_backward x K"
< 
< lemma trapped_iff_on_existence_ivl0:
<   "trapped x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x) \<subseteq> K)"
<   unfolding trapped_def trapped_forward_def trapped_backward_def
<   apply (auto)
<   by (metis IntI atLeast_iff atMost_iff image_subset_iff less_eq_real_def linorder_not_less)
< end
< 
< context auto_ll_on_open begin
< 
< lemma infinite_rev_existence_ivl0_rewrites:
<   "{0..} \<subseteq> rev.existence_ivl0 x \<longleftrightarrow> {..0} \<subseteq> existence_ivl0 x"
<   "{..0} \<subseteq> rev.existence_ivl0 x \<longleftrightarrow> {0..} \<subseteq> existence_ivl0 x"
<    apply (auto simp add: rev.rev_existence_ivl_eq0 subset_iff)
<   using neg_le_0_iff_le apply fastforce
<   using neg_0_le_iff_le by fastforce
< 
< lemma trapped_backward_iff_rev_trapped_forward:
<   "trapped_backward x K  \<longleftrightarrow> rev.trapped_forward x K"
<   unfolding trapped_backward_def rev.trapped_forward_def
<   by (auto simp add: rev_flow_image_eq existence_ivl_eq_rev0 image_subset_iff)
< 
< text \<open>If solution is trapped in a compact set at some time
<   on its existence interval then it is trapped forever\<close>
< lemma trapped_sol_right:
<   \<comment> \<open>TODO: when building on afp-devel (??? outdated):
<     \<^url>\<open>https://bitbucket.org/isa-afp/afp-devel/commits/0c3edf9248d5389197f248c723b625c419e4d3eb\<close>\<close>
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   shows "{0..} \<subseteq> existence_ivl0 x"
< proof (rule ccontr)
<   assume "\<not> {0..} \<subseteq> existence_ivl0 x"
<   from this obtain t where "0 \<le> t" "t \<notin> existence_ivl0 x" by blast
<   then have bdd: "bdd_above (existence_ivl0 x)" 
<     by (auto intro!: bdd_above_is_intervalI \<open>x \<in> X\<close>)
<   from flow_leaves_compact_ivl_right [OF UNIV_I \<open>x \<in> X\<close> bdd UNIV_I assms(1-2)]
<   show False by (metis assms(4) trapped_forward_def IntI atLeast_iff image_subset_iff)
< qed
< 
< lemma trapped_sol_right_gen:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "t \<in> existence_ivl0 x" "trapped_forward (flow0 x t) K"
<   shows "{t..} \<subseteq> existence_ivl0 x"
< proof -
<   have "x \<in> X"
<     using assms(3) local.existence_ivl_empty_iff by fastforce 
<   have xtk: "flow0 x t \<in> X"
<     by (simp add: assms(3) local.flow_in_domain)
<   from trapped_sol_right[OF assms(1-2) xtk assms(4)] have "{0..} \<subseteq> existence_ivl0 (flow0 x t)" .
<   thus "{t..} \<subseteq> existence_ivl0 x"
<     using existence_ivl_trans[OF assms(3)]
<     by (metis add.commute atLeast_iff diff_add_cancel le_add_same_cancel1 subset_iff)
< qed
< 
< lemma trapped_sol_left:
<   \<comment> \<open>TODO: when building on afp-devel:
<     \<^url>\<open>https://bitbucket.org/isa-afp/afp-devel/commits/0c3edf9248d5389197f248c723b625c419e4d3eb\<close>\<close>
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_backward x K"
<   shows "{..0} \<subseteq> existence_ivl0 x"
< proof (rule ccontr)
<   assume "\<not> {..0} \<subseteq> existence_ivl0 x"
<   from this obtain t where "t \<le> 0" "t \<notin> existence_ivl0 x" by blast
<   then have bdd: "bdd_below (existence_ivl0 x)" 
<     by (auto intro!: bdd_below_is_intervalI \<open>x \<in> X\<close>)
<   from flow_leaves_compact_ivl_left [OF UNIV_I \<open>x \<in> X\<close> bdd UNIV_I assms(1-2)]
<   show False
<     by (metis IntI assms(4) atMost_iff auto_ll_on_open.trapped_backward_def auto_ll_on_open_axioms image_subset_iff)
< qed
< 
< lemma trapped_sol_left_gen:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "t \<in> existence_ivl0 x" "trapped_backward (flow0 x t) K"
<   shows "{..t} \<subseteq> existence_ivl0 x"
< proof -
<   have "x \<in> X"
<     using assms(3) local.existence_ivl_empty_iff by fastforce 
<   have xtk: "flow0 x t \<in> X"
<     by (simp add: assms(3) local.flow_in_domain)
<   from trapped_sol_left[OF assms(1-2) xtk assms(4)] have "{..0} \<subseteq> existence_ivl0 (flow0 x t)" .
<   thus "{..t} \<subseteq> existence_ivl0 x"
<     using existence_ivl_trans[OF assms(3)]
<     by (metis add.commute add_le_same_cancel1 atMost_iff diff_add_cancel subset_eq)
< qed
< 
< lemma trapped_sol:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped x K"
<   shows "existence_ivl0 x = UNIV"
<   by (metis (mono_tags, lifting) assms existence_ivl_zero image_subset_iff interval local.existence_ivl_initial_time_iff local.existence_ivl_subset local.subset_mem_compact_implies_subset_existence_interval order_refl subset_antisym trapped_iff_on_existence_ivl0)
< 
< (* Follows from rectification *)
< lemma regular_locally_noteq:\<comment> \<open>TODO: should be true in \<open>ll_on_open_it\<close>\<close>
<   assumes "x \<in> X" "f x \<noteq> 0"
<   shows "eventually (\<lambda>t. flow0 x t \<noteq> x) (at 0)"
< proof -
<   have nf:"norm (f x) > 0" by (simp add: assms(2)) 
<       (* By continuity of solutions and f probably *)
<   obtain a where
<     a: "a>0"
<     "{-a--a} \<subseteq> existence_ivl0 x"
<     "0 \<in> {-a--a}"
<     "\<And>t. t \<in> {-a--a} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2"
<   proof -
<     from open_existence_ivl'[OF assms(1)]
<     obtain a1 where a1: "a1 > 0" "{-a1..a1} \<subseteq> existence_ivl0 x" .
<     have "continuous (at 0) (\<lambda>t. norm(f (flow0 x t) - f (flow0 x 0) ))"
<       apply (auto intro!: continuous_intros)
<       by (simp add: assms(1) local.f_flow_continuous)
<     then obtain a2 where "a2>0"
<       "\<forall>t. norm t < a2 \<longrightarrow>
<              norm (f (flow0 x t) - f (flow0 x 0)) < norm(f x)/2"
<       unfolding continuous_at_real_range
<       by (metis abs_norm_cancel cancel_comm_monoid_add_class.diff_cancel diff_zero half_gt_zero nf norm_zero)
<     then have 
<       t: "\<And>t. t \<in> {-a2<--<a2} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2"
<       by (smt open_segment_bound(2) open_segment_bound1 real_norm_def)
<     define a where "a = min a1 (a2/2)"
<     have t1:"a > 0" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close> by auto
<     then have t3:"0 \<in>{-a--a}"
<       using Starlike.closed_segment_eq_real_ivl by auto  
<     have "{-a--a} \<subseteq> {-a1..a1}" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close>
<       using ODE_Auxiliarities.closed_segment_eq_real_ivl by auto
<     then have t2:"{-a--a} \<subseteq> existence_ivl0 x" using a1 by auto
<     have "{-a--a} \<subseteq> {-a2<--<a2}" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close>
<       by (smt Diff_iff Starlike.closed_segment_eq_real_ivl atLeastAtMost_iff empty_iff half_gt_zero insert_iff pos_half_less segment(1) subset_eq)
<     then have t4:"\<And>t. t \<in> {-a--a} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2" using t by auto
<     show ?thesis using t1 t2 t3 t4 that by auto
<   qed
<   have "\<And>t. t \<in> {-a--a} \<Longrightarrow> (flow0 x has_vector_derivative f (flow0 x t)) (at t within {-a--a})"
<     apply (rule has_vector_derivative_at_within)
<     using a(2) by (auto intro!:flow_has_vector_derivative)
<   from vector_differentiable_bound_linearization[OF this _ a(4)]
<   have nb:"\<And>c d. {c--d} \<subseteq> {-a--a} \<Longrightarrow>
<    norm (flow0 x d - flow0 x c - (d - c) *\<^sub>R f (flow0 x 0))  \<le> norm (d - c) * (norm (f x) / 2)"
<     using a(3) by blast
<   have "\<And>t. dist t 0 < a \<Longrightarrow> t \<noteq> 0 \<Longrightarrow> flow0 x t \<noteq> x"
<   proof (rule ccontr)
<     fix t
<     assume "dist t 0 < a" "t \<noteq> 0" "\<not> flow0 x t \<noteq> x"
<     then have tx:"flow0 x t = x" by auto
<     have "t \<in> {-a--a}"
<       using Starlike.closed_segment_eq_real_ivl \<open>dist t 0 < a\<close> by auto 
<     have "t > 0 \<or> t < 0" using \<open>t \<noteq> 0\<close> by linarith
<     moreover {
<       assume "t > 0"
<       then have "{0--t} \<subseteq> {-a--a}"
<         by (simp add: \<open>t \<in> {-a--a}\<close> a(3) subset_closed_segment) 
<       from nb[OF this] have
<         "norm (flow0 x t - x - t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)"
<         by (simp add: assms(1))
<       then have "norm (t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)" using tx by auto
<       then have False using nf
<         using \<open>0 < t\<close> by auto 
<     }
<     moreover {
<       assume "t < 0"
<       then have "{t--0} \<subseteq> {-a--a}"
<         by (simp add: \<open>t \<in> {-a--a}\<close> a(3) subset_closed_segment) 
<       from nb[OF this] have
<         "norm (x - flow0 x t + t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)"
<         by (simp add: assms(1))
<       then have "norm (t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)" using tx by auto
<       then have False using nf
<         using \<open>t < 0\<close> by auto 
<     }
<     ultimately show False by blast
<   qed
<   thus ?thesis unfolding eventually_at
<     using a(1) by blast
< qed
< 
< lemma compact_max_time_flow_in_closed:
<   assumes "closed M" and t_ex: "t \<in> existence_ivl0 x"
<   shows "compact {s \<in> {0..t}. flow0 x ` {0..s} \<subseteq> M}" (is "compact ?C")
<   unfolding compact_eq_bounded_closed
< proof
<   have "bounded {0 .. t}" by auto
<   then show "bounded ?C"
<     by (rule bounded_subset) auto
<   show "closed ?C"
<     unfolding closed_def
<   proof (rule topological_space_class.openI, clarsimp)
<     \<comment> \<open>TODO: there must be a more abstract argument for this, e.g., with
<       @{thm continuous_on_closed_vimageI} and then reasoning about the connected component around 0?\<close>
<     fix s
<     assume notM: "s \<le> t \<longrightarrow> 0 \<le> s \<longrightarrow> \<not> flow0 x ` {0..s} \<subseteq> M"
<     consider "0 \<le> s" "s \<le> t" "flow0 x s \<notin> M" | "0 \<le> s" "s \<le> t" "flow0 x s \<in> M" | "s < 0" | "s > t"
<       by arith
<     then show "\<exists>T. open T \<and> s \<in> T \<and> T \<subseteq> - {s. 0 \<le> s \<and> s \<le> t \<and> flow0 x ` {0..s} \<subseteq> M}"
<     proof cases
<       assume s: "0 \<le> s" "s \<le> t" and sM: "flow0 x s \<notin> M"
<       have "isCont (flow0 x) s"
<         using s ivl_subset_existence_ivl[OF t_ex]
<         by (auto intro!: flow_continuous)
<       from this[unfolded continuous_at_open, rule_format, of "-M"] sM \<open>closed M\<close>
<       obtain S where "open S" "s \<in> S" "(\<forall>x'\<in>S. flow0 x x' \<in> - M)"
<         by auto
<       then show ?thesis
<         by (force intro!: exI[where x=S])
<     next
<       assume s: "0 \<le> s" "s \<le> t" and sM: "flow0 x s \<in> M"
<       from this notM obtain s0 where s0: "0 \<le> s0" "s0 < s" "flow0 x s0 \<notin> M"
<         by force
<       from order_tendstoD(1)[OF tendsto_ident_at \<open>s0 < s\<close>, of UNIV, unfolded eventually_at_topological]
<       obtain S where "open S" "s \<in> S" "\<And>x. x \<in> S \<Longrightarrow> x \<noteq> s \<Longrightarrow> s0 < x"
<         by auto
<       then show ?thesis using s0
<         by (auto simp: intro!: exI[where x=S]) (smt atLeastAtMost_iff image_subset_iff)
<     qed (force intro: exI[where x="{t<..}"] exI[where x="{..<0}"])+
<   qed
< qed
< 
< lemma flow_in_closed_max_timeE:
<   assumes "closed M" "t \<in> existence_ivl0 x" "0 \<le> t" "x \<in> M"
<   obtains T where "0 \<le> T" "T \<le> t" "flow0 x ` {0..T} \<subseteq> M"
<     "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> T"
< proof -
<   let ?C = "{s \<in> {0..t}. flow0 x ` {0..s} \<subseteq> M}"
<   have "?C \<noteq> {}"
<     using assms
<     using local.mem_existence_ivl_iv_defined
<     by (auto intro!: exI[where x=0])
<   from compact_max_time_flow_in_closed[OF assms(1,2)]
<   have "compact ?C" .
<   from compact_attains_sup[OF this \<open>?C \<noteq> {}\<close>]
<   obtain s where s: "0 \<le> s" "s \<le> t" "flow0 x ` {0..s} \<subseteq> M"
<     and s_max: "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> s"
<     by auto
<   then show ?thesis ..
< qed
< 
< lemma flow_leaves_closed_at_frontierE:
<   assumes "closed M" and t_ex: "t \<in> existence_ivl0 x" and "0 \<le> t" "x \<in> M" "flow0 x t \<notin> M"
<   obtains s where "0 \<le> s" "s < t" "flow0 x ` {0..s} \<subseteq> M"
<     "flow0 x s \<in> frontier M"
<     "\<exists>\<^sub>F s' in at_right s. flow0 x s' \<notin> M"
< proof -
<   from flow_in_closed_max_timeE[OF assms(1-4)] assms(5)
<   obtain s where s: "0 \<le> s" "s < t" "flow0 x ` {0..s} \<subseteq> M"
<     and s_max: "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> s"
<     by (smt atLeastAtMost_iff image_subset_iff)
<   note s
<   moreover
<   have "flow0 x s \<notin> interior M"
<   proof
<     assume interior: "flow0 x s \<in> interior M"
<     have "s \<in> existence_ivl0 x" using ivl_subset_existence_ivl[OF \<open>t \<in> _\<close>] s by auto
<     from flow_continuous[OF this, THEN isContD, THEN topological_tendstoD, OF open_interior interior]
<     have "\<forall>\<^sub>F s' in at s. flow0 x s' \<in> interior M" by auto
<     then have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> interior M"
<       by (auto simp: eventually_at_split)
<     moreover have "\<forall>\<^sub>F s' in at_right s. s' < t"
<       using tendsto_ident_at \<open>s < t\<close>
<       by (rule order_tendstoD)
<     ultimately have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> M \<and> s' < t"
<       by eventually_elim (use interior_subset[of M] in auto)
<     then obtain s' where s': "s < s'" "s' < t" "\<And>y. y > s \<Longrightarrow> y \<le> s' \<Longrightarrow> flow0 x y \<in> M"
<       by (auto simp: eventually_at_right_field_le)
<     have s'_ivl: "flow0 x ` {0..s'} \<subseteq> M"
<     proof safe
<       fix s'' assume "s'' \<in> {0 .. s'}"
<       then show "flow0 x s'' \<in> M"
<         using s interior_subset[of M] s'
<         by (cases "s'' \<le> s") auto
<     qed
<     with s_max[of s'] \<open>s' < t\<close> \<open>0 \<le> s\<close> \<open>s < s'\<close> show False by auto
<   qed
<   then have "flow0 x s \<in> frontier M"
<     using s closure_subset[of M]
<     by (force simp: frontier_def)
<   moreover
<   have "compact (flow0 x -` M \<inter> {s..t})" (is "compact ?C")
<     unfolding compact_eq_bounded_closed
<   proof
<     have "bounded {s .. t}" by simp
<     then show "bounded ?C"
<       by (rule bounded_subset) auto
<     show "closed ?C"
<       using \<open>closed M\<close> assms mem_existence_ivl_iv_defined(2)[OF t_ex] ivl_subset_existence_ivl[OF t_ex] \<open>0 \<le> s\<close>
<       by (intro closed_vimage_Int) (auto intro!: continuous_intros)
<   qed
<   have "\<exists>\<^sub>F s' in at_right s. flow0 x s' \<notin> M"
<     apply (rule ccontr)
<     unfolding not_frequently
<   proof -
<     assume "\<forall>\<^sub>F s' in at_right s. \<not> flow0 x s' \<notin> M"
<     moreover have "\<forall>\<^sub>F s' in at_right s. s' < t"
<       using tendsto_ident_at \<open>s < t\<close>
<       by (rule order_tendstoD)
<     ultimately have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> M \<and> s' < t" by eventually_elim auto
<     then obtain s' where s': "s < s'"
<       "\<And>y. y > s \<Longrightarrow> y < s' \<Longrightarrow> flow0 x y \<in> M"
<       "\<And>y. y > s \<Longrightarrow> y < s' \<Longrightarrow> y < t"
<       by (auto simp: eventually_at_right_field)
<     define s'' where "s'' = (s + s') / 2"
<     have "0 \<le> s''" "s'' \<le> t"  "s < s''" "s'' < s'"
<       using s s'
<       by (auto simp del: divide_le_eq_numeral1 le_divide_eq_numeral1 simp: s''_def) fastforce
<     then have "flow0 x ` {0..s''} \<subseteq> M"
<       using s s'
<       apply (auto simp: )
<       subgoal for u
<         by (cases "u\<le>s") auto
<       done
<     from s_max[OF \<open>0 \<le> s''\<close> \<open>s''\<le> t\<close> this] \<open>s'' > s\<close>
<     show False by simp
<   qed
<   ultimately show ?thesis ..
< qed
< 
< 
< subsection \<open>Connectedness\<close>
< 
< lemma fcontX:
<   shows "continuous_on X f"
<   using auto_local_lipschitz local_lipschitz_continuous_on by blast
< 
< lemma fcontx:
<   assumes "x \<in> X"
<   shows "continuous (at x) f"
< proof -
<   have "open X" by simp
<   from continuous_on_eq_continuous_at[OF this]
<   show ?thesis using fcontX assms(1) by blast
< qed
< 
< lemma continuous_at_imp_cball:
<   assumes "continuous (at x) g"
<   assumes "g x > (0::real)"
<   obtains r where "r > 0" "\<forall>y \<in> cball x r. g y > 0"
< proof -
<   from assms(1)
<   obtain d where "d>0" "g ` (ball x d) \<subseteq> ball (g x) ((g x)/2)"
<     by (meson assms(2) continuous_at_ball half_gt_zero)
<   then have "\<forall>y \<in> cball x (d/2). g y > 0"
<     by (smt assms(2) dist_norm image_subset_iff mem_ball mem_cball pos_half_less real_norm_def)
<   thus ?thesis
<     using \<open>0 < d\<close> that half_gt_zero by blast
< qed
< 
< text \<open> \<open>flow0\<close> is \<open>path_connected\<close> \<close>
< lemma flow0_path_connected_time:
<   assumes "ts \<subseteq> existence_ivl0 x" "path_connected ts"
<   shows "path_connected (flow0 x ` ts)"
< proof -
<   have "continuous_on ts (flow0 x)"
<     by (meson assms continuous_on_sequentially flow_continuous_on subsetD)
<   from path_connected_continuous_image[OF this assms(2)] 
<   show ?thesis .
< qed
< 
< lemma flow0_path_connected:
<   assumes "path_connected D"
<     "path_connected ts"
<     "\<And>x. x \<in> D \<Longrightarrow> ts \<subseteq> existence_ivl0 x"
<   shows "path_connected ( (\<lambda>(x, y). flow0 x y) ` (D \<times> ts))"
< proof -
<   have "D \<times> ts \<subseteq> Sigma X existence_ivl0"
<     using assms(3) subset_iff by fastforce
<   then have a1:"continuous_on (D \<times> ts) (\<lambda>(x, y). flow0 x y)"
<     using flow_continuous_on_state_space continuous_on_subset by blast 
<   have a2 : "path_connected (D \<times> ts)" using path_connected_Times assms by auto
<   from path_connected_continuous_image[OF a1 a2]
<   show ?thesis .
< qed
< 
< end
< 
< subsection \<open>Return Time and Implicit Function Theorem\<close>
< 
< context c1_on_open_euclidean begin
< 
< lemma flow_implicit_function:
<   \<comment> \<open>TODO: generalization of @{thm returns_to_implicit_function}!\<close>
<   fixes s::"'a::euclidean_space \<Rightarrow> real" and S::"'a set"
<   assumes t: "t \<in> existence_ivl0 x" and x: "x \<in> X" and st: "s (flow0 x t) = 0"
<   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
<   assumes DsC: "isCont Ds (flow0 x t)"
<   assumes nz: "Ds (flow0 x t) (f (flow0 x t)) \<noteq> 0"
<   obtains u e
<   where "s (flow0 x (u x)) = 0"
<     "u x = t"
<     "(\<And>y. y \<in> cball x e \<Longrightarrow> s (flow0 y (u y)) = 0)"
<     "continuous_on (cball x e) u"
<     "(\<lambda>t. (t, u t)) ` cball x e \<subseteq> Sigma X existence_ivl0"
<     "0 < e" "(u has_derivative (- blinfun_scaleR_left
<                    (inverse (blinfun_apply (Ds (flow0 x t)) (f (flow0 x t)))) o\<^sub>L
<                       (Ds (flow0 x t) o\<^sub>L flowderiv x t) o\<^sub>L embed1_blinfun)) (at x)"
< proof -
<   note [derivative_intros] = has_derivative_compose[OF _ Ds]
<   have cont_s: "continuous_on UNIV s" by (rule has_derivative_continuous_on[OF Ds])
<   note cls[simp, intro] = closed_levelset[OF cont_s]
<   then have xt1: "(x, t) \<in> Sigma X existence_ivl0"
<     by (auto simp: t x)
<   have D: "(\<And>x. x \<in> Sigma X existence_ivl0 \<Longrightarrow>
<       ((\<lambda>(x, t). s (flow0 x t)) has_derivative
<        blinfun_apply (Ds (flow0 (fst x) (snd x)) o\<^sub>L (flowderiv (fst x) (snd x))))
<        (at x))"
<     by (auto intro!: derivative_eq_intros)
<   have C: "isCont (\<lambda>x. Ds (flow0 (fst x) (snd x)) o\<^sub>L flowderiv (fst x) (snd x))
<    (x, t)"
<     using flowderiv_continuous_on[unfolded continuous_on_eq_continuous_within,
<         rule_format, OF xt1]
<     using at_within_open[OF xt1 open_state_space]
<     by (auto intro!: continuous_intros tendsto_eq_intros x t
<         isCont_tendsto_compose[OF DsC, unfolded poincare_map_def]
<         simp: split_beta' isCont_def)
<   have Z: "(case (x, t) of (x, t) \<Rightarrow> s (flow0 x t)) = 0"
<     by (auto simp: st)
<   have I1: "blinfun_scaleR_left (inverse (Ds (flow0 x t)(f (flow0 x t)))) o\<^sub>L 
<     ((Ds (flow0 (fst (x, t))
<             (snd (x, t))) o\<^sub>L
<        flowderiv (fst (x, t))
<         (snd (x, t))) o\<^sub>L
<       embed2_blinfun)
<      = 1\<^sub>L"
<     using nz
<     by (auto intro!: blinfun_eqI
<         simp: flowderiv_def blinfun.bilinear_simps inverse_eq_divide poincare_map_def)
<   have I2: "((Ds (flow0 (fst (x, t))
<             (snd (x, t))) o\<^sub>L
<        flowderiv (fst (x, t))
<         (snd (x, t))) o\<^sub>L
<       embed2_blinfun) o\<^sub>L blinfun_scaleR_left (inverse (Ds (flow0 x t)(f (flow0 x t))))
<      = 1\<^sub>L"
<     using nz
<     by (auto intro!: blinfun_eqI
<         simp: flowderiv_def blinfun.bilinear_simps inverse_eq_divide poincare_map_def)
<   show ?thesis
<     apply (rule implicit_function_theorem[where f="\<lambda>(x, t). s (flow0 x t)"
<           and S="Sigma X existence_ivl0", OF D xt1 open_state_space order_refl C Z I1 I2])
<      apply blast
<     unfolding split_beta' fst_conv snd_conv poincare_map_def[symmetric]
<     ..
< qed
< 
< lemma flow_implicit_function_at:
<   fixes s::"'a::euclidean_space \<Rightarrow> real" and S::"'a set"
<   assumes x: "x \<in> X" and st: "s x = 0"
<   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
<   assumes DsC: "isCont Ds x"
<   assumes nz: "Ds x (f x) \<noteq> 0"
<   assumes pos: "e > 0"
<   obtains u d
<   where
<     "0 < d"
<     "u x = 0"
<     "\<And>y. y \<in> cball x d \<Longrightarrow> s (flow0 y (u y)) = 0"
<     "\<And>y. y \<in> cball x d \<Longrightarrow> \<bar>u y\<bar> < e"
<     "\<And>y. y \<in> cball x d \<Longrightarrow> u y \<in> existence_ivl0 y"
<     "continuous_on (cball x d) u"
<     "(u has_derivative -Ds x /\<^sub>R (Ds x) (f x)) (at x)"
< proof -
<   have x0: "flow0 x 0 = x" by (simp add: x)
<   from flow_implicit_function[OF existence_ivl_zero[OF x] x, unfolded x0, of s, OF st Ds DsC nz]
<   obtain u d0 where
<     s0: "s (flow0 x (u x)) = 0"
<     and u0: "u x = 0"
<     and u: "\<And>y. y \<in> cball x d0 \<Longrightarrow> s (flow0 y (u y)) = 0"
<     and uc: "continuous_on (cball x d0) u"
<     and uex: "(\<lambda>t. (t, u t)) ` cball x d0 \<subseteq> Sigma X existence_ivl0"
<     and d0: "0 < d0"
<     and u': "(u has_derivative
<      blinfun_apply
<       (- blinfun_scaleR_left (inverse (blinfun_apply (Ds x) (f x))) o\<^sub>L (Ds x o\<^sub>L flowderiv x 0) o\<^sub>L embed1_blinfun))
<      (at x)"
<     by blast
<   have "at x within cball x d0 = at x" by (rule at_within_interior) (auto simp: \<open>0 < d0\<close>)
<   then have "(u \<longlongrightarrow> 0) (at x)"
<     using uc d0 by (auto simp: continuous_on_def u0 dest!: bspec[where x=x])
<   from tendstoD[OF this \<open>0 < e\<close>] pos u0
<   obtain d1 where d1: "0 < d1" "\<And>xa. dist xa x \<le> d1 \<Longrightarrow> \<bar>u xa\<bar> < e"
<     unfolding eventually_at_le
<     by force
<   define d where "d = min d0 d1"
<   have "0 < d" by (auto simp: d_def d0 d1)
<   moreover note u0
<   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> s (flow0 y (u y)) = 0" by (auto intro!: u simp: d_def)
<   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> \<bar>u y\<bar> < e" using d1 by (auto simp: d_def dist_commute)
<   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> u y \<in> existence_ivl0 y"
<     using uex by (force simp: d_def)
<   moreover have "continuous_on (cball x d) u"
<     using uc by (rule continuous_on_subset) (auto simp: d_def)
<   moreover
<   have "(u has_derivative -Ds x /\<^sub>R (Ds x) (f x)) (at x)"
<     using u'
<     by (rule has_derivative_subst) (auto intro!: ext simp: x x0 flowderiv_def blinfun.bilinear_simps)
<   ultimately show ?thesis ..
< qed
< 
< lemma returns_to_implicit_function_gen:
<   \<comment> \<open>TODO: generalizes proof of @{thm returns_to_implicit_function}!\<close>
<   fixes s::"'a::euclidean_space \<Rightarrow> real"
<   assumes rt: "returns_to {x \<in> S. s x = 0} x" (is "returns_to ?P x")
<   assumes cS: "closed S"
<   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
<     "isCont Ds (poincare_map ?P x)"
<     "Ds (poincare_map ?P x) (f (poincare_map ?P x)) \<noteq> 0"
<   obtains u e
<   where "s (flow0 x (u x)) = 0"
<     "u x = return_time ?P x"
<     "(\<And>y. y \<in> cball x e \<Longrightarrow> s (flow0 y (u y)) = 0)"
<     "continuous_on (cball x e) u"
<     "(\<lambda>t. (t, u t)) ` cball x e \<subseteq> Sigma X existence_ivl0"
<     "0 < e" "(u has_derivative (- blinfun_scaleR_left
<                    (inverse (blinfun_apply (Ds (poincare_map ?P x)) (f (poincare_map ?P x)))) o\<^sub>L
<                       (Ds (poincare_map ?P x) o\<^sub>L flowderiv x (return_time ?P x)) o\<^sub>L embed1_blinfun)) (at x)"
< proof -
<   note [derivative_intros] = has_derivative_compose[OF _ Ds(1)]
<   have cont_s: "continuous_on UNIV s" by (rule has_derivative_continuous_on[OF Ds(1)])
<   note cls[simp, intro] = closed_levelset[OF cont_s]
<   let ?t1 = "return_time ?P x"
<   have cls[simp, intro]: "closed {x \<in> S. s x = 0}"
<     by (rule closed_levelset_within) (auto intro!: cS continuous_on_subset[OF cont_s])
< 
<   have *: "poincare_map ?P x = flow0 x (return_time {x \<in> S. s x = 0} x)"
<     by (simp add: poincare_map_def)
<   have "return_time {x \<in> S. s x = 0} x \<in> existence_ivl0 x"
<     "x \<in> X"
<     "s (poincare_map ?P x) = 0"
<     using poincare_map_returns rt
<     by (auto intro!: return_time_exivl rt)
<   note E = flow_implicit_function[of "return_time ?P x" x s Ds, OF this[unfolded *] Ds[unfolded *],
<       folded *]
<   show ?thesis
<     by (rule E) rule
< qed
< 
< text \<open>c.f. Perko Section 3.7 Lemma 2 part 1.\<close>
< 
< lemma flow_transversal_surface_finite_intersections:
<   fixes s::"'a \<Rightarrow> 'b::real_normed_vector"
<     and Ds::"'a \<Rightarrow> 'a \<Rightarrow>\<^sub>L 'b"
<   assumes "closed S"
<   assumes "\<And>x. (s has_derivative (Ds x)) (at x)"
<   assumes "\<And>x. x \<in> S \<Longrightarrow> s x = 0 \<Longrightarrow> Ds x (f x) \<noteq> 0"
<   assumes "a \<le> b" "{a .. b} \<subseteq> existence_ivl0 x"
<   shows "finite {t\<in>{a..b}. flow0 x t \<in> {x \<in> S. s x = 0}}"
<     \<comment> \<open>TODO: define notion of (compact/closed)-(continuous/differentiable/C1)-surface?\<close>
< proof cases
<   note Ds = \<open>\<And>x. (s has_derivative (Ds x)) (at x)\<close>
<   note transversal = \<open>\<And>x. x \<in> S \<Longrightarrow> s x = 0 \<Longrightarrow> Ds x (f x) \<noteq> 0\<close>
<   assume "a < b"
<   show ?thesis
<   proof (rule ccontr)
<     let ?S = "{x \<in> S. s x = 0}"
<     let ?T = "{t\<in>{a..b}. flow0 x t \<in> {x \<in> S. s x = 0}}"
<     define \<phi> where "\<phi> = flow0 x"
<     have [THEN continuous_on_compose2, continuous_intros]: "continuous_on S s"
<       by (auto simp: intro!: has_derivative_continuous_on Ds intro: has_derivative_at_withinI)
<     assume "infinite ?T"
<     from compact_sequentialE[OF compact_Icc[of a b] this]
<     obtain t tl where t: "t n \<in> ?T" "flow0 x (t n) \<in> ?S" "t n \<in> {a .. b}" "t n \<noteq> tl"
<       and tl: "t \<longlonglongrightarrow> tl" "tl \<in> {a..b}"
<     for n
<       by force
<     have tl_ex: "tl \<in> existence_ivl0 x" using \<open>{a .. b} \<subseteq> existence_ivl0 x\<close> \<open>tl \<in> {a .. b}\<close> by auto
<     have "closed ?S"
<       by (auto intro!: closed_levelset_within \<open>closed S\<close> continuous_intros)
<     moreover
<     have "\<forall>n. flow0 x (t n) \<in> ?S"
<       using t by auto
<     moreover
<     have flow_t: "(\<lambda>n. flow0 x (t n)) \<longlonglongrightarrow> flow0 x tl"
<       by (auto intro!: tendsto_eq_intros tl_ex tl)
<     ultimately have "flow0 x tl \<in> ?S"
<       by (rule closed_sequentially)
< 
<     let ?qt = "\<lambda>t. (flow0 x t - flow0 x tl) /\<^sub>R (t - tl)"
<     from flow_has_vector_derivative[OF tl_ex, THEN has_vector_derivative_withinD]
<     have qt_tendsto: "?qt \<midarrow>tl\<rightarrow> f (flow0 x tl)" .
<     let ?q = "\<lambda>n. ?qt (t n)"
<     have "filterlim t (at tl) sequentially"
<       using tl(1)
<       by (rule filterlim_atI) (simp add: t)
<     with qt_tendsto have "?q \<longlonglongrightarrow> f (flow0 x tl)"
<       by (rule filterlim_compose)
<     then have "((\<lambda>n. Ds (flow0 x tl) (?q n))) \<longlonglongrightarrow> Ds (flow0 x tl) (f (flow0 x tl))"
<       by (auto intro!: tendsto_intros)
<     moreover
< 
<     from flow_lipschitzE[OF \<open>{a .. b} \<subseteq> existence_ivl0 x\<close>] obtain L' where L': "L'-lipschitz_on {a..b} (flow0 x)" .
<     define L where "L = L' + 1"
<     from lipschitz_on_le[OF L', of L] lipschitz_on_nonneg[OF L']
<     have L: "L-lipschitz_on {a .. b} (flow0 x)" and "L > 0"
<       by (auto simp: L_def)
<     from flow_lipschitzE[OF \<open>{a .. b} \<subseteq> existence_ivl0 x\<close>] obtain L' where "L'-lipschitz_on {a..b} (flow0 x)" .
<         \<comment> \<open>TODO: is this reasoning (below) with this Lipschitz constant really necessary?\<close>
<     have s[simp]: "s (flow0 x (t n)) = 0""s (flow0 x tl) = 0"
<       for n
<       using t \<open>flow0 x tl \<in> ?S\<close>
<       by auto
< 
<     from Ds(1)[of "flow0 x tl", unfolded has_derivative_within]
<     have "(\<lambda>y. (1 / norm (y - flow0 x tl)) *\<^sub>R (s y - (s (flow0 x tl) + blinfun_apply (Ds (flow0 x tl)) (y - flow0 x tl)))) \<midarrow>flow0 x tl\<rightarrow> 0"
<       by auto
<     then have "((\<lambda>y. (1 / norm (y - flow0 x tl)) *\<^sub>R (s y - (s (flow0 x tl) + blinfun_apply (Ds (flow0 x tl)) (y - flow0 x tl)))) \<longlongrightarrow> 0)
<       (nhds (flow0 x tl))"
<       by (rule tendsto_nhds_continuousI) simp
< 
<     from filterlim_compose[OF this flow_t]
<     have "(\<lambda>xa. (blinfun_apply (Ds (flow0 x tl)) (flow0 x (t xa) - flow0 x tl)) /\<^sub>R norm (flow0 x (t xa) - flow0 x tl))
<       \<longlonglongrightarrow> 0"
<       using t
<       by (auto simp: inverse_eq_divide tendsto_minus_cancel_right)
<     from tendsto_mult[OF tendsto_const[of "L"] tendsto_norm[OF this, simplified, simplified divide_inverse_commute[symmetric]]]\<comment> \<open>TODO: uuugly\<close>
<     have Ds0: "(\<lambda>xa. norm (blinfun_apply (Ds (flow0 x tl)) (flow0 x (t xa) - flow0 x tl)) / (norm (flow0 x (t xa) - flow0 x tl)/(L))) \<longlonglongrightarrow> 0"
<       by (auto simp: ac_simps)
< 
<     from _ Ds0 have "((\<lambda>n. Ds (flow0 x tl) (?q n)) \<longlonglongrightarrow> 0)"
<       apply (rule Lim_null_comparison)
<       apply (rule eventuallyI)
<       unfolding norm_scaleR blinfun.scaleR_right abs_inverse divide_inverse_commute[symmetric]
<       subgoal for n
<         apply (cases "flow0 x (t n) = flow0 x tl")
<         subgoal by (simp add: blinfun.bilinear_simps)
<         subgoal
<           apply (rule divide_left_mono)
<           using lipschitz_onD[OF L, of "t n" tl] \<open>0 < L\<close> t(3) tl(2)
<           by (auto simp: sign_simps zero_less_divide_iff dist_norm pos_divide_le_eq
<               intro!: add_pos_nonneg)
<         done
<       done
<     ultimately have "Ds (flow0 x tl) (f (flow0 x tl)) = 0"
<       by (rule LIMSEQ_unique)
<     moreover have "Ds (flow0 x tl) (f (flow0 x tl)) \<noteq> 0"
<       by (rule transversal) (use \<open>flow0 x tl \<in> ?S\<close> in auto)
<     ultimately show False by auto
<   qed
< qed (use assms in auto)
< 
< lemma uniform_limit_flow0_state:\<comment> \<open>TODO: is that something more general?\<close>
<   assumes "compact C"
<   assumes "C \<subseteq> X"
<   shows "uniform_limit C (\<lambda>s x. flow0 x s) (\<lambda>x. flow0 x 0) (at 0)"
< proof (cases "C = {}")
<   case True then show ?thesis by auto
< next
<   case False show ?thesis
<   proof (rule uniform_limitI)
<     fix e::real assume "0 < e"
<     {
<       fix x assume "x \<in> C"
<       with assms have "x \<in> X" by auto
<       from existence_ivl_cballs[OF UNIV_I \<open>x \<in> X\<close>]
<       obtain t L u where "\<And>y. y \<in> cball x u \<Longrightarrow> cball 0 t \<subseteq> existence_ivl0 y"
<         "\<And>s y. y \<in> cball x u \<Longrightarrow> s \<in> cball 0 t \<Longrightarrow> flow0 y s \<in> cball y u"
<         "L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)"
<         "\<And>y. y \<in> cball x u \<Longrightarrow> cball y u \<subseteq> X"
<         "0 < t" "0 < u"
<         by metis
<       then have "\<exists>L. \<exists>u>0. \<exists>t>0. L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)" by blast
<     } then have "\<forall>x\<in>C. \<exists>L. \<exists>u>0. \<exists>t>0. L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)" ..
<     then obtain L d' u' where
<       L: "\<And>x. x \<in> C \<Longrightarrow> (L x)-lipschitz_on (cball 0 (d' x)\<times>cball x (u' x)) (\<lambda>(t, x). flow0 x t)"
<       and d': "\<And>x. x \<in> C \<Longrightarrow> d' x > 0"
<       and u': "\<And>x. x \<in> C \<Longrightarrow> u' x > 0"
<       by metis
<     have "C \<subseteq> (\<Union>c\<in>C. ball c (u' c))" using u' by auto
<     from compactE_image[OF \<open>compact C\<close> _ this]
<     obtain C' where "C' \<subseteq> C" and [simp]: "finite C'" and C'_cover: "C \<subseteq> (\<Union>c\<in>C'. ball c (u' c))"
<       by auto
<     from C'_cover obtain c' where c': "x \<in> C \<Longrightarrow> x \<in> ball (c' x) (u' (c' x))" "x \<in> C \<Longrightarrow> c' x \<in> C'" for x
<       by (auto simp: subset_iff) metis
<     have "\<forall>\<^sub>F s in at 0. \<forall>x\<in>ball c (u' c). dist (flow0 x s) (flow0 x 0) < e" if "c \<in> C'" for c
<     proof -
<       have cC: "c \<in> C"
<         using c' \<open>c \<in> C'\<close> d' \<open>C' \<subseteq> C\<close>
<         by auto
<       have *: "dist (flow0 x s) (flow0 x 0) \<le> L c * \<bar>s\<bar>"
<         if "x\<in>ball c (u' c)"
<           "s \<in> cball 0 (d' c)"
<         for x s
<       proof -
<         from L[OF cC, THEN lipschitz_onD, of "(0, x)" "(s, x)"] d'[OF cC] that
<         show ?thesis
<           by (auto simp: dist_prod_def dist_commute)
<       qed
<       have "\<forall>\<^sub>F s in at 0. abs s < d' c"
<         by (rule order_tendstoD tendsto_intros)+ (use d' cC in auto)
<       moreover have "\<forall>\<^sub>F s in at 0. L c * \<bar>s\<bar> < e"
<         by (rule order_tendstoD tendsto_intros)+ (use \<open>0 < e\<close> in auto)
<       ultimately show ?thesis
<         apply eventually_elim
<         apply (use * in auto)
<         by smt
<     qed
<     then have "\<forall>\<^sub>F s in at 0. \<forall>c\<in>C'. \<forall>x\<in>ball c (u' c). dist (flow0 x s) (flow0 x 0) < e"
<       by (simp add: eventually_ball_finite_distrib)
<     then show "\<forall>\<^sub>F s in at 0. \<forall>x\<in>C. dist (flow0 x s) (flow0 x 0) < e"
<       apply eventually_elim
<       apply (auto simp: )
<       subgoal for s x
<         apply (drule bspec[where x="c' x"])
<          apply (simp add: c'(2))
<         apply (drule bspec) prefer 2 apply assumption
<         apply auto
<         using c'(1) by auto
<       done
<   qed
< qed
< 
< end
< 
< subsection \<open>Fixpoints\<close>
< 
< context auto_ll_on_open begin
< 
< lemma fixpoint_sol:
<   assumes "x \<in> X" "f x = 0"
<   shows "existence_ivl0 x = UNIV" "flow0 x t = x"
< proof -
<   have sol: "((\<lambda>t::real. x) solves_ode (\<lambda>_. f)) UNIV X"
<     apply (rule solves_odeI)
<     by(auto simp add: assms intro!: derivative_intros)
<   from maximal_existence_flow[OF sol] have
<     "UNIV \<subseteq> existence_ivl0 x" "flow0 x t = x" by auto
<   thus "existence_ivl0 x = UNIV" "flow0 x t = x" by auto
< qed
< 
< end
< 
---
> section \<open>Additions to the ODE Library\<close>
> theory ODE_Misc
>   imports
>     Ordinary_Differential_Equations.ODE_Analysis
>     Analysis_Misc
> begin
> 
> lemma local_lipschitz_compact_bicomposeE:
>   assumes ll: "local_lipschitz T X f"
>   assumes cf: "\<And>x. x \<in> X \<Longrightarrow> continuous_on I (\<lambda>t. f t x)"
>   assumes cI: "compact I"
>   assumes "I \<subseteq> T"
>   assumes cv: "continuous_on I v"
>   assumes cw: "continuous_on I w"
>   assumes v: "v ` I \<subseteq> X"
>   assumes w: "w ` I \<subseteq> X"
>   obtains L where "L > 0" "\<And>x. x \<in> I \<Longrightarrow> dist (f x (v x)) (f x (w x)) \<le> L * dist (v x) (w x)"
> proof -
>   from v w have "v ` I \<union> w ` I \<subseteq> X" by auto
>   with ll \<open>I \<subseteq> T\<close> have llI:"local_lipschitz I (v ` I \<union> w ` I) f"
>     by (rule local_lipschitz_subset)
>   have cvwI: "compact (v ` I \<union> w ` I)"
>     by (auto intro!: compact_continuous_image cv cw cI)    
> 
>   from local_lipschitz_compact_implies_lipschitz[OF llI cvwI \<open>compact I\<close> cf]
>   obtain L where L: "\<And>t. t \<in> I \<Longrightarrow> L-lipschitz_on (v ` I \<union> w ` I) (f t)"
>     using v w
>     by blast
>   define L' where "L' = max L 1"
>   with L have "L' > 0" "\<And>x. x \<in> I \<Longrightarrow> dist (f x (v x)) (f x (w x)) \<le> L' * dist (v x) (w x)"
>      apply (auto simp: lipschitz_on_def L'_def)
>     by (smt Un_iff image_eqI mult_right_mono zero_le_dist)
>   then show ?thesis ..
> qed
> 
> subsection \<open>Comparison Principle\<close>
> 
> lemma comparison_principle_le:
>   fixes f::"real \<Rightarrow> real \<Rightarrow> real"
>     and \<phi> \<psi>::"real \<Rightarrow> real"
>   assumes ll: "local_lipschitz X Y f"
>   assumes cf: "\<And>x. x \<in> Y \<Longrightarrow> continuous_on {a..b} (\<lambda>t. f t x)"
>   assumes abX: "{a .. b} \<subseteq> X"
>   assumes \<phi>': "\<And>x. x \<in> {a .. b} \<Longrightarrow> (\<phi> has_real_derivative \<phi>' x) (at x)"
>   assumes \<psi>': "\<And>x. x \<in> {a .. b} \<Longrightarrow> (\<psi> has_real_derivative \<psi>' x) (at x)"
>   assumes \<phi>_in: "\<phi> ` {a..b} \<subseteq> Y"
>   assumes \<psi>_in: "\<psi> ` {a..b} \<subseteq> Y"
>   assumes init: "\<phi> a \<le> \<psi> a"
>   assumes defect: "\<And>x. x \<in> {a .. b} \<Longrightarrow> \<phi>' x - f x (\<phi> x) \<le> \<psi>' x - f x (\<psi> x)"
>   shows "\<forall>x \<in> {a .. b}. \<phi> x \<le> \<psi> x" (is "?th1")
>     (*
>     "(\<forall>x \<in> {a .. b}. \<phi> x < \<psi> x) \<or> (\<exists>c\<in>{a..b}. (\<forall>x\<in>{a..c}. \<phi> x \<le> \<psi> x) \<and> (\<forall>x\<in>{c<..b}. \<phi> x < \<psi> x))"
>     (is "?th2")
> *)
>   unfolding atomize_conj
>   apply (cases "a \<le> b")
>    defer subgoal by simp
> proof -
>   assume "a \<le> b"
>   note \<phi>_cont = has_real_derivative_imp_continuous_on[OF \<phi>']
>   note \<psi>_cont = has_real_derivative_imp_continuous_on[OF \<psi>']
>   from local_lipschitz_compact_bicomposeE[OF ll cf compact_Icc abX \<phi>_cont \<psi>_cont \<phi>_in \<psi>_in]
>   obtain L where L: "L > 0" "\<And>x. x \<in> {a..b} \<Longrightarrow> dist (f x (\<phi> x)) (f x (\<psi> x)) \<le> L * dist (\<phi> x) (\<psi> x)" by blast
>   define w where "w x = \<psi> x - \<phi> x" for x
> 
>   have w'[derivative_intros]: "\<And>x. x \<in> {a .. b} \<Longrightarrow> (w has_real_derivative \<psi>' x - \<phi>' x) (at x)"
>     using \<phi>' \<psi>'
>     by (auto simp: has_vderiv_on_def w_def[abs_def] intro!: derivative_eq_intros)
>   note w_cont[continuous_intros] = has_real_derivative_imp_continuous_on[OF w', THEN continuous_on_compose2]
>   have "w d \<ge> 0" if "d \<in> {a .. b}" for d
>   proof (rule ccontr, unfold not_le)
>     assume "w d < 0"
>     let ?N = "(w -` {..0} \<inter> {a .. d})"
>     from \<open>w d < 0\<close> that have "d \<in> ?N" by auto
>     then have "?N \<noteq> {}" by auto
>     have "closed ?N"
>       unfolding compact_eq_bounded_closed
>       using that
>       by (intro conjI closed_vimage_Int) (auto intro!: continuous_intros)
> 
>     let ?N' = "{a0 \<in> {a .. d}. w ` {a0 .. d} \<subseteq> {..0}}"
>     from \<open>w d < 0\<close> that have "d \<in> ?N'" by simp
>     then have "?N' \<noteq> {}" by auto
>     have "compact ?N'"
>       unfolding compact_eq_bounded_closed
>     proof
>       have "?N' \<subseteq> {a .. d}" using that by auto
>       then show "bounded ?N'"
>         by (rule bounded_subset[rotated]) simp
>       have "w u \<le> 0" if "(\<forall>n. x n \<in> ?N')" "x \<longlonglongrightarrow> l" "l \<le> u" "u \<le> d" for x l u
>       proof cases
>         assume "l = u"
>         have "\<forall>n. x n \<in> ?N" using that(1) by force
>         from closed_sequentially[OF \<open>closed ?N\<close> this \<open>x \<longlonglongrightarrow> l\<close>]
>         show ?thesis by (auto simp: \<open>l = u\<close>)
>       next
>         assume "l \<noteq> u" with that have "l < u" by auto
>         from order_tendstoD(2)[OF \<open>x \<longlonglongrightarrow> l\<close> \<open>l < u\<close>] obtain n where "x n < u"
>           by (auto dest: eventually_happens)
>         with that show ?thesis using \<open>l < u\<close>
>           by (auto dest!: spec[where x=n] simp: image_subset_iff)
>       qed
>       then show "closed ?N'"
>         unfolding closed_sequential_limits
>         by (auto simp: Lim_bounded Lim_bounded2)
>     qed
> 
>     from compact_attains_inf[OF \<open>compact ?N'\<close> \<open>?N' \<noteq> {}\<close>]
>     obtain a0 where a0: "a \<le> a0" "a0 \<le> d" "w ` {a0..d} \<subseteq> {..0}"
>       and a0_least: "\<And>x. a \<le> x \<Longrightarrow> x \<le> d \<Longrightarrow> w ` {x..d} \<subseteq> {..0} \<Longrightarrow> a0 \<le> x"
>       by auto
>     have a0d: "{a0 .. d} \<subseteq> {a .. b}" using that a0
>       by auto
>     have L_w_bound: "L * w x \<le> \<psi>' x - \<phi>' x" if "x \<in> {a0 .. d}" for x
>     proof -
>       from set_mp[OF a0d that] have "x \<in> {a .. b}" .
>       from defect[OF this]
>       have "\<phi>' x - \<psi>' x \<le> dist (f x (\<phi> x)) (f x (\<psi> x))"
>         by (simp add: dist_real_def)
>       also have "\<dots> \<le> L * dist (\<phi> x) (\<psi> x)"
>         using \<open>x \<in> {a .. b}\<close>
>         by (rule L)
>       also have "\<dots> \<le> -L * w x"
>         using \<open>0 < L\<close> a0 that
>         by (force simp add: dist_real_def abs_real_def w_def algebra_split_simps )
>       finally show ?thesis
>         by simp
>     qed
>     have mono: "mono_on (\<lambda>x. w x * exp(-L*x)) {a0..d}"
>       apply (rule mono_onI)
>       apply (rule DERIV_nonneg_imp_nondecreasing, assumption)
>       using a0d
>       by (auto intro!: exI[where x="(\<psi>' x - \<phi>' x) * exp (- (L * x)) - exp (- (L * x)) * L * w x" for x]
>           derivative_eq_intros L_w_bound simp: )
>     then have "w a0 * exp (-L * a0) \<le> w d * exp (-L * d)"
>       by (rule mono_onD) (use that a0 in auto)
>     also have "\<dots> < 0" using \<open>w d < 0\<close> by (simp add: algebra_split_simps)
>     finally have "w a0 * exp (- L * a0) < 0" .
>     then have "w a0 < 0" by (simp add: algebra_split_simps)
>     have "a0 \<le> a"
>     proof (rule ccontr, unfold not_le)
>       assume "a < a0"
>       have "continuous_on {a.. a0} w"
>         by (rule continuous_intros, assumption) (use a0 a0d in auto)
>       from continuous_on_Icc_at_leftD[OF this \<open>a < a0\<close>]
>       have "(w \<longlongrightarrow> w a0) (at_left a0)" .
>       from order_tendstoD(2)[OF this \<open>w a0 < 0\<close>] have "\<forall>\<^sub>F x in at_left a0. w x < 0" .
>       moreover have "\<forall>\<^sub>F x in at_left a0. a < x"
>         by (rule order_tendstoD) (auto intro!: \<open>a < a0\<close>)
>       ultimately have "\<forall>\<^sub>F x in at_left a0. a < x \<and> w x < 0" by eventually_elim auto
>       then obtain a1' where "a1'<a0" and a1_neg: "\<And>y. y > a1' \<Longrightarrow> y < a0 \<Longrightarrow> a < y \<and> w y < 0"
>         unfolding eventually_at_left_field by auto
>       define a1 where "a1 = (a1' + a0)/2"
>       have "a1 < a0" using \<open>a1' < a0\<close> by (auto simp: a1_def)
>       have "a \<le> a1"
>         using \<open>a < a0\<close> a1_neg by (force simp: a1_def)
>       moreover have "a1 \<le> d"
>         using \<open>a1' < a0\<close> a0(2) by (auto simp: a1_def)
>       moreover have "w ` {a1..a0} \<subseteq> {..0}"
>         using \<open>w a0 < 0\<close> a1_neg a0(3)
>         by (auto simp: a1_def) smt
>       moreover have "w ` {a0..d} \<subseteq> {..0}" using a0 by auto
>       ultimately
>       have "a0 \<le> a1"
>         apply (intro a0_least) apply assumption apply assumption
>         by (smt atLeastAtMost_iff image_subset_iff)
>       with \<open>a1<a0\<close> show False by simp
>     qed
>     then have "a0 = a" using \<open>a \<le> a0\<close> by simp
>     with \<open>w a0 < 0\<close> have "w a < 0" by simp
>     with init show False
>       by (auto simp: w_def)
>   qed
>   then show ?thesis
>     by (auto simp: w_def)
> qed
> 
> lemma local_lipschitz_mult:
>   shows "local_lipschitz  (UNIV::real set) (UNIV::real set) (*)"
>   apply (auto intro!: c1_implies_local_lipschitz[where f'="\<lambda>p. blinfun_mult_left (fst p)"])
>    apply (simp add: has_derivative_mult_right mult_commute_abs)
>   by (auto intro!: continuous_intros)
> 
> lemma comparison_principle_le_linear:
>   fixes \<phi> :: "real \<Rightarrow> real"
>   assumes "continuous_on {a..b} g"
>   assumes "(\<And>t. t \<in> {a..b} \<Longrightarrow> (\<phi> has_real_derivative \<phi>' t) (at t))"
>   assumes "\<phi> a \<le> 0"
>   assumes "(\<And>t. t \<in> {a..b} \<Longrightarrow> \<phi>' t \<le> g t *\<^sub>R \<phi> t)"
>   shows "\<forall>t\<in>{a..b}. \<phi> t \<le> 0"
> proof -
>   have *: "\<And>x. continuous_on {a..b} (\<lambda>t. g t * x)"
>     using assms(1) continuous_on_mult_right by blast
>   then have "local_lipschitz (g`{a..b}) UNIV (*)"
>     using local_lipschitz_subset[OF local_lipschitz_mult] by blast 
>   from local_lipschitz_compose1[OF this assms(1)]
>   have "local_lipschitz {a..b} UNIV (\<lambda>t. (*) (g t))" .
>   from comparison_principle_le[OF this _ _ assms(2) _ _ _ assms(3), of b "\<lambda>t.0"] * assms(4)
>   show ?thesis by auto
> qed
> 
> subsection \<open>Locally Lipschitz ODEs\<close>
> 
> context ll_on_open_it begin
> 
> lemma flow_lipschitzE:
>   assumes "{a .. b} \<subseteq> existence_ivl t0 x"
>   obtains L where "L-lipschitz_on {a .. b} (flow t0 x)"
> proof -
>   have f': "(flow t0 x has_derivative (\<lambda>i. i *\<^sub>R f t (flow t0 x t))) (at t within {a .. b})" if "t \<in> {a .. b}" for t
>     using flow_has_derivative[of t x] assms that
>     by (auto simp: has_derivative_at_withinI)
> 
>   have "compact ((\<lambda>t. f t (flow t0 x t)) ` {a .. b})"
>     using assms
>     apply (auto intro!: compact_continuous_image continuous_intros)
>     using local.existence_ivl_empty2 apply fastforce
>      apply (meson atLeastAtMost_iff general.existence_ivl_subset in_mono)
>     by (simp add: general.flow_in_domain subset_iff)
>   then obtain C where "t \<in> {a .. b} \<Longrightarrow> norm (f t (flow t0 x t)) \<le> C" for t
>     by (fastforce dest!: compact_imp_bounded simp: bounded_iff intro: that)
>   then have "t \<in> {a..b} \<Longrightarrow> onorm (\<lambda>i. i *\<^sub>R f t (flow t0 x t)) \<le> max 0 C" for t
>     apply (subst onorm_scaleR_left) 
>      apply (auto simp: onorm_id max_def)
>     by (metis diff_0_right diff_mono diff_self norm_ge_zero)
>   from bounded_derivative_imp_lipschitz[OF f' _ this]
>   have "(max 0 C)-lipschitz_on {a..b} (flow t0 x)"
>     by auto
>   then show ?thesis ..
> qed
> 
> lemma flow_undefined0: "t \<notin> existence_ivl t0 x \<Longrightarrow> flow t0 x t = 0"
>   unfolding flow_def by auto
> 
> lemma csols_undefined: "x \<notin> X \<Longrightarrow> csols t0 x = {}"
>   apply (auto simp: csols_def)
>   using general.existence_ivl_empty2 general.existence_ivl_maximal_segment
>   apply blast
>   done
> 
> lemmas existence_ivl_undefined = existence_ivl_empty2
> 
> end
> 
> subsection \<open>Reverse flow as Sublocale\<close>
> 
> lemma range_preflect_0[simp]: "range (preflect 0) = UNIV"
>   by (auto simp: preflect_def)
> lemma range_uminus[simp]: "range uminus = (UNIV::'a::ab_group_add set)"
>   by auto
> 
> context auto_ll_on_open begin
> 
> sublocale rev: auto_ll_on_open "-f" rewrites "-(-f) = f"
>    apply unfold_locales
>   using auto_local_lipschitz auto_open_domain
>   unfolding fun_Compl_def local_lipschitz_minus
>   by auto
> 
> lemma existence_ivl_eq_rev0: "existence_ivl0 y = uminus ` rev.existence_ivl0 y" for y
>   by (auto simp: existence_ivl_eq_rev rev.existence_ivl0_def preflect_def)
> 
> lemma rev_existence_ivl_eq0: "rev.existence_ivl0 y = uminus ` existence_ivl0 y" for y
>   using uminus_uminus_image[of "rev.existence_ivl0 y"]
>   by (simp add: existence_ivl_eq_rev0)
> 
> lemma flow_eq_rev0: "flow0 y t = rev.flow0 y (-t)" for y t
>   apply (cases "t \<in> existence_ivl0 y")
>   subgoal
>     apply (subst flow_eq_rev(2), assumption)
>     apply (subst rev.flow0_def)
>     by (simp add: preflect_def)
>   subgoal
>     apply (frule flow_undefined0)
>     by (auto simp: existence_ivl_eq_rev0 rev.flow_undefined0)
>   done
> 
> lemma rev_eq_flow: "rev.flow0 y t = flow0 y (-t)" for y t
>   apply (subst flow_eq_rev0)
>   using uminus_uminus_image[of "rev.existence_ivl0 y"]
>   apply -
>   apply (subst (asm) existence_ivl_eq_rev0[symmetric])
>   by auto
> 
> lemma rev_flow_image_eq: "rev.flow0 x ` S = flow0 x ` (uminus ` S)"
>   unfolding rev_eq_flow[abs_def]
>   by force
> 
> lemma flow_image_eq_rev: "flow0 x ` S = rev.flow0 x ` (uminus ` S)"
>   unfolding rev_eq_flow[abs_def]
>   by force
> 
> end
> 
> context c1_on_open begin
> 
> sublocale rev: c1_on_open "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
>   by (rule c1_on_open_rev) auto
> 
> end
> 
> context c1_on_open_euclidean begin
> 
> sublocale rev: c1_on_open_euclidean "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
>   by unfold_locales auto
> 
> end
> 
> 
> subsection \<open>Autonomous LL ODE : Existence Interval and trapping on the interval\<close>
> 
> lemma bdd_above_is_intervalI: "bdd_above I"
>   if "is_interval I" "a \<le> b" "a \<in> I" "b \<notin> I" for I::"real set"
>   by (meson bdd_above_def is_interval_1 le_cases that) 
> 
> lemma bdd_below_is_intervalI: "bdd_below I"
>   if "is_interval I" "a \<le> b" "a \<notin> I" "b \<in> I" for I::"real set"
>   by (meson bdd_below_def is_interval_1 le_cases that) 
> 
> context auto_ll_on_open begin
> 
> lemma open_existence_ivl0:
>   assumes x : "x \<in> X"
>   shows "\<exists>a b. a < 0 \<and> 0 < b \<and> {a..b} \<subseteq> existence_ivl0 x"
> proof -
>   have a1:"0 \<in> existence_ivl0 x"
>     by (simp add: x)
>   have a2: "open (existence_ivl0 x)"
>     by (simp add: x)
>   from a1 a2 obtain d where "d > 0" "ball 0 d \<subseteq> existence_ivl0 x"
>     using openE by blast
>   have "{-d/2..d/2} \<subseteq> ball 0 d"
>     using \<open>0 < d\<close> dist_norm mem_ball by auto
>   thus ?thesis
>     by (smt \<open>0 < d\<close> \<open>ball 0 d \<subseteq> existence_ivl0 x\<close> divide_minus_left half_gt_zero order_trans)
> qed
> 
> lemma open_existence_ivl':
>   assumes x : "x \<in> X"
>   obtains a where "a > 0"  "{-a..a} \<subseteq> existence_ivl0 x"
> proof -
>   from open_existence_ivl0[OF assms(1)]
>   obtain a b where ab: "a < 0" "0 < b" "{a..b} \<subseteq> existence_ivl0 x" by auto
>   then have "min (-a) b > 0" by linarith
>   have "{-min (-a) b .. min(-a) b} \<subseteq> {a..b}" by auto
>   thus ?thesis using ab(3) that[OF \<open>min (-a) b > 0\<close>] by blast
> qed
> 
> lemma open_existence_ivl_on_compact:
>   assumes C: "C \<subseteq> X" and "compact C" "C \<noteq> {}"
>   obtains a where "a > 0" "\<And>x. x \<in> C \<Longrightarrow> {-a..a} \<subseteq> existence_ivl0 x"
> proof -
>   from existence_ivl_cballs
>   have "\<forall>x\<in>C. \<exists>e>0. \<exists>t>0. \<forall>y\<in>cball x e. cball 0 t\<subseteq>existence_ivl0 y"
>     by (metis (full_types) C Int_absorb1 Int_iff UNIV_I)
>   then
>   obtain d' t' where *:
>     "\<forall>x\<in>C. 0 < d' x \<and> t' x > 0 \<and> (\<forall>y\<in>cball x (d' x). cball 0 (t' x) \<subseteq> existence_ivl0 y)"
>     by metis
>   with compactE_image[OF \<open>compact C\<close>, of C "\<lambda>x. ball x (d' x)"]
>   obtain C' where "C' \<subseteq> C" and [simp]: "finite C'" and C_subset: "C \<subseteq> (\<Union>c\<in>C'. ball c (d' c))"
>     by force
>   from C_subset \<open>C \<noteq> {}\<close> have [simp]: "C' \<noteq> {}" by auto
>   define d where "d = Min (d' ` C')"
>   define t where "t = Min (t' ` C')"
>   have "t > 0" using * \<open>C' \<subseteq> C\<close>
>     by (auto simp: t_def)
>   moreover have "{-t .. t} \<subseteq> existence_ivl0 x" if "x \<in> C" for x
>   proof -
>     from C_subset that \<open>C' \<subseteq> C\<close>
>     obtain c where c: "c \<in> C'" "x \<in> ball c (d' c)" "c \<in> C" by force
>     then have "{-t .. t} \<subseteq> cball 0 (t' c)"
>       by (auto simp: abs_real_def t_def minus_le_iff)
>     also
>     from c have "cball 0 (t' c) \<subseteq> existence_ivl0 x"
>       using *[rule_format, OF \<open>c \<in> C\<close>] by auto
>     finally show ?thesis .
>   qed
>   ultimately show ?thesis ..
> qed
> 
> definition "trapped_forward x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x \<inter> {0..}) \<subseteq> K)"
>   \<comment> \<open>TODO: use this for backwards trapped, invariant, and all assumptions\<close>
> 
> definition "trapped_backward x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x \<inter> {..0}) \<subseteq> K)"
> 
> definition "trapped x K \<longleftrightarrow> trapped_forward x K \<and> trapped_backward x K"
> 
> lemma trapped_iff_on_existence_ivl0:
>   "trapped x K \<longleftrightarrow> (flow0 x ` (existence_ivl0 x) \<subseteq> K)"
>   unfolding trapped_def trapped_forward_def trapped_backward_def
>   apply (auto)
>   by (metis IntI atLeast_iff atMost_iff image_subset_iff less_eq_real_def linorder_not_less)
> end
> 
> context auto_ll_on_open begin
> 
> lemma infinite_rev_existence_ivl0_rewrites:
>   "{0..} \<subseteq> rev.existence_ivl0 x \<longleftrightarrow> {..0} \<subseteq> existence_ivl0 x"
>   "{..0} \<subseteq> rev.existence_ivl0 x \<longleftrightarrow> {0..} \<subseteq> existence_ivl0 x"
>    apply (auto simp add: rev.rev_existence_ivl_eq0 subset_iff)
>   using neg_le_0_iff_le apply fastforce
>   using neg_0_le_iff_le by fastforce
> 
> lemma trapped_backward_iff_rev_trapped_forward:
>   "trapped_backward x K  \<longleftrightarrow> rev.trapped_forward x K"
>   unfolding trapped_backward_def rev.trapped_forward_def
>   by (auto simp add: rev_flow_image_eq existence_ivl_eq_rev0 image_subset_iff)
> 
> text \<open>If solution is trapped in a compact set at some time
>   on its existence interval then it is trapped forever\<close>
> lemma trapped_sol_right:
>   \<comment> \<open>TODO: when building on afp-devel (??? outdated):
>     \<^url>\<open>https://bitbucket.org/isa-afp/afp-devel/commits/0c3edf9248d5389197f248c723b625c419e4d3eb\<close>\<close>
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   shows "{0..} \<subseteq> existence_ivl0 x"
> proof (rule ccontr)
>   assume "\<not> {0..} \<subseteq> existence_ivl0 x"
>   from this obtain t where "0 \<le> t" "t \<notin> existence_ivl0 x" by blast
>   then have bdd: "bdd_above (existence_ivl0 x)" 
>     by (auto intro!: bdd_above_is_intervalI \<open>x \<in> X\<close>)
>   from flow_leaves_compact_ivl_right [OF UNIV_I \<open>x \<in> X\<close> bdd UNIV_I assms(1-2)]
>   show False by (metis assms(4) trapped_forward_def IntI atLeast_iff image_subset_iff)
> qed
> 
> lemma trapped_sol_right_gen:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "t \<in> existence_ivl0 x" "trapped_forward (flow0 x t) K"
>   shows "{t..} \<subseteq> existence_ivl0 x"
> proof -
>   have "x \<in> X"
>     using assms(3) local.existence_ivl_empty_iff by fastforce 
>   have xtk: "flow0 x t \<in> X"
>     by (simp add: assms(3) local.flow_in_domain)
>   from trapped_sol_right[OF assms(1-2) xtk assms(4)] have "{0..} \<subseteq> existence_ivl0 (flow0 x t)" .
>   thus "{t..} \<subseteq> existence_ivl0 x"
>     using existence_ivl_trans[OF assms(3)]
>     by (metis add.commute atLeast_iff diff_add_cancel le_add_same_cancel1 subset_iff)
> qed
> 
> lemma trapped_sol_left:
>   \<comment> \<open>TODO: when building on afp-devel:
>     \<^url>\<open>https://bitbucket.org/isa-afp/afp-devel/commits/0c3edf9248d5389197f248c723b625c419e4d3eb\<close>\<close>
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_backward x K"
>   shows "{..0} \<subseteq> existence_ivl0 x"
> proof (rule ccontr)
>   assume "\<not> {..0} \<subseteq> existence_ivl0 x"
>   from this obtain t where "t \<le> 0" "t \<notin> existence_ivl0 x" by blast
>   then have bdd: "bdd_below (existence_ivl0 x)" 
>     by (auto intro!: bdd_below_is_intervalI \<open>x \<in> X\<close>)
>   from flow_leaves_compact_ivl_left [OF UNIV_I \<open>x \<in> X\<close> bdd UNIV_I assms(1-2)]
>   show False
>     by (metis IntI assms(4) atMost_iff auto_ll_on_open.trapped_backward_def auto_ll_on_open_axioms image_subset_iff)
> qed
> 
> lemma trapped_sol_left_gen:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "t \<in> existence_ivl0 x" "trapped_backward (flow0 x t) K"
>   shows "{..t} \<subseteq> existence_ivl0 x"
> proof -
>   have "x \<in> X"
>     using assms(3) local.existence_ivl_empty_iff by fastforce 
>   have xtk: "flow0 x t \<in> X"
>     by (simp add: assms(3) local.flow_in_domain)
>   from trapped_sol_left[OF assms(1-2) xtk assms(4)] have "{..0} \<subseteq> existence_ivl0 (flow0 x t)" .
>   thus "{..t} \<subseteq> existence_ivl0 x"
>     using existence_ivl_trans[OF assms(3)]
>     by (metis add.commute add_le_same_cancel1 atMost_iff diff_add_cancel subset_eq)
> qed
> 
> lemma trapped_sol:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped x K"
>   shows "existence_ivl0 x = UNIV"
>   by (metis (mono_tags, lifting) assms existence_ivl_zero image_subset_iff interval local.existence_ivl_initial_time_iff local.existence_ivl_subset local.subset_mem_compact_implies_subset_existence_interval order_refl subset_antisym trapped_iff_on_existence_ivl0)
> 
> (* Follows from rectification *)
> lemma regular_locally_noteq:\<comment> \<open>TODO: should be true in \<open>ll_on_open_it\<close>\<close>
>   assumes "x \<in> X" "f x \<noteq> 0"
>   shows "eventually (\<lambda>t. flow0 x t \<noteq> x) (at 0)"
> proof -
>   have nf:"norm (f x) > 0" by (simp add: assms(2)) 
>       (* By continuity of solutions and f probably *)
>   obtain a where
>     a: "a>0"
>     "{-a--a} \<subseteq> existence_ivl0 x"
>     "0 \<in> {-a--a}"
>     "\<And>t. t \<in> {-a--a} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2"
>   proof -
>     from open_existence_ivl'[OF assms(1)]
>     obtain a1 where a1: "a1 > 0" "{-a1..a1} \<subseteq> existence_ivl0 x" .
>     have "continuous (at 0) (\<lambda>t. norm(f (flow0 x t) - f (flow0 x 0) ))"
>       apply (auto intro!: continuous_intros)
>       by (simp add: assms(1) local.f_flow_continuous)
>     then obtain a2 where "a2>0"
>       "\<forall>t. norm t < a2 \<longrightarrow>
>              norm (f (flow0 x t) - f (flow0 x 0)) < norm(f x)/2"
>       unfolding continuous_at_real_range
>       by (metis abs_norm_cancel cancel_comm_monoid_add_class.diff_cancel diff_zero half_gt_zero nf norm_zero)
>     then have 
>       t: "\<And>t. t \<in> {-a2<--<a2} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2"
>       by (smt open_segment_bound(2) open_segment_bound1 real_norm_def)
>     define a where "a = min a1 (a2/2)"
>     have t1:"a > 0" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close> by auto
>     then have t3:"0 \<in>{-a--a}"
>       using closed_segment_eq_real_ivl by auto
>     have "{-a--a} \<subseteq> {-a1..a1}" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close>
>       using ODE_Auxiliarities.closed_segment_eq_real_ivl by auto
>     then have t2:"{-a--a} \<subseteq> existence_ivl0 x" using a1 by auto
>     have "{-a--a} \<subseteq> {-a2<--<a2}" unfolding a_def using \<open>a1 > 0\<close> \<open>a2 > 0\<close>
>       by (smt Diff_iff closed_segment_eq_real_ivl atLeastAtMost_iff empty_iff half_gt_zero insert_iff pos_half_less segment(1) subset_eq)
>     then have t4:"\<And>t. t \<in> {-a--a} \<Longrightarrow> norm(f (flow0 x t) - f (flow0 x 0)) \<le> norm(f x)/2" using t by auto
>     show ?thesis using t1 t2 t3 t4 that by auto
>   qed
>   have "\<And>t. t \<in> {-a--a} \<Longrightarrow> (flow0 x has_vector_derivative f (flow0 x t)) (at t within {-a--a})"
>     apply (rule has_vector_derivative_at_within)
>     using a(2) by (auto intro!:flow_has_vector_derivative)
>   from vector_differentiable_bound_linearization[OF this _ a(4)]
>   have nb:"\<And>c d. {c--d} \<subseteq> {-a--a} \<Longrightarrow>
>    norm (flow0 x d - flow0 x c - (d - c) *\<^sub>R f (flow0 x 0))  \<le> norm (d - c) * (norm (f x) / 2)"
>     using a(3) by blast
>   have "\<And>t. dist t 0 < a \<Longrightarrow> t \<noteq> 0 \<Longrightarrow> flow0 x t \<noteq> x"
>   proof (rule ccontr)
>     fix t
>     assume "dist t 0 < a" "t \<noteq> 0" "\<not> flow0 x t \<noteq> x"
>     then have tx:"flow0 x t = x" by auto
>     have "t \<in> {-a--a}"
>       using closed_segment_eq_real_ivl \<open>dist t 0 < a\<close> by auto
>     have "t > 0 \<or> t < 0" using \<open>t \<noteq> 0\<close> by linarith
>     moreover {
>       assume "t > 0"
>       then have "{0--t} \<subseteq> {-a--a}"
>         by (simp add: \<open>t \<in> {-a--a}\<close> a(3) subset_closed_segment) 
>       from nb[OF this] have
>         "norm (flow0 x t - x - t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)"
>         by (simp add: assms(1))
>       then have "norm (t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)" using tx by auto
>       then have False using nf
>         using \<open>0 < t\<close> by auto 
>     }
>     moreover {
>       assume "t < 0"
>       then have "{t--0} \<subseteq> {-a--a}"
>         by (simp add: \<open>t \<in> {-a--a}\<close> a(3) subset_closed_segment) 
>       from nb[OF this] have
>         "norm (x - flow0 x t + t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)"
>         by (simp add: assms(1))
>       then have "norm (t *\<^sub>R f x) \<le> norm t * (norm (f x) / 2)" using tx by auto
>       then have False using nf
>         using \<open>t < 0\<close> by auto 
>     }
>     ultimately show False by blast
>   qed
>   thus ?thesis unfolding eventually_at
>     using a(1) by blast
> qed
> 
> lemma compact_max_time_flow_in_closed:
>   assumes "closed M" and t_ex: "t \<in> existence_ivl0 x"
>   shows "compact {s \<in> {0..t}. flow0 x ` {0..s} \<subseteq> M}" (is "compact ?C")
>   unfolding compact_eq_bounded_closed
> proof
>   have "bounded {0 .. t}" by auto
>   then show "bounded ?C"
>     by (rule bounded_subset) auto
>   show "closed ?C"
>     unfolding closed_def
>   proof (rule topological_space_class.openI, clarsimp)
>     \<comment> \<open>TODO: there must be a more abstract argument for this, e.g., with
>       @{thm continuous_on_closed_vimageI} and then reasoning about the connected component around 0?\<close>
>     fix s
>     assume notM: "s \<le> t \<longrightarrow> 0 \<le> s \<longrightarrow> \<not> flow0 x ` {0..s} \<subseteq> M"
>     consider "0 \<le> s" "s \<le> t" "flow0 x s \<notin> M" | "0 \<le> s" "s \<le> t" "flow0 x s \<in> M" | "s < 0" | "s > t"
>       by arith
>     then show "\<exists>T. open T \<and> s \<in> T \<and> T \<subseteq> - {s. 0 \<le> s \<and> s \<le> t \<and> flow0 x ` {0..s} \<subseteq> M}"
>     proof cases
>       assume s: "0 \<le> s" "s \<le> t" and sM: "flow0 x s \<notin> M"
>       have "isCont (flow0 x) s"
>         using s ivl_subset_existence_ivl[OF t_ex]
>         by (auto intro!: flow_continuous)
>       from this[unfolded continuous_at_open, rule_format, of "-M"] sM \<open>closed M\<close>
>       obtain S where "open S" "s \<in> S" "(\<forall>x'\<in>S. flow0 x x' \<in> - M)"
>         by auto
>       then show ?thesis
>         by (force intro!: exI[where x=S])
>     next
>       assume s: "0 \<le> s" "s \<le> t" and sM: "flow0 x s \<in> M"
>       from this notM obtain s0 where s0: "0 \<le> s0" "s0 < s" "flow0 x s0 \<notin> M"
>         by force
>       from order_tendstoD(1)[OF tendsto_ident_at \<open>s0 < s\<close>, of UNIV, unfolded eventually_at_topological]
>       obtain S where "open S" "s \<in> S" "\<And>x. x \<in> S \<Longrightarrow> x \<noteq> s \<Longrightarrow> s0 < x"
>         by auto
>       then show ?thesis using s0
>         by (auto simp: intro!: exI[where x=S]) (smt atLeastAtMost_iff image_subset_iff)
>     qed (force intro: exI[where x="{t<..}"] exI[where x="{..<0}"])+
>   qed
> qed
> 
> lemma flow_in_closed_max_timeE:
>   assumes "closed M" "t \<in> existence_ivl0 x" "0 \<le> t" "x \<in> M"
>   obtains T where "0 \<le> T" "T \<le> t" "flow0 x ` {0..T} \<subseteq> M"
>     "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> T"
> proof -
>   let ?C = "{s \<in> {0..t}. flow0 x ` {0..s} \<subseteq> M}"
>   have "?C \<noteq> {}"
>     using assms
>     using local.mem_existence_ivl_iv_defined
>     by (auto intro!: exI[where x=0])
>   from compact_max_time_flow_in_closed[OF assms(1,2)]
>   have "compact ?C" .
>   from compact_attains_sup[OF this \<open>?C \<noteq> {}\<close>]
>   obtain s where s: "0 \<le> s" "s \<le> t" "flow0 x ` {0..s} \<subseteq> M"
>     and s_max: "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> s"
>     by auto
>   then show ?thesis ..
> qed
> 
> lemma flow_leaves_closed_at_frontierE:
>   assumes "closed M" and t_ex: "t \<in> existence_ivl0 x" and "0 \<le> t" "x \<in> M" "flow0 x t \<notin> M"
>   obtains s where "0 \<le> s" "s < t" "flow0 x ` {0..s} \<subseteq> M"
>     "flow0 x s \<in> frontier M"
>     "\<exists>\<^sub>F s' in at_right s. flow0 x s' \<notin> M"
> proof -
>   from flow_in_closed_max_timeE[OF assms(1-4)] assms(5)
>   obtain s where s: "0 \<le> s" "s < t" "flow0 x ` {0..s} \<subseteq> M"
>     and s_max: "\<And>s'. 0 \<le> s' \<Longrightarrow> s' \<le> t \<Longrightarrow> flow0 x ` {0..s'} \<subseteq> M \<Longrightarrow> s' \<le> s"
>     by (smt atLeastAtMost_iff image_subset_iff)
>   note s
>   moreover
>   have "flow0 x s \<notin> interior M"
>   proof
>     assume interior: "flow0 x s \<in> interior M"
>     have "s \<in> existence_ivl0 x" using ivl_subset_existence_ivl[OF \<open>t \<in> _\<close>] s by auto
>     from flow_continuous[OF this, THEN isContD, THEN topological_tendstoD, OF open_interior interior]
>     have "\<forall>\<^sub>F s' in at s. flow0 x s' \<in> interior M" by auto
>     then have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> interior M"
>       by (auto simp: eventually_at_split)
>     moreover have "\<forall>\<^sub>F s' in at_right s. s' < t"
>       using tendsto_ident_at \<open>s < t\<close>
>       by (rule order_tendstoD)
>     ultimately have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> M \<and> s' < t"
>       by eventually_elim (use interior_subset[of M] in auto)
>     then obtain s' where s': "s < s'" "s' < t" "\<And>y. y > s \<Longrightarrow> y \<le> s' \<Longrightarrow> flow0 x y \<in> M"
>       by (auto simp: eventually_at_right_field_le)
>     have s'_ivl: "flow0 x ` {0..s'} \<subseteq> M"
>     proof safe
>       fix s'' assume "s'' \<in> {0 .. s'}"
>       then show "flow0 x s'' \<in> M"
>         using s interior_subset[of M] s'
>         by (cases "s'' \<le> s") auto
>     qed
>     with s_max[of s'] \<open>s' < t\<close> \<open>0 \<le> s\<close> \<open>s < s'\<close> show False by auto
>   qed
>   then have "flow0 x s \<in> frontier M"
>     using s closure_subset[of M]
>     by (force simp: frontier_def)
>   moreover
>   have "compact (flow0 x -` M \<inter> {s..t})" (is "compact ?C")
>     unfolding compact_eq_bounded_closed
>   proof
>     have "bounded {s .. t}" by simp
>     then show "bounded ?C"
>       by (rule bounded_subset) auto
>     show "closed ?C"
>       using \<open>closed M\<close> assms mem_existence_ivl_iv_defined(2)[OF t_ex] ivl_subset_existence_ivl[OF t_ex] \<open>0 \<le> s\<close>
>       by (intro closed_vimage_Int) (auto intro!: continuous_intros)
>   qed
>   have "\<exists>\<^sub>F s' in at_right s. flow0 x s' \<notin> M"
>     apply (rule ccontr)
>     unfolding not_frequently
>   proof -
>     assume "\<forall>\<^sub>F s' in at_right s. \<not> flow0 x s' \<notin> M"
>     moreover have "\<forall>\<^sub>F s' in at_right s. s' < t"
>       using tendsto_ident_at \<open>s < t\<close>
>       by (rule order_tendstoD)
>     ultimately have "\<forall>\<^sub>F s' in at_right s. flow0 x s' \<in> M \<and> s' < t" by eventually_elim auto
>     then obtain s' where s': "s < s'"
>       "\<And>y. y > s \<Longrightarrow> y < s' \<Longrightarrow> flow0 x y \<in> M"
>       "\<And>y. y > s \<Longrightarrow> y < s' \<Longrightarrow> y < t"
>       by (auto simp: eventually_at_right_field)
>     define s'' where "s'' = (s + s') / 2"
>     have "0 \<le> s''" "s'' \<le> t"  "s < s''" "s'' < s'"
>       using s s'
>       by (auto simp del: divide_le_eq_numeral1 le_divide_eq_numeral1 simp: s''_def) fastforce
>     then have "flow0 x ` {0..s''} \<subseteq> M"
>       using s s'
>       apply (auto simp: )
>       subgoal for u
>         by (cases "u\<le>s") auto
>       done
>     from s_max[OF \<open>0 \<le> s''\<close> \<open>s''\<le> t\<close> this] \<open>s'' > s\<close>
>     show False by simp
>   qed
>   ultimately show ?thesis ..
> qed
> 
> 
> subsection \<open>Connectedness\<close>
> 
> lemma fcontX:
>   shows "continuous_on X f"
>   using auto_local_lipschitz local_lipschitz_continuous_on by blast
> 
> lemma fcontx:
>   assumes "x \<in> X"
>   shows "continuous (at x) f"
> proof -
>   have "open X" by simp
>   from continuous_on_eq_continuous_at[OF this]
>   show ?thesis using fcontX assms(1) by blast
> qed
> 
> lemma continuous_at_imp_cball:
>   assumes "continuous (at x) g"
>   assumes "g x > (0::real)"
>   obtains r where "r > 0" "\<forall>y \<in> cball x r. g y > 0"
> proof -
>   from assms(1)
>   obtain d where "d>0" "g ` (ball x d) \<subseteq> ball (g x) ((g x)/2)"
>     by (meson assms(2) continuous_at_ball half_gt_zero)
>   then have "\<forall>y \<in> cball x (d/2). g y > 0"
>     by (smt assms(2) dist_norm image_subset_iff mem_ball mem_cball pos_half_less real_norm_def)
>   thus ?thesis
>     using \<open>0 < d\<close> that half_gt_zero by blast
> qed
> 
> text \<open> \<open>flow0\<close> is \<open>path_connected\<close> \<close>
> lemma flow0_path_connected_time:
>   assumes "ts \<subseteq> existence_ivl0 x" "path_connected ts"
>   shows "path_connected (flow0 x ` ts)"
> proof -
>   have "continuous_on ts (flow0 x)"
>     by (meson assms continuous_on_sequentially flow_continuous_on subsetD)
>   from path_connected_continuous_image[OF this assms(2)] 
>   show ?thesis .
> qed
> 
> lemma flow0_path_connected:
>   assumes "path_connected D"
>     "path_connected ts"
>     "\<And>x. x \<in> D \<Longrightarrow> ts \<subseteq> existence_ivl0 x"
>   shows "path_connected ( (\<lambda>(x, y). flow0 x y) ` (D \<times> ts))"
> proof -
>   have "D \<times> ts \<subseteq> Sigma X existence_ivl0"
>     using assms(3) subset_iff by fastforce
>   then have a1:"continuous_on (D \<times> ts) (\<lambda>(x, y). flow0 x y)"
>     using flow_continuous_on_state_space continuous_on_subset by blast 
>   have a2 : "path_connected (D \<times> ts)" using path_connected_Times assms by auto
>   from path_connected_continuous_image[OF a1 a2]
>   show ?thesis .
> qed
> 
> end
> 
> subsection \<open>Return Time and Implicit Function Theorem\<close>
> 
> context c1_on_open_euclidean begin
> 
> lemma flow_implicit_function:
>   \<comment> \<open>TODO: generalization of @{thm returns_to_implicit_function}!\<close>
>   fixes s::"'a::euclidean_space \<Rightarrow> real" and S::"'a set"
>   assumes t: "t \<in> existence_ivl0 x" and x: "x \<in> X" and st: "s (flow0 x t) = 0"
>   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
>   assumes DsC: "isCont Ds (flow0 x t)"
>   assumes nz: "Ds (flow0 x t) (f (flow0 x t)) \<noteq> 0"
>   obtains u e
>   where "s (flow0 x (u x)) = 0"
>     "u x = t"
>     "(\<And>y. y \<in> cball x e \<Longrightarrow> s (flow0 y (u y)) = 0)"
>     "continuous_on (cball x e) u"
>     "(\<lambda>t. (t, u t)) ` cball x e \<subseteq> Sigma X existence_ivl0"
>     "0 < e" "(u has_derivative (- blinfun_scaleR_left
>                    (inverse (blinfun_apply (Ds (flow0 x t)) (f (flow0 x t)))) o\<^sub>L
>                       (Ds (flow0 x t) o\<^sub>L flowderiv x t) o\<^sub>L embed1_blinfun)) (at x)"
> proof -
>   note [derivative_intros] = has_derivative_compose[OF _ Ds]
>   have cont_s: "continuous_on UNIV s" by (rule has_derivative_continuous_on[OF Ds])
>   note cls[simp, intro] = closed_levelset[OF cont_s]
>   then have xt1: "(x, t) \<in> Sigma X existence_ivl0"
>     by (auto simp: t x)
>   have D: "(\<And>x. x \<in> Sigma X existence_ivl0 \<Longrightarrow>
>       ((\<lambda>(x, t). s (flow0 x t)) has_derivative
>        blinfun_apply (Ds (flow0 (fst x) (snd x)) o\<^sub>L (flowderiv (fst x) (snd x))))
>        (at x))"
>     by (auto intro!: derivative_eq_intros)
>   have C: "isCont (\<lambda>x. Ds (flow0 (fst x) (snd x)) o\<^sub>L flowderiv (fst x) (snd x))
>    (x, t)"
>     using flowderiv_continuous_on[unfolded continuous_on_eq_continuous_within,
>         rule_format, OF xt1]
>     using at_within_open[OF xt1 open_state_space]
>     by (auto intro!: continuous_intros tendsto_eq_intros x t
>         isCont_tendsto_compose[OF DsC, unfolded poincare_map_def]
>         simp: split_beta' isCont_def)
>   have Z: "(case (x, t) of (x, t) \<Rightarrow> s (flow0 x t)) = 0"
>     by (auto simp: st)
>   have I1: "blinfun_scaleR_left (inverse (Ds (flow0 x t)(f (flow0 x t)))) o\<^sub>L 
>     ((Ds (flow0 (fst (x, t))
>             (snd (x, t))) o\<^sub>L
>        flowderiv (fst (x, t))
>         (snd (x, t))) o\<^sub>L
>       embed2_blinfun)
>      = 1\<^sub>L"
>     using nz
>     by (auto intro!: blinfun_eqI
>         simp: flowderiv_def blinfun.bilinear_simps inverse_eq_divide poincare_map_def)
>   have I2: "((Ds (flow0 (fst (x, t))
>             (snd (x, t))) o\<^sub>L
>        flowderiv (fst (x, t))
>         (snd (x, t))) o\<^sub>L
>       embed2_blinfun) o\<^sub>L blinfun_scaleR_left (inverse (Ds (flow0 x t)(f (flow0 x t))))
>      = 1\<^sub>L"
>     using nz
>     by (auto intro!: blinfun_eqI
>         simp: flowderiv_def blinfun.bilinear_simps inverse_eq_divide poincare_map_def)
>   show ?thesis
>     apply (rule implicit_function_theorem[where f="\<lambda>(x, t). s (flow0 x t)"
>           and S="Sigma X existence_ivl0", OF D xt1 open_state_space order_refl C Z I1 I2])
>      apply blast
>     unfolding split_beta' fst_conv snd_conv poincare_map_def[symmetric]
>     ..
> qed
> 
> lemma flow_implicit_function_at:
>   fixes s::"'a::euclidean_space \<Rightarrow> real" and S::"'a set"
>   assumes x: "x \<in> X" and st: "s x = 0"
>   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
>   assumes DsC: "isCont Ds x"
>   assumes nz: "Ds x (f x) \<noteq> 0"
>   assumes pos: "e > 0"
>   obtains u d
>   where
>     "0 < d"
>     "u x = 0"
>     "\<And>y. y \<in> cball x d \<Longrightarrow> s (flow0 y (u y)) = 0"
>     "\<And>y. y \<in> cball x d \<Longrightarrow> \<bar>u y\<bar> < e"
>     "\<And>y. y \<in> cball x d \<Longrightarrow> u y \<in> existence_ivl0 y"
>     "continuous_on (cball x d) u"
>     "(u has_derivative -Ds x /\<^sub>R (Ds x) (f x)) (at x)"
> proof -
>   have x0: "flow0 x 0 = x" by (simp add: x)
>   from flow_implicit_function[OF existence_ivl_zero[OF x] x, unfolded x0, of s, OF st Ds DsC nz]
>   obtain u d0 where
>     s0: "s (flow0 x (u x)) = 0"
>     and u0: "u x = 0"
>     and u: "\<And>y. y \<in> cball x d0 \<Longrightarrow> s (flow0 y (u y)) = 0"
>     and uc: "continuous_on (cball x d0) u"
>     and uex: "(\<lambda>t. (t, u t)) ` cball x d0 \<subseteq> Sigma X existence_ivl0"
>     and d0: "0 < d0"
>     and u': "(u has_derivative
>      blinfun_apply
>       (- blinfun_scaleR_left (inverse (blinfun_apply (Ds x) (f x))) o\<^sub>L (Ds x o\<^sub>L flowderiv x 0) o\<^sub>L embed1_blinfun))
>      (at x)"
>     by blast
>   have "at x within cball x d0 = at x" by (rule at_within_interior) (auto simp: \<open>0 < d0\<close>)
>   then have "(u \<longlongrightarrow> 0) (at x)"
>     using uc d0 by (auto simp: continuous_on_def u0 dest!: bspec[where x=x])
>   from tendstoD[OF this \<open>0 < e\<close>] pos u0
>   obtain d1 where d1: "0 < d1" "\<And>xa. dist xa x \<le> d1 \<Longrightarrow> \<bar>u xa\<bar> < e"
>     unfolding eventually_at_le
>     by force
>   define d where "d = min d0 d1"
>   have "0 < d" by (auto simp: d_def d0 d1)
>   moreover note u0
>   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> s (flow0 y (u y)) = 0" by (auto intro!: u simp: d_def)
>   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> \<bar>u y\<bar> < e" using d1 by (auto simp: d_def dist_commute)
>   moreover have "\<And>y. y \<in> cball x d \<Longrightarrow> u y \<in> existence_ivl0 y"
>     using uex by (force simp: d_def)
>   moreover have "continuous_on (cball x d) u"
>     using uc by (rule continuous_on_subset) (auto simp: d_def)
>   moreover
>   have "(u has_derivative -Ds x /\<^sub>R (Ds x) (f x)) (at x)"
>     using u'
>     by (rule has_derivative_subst) (auto intro!: ext simp: x x0 flowderiv_def blinfun.bilinear_simps)
>   ultimately show ?thesis ..
> qed
> 
> lemma returns_to_implicit_function_gen:
>   \<comment> \<open>TODO: generalizes proof of @{thm returns_to_implicit_function}!\<close>
>   fixes s::"'a::euclidean_space \<Rightarrow> real"
>   assumes rt: "returns_to {x \<in> S. s x = 0} x" (is "returns_to ?P x")
>   assumes cS: "closed S"
>   assumes Ds: "\<And>x. (s has_derivative blinfun_apply (Ds x)) (at x)"
>     "isCont Ds (poincare_map ?P x)"
>     "Ds (poincare_map ?P x) (f (poincare_map ?P x)) \<noteq> 0"
>   obtains u e
>   where "s (flow0 x (u x)) = 0"
>     "u x = return_time ?P x"
>     "(\<And>y. y \<in> cball x e \<Longrightarrow> s (flow0 y (u y)) = 0)"
>     "continuous_on (cball x e) u"
>     "(\<lambda>t. (t, u t)) ` cball x e \<subseteq> Sigma X existence_ivl0"
>     "0 < e" "(u has_derivative (- blinfun_scaleR_left
>                    (inverse (blinfun_apply (Ds (poincare_map ?P x)) (f (poincare_map ?P x)))) o\<^sub>L
>                       (Ds (poincare_map ?P x) o\<^sub>L flowderiv x (return_time ?P x)) o\<^sub>L embed1_blinfun)) (at x)"
> proof -
>   note [derivative_intros] = has_derivative_compose[OF _ Ds(1)]
>   have cont_s: "continuous_on UNIV s" by (rule has_derivative_continuous_on[OF Ds(1)])
>   note cls[simp, intro] = closed_levelset[OF cont_s]
>   let ?t1 = "return_time ?P x"
>   have cls[simp, intro]: "closed {x \<in> S. s x = 0}"
>     by (rule closed_levelset_within) (auto intro!: cS continuous_on_subset[OF cont_s])
> 
>   have *: "poincare_map ?P x = flow0 x (return_time {x \<in> S. s x = 0} x)"
>     by (simp add: poincare_map_def)
>   have "return_time {x \<in> S. s x = 0} x \<in> existence_ivl0 x"
>     "x \<in> X"
>     "s (poincare_map ?P x) = 0"
>     using poincare_map_returns rt
>     by (auto intro!: return_time_exivl rt)
>   note E = flow_implicit_function[of "return_time ?P x" x s Ds, OF this[unfolded *] Ds[unfolded *],
>       folded *]
>   show ?thesis
>     by (rule E) rule
> qed
> 
> text \<open>c.f. Perko Section 3.7 Lemma 2 part 1.\<close>
> 
> lemma flow_transversal_surface_finite_intersections:
>   fixes s::"'a \<Rightarrow> 'b::real_normed_vector"
>     and Ds::"'a \<Rightarrow> 'a \<Rightarrow>\<^sub>L 'b"
>   assumes "closed S"
>   assumes "\<And>x. (s has_derivative (Ds x)) (at x)"
>   assumes "\<And>x. x \<in> S \<Longrightarrow> s x = 0 \<Longrightarrow> Ds x (f x) \<noteq> 0"
>   assumes "a \<le> b" "{a .. b} \<subseteq> existence_ivl0 x"
>   shows "finite {t\<in>{a..b}. flow0 x t \<in> {x \<in> S. s x = 0}}"
>     \<comment> \<open>TODO: define notion of (compact/closed)-(continuous/differentiable/C1)-surface?\<close>
> proof cases
>   note Ds = \<open>\<And>x. (s has_derivative (Ds x)) (at x)\<close>
>   note transversal = \<open>\<And>x. x \<in> S \<Longrightarrow> s x = 0 \<Longrightarrow> Ds x (f x) \<noteq> 0\<close>
>   assume "a < b"
>   show ?thesis
>   proof (rule ccontr)
>     let ?S = "{x \<in> S. s x = 0}"
>     let ?T = "{t\<in>{a..b}. flow0 x t \<in> {x \<in> S. s x = 0}}"
>     define \<phi> where "\<phi> = flow0 x"
>     have [THEN continuous_on_compose2, continuous_intros]: "continuous_on S s"
>       by (auto simp: intro!: has_derivative_continuous_on Ds intro: has_derivative_at_withinI)
>     assume "infinite ?T"
>     from compact_sequentialE[OF compact_Icc[of a b] this]
>     obtain t tl where t: "t n \<in> ?T" "flow0 x (t n) \<in> ?S" "t n \<in> {a .. b}" "t n \<noteq> tl"
>       and tl: "t \<longlonglongrightarrow> tl" "tl \<in> {a..b}"
>     for n
>       by force
>     have tl_ex: "tl \<in> existence_ivl0 x" using \<open>{a .. b} \<subseteq> existence_ivl0 x\<close> \<open>tl \<in> {a .. b}\<close> by auto
>     have "closed ?S"
>       by (auto intro!: closed_levelset_within \<open>closed S\<close> continuous_intros)
>     moreover
>     have "\<forall>n. flow0 x (t n) \<in> ?S"
>       using t by auto
>     moreover
>     have flow_t: "(\<lambda>n. flow0 x (t n)) \<longlonglongrightarrow> flow0 x tl"
>       by (auto intro!: tendsto_eq_intros tl_ex tl)
>     ultimately have "flow0 x tl \<in> ?S"
>       by (rule closed_sequentially)
> 
>     let ?qt = "\<lambda>t. (flow0 x t - flow0 x tl) /\<^sub>R (t - tl)"
>     from flow_has_vector_derivative[OF tl_ex, THEN has_vector_derivative_withinD]
>     have qt_tendsto: "?qt \<midarrow>tl\<rightarrow> f (flow0 x tl)" .
>     let ?q = "\<lambda>n. ?qt (t n)"
>     have "filterlim t (at tl) sequentially"
>       using tl(1)
>       by (rule filterlim_atI) (simp add: t)
>     with qt_tendsto have "?q \<longlonglongrightarrow> f (flow0 x tl)"
>       by (rule filterlim_compose)
>     then have "((\<lambda>n. Ds (flow0 x tl) (?q n))) \<longlonglongrightarrow> Ds (flow0 x tl) (f (flow0 x tl))"
>       by (auto intro!: tendsto_intros)
>     moreover
> 
>     from flow_lipschitzE[OF \<open>{a .. b} \<subseteq> existence_ivl0 x\<close>] obtain L' where L': "L'-lipschitz_on {a..b} (flow0 x)" .
>     define L where "L = L' + 1"
>     from lipschitz_on_le[OF L', of L] lipschitz_on_nonneg[OF L']
>     have L: "L-lipschitz_on {a .. b} (flow0 x)" and "L > 0"
>       by (auto simp: L_def)
>     from flow_lipschitzE[OF \<open>{a .. b} \<subseteq> existence_ivl0 x\<close>] obtain L' where "L'-lipschitz_on {a..b} (flow0 x)" .
>         \<comment> \<open>TODO: is this reasoning (below) with this Lipschitz constant really necessary?\<close>
>     have s[simp]: "s (flow0 x (t n)) = 0""s (flow0 x tl) = 0"
>       for n
>       using t \<open>flow0 x tl \<in> ?S\<close>
>       by auto
> 
>     from Ds(1)[of "flow0 x tl", unfolded has_derivative_within]
>     have "(\<lambda>y. (1 / norm (y - flow0 x tl)) *\<^sub>R (s y - (s (flow0 x tl) + blinfun_apply (Ds (flow0 x tl)) (y - flow0 x tl)))) \<midarrow>flow0 x tl\<rightarrow> 0"
>       by auto
>     then have "((\<lambda>y. (1 / norm (y - flow0 x tl)) *\<^sub>R (s y - (s (flow0 x tl) + blinfun_apply (Ds (flow0 x tl)) (y - flow0 x tl)))) \<longlongrightarrow> 0)
>       (nhds (flow0 x tl))"
>       by (rule tendsto_nhds_continuousI) simp
> 
>     from filterlim_compose[OF this flow_t]
>     have "(\<lambda>xa. (blinfun_apply (Ds (flow0 x tl)) (flow0 x (t xa) - flow0 x tl)) /\<^sub>R norm (flow0 x (t xa) - flow0 x tl))
>       \<longlonglongrightarrow> 0"
>       using t
>       by (auto simp: inverse_eq_divide tendsto_minus_cancel_right)
>     from tendsto_mult[OF tendsto_const[of "L"] tendsto_norm[OF this, simplified, simplified divide_inverse_commute[symmetric]]]\<comment> \<open>TODO: uuugly\<close>
>     have Ds0: "(\<lambda>xa. norm (blinfun_apply (Ds (flow0 x tl)) (flow0 x (t xa) - flow0 x tl)) / (norm (flow0 x (t xa) - flow0 x tl)/(L))) \<longlonglongrightarrow> 0"
>       by (auto simp: ac_simps)
> 
>     from _ Ds0 have "((\<lambda>n. Ds (flow0 x tl) (?q n)) \<longlonglongrightarrow> 0)"
>       apply (rule Lim_null_comparison)
>       apply (rule eventuallyI)
>       unfolding norm_scaleR blinfun.scaleR_right abs_inverse divide_inverse_commute[symmetric]
>       subgoal for n
>         apply (cases "flow0 x (t n) = flow0 x tl")
>         subgoal by (simp add: blinfun.bilinear_simps)
>         subgoal
>           apply (rule divide_left_mono)
>           using lipschitz_onD[OF L, of "t n" tl] \<open>0 < L\<close> t(3) tl(2)
>           by (auto simp: algebra_split_simps zero_less_divide_iff dist_norm pos_divide_le_eq
>               intro!: add_pos_nonneg)
>         done
>       done
>     ultimately have "Ds (flow0 x tl) (f (flow0 x tl)) = 0"
>       by (rule LIMSEQ_unique)
>     moreover have "Ds (flow0 x tl) (f (flow0 x tl)) \<noteq> 0"
>       by (rule transversal) (use \<open>flow0 x tl \<in> ?S\<close> in auto)
>     ultimately show False by auto
>   qed
> qed (use assms in auto)
> 
> lemma uniform_limit_flow0_state:\<comment> \<open>TODO: is that something more general?\<close>
>   assumes "compact C"
>   assumes "C \<subseteq> X"
>   shows "uniform_limit C (\<lambda>s x. flow0 x s) (\<lambda>x. flow0 x 0) (at 0)"
> proof (cases "C = {}")
>   case True then show ?thesis by auto
> next
>   case False show ?thesis
>   proof (rule uniform_limitI)
>     fix e::real assume "0 < e"
>     {
>       fix x assume "x \<in> C"
>       with assms have "x \<in> X" by auto
>       from existence_ivl_cballs[OF UNIV_I \<open>x \<in> X\<close>]
>       obtain t L u where "\<And>y. y \<in> cball x u \<Longrightarrow> cball 0 t \<subseteq> existence_ivl0 y"
>         "\<And>s y. y \<in> cball x u \<Longrightarrow> s \<in> cball 0 t \<Longrightarrow> flow0 y s \<in> cball y u"
>         "L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)"
>         "\<And>y. y \<in> cball x u \<Longrightarrow> cball y u \<subseteq> X"
>         "0 < t" "0 < u"
>         by metis
>       then have "\<exists>L. \<exists>u>0. \<exists>t>0. L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)" by blast
>     } then have "\<forall>x\<in>C. \<exists>L. \<exists>u>0. \<exists>t>0. L-lipschitz_on (cball 0 t\<times>cball x u) (\<lambda>(t, x). flow0 x t)" ..
>     then obtain L d' u' where
>       L: "\<And>x. x \<in> C \<Longrightarrow> (L x)-lipschitz_on (cball 0 (d' x)\<times>cball x (u' x)) (\<lambda>(t, x). flow0 x t)"
>       and d': "\<And>x. x \<in> C \<Longrightarrow> d' x > 0"
>       and u': "\<And>x. x \<in> C \<Longrightarrow> u' x > 0"
>       by metis
>     have "C \<subseteq> (\<Union>c\<in>C. ball c (u' c))" using u' by auto
>     from compactE_image[OF \<open>compact C\<close> _ this]
>     obtain C' where "C' \<subseteq> C" and [simp]: "finite C'" and C'_cover: "C \<subseteq> (\<Union>c\<in>C'. ball c (u' c))"
>       by auto
>     from C'_cover obtain c' where c': "x \<in> C \<Longrightarrow> x \<in> ball (c' x) (u' (c' x))" "x \<in> C \<Longrightarrow> c' x \<in> C'" for x
>       by (auto simp: subset_iff) metis
>     have "\<forall>\<^sub>F s in at 0. \<forall>x\<in>ball c (u' c). dist (flow0 x s) (flow0 x 0) < e" if "c \<in> C'" for c
>     proof -
>       have cC: "c \<in> C"
>         using c' \<open>c \<in> C'\<close> d' \<open>C' \<subseteq> C\<close>
>         by auto
>       have *: "dist (flow0 x s) (flow0 x 0) \<le> L c * \<bar>s\<bar>"
>         if "x\<in>ball c (u' c)"
>           "s \<in> cball 0 (d' c)"
>         for x s
>       proof -
>         from L[OF cC, THEN lipschitz_onD, of "(0, x)" "(s, x)"] d'[OF cC] that
>         show ?thesis
>           by (auto simp: dist_prod_def dist_commute)
>       qed
>       have "\<forall>\<^sub>F s in at 0. abs s < d' c"
>         by (rule order_tendstoD tendsto_intros)+ (use d' cC in auto)
>       moreover have "\<forall>\<^sub>F s in at 0. L c * \<bar>s\<bar> < e"
>         by (rule order_tendstoD tendsto_intros)+ (use \<open>0 < e\<close> in auto)
>       ultimately show ?thesis
>         apply eventually_elim
>         apply (use * in auto)
>         by smt
>     qed
>     then have "\<forall>\<^sub>F s in at 0. \<forall>c\<in>C'. \<forall>x\<in>ball c (u' c). dist (flow0 x s) (flow0 x 0) < e"
>       by (simp add: eventually_ball_finite_distrib)
>     then show "\<forall>\<^sub>F s in at 0. \<forall>x\<in>C. dist (flow0 x s) (flow0 x 0) < e"
>       apply eventually_elim
>       apply (auto simp: )
>       subgoal for s x
>         apply (drule bspec[where x="c' x"])
>          apply (simp add: c'(2))
>         apply (drule bspec) prefer 2 apply assumption
>         apply auto
>         using c'(1) by auto
>       done
>   qed
> qed
> 
> end
> 
> subsection \<open>Fixpoints\<close>
> 
> context auto_ll_on_open begin
> 
> lemma fixpoint_sol:
>   assumes "x \<in> X" "f x = 0"
>   shows "existence_ivl0 x = UNIV" "flow0 x t = x"
> proof -
>   have sol: "((\<lambda>t::real. x) solves_ode (\<lambda>_. f)) UNIV X"
>     apply (rule solves_odeI)
>     by(auto simp add: assms intro!: derivative_intros)
>   from maximal_existence_flow[OF sol] have
>     "UNIV \<subseteq> existence_ivl0 x" "flow0 x t = x" by auto
>   thus "existence_ivl0 x = UNIV" "flow0 x t = x" by auto
> qed
> 
> end
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Periodic_Orbit.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Periodic_Orbit.thy
1,540c1,540
< section \<open>Periodic Orbits\<close>
< theory Periodic_Orbit
<   imports 
<     Ordinary_Differential_Equations.ODE_Analysis
<     Analysis_Misc
<     ODE_Misc
<     Limit_Set
< begin
< 
< text \<open> Definition of closed and periodic orbits and their associated properties \<close>
< 
< context auto_ll_on_open
< begin
< 
< text \<open>
<    TODO: not sure if the "closed orbit" terminology is standard
<    Closed orbits have some non-zero recurrence time T where the flow returns to the initial state
<    The period of a closed orbit is the infimum of all positive recurrence times
<    Periodic orbits are the subset of closed orbits where the period is non-zero
<   \<close>
< 
< definition "closed_orbit x \<longleftrightarrow>
<   (\<exists>T \<in> existence_ivl0 x. T \<noteq> 0 \<and> flow0 x T = x)"
< 
< definition "period x =
<   Inf {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
< 
< definition "periodic_orbit x \<longleftrightarrow>
<   closed_orbit x \<and> period x > 0"
< 
< lemma recurrence_time_flip_sign:
<   assumes "T \<in> existence_ivl0 x" "flow0 x T = x"
<   shows "-T \<in> existence_ivl0 x" "flow0 x (-T) = x"
<   using assms existence_ivl_reverse apply fastforce
<   using assms flows_reverse by fastforce  
< 
< lemma closed_orbit_recurrence_times_nonempty:
<   assumes "closed_orbit x"
<   shows " {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x} \<noteq> {}"
<   apply auto
<   using assms(1) unfolding closed_orbit_def
<   by (smt recurrence_time_flip_sign)
< 
< lemma closed_orbit_recurrence_times_bdd_below:
<   shows "bdd_below {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
<   unfolding bdd_below_def
<   by (auto) (meson le_cases not_le)
< 
< lemma closed_orbit_period_nonneg:
<   assumes "closed_orbit x"
<   shows "period x \<ge> 0"
<   unfolding period_def
<   using assms(1) unfolding closed_orbit_def apply (auto intro!:cInf_greatest)
<   by (smt recurrence_time_flip_sign)
< 
< lemma closed_orbit_in_domain:
<   assumes "closed_orbit x"
<   shows "x \<in> X"
<   using assms unfolding closed_orbit_def
<   using local.mem_existence_ivl_iv_defined(2) by blast
< 
< lemma closed_orbit_global_existence:
<   assumes "closed_orbit x"
<   shows "existence_ivl0 x = UNIV"
< proof -
<   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
<     unfolding closed_orbit_def by blast
<   then obtain T where T: "T > 0" "T \<in> existence_ivl0 x" "flow0 x T = x"
<     by (smt recurrence_time_flip_sign)
<   have apos: "real n * T \<in> existence_ivl0 x \<and> flow0 x (real n * T) = x" for n
<   proof (induction n)
<     case 0
<     then show ?case using closed_orbit_in_domain assms by auto
<   next
<     case (Suc n)
<     fix n
<     assume ih:"real n * T \<in> existence_ivl0 x \<and> flow0 x (real n * T) = x"
<     then have "T \<in> existence_ivl0 (flow0 x (real n * T))" using T by metis
<     then have l:"real n * T + T \<in> existence_ivl0 x" using ih
<       using existence_ivl_trans by blast 
<     have "flow0 (flow0 x (real n * T)) T = x" using ih T by metis
<     then have r: "flow0 x (real n * T + T) = x"
<       by (simp add: T(2) ih local.flow_trans)
<     show "real (Suc n) * T \<in> existence_ivl0 x \<and> flow0 x (real (Suc n) * T) = x"
<       using l r
<       by (simp add: add.commute distrib_left mult.commute)
<   qed
<   then have aneg: "-real n * T \<in> existence_ivl0 x \<and> flow0 x (-real n * T) = x" for n
<     by (simp add: recurrence_time_flip_sign)
<   have "\<forall>t. t \<in> existence_ivl0 x"
<   proof safe
<     fix t
<     have "t \<ge> 0 \<or> t \<le> (0::real)" by linarith
<     moreover {
<       assume "t \<ge> 0"
<       obtain k where "real k * T > t"
<         using T(1) ex_less_of_nat_mult by blast
<       then have "t \<in> existence_ivl0 x" using apos
<         by (meson \<open>0 \<le> t\<close> atLeastAtMost_iff less_eq_real_def local.ivl_subset_existence_ivl subset_eq) 
<     }
<     moreover {
<       assume "t \<le> 0"
<       obtain k where "- real k * T < t"
<         by (metis T(1) add.inverse_inverse ex_less_of_nat_mult mult.commute mult_minus_right neg_less_iff_less)
<       then have "t \<in> existence_ivl0 x" using aneg
<         by (smt apos atLeastAtMost_iff calculation(2) local.existence_ivl_trans' local.ivl_subset_existence_ivl mult_minus_left subset_eq)
<     }
<     ultimately show "t \<in> existence_ivl0 x" by blast
<   qed
<   thus ?thesis by auto
< qed
< 
< lemma recurrence_time_multiples:
<   fixes n::nat
<   assumes "T \<in> existence_ivl0 x" "T \<noteq> 0" "flow0 x T = x"
<   shows "\<And>t. flow0 x (t+T*n) = flow0 x t"
< proof (induction n)
<   case 0
<   then show ?case by auto
< next
<   case (Suc n)
<   fix n t
<   assume ih : "(\<And>t. flow0 x (t + T * real n) = flow0 x t)"
<   have "closed_orbit x" using assms unfolding closed_orbit_def by auto
<   from closed_orbit_global_existence[OF this] have ex:"existence_ivl0 x = UNIV" .
<   have "flow0 x (t + T * real (Suc n)) = flow0 x (t+T*real n + T)"
<     by (simp add: Groups.add_ac(3) add.commute distrib_left)
<   also have "... = flow0 (flow0 x (t+ T*real n)) T" using ex
<     by (simp add: local.existence_ivl_trans' local.flow_trans)
<   also have "... = flow0 (flow0 x t) T" using ih by auto
<   also have "... = flow0 (flow0 x T) t" using ex
<     by (metis UNIV_I add.commute local.existence_ivl_trans' local.flow_trans)
<   finally show "flow0 x (t + T * real (Suc n)) = flow0 x t" using assms(3) by simp
< qed
< 
< lemma nasty_arithmetic1:
<   fixes t T::real
<   assumes "T > 0" "t \<ge> 0"
<   obtains q r where "t = (q::nat) * T + r" "0 \<le> r" "r < T"
< proof -
<   define q where "q = floor (t / T)"
<   have q:"q \<ge> 0" using assms unfolding q_def by auto
<   from floor_divide_lower[OF assms(1), of t]
<   have ql: "q * T \<le> t" unfolding q_def .
<   from floor_divide_upper[OF assms(1), of t]
<   have qu: "t < (q + 1)* T" unfolding q_def by auto
<   define r where "r = t - q * T"
<   have rl:"0 \<le> r" using ql unfolding r_def by auto
<   have ru:"r < T" using qu unfolding r_def  by (simp add: distrib_right)
<   show ?thesis using q r_def rl ru
<     by (metis le_add_diff_inverse of_int_of_nat_eq plus_int_code(2) ql that zle_iff_zadd)
< qed
< 
< lemma nasty_arithmetic2:
<   fixes t T::real
<   assumes "T > 0" "t \<le> 0"
<   obtains q r where "t = (q::nat) * (-T) + r" "0 \<le> r" "r < T"
< proof -
<   have "-t \<ge> 0" using assms(2) by linarith
<   from nasty_arithmetic1[OF assms(1) this]
<   obtain q r where qr: "-t = (q::nat) * T + r" "0 \<le> r" "r < T" by blast
<   then have "t = q * (-T) - r"  by auto
<   then have "t = (q+(1::nat)) * (-T) + (T-r)" by (simp add: distrib_right)
<   thus ?thesis using qr(2-3)
<     by (smt \<open>t = real q * - T - r\<close> that) 
< qed
< 
< lemma recurrence_time_restricts_compact_flow:
<   assumes "T \<in> existence_ivl0 x" "T > 0" "flow0 x T = x"
<   shows "flow0 x ` UNIV = flow0 x ` {0..T}"
<   apply auto
< proof -
<   fix t
<   have "t \<ge> 0 \<or> t \<le> (0::real)" by linarith
<   moreover {
<     assume "t \<ge> 0"
<     from nasty_arithmetic1[OF assms(2) this]
<     obtain q r where qr:"t = (q::nat) * T + r" "0 \<le> r" "r < T" by blast
<     have "T \<noteq> 0" using assms(2) by auto
<     from recurrence_time_multiples[OF assms(1) this assms(3),of "r" "q"]
<     have "flow0 x t = flow0 x r"
<       by (simp add: qr(1) add.commute mult.commute)
<     then have "flow0 x t \<in> flow0 x ` {0..<T}" using qr by auto
<   }
<   moreover {
<     assume "t \<le> 0"
<     from nasty_arithmetic2[OF assms(2) this]
<     obtain q r where qr:"t = (q::nat) * (-T) + r" "0 \<le> r" "r < T" by blast
<     have "-T \<in> existence_ivl0 x" "-T \<noteq> 0" "flow0 x (-T) = x" using recurrence_time_flip_sign assms by auto
<     from recurrence_time_multiples[OF this, of r q]
<     have "flow0 x t = flow0 x r"
<       by (simp add: mult.commute qr(1))
<     then have "flow0 x t \<in> flow0 x ` {0..<T}" using qr by auto
<   }
<   ultimately show "flow0 x t \<in> flow0 x ` {0..T}"
<     by auto
< qed
< 
< lemma closed_orbitI:
<   assumes "t \<noteq> t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
<   assumes "flow0 y t = flow0 y t'"
<   shows "closed_orbit y"
<   unfolding closed_orbit_def
<   by (smt assms local.existence_ivl_reverse local.existence_ivl_trans local.flow_trans local.flows_reverse)
< 
< (* TODO: can be considerably generalized *)
< lemma flow0_image_UNIV:
<   assumes "existence_ivl0 x = UNIV"
<   shows "flow0 (flow0 x t) ` S = flow0 x ` (\<lambda>s. s + t) ` S"
<   apply auto
<    apply (metis UNIV_I add.commute assms image_eqI local.existence_ivl_trans' local.flow_trans)
<   by (metis UNIV_I add.commute assms imageI local.existence_ivl_trans' local.flow_trans)
< 
< lemma recurrence_time_restricts_compact_flow':
<   assumes "t < t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
<   assumes "flow0 y t = flow0 y t'"
<   shows "flow0 y ` UNIV = flow0 y ` {t..t'}"
< proof -
<   have "closed_orbit y"
<     using assms(1-4) closed_orbitI inf.strict_order_iff by blast
<   from closed_orbit_global_existence[OF this]
<   have yex: "existence_ivl0 y = UNIV" .
<   have a1:"t'- t \<in> existence_ivl0 (flow0 y t)"
<     by (simp add: assms(2-3) local.existence_ivl_trans')
<   have a2:"t' -t > 0" using assms(1) by auto
<   have a3:"flow0 (flow0 y t) (t' - t) = flow0 y t"
<     using a1 assms(2) assms(4) local.flow_trans by fastforce 
<   from recurrence_time_restricts_compact_flow[OF a1 a2 a3]
<   have eq:"flow0 (flow0 y t) ` UNIV = flow0 (flow0 y t) ` {0.. t'-t}" .
<   from flow0_image_UNIV[OF yex, of _ "UNIV"]
<   have eql:"flow0 (flow0 y t) ` UNIV = flow0 y ` UNIV"
<     by (metis (no_types) add.commute surj_def surj_plus)
<   from flow0_image_UNIV[OF yex, of _ "{0..t'-t}"]
<   have eqr:"flow0 (flow0 y t) ` {0.. t'-t} = flow0 y ` {t..t'}" by auto
<   show ?thesis using eq eql eqr by auto
< qed
< 
< lemma closed_orbitE':
<   assumes "closed_orbit x"
<   obtains T where "T > 0" "\<And>t (n::nat). flow0 x (t+T*n) = flow0 x t"
< proof -
<   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
<     unfolding closed_orbit_def by blast
<   then obtain T where T: "T > 0" "T \<in> existence_ivl0 x" "flow0 x T = x"
<     by (smt recurrence_time_flip_sign)
<   thus ?thesis using  recurrence_time_multiples T that by blast 
< qed
< 
< lemma closed_orbitE:
<   assumes "closed_orbit x"
<   obtains T where "T > 0" "\<And>t. flow0 x (t+T) = flow0 x t"
<   using closed_orbitE'
<   by (metis assms mult.commute reals_Archimedean3)
< 
< lemma closed_orbit_flow_compact:
<   assumes "closed_orbit x"
<   shows "compact(flow0 x ` UNIV)"
< proof -
<   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
<     unfolding closed_orbit_def by blast
<   then obtain T where T: "T \<in> existence_ivl0 x" "T > 0" "flow0 x T = x"
<     by (smt recurrence_time_flip_sign)
<   from recurrence_time_restricts_compact_flow[OF this]
<   have feq: "flow0 x ` UNIV = flow0 x ` {0..T}" .
<   have "continuous_on {0..T} (flow0 x)"
<     by (meson T(1) continuous_on_sequentially in_mono local.flow_continuous_on local.ivl_subset_existence_ivl) 
<   from compact_continuous_image[OF this]
<   have "compact (flow0 x ` {0..T})" by auto
<   thus ?thesis using feq by auto
< qed
< 
< lemma fixed_point_imp_closed_orbit_period_zero:
<   assumes "x \<in> X"
<   assumes "f x = 0"
<   shows "closed_orbit x" "period x = 0"
< proof -
<   from fixpoint_sol[OF assms] have fp:"existence_ivl0 x = UNIV" "\<And>t. flow0 x t = x" by auto
<   then have co:"closed_orbit x" unfolding closed_orbit_def by blast
<   have a: "\<forall>y>0. \<exists>a\<in>{T \<in> existence_ivl0 x. 0 < T \<and> flow0 x T = x}. a < y"
<     apply auto
<     using fp
<     by (simp add: dense) 
<   from cInf_le_iff[OF closed_orbit_recurrence_times_nonempty[OF co]
<       closed_orbit_recurrence_times_bdd_below , of 0]
<   have "period x \<le> 0" unfolding period_def using a by auto
<   from closed_orbit_period_nonneg[OF co] have "period x \<ge> 0" .
<   then have "period x = 0" using \<open>period x \<le> 0\<close> by linarith
<   thus "closed_orbit x" "period x = 0" using co by auto
< qed
< 
< lemma closed_orbit_period_zero_fixed_point:
<   assumes "closed_orbit x" "period x = 0"
<   shows "f x = 0"
< proof (rule ccontr)
<   assume "f x \<noteq> 0"
<   from regular_locally_noteq[OF closed_orbit_in_domain[OF assms(1)] this]
<   have "\<forall>\<^sub>F t in at 0. flow0 x t \<noteq> x " .
<   then obtain r where "r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 x t \<noteq> x" unfolding eventually_at
<     by auto
<   then have "period x \<ge> r" unfolding period_def
<     apply (auto intro!:cInf_greatest)
<      apply (meson assms(1) closed_orbit_def linorder_neqE_linordered_idom neg_0_less_iff_less recurrence_time_flip_sign)
<     using not_le by force
<   thus False using assms(2) \<open>r >0\<close> by linarith
< qed
< 
< lemma closed_orbit_subset_\<omega>_limit_set:
<   assumes "closed_orbit x"
<   shows "flow0 x ` UNIV \<subseteq> \<omega>_limit_set x"
<   unfolding \<omega>_limit_set_def \<omega>_limit_point_def
< proof clarsimp
<   fix t
<   from closed_orbitE'[OF assms]
<   obtain T where T: "0 < T" "\<And>t n. flow0 x (t + T* real n) = flow0 x t" by blast
<   define s where "s = (\<lambda>n::nat. t + T * real n)"
<   have exist: "{0..} \<subseteq> existence_ivl0 x"
<     by (simp add: assms closed_orbit_global_existence)
<   have l:"filterlim s at_top sequentially" unfolding s_def
<     using T(1)
<     by (auto intro!:filterlim_tendsto_add_at_top filterlim_tendsto_pos_mult_at_top
<         simp add: filterlim_real_sequentially)
<   have "flow0 x \<circ> s = (\<lambda>n. flow0 x t)" unfolding o_def s_def using T(2) by simp
<   then have r:"(flow0 x \<circ> s) \<longlonglongrightarrow> flow0 x t" by auto
<   show "{0..} \<subseteq> existence_ivl0 x \<and> (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> flow0 x t)"
<     using exist l r by blast
< qed
< 
< lemma closed_orbit_\<omega>_limit_set:
<   assumes "closed_orbit x"
<   shows "flow0 x ` UNIV = \<omega>_limit_set x"
< proof -
<   have "\<omega>_limit_set x \<subseteq> flow0 x ` UNIV"
<     using closed_orbit_global_existence[OF assms]
<     by (intro \<omega>_limit_set_in_compact_subset)
<       (auto intro!: flow_in_domain
<         simp add: assms closed_orbit_in_domain image_subset_iff trapped_forward_def
<         closed_orbit_flow_compact)
<   thus ?thesis using closed_orbit_subset_\<omega>_limit_set[OF assms] by auto
< qed
< 
< lemma flow0_inj_on:
<   assumes "t \<le> t'"
<   assumes "{t..t'} \<subseteq> existence_ivl0 x"
<   assumes "\<And>s. t < s \<Longrightarrow> s \<le> t' \<Longrightarrow> flow0 x s \<noteq> flow0 x t"
<   shows "inj_on (flow0 x) {t..t'}"
<   apply (rule inj_onI)
< proof (rule ccontr)
<   fix u v
<   assume uv: "u \<in> {t..t'}" "v \<in> {t..t'}" "flow0 x u = flow0 x v" "u \<noteq> v"
<   have "u < v \<or> v < u" using uv(4) by linarith
<   moreover {
<     assume "u < v"
<     from recurrence_time_restricts_compact_flow'[OF this _ _ uv(3)]
<     have "flow0 x ` UNIV = flow0 x ` {u..v}"  using uv(1-2) assms(2) by blast
<     then have "flow0 x t \<in> flow0 x ` {u..v}" by auto
<     moreover have "u = t \<or> flow0 x t \<notin> flow0 x ` {u..v}" using assms(3)
<       by (smt atLeastAtMost_iff image_iff uv(1) uv(2))
<     ultimately have False using uv assms(3)
<       by force
<   }
<   moreover {
<     assume "v < u"
<     from recurrence_time_restricts_compact_flow'[OF this _ _ ]
<     have "flow0 x ` UNIV = flow0 x ` {v..u}"
<       by (metis assms(2) subset_iff uv(1) uv(2) uv(3))
<     then have "flow0 x t \<in> flow0 x ` {v..u}" by auto
<     moreover have "v = t \<or> flow0 x t \<notin> flow0 x ` {v..u}" using assms(3)
<       by (smt atLeastAtMost_iff image_iff uv(1) uv(2))
<     ultimately have False using uv assms(3) by force
<   }
<   ultimately show False by blast
< qed
< 
< (* TODO: Probably has a simpler proof *)
< lemma finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes "finite (\<omega>_limit_set x)"
<   obtains y where "\<omega>_limit_set x = {y}" "f y = 0"
< proof -
<   from connected_finite_iff_sing[OF \<omega>_limit_set_in_compact_connected]
<   obtain y where y: "\<omega>_limit_set x = {y}"
<     using \<omega>_limit_set_in_compact_nonempty assms by auto
<   have "f y = 0"
<   proof (rule ccontr)
<     assume fy:"f y \<noteq> 0"
<     from \<omega>_limit_set_in_compact_existence[OF assms(1-4)]
<     have yex: "existence_ivl0 y = UNIV"
<       by (simp add: y)
<     then have "y \<in> X"
<       by (simp add: local.mem_existence_ivl_iv_defined(2))
<     from regular_locally_noteq[OF this fy]
<     have "\<forall>\<^sub>F t in at 0. flow0 y t \<noteq> y" .
<     then obtain r where r: "r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 y t \<noteq> flow0 y 0"
<       unfolding eventually_at using \<open>y \<in> X\<close>
<       by auto
<     then have "\<And>s. 0 < s \<Longrightarrow> s \<le> r/2 \<Longrightarrow> flow0 y s \<noteq> flow0 y 0" by simp
<     from flow0_inj_on[OF _ _ this, of "r/2"]
<     obtain "inj_on(flow0 y) {0..r/2}" using r yex by simp
<     then have "infinite (flow0 y`{0..r/2})" by (simp add: finite_image_iff r(1))
<     moreover from \<omega>_limit_set_invariant[of x]
<     have "flow0 y `{0..r/2} \<subseteq> \<omega>_limit_set x" using y yex
<       unfolding invariant_def trapped_iff_on_existence_ivl0 by auto
<     ultimately show False using y
<       by (metis assms(5) finite.emptyI subset_singleton_iff)
<   qed
<   thus ?thesis using that y by auto
< qed
< 
< lemma closed_orbit_periodic:
<   assumes "closed_orbit x" "f x \<noteq> 0"
<   shows "periodic_orbit x"
<   unfolding periodic_orbit_def
<   using assms(1) apply auto
< proof (rule ccontr)
<   assume "closed_orbit x"
<   from closed_orbit_period_nonneg[OF assms(1)] have nneg: "period x \<ge> 0" .
<   assume "\<not> 0 < period x"
<   then have "period x = 0" using nneg by linarith
<   from closed_orbit_period_zero_fixed_point[OF assms(1) this]
<   have "f x = 0" . 
<   thus False using assms(2) by linarith
< qed
< 
< lemma periodic_orbitI:
<   assumes "t \<noteq> t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
<   assumes "flow0 y t = flow0 y t'"
<   assumes "f y \<noteq> 0"
<   shows "periodic_orbit y"
< proof -
<   have y:"y \<in> X"
<     using assms(3) local.mem_existence_ivl_iv_defined(2) by blast
<   from closed_orbitI[OF assms(1-4)] have "closed_orbit y" .
<   from closed_orbit_periodic[OF this assms(5)]
<   show ?thesis .
< qed
< 
< lemma periodic_orbit_recurrence_times_closed:
<   assumes "periodic_orbit x"
<   shows "closed {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
< proof -
<   have a1:"x \<in> X"
<     using assms closed_orbit_in_domain periodic_orbit_def by auto 
<   have a2:"f x \<noteq> 0"
<     using assms closed_orbit_in_domain fixed_point_imp_closed_orbit_period_zero(2) periodic_orbit_def by auto
<   from regular_locally_noteq[OF a1 a2] have
<     "\<forall>\<^sub>F t in at 0. flow0 x t \<noteq> x" .
<   then obtain r where r:"r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 x t \<noteq> x" unfolding eventually_at
<     by auto
<   show ?thesis
<   proof (auto intro!:discrete_imp_closed[OF r(1)])
<     fix t1 t2
<     assume t12: "t1 > 0" "flow0 x t1 = x" "t2 > 0" "flow0 x t2 = x" "dist t2 t1 < r"
<     then have fx: "flow0 x (t1-t2) = x"
<       by (smt a1 assms closed_orbit_global_existence existence_ivl_zero general.existence_ivl_initial_time_iff local.flow_trans periodic_orbit_def)
<     have "dist (t1-t2) 0 < r" using t12(5)
<       by (simp add: dist_norm) 
<     thus "t2 = t1" using r fx
<       by smt
<   qed
< qed
< 
< lemma periodic_orbit_period:
<   assumes "periodic_orbit x"
<   shows "period x > 0" "flow0 x (period x) = x"
< proof -
<   from periodic_orbit_recurrence_times_closed[OF assms(1)]
<   have cl: "closed {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}" .
<   have "closed_orbit x" using assms(1) unfolding periodic_orbit_def by auto
<   from closed_contains_Inf[OF closed_orbit_recurrence_times_nonempty[OF this]
<       closed_orbit_recurrence_times_bdd_below cl]
<   have "period x \<in>  {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}" unfolding period_def .
<   thus "period x > 0" "flow0 x (period x) = x" by auto
< qed
< 
< lemma closed_orbit_flow0:
<   assumes "closed_orbit x"
<   shows "closed_orbit (flow0 x t)"
< proof -
<   from closed_orbit_global_existence[OF assms]
<   have "existence_ivl0 x = UNIV" .
<   from closed_orbitE[OF assms]
<   obtain T where "T > 0" "flow0 x (t+T) = flow0 x t"
<     by metis
<   thus ?thesis unfolding closed_orbit_def
<     by (metis UNIV_I \<open>existence_ivl0 x = UNIV\<close> less_irrefl local.existence_ivl_trans' local.flow_trans)
< qed
< 
< lemma periodic_orbit_imp_flow0_regular:
<   assumes "periodic_orbit x"
<   shows "f (flow0 x t) \<noteq> 0"
<   by (metis UNIV_I assms closed_orbit_flow0 closed_orbit_global_existence closed_orbit_in_domain fixed_point_imp_closed_orbit_period_zero(2) fixpoint_sol(2) less_irrefl local.flows_reverse periodic_orbit_def)
< 
< lemma fixed_point_imp_\<omega>_limit_set:
<   assumes "x \<in> X" "f x = 0"
<   shows "\<omega>_limit_set x = {x}"
< proof -
<   have "closed_orbit x"
<     by (metis assms fixed_point_imp_closed_orbit_period_zero(1))
<   from closed_orbit_\<omega>_limit_set[OF this]
<   have "flow0 x ` UNIV = \<omega>_limit_set x" .
<   thus ?thesis
<     by (metis assms(1) assms(2) fixpoint_sol(2) image_empty image_insert image_subset_iff insertI1 rangeI subset_antisym)
< qed
< 
< end
< 
< context auto_ll_on_open begin
< 
< lemma closed_orbit_eq_rev: "closed_orbit x = rev.closed_orbit x"
<   unfolding closed_orbit_def rev.closed_orbit_def rev_eq_flow rev_existence_ivl_eq0
<   by auto
< 
< lemma closed_orbit_\<alpha>_limit_set:
<   assumes "closed_orbit x"
<   shows "flow0 x ` UNIV = \<alpha>_limit_set x"
<   using rev.closed_orbit_\<omega>_limit_set assms
<   unfolding closed_orbit_eq_rev \<alpha>_limit_set_eq_rev flow_image_eq_rev range_uminus .
< 
< lemma fixed_point_imp_\<alpha>_limit_set:
<   assumes "x \<in> X" "f x = 0"
<   shows "\<alpha>_limit_set x = {x}"
<   using rev.fixed_point_imp_\<omega>_limit_set assms
<   unfolding \<alpha>_limit_set_eq_rev
<   by auto
< 
< lemma finite_\<alpha>_limit_set_in_compact_imp_unique_fixed_point:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X"  "trapped_backward x K"
<   assumes "finite (\<alpha>_limit_set x)"
<   obtains y where "\<alpha>_limit_set x = {y}" "f y = 0"
< proof -
<   from rev.finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF
<       assms(1-5)[unfolded trapped_backward_iff_rev_trapped_forward \<alpha>_limit_set_eq_rev]]
<   show ?thesis using that
<     unfolding \<alpha>_limit_set_eq_rev
<     by auto
< qed
< end
< 
---
> section \<open>Periodic Orbits\<close>
> theory Periodic_Orbit
>   imports 
>     Ordinary_Differential_Equations.ODE_Analysis
>     Analysis_Misc
>     ODE_Misc
>     Limit_Set
> begin
> 
> text \<open> Definition of closed and periodic orbits and their associated properties \<close>
> 
> context auto_ll_on_open
> begin
> 
> text \<open>
>    TODO: not sure if the "closed orbit" terminology is standard
>    Closed orbits have some non-zero recurrence time T where the flow returns to the initial state
>    The period of a closed orbit is the infimum of all positive recurrence times
>    Periodic orbits are the subset of closed orbits where the period is non-zero
>   \<close>
> 
> definition "closed_orbit x \<longleftrightarrow>
>   (\<exists>T \<in> existence_ivl0 x. T \<noteq> 0 \<and> flow0 x T = x)"
> 
> definition "period x =
>   Inf {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
> 
> definition "periodic_orbit x \<longleftrightarrow>
>   closed_orbit x \<and> period x > 0"
> 
> lemma recurrence_time_flip_sign:
>   assumes "T \<in> existence_ivl0 x" "flow0 x T = x"
>   shows "-T \<in> existence_ivl0 x" "flow0 x (-T) = x"
>   using assms existence_ivl_reverse apply fastforce
>   using assms flows_reverse by fastforce  
> 
> lemma closed_orbit_recurrence_times_nonempty:
>   assumes "closed_orbit x"
>   shows " {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x} \<noteq> {}"
>   apply auto
>   using assms(1) unfolding closed_orbit_def
>   by (smt recurrence_time_flip_sign)
> 
> lemma closed_orbit_recurrence_times_bdd_below:
>   shows "bdd_below {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
>   unfolding bdd_below_def
>   by (auto) (meson le_cases not_le)
> 
> lemma closed_orbit_period_nonneg:
>   assumes "closed_orbit x"
>   shows "period x \<ge> 0"
>   unfolding period_def
>   using assms(1) unfolding closed_orbit_def apply (auto intro!:cInf_greatest)
>   by (smt recurrence_time_flip_sign)
> 
> lemma closed_orbit_in_domain:
>   assumes "closed_orbit x"
>   shows "x \<in> X"
>   using assms unfolding closed_orbit_def
>   using local.mem_existence_ivl_iv_defined(2) by blast
> 
> lemma closed_orbit_global_existence:
>   assumes "closed_orbit x"
>   shows "existence_ivl0 x = UNIV"
> proof -
>   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
>     unfolding closed_orbit_def by blast
>   then obtain T where T: "T > 0" "T \<in> existence_ivl0 x" "flow0 x T = x"
>     by (smt recurrence_time_flip_sign)
>   have apos: "real n * T \<in> existence_ivl0 x \<and> flow0 x (real n * T) = x" for n
>   proof (induction n)
>     case 0
>     then show ?case using closed_orbit_in_domain assms by auto
>   next
>     case (Suc n)
>     fix n
>     assume ih:"real n * T \<in> existence_ivl0 x \<and> flow0 x (real n * T) = x"
>     then have "T \<in> existence_ivl0 (flow0 x (real n * T))" using T by metis
>     then have l:"real n * T + T \<in> existence_ivl0 x" using ih
>       using existence_ivl_trans by blast 
>     have "flow0 (flow0 x (real n * T)) T = x" using ih T by metis
>     then have r: "flow0 x (real n * T + T) = x"
>       by (simp add: T(2) ih local.flow_trans)
>     show "real (Suc n) * T \<in> existence_ivl0 x \<and> flow0 x (real (Suc n) * T) = x"
>       using l r
>       by (simp add: add.commute distrib_left mult.commute)
>   qed
>   then have aneg: "-real n * T \<in> existence_ivl0 x \<and> flow0 x (-real n * T) = x" for n
>     by (simp add: recurrence_time_flip_sign)
>   have "\<forall>t. t \<in> existence_ivl0 x"
>   proof safe
>     fix t
>     have "t \<ge> 0 \<or> t \<le> (0::real)" by linarith
>     moreover {
>       assume "t \<ge> 0"
>       obtain k where "real k * T > t"
>         using T(1) ex_less_of_nat_mult by blast
>       then have "t \<in> existence_ivl0 x" using apos
>         by (meson \<open>0 \<le> t\<close> atLeastAtMost_iff less_eq_real_def local.ivl_subset_existence_ivl subset_eq) 
>     }
>     moreover {
>       assume "t \<le> 0"
>       obtain k where "- real k * T < t"
>         by (metis T(1) add.inverse_inverse ex_less_of_nat_mult mult.commute mult_minus_right neg_less_iff_less)
>       then have "t \<in> existence_ivl0 x" using aneg
>         by (smt apos atLeastAtMost_iff calculation(2) local.existence_ivl_trans' local.ivl_subset_existence_ivl mult_minus_left subset_eq)
>     }
>     ultimately show "t \<in> existence_ivl0 x" by blast
>   qed
>   thus ?thesis by auto
> qed
> 
> lemma recurrence_time_multiples:
>   fixes n::nat
>   assumes "T \<in> existence_ivl0 x" "T \<noteq> 0" "flow0 x T = x"
>   shows "\<And>t. flow0 x (t+T*n) = flow0 x t"
> proof (induction n)
>   case 0
>   then show ?case by auto
> next
>   case (Suc n)
>   fix n t
>   assume ih : "(\<And>t. flow0 x (t + T * real n) = flow0 x t)"
>   have "closed_orbit x" using assms unfolding closed_orbit_def by auto
>   from closed_orbit_global_existence[OF this] have ex:"existence_ivl0 x = UNIV" .
>   have "flow0 x (t + T * real (Suc n)) = flow0 x (t+T*real n + T)"
>     by (simp add: Groups.add_ac(3) add.commute distrib_left)
>   also have "... = flow0 (flow0 x (t+ T*real n)) T" using ex
>     by (simp add: local.existence_ivl_trans' local.flow_trans)
>   also have "... = flow0 (flow0 x t) T" using ih by auto
>   also have "... = flow0 (flow0 x T) t" using ex
>     by (metis UNIV_I add.commute local.existence_ivl_trans' local.flow_trans)
>   finally show "flow0 x (t + T * real (Suc n)) = flow0 x t" using assms(3) by simp
> qed
> 
> lemma nasty_arithmetic1:
>   fixes t T::real
>   assumes "T > 0" "t \<ge> 0"
>   obtains q r where "t = (q::nat) * T + r" "0 \<le> r" "r < T"
> proof -
>   define q where "q = floor (t / T)"
>   have q:"q \<ge> 0" using assms unfolding q_def by auto
>   from floor_divide_lower[OF assms(1), of t]
>   have ql: "q * T \<le> t" unfolding q_def .
>   from floor_divide_upper[OF assms(1), of t]
>   have qu: "t < (q + 1)* T" unfolding q_def by auto
>   define r where "r = t - q * T"
>   have rl:"0 \<le> r" using ql unfolding r_def by auto
>   have ru:"r < T" using qu unfolding r_def  by (simp add: distrib_right)
>   show ?thesis using q r_def rl ru
>     by (metis le_add_diff_inverse of_int_of_nat_eq plus_int_code(2) ql that zle_iff_zadd)
> qed
> 
> lemma nasty_arithmetic2:
>   fixes t T::real
>   assumes "T > 0" "t \<le> 0"
>   obtains q r where "t = (q::nat) * (-T) + r" "0 \<le> r" "r < T"
> proof -
>   have "-t \<ge> 0" using assms(2) by linarith
>   from nasty_arithmetic1[OF assms(1) this]
>   obtain q r where qr: "-t = (q::nat) * T + r" "0 \<le> r" "r < T" by blast
>   then have "t = q * (-T) - r"  by auto
>   then have "t = (q+(1::nat)) * (-T) + (T-r)" by (simp add: distrib_right)
>   thus ?thesis using qr(2-3)
>     by (smt \<open>t = real q * - T - r\<close> that) 
> qed
> 
> lemma recurrence_time_restricts_compact_flow:
>   assumes "T \<in> existence_ivl0 x" "T > 0" "flow0 x T = x"
>   shows "flow0 x ` UNIV = flow0 x ` {0..T}"
>   apply auto
> proof -
>   fix t
>   have "t \<ge> 0 \<or> t \<le> (0::real)" by linarith
>   moreover {
>     assume "t \<ge> 0"
>     from nasty_arithmetic1[OF assms(2) this]
>     obtain q r where qr:"t = (q::nat) * T + r" "0 \<le> r" "r < T" by blast
>     have "T \<noteq> 0" using assms(2) by auto
>     from recurrence_time_multiples[OF assms(1) this assms(3),of "r" "q"]
>     have "flow0 x t = flow0 x r"
>       by (simp add: qr(1) add.commute mult.commute)
>     then have "flow0 x t \<in> flow0 x ` {0..<T}" using qr by auto
>   }
>   moreover {
>     assume "t \<le> 0"
>     from nasty_arithmetic2[OF assms(2) this]
>     obtain q r where qr:"t = (q::nat) * (-T) + r" "0 \<le> r" "r < T" by blast
>     have "-T \<in> existence_ivl0 x" "-T \<noteq> 0" "flow0 x (-T) = x" using recurrence_time_flip_sign assms by auto
>     from recurrence_time_multiples[OF this, of r q]
>     have "flow0 x t = flow0 x r"
>       by (simp add: mult.commute qr(1))
>     then have "flow0 x t \<in> flow0 x ` {0..<T}" using qr by auto
>   }
>   ultimately show "flow0 x t \<in> flow0 x ` {0..T}"
>     by auto
> qed
> 
> lemma closed_orbitI:
>   assumes "t \<noteq> t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
>   assumes "flow0 y t = flow0 y t'"
>   shows "closed_orbit y"
>   unfolding closed_orbit_def
>   by (smt assms local.existence_ivl_reverse local.existence_ivl_trans local.flow_trans local.flows_reverse)
> 
> (* TODO: can be considerably generalized *)
> lemma flow0_image_UNIV:
>   assumes "existence_ivl0 x = UNIV"
>   shows "flow0 (flow0 x t) ` S = flow0 x ` (\<lambda>s. s + t) ` S"
>   apply auto
>    apply (metis UNIV_I add.commute assms image_eqI local.existence_ivl_trans' local.flow_trans)
>   by (metis UNIV_I add.commute assms imageI local.existence_ivl_trans' local.flow_trans)
> 
> lemma recurrence_time_restricts_compact_flow':
>   assumes "t < t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
>   assumes "flow0 y t = flow0 y t'"
>   shows "flow0 y ` UNIV = flow0 y ` {t..t'}"
> proof -
>   have "closed_orbit y"
>     using assms(1-4) closed_orbitI inf.strict_order_iff by blast
>   from closed_orbit_global_existence[OF this]
>   have yex: "existence_ivl0 y = UNIV" .
>   have a1:"t'- t \<in> existence_ivl0 (flow0 y t)"
>     by (simp add: assms(2-3) local.existence_ivl_trans')
>   have a2:"t' -t > 0" using assms(1) by auto
>   have a3:"flow0 (flow0 y t) (t' - t) = flow0 y t"
>     using a1 assms(2) assms(4) local.flow_trans by fastforce 
>   from recurrence_time_restricts_compact_flow[OF a1 a2 a3]
>   have eq:"flow0 (flow0 y t) ` UNIV = flow0 (flow0 y t) ` {0.. t'-t}" .
>   from flow0_image_UNIV[OF yex, of _ "UNIV"]
>   have eql:"flow0 (flow0 y t) ` UNIV = flow0 y ` UNIV"
>     by (metis (no_types) add.commute surj_def surj_plus)
>   from flow0_image_UNIV[OF yex, of _ "{0..t'-t}"]
>   have eqr:"flow0 (flow0 y t) ` {0.. t'-t} = flow0 y ` {t..t'}" by auto
>   show ?thesis using eq eql eqr by auto
> qed
> 
> lemma closed_orbitE':
>   assumes "closed_orbit x"
>   obtains T where "T > 0" "\<And>t (n::nat). flow0 x (t+T*n) = flow0 x t"
> proof -
>   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
>     unfolding closed_orbit_def by blast
>   then obtain T where T: "T > 0" "T \<in> existence_ivl0 x" "flow0 x T = x"
>     by (smt recurrence_time_flip_sign)
>   thus ?thesis using  recurrence_time_multiples T that by blast 
> qed
> 
> lemma closed_orbitE:
>   assumes "closed_orbit x"
>   obtains T where "T > 0" "\<And>t. flow0 x (t+T) = flow0 x t"
>   using closed_orbitE'
>   by (metis assms mult.commute reals_Archimedean3)
> 
> lemma closed_orbit_flow_compact:
>   assumes "closed_orbit x"
>   shows "compact(flow0 x ` UNIV)"
> proof -
>   obtain Tp where "Tp \<noteq> 0" "Tp \<in> existence_ivl0 x" "flow0 x Tp = x" using assms
>     unfolding closed_orbit_def by blast
>   then obtain T where T: "T \<in> existence_ivl0 x" "T > 0" "flow0 x T = x"
>     by (smt recurrence_time_flip_sign)
>   from recurrence_time_restricts_compact_flow[OF this]
>   have feq: "flow0 x ` UNIV = flow0 x ` {0..T}" .
>   have "continuous_on {0..T} (flow0 x)"
>     by (meson T(1) continuous_on_sequentially in_mono local.flow_continuous_on local.ivl_subset_existence_ivl) 
>   from compact_continuous_image[OF this]
>   have "compact (flow0 x ` {0..T})" by auto
>   thus ?thesis using feq by auto
> qed
> 
> lemma fixed_point_imp_closed_orbit_period_zero:
>   assumes "x \<in> X"
>   assumes "f x = 0"
>   shows "closed_orbit x" "period x = 0"
> proof -
>   from fixpoint_sol[OF assms] have fp:"existence_ivl0 x = UNIV" "\<And>t. flow0 x t = x" by auto
>   then have co:"closed_orbit x" unfolding closed_orbit_def by blast
>   have a: "\<forall>y>0. \<exists>a\<in>{T \<in> existence_ivl0 x. 0 < T \<and> flow0 x T = x}. a < y"
>     apply auto
>     using fp
>     by (simp add: dense) 
>   from cInf_le_iff[OF closed_orbit_recurrence_times_nonempty[OF co]
>       closed_orbit_recurrence_times_bdd_below , of 0]
>   have "period x \<le> 0" unfolding period_def using a by auto
>   from closed_orbit_period_nonneg[OF co] have "period x \<ge> 0" .
>   then have "period x = 0" using \<open>period x \<le> 0\<close> by linarith
>   thus "closed_orbit x" "period x = 0" using co by auto
> qed
> 
> lemma closed_orbit_period_zero_fixed_point:
>   assumes "closed_orbit x" "period x = 0"
>   shows "f x = 0"
> proof (rule ccontr)
>   assume "f x \<noteq> 0"
>   from regular_locally_noteq[OF closed_orbit_in_domain[OF assms(1)] this]
>   have "\<forall>\<^sub>F t in at 0. flow0 x t \<noteq> x " .
>   then obtain r where "r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 x t \<noteq> x" unfolding eventually_at
>     by auto
>   then have "period x \<ge> r" unfolding period_def
>     apply (auto intro!:cInf_greatest)
>      apply (meson assms(1) closed_orbit_def linorder_neqE_linordered_idom neg_0_less_iff_less recurrence_time_flip_sign)
>     using not_le by force
>   thus False using assms(2) \<open>r >0\<close> by linarith
> qed
> 
> lemma closed_orbit_subset_\<omega>_limit_set:
>   assumes "closed_orbit x"
>   shows "flow0 x ` UNIV \<subseteq> \<omega>_limit_set x"
>   unfolding \<omega>_limit_set_def \<omega>_limit_point_def
> proof clarsimp
>   fix t
>   from closed_orbitE'[OF assms]
>   obtain T where T: "0 < T" "\<And>t n. flow0 x (t + T* real n) = flow0 x t" by blast
>   define s where "s = (\<lambda>n::nat. t + T * real n)"
>   have exist: "{0..} \<subseteq> existence_ivl0 x"
>     by (simp add: assms closed_orbit_global_existence)
>   have l:"filterlim s at_top sequentially" unfolding s_def
>     using T(1)
>     by (auto intro!:filterlim_tendsto_add_at_top filterlim_tendsto_pos_mult_at_top
>         simp add: filterlim_real_sequentially)
>   have "flow0 x \<circ> s = (\<lambda>n. flow0 x t)" unfolding o_def s_def using T(2) by simp
>   then have r:"(flow0 x \<circ> s) \<longlonglongrightarrow> flow0 x t" by auto
>   show "{0..} \<subseteq> existence_ivl0 x \<and> (\<exists>s. s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity> \<and> (flow0 x \<circ> s) \<longlonglongrightarrow> flow0 x t)"
>     using exist l r by blast
> qed
> 
> lemma closed_orbit_\<omega>_limit_set:
>   assumes "closed_orbit x"
>   shows "flow0 x ` UNIV = \<omega>_limit_set x"
> proof -
>   have "\<omega>_limit_set x \<subseteq> flow0 x ` UNIV"
>     using closed_orbit_global_existence[OF assms]
>     by (intro \<omega>_limit_set_in_compact_subset)
>       (auto intro!: flow_in_domain
>         simp add: assms closed_orbit_in_domain image_subset_iff trapped_forward_def
>         closed_orbit_flow_compact)
>   thus ?thesis using closed_orbit_subset_\<omega>_limit_set[OF assms] by auto
> qed
> 
> lemma flow0_inj_on:
>   assumes "t \<le> t'"
>   assumes "{t..t'} \<subseteq> existence_ivl0 x"
>   assumes "\<And>s. t < s \<Longrightarrow> s \<le> t' \<Longrightarrow> flow0 x s \<noteq> flow0 x t"
>   shows "inj_on (flow0 x) {t..t'}"
>   apply (rule inj_onI)
> proof (rule ccontr)
>   fix u v
>   assume uv: "u \<in> {t..t'}" "v \<in> {t..t'}" "flow0 x u = flow0 x v" "u \<noteq> v"
>   have "u < v \<or> v < u" using uv(4) by linarith
>   moreover {
>     assume "u < v"
>     from recurrence_time_restricts_compact_flow'[OF this _ _ uv(3)]
>     have "flow0 x ` UNIV = flow0 x ` {u..v}"  using uv(1-2) assms(2) by blast
>     then have "flow0 x t \<in> flow0 x ` {u..v}" by auto
>     moreover have "u = t \<or> flow0 x t \<notin> flow0 x ` {u..v}" using assms(3)
>       by (smt atLeastAtMost_iff image_iff uv(1) uv(2))
>     ultimately have False using uv assms(3)
>       by force
>   }
>   moreover {
>     assume "v < u"
>     from recurrence_time_restricts_compact_flow'[OF this _ _ ]
>     have "flow0 x ` UNIV = flow0 x ` {v..u}"
>       by (metis assms(2) subset_iff uv(1) uv(2) uv(3))
>     then have "flow0 x t \<in> flow0 x ` {v..u}" by auto
>     moreover have "v = t \<or> flow0 x t \<notin> flow0 x ` {v..u}" using assms(3)
>       by (smt atLeastAtMost_iff image_iff uv(1) uv(2))
>     ultimately have False using uv assms(3) by force
>   }
>   ultimately show False by blast
> qed
> 
> (* TODO: Probably has a simpler proof *)
> lemma finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes "finite (\<omega>_limit_set x)"
>   obtains y where "\<omega>_limit_set x = {y}" "f y = 0"
> proof -
>   from connected_finite_iff_sing[OF \<omega>_limit_set_in_compact_connected]
>   obtain y where y: "\<omega>_limit_set x = {y}"
>     using \<omega>_limit_set_in_compact_nonempty assms by auto
>   have "f y = 0"
>   proof (rule ccontr)
>     assume fy:"f y \<noteq> 0"
>     from \<omega>_limit_set_in_compact_existence[OF assms(1-4)]
>     have yex: "existence_ivl0 y = UNIV"
>       by (simp add: y)
>     then have "y \<in> X"
>       by (simp add: local.mem_existence_ivl_iv_defined(2))
>     from regular_locally_noteq[OF this fy]
>     have "\<forall>\<^sub>F t in at 0. flow0 y t \<noteq> y" .
>     then obtain r where r: "r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 y t \<noteq> flow0 y 0"
>       unfolding eventually_at using \<open>y \<in> X\<close>
>       by auto
>     then have "\<And>s. 0 < s \<Longrightarrow> s \<le> r/2 \<Longrightarrow> flow0 y s \<noteq> flow0 y 0" by simp
>     from flow0_inj_on[OF _ _ this, of "r/2"]
>     obtain "inj_on(flow0 y) {0..r/2}" using r yex by simp
>     then have "infinite (flow0 y`{0..r/2})" by (simp add: finite_image_iff r(1))
>     moreover from \<omega>_limit_set_invariant[of x]
>     have "flow0 y `{0..r/2} \<subseteq> \<omega>_limit_set x" using y yex
>       unfolding invariant_def trapped_iff_on_existence_ivl0 by auto
>     ultimately show False using y
>       by (metis assms(5) finite.emptyI subset_singleton_iff)
>   qed
>   thus ?thesis using that y by auto
> qed
> 
> lemma closed_orbit_periodic:
>   assumes "closed_orbit x" "f x \<noteq> 0"
>   shows "periodic_orbit x"
>   unfolding periodic_orbit_def
>   using assms(1) apply auto
> proof (rule ccontr)
>   assume "closed_orbit x"
>   from closed_orbit_period_nonneg[OF assms(1)] have nneg: "period x \<ge> 0" .
>   assume "\<not> 0 < period x"
>   then have "period x = 0" using nneg by linarith
>   from closed_orbit_period_zero_fixed_point[OF assms(1) this]
>   have "f x = 0" . 
>   thus False using assms(2) by linarith
> qed
> 
> lemma periodic_orbitI:
>   assumes "t \<noteq> t'" "t \<in> existence_ivl0 y" "t' \<in> existence_ivl0 y"
>   assumes "flow0 y t = flow0 y t'"
>   assumes "f y \<noteq> 0"
>   shows "periodic_orbit y"
> proof -
>   have y:"y \<in> X"
>     using assms(3) local.mem_existence_ivl_iv_defined(2) by blast
>   from closed_orbitI[OF assms(1-4)] have "closed_orbit y" .
>   from closed_orbit_periodic[OF this assms(5)]
>   show ?thesis .
> qed
> 
> lemma periodic_orbit_recurrence_times_closed:
>   assumes "periodic_orbit x"
>   shows "closed {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}"
> proof -
>   have a1:"x \<in> X"
>     using assms closed_orbit_in_domain periodic_orbit_def by auto 
>   have a2:"f x \<noteq> 0"
>     using assms closed_orbit_in_domain fixed_point_imp_closed_orbit_period_zero(2) periodic_orbit_def by auto
>   from regular_locally_noteq[OF a1 a2] have
>     "\<forall>\<^sub>F t in at 0. flow0 x t \<noteq> x" .
>   then obtain r where r:"r>0" "\<forall>t. t \<noteq> 0 \<and> dist t 0 < r \<longrightarrow> flow0 x t \<noteq> x" unfolding eventually_at
>     by auto
>   show ?thesis
>   proof (auto intro!:discrete_imp_closed[OF r(1)])
>     fix t1 t2
>     assume t12: "t1 > 0" "flow0 x t1 = x" "t2 > 0" "flow0 x t2 = x" "dist t2 t1 < r"
>     then have fx: "flow0 x (t1-t2) = x"
>       by (smt a1 assms closed_orbit_global_existence existence_ivl_zero general.existence_ivl_initial_time_iff local.flow_trans periodic_orbit_def)
>     have "dist (t1-t2) 0 < r" using t12(5)
>       by (simp add: dist_norm) 
>     thus "t2 = t1" using r fx
>       by smt
>   qed
> qed
> 
> lemma periodic_orbit_period:
>   assumes "periodic_orbit x"
>   shows "period x > 0" "flow0 x (period x) = x"
> proof -
>   from periodic_orbit_recurrence_times_closed[OF assms(1)]
>   have cl: "closed {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}" .
>   have "closed_orbit x" using assms(1) unfolding periodic_orbit_def by auto
>   from closed_contains_Inf[OF closed_orbit_recurrence_times_nonempty[OF this]
>       closed_orbit_recurrence_times_bdd_below cl]
>   have "period x \<in>  {T \<in> existence_ivl0 x. T > 0 \<and> flow0 x T = x}" unfolding period_def .
>   thus "period x > 0" "flow0 x (period x) = x" by auto
> qed
> 
> lemma closed_orbit_flow0:
>   assumes "closed_orbit x"
>   shows "closed_orbit (flow0 x t)"
> proof -
>   from closed_orbit_global_existence[OF assms]
>   have "existence_ivl0 x = UNIV" .
>   from closed_orbitE[OF assms]
>   obtain T where "T > 0" "flow0 x (t+T) = flow0 x t"
>     by metis
>   thus ?thesis unfolding closed_orbit_def
>     by (metis UNIV_I \<open>existence_ivl0 x = UNIV\<close> less_irrefl local.existence_ivl_trans' local.flow_trans)
> qed
> 
> lemma periodic_orbit_imp_flow0_regular:
>   assumes "periodic_orbit x"
>   shows "f (flow0 x t) \<noteq> 0"
>   by (metis UNIV_I assms closed_orbit_flow0 closed_orbit_global_existence closed_orbit_in_domain fixed_point_imp_closed_orbit_period_zero(2) fixpoint_sol(2) less_irrefl local.flows_reverse periodic_orbit_def)
> 
> lemma fixed_point_imp_\<omega>_limit_set:
>   assumes "x \<in> X" "f x = 0"
>   shows "\<omega>_limit_set x = {x}"
> proof -
>   have "closed_orbit x"
>     by (metis assms fixed_point_imp_closed_orbit_period_zero(1))
>   from closed_orbit_\<omega>_limit_set[OF this]
>   have "flow0 x ` UNIV = \<omega>_limit_set x" .
>   thus ?thesis
>     by (metis assms(1) assms(2) fixpoint_sol(2) image_empty image_insert image_subset_iff insertI1 rangeI subset_antisym)
> qed
> 
> end
> 
> context auto_ll_on_open begin
> 
> lemma closed_orbit_eq_rev: "closed_orbit x = rev.closed_orbit x"
>   unfolding closed_orbit_def rev.closed_orbit_def rev_eq_flow rev_existence_ivl_eq0
>   by auto
> 
> lemma closed_orbit_\<alpha>_limit_set:
>   assumes "closed_orbit x"
>   shows "flow0 x ` UNIV = \<alpha>_limit_set x"
>   using rev.closed_orbit_\<omega>_limit_set assms
>   unfolding closed_orbit_eq_rev \<alpha>_limit_set_eq_rev flow_image_eq_rev range_uminus .
> 
> lemma fixed_point_imp_\<alpha>_limit_set:
>   assumes "x \<in> X" "f x = 0"
>   shows "\<alpha>_limit_set x = {x}"
>   using rev.fixed_point_imp_\<omega>_limit_set assms
>   unfolding \<alpha>_limit_set_eq_rev
>   by auto
> 
> lemma finite_\<alpha>_limit_set_in_compact_imp_unique_fixed_point:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X"  "trapped_backward x K"
>   assumes "finite (\<alpha>_limit_set x)"
>   obtains y where "\<alpha>_limit_set x = {y}" "f y = 0"
> proof -
>   from rev.finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF
>       assms(1-5)[unfolded trapped_backward_iff_rev_trapped_forward \<alpha>_limit_set_eq_rev]]
>   show ?thesis using that
>     unfolding \<alpha>_limit_set_eq_rev
>     by auto
> qed
> end
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Bendixson/Poincare_Bendixson.thy ../../AFPs/afp-2020/thys/Poincare_Bendixson/Poincare_Bendixson.thy
1,2824c1,2821
< section \<open>Poincare Bendixson Theory\<close>
< theory Poincare_Bendixson
<   imports 
<     Ordinary_Differential_Equations.ODE_Analysis
<     Analysis_Misc ODE_Misc Periodic_Orbit
< begin
< 
< 
< subsection \<open>Flow to Path\<close>
< 
< context auto_ll_on_open begin
< 
< (* The path along the flow starting at time t to time t' *)
< definition "flow_to_path x t t' = flow0 x \<circ> linepath t t'"
< 
< lemma pathstart_flow_to_path[simp]:
<   shows "pathstart (flow_to_path x t t') = flow0 x t"
<   unfolding flow_to_path_def
<   by (auto simp add: pathstart_compose)
< 
< lemma pathfinish_flow_to_path[simp]:
<   shows "pathfinish (flow_to_path x t t') = flow0 x t'"
<   unfolding flow_to_path_def
<   by (auto simp add: pathfinish_compose)
< 
< lemma flow_to_path_unfold:
<   shows "flow_to_path x t t' s = flow0 x ((1 - s) * t + s * t')"
<   unfolding flow_to_path_def o_def linepath_def by auto
< 
< lemma subpath0_flow_to_path:
<   shows "(subpath 0 u (flow_to_path x t t')) = flow_to_path x t (t + u*(t'-t))"
<   unfolding flow_to_path_def subpath_image subpath0_linepath
<   by auto
< 
< lemma path_image_flow_to_path[simp]:
<   assumes "t \<le> t'"
<   shows "path_image (flow_to_path x t t') = flow0 x ` {t..t'}"
<   unfolding flow_to_path_def path_image_compose path_image_linepath
<   using assms real_Icc_closed_segment by auto
< 
< lemma flow_to_path_image0_right_open[simp]:
<   assumes "t < t'"
<   shows "flow_to_path x t t' ` {0..<1} = flow0 x `{t..<t'}"
<   unfolding flow_to_path_def image_comp[symmetric] linepath_image0_right_open_real[OF assms]
<   by auto
< 
< lemma flow_to_path_path:
<   assumes "t \<le> t'"
<   assumes "{t..t'} \<subseteq> existence_ivl0 x"
<   shows "path (flow_to_path x t t')"
< proof -
<   have "x \<in> X"
<     using assms(1) assms(2) subset_empty by fastforce
<   have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow>  (1 - xa) * t + xa * t' \<le> t'"
<     by (simp add: assms(1) convex_bound_le)
<   moreover have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow> t \<le> (1 - xa) * t + xa * t'" using assms(1)
<     by (metis add.commute add_diff_cancel_left' diff_diff_eq2 diff_le_eq mult.commute mult.right_neutral mult_right_mono right_diff_distrib')
<   ultimately have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow> (1 - xa) * t + xa * t' \<in> existence_ivl0 x"
<     using assms(2) by auto
<   thus ?thesis unfolding path_def flow_to_path_def linepath_def
<     by (auto intro!:continuous_intros simp add :\<open>x \<in> X\<close>)
< qed
< 
< lemma flow_to_path_arc:
<   assumes "t \<le> t'"
<   assumes "{t..t'} \<subseteq> existence_ivl0 x"
<   assumes "\<forall>s \<in> {t<..<t'}. flow0 x s \<noteq> flow0 x t"
<   assumes "flow0 x t \<noteq> flow0 x t'"
<   shows "arc (flow_to_path x t t')"
<   unfolding arc_def
< proof safe
<   from flow_to_path_path[OF assms(1-2)]
<   show "path (flow_to_path x t t')" .
< next
<   show "inj_on (flow_to_path x t t') {0..1}"
<     unfolding flow_to_path_def
<     apply (rule comp_inj_on)
<      apply (metis assms(4) inj_on_linepath)
<     using assms path_image_linepath[of t t'] apply (auto intro!:flow0_inj_on)
<     using flow0_inj_on greaterThanLessThan_iff linepath_image_01 real_Icc_closed_segment by fastforce
< qed
< 
< end
< 
< locale c1_on_open_R2 = c1_on_open_euclidean f f' X for f::"'a::executable_euclidean_space \<Rightarrow> _" and f' and X +
<   assumes dim2: "DIM('a) = 2"
< begin
< 
< 
< subsection \<open>2D Line segments\<close>
< 
< text \<open>Line segments are specified by two endpoints
<       The closed line segment from x to y is given by the set {x--y}
<       and {x<--<y} for the open segment\<close>
< 
< text \<open> Rotates a vector clockwise 90 degrees \<close>
< definition "rot (v::'a) = (eucl_of_list [nth_eucl v 1, -nth_eucl v 0]::'a)"
< 
< lemma exhaust2_nat: "(\<forall>i<(2::nat). P i) \<longleftrightarrow> P 0 \<and> P 1"
<   using less_2_cases by auto
< lemma sum2_nat: "(\<Sum>i<(2::nat). P i) = P 0 + P 1"
<   by (simp add: eval_nat_numeral)
< 
< lemmas vec_simps =
<   eucl_eq_iff[where 'a='a] dim2 eucl_of_list_eucl_nth exhaust2_nat
<   plus_nth_eucl
<   minus_nth_eucl
<   uminus_nth_eucl
<   scaleR_nth_eucl
<   inner_nth_eucl
<   sum2_nat
<   algebra_simps
< 
< lemma minus_expand:
<   shows "(x::'a)-y = (eucl_of_list [x$\<^sub>e0 - y$\<^sub>e0, x$\<^sub>e1 - y$\<^sub>e1])"
<   by (simp add:vec_simps)
< 
< lemma dot_ortho[simp]: "x \<bullet> rot x = 0"
<   unfolding rot_def minus_expand
<   by (simp add: vec_simps)
< 
< lemma nrm_dot:
<   shows "((x::'a)-y) \<bullet> (rot (x-y)) = 0"
<   unfolding rot_def minus_expand
<   by (simp add: vec_simps)
< 
< lemma nrm_reverse: "a \<bullet> (rot (x-y)) = - a \<bullet> (rot (y-x))" for x y::'a
<   unfolding rot_def
<   by (simp add:vec_simps)
< 
< lemma norm_rot: "norm (rot v) = norm v" for v::'a
<   unfolding rot_def
<   by (simp add:vec_simps norm_nth_eucl L2_set_def)
< 
< lemma rot_rot[simp]:
<   shows "rot (rot v) = -v"
<   unfolding rot_def
<   by (simp add:vec_simps)
< 
< lemma rot_scaleR[simp]:
<   shows "rot ( u *\<^sub>R v) =  u *\<^sub>R (rot v)"
<   unfolding rot_def
<   by (simp add:vec_simps)
< 
< lemma rot_0[simp]: "rot 0 = 0"
<   using rot_scaleR[of 0] by simp
< 
< lemma rot_eq_0_iff[simp]: "rot x = 0 \<longleftrightarrow> x = 0"
<   apply (auto simp: rot_def)
<    apply (metis One_nat_def norm_eq_zero norm_rot norm_zero rot_def)
<   using rot_0 rot_def by auto
< 
< lemma in_segment_inner_rot:
<   "(x - a) \<bullet> rot (b - a) = 0"
<   if "x \<in> {a--b}"
< proof -
<   from that obtain u where x: "x = a + u *\<^sub>R (b - a)" "0 \<le> u" "u \<le> 1"
<     by (auto simp: in_segment algebra_simps)
<   show ?thesis
<     unfolding x
<     by (simp add: inner_add_left nrm_dot)
< qed
< 
< lemma inner_rot_in_segment:
<   "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))"
<   if "(x - a) \<bullet> rot (b - a) = 0" "a \<noteq> b"
< proof -
<   from that have
<     x0: "b $\<^sub>e 0 = a $\<^sub>e 0 \<Longrightarrow> x $\<^sub>e 0 =
<       (a $\<^sub>e 0 * b $\<^sub>e Suc 0 - b $\<^sub>e 0 * a $\<^sub>e Suc 0 + (b $\<^sub>e 0 - a $\<^sub>e 0) * x $\<^sub>e Suc 0) /
<       (b $\<^sub>e Suc 0 - a $\<^sub>e Suc 0)"
<     and x1: "b $\<^sub>e 0 \<noteq> a $\<^sub>e 0 \<Longrightarrow> x $\<^sub>e Suc 0 =
<       ((b $\<^sub>e Suc 0 - a $\<^sub>e Suc 0) * x $\<^sub>e 0 - a $\<^sub>e 0 * b $\<^sub>e Suc 0 + b $\<^sub>e 0 * a $\<^sub>e Suc 0) / (b $\<^sub>e 0 - a $\<^sub>e 0)"
<     by (auto simp: rot_def vec_simps divide_simps)
<   define u where "u = (if b $\<^sub>e 0 - a $\<^sub>e 0 \<noteq> 0
<     then ((x $\<^sub>e 0 - a $\<^sub>e 0) / (b $\<^sub>e 0 -  a $\<^sub>e 0))
<     else ((x $\<^sub>e 1 - a $\<^sub>e 1) / (b $\<^sub>e 1 -  a $\<^sub>e 1)))
<     "
<   show ?thesis
<     apply (cases "b $\<^sub>e 0 - a $\<^sub>e 0 = 0")
<     subgoal
<       using that(2)
<       apply (auto intro!: image_eqI[where x="((x $\<^sub>e 1 - a $\<^sub>e 1) / (b $\<^sub>e 1 -  a $\<^sub>e 1))"]
<           simp: vec_simps x0 divide_simps algebra_simps)
<        apply (metis ab_semigroup_mult_class.mult_ac(1) mult.commute sum_sqs_eq)
<       by (metis mult.commute mult.left_commute sum_sqs_eq)
<     subgoal
<       apply (auto intro!: image_eqI[where x="((x $\<^sub>e 0 - a $\<^sub>e 0) / (b $\<^sub>e 0 -  a $\<^sub>e 0))"]
<           simp: vec_simps x1 divide_simps algebra_simps)
<        apply (metis ab_semigroup_mult_class.mult_ac(1) mult.commute sum_sqs_eq)
<       by (metis mult.commute mult.left_commute sum_sqs_eq)
<     done
< qed
< 
< lemma in_open_segment_iff_rot:
<   "x \<in> {a<--<b} \<longleftrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) <..< b \<bullet> (b - a)}"
<   if "a \<noteq> b"
<   unfolding open_segment_line_hyperplanes[OF that]
<   by (auto simp: nrm_dot intro!: inner_rot_in_segment)
< 
< lemma in_open_segment_rotD:
<   "x \<in> {a<--<b} \<Longrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) <..< b \<bullet> (b - a)}"
<   by (subst in_open_segment_iff_rot[symmetric]) auto
< 
< lemma in_closed_segment_iff_rot:
<   "x \<in> {a--b} \<longleftrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) .. b \<bullet> (b - a)}"
<   if "a \<noteq> b"
<   unfolding closed_segment_line_hyperplanes[OF that] using that
<   by (auto simp: nrm_dot intro!: inner_rot_in_segment)
< 
< lemma in_segment_inner_rot2:
<   "(x - y) \<bullet> rot (a - b) = 0"
<   if "x \<in> {a--b}" "y \<in> {a--b}"
< proof -
<   from that obtain u where x: "x = a + u *\<^sub>R (b - a)" "0 \<le> u" "u \<le> 1"
<     by (auto simp: in_segment algebra_simps)
<   from that obtain v where y: "y = a + v *\<^sub>R (b - a)" "0 \<le> v" "v \<le> 1"
<     by (auto simp: in_segment algebra_simps)
<   show ?thesis
<     unfolding x y
<     apply (auto simp: inner_add_left )
<     by (smt add_diff_cancel_left' in_segment_inner_rot inner_diff_left minus_diff_eq nrm_reverse that(1) that(2) x(1) y(1))
< qed
< 
< lemma closed_segment_surface:
<   "a \<noteq> b \<Longrightarrow> {a--b} = { x \<in> {x. x \<bullet> (b - a) \<in> {a\<bullet>(b - a) .. b \<bullet> (b - a)}}. (x - a) \<bullet> rot (b - a) = 0}"
<   by (auto simp: in_closed_segment_iff_rot)
< 
< lemma rot_diff_commute: "rot (b - a) = -rot(a - b)"
<   apply (auto simp: rot_def algebra_simps)
<   by (metis One_nat_def minus_diff_eq rot_def rot_rot)
< 
< 
< subsection \<open>Bijection Real-Complex for Jordan Curve Theorem\<close>
< 
< definition "complex_of (x::'a) = x$\<^sub>e0 + \<i> * x$\<^sub>e1"
< 
< definition "real_of (x::complex) = (eucl_of_list [Re x, Im x]::'a)"
< 
< lemma complex_of_linear:
<   shows "linear complex_of"
<   unfolding complex_of_def
<   apply (auto intro!:linearI simp add: distrib_left plus_nth_eucl)
<   by (simp add: of_real_def scaleR_add_right scaleR_nth_eucl)
< 
< lemma complex_of_bounded_linear:
<   shows "bounded_linear complex_of"
<   unfolding complex_of_def
<   apply (auto intro!:bounded_linearI' simp add: distrib_left plus_nth_eucl)
<   by (simp add: of_real_def scaleR_add_right scaleR_nth_eucl)
< 
< lemma real_of_linear:
<   shows "linear real_of"
<   unfolding real_of_def
<   by (auto intro!:linearI simp add: vec_simps)
< 
< lemma real_of_bounded_linear:
<   shows "bounded_linear real_of"
<   unfolding real_of_def
<   by (auto intro!:bounded_linearI' simp add: vec_simps)
< 
< lemma complex_of_real_of:
<   "(complex_of \<circ> real_of) = id"
<   unfolding complex_of_def real_of_def
<   using complex_eq by (auto simp add:vec_simps)
< 
< lemma real_of_complex_of:
<   "(real_of \<circ> complex_of) = id"
<   unfolding complex_of_def real_of_def
<   using complex_eq by (auto simp add:vec_simps)
< 
< lemma complex_of_bij:
<   shows "bij (complex_of)"
<   using o_bij[OF real_of_complex_of complex_of_real_of] .
< 
< lemma real_of_bij:
<   shows "bij (real_of)"
<   using o_bij[OF complex_of_real_of real_of_complex_of] .
< 
< lemma real_of_inj:
<   shows "inj (real_of)"
<   using real_of_bij
<   using bij_betw_imp_inj_on by auto
< 
< lemma Jordan_curve_R2:
<   fixes c :: "real \<Rightarrow> 'a"
<   assumes "simple_path c" "pathfinish c = pathstart c"
<   obtains inside outside where
<     "inside \<noteq> {}" "open inside" "connected inside"
<     "outside \<noteq> {}" "open outside" "connected outside"
<     "bounded inside" "\<not> bounded outside"
<     "inside \<inter> outside = {}"
<     "inside \<union> outside = - path_image c"
<     "frontier inside = path_image c"
<     "frontier outside = path_image c"
< proof -
<   from simple_path_linear_image_eq[OF complex_of_linear]
<   have a1:"simple_path (complex_of \<circ> c)" using assms(1) complex_of_bij
<     using bij_betw_imp_inj_on by blast
<   have a2:"pathfinish (complex_of \<circ> c) = pathstart (complex_of \<circ> c)"
<     using assms(2) by (simp add:pathstart_compose pathfinish_compose)
< 
<   from Jordan_curve[OF a1 a2]
<   obtain inside outside where io:
<     "inside \<noteq> {}" "open inside" "connected inside"
<     "outside \<noteq> {}" "open outside" "connected outside"
<     "bounded inside" "\<not> bounded outside" "inside \<inter> outside = {}"
<     "inside \<union> outside = - path_image (complex_of \<circ> c)"
<     "frontier inside = path_image (complex_of \<circ> c)"
<     "frontier outside = path_image (complex_of \<circ> c)" by blast
<   let ?rin = "real_of ` inside"
<   let ?rout = "real_of ` outside"
<   have i: "inside = complex_of ` ?rin" using complex_of_real_of unfolding image_comp
<     by auto
<   have o: "outside = complex_of ` ?rout" using complex_of_real_of unfolding image_comp
<     by auto
<   have c: "path_image(complex_of \<circ> c) = complex_of ` (path_image c)"
<     by (simp add: path_image_compose)
<   have "?rin \<noteq> {}" using io by auto
<   moreover from open_bijective_linear_image_eq[OF real_of_linear real_of_bij]
<   have "open ?rin" using io by auto
<   moreover from connected_linear_image[OF real_of_linear]
<   have "connected ?rin" using io by auto
<   moreover have "?rout \<noteq> {}" using io by auto
<   moreover from open_bijective_linear_image_eq[OF real_of_linear real_of_bij]
<   have "open ?rout" using io by auto
<   moreover from connected_linear_image[OF real_of_linear]
<   have "connected ?rout" using io by auto
<   moreover from bounded_linear_image[OF io(7) real_of_bounded_linear]
<   have "bounded ?rin" .
<   moreover from bounded_linear_image[OF _ complex_of_bounded_linear]
<   have "\<not> bounded ?rout" using io(8) o
<     by force
<   from image_Int[OF real_of_inj]
<   have "?rin \<inter> ?rout = {}" using io(9) by auto
<   moreover from bij_image_Compl_eq[OF complex_of_bij]
<   have "?rin \<union> ?rout = - path_image c" using io(10) unfolding c
<     by (metis id_apply image_Un image_comp image_cong image_ident real_of_complex_of)
<   moreover from closure_injective_linear_image[OF real_of_linear real_of_inj]
<   have "frontier ?rin = path_image c" using io(11)
<     unfolding frontier_closures c
<     by (metis \<open>\<And>B A. real_of ` (A \<inter> B) = real_of ` A \<inter> real_of ` B\<close> bij_image_Compl_eq c calculation(9) compl_sup double_compl io(10) real_of_bij)
<   moreover from closure_injective_linear_image[OF real_of_linear real_of_inj]
<   have "frontier ?rout = path_image c" using io(12)
<     unfolding frontier_closures c
<     by (metis \<open>\<And>B A. real_of ` (A \<inter> B) = real_of ` A \<inter> real_of ` B\<close> bij_image_Compl_eq c calculation(10) frontier_closures io(11) real_of_bij)
<   ultimately show ?thesis
<     by (meson \<open>\<not> bounded (real_of ` outside)\<close> that)
< qed
< 
< (* copied *)
< corollary Jordan_inside_outside_R2:
<   fixes c :: "real \<Rightarrow> 'a"
<   assumes "simple_path c" "pathfinish c = pathstart c"
<   shows "inside(path_image c) \<noteq> {} \<and>
<           open(inside(path_image c)) \<and>
<           connected(inside(path_image c)) \<and>
<           outside(path_image c) \<noteq> {} \<and>
<           open(outside(path_image c)) \<and>
<           connected(outside(path_image c)) \<and>
<           bounded(inside(path_image c)) \<and>
<           \<not> bounded(outside(path_image c)) \<and>
<           inside(path_image c) \<inter> outside(path_image c) = {} \<and>
<           inside(path_image c) \<union> outside(path_image c) =
<           - path_image c \<and>
<           frontier(inside(path_image c)) = path_image c \<and>
<           frontier(outside(path_image c)) = path_image c"
< proof -
<   obtain inner outer
<     where *: "inner \<noteq> {}" "open inner" "connected inner"
<       "outer \<noteq> {}" "open outer" "connected outer"
<       "bounded inner" "\<not> bounded outer" "inner \<inter> outer = {}"
<       "inner \<union> outer = - path_image c"
<       "frontier inner = path_image c"
<       "frontier outer = path_image c"
<     using Jordan_curve_R2 [OF assms] by blast
<   then have inner: "inside(path_image c) = inner"
<     by (metis dual_order.antisym inside_subset interior_eq interior_inside_frontier)
<   have outer: "outside(path_image c) = outer"
<     using \<open>inner \<union> outer = - path_image c\<close> \<open>inside (path_image c) = inner\<close>
<       outside_inside \<open>inner \<inter> outer = {}\<close> by auto
<   show ?thesis
<     using * by (auto simp: inner outer)
< qed
< 
< lemma jordan_points_inside_outside:
<   fixes p :: "real \<Rightarrow> 'a"
<   assumes "0 < e"
<   assumes jordan: "simple_path p" "pathfinish p = pathstart p"
<   assumes x: "x \<in> path_image p"
<   obtains y z where "y \<in> inside (path_image p)" "y \<in> ball x e" 
<     "z \<in> outside (path_image p)" "z \<in> ball x e"
< proof -
<   from Jordan_inside_outside_R2[OF jordan]
<   have xi: "x \<in> frontier(inside (path_image p))" and
<     xo: "x \<in> frontier(outside (path_image p))"
<     using x by auto
<   obtain y where y:"y \<in> inside (path_image p)" "y \<in> ball x e" using \<open>0 < e\<close> xi
<     unfolding frontier_straddle
<     by auto
<   obtain z where z:"z \<in> outside (path_image p)" "z \<in> ball x e" using \<open>0 < e\<close> xo
<     unfolding frontier_straddle
<     by auto
<   show ?thesis using y z that by blast
< qed  
< 
< lemma eventually_at_open_segment:
<   assumes "x \<in> {a<--<b}"
<   shows "\<forall>\<^sub>F y in at x. (y-a) \<bullet> rot(a-b) = 0 \<longrightarrow> y \<in> {a <--< b}"
< proof -
<   from assms have "a \<noteq> b" by auto
<   from assms have x: "(x - a) \<bullet> rot (b - a) = 0" "x \<bullet> (b - a) \<in> {a \<bullet> (b - a)<..<b \<bullet> (b - a)}"
<     unfolding in_open_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
<     by auto
<   then have "\<forall>\<^sub>F y in at x. y \<bullet> (b - a) \<in> {a \<bullet> (b - a)<..<b \<bullet> (b - a)}"
<     by (intro topological_tendstoD) (auto intro!: tendsto_intros)
<   then show ?thesis
<     by eventually_elim (auto simp: in_open_segment_iff_rot[OF \<open>a \<noteq> b\<close>] nrm_reverse[of _ a b] algebra_simps dist_commute)
< qed
< 
< lemma linepath_ball:
<   assumes "x \<in> {a<--<b}"
<   obtains e where "e > 0" "ball x e \<inter> {y. (y-a) \<bullet> rot(a-b) = 0} \<subseteq> {a <--< b}"
< proof -
<   from eventually_at_open_segment[OF assms] assms
<   obtain e where "0 < e" "ball x e \<inter> {y. (y - a) \<bullet> rot (a - b) = 0} \<subseteq> {a<--<b}"
<     by (force simp: eventually_at in_open_segment_iff_rot dist_commute)
<   then show ?thesis ..
< qed
< 
< lemma linepath_ball_inside_outside:
<   fixes p :: "real \<Rightarrow> 'a"
<   assumes jordan: "simple_path (p +++ linepath a b)" "pathfinish p = a" "pathstart p = b"
<   assumes x: "x \<in> {a<--<b}"
<   obtains e where "e > 0" "ball x e \<inter> path_image p = {}"
<     "ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0} \<subseteq> inside (path_image (p +++ linepath a b)) \<and>
<      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0} \<subseteq> outside (path_image (p +++ linepath a b))
<      \<or> 
<      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0} \<subseteq> inside (path_image (p +++ linepath a b)) \<and>
<      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0} \<subseteq> outside (path_image (p +++ linepath a b))"
< proof -
<   let ?lp = "p +++ linepath a b"
<   have "a \<noteq> b" using x by auto
<   have pp:"path p" using jordan path_join pathfinish_linepath simple_path_imp_path
<     by fastforce
<   have "path_image p \<inter> path_image (linepath a b) \<subseteq> {a,b}"
<     using jordan simple_path_join_loop_eq
<     by (metis (no_types, lifting) inf_sup_aci(1) insert_commute path_join_path_ends path_linepath simple_path_imp_path simple_path_joinE)
<   then have "x \<notin> path_image p" using x unfolding path_image_linepath
<     by (metis DiffE Int_iff le_iff_inf open_segment_def)
<   then have "\<forall>\<^sub>F y in at x. y \<notin> path_image p"
<     by (intro eventually_not_in_closed) (auto simp: closed_path_image \<open>path p\<close>)
<   moreover 
<   have "\<forall>\<^sub>F y in at x. (y - a) \<bullet> rot (a - b) = 0 \<longrightarrow> y \<in> {a<--<b}"
<     by (rule eventually_at_open_segment[OF x])
<   ultimately have "\<forall>\<^sub>F y in at x. y \<notin> path_image p \<and> ((y - a) \<bullet> rot (a - b) = 0 \<longrightarrow> y \<in> {a<--<b})"
<     by eventually_elim auto
<   then obtain e where e: "e > 0" "ball x e \<inter> path_image p = {}"
<     "ball x e \<inter> {y. (y - a) \<bullet> rot (a - b) = 0} \<subseteq> {a<--<b}"
<     using \<open>x \<notin> path_image p\<close> x in_open_segment_rotD[OF x]
<     apply (auto simp: eventually_at subset_iff dist_commute dest!: )
<     by (metis Int_iff all_not_in_conv dist_commute mem_ball) 
<   have a1: "pathfinish ?lp = pathstart ?lp"
<     by (auto simp add: jordan)
<   have "x \<in> path_image ?lp"
<     using jordan(1) open_closed_segment path_image_join path_join_path_ends simple_path_imp_path x by fastforce
<   from jordan_points_inside_outside[OF e(1) jordan(1) a1 this]
<   obtain y z where y: "y \<in> inside (path_image ?lp)" "y \<in> ball x e" 
<     and z: "z \<in> outside (path_image ?lp)" "z \<in> ball x e" by blast
<   have jordancurve:
<     "inside (path_image ?lp) \<inter> outside(path_image ?lp) = {}"
<     "frontier (inside (path_image ?lp)) = path_image ?lp"
<     "frontier (outside (path_image ?lp)) = path_image ?lp"
<     using Jordan_inside_outside_R2[OF jordan(1) a1] by auto
<   define b1 where "b1 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0}"
<   define b2 where "b2 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0}"
<   define b3 where "b3 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) = 0}"
<   have "path_connected b1" unfolding b1_def
<     apply (auto intro!: convex_imp_path_connected convex_Int simp add:inner_diff_left)
<     using convex_halfspace_gt[of "a \<bullet> rot (a - b)" "rot(a-b)"] inner_commute
<     by (metis (no_types, lifting) Collect_cong)
<   have "path_connected b2" unfolding b2_def
<     apply (auto intro!: convex_imp_path_connected convex_Int simp add:inner_diff_left)
<     using convex_halfspace_lt[of "rot(a-b)" "a \<bullet> rot (a - b)"] inner_commute
<     by (metis (no_types, lifting) Collect_cong)
<   have "b1 \<inter> path_image(linepath a b) = {}" unfolding path_image_linepath b1_def
<     using closed_segment_surface[OF \<open>a \<noteq> b\<close>] in_segment_inner_rot2 by auto 
<   then have b1i:"b1 \<inter> path_image ?lp = {}"
<     by (metis IntD2 b1_def disjoint_iff_not_equal e(2) inf_sup_aci(1) not_in_path_image_join)
<   have "b2 \<inter> path_image(linepath a b) = {}" unfolding path_image_linepath b2_def
<     using closed_segment_surface[OF \<open>a \<noteq> b\<close>] in_segment_inner_rot2 by auto 
<   then have b2i:"b2 \<inter> path_image ?lp = {}"
<     by (metis IntD2 b2_def disjoint_iff_not_equal e(2) inf_sup_aci(1) not_in_path_image_join)
<   have bsplit: "ball x e = b1 \<union> b2 \<union> b3"
<     unfolding b1_def b2_def b3_def
<     by auto
<   have "z \<notin> b3"
<   proof clarsimp
<     assume "z \<in> b3"
<     then have "z \<in> {a<--<b}" unfolding b3_def using e by blast
<     then have "z \<in> path_image(linepath a b)" by (auto simp add: open_segment_def)
<     then have "z \<in> path_image ?lp"
<       by (simp add: jordan(2) path_image_join)
<     thus False using z
<       using inside_Un_outside by fastforce
<   qed
<   then have z12: "z \<in> b1 \<or> z \<in> b2" using z bsplit by blast
<   have "y \<notin> b3"
<   proof clarsimp
<     assume "y \<in> b3"
<     then have "y \<in> {a<--<b}" unfolding b3_def using e by auto
<     then have "y \<in> path_image(linepath a b)" by (auto simp add: open_segment_def)
<     then have "y \<in> path_image ?lp"
<       by (simp add: jordan(2) path_image_join)
<     thus False using y
<       using inside_Un_outside by fastforce
<   qed
<   then have "y \<in> b1 \<or> y \<in> b2" using y bsplit by blast
<   moreover {
<     assume "y \<in> b1"
<     then have "b1 \<inter> inside (path_image ?lp) \<noteq> {}" using y by blast
<     from path_connected_not_frontier_subset[OF \<open>path_connected b1\<close> this]
<     have 1:"b1 \<subseteq> inside (path_image ?lp)" unfolding jordancurve using b1i
<       by blast
<     then have "z \<in> b2" using jordancurve(1) z(1) z12 by blast
<     then have "b2 \<inter> outside (path_image ?lp) \<noteq> {}" using z by blast
<     from path_connected_not_frontier_subset[OF \<open>path_connected b2\<close> this]
<     have 2:"b2 \<subseteq> outside (path_image ?lp)" unfolding jordancurve using b2i
<       by blast
<     note conjI[OF 1 2]
<   }
<   moreover {
<     assume "y \<in> b2"
<     then have "b2 \<inter> inside (path_image ?lp) \<noteq> {}" using y by blast
<     from path_connected_not_frontier_subset[OF \<open>path_connected b2\<close> this]
<     have 1:"b2 \<subseteq> inside (path_image ?lp)" unfolding jordancurve using b2i
<       by blast
<     then have "z \<in> b1" using jordancurve(1) z(1) z12 by blast
<     then have "b1 \<inter> outside (path_image ?lp) \<noteq> {}" using z by blast
<     from path_connected_not_frontier_subset[OF \<open>path_connected b1\<close> this]
<     have 2:"b1 \<subseteq> outside (path_image ?lp)" unfolding jordancurve using b1i
<       by blast
<     note conjI[OF 1 2]
<   } 
<   ultimately show ?thesis unfolding b1_def b2_def using that[OF e(1-2)] by auto
< qed
< 
< subsection \<open>Transversal Segments\<close>\<comment> \<open>TODO: Transversal surface in Euclidean space?!\<close>
< 
< definition "transversal_segment a b \<longleftrightarrow>
<   a \<noteq> b \<and> {a--b} \<subseteq> X \<and>
<   (\<forall>z \<in> {a--b}. f z \<bullet> rot (a-b) \<noteq> 0)"
< 
< lemma transversal_segment_reverse:
<   assumes "transversal_segment x y"
<   shows "transversal_segment y x"
<   unfolding transversal_segment_def
<   by (metis (no_types, hide_lams) add.left_neutral add_uminus_conv_diff assms closed_segment_commute inner_diff_left inner_zero_left nrm_reverse transversal_segment_def) 
< 
< lemma transversal_segment_commute: "transversal_segment x y \<longleftrightarrow> transversal_segment y x"
<   using transversal_segment_reverse by blast
< 
< lemma transversal_segment_neg:
<   assumes "transversal_segment x y"
<   assumes w: "w \<in> {x -- y}" and "f w \<bullet> rot (x-y) < 0"
<   shows "\<forall>z \<in> {x--y}. f(z) \<bullet> rot (x-y) < 0"
< proof (rule ccontr)
<   assume " \<not> (\<forall>z\<in>{x--y}. f z \<bullet> rot (x-y) < 0)"
<   then obtain z where z: "z \<in> {x--y}" "f z \<bullet> rot (x-y) \<ge> 0" by auto
<   define ff where "ff = (\<lambda>s. f (w + s *\<^sub>R (z - w)) \<bullet> rot (x-y))"
<   have f0:"ff 0 \<le> 0" unfolding ff_def using assms(3)
<     by simp 
<   have fu:"ff 1 \<ge> 0"
<     by (auto simp: ff_def z)
<   from assms(2) obtain u where u: "0 \<le> u" "u \<le> 1" "w = (1 - u) *\<^sub>R x + u *\<^sub>R y"
<     unfolding in_segment by blast
<   have "{x--y} \<subseteq> X" using assms(1) unfolding transversal_segment_def by blast
<   then have "continuous_on {0..1} ff" unfolding ff_def 
<     using assms(2)
<     by (auto intro!:continuous_intros closed_subsegmentI z elim!: set_mp)
<   from IVT'[of ff, OF f0 fu zero_le_one this]
<   obtain s where s: "s \<ge> 0" "s \<le> 1" "ff s = 0" by blast
<   have "w + s *\<^sub>R (z - w) \<in> {x -- y}"
<     by (auto intro!: closed_subsegmentI z s w)
<   with \<open>ff s = 0\<close> show False
<     using s assms(1) unfolding transversal_segment_def ff_def by blast
< qed
< 
< lemmas transversal_segment_sign_less = transversal_segment_neg[OF _ ends_in_segment(1)]
< 
< lemma transversal_segment_pos:
<   assumes "transversal_segment x y"
<   assumes w: "w \<in> {x -- y}" "f w \<bullet> rot (x-y) > 0"
<   shows "\<forall>z \<in> {x--y}. f(z) \<bullet> rot (x-y) > 0"
<   using transversal_segment_neg[OF transversal_segment_reverse[OF assms(1)], of w] w
<   by (auto simp: rot_diff_commute[of x y] closed_segment_commute)
< 
< lemma transversal_segment_posD:
<   assumes "transversal_segment x y"
<     and pos: "z \<in> {x -- y}" "f z \<bullet> rot (x - y) > 0"
<   shows "x \<noteq> y" "{x--y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x-y) > 0"
<   using assms(1) transversal_segment_pos[OF assms]
<   by (auto simp: transversal_segment_def)
< 
< lemma transversal_segment_negD:
<   assumes "transversal_segment x y"
<     and pos: "z \<in> {x -- y}" "f z \<bullet> rot (x - y) < 0"
<   shows "x \<noteq> y" "{x--y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x-y) < 0"
<   using assms(1) transversal_segment_neg[OF assms]
<   by (auto simp: transversal_segment_def)
< 
< lemma transversal_segmentE:
<   assumes "transversal_segment x y"
<   obtains "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x - y) > 0"
<   |  "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (y - x) > 0"
< proof (cases "f x \<bullet> rot (x - y) < 0")
<   case True
<   from transversal_segment_negD[OF assms ends_in_segment(1) True]
<   have "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (y - x) > 0"
<     by (auto simp: rot_diff_commute[of x y])
<   then show ?thesis ..
< next
<   case False
<   then have "f x \<bullet> rot (x - y) > 0" using assms
<     by (auto simp: transversal_segment_def sign_simps not_less order.order_iff_strict)
<   from transversal_segment_posD[OF assms ends_in_segment(1) this]
<   show ?thesis ..
< qed
< 
< lemma dist_add_vec:
<   shows "dist (x + s *\<^sub>R v) x = abs s * norm v"
<   by (simp add: dist_cancel_add1)
< 
< lemma transversal_segment_exists:
<   assumes "x \<in> X" "f x \<noteq> 0"
<   obtains a b where "x \<in> {a<--<b}"
<     "transversal_segment a b"
< proof -
<   (* Line through x perpendicular to f x *)
<   define l where "l = (\<lambda>s::real. x + (s/norm(f x)) *\<^sub>R rot (f x))"
<   have "norm (f x) > 0" using assms(2) using zero_less_norm_iff by blast 
<   then have distl: "\<forall>s. dist (l s) x = abs s" unfolding l_def dist_add_vec
<     by (auto simp add: norm_rot)
<   obtain d where d:"d > 0" "cball x d \<subseteq> X"
<     by (meson UNIV_I assms(1) local.local_unique_solution)
<   then have lb: "l`{-d..d} \<subseteq> cball x d" using distl by (simp add: abs_le_iff dist_commute image_subset_iff)
<   from fcontx[OF assms(1)] have "continuous (at x) f" .
<   then have c:"continuous (at 0) ((\<lambda>y. (f y \<bullet> f x)) \<circ> l)" unfolding l_def
<     by (auto intro!:continuous_intros simp add: assms(2))
<   have "((\<lambda>y. f y \<bullet> f x) \<circ> l) 0 > 0" using assms(2) unfolding l_def o_def by auto
<   from continuous_at_imp_cball[OF c this]
<   obtain r where r:"r > 0" " \<forall>z\<in>cball 0 r. 0 < ((\<lambda>y. f y \<bullet> f x) \<circ> l) z" by blast
<   then have rc:"\<forall>z \<in> l`{-r..r}. 0 < f z \<bullet> f x" using real_norm_def by auto 
<   define dr where "dr = min r d"
<   have t1:"l (-dr) \<noteq> l dr" unfolding l_def dr_def
<     by (smt \<open>0 < d\<close> \<open>0 < norm (f x)\<close> \<open>0 < r\<close> add_left_imp_eq divide_cancel_right norm_rot norm_zero scale_cancel_right)
<   have "x = midpoint (l (-dr)) (l dr)" unfolding midpoint_def l_def by auto
<   then have xin:"x \<in> {l (-dr)<--<(l dr)}" using t1 by auto
<       (* TODO: actually this should be equality, but l is affine ...
<      also the existing stuff about -- is a little too specific *)
<   have lsub:"{l (-dr)--l dr} \<subseteq> l`{-dr..dr}"
<   proof safe
<     fix z
<     assume "z \<in> {l (- dr)--l dr}"
<     then obtain u where u: "0 \<le> u" "u \<le> 1" "z = (1 - u) *\<^sub>R (l (-dr)) + u *\<^sub>R (l dr)"
<       unfolding in_segment by blast
<     then have "z = x - (1-u) *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x) + u *\<^sub>R  (dr/norm(f x)) *\<^sub>R rot (f x) "
<       unfolding l_def
<       by (simp add: l_def scaleR_add_right scale_right_diff_distrib u(3))
<     also have "... = x - (1 - 2 * u) *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x)"
<       by (auto simp add: algebra_simps divide_simps simp flip: scaleR_add_left)
<     also have "... =  x + (((2 * u - 1) * dr)/norm(f x)) *\<^sub>R rot (f x)"
<       by (smt add_uminus_conv_diff scaleR_scaleR scale_minus_left times_divide_eq_right)
<     finally have zeq: "z = l ((2*u-1)*dr)" unfolding l_def .
<     have ub: " 2* u - 1 \<le> 1 \<and> -1 \<le>  2* u - 1 " using u by linarith
<     thus "z \<in> l ` {- dr..dr}" using zeq
<       by (smt atLeastAtMost_iff d(1) dr_def image_eqI mult.commute mult_left_le mult_minus_left r(1)) 
<   qed
<   have t2: "{l (- dr)--l dr} \<subseteq> X" using lsub
<     by (smt atLeastAtMost_iff d(2) dist_commute distl dr_def image_subset_iff mem_cball order_trans)
<   have "l (- dr) - l dr = -2 *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x)" unfolding l_def
<     by (simp add: algebra_simps flip: scaleR_add_left)
<   then have req: "rot (l (- dr) - l dr) = (2 * dr/norm(f x)) *\<^sub>R f x"
<     by auto (metis add.inverse_inverse rot_rot rot_scaleR)
<   have "l`{-dr..dr} \<subseteq> l ` {-r ..r}"
<     by (simp add: dr_def image_mono)
<   then have "{l (- dr)--l dr} \<subseteq> l ` {-r .. r}" using lsub by auto
<   then have "\<forall>z \<in> {l (- dr)--l dr}. 0 < f z \<bullet> f x" using rc by blast
<   moreover have "(dr / norm (f x)) > 0"
<     using \<open>0 < norm (f x)\<close> d(1) dr_def r(1) by auto 
<   ultimately have t3: "\<forall>z \<in> {l (- dr)--l dr}. f z \<bullet> rot (l (- dr)- l dr) > 0" unfolding req
<     by (smt divide_divide_eq_right inner_scaleR_right mult_2 norm_not_less_zero scaleR_2 times_divide_eq_left times_divide_eq_right zero_less_divide_iff)
<   have "transversal_segment (l (-dr)) (l dr)" using t1 t2 t3 unfolding transversal_segment_def by auto
<   thus ?thesis using xin
<     using that by auto 
< qed
< 
< text \<open>Perko Section 3.7 Lemma 2 part 1.\<close> 
< lemma flow_transversal_segment_finite_intersections:
<   assumes "transversal_segment a b"
<   assumes "t \<le> t'" "{t .. t'} \<subseteq> existence_ivl0 x"
<   shows "finite {s\<in>{t..t'}. flow0 x s \<in> {a--b}}"
< proof -
<   from assms have "a \<noteq> b" by (simp add: transversal_segment_def)
<   show ?thesis
<     unfolding closed_segment_surface[OF \<open>a \<noteq> b\<close>]
<     apply (rule flow_transversal_surface_finite_intersections[where Ds="\<lambda>_. blinfun_inner_left (rot (b - a))"])
<     by
<       (use assms in \<open>auto intro!: closed_Collect_conj closed_halfspace_component_ge closed_halfspace_component_le
<         derivative_eq_intros
<         simp: transversal_segment_def nrm_reverse[where x=a] in_closed_segment_iff_rot\<close>)
< qed
< 
< lemma transversal_bound_posE:
<   assumes transversal: "transversal_segment a b"
<   assumes direction: "z \<in> {a -- b}" "f z \<bullet> (rot (a - b)) > 0"
<   obtains d B where "d > 0" "0 < B"
<     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (a - b)) \<ge> B"
< proof -
<   let ?a = "(\<lambda>y. (f y) \<bullet> (rot (a - b)))"
<   from transversal_segment_posD[OF transversal direction]
<   have seg: "a \<noteq> b" "{a--b} \<subseteq> X" "z \<in> {a--b} \<Longrightarrow> 0 < f z \<bullet> rot (a - b)" for z
<     by auto
<   {
<     fix x
<     assume "x \<in> {a--b}"
<     then have "x \<in> X" "f x \<noteq> 0" "a \<noteq> b" using transversal by (auto simp: transversal_segment_def)
<     then have "?a \<midarrow>x\<rightarrow> ?a x"
<       by (auto intro!: tendsto_eq_intros)
<     moreover have "?a x > 0"
<       using seg \<open>x \<in> {a -- b}\<close> \<open>f x \<noteq> 0\<close>
<       by (auto simp: simp del: divide_const_simps
<           intro!: divide_pos_pos mult_pos_pos)
<     ultimately have "\<forall>\<^sub>F x in at x. ?a x > 0"
<       by (rule order_tendstoD)
<     moreover have "\<forall>\<^sub>F x in at x. x \<in> X"
<       by (rule topological_tendstoD[OF tendsto_ident_at open_dom \<open>x \<in> X\<close>])
<     moreover have "\<forall>\<^sub>F x in at x. f x \<noteq> 0"
<       by (rule tendsto_imp_eventually_ne tendsto_intros \<open>x \<in> X\<close> \<open>f x \<noteq> 0\<close>)+
<     ultimately have "\<forall>\<^sub>F x in at x. ?a x>0 \<and> x \<in> X \<and> f x \<noteq> 0" by eventually_elim auto
<     then obtain d where d: "0 < d" "\<And>y. y \<in> cball x d \<Longrightarrow> ?a y > 0 \<and> y \<in> X \<and> f y \<noteq> 0"
<       using \<open>?a x > 0\<close> \<open>x \<in> X\<close>
<       by (force simp: eventually_at_le dist_commute)
< 
<     have "continuous_on (cball x d) ?a"
<       using d \<open>a \<noteq> b\<close>
<       by (auto intro!: continuous_intros)
<     from compact_continuous_image[OF this compact_cball]
<     have "compact (?a ` cball x d)" .
<     from compact_attains_inf[OF this] obtain s where "s \<in> cball x d" "\<forall>x\<in>cball x d. ?a x \<ge> ?a s"
<       using \<open>d > 0\<close>
<       by auto
<     then have "\<exists>d>0. \<exists>b>0. \<forall>x \<in> cball x d. ?a x \<ge> b"
<       using d
<       by (force simp: intro: exI[where x="?a s"])
<   } then obtain dx Bx where dB:
<     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> y\<in>cball x (dx x) \<Longrightarrow> ?a y \<ge> Bx x"
<     "\<And>x. x \<in> {a -- b} \<Longrightarrow> Bx x > 0"
<     "\<And>x. x \<in> {a -- b} \<Longrightarrow> dx x > 0"
<     by metis
<   define d' where "d' = (\<lambda>x. dx x / 2)"
<   have d':
<     "\<And>x. x \<in> {a -- b} \<Longrightarrow> \<forall>y\<in>cball x (d' x). ?a y \<ge> Bx x"
<     "\<And>x. x \<in> {a -- b} \<Longrightarrow> d' x > 0"
<     using dB(1,3) by (force simp: d'_def)+
<   have d'B: "\<And>x. x \<in> {a -- b} \<Longrightarrow> \<forall>y\<in>cball x (d' x). ?a y \<ge> Bx x"
<     using d' by auto
<   have "{a--b} \<subseteq> \<Union>((\<lambda>x. ball x (d' x)) ` {a -- b})"
<     using d'(2) by auto
<   from compactE_image[OF compact_segment _ this]
<   obtain X where X: "X \<subseteq> {a--b}"
<     and [simp]: "finite X"
<     and cover: "{a--b} \<subseteq> (\<Union>x\<in>X. ball x (d' x))"
<     by auto
<   have [simp]: "X \<noteq> {}" using X cover by auto
<   define d where "d = Min (d' ` X)"
<   define B where "B = Min (Bx ` X)"
<   have "d > 0"
<     using X d'
<     by (auto simp: d_def d'_def)
<   moreover have "B > 0"
<     using X dB
<     by (auto simp: B_def simp del: divide_const_simps)
<   moreover have "B \<le> ?a y" if "x \<in> {a -- b}" "dist x y \<le> d" for x y
<   proof -
<     from \<open>x \<in> {a -- b}\<close> obtain xc where xc: "xc \<in> X" "x \<in> ball xc (d' xc)"
<       using cover by auto
<     have "?a y \<ge> Bx xc"
<     proof (rule dB)
<       show "xc \<in> {a -- b}" using xc \<open>X \<subseteq> _\<close> by auto
<       have "dist xc y \<le> dist xc x + dist x y" by norm
<       also have "dist xc x \<le> d' xc" using xc by auto
<       also note \<open>dist x y \<le> d\<close>
<       also have "d \<le> d' xc"
<         using xc
<         by (auto simp: d_def)
<       also have "d' xc + d' xc = dx xc" by (simp add: d'_def)
<       finally show "y \<in> cball xc (dx xc)" by simp
<     qed
<     also have "B \<le> Bx xc"
<       using xc
<       unfolding B_def
<       by (auto simp: B_def)
<     finally (xtrans) show ?thesis .
<   qed
<   ultimately show ?thesis ..
< qed
< 
< lemma transversal_bound_negE:
<   assumes transversal: "transversal_segment a b"
<   assumes direction: "z \<in> {a -- b}" "f z \<bullet> (rot (a - b)) < 0"
<   obtains d B where "d > 0" "0 < B"
<     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (b - a)) \<ge> B"
< proof -
<   from direction have "z \<in> {b -- a}" "f z \<bullet> (rot (b - a)) > 0"
<     by (auto simp: closed_segment_commute rot_diff_commute[of b a])
<   from transversal_bound_posE[OF transversal_segment_reverse[OF transversal] this]
<   obtain d B where "d > 0" "0 < B"
<     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (b - a)) \<ge> B"
<     by (auto simp: closed_segment_commute)
<   then show ?thesis ..
< qed
< 
< lemma leaves_transversal_segmentE:
<   assumes transversal: "transversal_segment a b"
<   obtains T n where "T > 0" "n = a - b \<or> n = b - a"
<     "\<And>x. x \<in> {a -- b} \<Longrightarrow> {-T..T} \<subseteq> existence_ivl0 x"
<     "\<And>x s. x \<in> {a -- b} \<Longrightarrow> 0 < s \<Longrightarrow> s \<le> T \<Longrightarrow>
<     (flow0 x s - x) \<bullet> rot n > 0"
<     "\<And>x s. x \<in> {a -- b} \<Longrightarrow> -T \<le> s \<Longrightarrow> s < 0 \<Longrightarrow>
<     (flow0 x s - x) \<bullet> rot n < 0"
< proof -
<   from transversal_segmentE[OF assms(1)] obtain n
<     where n: "n = (a - b) \<or> n = (b - a)"
<       and seg: "a \<noteq> b" "{a -- b} \<subseteq> X" "\<And>z. z \<in> {a--b} \<Longrightarrow> f z \<bullet> rot n > 0"
<     by metis
<   from open_existence_ivl_on_compact[OF \<open>{a -- b} \<subseteq> X\<close>]
<   obtain t where "0 < t" and t: "x \<in> {a--b} \<Longrightarrow> {- t..t} \<subseteq> existence_ivl0 x" for x
<     by auto
<   from n obtain d B where B: "0 < d" "0 < B" "(\<And>x y. x \<in> {a--b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> B \<le> f y \<bullet> rot n)"
<   proof
<     assume n_def: "n = a - b"
<     with seg have pos:  "0 < f a \<bullet> rot (a - b)"
<       by auto
<     from transversal_bound_posE[OF transversal ends_in_segment(1) pos, folded n_def]
<     show ?thesis using that by blast
<   next
<     assume n_def: "n = b - a"
<     with seg have pos:  "0 > f a \<bullet> rot (a - b)"
<       by (auto simp: rot_diff_commute[of a b])
<     from transversal_bound_negE[OF transversal ends_in_segment(1) this, folded n_def]
<     show ?thesis using that by blast
<   qed
<   define S where "S = \<Union>((\<lambda>x. ball x d) ` {a -- b})"
<   have S: "x \<in> S \<Longrightarrow> B \<le> f x \<bullet> rot n" for x
<     by (auto simp: S_def intro!: B)
<   have "open S" by (auto simp: S_def)
<   have "{a -- b} \<subseteq> S"
<     by (auto simp: S_def \<open>0 < d\<close>)
<   have "\<forall>\<^sub>F (t, x) in at (0, x). flow0 x t \<in> S" if "x \<in> {a -- b}" for x
<     unfolding split_beta'
<     apply (rule topological_tendstoD tendsto_intros)+
<     using set_mp[OF \<open>{a -- b} \<subseteq> X\<close> that] \<open>0 < d\<close> that \<open>open S\<close> \<open>{a -- b} \<subseteq> S\<close>
<     by (force simp: )+
<   then obtain d' where d':
<     "\<And>x. x \<in> {a--b} \<Longrightarrow> d' x > 0"
<     "\<And>x y s. x \<in> {a--b} \<Longrightarrow> (s = 0 \<longrightarrow> y \<noteq> x) \<Longrightarrow> dist (s, y) (0, x) < d' x \<Longrightarrow> flow0 y s \<in> S"
<     by (auto simp: eventually_at) metis
<   define d2 where "d2 x = d' x / 2" for x
<   have d2: "\<And>x. x \<in> {a--b} \<Longrightarrow> d2 x > 0" using d' by (auto simp: d2_def)
<   have C: "{a--b} \<subseteq> \<Union>((\<lambda>x. ball x (d2 x)) ` {a -- b})"
<     using d2 by auto
<   from compactE_image[OF compact_segment _ C]
<   obtain C' where "C' \<subseteq> {a--b}" and [simp]: "finite C'"
<     and C'_cover: "{a--b} \<subseteq> (\<Union>c\<in>C'. ball c (d2 c))" by auto
< 
<   define T where "T = Min (insert t (d2 ` C'))"
< 
<   have "T > 0"
<     using \<open>0 < t\<close> d2 \<open>C' \<subseteq> _\<close> 
<     by (auto simp: T_def)
<   moreover
<   note n
<   moreover
<   have T_ex: "{-T..T} \<subseteq> existence_ivl0 x" if "x \<in> {a--b}" for x
<     by (rule order_trans[OF _ t[OF that]]) (auto simp: T_def)
<   moreover
<   have B_le: "B \<le> f (flow0 x \<xi>) \<bullet> rot n"
<     if "x \<in> {a -- b}"
<       and c': "c' \<in> C'" "x \<in> ball c' (d2 c')"
<       and "\<xi> \<noteq> 0" and \<xi>_le: "\<bar>\<xi>\<bar> < d2 c'"
<     for x c' \<xi>
<   proof -
<     have "c' \<in> {a -- b}" using c' \<open>C' \<subseteq> _\<close> by auto
<     moreover have "\<xi> = 0 \<longrightarrow> x \<noteq> c'" using \<open>\<xi> \<noteq> 0\<close> by simp
<     moreover have "dist (\<xi>, x) (0, c') < d' c'"
<     proof -
<       have "dist (\<xi>, x) (0, c') \<le> dist (\<xi>, x) (\<xi>, c') + dist (\<xi>, c') (0, c')"
<         by norm
<       also have "dist (\<xi>, x) (\<xi>, c') < d2 c'"
<         using c'
<         by (simp add: dist_prod_def dist_commute)
<       also
<       have "T \<le> d2 c'" using c'
<         by (auto simp: T_def)
<       then have "dist (\<xi>, c') (0, c') < d2 c'"
<         using \<xi>_le
<         by (simp add: dist_prod_def)
<       also have "d2 c' + d2 c' = d' c'" by (simp add: d2_def)
<       finally show ?thesis by simp
<     qed
<     ultimately have "flow0 x \<xi> \<in> S"
<       by (rule d')
<     then show ?thesis
<       by (rule S)
<   qed
<   let ?g = "(\<lambda>x t. (flow0 x t - x) \<bullet> rot n)"
<   have cont: "continuous_on {-T .. T} (?g x)"
<     if "x \<in> {a--b}" for x
<     using T_ex that
<     by (force intro!: continuous_intros)
<   have deriv: "-T \<le> s' \<Longrightarrow> s' \<le> T \<Longrightarrow> ((?g x) has_derivative
<       (\<lambda>t. t * (f (flow0 x s') \<bullet> rot n))) (at s')"
<     if "x \<in> {a--b}" for x s'
<     using T_ex that
<     by (force intro!: derivative_eq_intros simp: flowderiv_def blinfun.bilinear_simps)
< 
<   have "(flow0 x s - x) \<bullet> rot n > 0" if "x \<in> {a -- b}" "0 < s" "s \<le> T" for x s
<   proof (rule ccontr, unfold not_less)
<     have [simp]: "x \<in> X" using that \<open>{a -- b} \<subseteq> X\<close> by auto
<     assume H: "(flow0 x s - x) \<bullet> rot n \<le> 0"
<     have cont: "continuous_on {0 .. s} (?g x)"
<       using cont by (rule continuous_on_subset) (use that in auto)
<     from mvt[OF \<open>0 < s\<close> cont deriv] that
<     obtain \<xi> where \<xi>: "0 < \<xi>" "\<xi> < s" "(flow0 x s - x) \<bullet> rot n = s * (f (flow0 x \<xi>) \<bullet> rot n)"
<       by (auto intro: continuous_on_subset)
<     note \<open>0 < B\<close>
<     also
<     from C'_cover that obtain c' where c': "c' \<in> C'" "x \<in> ball c' (d2 c')" by auto
<     have "B \<le> f (flow0 x \<xi>) \<bullet> rot n"
<     proof (rule B_le[OF that(1) c'])
<       show "\<xi> \<noteq> 0" using \<open>0 < \<xi>\<close> by simp
<       have "T \<le> d2 c'" using c'
<         by (auto simp: T_def)
<       then show "\<bar>\<xi>\<bar> < d2 c'"
<         using \<open>0 < \<xi>\<close> \<open>\<xi> < s\<close> \<open>s \<le> T\<close>
<         by (simp add: dist_prod_def)
<     qed
<     also from \<xi> H have "\<dots> \<le> 0"
<       by (auto simp add: sign_simps not_less split: if_splits)
<         (metis mult_zero_right real_mult_le_cancel_iff2 that(2))
<     finally show False by simp
<   qed
<   moreover
<   have "(flow0 x s - x) \<bullet> rot n < 0" if "x \<in> {a -- b}" "-T \<le> s" "s < 0" for x s
<   proof (rule ccontr, unfold not_less)
<     have [simp]: "x \<in> X" using that \<open>{a -- b} \<subseteq> X\<close> by auto
<     assume H: "(flow0 x s - x) \<bullet> rot n \<ge> 0"
<     have cont: "continuous_on {s .. 0} (?g x)"
<       using cont by (rule continuous_on_subset) (use that in auto)
<     from mvt[OF \<open>s < 0\<close> cont deriv] that
<     obtain \<xi> where \<xi>: "s < \<xi>" "\<xi> < 0" "(flow0 x s - x) \<bullet> rot n = s * (f (flow0 x \<xi>) \<bullet> rot n)"
<       by auto
<     note \<open>0 < B\<close>
<     also
<     from C'_cover that obtain c' where c': "c' \<in> C'" "x \<in> ball c' (d2 c')" by auto
<     have "B \<le> (f (flow0 x \<xi>) \<bullet> rot n)"
<     proof (rule B_le[OF that(1) c'])
<       show "\<xi> \<noteq> 0" using \<open>0 > \<xi>\<close> by simp
<       have "T \<le> d2 c'" using c'
<         by (auto simp: T_def)
<       then show "\<bar>\<xi>\<bar> < d2 c'"
<         using \<open>0 > \<xi>\<close> \<open>\<xi> > s\<close> \<open>s \<ge> - T\<close>
<         by (simp add: dist_prod_def)
<     qed
<     also from \<xi> H have "\<dots> \<le> 0"
<       by (simp add: sign_simps algebra_simps)
<         (metis less_eq_real_def mult_less_cancel_left mult_pos_neg2 mult_zero_right that(3))
<     finally show False by simp
<   qed
<   ultimately show ?thesis ..
< qed
< 
< 
< lemma inner_rot_pos_move_base: "(x - a) \<bullet> rot (a - b) > 0"
<   if "(x - y) \<bullet> rot (a - b) > 0" "y \<in> {a -- b}"
<   by (smt in_segment_inner_rot inner_diff_left inner_minus_right minus_diff_eq rot_rot that)
< 
< lemma inner_rot_neg_move_base: "(x - a) \<bullet> rot (a - b) < 0"
<   if "(x - y) \<bullet> rot (a - b) < 0" "y \<in> {a -- b}"
<   by (smt in_segment_inner_rot inner_diff_left inner_minus_right minus_diff_eq rot_rot that)
< 
< lemma inner_pos_move_base: "(x - a) \<bullet> n > 0"
<   if "(a - b) \<bullet> n = 0" "(x - y) \<bullet> n > 0" "y \<in> {a -- b}"
< proof -
<   from that(3) obtain u where y_def: "y = (1 - u) *\<^sub>R a + u *\<^sub>R b" and u: "0 \<le> u" "u \<le> 1"
<     by (auto simp: in_segment)
<   have "(x - a) \<bullet> n = (x - y) \<bullet> n - u * ((a - b) \<bullet> n)"
<     by (simp add: algebra_simps y_def)
<   also have "\<dots> = (x - y) \<bullet> n"
<     by (simp add: that)
<   also note \<open>\<dots> > 0\<close>
<   finally show ?thesis .
< qed
< 
< lemma inner_neg_move_base: "(x - a) \<bullet> n < 0"
<   if "(a - b) \<bullet> n = 0" "(x - y) \<bullet> n < 0" "y \<in> {a -- b}"
< proof -
<   from that(3) obtain u where y_def: "y = (1 - u) *\<^sub>R a + u *\<^sub>R b" and u: "0 \<le> u" "u \<le> 1"
<     by (auto simp: in_segment)
<   have "(x - a) \<bullet> n = (x - y) \<bullet> n - u * ((a - b) \<bullet> n)"
<     by (simp add: algebra_simps y_def)
<   also have "\<dots> = (x - y) \<bullet> n"
<     by (simp add: that)
<   also note \<open>\<dots> < 0\<close>
<   finally show ?thesis .
< qed
< 
< lemma rot_same_dir:
<   assumes "x1 \<in> {a<--<b}"
<   assumes "x2 \<in> {x1<--<b}"
<   shows "(y \<bullet> rot (a-b) > 0) = (y \<bullet> rot(x1-x2) > 0)"  "(y \<bullet> rot (a-b) < 0) = (y \<bullet> rot(x1-x2) < 0)"
<   using oriented_subsegment_scale[OF assms]
<    apply (smt inner_scaleR_right nrm_reverse rot_scaleR zero_less_mult_iff)
<   by (smt \<open>\<And>thesis. (\<And>e. \<lbrakk>0 < e; b - a = e *\<^sub>R (x2 - x1)\<rbrakk> \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> inner_minus_right inner_scaleR_right rot_diff_commute rot_scaleR zero_less_mult_iff)
< 
< 
< subsection \<open>Monotone Step Lemma\<close>
< 
< lemma flow0_transversal_segment_monotone_step:
<   assumes "transversal_segment a b"
<   assumes "t1 \<le> t2" "{t1..t2} \<subseteq> existence_ivl0 x"
<   assumes x1: "flow0 x t1 \<in> {a<--<b}"
<   assumes x2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
<   assumes "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
<   assumes "t > t2" "t \<in> existence_ivl0 x"
<   shows "flow0 x t \<notin> {a<--<flow0 x t2}"
< proof -
<   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
<   note t1t2 = \<open>\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}\<close>
<     (* Basic properties of the segment *)
<   have x1neqx2: "flow0 x t1 \<noteq> flow0 x t2"
<     using open_segment_def x2 by force 
<   then have t1neqt2: "t1 \<noteq> t2" by auto
< 
<   have [simp]: "a \<noteq> b" and \<open>{a -- b} \<subseteq> X\<close> using \<open>transversal_segment a b\<close>
<     by (auto simp: transversal_segment_def)
< 
<   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
<     by (auto simp: in_open_segment_iff_line)
<   from x2 obtain i2 where i2: "flow0 x t2 = line a b i2" "0 < i1" "i1 < i2"
<     by (auto simp: i1 line_open_segment_iff)
< 
< 
<   have "{a <--< flow0 x t1} \<subseteq> {a<--<b}"
<     by (simp add: open_closed_segment subset_open_segment x1) 
<   have t12sub: "{flow0 x t1--flow0 x t2} \<subseteq> {a<--<b}"
<     by (metis ends_in_segment(2) open_closed_segment subset_co_segment subset_eq subset_open_segment x1 x2)
<   have subr: "{flow0 x t1<--<flow0 x t2} \<subseteq> {flow0 x t1 <--<b}"
<     by (simp add: open_closed_segment subset_open_segment x2)
<   have "flow0 x t1 \<in> {a <--<flow0 x t2}" using x1 x2
<     by (rule open_segment_subsegment)
<   then have subl: "{flow0 x t1<--<flow0 x t2} \<subseteq> {a <--< flow0 x t2}" using x1 x2
<     by (simp add: open_closed_segment subset_open_segment x2)
<   then have subl2: "{flow0 x t1--<flow0 x t2} \<subseteq> {a <--< flow0 x t2}" using x1 x2
<     by (smt DiffE DiffI \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> half_open_segment_def insert_iff open_segment_def subset_eq)
< 
<   have sub1b: "{flow0 x t1--b} \<subseteq> {a--b}"
<     by (simp add: open_closed_segment subset_closed_segment x1)
<   have suba2: "{a--flow0 x t2} \<subseteq> {a -- b}"
<     using open_closed_segment subset_closed_segment t12sub by blast
<   then have suba2o: "{a<--<flow0 x t2} \<subseteq> {a -- b}"
<     using open_closed_segment subset_closed_segment t12sub by blast
<   have x2_notmem: "flow0 x t2 \<notin> {a--flow0 x t1}"
<     using i1 i2
<     by (auto simp: closed_segment_line_iff)
<   have suba12: "{a--flow0 x t1} \<subseteq> {a--flow0 x t2}"
<     by (simp add: \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> open_closed_segment subset_closed_segment)
<   then have suba12_open: "{a<--<flow0 x t1} \<subseteq> {a<--<flow0 x t2}"
<     using x2_notmem
<     by (auto simp: open_segment_def)
<   have "flow0 x t2 \<in> {a--b}"
<     using suba2 by auto
< 
<   have intereq: "\<And>t. t1 \<le> t \<Longrightarrow> t \<le> t2 \<Longrightarrow> flow0 x t \<in> {a<--<b} \<Longrightarrow>  t = t1 \<or> t = t2"
<   proof (rule ccontr)
<     fix t
<     assume t: "t1 \<le> t" "t \<le> t2" "flow0 x t \<in> {a<--<b}" "\<not>(t= t1 \<or> t = t2)"
<     then have "t \<in> {t1<..<t2}" by auto
<     then have "flow0 x t \<notin> {a<--<b}" using t1t2 by blast
<     thus False using t by auto
<   qed
<   then have intereqt12: "\<And>t. t1 \<le> t \<Longrightarrow> t \<le> t2 \<Longrightarrow> flow0 x t \<in> {flow0 x t1--flow0 x t2} \<Longrightarrow>  t = t1 \<or> t = t2"
<     using t12sub by blast
< 
< (* The Jordan curve *)
<   define J1 where "J1 = flow_to_path x t1 t2"
<   define J2 where "J2 = linepath (flow0 x t2) (flow0 x t1)" 
<   define J where "J = J1 +++ J2"
<     (* Proof that J is a Jordan curve *)
<   have "pathfinish J = pathstart J" unfolding J_def J1_def J2_def
<     by (auto simp add: pathstart_compose pathfinish_compose)
<   have piJ: "path_image J = path_image J1 \<union> path_image J2"
<     unfolding J_def J1_def J2_def
<     apply (rule path_image_join)
<     by auto
<   have "flow0 x t1 \<in> flow0 x ` {t1..t2} \<and> flow0 x t2 \<in> flow0 x ` {t1..t2}"
<     using atLeastAtMost_iff \<open>t1 \<le> t2\<close> by blast 
<   then have piD: "path_image J = path_image J1 \<union> {flow0 x t1 <--<flow0 x t2}"
<     unfolding piJ J1_def J2_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
<       path_image_linepath open_segment_def
<     by (smt Diff_idemp Diff_insert2 Un_Diff_cancel closed_segment_commute mk_disjoint_insert)
<   have "\<forall>s\<in>{t1<..<t2}. flow0 x s \<noteq> flow0 x t1"
<     using x1 t1t2 by fastforce
<   from flow_to_path_arc[OF \<open>t1 \<le> t2\<close> exist this x1neqx2]
<   have "arc J1" using J1_def assms flow_to_path_arc by auto
<   then have "simple_path J" unfolding J_def
<     using \<open>arc J1\<close> J1_def J2_def assms x1neqx2 t1neqt2 apply (auto intro!:simple_path_join_loop)
<     using intereqt12 closed_segment_commute by blast
< 
<   from Jordan_inside_outside_R2[OF this \<open>pathfinish J = pathstart J\<close>]
<   obtain inner outer where inner_def: "inner = inside (path_image J)"
<     and outer_def: "outer = outside (path_image J)"
<     and io:
<     "inner \<noteq> {}" "open inner" "connected inner"
<     "outer \<noteq> {}" "open outer" "connected outer"
<     "bounded inner" "\<not> bounded outer" "inner \<inter> outer = {}"
<     "inner \<union> outer = - path_image J"
<     "frontier inner = path_image J"
<     "frontier outer = path_image J" by metis
<   from io have io2: "outer \<inter> inner = {}" "outer \<union> inner = - path_image J" by auto
< 
<   have swap_side: "\<And>y t. y \<in> side2 \<Longrightarrow>
<     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
<     flow0 y t \<in> closure side1 \<Longrightarrow>
<     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> side2) \<and>
<         flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
<     if "side1 \<inter> side2 = {}"
<       "open side2"
<       "frontier side1 = path_image J"
<       "frontier side2 = path_image J"
<       "side1 \<union> side2 = - path_image J"
<     for side1 side2
<   proof -
<     fix y t
<     assume yt: "y \<in> side2" "0 \<le> t" "t \<in> existence_ivl0 y"
<       "flow0 y t \<in> closure side1"
<     define fp where "fp = flow_to_path y 0 t"
<     have ex:"{0..t} \<subseteq> existence_ivl0 y"
<       using ivl_subset_existence_ivl yt(3) by blast
<     then have y0:"flow0 y 0 = y"
<       using mem_existence_ivl_iv_defined(2) yt(3) by auto
<     then have tpos: "t > 0" using yt(2)  \<open>side1 \<inter> side2 = {}\<close>
<       using yt(1) yt(4)
<       by (metis closure_iff_nhds_not_empty less_eq_real_def order_refl that(2)) 
<     from flow_to_path_path[OF yt(2) ex]
<     have a1: "path fp" unfolding fp_def .
<     have "y \<in> closure side2" using yt(1)
<       by (simp add: assms closure_def)
<     then have a2: "pathstart fp \<in> closure side2" unfolding fp_def using y0 by auto
<     have a3:"pathfinish fp \<notin> side2" using yt(4) \<open>side1 \<inter> side2 = {}\<close>
<       unfolding fp_def apply auto
<       using closure_iff_nhds_not_empty that(2) by blast
<     from subpath_to_frontier_strong[OF a1 a3]
<     obtain u where u:"0 \<le> u" "u \<le> 1"
<       "fp u \<notin> interior side2"
<       "u = 0 \<or>
<       (\<forall>x. 0 \<le> x \<and> x < 1 \<longrightarrow>
<         subpath 0 u fp x \<in> interior side2) \<and> fp u \<in> closure side2" by blast
<     have p1:"path_image (subpath 0 u fp) =  flow0 y ` {0 ..  u*t}"
<       unfolding fp_def subpath0_flow_to_path using path_image_flow_to_path
<       by (simp add: u(1) yt(2))
<     have p2:"fp u = flow0 y (u*t)" unfolding fp_def flow_to_path_unfold by simp
<     have inout:"interior side2 = side2" using \<open>open side2\<close>
<       by (simp add: interior_eq)
<     then have iemp: "side2 \<inter> path_image J = {}"
<       using \<open>frontier side2 = path_image J\<close>
<       by (metis frontier_disjoint_eq inf_sup_aci(1) interior_eq)
<     have "u \<noteq> 0" using inout u(3) y0 p2 yt(1) by force
<     then have c1:"u * t > 0" using tpos u y0  \<open>side1 \<inter> side2 = {}\<close>
<       using frontier_disjoint_eq io(5) yt(1) zero_less_mult_iff by fastforce
<     have uim:"fp u \<in> path_image J" using u \<open>u \<noteq> 0\<close>
<       using \<open>frontier side2 = path_image J\<close>
<       by (metis ComplI IntI closure_subset frontier_closures inout subsetD) 
<     have c2:"u * t \<le> t"  using u(1-2) tpos by auto
<     have"(flow_to_path y 0 (u * t) ` {0..<1} \<subseteq> side2)"
<       using \<open>u \<noteq> 0\<close> u inout unfolding fp_def subpath0_flow_to_path by auto
<     then have c3:"\<forall>s \<in>{0..<u*t}. flow0 y s \<in> side2" by auto
<     have c4: "flow0 y (u*t) \<in> path_image J"
<       using uim path_image_join_subset
<       by (simp add: p2)
<     have "flow0 y (u*t) \<notin> path_image J1 \<or> flow0 y (u*t) = flow0 x t1"
<     proof clarsimp
<       assume "flow0 y (u*t) \<in> path_image J1"
<       then obtain s where s: "t1 \<le> s" "s \<le> t2" "flow0 x s = flow0 y (u*t)"
<         using J1_def \<open>t1 \<le> t2\<close> by auto
<       have "s = t1"
<       proof (rule ccontr)
<         assume "s \<noteq> t1"
<         then have st1:"s > t1" using s(1) by linarith
<         define sc where "sc = min (s-t1) (u*t)"
<         have scd: "s-sc \<in> {t1..t2}" unfolding sc_def
<           using c1 s(1) s(2) by auto
<         then have *:"flow0 x (s-sc) \<in> path_image J1" unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
<           by blast
<         have "flow0 x (s-sc) = flow0 (flow0 x s) (-sc)"
<           by (smt exist atLeastAtMost_iff existence_ivl_trans' flow_trans s(1) s(2) scd subsetD)
<         then have **:"flow0 (flow0 y (u*t)) (-sc)  \<in> path_image J1"
<           using s(3) * by auto
<         have b:"u*t - sc \<in> {0..<u*t}" unfolding sc_def by (simp add: st1 c1 s(1))
<         then have "u*t - sc \<in> existence_ivl0 y"
<           using c2 ex by auto 
<         then have "flow0 y (u*t - sc) \<in> path_image J1" using **
<           by (smt atLeastAtMost_iff diff_existence_ivl_trans ex flow_trans mult_left_le_one_le mult_nonneg_nonneg subset_eq u(1) u(2) yt(2))
<         thus False using b c3 iemp piJ by blast
<       qed
<       thus "flow0 y (u * t) = flow0 x t1" using s by simp
<     qed
<     thus "\<exists>T>0. T \<le> t \<and> (\<forall>s\<in>{0..<T}. flow0 y s \<in> side2) \<and>
<           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
<       using c1 c2 c3 c4 unfolding piD
<       by (metis DiffE UnE ends_in_segment(1) half_open_segment_closed_segmentI insertCI open_segment_def x1neqx2)
<   qed
<   have outside_in: "\<And>y t. y \<in> outer \<Longrightarrow>
<     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
<     flow0 y t \<in> closure inner \<Longrightarrow>
<     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> outer) \<and>
<           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
<     by (rule swap_side; (rule io | assumption))
<   have inside_out: "\<And>y t. y \<in> inner \<Longrightarrow>
<     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
<     flow0 y t \<in> closure outer \<Longrightarrow>
<     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> inner) \<and>
<           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
<     by (rule swap_side; (rule io2 io | assumption))
< 
<   from leaves_transversal_segmentE[OF assms(1)]
<   obtain d n where d: "d > (0::real)"
<     and n: "n = a - b \<or> n = b - a"
<     and d_ex: "\<And>x. x \<in> {a -- b} \<Longrightarrow> {-d..d} \<subseteq> existence_ivl0 x"
<     and d_above: "\<And>x s. x \<in> {a -- b} \<Longrightarrow> 0 < s \<Longrightarrow> s \<le> d \<Longrightarrow> (flow0 x s - x) \<bullet> rot n > 0"
<     and d_below: "\<And>x s. x \<in> {a -- b} \<Longrightarrow> -d \<le> s \<Longrightarrow> s < 0 \<Longrightarrow> (flow0 x s - x) \<bullet> rot n < 0"
<     by blast
< 
<   have ortho: "(a - b) \<bullet> rot n = 0"
<     using n by (auto simp: algebra_simps)
< 
< (* These "rectangles" are either fully inside or fully outside
<            |-----------------------|
<            |           r1          | (flow d)
<     a --- (t1) --- rp --- (t2) --- b
<     |          r2           | (flow -d)
<     |-----------------------|
<    *)
<   define r1 where "r1 = (\<lambda>(x, y). flow0 x y)`({flow0 x t1<--<b} \<times> {0<..<d}) "
<   have r1a1: "path_connected {flow0 x t1 <--<b}" by simp
<   have r1a2: "path_connected {0<..<d}" by simp
<   have "{flow0 x t1<--<b} \<subseteq> {a--b}"
<     by (simp add: open_closed_segment subset_oc_segment x1)
<   then have r1a3: "y \<in> {flow0 x t1<--<b} \<Longrightarrow> {0<..<d} \<subseteq> existence_ivl0 y" for y
<     using d_ex[of y]
<     by force
<   from flow0_path_connected[OF r1a1 r1a2 r1a3]
<   have pcr1:"path_connected r1" unfolding r1_def by auto
<   have pir1J1: "r1 \<inter> path_image J1 = {}"
<     unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
<   proof (rule ccontr)
<     assume "r1 \<inter> flow0 x ` {t1..t2} \<noteq> {}"
<     then obtain xx tt ss where
<       eq: "flow0 xx tt = flow0 x ss"
<       and xx: "xx \<in> {flow0 x t1<--<b}"
<       and ss: "t1 \<le> ss" "ss \<le> t2"
<       and tt: "0 < tt" "tt < d"
<       unfolding r1_def
<       by force
<     have "xx \<in> {a -- b}"
<       using sub1b
<       apply (rule set_mp)
<       using xx by (simp add: open_closed_segment)
<     then have [simp]: "xx \<in> X" using \<open>transversal_segment a b\<close> by (auto simp: transversal_segment_def)
<     from ss have ss_ex: "ss \<in> existence_ivl0 x" using exist
<       by auto
<     from d_ex[OF \<open>xx \<in> {a -- b}\<close>] tt
<     have tt_ex: "tt \<in> existence_ivl0 xx" by auto
<     then have neg_tt_ex: "- tt \<in> existence_ivl0 (flow0 xx tt)"
<       by (rule existence_ivl_reverse[simplified])
<     from eq have "flow0 (flow0 xx tt) (-tt) = flow0 (flow0 x ss) (-tt)"
<       by simp
<     then have "xx = flow0 x (ss - tt)"
<       apply (subst (asm) flow_trans[symmetric])
<         apply (rule tt_ex)
<        apply (rule neg_tt_ex)
<       apply (subst (asm) flow_trans[symmetric])
<         apply (rule ss_ex)
<        apply (subst eq[symmetric])
<        apply (rule neg_tt_ex)
<       by simp
<     moreover
<     define e where "e = ss - t1"
<     consider "e > tt" | "e \<le> tt" by arith
<     then show False
<     proof cases
<       case 1
<       have "flow0 (flow0 x ss) (-tt) \<notin> {a<--<b}"
<         apply (subst flow_trans[symmetric])
<           apply fact
<         subgoal using neg_tt_ex eq by simp
<         apply (rule t1t2)
<         using 1 ss tt
<         unfolding e_def
<         by auto
<       moreover have "flow0 (flow0 x ss) (-tt) \<in> {a<--<b}"
<         unfolding eq[symmetric] using tt_ex xx
<         apply (subst flow_trans[symmetric])
<           apply (auto simp add: neg_tt_ex)
<         by (metis (no_types, hide_lams) sub1b subset_eq subset_open_segment)
<       ultimately show ?thesis by simp
<     next
<       case 2
<       have les: "0 \<le> tt - e" "tt - e \<le> d"
<         using tt ss 2 e_def
<         by auto
<       have xxtte: "flow0 xx (tt - e) = flow0 x t1"
<         apply (simp add: e_def)
<         by (smt \<open>0 \<le> tt - e\<close> \<open>{- d..d} \<subseteq> existence_ivl0 xx\<close> atLeastAtMost_iff e_def eq
<             local.existence_ivl_reverse local.existence_ivl_trans local.flow_trans ss(1) ss_ex subset_iff tt(2))
<       show False
<       proof (cases "tt = e")
<         case True
<         with xxtte have "xx = flow0 x t1"
<           by (simp add: )
<         with xx show ?thesis
<           apply auto
<           by (auto simp: open_segment_def)
<       next
<         case False
<         with les have "0 < tt - e" by (simp)
<         from d_above[OF \<open>xx \<in> {a -- b}\<close> this \<open>tt - e \<le> d\<close>]
<         have "flow0 xx (tt - e) \<notin> {a -- b}"
<           apply (simp add: in_closed_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
<               not_le )
<           by (smt \<open>xx \<in> {a--b}\<close> inner_minus_right inner_rot_neg_move_base inner_rot_pos_move_base n rot_diff_commute)
<         with xxtte show ?thesis
<           using \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> suba2o by auto
<       qed
<     qed
<   qed
<     (* for sufficiently small d, the flow does not return to the line *)
<   moreover
<   have pir1J2: "r1 \<inter> path_image J2 = {}"
<   proof -
<     have "r1 \<subseteq> {x. (x - a) \<bullet> rot n > 0}"
<       unfolding r1_def
<     proof safe
<       fix aa ba
<       assume "aa \<in> {flow0 x t1<--<b}" "ba \<in> {0<..<d}"
<       with sub1b show "0 < (flow0 aa ba - a) \<bullet> rot n"
<         using segment_open_subset_closed[of "flow0 x t1" b]
<         by (intro inner_pos_move_base[OF ortho d_above]) auto
<     qed
<     also have "\<dots> \<inter> {a -- b} = {}"
<       using in_segment_inner_rot in_segment_inner_rot2 n by auto
<     finally show ?thesis
<       unfolding J2_def path_image_linepath
<       using t12sub open_closed_segment
<       by (force simp: closed_segment_commute)
<   qed
<   ultimately have pir1:"r1 \<inter> (path_image J) = {}" unfolding J_def
<     by (metis disjoint_iff_not_equal not_in_path_image_join)
< 
<   define r2 where "r2 =(\<lambda>(x, y). flow0 x y)`({a <--< flow0 x t2} \<times> {-d<..<0})"
<   have r2a1:"path_connected {a <--< flow0 x t2}" by simp
<   have r2a2:"path_connected {-d<..<0}" by simp
<   have "{a <--< flow0 x t2} \<subseteq> {a -- b}"
<     by (meson ends_in_segment(1) open_closed_segment subset_co_segment subset_oc_segment t12sub)
<   then have r2a3: "y \<in> {a <--< flow0 x t2} \<Longrightarrow> {-d<..<0} \<subseteq> existence_ivl0 y" for y
<     using d_ex[of y]
<     by force
<   from flow0_path_connected[OF r2a1 r2a2 r2a3]
<   have pcr2:"path_connected r2" unfolding r2_def by auto
<   have pir2J2: "r2 \<inter> path_image J1 = {}"
<     unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
<   proof (rule ccontr)
<     assume "r2 \<inter> flow0 x ` {t1..t2} \<noteq> {}"
<     then obtain xx tt ss where
<       eq: "flow0 xx tt = flow0 x ss"
<       and xx: "xx \<in> {a<--<flow0 x t2}"
<       and ss: "t1 \<le> ss" "ss \<le> t2"
<       and tt: "-d < tt" "tt < 0"
<       unfolding r2_def
<       by force
<     have "xx \<in> {a -- b}"
<       using suba2
<       apply (rule set_mp)
<       using xx by (simp add: open_closed_segment)
<     then have [simp]: "xx \<in> X" using \<open>transversal_segment a b\<close> by (auto simp: transversal_segment_def)
<     from ss have ss_ex: "ss \<in> existence_ivl0 x" using exist
<       by auto
<     from d_ex[OF \<open>xx \<in> {a -- b}\<close>] tt
<     have tt_ex: "tt \<in> existence_ivl0 xx" by auto
<     then have neg_tt_ex: "- tt \<in> existence_ivl0 (flow0 xx tt)"
<       by (rule existence_ivl_reverse[simplified])
<     from eq have "flow0 (flow0 xx tt) (-tt) = flow0 (flow0 x ss) (-tt)"
<       by simp
<     then have "xx = flow0 x (ss - tt)"
<       apply (subst (asm) flow_trans[symmetric])
<         apply (rule tt_ex)
<        apply (rule neg_tt_ex)
<       apply (subst (asm) flow_trans[symmetric])
<         apply (rule ss_ex)
<        apply (subst eq[symmetric])
<        apply (rule neg_tt_ex)
<       by simp
<     moreover
<     define e where "e = t2 - ss"
<     consider "e > - tt" | "e \<le> -tt" by arith
<     then show False
<     proof cases
<       case 1
<       have "flow0 (flow0 x ss) (-tt) \<notin> {a<--<b}"
<         apply (subst flow_trans[symmetric])
<           apply fact
<         subgoal using neg_tt_ex eq by simp
<         apply (rule t1t2)
<         using 1 ss tt
<         unfolding e_def
<         by auto
<       moreover have "flow0 (flow0 x ss) (-tt) \<in> {a<--<b}"
<         unfolding eq[symmetric] using tt_ex xx
<         apply (subst flow_trans[symmetric])
<           apply (auto simp add: neg_tt_ex)
<         by (metis (no_types, hide_lams) suba2 subset_eq subset_open_segment)
<       ultimately show ?thesis by simp
<     next
<       case 2
<       have les: "tt + e \<le> 0" "-d \<le> tt + e"
<         using tt ss 2 e_def
<         by auto
<       have xxtte: "flow0 xx (tt + e) = flow0 x t2"
<         apply (simp add: e_def)
<         by (smt atLeastAtMost_iff calculation eq exist local.existence_ivl_trans' local.flow_trans neg_tt_ex ss_ex subset_iff \<open>t1 \<le> t2\<close>)
<       show False
<       proof (cases "tt=-e")
<         case True
<         with xxtte have "xx = flow0 x t2"
<           by (simp add: )
<         with xx show ?thesis
<           apply auto
<           by (auto simp: open_segment_def)
<       next
<         case False
<         with les have "tt+e < 0" by simp
<         from d_below[OF \<open>xx \<in> {a -- b}\<close>  \<open>-d \<le> tt + e\<close> this]
<         have "flow0 xx (tt + e) \<notin> {a -- b}"
<           apply (simp add: in_closed_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
<               not_le )
<           by (smt \<open>xx \<in> {a--b}\<close> inner_minus_right inner_rot_neg_move_base inner_rot_pos_move_base n rot_diff_commute)
<         with xxtte show ?thesis
<           using \<open>flow0 x t2 \<in> {a--b}\<close> by simp
<       qed
<     qed
<   qed
<   moreover
<   have pir2J2: "r2 \<inter> path_image J2 = {}"
<   proof -
<     have "r2 \<subseteq> {x. (x - a) \<bullet> rot n < 0}"
<       unfolding r2_def
<     proof safe
<       fix aa ba
<       assume "aa \<in> {a<--<flow0 x t2}" "ba \<in> {-d<..<0}"
<       with suba2 show "0 > (flow0 aa ba - a) \<bullet> rot n"
<         using segment_open_subset_closed[of a "flow0 x t2"]
<         by (intro inner_neg_move_base[OF ortho d_below]) auto
<     qed
<     also have "\<dots> \<inter> {a -- b} = {}"
<       using in_segment_inner_rot in_segment_inner_rot2 n by auto
<     finally show ?thesis
<       unfolding J2_def path_image_linepath
<       using t12sub open_closed_segment
<       by (force simp: closed_segment_commute)
<   qed
<   ultimately have pir2:"r2 \<inter> (path_image J) = {}"
<     unfolding J_def
<     by (metis disjoint_iff_not_equal not_in_path_image_join)
< 
<   define rp where "rp = midpoint (flow0 x t1) (flow0 x t2)"
<   have rpi: "rp \<in> {flow0 x t1<--<flow0 x t2}" unfolding rp_def
<     by (simp add: x1neqx2)
<   have "rp \<in> {a -- b}"
<     using rpi suba2o subl by blast
<   then have [simp]: "rp \<in> X"
<     using \<open>{a--b} \<subseteq> X\<close> by blast
< 
< (* The fundamental case distinction *)
<   have *: "pathfinish J1 = flow0 x t2"
<     "pathstart J1 = flow0 x t1"
<     "rp \<in> {flow0 x t2<--<flow0 x t1}"
<     using rpi
<     by (auto simp: open_segment_commute J1_def)
<   have "{y. 0 < (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1)} = {y. 0 < (y - rp) \<bullet> rot (flow0 x t2 - flow0 x t1)}"
<     by (smt Collect_cong in_open_segment_rotD inner_diff_left nrm_dot rpi)
<   also have "... =  {y. 0 > (y - rp) \<bullet> rot (flow0 x t1 - flow0 x t2)}"
<     by (smt Collect_cong inner_minus_left nrm_reverse)
<   also have " ... = {y. 0 > (y - rp) \<bullet> rot (a - b) }"
<     by (metis rot_same_dir(2) x1 x2)
<   finally have side1: "{y. 0 < (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1)} = {y. 0 > (y - rp) \<bullet> rot (a - b) }"
<     (is "_ = ?lower1") .
<   have "{y. (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0} = {y. (y - rp) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0}"
<     by (smt Collect_cong in_open_segment_rotD inner_diff_left nrm_dot rpi)
<   also have "... =  {y. (y - rp) \<bullet> rot (flow0 x t1 - flow0 x t2) > 0}"
<     by (smt Collect_cong inner_minus_left nrm_reverse)
<   also have " ... = {y. 0 < (y - rp) \<bullet> rot (a - b) }"
<     by (metis rot_same_dir(1) x1 x2)
<   finally have side2: "{y. (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0} = {y. 0 < (y - rp) \<bullet> rot (a - b) }"
<     (is "_ = ?upper1") .
<   from linepath_ball_inside_outside[OF \<open>simple_path J\<close>[unfolded J_def J2_def] *,
<       folded J2_def J_def, unfolded side1 side2]
<   obtain e where e0: "0 < e"
<     "ball rp e \<inter> path_image J1 = {}"
<     "ball rp e \<inter> ?lower1 \<subseteq> inner \<and>
<         ball rp e \<inter> ?upper1 \<subseteq> outer \<or>
<         ball rp e \<inter> ?upper1 \<subseteq> inner \<and>
<         ball rp e \<inter> ?lower1 \<subseteq> outer"
<     by (auto simp: inner_def outer_def)
< 
<   let ?lower = "{y. 0 > (y - rp) \<bullet> rot n }"
<   let ?upper = "{y. 0 < (y - rp) \<bullet> rot n }"
<   have "?lower1 = {y. 0 < (y - rp) \<bullet> rot n } \<and> ?upper1 = {y. 0 > (y - rp) \<bullet> rot n } \<or>
<       ?lower1 = {y. 0 > (y - rp) \<bullet> rot n } \<and> ?upper1 =  {y. 0 < (y - rp) \<bullet> rot n }"
<     using n rot_diff_commute[of a b]
<     by auto
<   from this e0 have e: "0 < e"
<     "ball rp e \<inter> path_image J1 = {}"
<     "ball rp e \<inter> ?lower \<subseteq> inner \<and>
<         ball rp e \<inter> ?upper \<subseteq> outer \<or>
<         ball rp e \<inter> ?upper \<subseteq> inner \<and>
<         ball rp e \<inter> ?lower \<subseteq> outer"
<     by auto
< 
<   have "\<forall>\<^sub>F t in at_right 0. t < d"
<     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
<   then have evr: "\<forall>\<^sub>F t in at_right 0. 0 < (flow0 rp t - rp) \<bullet> rot n"
<     unfolding eventually_at_filter
<     by eventually_elim (auto intro!: \<open>rp \<in> {a--b}\<close> d_above)
<   have "\<forall>\<^sub>F t in at_left 0. t > -d"
<     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
<   then have evl: "\<forall>\<^sub>F t in at_left 0. 0 > (flow0 rp t - rp) \<bullet> rot n"
<     unfolding eventually_at_filter
<     by eventually_elim (auto intro!: \<open>rp \<in> {a--b}\<close> d_below)
<   have "\<forall>\<^sub>F t in at 0. flow0 rp t \<in> ball rp e"
<     unfolding mem_ball
<     apply (subst dist_commute)
<     apply (rule tendstoD)
<     by (auto intro!: tendsto_eq_intros \<open>0 < e\<close>)
<   then have evl2: "(\<forall>\<^sub>F t in at_left 0. flow0 rp t \<in> ball rp e)"
<     and evr2: "(\<forall>\<^sub>F t in at_right 0. flow0 rp t \<in> ball rp e)"
<     unfolding eventually_at_split by auto
<   have evl3: "(\<forall>\<^sub>F t in at_left 0. t > -d)"
<     and evr3: "(\<forall>\<^sub>F t in at_right 0. t < d)"
<     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
<   have evl4: "(\<forall>\<^sub>F t in at_left 0. t < 0)"
<     and evr4: "(\<forall>\<^sub>F t in at_right 0. t > 0)"
<     by (auto simp: eventually_at_filter)
<   from evl evl2 evl3 evl4
<   have "\<forall>\<^sub>F t in at_left 0. (flow0 rp t - rp) \<bullet> rot n < 0 \<and> flow0 rp t \<in> ball rp e \<and> t > -d \<and> t < 0"
<     by eventually_elim auto
<   from eventually_happens[OF this]
<   obtain dl where dl: "(flow0 rp dl - rp) \<bullet> rot n < 0" "flow0 rp dl \<in> ball rp e" "- d < dl" "dl < 0"
<     by auto
<   from evr evr2 evr3 evr4
<   have "\<forall>\<^sub>F t in at_right 0. (flow0 rp t - rp) \<bullet> rot n > 0 \<and> flow0 rp t \<in> ball rp e \<and> t < d \<and> t > 0"
<     by eventually_elim auto
<   from eventually_happens[OF this]
<   obtain dr where dr: "(flow0 rp dr - rp) \<bullet> rot n > 0" "flow0 rp dr \<in> ball rp e" "d > dr" "dr > 0"
<     by auto
< 
<   have "rp \<in> {flow0 x t1<--<b}" using rpi subr by auto
<   then have rpr1:"flow0 rp (dr) \<in> r1" unfolding r1_def using \<open>d > dr\<close> \<open>dr > 0\<close>
<     by auto
<   have "rp \<in> {a<--<flow0 x t2}" using rpi subl by auto
<   then have rpr2:"flow0 rp (dl) \<in> r2" unfolding r2_def using \<open>-d < dl\<close> \<open>dl < 0\<close>
<     by auto
< 
<   from e(3) dr dl
<   have "flow0 rp (dr) \<in> outer \<and> flow0 rp (dl) \<in> inner \<or> flow0 rp (dr) \<in> inner \<and> flow0 rp (dl) \<in> outer"
<     by auto
<   moreover {
<     assume "flow0 rp dr \<in> outer" "flow0 rp dl \<in> inner"
<     then have
<       r1o: "r1 \<inter> outer \<noteq> {}" and
<       r2i: "r2 \<inter> inner \<noteq> {}" using rpr1 rpr2 by auto
<     from path_connected_not_frontier_subset[OF pcr1 r1o]
<     have "r1 \<subseteq> outer" using pir1 by (simp add: io(12))
<     from path_connected_not_frontier_subset[OF pcr2 r2i]
<     have "r2 \<subseteq> inner" using pir2 by (simp add: io(11))
<     have "(\<lambda>(x, y). flow0 x y)`({flow0 x t2} \<times> {0<..<d}) \<subseteq> r1" unfolding r1_def
<       by (auto intro!:image_mono simp add: x2)
<     then have *:"\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 (flow0 x t2) t \<in> outer"
<       by (smt \<open>r1 \<subseteq> outer\<close> greaterThanLessThan_iff mem_Sigma_iff pair_imageI r1_def subset_eq x2)
< 
<     then have t2o: "\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 x (t2 + t) \<in> outer"
<       using r1a3[OF x2] exist flow_trans
<       by (metis (no_types, hide_lams) closed_segment_commute ends_in_segment(1) local.existence_ivl_trans' local.flow_undefined0 real_Icc_closed_segment subset_eq \<open>t1 \<le> t2\<close>)
< 
< (* Construct a sequence of times converging to these points in r2 \<subseteq> inner *)
<     have inner: "{a <--< flow0 x t2} \<subseteq> closure inner"
<     proof (rule subsetI)
<       fix y
<       assume y: "y \<in> {a <--< flow0 x t2}"
<       have [simp]: "y \<in> X"
<         using y suba12_open suba2o \<open>{a -- b} \<subseteq> X\<close>
<         by auto
<       have "(\<forall>n. flow0 y (- d / real (Suc (Suc n))) \<in> inner)"
<         using y
<         using suba12_open \<open>0 < d\<close> suba2o \<open>{a -- b} \<subseteq> X\<close>
<         by (auto intro!: set_mp[OF \<open>r2 \<subseteq> inner\<close>] image_eqI[where x="(y, -d/Suc (Suc n))" for n]
<             simp: r2_def divide_simps) 
<       moreover
<       have d_over_0: "(\<lambda>s. - d / real (Suc (Suc s))) \<longlonglongrightarrow> 0"
<         by (rule real_tendsto_divide_at_top)
<           (auto intro!: filterlim_tendsto_add_at_top filterlim_real_sequentially)
<       have "(\<lambda>n. flow0 y (- d / real (Suc (Suc n)))) \<longlonglongrightarrow> y"
<         apply (rule tendsto_eq_intros)
<            apply (rule tendsto_intros)
<           apply (rule d_over_0)
<         by auto
<       ultimately show "y \<in> closure inner"
<         unfolding closure_sequential
<         by (intro exI[where x="\<lambda>n. flow0 y (-d/Suc (Suc n))"]) (rule conjI)
<     qed
<     then have "{a <--< flow0 x t1} \<subseteq> closure inner"
<       using suba12_open by blast
<     then have "{flow0 x t1 -- flow0 x t2} \<subseteq> closure inner"
<       by (metis (no_types, lifting) closure_closure closure_mono closure_open_segment dual_order.trans inner subl x1neqx2)
<     have outer:"\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> outer"
<     proof (rule ccontr)
<       fix t
<       assume t: "t > t2" "t \<in> existence_ivl0 x" "flow0 x t \<notin> outer"
<       have "0 \<le> t- (t2+d)" using t2o t  by smt 
<       then have a2:"0 \<le> t - (t2+dr)" using d \<open>0 < dr\<close> \<open>dr < d\<close> by linarith
<       have t2d2_ex: "t2 + dr \<in> existence_ivl0 x"
<         using \<open>t1 \<le> t2\<close> exist d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a--b}\<close> \<open>0 < d\<close> \<open>0 < dr\<close> \<open>dr < d\<close> 
<         by (intro existence_ivl_trans) auto
<       then have a3: "t - (t2 + dr) \<in> existence_ivl0 (flow0 x (t2 + dr))"
<         using t(2)
<         by (intro diff_existence_ivl_trans) auto
<       then have "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) = flow0 x t"
<         by (subst flow_trans[symmetric]) (auto simp: t2d2_ex)
<       moreover have "flow0 x t \<in> closure inner" using t(3) io
<         by (metis ComplI Un_iff closure_Un_frontier)
<       ultimately have a4: "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) \<in> closure inner" by auto
<       have a1: "flow0 x (t2+dr) \<in> outer"
<         by (simp add: d t2o \<open>0 < dr\<close> \<open>dr < d\<close>)
<       from outside_in[OF a1 a2 a3 a4]
<       obtain T where T: "T > 0" "T \<le> t - (t2 + dr)"
<         "(\<forall>s\<in>{0..<T}. flow0 (flow0 x (t2 + dr)) s \<in> outer)"
<         "flow0 (flow0 x (t2 + dr)) T \<in> {flow0 x t1 --< flow0 x t2}" by blast
<       define y where "y = flow0 (flow0 x (t2 + dr)) T"
<       have "y \<in> {a <--< flow0 x t2}" unfolding y_def using T(4)
<         using subl2 by blast 
<       then have "(\<lambda>(x, y). flow0 x y)`({y} \<times> {-d<..<0}) \<subseteq> r2" unfolding r2_def
<         by (auto intro!:image_mono)
<       then have *:"\<And>t. -d < t \<Longrightarrow> t < 0 \<Longrightarrow> flow0 y t \<in> r2"
<         by (simp add: pair_imageI subsetD)
<       have "max (-T/2) dl < 0" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
<       moreover have "-d < max (-T/2) dl" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
<       ultimately have inner: "flow0 y (max (-T/2) dl) \<in> inner" using * \<open>r2 \<subseteq> inner\<close> by blast 
<       have "0\<le>(T+(max (-T/2) dl))" using T(1) by linarith
<       moreover have "(T+(max (-T/2) dl)) < T" using T(1) d \<open>0 > dl\<close> \<open>dl > -d\<close> by linarith
<       ultimately have outer: " flow0 (flow0 x (t2 + dr)) (T+(max (-T/2) dl)) \<in> outer"
<         using T by auto
<       have T_ex: "T \<in> existence_ivl0 (flow0 x (t2 + dr))"
<         apply (subst flow_trans)
<         using exist \<open>t1 \<le> t2\<close>
<         using d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a -- b}\<close> \<open>d > 0\<close> T \<open>0 < dr\<close> \<open>dr < d\<close>
<           apply (auto simp: )
<         apply (rule set_rev_mp[where A="{0 .. t - (t2 + dr)}"], force)
<         apply (rule ivl_subset_existence_ivl)
<         apply (rule existence_ivl_trans')
<          apply (rule existence_ivl_trans')
<         by (auto simp: t)
<       have T_ex2: "dr + T \<in> existence_ivl0 (flow0 x t2)"
<         by (smt T_ex ends_in_segment(2) exist local.existence_ivl_trans local.existence_ivl_trans' real_Icc_closed_segment subset_eq t2d2_ex \<open>t1 \<le> t2\<close>)
<       thus False using T \<open>t1 \<le> t2\<close> exist
<         by (smt T_ex diff_existence_ivl_trans disjoint_iff_not_equal inner io(9) local.flow_trans local.flow_undefined0 outer y_def)
<     qed
<     have "closure inner \<inter> outer = {}"
<       by (simp add: inf_sup_aci(1) io(5) io(9) open_Int_closure_eq_empty) 
<     then have "flow0 x t \<notin> {a<--<flow0 x t2}"
<       using \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close> inner outer by blast
<   }
<   moreover {
<     assume "flow0 rp dr \<in> inner" "flow0 rp dl \<in> outer"
<     then have
<       r1i: "r1 \<inter> inner \<noteq> {}" and
<       r2o: "r2 \<inter> outer \<noteq> {}" using rpr1 rpr2 by auto
<     from path_connected_not_frontier_subset[OF pcr1 r1i]
<     have "r1 \<subseteq> inner" using pir1 by (simp add: io(11))
<     from path_connected_not_frontier_subset[OF pcr2 r2o]
<     have "r2 \<subseteq> outer" using pir2 by (simp add: io(12))
< 
<     have "(\<lambda>(x, y). flow0 x y)`({flow0 x t2} \<times> {0<..<d}) \<subseteq> r1" unfolding r1_def
<       by (auto intro!:image_mono simp add: x2)
<     then have
<       *:"\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 (flow0 x t2) t \<in> inner"
<       by (smt \<open>r1 \<subseteq> inner\<close> greaterThanLessThan_iff mem_Sigma_iff pair_imageI r1_def subset_eq x2)
< 
<     then have t2o: "\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 x (t2 + t) \<in> inner"
<       using r1a3[OF x2] exist flow_trans
<       by (metis (no_types, hide_lams) closed_segment_commute ends_in_segment(1) local.existence_ivl_trans' local.flow_undefined0 real_Icc_closed_segment subset_eq \<open>t1 \<le> t2\<close>)
< 
< (* Construct a sequence of times converging to these points in r2 \<subseteq> outer *)
<     have outer: "{a <--< flow0 x t2} \<subseteq> closure outer"
<     proof (rule subsetI)
<       fix y
<       assume y: "y \<in> {a <--< flow0 x t2}"
<       have [simp]: "y \<in> X"
<         using y suba12_open suba2o \<open>{a -- b} \<subseteq> X\<close>
<         by auto
<       have "(\<forall>n. flow0 y (- d / real (Suc (Suc n))) \<in> outer)"
<         using y
<         using suba12_open \<open>0 < d\<close> suba2o \<open>{a -- b} \<subseteq> X\<close>
<         by (auto intro!: set_mp[OF \<open>r2 \<subseteq> outer\<close>] image_eqI[where x="(y, -d/Suc (Suc n))" for n]
<             simp: r2_def divide_simps) 
<       moreover
<       have d_over_0: "(\<lambda>s. - d / real (Suc (Suc s))) \<longlonglongrightarrow> 0"
<         by (rule real_tendsto_divide_at_top)
<           (auto intro!: filterlim_tendsto_add_at_top filterlim_real_sequentially)
<       have "(\<lambda>n. flow0 y (- d / real (Suc (Suc n)))) \<longlonglongrightarrow> y"
<         apply (rule tendsto_eq_intros)
<            apply (rule tendsto_intros)
<           apply (rule d_over_0)
<         by auto
<       ultimately show "y \<in> closure outer"
<         unfolding closure_sequential
<         by (intro exI[where x="\<lambda>n. flow0 y (-d/Suc (Suc n))"]) (rule conjI)
<     qed
<     then have "{a <--< flow0 x t1} \<subseteq> closure outer"
<       using suba12_open by blast
<     then have "{flow0 x t1 -- flow0 x t2} \<subseteq> closure outer"
<       by (metis (no_types, lifting) closure_closure closure_mono closure_open_segment dual_order.trans outer subl x1neqx2)
< 
<     have inner:"\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> inner"
<     proof (rule ccontr)
<       fix t
<       assume t: "t > t2" "t \<in> existence_ivl0 x" "flow0 x t \<notin> inner"
<       have "0 \<le> t- (t2+d)" using t2o t by smt 
<       then have a2:"0 \<le> t - (t2+dr)" using d \<open>0 < dr\<close> \<open>dr < d\<close> by linarith
<       have t2d2_ex: "t2 + dr \<in> existence_ivl0 x"
<         using \<open>t1 \<le> t2\<close> exist d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a--b}\<close> \<open>0 < d\<close> \<open>0 < dr\<close> \<open>dr < d\<close> 
<         by (intro existence_ivl_trans) auto
<       then have a3: "t - (t2 + dr) \<in> existence_ivl0 (flow0 x (t2 + dr))"
<         using t(2)
<         by (intro diff_existence_ivl_trans) auto
<       then have "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) = flow0 x t"
<         by (subst flow_trans[symmetric]) (auto simp: t2d2_ex)
<       moreover have "flow0 x t \<in> closure outer" using t(3) io
<         by (metis ComplI Un_iff closure_Un_frontier)
<       ultimately have a4: "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) \<in> closure outer" by auto
<       have a1: "flow0 x (t2+dr) \<in> inner"
<         by (simp add: d t2o \<open>0 < dr\<close> \<open>dr < d\<close>)
<       from inside_out[OF a1 a2 a3 a4]
<       obtain T where T: "T > 0" "T \<le> t - (t2 + dr)"
<         "(\<forall>s\<in>{0..<T}. flow0 (flow0 x (t2 + dr)) s \<in> inner)"
<         "flow0 (flow0 x (t2 + dr)) T \<in> {flow0 x t1 --< flow0 x t2}" by blast
<       define y where "y = flow0 (flow0 x (t2 + dr)) T"
<       have "y \<in> {a <--< flow0 x t2}" unfolding y_def using T(4)
<         using subl2 by blast 
<       then have "(\<lambda>(x, y). flow0 x y)`({y} \<times> {-d<..<0}) \<subseteq> r2" unfolding r2_def
<         by (auto intro!:image_mono)
<       then have *:"\<And>t. -d < t \<Longrightarrow> t < 0 \<Longrightarrow> flow0 y t \<in> r2"
<         by (simp add: pair_imageI subsetD)
<       have "max (-T/2) dl < 0" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
<       moreover have "-d < max (-T/2) dl" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
<       ultimately have outer: "flow0 y (max (-T/2) dl) \<in> outer" using * \<open>r2 \<subseteq> outer\<close> by blast 
<       have "0\<le>(T+(max (-T/2) dl))" using T(1) by linarith
<       moreover have "(T+(max (-T/2) dl)) < T" using T(1) d \<open>0 > dl\<close> \<open>dl > -d\<close> by linarith
<       ultimately have inner: " flow0 (flow0 x (t2 + dr)) (T+(max (-T/2) dl)) \<in> inner"
<         using T by auto
<       have T_ex: "T \<in> existence_ivl0 (flow0 x (t2 + dr))"
<         apply (subst flow_trans)
<         using exist \<open>t1 \<le> t2\<close>
<         using d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a -- b}\<close> \<open>d > 0\<close> T \<open>0 < dr\<close> \<open>dr < d\<close>
<           apply (auto simp: )
<         apply (rule set_rev_mp[where A="{0 .. t - (t2 + dr)}"], force)
<         apply (rule ivl_subset_existence_ivl)
<         apply (rule existence_ivl_trans')
<          apply (rule existence_ivl_trans')
<         by (auto simp: t)
<       have T_ex2: "dr + T \<in> existence_ivl0 (flow0 x t2)"
<         by (smt T_ex ends_in_segment(2) exist local.existence_ivl_trans local.existence_ivl_trans' real_Icc_closed_segment subset_eq t2d2_ex \<open>t1 \<le> t2\<close>)
<       thus False using T \<open>t1 \<le> t2\<close> exist
<         by (smt T_ex diff_existence_ivl_trans disjoint_iff_not_equal inner io(9) local.flow_trans local.flow_undefined0 outer y_def)
<     qed
<     have "closure outer \<inter> inner = {}"
<       by (metis inf_sup_aci(1) io(2) io2(1) open_Int_closure_eq_empty)
<     then have "flow0 x t \<notin> {a<--<flow0 x t2}"
<       using \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close> inner outer by blast
<   }
<   ultimately show
<     "flow0 x t \<notin> {a<--<flow0 x t2}" by auto
< qed
< 
< lemma open_segment_trichotomy:
<   fixes x y a b::'a
<   assumes x:"x \<in> {a<--<b}"
<   assumes y:"y \<in> {a<--<b}"
<   shows "x = y \<or> y \<in> {x<--<b} \<or> y \<in> {a<--<x}"
< proof -
<   from Un_open_segment[OF y]
<   have "{a<--<y} \<union> {y} \<union> {y<--<b} = {a<--<b}" .
<   then have "x \<in> {a<--<y} \<or> x = y \<or> x \<in> {y <--<b}" using x by blast
<   moreover {
<     assume "x \<in> {a<--<y}"
<     then have "y \<in> {x<--<b}" using open_segment_subsegment
<       using open_segment_commute y by blast
<   }
<   moreover {
<     assume "x \<in> {y<--<b}"
<     from open_segment_subsegment[OF y this]
<     have "y \<in> {a<--<x}" .
<   }
<   ultimately show ?thesis by blast
< qed
< 
< sublocale rev: c1_on_open_R2 "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
<   by unfold_locales (auto simp: dim2)
< 
< lemma rev_transversal_segment: "rev.transversal_segment a b = transversal_segment a b"
<   by (auto simp: transversal_segment_def rev.transversal_segment_def)
< 
< lemma flow0_transversal_segment_monotone_step_reverse:
<   assumes "transversal_segment a b"
<   assumes "t1 \<le> t2"
<   assumes "{t1..t2} \<subseteq> existence_ivl0 x"
<   assumes x1: "flow0 x t1 \<in> {a<--<b}"
<   assumes x2: "flow0 x t2 \<in> {a<--<flow0 x t1}"
<   assumes "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
<   assumes "t < t1" "t \<in> existence_ivl0 x"
<   shows "flow0 x t \<notin> {a<--<flow0 x t1}"
< proof -
<   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
<   note t1t2 = \<open>\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}\<close>
<   from \<open>transversal_segment a b\<close> have [simp]: "a \<noteq> b" by (simp add: transversal_segment_def)
<   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
<     by (auto simp: in_open_segment_iff_line)
<   from x2 obtain i2 where i2: "flow0 x t2 = line a b i2" "0 < i2" "i2 < i1"
<     by (auto simp: i1 open_segment_line_iff)
< 
<   have t2_exist[simp]: "t2 \<in> existence_ivl0 x"
<     using \<open>t1 \<le> t2\<close> exist by auto
<   have t2_mem: "flow0 x t2 \<in> {a<--<b}"
<     and x1_mem: "flow0 x t1 \<in> {flow0 x t2<--<b}"
<     using i1 i2
<     by (auto simp: line_in_subsegment line_line1)
< 
<   have transversal': "rev.transversal_segment a b"
<     using \<open>transversal_segment a b\<close> unfolding rev_transversal_segment .
<   have time': "0 \<le> t2 - t1" using \<open>t1 \<le> t2\<close> by simp
<   have [simp, intro]: "flow0 x t2 \<in> X"
<     using exist \<open>t1 \<le> t2\<close>
<     by auto
<   have exivl': "{0..t2 - t1} \<subseteq> rev.existence_ivl0 (flow0 x t2)"
<     using exist \<open>t1 \<le> t2\<close>
<     by (force simp add: rev_existence_ivl_eq0 intro!: existence_ivl_trans')
<   have step': "rev.flow0 (flow0 x t2) (t2-t) \<notin>  {a<--<rev.flow0 (flow0 x t2) (t2 - t1)}"
<     apply (rule rev.flow0_transversal_segment_monotone_step[OF transversal' time' exivl'])
<     using exist \<open>t1 \<le> t2\<close> x1 x2 t2_mem x1_mem t1t2 \<open>t < t1\<close> \<open>t \<in> existence_ivl0 x\<close>
<         apply (auto simp: rev_existence_ivl_eq0 rev_eq_flow existence_ivl_trans' flow_trans[symmetric])
<     by (subst (asm) flow_trans[symmetric]) (auto intro!: existence_ivl_trans')
<   then show ?thesis
<     unfolding rev_eq_flow
<     using \<open>t1 \<le> t2\<close> exist \<open>t < t1\<close> \<open>t \<in> existence_ivl0 x\<close>
<     by (auto simp: flow_trans[symmetric] existence_ivl_trans')
< qed
< 
< lemma flow0_transversal_segment_monotone_step_reverse2:
<   assumes transversal: "transversal_segment a b"
<   assumes time: "t1 \<le> t2"
<   assumes exist: "{t1..t2} \<subseteq> existence_ivl0 x"
<   assumes t1: "flow0 x t1 \<in> {a<--<b}"
<   assumes t2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
<   assumes t1t2: "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
<   assumes t: "t < t1" "t \<in> existence_ivl0 x"
<   shows "flow0 x t \<notin> {flow0 x t1<--<b}"
<   using flow0_transversal_segment_monotone_step_reverse[of b a, OF _ time exist, of t]
<     assms
<   by (auto simp: open_segment_commute transversal_segment_commute)
< 
< lemma flow0_transversal_segment_monotone_step2:
<   assumes transversal: "transversal_segment a b"
<   assumes time: "t1 \<le> t2"
<   assumes exist: "{t1..t2} \<subseteq> existence_ivl0 x"
<   assumes t1: "flow0 x t1 \<in> {a<--<b}"
<   assumes t2: "flow0 x t2 \<in> {a<--<flow0 x t1}"
<   assumes t1t2: "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
<   shows "\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<notin> {flow0 x t2<--<b}"
<   using flow0_transversal_segment_monotone_step[of b a, OF _ time exist]
<     assms
<   by (auto simp: transversal_segment_commute open_segment_commute)
< 
< lemma flow0_transversal_segment_monotone:
<   assumes "transversal_segment a b"
<   assumes "t1 \<le> t2"
<   assumes "{t1..t2} \<subseteq> existence_ivl0 x"
<   assumes x1: "flow0 x t1 \<in> {a<--<b}"
<   assumes x2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
<   assumes "t > t2" "t \<in> existence_ivl0 x"
<   shows "flow0 x t \<notin> {a<--<flow0 x t2}"
< proof -
<   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
<   note t = \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close>
<   have x1neqx2: "flow0 x t1 \<noteq> flow0 x t2"
<     using open_segment_def x2 by force 
<   then have t1neqt2: "t1 \<noteq> t2" by auto
<   with \<open>t1 \<le> t2\<close> have "t1 < t2" by simp
< 
<   from \<open>transversal_segment a b\<close> have [simp]: "a \<noteq> b" by (simp add: transversal_segment_def)
<   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
<     by (auto simp: in_open_segment_iff_line)
<   from x2 i1 obtain i2 where i2: "flow0 x t2 = line a b i2" "i1 < i2" "i2 < 1"
<     by (auto simp: line_open_segment_iff)
<   have t2_in: "flow0 x t2 \<in> {a<--<b}"
<     using i1 i2
<     by simp
< 
<   let ?T = "{s \<in> {t1..t2}. flow0 x s \<in> {a--b}}"
<   let ?T' = "{s \<in> {t1..<t2}. flow0 x s \<in> {a<--<b}}"
<   from flow_transversal_segment_finite_intersections[OF \<open>transversal_segment a b\<close> \<open>t1 \<le> t2\<close> exist]
<   have "finite ?T" .
<   then have "finite ?T'" by (rule finite_subset[rotated]) (auto simp: open_closed_segment)
<   have "?T' \<noteq> {}"
<     by (auto intro!: exI[where x=t1] \<open>t1 < t2\<close> x1)
<   note tm_defined = \<open>finite ?T'\<close> \<open>?T' \<noteq> {}\<close>
<   define tm where "tm = Max ?T'"
<   have "tm \<in> ?T'"
<     unfolding tm_def
<     using tm_defined by (rule Max_in)
<   have tm_in: "flow0 x tm \<in> {a<--<b}"
<     using \<open>tm \<in> ?T'\<close>
<     by auto
<   have tm: "t1 \<le> tm" "tm < t2" "tm \<le> t2"
<     using \<open>tm \<in> ?T'\<close> by auto
<   have tm_Max: "t \<le> tm" if "t \<in> ?T'" for t
<     unfolding tm_def
<     using tm_defined(1) that
<     by (rule Max_ge)
< 
<   have tm_exclude: "flow0 x t \<notin> {a<--<b}" if "t \<in> {tm<..<t2}" for t
<     using \<open>tm \<in> ?T'\<close> tm_Max that
<     by auto (meson approximation_preproc_push_neg(2) dual_order.strict_trans2 le_cases)
<   have "{tm..t2} \<subseteq> existence_ivl0 x"
<     using exist tm by auto
< 
<   from open_segment_trichotomy[OF tm_in t2_in]
<   consider
<     "flow0 x t2 \<in> {flow0 x tm<--<b}" |
<     "flow0 x t2 \<in> {a<--<flow0 x tm}" |
<     "flow0 x tm = flow0 x t2"
<     by blast
<   then show "flow0 x t \<notin> {a<--<flow0 x t2}"
<   proof cases
<     case 1
<     from flow0_transversal_segment_monotone_step[OF \<open>transversal_segment a b\<close> \<open>tm \<le> t2\<close>
<         \<open>{tm..t2} \<subseteq> existence_ivl0 x\<close> tm_in 1 tm_exclude t]
<     show ?thesis .
<   next
<     case 2
<     have "t1 \<noteq> tm"
<       using 2 x2 i1 i2
<       by (auto simp: line_in_subsegment line_in_subsegment2)
<     then have "t1 < tm" using \<open>t1 \<le> tm\<close> by simp
<     from flow0_transversal_segment_monotone_step_reverse[OF \<open>transversal_segment a b\<close> \<open>tm \<le> t2\<close>
<         \<open>{tm..t2} \<subseteq> existence_ivl0 x\<close> tm_in 2 tm_exclude \<open>t1 < tm\<close>] exist \<open>t1 \<le> t2\<close>
<     have "flow0 x t1 \<notin> {a<--<flow0 x tm}" by auto
<     then have False
<       using x1 x2 2 i1 i2
<       apply (auto simp: line_in_subsegment line_in_subsegment2)
<       by (smt greaterThanLessThan_iff in_open_segment_iff_line line_in_subsegment2 tm_in)
<     then show ?thesis by simp
<   next
<     case 3
<     have "t1 \<noteq> tm"
<       using 3 x2
<       by (auto simp: open_segment_def)
<     then have "t1 < tm" using \<open>t1 \<le> tm\<close> by simp
<     have "range (flow0 x) = flow0 x ` {tm..t2}"
<       apply (rule recurrence_time_restricts_compact_flow'[OF \<open>tm < t2\<close> _ _ 3])
<       using exist \<open>t1 \<le> t2\<close> \<open>t1 < tm\<close> \<open>tm < t2\<close>
<       by auto
<     also have "\<dots> = flow0 x ` (insert t2 {tm<..<t2})"
<       using \<open>tm \<le> t2\<close> 3
<       apply (auto simp: )
<       by (smt greaterThanLessThan_iff image_eqI)
<     finally have "flow0 x t1 \<in> flow0 x ` (insert t2 {tm<..<t2})"
<       by auto
<     then have "flow0 x t1 \<in> flow0 x ` {tm<..<t2}" using x1neqx2
<       by auto
<     moreover have "\<dots> \<inter> {a<--<b} = {}"
<       using tm_exclude
<       by auto
<     ultimately have False using x1 by auto
<     then show ?thesis by blast
<   qed
< qed
< 
< subsection \<open>Straightening\<close>
< 
< text \<open> This lemma uses the implicit function theorem \<close>
< lemma cross_time_continuous:
<   assumes "transversal_segment a b"
<   assumes "x \<in> {a<--<b}"
<   assumes "e > 0"
<   obtains d t where "d > 0" "continuous_on (ball x d) t"
<     "\<And>y. y \<in> ball x d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b}"
<     "\<And>y. y \<in> ball x d \<Longrightarrow> \<bar>t y\<bar> < e"
<     "continuous_on (ball x d) t"
<     "t x = 0"
< proof -
<   have "x \<in> X" using assms segment_open_subset_closed[of a b]
<     by (auto simp: transversal_segment_def)
<   have "a \<noteq> b" using assms by auto
<   define s where "s x = (x - a) \<bullet> rot (b - a)" for x
<   have "s x = 0"
<     unfolding s_def
<     by (subst in_segment_inner_rot) (auto intro!: assms open_closed_segment)
<   have Ds: "(s has_derivative blinfun_inner_left (rot (b - a))) (at x)"
<     (is "(_ has_derivative blinfun_apply (?Ds x)) _")
<     for x
<     unfolding s_def
<     by (auto intro!: derivative_eq_intros)
<   have Dsc: "isCont ?Ds x" by (auto intro!: continuous_intros)
<   have nz: "?Ds x (f x) \<noteq> 0"
<     using assms  apply auto
<     unfolding transversal_segment_def
<     by (smt inner_minus_left nrm_reverse open_closed_segment)
< 
<   from flow_implicit_function_at[OF \<open>x \<in> X\<close>, of s, OF \<open>s x = 0\<close> Ds Dsc nz \<open>e > 0\<close>]
<   obtain t d1 where "0 < d1"
<     and t0: "t x = 0"
<     and d1: "(\<And>y. y \<in> cball x d1 \<Longrightarrow> s (flow0 y (t y)) = 0)"
<     "(\<And>y. y \<in> cball x d1 \<Longrightarrow> \<bar>t y\<bar> < e)"
<     "(\<And>y. y \<in> cball x d1 \<Longrightarrow> t y \<in> existence_ivl0 y)"
<     and tc: "continuous_on (cball x d1) t"
<     and t': "(t has_derivative
<         (- blinfun_inner_left (rot (b - a)) /\<^sub>R (blinfun_inner_left (rot (b - a))) (f x)))
<       (at x)"
<     by metis
<   from tc
<   have "t \<midarrow>x\<rightarrow> 0"
<     using \<open>0 < d1\<close>
<     by (auto simp: continuous_on_def at_within_interior t0 dest!: bspec[where x=x])
<   then have ftc: "((\<lambda>y. flow0 y (t y)) \<longlongrightarrow> x) (at x)"
<     by (auto intro!: tendsto_eq_intros simp: \<open>x \<in> X\<close>)
< 
< 
< 
<   define e2 where "e2 = min (dist a x) (dist b x)"
<   have "e2 > 0"
<     using assms
<     by (auto simp: e2_def open_segment_def)
< 
<   from tendstoD[OF ftc this] have "\<forall>\<^sub>F y in at x. dist (flow0 y (t y)) x < e2" .
<   moreover
<   let ?S = "{x. a \<bullet> (b - a) < x \<bullet> (b - a) \<and> x \<bullet> (b - a) < b \<bullet> (b - a)}"
<   have "open ?S" "x \<in> ?S"
<     using \<open>x \<in> {a<--<b}\<close>
<     by (auto simp add: open_segment_line_hyperplanes \<open>a \<noteq> b\<close>
<         intro!: open_Collect_conj open_halfspace_component_gt open_halfspace_component_lt)
<   from topological_tendstoD[OF ftc this] have "\<forall>\<^sub>F y in at x. flow0 y (t y) \<in> ?S" .
<   ultimately
<   have "\<forall>\<^sub>F y in at x. flow0 y (t y) \<in> ball x e2 \<inter> ?S" by eventually_elim (auto simp: dist_commute)
<   then obtain d2 where "0 < d2" and "\<And>y. x \<noteq> y \<Longrightarrow> dist y x < d2 \<Longrightarrow> flow0 y (t y) \<in> ball x e2 \<inter> ?S"
<     by (force simp: eventually_at)
<   then have d2: "dist y x < d2 \<Longrightarrow> flow0 y (t y) \<in> ball x e2 \<inter> ?S" for y
<     using \<open>0 < e2\<close> \<open>x \<in> X\<close> t0 \<open>x \<in> ?S\<close>
<     by (cases "y = x") auto
< 
<   define d where "d = min d1 d2"
<   have "d > 0" using \<open>0 < d1\<close> \<open>0 < d2\<close> by (simp add: d_def)
<   moreover have "continuous_on (ball x d) t"
<     by (auto intro!:continuous_on_subset[OF tc] simp add: d_def)
<   moreover
<   have "ball x e2 \<inter> ?S \<inter> {x. s x = 0} \<subseteq> {a<--<b}"
<     by (auto simp add: in_open_segment_iff_rot \<open>a \<noteq> b\<close>) (auto simp: s_def e2_def in_segment)
<   then have "\<And>y. y \<in> ball x d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b}"
<     apply (rule set_mp)
<     using d1 d2 \<open>0 < d2\<close>
<     by (auto simp: d_def e2_def dist_commute)
<   moreover have "\<And>y. y \<in> ball x d \<Longrightarrow> \<bar>t y\<bar> < e"
<     using d1 by (auto simp: d_def)
<   moreover have "continuous_on (ball x d) t"
<     using tc by (rule continuous_on_subset) (auto simp: d_def)
<   moreover have "t x = 0" by (simp add: t0)
<   ultimately show ?thesis ..
< qed
< 
< lemma \<omega>_limit_crossings:
<   assumes "transversal_segment a b"
<   assumes pos_ex: "{0..} \<subseteq> existence_ivl0 x"
<   assumes "\<omega>_limit_point x p"
<   assumes "p \<in> {a<--<b}"
<   obtains s where 
<     "s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b} \<and> s n \<in> existence_ivl0 x"
< proof -
<   from assms have "p \<in> X" by (auto simp: transversal_segment_def open_closed_segment)
<   from assms(3)
<   obtain t where
<     "t \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>" "(flow0 x \<circ> t) \<longlonglongrightarrow> p"
<     by (auto simp: \<omega>_limit_point_def)
<   note t = \<open>t \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>\<close> \<open>(flow0 x \<circ> t) \<longlonglongrightarrow> p\<close>
<   note [tendsto_intros] = t(2)
<   from cross_time_continuous[OF assms(1,4) zero_less_one\<comment> \<open>TODO ??\<close>]
<   obtain \<tau> \<delta>
<     where "0 < \<delta>" "continuous_on (ball p \<delta>) \<tau>" 
<       "\<tau> p = 0" "(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> \<bar>\<tau> y\<bar> < 1)"
<       "(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> flow0 y (\<tau> y) \<in> {a<--<b})"
<     by metis
<   note \<tau> =
<     \<open>(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> flow0 y (\<tau> y) \<in> {a<--<b})\<close>
<     \<open>(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> \<bar>\<tau> y\<bar> < 1)\<close>
<     \<open>continuous_on (ball p \<delta>) \<tau>\<close> \<open>\<tau> p = 0\<close>
<   define s where "s n = t n + \<tau> (flow0 x (t n))" for n
<   have ev_in_ball: "\<forall>\<^sub>F n in at_top. flow0 x (t n) \<in> ball p \<delta>"
<     apply (simp add: )
<     apply (subst dist_commute)
<     apply (rule tendstoD)
<      apply (rule t[unfolded o_def])
<     apply (rule \<open>0 < \<delta>\<close>)
<     done
<   have "filterlim s at_top sequentially"
<   proof (rule filterlim_at_top_mono)
<     show "filterlim (\<lambda>n. -1 + t n) at_top sequentially"
<       by (rule filterlim_tendsto_add_at_top) (auto intro!: filterlim_tendsto_add_at_top t)
<     from ev_in_ball show "\<forall>\<^sub>F x in sequentially. -1 + t x \<le> s x"
<       apply eventually_elim
<       using \<tau>
<       by (force simp : s_def)
<   qed
<   moreover
<   have \<tau>_cont: "\<tau> \<midarrow>p\<rightarrow> \<tau> p"
<     using \<tau>(3) \<open>0 < \<delta>\<close>
<     by (auto simp: continuous_on_def at_within_ball dest!: bspec[where x=p])
<   note [tendsto_intros] = tendsto_compose_at[OF _ this, simplified]
<   have ev1: "\<forall>\<^sub>F n in sequentially. t n > 1"
<     using filterlim_at_top_dense t(1) by auto
<   then have ev_eq: "\<forall>\<^sub>F n in sequentially. flow0 ((flow0 x o t) n) ((\<tau> o (flow0 x o t)) n) = (flow0 x o s) n"
<     using ev_in_ball
<     apply (eventually_elim)
<     apply (drule \<tau>(2))
<     unfolding o_def
<     apply (subst flow_trans[symmetric])
<     using pos_ex
<       apply (auto simp: s_def)
<     apply (rule existence_ivl_trans')
<     by auto
<   then
<   have "\<forall>\<^sub>F n in sequentially.
<   (flow0 x o s) n = flow0 ((flow0 x o t) n) ((\<tau> o (flow0 x o t)) n)"
<     by (simp add: eventually_mono)
<   from \<open>(flow0 x \<circ> t) \<longlonglongrightarrow> p\<close> and \<open>\<tau> \<midarrow>p\<rightarrow> \<tau> p\<close>
<   have
<     "(\<lambda>n. flow0 ((flow0 x \<circ> t) n) ((\<tau> \<circ> (flow0 x \<circ> t)) n))
<   \<longlonglongrightarrow>
<   flow0 p (\<tau> p)"
<     using \<open>\<tau> p = 0\<close> \<tau>_cont \<open>p \<in> X\<close>
<     by (intro tendsto_eq_intros) auto
<   with ev_eq have "(flow0 x o s) \<longlonglongrightarrow> flow0 p (\<tau> p)"
<     by (rule Lim_transform_eventually)
<   then have "(flow0 x o s) \<longlonglongrightarrow> p"
<     using \<open>p \<in> X\<close> \<open>\<tau> p = 0\<close>
<     by simp
<   moreover
<   {
<     have "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b}"
<       using ev_eq ev_in_ball
<       apply eventually_elim
<       apply (drule sym)
<       apply simp
<       apply (rule \<tau>) by simp
<     moreover have "\<forall>\<^sub>F n in sequentially. s n \<in> existence_ivl0 x"
<       using ev_in_ball ev1
<       apply (eventually_elim)
<       apply (drule \<tau>(2))
<       using pos_ex
<       by (auto simp: s_def)
<     ultimately have "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b} \<and> s n \<in> existence_ivl0 x"
<       by eventually_elim auto
<   }
<   ultimately show ?thesis ..
< qed
< 
< (* Obvious but frequently used step *)
< lemma filterlim_at_top_tendstoE:
<   assumes "e > 0"
<   assumes "filterlim s at_top sequentially"
<   assumes "(flow0 x \<circ> s) \<longlonglongrightarrow> u"
<   assumes "\<forall>\<^sub>F n in sequentially. P (s n)"
<   obtains m where "m > b" "P m" "dist (flow0 x m) u < e"
< proof -
<   from assms(2) have "\<forall>\<^sub>F n in sequentially. b < s n"
<     by (simp add: filterlim_at_top_dense)
<   moreover have "\<forall>\<^sub>F n in sequentially. norm ((flow0 x \<circ> s) n - u) < e"
<     using assms(3)[THEN tendstoD, OF assms(1)] by (simp add: dist_norm)
<   moreover note assms(4)
<   ultimately have "\<forall>\<^sub>F n in sequentially. b < s n \<and> norm ((flow0 x \<circ> s) n - u) < e \<and> P (s n)"
<     by eventually_elim auto
<   then obtain m where "m > b" "P m" "dist (flow0 x m) u < e"
<     by (auto simp add: eventually_sequentially dist_norm)
<   then show ?thesis ..
< qed
< 
< lemma open_segment_separate_left:
<   fixes u v x a b::'a
<   assumes u:"u \<in> {a <--< b}"
<   assumes v:"v \<in> {u <--< b}"
<   assumes x: "dist x u < dist u v" "x \<in> {a <--< b}"
<   shows "x \<in> {a <--< v}"
< proof -
<   have "v \<noteq> x"
<     by (smt dist_commute x(1)) 
<   moreover have "x \<notin> {v<--<b}"
<     by (smt dist_commute dist_in_open_segment open_segment_subsegment v x(1))
<   moreover have "v \<in> {a<--<b}" using v
<     by (metis ends_in_segment(1) segment_open_subset_closed subset_eq subset_segment(4) u)
<   ultimately show ?thesis using open_segment_trichotomy[OF _ x(2)]
<     by blast
< qed
< 
< lemma open_segment_separate_right:
<   fixes u v x a b::'a
<   assumes u:"u \<in> {a <--< b}"
<   assumes v:"v \<in> {a <--< u}"
<   assumes x: "dist x u < dist u v" "x \<in> {a <--< b}"
<   shows "x \<in> {v <--< b}"
< proof -
<   have "v \<noteq> x"
<     by (smt dist_commute x(1))
<   moreover have "x \<notin> {a<--<v}"
<     by (smt dist_commute dist_in_open_segment open_segment_commute open_segment_subsegment v x(1))
<   moreover have "v \<in> {a<--<b}" using v
<     by (metis ends_in_segment(1) segment_open_subset_closed subset_eq subset_segment(4) u)
<   ultimately show ?thesis using open_segment_trichotomy[OF _ x(2)]
<     by blast
< qed
< 
< lemma no_two_\<omega>_limit_points:
<   assumes transversal: "transversal_segment a b"
<   assumes ex_pos: "{0..} \<subseteq> existence_ivl0 x"
<   assumes u: "\<omega>_limit_point x u" "u \<in> {a<--<b}"
<   assumes v: "\<omega>_limit_point x v" "v \<in> {a<--<b}"
<   assumes uv: "v \<in> {u<--<b}"
<   shows False
< proof -
<   have unotv: "u \<noteq> v" using uv
<     using dist_in_open_segment by blast 
<   define duv where "duv = dist u v / 2"
<   have duv: "duv > 0" unfolding duv_def using unotv by simp
<   from \<omega>_limit_crossings[OF transversal ex_pos u]
<   obtain su where su: "filterlim su at_top sequentially"
<     "(flow0 x \<circ> su) \<longlonglongrightarrow> u"
<     "\<forall>\<^sub>F n in sequentially. flow0 x (su n) \<in> {a<--<b} \<and> su n \<in> existence_ivl0 x" by blast
<   from \<omega>_limit_crossings[OF transversal ex_pos v]
<   obtain sv where sv: "filterlim sv at_top sequentially"
<     "(flow0 x \<circ> sv) \<longlonglongrightarrow> v"
<     "\<forall>\<^sub>F n in sequentially. flow0 x (sv n) \<in> {a<--<b} \<and> sv n \<in> existence_ivl0 x" by blast
<   from filterlim_at_top_tendstoE[OF duv su]
<   obtain su1 where su1:"su1 > 0" "flow0 x su1 \<in> {a<--<b}"
<     "su1 \<in> existence_ivl0 x" "dist (flow0 x su1) u < duv" by auto
<   from filterlim_at_top_tendstoE[OF duv sv, of su1]
<   obtain su2 where su2:"su2 > su1" "flow0 x su2 \<in> {a<--<b}"
<     "su2 \<in> existence_ivl0 x" "dist (flow0 x su2) v < duv" by auto
<   from filterlim_at_top_tendstoE[OF duv su, of su2]
<   obtain su3 where su3:"su3 > su2" "flow0 x su3 \<in> {a<--<b}"
<     "su3 \<in> existence_ivl0 x" "dist (flow0 x su3) u < duv" by auto
<   have *: "su1 \<le> su2" "{su1..su2} \<subseteq> existence_ivl0 x" using su1 su2
<      apply linarith
<     by (metis atLeastatMost_empty_iff empty_iff mvar.closed_segment_subset_domain real_Icc_closed_segment su1(3) su2(3) subset_eq)
< 
< (* by construction *)
<   have d1: "dist (flow0 x su1) v \<ge> (dist u v)/2" using su1(4) duv unfolding duv_def
<     by (smt dist_triangle_half_r)
<   have "dist (flow0 x su1) u < dist u v" using su1(4) duv unfolding duv_def by linarith
<   from open_segment_separate_left[OF u(2) uv this su1(2)]
<   have su1l:"flow0 x su1 \<in> {a<--<v}" .
<   have "dist (flow0 x su2) v < dist v (flow0 x su1)" using d1
<     by (smt dist_commute duv_def su2(4))
<   from open_segment_separate_right[OF v(2) su1l this su2(2)]
<   have su2l:"flow0 x su2 \<in> {flow0 x su1<--<b}" .
<   then have su2ll:"flow0 x su2 \<in> {u<--<b}"
<     by (smt dist_commute dist_pos_lt duv_def open_segment_subsegment pos_half_less open_segment_separate_right su2(2) su2(4) u(2) uv v(2) unotv)
< 
<   have "dist (flow0 x su2) u \<ge> (dist u v)/2" using su2(4) duv unfolding duv_def
<     by (smt dist_triangle_half_r)
<   then have "dist (flow0 x su3) u < dist u (flow0 x su2)"
<     by (smt dist_commute duv_def su3(4)) 
<   from open_segment_separate_left[OF u(2) su2ll this su3(2)]
<   have su3l:"flow0 x su3 \<in> {a<--<flow0 x su2}" .
< 
<   from flow0_transversal_segment_monotone[OF transversal * su1(2) su2l su3(1) su3(3)]
<   have "flow0 x su3 \<notin> {a <--<flow0 x su2}" .
<   thus False using su3l by auto
< qed
< 
< 
< subsection \<open>Unique Intersection\<close>
< 
< text \<open>Perko Section 3.7 Remark 2\<close>
< lemma unique_transversal_segment_intersection:
<   assumes "transversal_segment a b"
<   assumes "{0..} \<subseteq> existence_ivl0 x"
<   assumes "u \<in> \<omega>_limit_set x \<inter> {a<--<b}"
<   shows "\<omega>_limit_set x \<inter> {a<--<b} = {u}"
< proof (rule ccontr)
<   assume "\<omega>_limit_set x \<inter> {a<--<b} \<noteq> {u}"
<   then
<   obtain v where uv: "u \<noteq> v"
<     and v: "\<omega>_limit_point x v" "v \<in> {a<--<b}" using assms unfolding \<omega>_limit_set_def
<     by fastforce
<   have u:"\<omega>_limit_point x u" "u \<in> {a<--<b}" using assms unfolding \<omega>_limit_set_def
<     by auto
<   show False using no_two_\<omega>_limit_points[OF \<open>transversal_segment a b\<close>]
<     by (smt dist_commute dist_in_open_segment open_segment_trichotomy u uv v assms)
< qed
< 
< text \<open>Adapted from Perko Section 3.7 Lemma 4 (+ Chicone )\<close>
< lemma periodic_imp_\<omega>_limit_set:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes "periodic_orbit y"
<     "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x"
<   shows "flow0 y `UNIV = \<omega>_limit_set x"
< proof (rule ccontr)
<   note y = \<open>periodic_orbit y\<close> \<open>flow0 y ` UNIV \<subseteq> \<omega>_limit_set x\<close>
<   from trapped_sol_right[OF assms(1-4)] 
<   have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
<   assume "flow0 y `UNIV \<noteq> \<omega>_limit_set x"
<   obtain p where p: "p \<in> \<omega>_limit_set x" "p \<notin> flow0 y ` UNIV"
<     using y(2) apply auto
<     using \<open>range (flow0 y) \<noteq> \<omega>_limit_set x\<close> by blast
<   from \<omega>_limit_set_in_compact_connected[OF assms(1-4)] have
<     wcon: "connected (\<omega>_limit_set x)" .
<   from \<omega>_limit_set_invariant have
<     "invariant (\<omega>_limit_set x)" .
<   from \<omega>_limit_set_in_compact_compact[OF assms(1-4)] have
<     "compact (\<omega>_limit_set x)" .
<   then have sc: "seq_compact (\<omega>_limit_set x)"
<     using compact_imp_seq_compact by blast
<   have y1:"closed (flow0 y ` UNIV)"
<     using closed_orbit_\<omega>_limit_set periodic_orbit_def \<omega>_limit_set_closed y(1) by auto
<   have y2: "flow0 y ` UNIV \<noteq> {}" by simp 
<   let ?py = "infdist p (range (flow0 y))"
<   have "0 < ?py"
<     using y1 y2 p(2)
<     by (rule infdist_pos_not_in_closed)
<   have "\<forall>n::nat. \<exists>z. z \<in> \<omega>_limit_set x - flow0 y ` UNIV \<and>
<     infdist z (flow0 y ` UNIV) < ?py/2^n"
<   proof (rule ccontr)
<     assume " \<not> (\<forall>n. \<exists>z. z \<in> \<omega>_limit_set x - range (flow0 y) \<and>
<                 infdist z (range (flow0 y))
<                 < infdist p (range (flow0 y)) / 2 ^ n) "
<     then obtain n where n: "(\<forall>z \<in> \<omega>_limit_set x - range (flow0 y).
<       infdist z (range (flow0 y)) \<ge> ?py / 2 ^ n)"
<       using not_less by blast
<     define A where "A = flow0 y ` UNIV"
<     define B where "B = {z. infdist z (range (flow0 y)) \<ge> ?py / 2 ^ n}"
<     have Ac:"closed A" unfolding A_def using y1 by auto
<     have Bc:"closed B" unfolding B_def using infdist_closed by auto
<     have "A \<inter> B = {}"
<     proof (rule ccontr)
<       assume "A \<inter> B \<noteq> {}"
<       then obtain q where q: "q \<in> A" "q \<in> B" by blast
<       have qz:"infdist q (range(flow0 y)) = 0" using q(1) unfolding A_def
<         by simp
<       note \<open>0 < ?py\<close>
<       moreover have "2 ^ n > (0::real)" by auto
<       ultimately have "infdist p (range (flow0 y)) / 2 ^ n > (0::real)"
<         by simp
<       then have qnz: "infdist q(range (flow0 y)) > 0" using q(2) unfolding B_def
<         by auto
<       show False using qz qnz by auto
<     qed
<     then have a1:"A \<inter> B \<inter> \<omega>_limit_set x = {}" by auto
<     have "\<omega>_limit_set x - range(flow0 y) \<subseteq> B" using n B_def by blast
<     then have a2:"\<omega>_limit_set x \<subseteq> A \<union> B" using A_def by auto
<     from connected_closedD[OF wcon a1 a2 Ac Bc]
<     have "A \<inter> \<omega>_limit_set x = {} \<or> B \<inter> \<omega>_limit_set x = {}" .
<     moreover {
<       assume "A \<inter> \<omega>_limit_set x = {}"
<       then have False unfolding A_def using y(2) by blast
<     }
<     moreover {
<       assume "B \<inter> \<omega>_limit_set x = {}"
<       then have False unfolding B_def using p
<         using A_def B_def a2 by blast
<     }
<     ultimately show False by blast
<   qed
<   then obtain s where s: "\<forall>n::nat. (s::nat \<Rightarrow> _) n \<in> \<omega>_limit_set x - flow0 y ` UNIV \<and>
<                       infdist (s n) (flow0 y ` UNIV) < ?py/2^n"
<     by metis
<   then have "\<forall>n. s n \<in> \<omega>_limit_set x" by blast
<   from seq_compactE[OF sc this]
<   obtain l r where lr: "l \<in> \<omega>_limit_set x" "strict_mono r" "(s \<circ> r) \<longlonglongrightarrow> l" by blast
<   have "\<And>n. infdist (s n) (range (flow0 y)) \<le> ?py / 2 ^ n" using s
<     using less_eq_real_def by blast
<   then have "\<And>n. norm(infdist (s n) (range (flow0 y))) \<le> ?py / 2 ^ n"
<     by (auto simp add: infdist_nonneg)
<   from LIMSEQ_norm_0_pow[OF \<open>0 < ?py\<close> _ this]
<   have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> s) \<longlonglongrightarrow> 0"
<     by (auto simp add:o_def)
<   from LIMSEQ_subseq_LIMSEQ[OF this lr(2)]
<   have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> (s \<circ> r)) \<longlonglongrightarrow> 0" by (simp add: o_assoc)
<   moreover have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> (s \<circ> r)) \<longlonglongrightarrow> infdist l (flow0 y ` UNIV)"
<     using continuous_on_sequentially lr(3) continuous_on_infdist
<     by blast
<   ultimately have "infdist l (flow0 y `UNIV) = 0" using LIMSEQ_unique by auto
<   then have lu: "l \<in> flow0 y ` UNIV" using in_closed_iff_infdist_zero[OF y1 y2] by auto
<   then have l1:"l \<in> X"
<     using closed_orbit_global_existence periodic_orbit_def y(1) by auto
<       (* TODO: factor out as periodic_orbitE *)
<   have l2:"f l \<noteq> 0"
<     by (smt \<open>l \<in> X\<close> \<open>l \<in> range (flow0 y)\<close> closed_orbit_global_existence fixed_point_imp_closed_orbit_period_zero(2) fixpoint_sol(2) image_iff local.flows_reverse periodic_orbit_def y(1))
<   from transversal_segment_exists[OF l1 l2]
<   obtain a b where ab: "transversal_segment a b" "l \<in> {a<--<b}" by blast
<   then have "l \<in> \<omega>_limit_set x \<inter> {a<--<b}" using lr by auto
<   from unique_transversal_segment_intersection[OF ab(1) ex_pos this]
<   have luniq: "\<omega>_limit_set x \<inter> {a<--<b} = {l} " .
<   from cross_time_continuous[OF ab, of 1]
<   obtain d t where dt: "0 < d"
<     "(\<And>y. y \<in> ball l d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b})"
<     "(\<And>y. y \<in> ball l d \<Longrightarrow> \<bar>t y\<bar> < 1)"
<     "continuous_on (ball l d) t" "t l = 0"
<     by auto
<   obtain n where "(s \<circ> r) n \<in> ball l d" using lr(3) dt(1) unfolding LIMSEQ_iff_nz
<     by (metis dist_commute mem_ball order_refl)
<   then have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> {a<--<b}" using dt by auto
<   moreover have sr: "(s \<circ> r) n \<in> \<omega>_limit_set x" "(s \<circ> r) n \<notin> flow0 y ` UNIV"
<     using s by auto
<   moreover have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> \<omega>_limit_set x"
<     using \<open>invariant (\<omega>_limit_set x)\<close> calculation unfolding invariant_def trapped_def
<     by (smt \<omega>_limit_set_in_compact_subset \<open>invariant (\<omega>_limit_set x)\<close> assms(1-4) invariant_def order_trans range_eqI subsetD trapped_iff_on_existence_ivl0 trapped_sol)
<   ultimately have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> \<omega>_limit_set x \<inter> {a<--<b}" by auto
<   from unique_transversal_segment_intersection[OF ab(1) ex_pos this]
<   have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) = l" using luniq by auto
<   then have "((s \<circ> r) n) = flow0 l (-(t ((s \<circ> r) n ))) "
<     by (smt UNIV_I \<open>(s \<circ> r) n \<in> \<omega>_limit_set x\<close> flows_reverse \<omega>_limit_set_in_compact_existence assms(1-4)) 
<   thus False using sr(2) lu
<       \<open>flow0 ((s \<circ> r) n) (t ((s \<circ> r) n)) = l\<close> \<open>flow0 ((s \<circ> r) n) (t ((s \<circ> r) n)) \<in> \<omega>_limit_set x\<close>
<       closed_orbit_global_existence image_iff local.flow_trans periodic_orbit_def \<omega>_limit_set_in_compact_existence range_eqI assms y(1)
<     by smt
< qed
< 
< end context c1_on_open_R2 begin
< 
< lemma \<alpha>_limit_crossings:
<   assumes "transversal_segment a b"
<   assumes pos_ex: "{..0} \<subseteq> existence_ivl0 x"
<   assumes "\<alpha>_limit_point x p"
<   assumes "p \<in> {a<--<b}"
<   obtains s where
<     "s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>"
<     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>\<^sub>F n in sequentially.
<     flow0 x (s n) \<in> {a<--<b} \<and>
<     s n \<in> existence_ivl0 x"
< proof -
<   from pos_ex have "{0..} \<subseteq> uminus ` existence_ivl0 x" by force
<   from rev.\<omega>_limit_crossings[unfolded rev_transversal_segment rev_existence_ivl_eq0 rev_eq_flow
<       \<alpha>_limit_point_eq_rev[symmetric], OF assms(1) this assms(3,4)]
<   obtain s where "filterlim s at_top sequentially" "((\<lambda>t. flow0 x (- t)) \<circ> s) \<longlonglongrightarrow> p"
<     "\<forall>\<^sub>F n in sequentially. flow0 x (- s n) \<in> {a<--<b} \<and> s n \<in> uminus ` existence_ivl0 x" .
<   then have "filterlim (-s) at_bot sequentially"
<     "(flow0 x \<circ> (-s)) \<longlonglongrightarrow> p"
<     "\<forall>\<^sub>F n in sequentially. flow0 x ((-s) n) \<in> {a<--<b} \<and> (-s) n \<in> existence_ivl0 x"
<     by (auto simp: fun_Compl_def o_def filterlim_uminus_at_top)
<   then show ?thesis ..
< qed
< 
< text \<open>If a positive limit point has a regular point in its positive limit set then it is periodic\<close>
< lemma \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes y: "y \<in> \<omega>_limit_set x" "f y \<noteq> 0"
<   assumes z: "z \<in> \<omega>_limit_set y \<union> \<alpha>_limit_set y" "f z \<noteq> 0"
<   shows "periodic_orbit y \<and> flow0 y ` UNIV = \<omega>_limit_set x"
< proof -
<   from trapped_sol_right[OF assms(1-4)] have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
<   from \<omega>_limit_set_in_compact_existence[OF assms(1-4) y(1)]
<   have yex: "existence_ivl0 y = UNIV" .
<   from \<omega>_limit_set_invariant
<   have "invariant (\<omega>_limit_set x)" .
<   then have yinv: "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x" using yex unfolding invariant_def
<     using trapped_iff_on_existence_ivl0 y(1) by blast 
< 
<   have zy: "\<omega>_limit_point y z \<or> \<alpha>_limit_point y z"
<     using z unfolding \<omega>_limit_set_def \<alpha>_limit_set_def by auto
< 
<   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
<     \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained[OF assms(1-4)]
<   have zx:"z \<in> \<omega>_limit_set x" using zy y
<     using z(1) by blast
<   then have "z \<in> X"
<     by (metis UNIV_I local.existence_ivl_initial_time_iff \<omega>_limit_set_in_compact_existence assms(1-4))
<   from transversal_segment_exists[OF this z(2)]
<   obtain a b where ab: "transversal_segment a b" "z \<in> {a<--<b}" by blast
< 
<   from zy
<   obtain t1 t2 where t1: "flow0 y t1 \<in> {a<--<b}" and t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
<   proof
<     assume zy: "\<omega>_limit_point y z"
<     from \<omega>_limit_crossings[OF ab(1) _ zy ab(2), unfolded yex]
<     obtain s where s: "filterlim s at_top sequentially"
<       "(flow0 y \<circ> s) \<longlonglongrightarrow> z"
<       "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b}"
<       by auto
<     from eventually_happens[OF this(3)] obtain t1 where t1: "flow0 y t1 \<in> {a<--<b}" by auto
<     have "\<forall>\<^sub>F n in sequentially. s n > t1"
<       using filterlim_at_top_dense s(1) by auto
<     with s(3) have "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b} \<and> s n > t1"
<       by eventually_elim simp
<     from eventually_happens[OF this] obtain t2 where t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
<       by auto
<     from t1 this show ?thesis ..
<   next
<     assume zy: "\<alpha>_limit_point y z"
<     from \<alpha>_limit_crossings[OF ab(1) _ zy ab(2), unfolded yex]
<     obtain s where s: "filterlim s at_bot sequentially"
<       "(flow0 y \<circ> s) \<longlonglongrightarrow> z"
<       "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b}"
<       by auto
<     from eventually_happens[OF this(3)] obtain t1 where t1: "flow0 y t1 \<in> {a<--<b}" by auto
<     have "\<forall>\<^sub>F n in sequentially. s n < t1"
<       using filterlim_at_bot_dense s(1) by auto
<     with s(3) have "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b} \<and> s n < t1"
<       by eventually_elim simp
<     from eventually_happens[OF this] obtain t2 where t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
<       by auto
<     from t1 this show ?thesis ..
<   qed
<   have "flow0 y t1 \<in> \<omega>_limit_set x \<inter> {a<--<b}" using t1 UNIV_I yinv by auto
<   moreover have "flow0 y t2 \<in> \<omega>_limit_set x \<inter> {a<--<b}" using t2 UNIV_I yinv by auto
<   ultimately have feq:"flow0 y t1 = flow0 y t2"
<     using unique_transversal_segment_intersection[OF \<open>transversal_segment a b\<close> ex_pos]
<     by blast
<   have "t1 \<noteq> t2" "t1 \<in> existence_ivl0 y" "t2 \<in> existence_ivl0 y" using \<open>t1 \<noteq>  t2\<close>
<       apply blast
<      apply (simp add: yex)
<     by (simp add: yex)
<   from periodic_orbitI[OF this feq y(2)]
<   have 1: "periodic_orbit y" .
<   from periodic_imp_\<omega>_limit_set[OF assms(1-4) this yinv]
<   have 2: "flow0 y` UNIV = \<omega>_limit_set x" .
<   show ?thesis using 1 2 by auto
< qed
< 
< subsection \<open>Poincare Bendixson Theorems\<close>
< text \<open>Perko Section 3.7 Theorem 1\<close>
< theorem poincare_bendixson:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes "0 \<notin> f ` (\<omega>_limit_set x)"
<   obtains y where "periodic_orbit y"
<     "flow0 y ` UNIV = \<omega>_limit_set x"
< proof -
<   note f = \<open>0 \<notin> f ` (\<omega>_limit_set x)\<close>
<   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-4)]
<   obtain y where y: "y \<in> \<omega>_limit_set x" by fastforce
<   from \<omega>_limit_set_in_compact_existence[OF  assms(1-4) y]
<   have yex: "existence_ivl0 y = UNIV" .
<   from \<omega>_limit_set_invariant
<   have "invariant (\<omega>_limit_set x)" .
<   then have yinv: "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x" using yex unfolding invariant_def
<     using trapped_iff_on_existence_ivl0 y by blast
<   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
<   have "\<omega>_limit_set x \<subseteq> K" .
<   then have "flow0 y ` UNIV \<subseteq> K" using yinv by auto
<   then have yk:"trapped_forward y K"
<     by (simp add: image_subsetI range_subsetD trapped_forward_def)
<   have "y \<in> X"
<     by (simp add: local.mem_existence_ivl_iv_defined(2) yex)
< 
<   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-2) this _]
<   obtain z where z: "z \<in> \<omega>_limit_set y" using yk by blast
<   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
<   have zx:"z \<in> \<omega>_limit_set x" using \<open>z \<in> \<omega>_limit_set y\<close> y by auto
< 
<   have yreg : "f y \<noteq> 0" using f y
<     by (metis rev_image_eqI)
<   have zreg : "f z \<noteq> 0" using f zx
<     by (metis rev_image_eqI) 
<   from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) y yreg _ zreg] z
<   show ?thesis using that by blast
< qed
< 
< lemma fixed_point_in_\<omega>_limit_set_imp_\<omega>_limit_set_singleton_fixed_point:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes fp: "yfp \<in> \<omega>_limit_set x" "f yfp = 0"
<   assumes zpx: "z \<in> \<omega>_limit_set x"
<   assumes finite_fp: "finite {y \<in> K. f y = 0}" (is "finite ?S")
<   shows "(\<exists>p1 \<in> \<omega>_limit_set x. f p1 = 0 \<and> \<omega>_limit_set z = {p1}) \<and>
<     (\<exists>p2 \<in> \<omega>_limit_set x. f p2 = 0 \<and> \<alpha>_limit_set z = {p2})"
< proof -
<   let ?weq = "{y \<in> \<omega>_limit_set x. f y = 0}"
<   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
<   have wxK: "\<omega>_limit_set x \<subseteq> K" .
<   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
<   have zx: "\<omega>_limit_set z \<subseteq> \<omega>_limit_set x" using zpx by auto
<   have zX: "z \<in> X" using subset_trans[OF wxK assms(2)]
<     by (metis subset_iff zpx)
<   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
<   have "?weq \<subseteq> ?S"
<     by (smt Collect_mono_iff Int_iff inf.absorb_iff1)
<   then have "finite ?weq" using \<open>finite ?S\<close>
<     by (blast intro: rev_finite_subset) 
< 
<   consider "f z = 0" | "f z \<noteq> 0" by auto
<   then show ?thesis
<   proof cases
<     assume "f z = 0"
<     from fixed_point_imp_\<omega>_limit_set[OF zX this]
<       fixed_point_imp_\<alpha>_limit_set[OF zX this]
<     show ?thesis
<       by (metis (mono_tags) \<open>f z = 0\<close> zpx)
<   next
<     assume "f z \<noteq> 0"
<     have zweq: "\<omega>_limit_set z \<subseteq> ?weq"
<       apply clarsimp
<     proof (rule ccontr)
<       fix k assume k: "k \<in> \<omega>_limit_set z" "\<not> (k \<in> \<omega>_limit_set x \<and> f k = 0)"
<       then have "f k \<noteq> 0" using zx k by auto
<       from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) zpx \<open>f z \<noteq> 0\<close> _ this] k(1)
<       have "periodic_orbit z" "range(flow0 z) = \<omega>_limit_set x" by auto
<       then have "0 \<notin> f ` (\<omega>_limit_set x)"
<         by (metis image_iff periodic_orbit_imp_flow0_regular)
<       thus False using fp
<         by (metis (mono_tags, lifting) empty_Collect_eq image_eqI)
<     qed
<     have zweq0: "\<alpha>_limit_set z \<subseteq> ?weq"
<       apply clarsimp
<     proof (rule ccontr)
<       fix k assume k: "k \<in> \<alpha>_limit_set z" "\<not> (k \<in> \<omega>_limit_set x \<and> f k = 0)"
<       then have "f k \<noteq> 0" using zx k
<           \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained[OF assms(1-4), of z] zpx
<         by auto
<       from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) zpx \<open>f z \<noteq> 0\<close> _ this] k(1)
<       have "periodic_orbit z" "range(flow0 z) = \<omega>_limit_set x" by auto
<       then have "0 \<notin> f ` (\<omega>_limit_set x)"
<         by (metis image_iff periodic_orbit_imp_flow0_regular)
<       thus False using fp
<         by (metis (mono_tags, lifting) empty_Collect_eq image_eqI)
<     qed
<     from \<omega>_limit_set_in_compact_existence[OF assms(1-4) zpx]
<     have zex: "existence_ivl0 z = UNIV" .
<     from \<omega>_limit_set_invariant
<     have "invariant (\<omega>_limit_set x)" .
<     then have zinv: "flow0 z ` UNIV \<subseteq> \<omega>_limit_set x" using zex unfolding invariant_def
<       using trapped_iff_on_existence_ivl0 zpx by blast
<     then have "flow0 z ` UNIV \<subseteq> K" using wxK by auto
<     then have a2: "trapped_forward z K" "trapped_backward z K"
<       using trapped_def trapped_iff_on_existence_ivl0 apply fastforce
<       using \<open>range (flow0 z) \<subseteq> K\<close> trapped_def trapped_iff_on_existence_ivl0 by blast
<     have a3: "finite (\<omega>_limit_set z)"
<       by (metis \<open>finite ?weq\<close> finite_subset zweq)
<     from finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-2) zX a2(1) a3]
<     obtain p1 where p1: "\<omega>_limit_set z = {p1}" "f p1 = 0" by blast
<     then have "p1 \<in> ?weq" using zweq by blast
<     moreover
<     have "finite (\<alpha>_limit_set z)"
<       by (metis \<open>finite ?weq\<close> finite_subset zweq0)
<     from finite_\<alpha>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-2) zX a2(2) this]
<     obtain p2 where p2: "\<alpha>_limit_set z = {p2}" "f p2 = 0" by blast
<     then have "p2 \<in> ?weq" using zweq0 by blast
<     ultimately show ?thesis
<       by (simp add: p1 p2)
<   qed
< qed
< 
< end context c1_on_open_R2 begin
< 
< text \<open>Perko Section 3.7 Theorem 2\<close>
< theorem poincare_bendixson_general:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> X" "trapped_forward x K"
<   assumes "S = {y \<in> K. f y = 0}" "finite S"
<   shows
<     "(\<exists>y \<in> S. \<omega>_limit_set x = {y}) \<or>
<   (\<exists>y. periodic_orbit y \<and>
<     flow0 y ` UNIV = \<omega>_limit_set x) \<or>
<   (\<exists>P R. \<omega>_limit_set x = P \<union> R \<and>
<     P \<subseteq> S \<and> 0 \<notin> f ` R \<and> R \<noteq> {} \<and>
<     (\<forall>z \<in> R.
<       (\<exists>p1 \<in> P. \<omega>_limit_set z = {p1}) \<and>
<       (\<exists>p2 \<in> P. \<alpha>_limit_set z = {p2})))"
< proof -
<   note S = \<open>S = {y \<in> K. f y = 0}\<close>
<   let ?wreg = "{y \<in> \<omega>_limit_set x. f y \<noteq> 0}"
<   let ?weq = "{y \<in> \<omega>_limit_set x. f y = 0}"
<   have wreqweq: "?wreg \<union> ?weq = \<omega>_limit_set x"
<     by (smt Collect_cong Collect_disj_eq mem_Collect_eq \<omega>_limit_set_def)
< 
<   from trapped_sol_right[OF assms(1-4)] have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
<   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
<   have wxK: "\<omega>_limit_set x \<subseteq> K" .
<   then have "?weq \<subseteq> S" using S
<     by (smt Collect_mono_iff Int_iff inf.absorb_iff1)
<   then have "finite ?weq" using \<open>finite S\<close>
<     by (metis rev_finite_subset) 
<   from \<omega>_limit_set_invariant
<   have xinv: "invariant (\<omega>_limit_set x)" .
< 
<   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-4)] wreqweq
<   consider "?wreg = {}" |
<     "?weq = {}" |
<     "?weq \<noteq> {}" "?wreg \<noteq> {}" by auto
<   then show ?thesis
<   proof cases
<     (* If w has no regular points then it is equal to a single unique fixed point *)
<     assume "?wreg = {}"
<     then have "finite (\<omega>_limit_set x)"
<       by (metis (mono_tags, lifting) \<open>{y \<in> \<omega>_limit_set x. f y = 0} \<subseteq> S\<close> \<open>finite S\<close> rev_finite_subset sup_bot.left_neutral wreqweq)
<     from finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-4) this]
<     obtain y where y: "\<omega>_limit_set x = {y}" "f y = 0" by blast
<     then have "y \<in> S"
<       by (metis Un_empty_left \<open>?weq \<subseteq> S\<close> \<open>?wreg = {}\<close> insert_subset wreqweq)
<     then show ?thesis using y by auto
<   next
<     (* If w has no fixed points, then the Poincare Bendixson theorem applies *)
<     assume "?weq = {}"
<     then have " 0 \<notin> f ` \<omega>_limit_set x"
<       by (smt empty_Collect_eq imageE)
<     from poincare_bendixson[OF assms(1-4) this]
<     have "(\<exists>y. periodic_orbit y \<and> flow0 y ` UNIV = \<omega>_limit_set x)"
<       by metis
<     then show ?thesis by blast
<   next
<     (* Otherwise, all points in the limit set converge to a finite subset of the fixed points *)
<     assume "?weq \<noteq> {}" "?wreg \<noteq> {}"
<     then obtain yfp where yfp: "yfp \<in> \<omega>_limit_set x" "f yfp = 0" by auto
<     have "0 \<notin> f ` ?wreg" by auto
<     have "(\<exists>p1\<in>\<omega>_limit_set x. f p1 = 0 \<and> \<omega>_limit_set z = {p1}) \<and>
<       (\<exists>p2\<in>\<omega>_limit_set x. f p2 = 0 \<and> \<alpha>_limit_set z = {p2})"
<       if zpx: "z \<in> \<omega>_limit_set x" for z
<       using fixed_point_in_\<omega>_limit_set_imp_\<omega>_limit_set_singleton_fixed_point[
<           OF assms(1-4) yfp zpx \<open>finite S\<close>[unfolded S]] by auto
<     then have "\<omega>_limit_set x = ?weq \<union> ?wreg \<and>
<         ?weq \<subseteq> S \<and> 0 \<notin> f ` ?wreg \<and> ?wreg \<noteq> {} \<and>
<         (\<forall>z \<in> ?wreg.
<          (\<exists>p1 \<in> ?weq. \<omega>_limit_set z = {p1}) \<and>
<          (\<exists>p2 \<in> ?weq. \<alpha>_limit_set z = {p2}))"
<       using wreqweq \<open>?weq \<subseteq> S\<close> \<open>?wreg \<noteq> {}\<close> \<open>0 \<notin> f ` ?wreg\<close>
<       by blast
<     then show ?thesis by blast
<   qed
< qed
< 
< corollary poincare_bendixson_applied:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "K \<noteq> {}" "positively_invariant K"
<   assumes "0 \<notin> f ` K"
<   obtains y where "periodic_orbit y" "flow0 y ` UNIV \<subseteq> K"
< proof -
<   from assms(1-4) obtain x where "x \<in> K" "x \<in> X" by auto
<   have *: "trapped_forward x K"
<     using assms(4) \<open>x \<in> K\<close>
<     by (auto simp: positively_invariant_def)
<   have subs: "\<omega>_limit_set x \<subseteq> K"
<     by (rule \<omega>_limit_set_in_compact_subset[OF assms(1-2) \<open>x \<in> X\<close> *])
<   with assms(5) have "0 \<notin> f ` \<omega>_limit_set x" by auto
<   from poincare_bendixson[OF assms(1-2) \<open>x \<in> X\<close> * this]
<   obtain y where "periodic_orbit y" "range (flow0 y) = \<omega>_limit_set x"
<     by force
<   then have "periodic_orbit y" "flow0 y ` UNIV \<subseteq> K" using subs by auto
<   then show ?thesis ..
< qed
< 
< (*
<   Limit cycles are periodic orbits that is the \<omega> (or \<alpha>)-limit set of some point not in the cycle.
<   As with periodic_orbit, limit_cycles are defined for a representative point y
< *)
< definition "limit_cycle y \<longleftrightarrow>
<   periodic_orbit y \<and>
<   (\<exists>x. x \<notin> flow0 y ` UNIV \<and>
<   (flow0 y ` UNIV = \<omega>_limit_set x \<or> flow0 y ` UNIV = \<alpha>_limit_set x))"
< 
< corollary poincare_bendixson_limit_cycle:
<   assumes "compact K" "K \<subseteq> X"
<   assumes "x \<in> K" "positively_invariant K"
<   assumes "0 \<notin> f ` K"
<   assumes "rev.flow0 x t \<notin> K"
<   obtains y where "limit_cycle y" "flow0 y ` UNIV \<subseteq> K"
< proof -
<   have "x \<in> X" using assms(2-3) by blast
<   have *: "trapped_forward x K"
<     using assms(3-4)
<     by (auto simp: positively_invariant_def)
<   have subs: "\<omega>_limit_set x \<subseteq> K"
<     by (rule \<omega>_limit_set_in_compact_subset[OF assms(1-2) \<open>x \<in> X\<close> *])
<   with assms(5) have "0 \<notin> f ` \<omega>_limit_set x" by auto
<   from poincare_bendixson[OF assms(1-2) \<open>x \<in> X\<close> * this]
<   obtain y where y: "periodic_orbit y" "range (flow0 y) = \<omega>_limit_set x"
<     by force
<   then have c2: "flow0 y ` UNIV \<subseteq> K" using subs by auto
<   have exy: "existence_ivl0 y = UNIV"
<     using closed_orbit_global_existence periodic_orbit_def y(1) by blast
<   have "x \<notin> flow0 y ` UNIV"
<   proof clarsimp
<     fix tt
<     assume "x = flow0 y tt"
<     then have "rev.flow0 (flow0 y tt) t \<notin> K" using assms(6) by auto
<     moreover have "rev.flow0 (flow0 y tt) t \<in> flow0 y ` UNIV" using exy unfolding rev_eq_flow
<       using UNIV_I \<open>x = flow0 y tt\<close> closed_orbit_\<omega>_limit_set closed_orbit_flow0 periodic_orbit_def y by auto
<     ultimately show False using c2 by blast
<   qed
<   then have "limit_cycle y" "flow0 y ` UNIV \<subseteq> K" using y c2 unfolding limit_cycle_def by auto
<   then show ?thesis ..
< qed
< 
< end
< 
< end
---
> section \<open>Poincare Bendixson Theory\<close>
> theory Poincare_Bendixson
>   imports 
>     Ordinary_Differential_Equations.ODE_Analysis
>     Analysis_Misc ODE_Misc Periodic_Orbit
> begin
> 
> 
> subsection \<open>Flow to Path\<close>
> 
> context auto_ll_on_open begin
> 
> (* The path along the flow starting at time t to time t' *)
> definition "flow_to_path x t t' = flow0 x \<circ> linepath t t'"
> 
> lemma pathstart_flow_to_path[simp]:
>   shows "pathstart (flow_to_path x t t') = flow0 x t"
>   unfolding flow_to_path_def
>   by (auto simp add: pathstart_compose)
> 
> lemma pathfinish_flow_to_path[simp]:
>   shows "pathfinish (flow_to_path x t t') = flow0 x t'"
>   unfolding flow_to_path_def
>   by (auto simp add: pathfinish_compose)
> 
> lemma flow_to_path_unfold:
>   shows "flow_to_path x t t' s = flow0 x ((1 - s) * t + s * t')"
>   unfolding flow_to_path_def o_def linepath_def by auto
> 
> lemma subpath0_flow_to_path:
>   shows "(subpath 0 u (flow_to_path x t t')) = flow_to_path x t (t + u*(t'-t))"
>   unfolding flow_to_path_def subpath_image subpath0_linepath
>   by auto
> 
> lemma path_image_flow_to_path[simp]:
>   assumes "t \<le> t'"
>   shows "path_image (flow_to_path x t t') = flow0 x ` {t..t'}"
>   unfolding flow_to_path_def path_image_compose path_image_linepath
>   using assms real_Icc_closed_segment by auto
> 
> lemma flow_to_path_image0_right_open[simp]:
>   assumes "t < t'"
>   shows "flow_to_path x t t' ` {0..<1} = flow0 x `{t..<t'}"
>   unfolding flow_to_path_def image_comp[symmetric] linepath_image0_right_open_real[OF assms]
>   by auto
> 
> lemma flow_to_path_path:
>   assumes "t \<le> t'"
>   assumes "{t..t'} \<subseteq> existence_ivl0 x"
>   shows "path (flow_to_path x t t')"
> proof -
>   have "x \<in> X"
>     using assms(1) assms(2) subset_empty by fastforce
>   have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow>  (1 - xa) * t + xa * t' \<le> t'"
>     by (simp add: assms(1) convex_bound_le)
>   moreover have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow> t \<le> (1 - xa) * t + xa * t'" using assms(1)
>     by (metis add.commute add_diff_cancel_left' diff_diff_eq2 diff_le_eq mult.commute mult.right_neutral mult_right_mono right_diff_distrib')
>   ultimately have "\<And>xa. 0 \<le> xa \<Longrightarrow> xa \<le> 1 \<Longrightarrow> (1 - xa) * t + xa * t' \<in> existence_ivl0 x"
>     using assms(2) by auto
>   thus ?thesis unfolding path_def flow_to_path_def linepath_def
>     by (auto intro!:continuous_intros simp add :\<open>x \<in> X\<close>)
> qed
> 
> lemma flow_to_path_arc:
>   assumes "t \<le> t'"
>   assumes "{t..t'} \<subseteq> existence_ivl0 x"
>   assumes "\<forall>s \<in> {t<..<t'}. flow0 x s \<noteq> flow0 x t"
>   assumes "flow0 x t \<noteq> flow0 x t'"
>   shows "arc (flow_to_path x t t')"
>   unfolding arc_def
> proof safe
>   from flow_to_path_path[OF assms(1-2)]
>   show "path (flow_to_path x t t')" .
> next
>   show "inj_on (flow_to_path x t t') {0..1}"
>     unfolding flow_to_path_def
>     apply (rule comp_inj_on)
>      apply (metis assms(4) inj_on_linepath)
>     using assms path_image_linepath[of t t'] apply (auto intro!:flow0_inj_on)
>     using flow0_inj_on greaterThanLessThan_iff linepath_image_01 real_Icc_closed_segment by fastforce
> qed
> 
> end
> 
> locale c1_on_open_R2 = c1_on_open_euclidean f f' X for f::"'a::executable_euclidean_space \<Rightarrow> _" and f' and X +
>   assumes dim2: "DIM('a) = 2"
> begin
> 
> 
> subsection \<open>2D Line segments\<close>
> 
> text \<open>Line segments are specified by two endpoints
>       The closed line segment from x to y is given by the set {x--y}
>       and {x<--<y} for the open segment\<close>
> 
> text \<open> Rotates a vector clockwise 90 degrees \<close>
> definition "rot (v::'a) = (eucl_of_list [nth_eucl v 1, -nth_eucl v 0]::'a)"
> 
> lemma exhaust2_nat: "(\<forall>i<(2::nat). P i) \<longleftrightarrow> P 0 \<and> P 1"
>   using less_2_cases by auto
> lemma sum2_nat: "(\<Sum>i<(2::nat). P i) = P 0 + P 1"
>   by (simp add: eval_nat_numeral)
> 
> lemmas vec_simps =
>   eucl_eq_iff[where 'a='a] dim2 eucl_of_list_eucl_nth exhaust2_nat
>   plus_nth_eucl
>   minus_nth_eucl
>   uminus_nth_eucl
>   scaleR_nth_eucl
>   inner_nth_eucl
>   sum2_nat
>   algebra_simps
> 
> lemma minus_expand:
>   shows "(x::'a)-y = (eucl_of_list [x$\<^sub>e0 - y$\<^sub>e0, x$\<^sub>e1 - y$\<^sub>e1])"
>   by (simp add:vec_simps)
> 
> lemma dot_ortho[simp]: "x \<bullet> rot x = 0"
>   unfolding rot_def minus_expand
>   by (simp add: vec_simps)
> 
> lemma nrm_dot:
>   shows "((x::'a)-y) \<bullet> (rot (x-y)) = 0"
>   unfolding rot_def minus_expand
>   by (simp add: vec_simps)
> 
> lemma nrm_reverse: "a \<bullet> (rot (x-y)) = - a \<bullet> (rot (y-x))" for x y::'a
>   unfolding rot_def
>   by (simp add:vec_simps)
> 
> lemma norm_rot: "norm (rot v) = norm v" for v::'a
>   unfolding rot_def
>   by (simp add:vec_simps norm_nth_eucl L2_set_def)
> 
> lemma rot_rot[simp]:
>   shows "rot (rot v) = -v"
>   unfolding rot_def
>   by (simp add:vec_simps)
> 
> lemma rot_scaleR[simp]:
>   shows "rot ( u *\<^sub>R v) =  u *\<^sub>R (rot v)"
>   unfolding rot_def
>   by (simp add:vec_simps)
> 
> lemma rot_0[simp]: "rot 0 = 0"
>   using rot_scaleR[of 0] by simp
> 
> lemma rot_eq_0_iff[simp]: "rot x = 0 \<longleftrightarrow> x = 0"
>   apply (auto simp: rot_def)
>    apply (metis One_nat_def norm_eq_zero norm_rot norm_zero rot_def)
>   using rot_0 rot_def by auto
> 
> lemma in_segment_inner_rot:
>   "(x - a) \<bullet> rot (b - a) = 0"
>   if "x \<in> {a--b}"
> proof -
>   from that obtain u where x: "x = a + u *\<^sub>R (b - a)" "0 \<le> u" "u \<le> 1"
>     by (auto simp: in_segment algebra_simps)
>   show ?thesis
>     unfolding x
>     by (simp add: inner_add_left nrm_dot)
> qed
> 
> lemma inner_rot_in_segment:
>   "x \<in> range (\<lambda>u. a + u *\<^sub>R (b - a))"
>   if "(x - a) \<bullet> rot (b - a) = 0" "a \<noteq> b"
> proof -
>   from that have
>     x0: "b $\<^sub>e 0 = a $\<^sub>e 0 \<Longrightarrow> x $\<^sub>e 0 =
>       (a $\<^sub>e 0 * b $\<^sub>e Suc 0 - b $\<^sub>e 0 * a $\<^sub>e Suc 0 + (b $\<^sub>e 0 - a $\<^sub>e 0) * x $\<^sub>e Suc 0) /
>       (b $\<^sub>e Suc 0 - a $\<^sub>e Suc 0)"
>     and x1: "b $\<^sub>e 0 \<noteq> a $\<^sub>e 0 \<Longrightarrow> x $\<^sub>e Suc 0 =
>       ((b $\<^sub>e Suc 0 - a $\<^sub>e Suc 0) * x $\<^sub>e 0 - a $\<^sub>e 0 * b $\<^sub>e Suc 0 + b $\<^sub>e 0 * a $\<^sub>e Suc 0) / (b $\<^sub>e 0 - a $\<^sub>e 0)"
>     by (auto simp: rot_def vec_simps divide_simps)
>   define u where "u = (if b $\<^sub>e 0 - a $\<^sub>e 0 \<noteq> 0
>     then ((x $\<^sub>e 0 - a $\<^sub>e 0) / (b $\<^sub>e 0 -  a $\<^sub>e 0))
>     else ((x $\<^sub>e 1 - a $\<^sub>e 1) / (b $\<^sub>e 1 -  a $\<^sub>e 1)))
>     "
>   show ?thesis
>     apply (cases "b $\<^sub>e 0 - a $\<^sub>e 0 = 0")
>     subgoal
>       using that(2)
>       apply (auto intro!: image_eqI[where x="((x $\<^sub>e 1 - a $\<^sub>e 1) / (b $\<^sub>e 1 -  a $\<^sub>e 1))"]
>           simp: vec_simps x0 divide_simps algebra_simps)
>        apply (metis ab_semigroup_mult_class.mult_ac(1) mult.commute sum_sqs_eq)
>       by (metis mult.commute mult.left_commute sum_sqs_eq)
>     subgoal
>       apply (auto intro!: image_eqI[where x="((x $\<^sub>e 0 - a $\<^sub>e 0) / (b $\<^sub>e 0 -  a $\<^sub>e 0))"]
>           simp: vec_simps x1 divide_simps algebra_simps)
>        apply (metis ab_semigroup_mult_class.mult_ac(1) mult.commute sum_sqs_eq)
>       by (metis mult.commute mult.left_commute sum_sqs_eq)
>     done
> qed
> 
> lemma in_open_segment_iff_rot:
>   "x \<in> {a<--<b} \<longleftrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) <..< b \<bullet> (b - a)}"
>   if "a \<noteq> b"
>   unfolding open_segment_line_hyperplanes[OF that]
>   by (auto simp: nrm_dot intro!: inner_rot_in_segment)
> 
> lemma in_open_segment_rotD:
>   "x \<in> {a<--<b} \<Longrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) <..< b \<bullet> (b - a)}"
>   by (subst in_open_segment_iff_rot[symmetric]) auto
> 
> lemma in_closed_segment_iff_rot:
>   "x \<in> {a--b} \<longleftrightarrow> (x - a) \<bullet> rot (b - a) = 0 \<and> x \<bullet> (b - a) \<in> {a\<bullet>(b - a) .. b \<bullet> (b - a)}"
>   if "a \<noteq> b"
>   unfolding closed_segment_line_hyperplanes[OF that] using that
>   by (auto simp: nrm_dot intro!: inner_rot_in_segment)
> 
> lemma in_segment_inner_rot2:
>   "(x - y) \<bullet> rot (a - b) = 0"
>   if "x \<in> {a--b}" "y \<in> {a--b}"
> proof -
>   from that obtain u where x: "x = a + u *\<^sub>R (b - a)" "0 \<le> u" "u \<le> 1"
>     by (auto simp: in_segment algebra_simps)
>   from that obtain v where y: "y = a + v *\<^sub>R (b - a)" "0 \<le> v" "v \<le> 1"
>     by (auto simp: in_segment algebra_simps)
>   show ?thesis
>     unfolding x y
>     apply (auto simp: inner_add_left )
>     by (smt add_diff_cancel_left' in_segment_inner_rot inner_diff_left minus_diff_eq nrm_reverse that(1) that(2) x(1) y(1))
> qed
> 
> lemma closed_segment_surface:
>   "a \<noteq> b \<Longrightarrow> {a--b} = { x \<in> {x. x \<bullet> (b - a) \<in> {a\<bullet>(b - a) .. b \<bullet> (b - a)}}. (x - a) \<bullet> rot (b - a) = 0}"
>   by (auto simp: in_closed_segment_iff_rot)
> 
> lemma rot_diff_commute: "rot (b - a) = -rot(a - b)"
>   apply (auto simp: rot_def algebra_simps)
>   by (metis One_nat_def minus_diff_eq rot_def rot_rot)
> 
> 
> subsection \<open>Bijection Real-Complex for Jordan Curve Theorem\<close>
> 
> definition "complex_of (x::'a) = x$\<^sub>e0 + \<i> * x$\<^sub>e1"
> 
> definition "real_of (x::complex) = (eucl_of_list [Re x, Im x]::'a)"
> 
> lemma complex_of_linear:
>   shows "linear complex_of"
>   unfolding complex_of_def
>   apply (auto intro!:linearI simp add: distrib_left plus_nth_eucl)
>   by (simp add: of_real_def scaleR_add_right scaleR_nth_eucl)
> 
> lemma complex_of_bounded_linear:
>   shows "bounded_linear complex_of"
>   unfolding complex_of_def
>   apply (auto intro!:bounded_linearI' simp add: distrib_left plus_nth_eucl)
>   by (simp add: of_real_def scaleR_add_right scaleR_nth_eucl)
> 
> lemma real_of_linear:
>   shows "linear real_of"
>   unfolding real_of_def
>   by (auto intro!:linearI simp add: vec_simps)
> 
> lemma real_of_bounded_linear:
>   shows "bounded_linear real_of"
>   unfolding real_of_def
>   by (auto intro!:bounded_linearI' simp add: vec_simps)
> 
> lemma complex_of_real_of:
>   "(complex_of \<circ> real_of) = id"
>   unfolding complex_of_def real_of_def
>   using complex_eq by (auto simp add:vec_simps)
> 
> lemma real_of_complex_of:
>   "(real_of \<circ> complex_of) = id"
>   unfolding complex_of_def real_of_def
>   using complex_eq by (auto simp add:vec_simps)
> 
> lemma complex_of_bij:
>   shows "bij (complex_of)"
>   using o_bij[OF real_of_complex_of complex_of_real_of] .
> 
> lemma real_of_bij:
>   shows "bij (real_of)"
>   using o_bij[OF complex_of_real_of real_of_complex_of] .
> 
> lemma real_of_inj:
>   shows "inj (real_of)"
>   using real_of_bij
>   using bij_betw_imp_inj_on by auto
> 
> lemma Jordan_curve_R2:
>   fixes c :: "real \<Rightarrow> 'a"
>   assumes "simple_path c" "pathfinish c = pathstart c"
>   obtains inside outside where
>     "inside \<noteq> {}" "open inside" "connected inside"
>     "outside \<noteq> {}" "open outside" "connected outside"
>     "bounded inside" "\<not> bounded outside"
>     "inside \<inter> outside = {}"
>     "inside \<union> outside = - path_image c"
>     "frontier inside = path_image c"
>     "frontier outside = path_image c"
> proof -
>   from simple_path_linear_image_eq[OF complex_of_linear]
>   have a1:"simple_path (complex_of \<circ> c)" using assms(1) complex_of_bij
>     using bij_betw_imp_inj_on by blast
>   have a2:"pathfinish (complex_of \<circ> c) = pathstart (complex_of \<circ> c)"
>     using assms(2) by (simp add:pathstart_compose pathfinish_compose)
> 
>   from Jordan_curve[OF a1 a2]
>   obtain inside outside where io:
>     "inside \<noteq> {}" "open inside" "connected inside"
>     "outside \<noteq> {}" "open outside" "connected outside"
>     "bounded inside" "\<not> bounded outside" "inside \<inter> outside = {}"
>     "inside \<union> outside = - path_image (complex_of \<circ> c)"
>     "frontier inside = path_image (complex_of \<circ> c)"
>     "frontier outside = path_image (complex_of \<circ> c)" by blast
>   let ?rin = "real_of ` inside"
>   let ?rout = "real_of ` outside"
>   have i: "inside = complex_of ` ?rin" using complex_of_real_of unfolding image_comp
>     by auto
>   have o: "outside = complex_of ` ?rout" using complex_of_real_of unfolding image_comp
>     by auto
>   have c: "path_image(complex_of \<circ> c) = complex_of ` (path_image c)"
>     by (simp add: path_image_compose)
>   have "?rin \<noteq> {}" using io by auto
>   moreover from open_bijective_linear_image_eq[OF real_of_linear real_of_bij]
>   have "open ?rin" using io by auto
>   moreover from connected_linear_image[OF real_of_linear]
>   have "connected ?rin" using io by auto
>   moreover have "?rout \<noteq> {}" using io by auto
>   moreover from open_bijective_linear_image_eq[OF real_of_linear real_of_bij]
>   have "open ?rout" using io by auto
>   moreover from connected_linear_image[OF real_of_linear]
>   have "connected ?rout" using io by auto
>   moreover from bounded_linear_image[OF io(7) real_of_bounded_linear]
>   have "bounded ?rin" .
>   moreover from bounded_linear_image[OF _ complex_of_bounded_linear]
>   have "\<not> bounded ?rout" using io(8) o
>     by force
>   from image_Int[OF real_of_inj]
>   have "?rin \<inter> ?rout = {}" using io(9) by auto
>   moreover from bij_image_Compl_eq[OF complex_of_bij]
>   have "?rin \<union> ?rout = - path_image c" using io(10) unfolding c
>     by (metis id_apply image_Un image_comp image_cong image_ident real_of_complex_of)
>   moreover from closure_injective_linear_image[OF real_of_linear real_of_inj]
>   have "frontier ?rin = path_image c" using io(11)
>     unfolding frontier_closures c
>     by (metis \<open>\<And>B A. real_of ` (A \<inter> B) = real_of ` A \<inter> real_of ` B\<close> bij_image_Compl_eq c calculation(9) compl_sup double_compl io(10) real_of_bij)
>   moreover from closure_injective_linear_image[OF real_of_linear real_of_inj]
>   have "frontier ?rout = path_image c" using io(12)
>     unfolding frontier_closures c
>     by (metis \<open>\<And>B A. real_of ` (A \<inter> B) = real_of ` A \<inter> real_of ` B\<close> bij_image_Compl_eq c calculation(10) frontier_closures io(11) real_of_bij)
>   ultimately show ?thesis
>     by (meson \<open>\<not> bounded (real_of ` outside)\<close> that)
> qed
> 
> (* copied *)
> corollary Jordan_inside_outside_R2:
>   fixes c :: "real \<Rightarrow> 'a"
>   assumes "simple_path c" "pathfinish c = pathstart c"
>   shows "inside(path_image c) \<noteq> {} \<and>
>           open(inside(path_image c)) \<and>
>           connected(inside(path_image c)) \<and>
>           outside(path_image c) \<noteq> {} \<and>
>           open(outside(path_image c)) \<and>
>           connected(outside(path_image c)) \<and>
>           bounded(inside(path_image c)) \<and>
>           \<not> bounded(outside(path_image c)) \<and>
>           inside(path_image c) \<inter> outside(path_image c) = {} \<and>
>           inside(path_image c) \<union> outside(path_image c) =
>           - path_image c \<and>
>           frontier(inside(path_image c)) = path_image c \<and>
>           frontier(outside(path_image c)) = path_image c"
> proof -
>   obtain inner outer
>     where *: "inner \<noteq> {}" "open inner" "connected inner"
>       "outer \<noteq> {}" "open outer" "connected outer"
>       "bounded inner" "\<not> bounded outer" "inner \<inter> outer = {}"
>       "inner \<union> outer = - path_image c"
>       "frontier inner = path_image c"
>       "frontier outer = path_image c"
>     using Jordan_curve_R2 [OF assms] by blast
>   then have inner: "inside(path_image c) = inner"
>     by (metis dual_order.antisym inside_subset interior_eq interior_inside_frontier)
>   have outer: "outside(path_image c) = outer"
>     using \<open>inner \<union> outer = - path_image c\<close> \<open>inside (path_image c) = inner\<close>
>       outside_inside \<open>inner \<inter> outer = {}\<close> by auto
>   show ?thesis
>     using * by (auto simp: inner outer)
> qed
> 
> lemma jordan_points_inside_outside:
>   fixes p :: "real \<Rightarrow> 'a"
>   assumes "0 < e"
>   assumes jordan: "simple_path p" "pathfinish p = pathstart p"
>   assumes x: "x \<in> path_image p"
>   obtains y z where "y \<in> inside (path_image p)" "y \<in> ball x e" 
>     "z \<in> outside (path_image p)" "z \<in> ball x e"
> proof -
>   from Jordan_inside_outside_R2[OF jordan]
>   have xi: "x \<in> frontier(inside (path_image p))" and
>     xo: "x \<in> frontier(outside (path_image p))"
>     using x by auto
>   obtain y where y:"y \<in> inside (path_image p)" "y \<in> ball x e" using \<open>0 < e\<close> xi
>     unfolding frontier_straddle
>     by auto
>   obtain z where z:"z \<in> outside (path_image p)" "z \<in> ball x e" using \<open>0 < e\<close> xo
>     unfolding frontier_straddle
>     by auto
>   show ?thesis using y z that by blast
> qed  
> 
> lemma eventually_at_open_segment:
>   assumes "x \<in> {a<--<b}"
>   shows "\<forall>\<^sub>F y in at x. (y-a) \<bullet> rot(a-b) = 0 \<longrightarrow> y \<in> {a <--< b}"
> proof -
>   from assms have "a \<noteq> b" by auto
>   from assms have x: "(x - a) \<bullet> rot (b - a) = 0" "x \<bullet> (b - a) \<in> {a \<bullet> (b - a)<..<b \<bullet> (b - a)}"
>     unfolding in_open_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
>     by auto
>   then have "\<forall>\<^sub>F y in at x. y \<bullet> (b - a) \<in> {a \<bullet> (b - a)<..<b \<bullet> (b - a)}"
>     by (intro topological_tendstoD) (auto intro!: tendsto_intros)
>   then show ?thesis
>     by eventually_elim (auto simp: in_open_segment_iff_rot[OF \<open>a \<noteq> b\<close>] nrm_reverse[of _ a b] algebra_simps dist_commute)
> qed
> 
> lemma linepath_ball:
>   assumes "x \<in> {a<--<b}"
>   obtains e where "e > 0" "ball x e \<inter> {y. (y-a) \<bullet> rot(a-b) = 0} \<subseteq> {a <--< b}"
> proof -
>   from eventually_at_open_segment[OF assms] assms
>   obtain e where "0 < e" "ball x e \<inter> {y. (y - a) \<bullet> rot (a - b) = 0} \<subseteq> {a<--<b}"
>     by (force simp: eventually_at in_open_segment_iff_rot dist_commute)
>   then show ?thesis ..
> qed
> 
> lemma linepath_ball_inside_outside:
>   fixes p :: "real \<Rightarrow> 'a"
>   assumes jordan: "simple_path (p +++ linepath a b)" "pathfinish p = a" "pathstart p = b"
>   assumes x: "x \<in> {a<--<b}"
>   obtains e where "e > 0" "ball x e \<inter> path_image p = {}"
>     "ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0} \<subseteq> inside (path_image (p +++ linepath a b)) \<and>
>      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0} \<subseteq> outside (path_image (p +++ linepath a b))
>      \<or> 
>      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0} \<subseteq> inside (path_image (p +++ linepath a b)) \<and>
>      ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0} \<subseteq> outside (path_image (p +++ linepath a b))"
> proof -
>   let ?lp = "p +++ linepath a b"
>   have "a \<noteq> b" using x by auto
>   have pp:"path p" using jordan path_join pathfinish_linepath simple_path_imp_path
>     by fastforce
>   have "path_image p \<inter> path_image (linepath a b) \<subseteq> {a,b}"
>     using jordan simple_path_join_loop_eq
>     by (metis (no_types, lifting) inf_sup_aci(1) insert_commute path_join_path_ends path_linepath simple_path_imp_path simple_path_joinE)
>   then have "x \<notin> path_image p" using x unfolding path_image_linepath
>     by (metis DiffE Int_iff le_iff_inf open_segment_def)
>   then have "\<forall>\<^sub>F y in at x. y \<notin> path_image p"
>     by (intro eventually_not_in_closed) (auto simp: closed_path_image \<open>path p\<close>)
>   moreover 
>   have "\<forall>\<^sub>F y in at x. (y - a) \<bullet> rot (a - b) = 0 \<longrightarrow> y \<in> {a<--<b}"
>     by (rule eventually_at_open_segment[OF x])
>   ultimately have "\<forall>\<^sub>F y in at x. y \<notin> path_image p \<and> ((y - a) \<bullet> rot (a - b) = 0 \<longrightarrow> y \<in> {a<--<b})"
>     by eventually_elim auto
>   then obtain e where e: "e > 0" "ball x e \<inter> path_image p = {}"
>     "ball x e \<inter> {y. (y - a) \<bullet> rot (a - b) = 0} \<subseteq> {a<--<b}"
>     using \<open>x \<notin> path_image p\<close> x in_open_segment_rotD[OF x]
>     apply (auto simp: eventually_at subset_iff dist_commute dest!: )
>     by (metis Int_iff all_not_in_conv dist_commute mem_ball) 
>   have a1: "pathfinish ?lp = pathstart ?lp"
>     by (auto simp add: jordan)
>   have "x \<in> path_image ?lp"
>     using jordan(1) open_closed_segment path_image_join path_join_path_ends simple_path_imp_path x by fastforce
>   from jordan_points_inside_outside[OF e(1) jordan(1) a1 this]
>   obtain y z where y: "y \<in> inside (path_image ?lp)" "y \<in> ball x e" 
>     and z: "z \<in> outside (path_image ?lp)" "z \<in> ball x e" by blast
>   have jordancurve:
>     "inside (path_image ?lp) \<inter> outside(path_image ?lp) = {}"
>     "frontier (inside (path_image ?lp)) = path_image ?lp"
>     "frontier (outside (path_image ?lp)) = path_image ?lp"
>     using Jordan_inside_outside_R2[OF jordan(1) a1] by auto
>   define b1 where "b1 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) > 0}"
>   define b2 where "b2 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) < 0}"
>   define b3 where "b3 = ball x e \<inter> {y. (y-a) \<bullet> rot (a-b) = 0}"
>   have "path_connected b1" unfolding b1_def
>     apply (auto intro!: convex_imp_path_connected convex_Int simp add:inner_diff_left)
>     using convex_halfspace_gt[of "a \<bullet> rot (a - b)" "rot(a-b)"] inner_commute
>     by (metis (no_types, lifting) Collect_cong)
>   have "path_connected b2" unfolding b2_def
>     apply (auto intro!: convex_imp_path_connected convex_Int simp add:inner_diff_left)
>     using convex_halfspace_lt[of "rot(a-b)" "a \<bullet> rot (a - b)"] inner_commute
>     by (metis (no_types, lifting) Collect_cong)
>   have "b1 \<inter> path_image(linepath a b) = {}" unfolding path_image_linepath b1_def
>     using closed_segment_surface[OF \<open>a \<noteq> b\<close>] in_segment_inner_rot2 by auto 
>   then have b1i:"b1 \<inter> path_image ?lp = {}"
>     by (metis IntD2 b1_def disjoint_iff_not_equal e(2) inf_sup_aci(1) not_in_path_image_join)
>   have "b2 \<inter> path_image(linepath a b) = {}" unfolding path_image_linepath b2_def
>     using closed_segment_surface[OF \<open>a \<noteq> b\<close>] in_segment_inner_rot2 by auto 
>   then have b2i:"b2 \<inter> path_image ?lp = {}"
>     by (metis IntD2 b2_def disjoint_iff_not_equal e(2) inf_sup_aci(1) not_in_path_image_join)
>   have bsplit: "ball x e = b1 \<union> b2 \<union> b3"
>     unfolding b1_def b2_def b3_def
>     by auto
>   have "z \<notin> b3"
>   proof clarsimp
>     assume "z \<in> b3"
>     then have "z \<in> {a<--<b}" unfolding b3_def using e by blast
>     then have "z \<in> path_image(linepath a b)" by (auto simp add: open_segment_def)
>     then have "z \<in> path_image ?lp"
>       by (simp add: jordan(2) path_image_join)
>     thus False using z
>       using inside_Un_outside by fastforce
>   qed
>   then have z12: "z \<in> b1 \<or> z \<in> b2" using z bsplit by blast
>   have "y \<notin> b3"
>   proof clarsimp
>     assume "y \<in> b3"
>     then have "y \<in> {a<--<b}" unfolding b3_def using e by auto
>     then have "y \<in> path_image(linepath a b)" by (auto simp add: open_segment_def)
>     then have "y \<in> path_image ?lp"
>       by (simp add: jordan(2) path_image_join)
>     thus False using y
>       using inside_Un_outside by fastforce
>   qed
>   then have "y \<in> b1 \<or> y \<in> b2" using y bsplit by blast
>   moreover {
>     assume "y \<in> b1"
>     then have "b1 \<inter> inside (path_image ?lp) \<noteq> {}" using y by blast
>     from path_connected_not_frontier_subset[OF \<open>path_connected b1\<close> this]
>     have 1:"b1 \<subseteq> inside (path_image ?lp)" unfolding jordancurve using b1i
>       by blast
>     then have "z \<in> b2" using jordancurve(1) z(1) z12 by blast
>     then have "b2 \<inter> outside (path_image ?lp) \<noteq> {}" using z by blast
>     from path_connected_not_frontier_subset[OF \<open>path_connected b2\<close> this]
>     have 2:"b2 \<subseteq> outside (path_image ?lp)" unfolding jordancurve using b2i
>       by blast
>     note conjI[OF 1 2]
>   }
>   moreover {
>     assume "y \<in> b2"
>     then have "b2 \<inter> inside (path_image ?lp) \<noteq> {}" using y by blast
>     from path_connected_not_frontier_subset[OF \<open>path_connected b2\<close> this]
>     have 1:"b2 \<subseteq> inside (path_image ?lp)" unfolding jordancurve using b2i
>       by blast
>     then have "z \<in> b1" using jordancurve(1) z(1) z12 by blast
>     then have "b1 \<inter> outside (path_image ?lp) \<noteq> {}" using z by blast
>     from path_connected_not_frontier_subset[OF \<open>path_connected b1\<close> this]
>     have 2:"b1 \<subseteq> outside (path_image ?lp)" unfolding jordancurve using b1i
>       by blast
>     note conjI[OF 1 2]
>   } 
>   ultimately show ?thesis unfolding b1_def b2_def using that[OF e(1-2)] by auto
> qed
> 
> subsection \<open>Transversal Segments\<close>\<comment> \<open>TODO: Transversal surface in Euclidean space?!\<close>
> 
> definition "transversal_segment a b \<longleftrightarrow>
>   a \<noteq> b \<and> {a--b} \<subseteq> X \<and>
>   (\<forall>z \<in> {a--b}. f z \<bullet> rot (a-b) \<noteq> 0)"
> 
> lemma transversal_segment_reverse:
>   assumes "transversal_segment x y"
>   shows "transversal_segment y x"
>   unfolding transversal_segment_def
>   by (metis (no_types, hide_lams) add.left_neutral add_uminus_conv_diff assms closed_segment_commute inner_diff_left inner_zero_left nrm_reverse transversal_segment_def) 
> 
> lemma transversal_segment_commute: "transversal_segment x y \<longleftrightarrow> transversal_segment y x"
>   using transversal_segment_reverse by blast
> 
> lemma transversal_segment_neg:
>   assumes "transversal_segment x y"
>   assumes w: "w \<in> {x -- y}" and "f w \<bullet> rot (x-y) < 0"
>   shows "\<forall>z \<in> {x--y}. f(z) \<bullet> rot (x-y) < 0"
> proof (rule ccontr)
>   assume " \<not> (\<forall>z\<in>{x--y}. f z \<bullet> rot (x-y) < 0)"
>   then obtain z where z: "z \<in> {x--y}" "f z \<bullet> rot (x-y) \<ge> 0" by auto
>   define ff where "ff = (\<lambda>s. f (w + s *\<^sub>R (z - w)) \<bullet> rot (x-y))"
>   have f0:"ff 0 \<le> 0" unfolding ff_def using assms(3)
>     by simp 
>   have fu:"ff 1 \<ge> 0"
>     by (auto simp: ff_def z)
>   from assms(2) obtain u where u: "0 \<le> u" "u \<le> 1" "w = (1 - u) *\<^sub>R x + u *\<^sub>R y"
>     unfolding in_segment by blast
>   have "{x--y} \<subseteq> X" using assms(1) unfolding transversal_segment_def by blast
>   then have "continuous_on {0..1} ff" unfolding ff_def 
>     using assms(2)
>     by (auto intro!:continuous_intros closed_subsegmentI z elim!: set_mp)
>   from IVT'[of ff, OF f0 fu zero_le_one this]
>   obtain s where s: "s \<ge> 0" "s \<le> 1" "ff s = 0" by blast
>   have "w + s *\<^sub>R (z - w) \<in> {x -- y}"
>     by (auto intro!: closed_subsegmentI z s w)
>   with \<open>ff s = 0\<close> show False
>     using s assms(1) unfolding transversal_segment_def ff_def by blast
> qed
> 
> lemmas transversal_segment_sign_less = transversal_segment_neg[OF _ ends_in_segment(1)]
> 
> lemma transversal_segment_pos:
>   assumes "transversal_segment x y"
>   assumes w: "w \<in> {x -- y}" "f w \<bullet> rot (x-y) > 0"
>   shows "\<forall>z \<in> {x--y}. f(z) \<bullet> rot (x-y) > 0"
>   using transversal_segment_neg[OF transversal_segment_reverse[OF assms(1)], of w] w
>   by (auto simp: rot_diff_commute[of x y] closed_segment_commute)
> 
> lemma transversal_segment_posD:
>   assumes "transversal_segment x y"
>     and pos: "z \<in> {x -- y}" "f z \<bullet> rot (x - y) > 0"
>   shows "x \<noteq> y" "{x--y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x-y) > 0"
>   using assms(1) transversal_segment_pos[OF assms]
>   by (auto simp: transversal_segment_def)
> 
> lemma transversal_segment_negD:
>   assumes "transversal_segment x y"
>     and pos: "z \<in> {x -- y}" "f z \<bullet> rot (x - y) < 0"
>   shows "x \<noteq> y" "{x--y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x-y) < 0"
>   using assms(1) transversal_segment_neg[OF assms]
>   by (auto simp: transversal_segment_def)
> 
> lemma transversal_segmentE:
>   assumes "transversal_segment x y"
>   obtains "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (x - y) > 0"
>   |  "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (y - x) > 0"
> proof (cases "f x \<bullet> rot (x - y) < 0")
>   case True
>   from transversal_segment_negD[OF assms ends_in_segment(1) True]
>   have "x \<noteq> y" "{x -- y} \<subseteq> X" "\<And>z. z \<in> {x--y} \<Longrightarrow> f z \<bullet> rot (y - x) > 0"
>     by (auto simp: rot_diff_commute[of x y])
>   then show ?thesis ..
> next
>   case False
>   then have "f x \<bullet> rot (x - y) > 0" using assms
>     by (auto simp: transversal_segment_def algebra_split_simps not_less order.order_iff_strict)
>   from transversal_segment_posD[OF assms ends_in_segment(1) this]
>   show ?thesis ..
> qed
> 
> lemma dist_add_vec:
>   shows "dist (x + s *\<^sub>R v) x = abs s * norm v"
>   by (simp add: dist_cancel_add1)
> 
> lemma transversal_segment_exists:
>   assumes "x \<in> X" "f x \<noteq> 0"
>   obtains a b where "x \<in> {a<--<b}"
>     "transversal_segment a b"
> proof -
>   (* Line through x perpendicular to f x *)
>   define l where "l = (\<lambda>s::real. x + (s/norm(f x)) *\<^sub>R rot (f x))"
>   have "norm (f x) > 0" using assms(2) using zero_less_norm_iff by blast 
>   then have distl: "\<forall>s. dist (l s) x = abs s" unfolding l_def dist_add_vec
>     by (auto simp add: norm_rot)
>   obtain d where d:"d > 0" "cball x d \<subseteq> X"
>     by (meson UNIV_I assms(1) local.local_unique_solution)
>   then have lb: "l`{-d..d} \<subseteq> cball x d" using distl by (simp add: abs_le_iff dist_commute image_subset_iff)
>   from fcontx[OF assms(1)] have "continuous (at x) f" .
>   then have c:"continuous (at 0) ((\<lambda>y. (f y \<bullet> f x)) \<circ> l)" unfolding l_def
>     by (auto intro!:continuous_intros simp add: assms(2))
>   have "((\<lambda>y. f y \<bullet> f x) \<circ> l) 0 > 0" using assms(2) unfolding l_def o_def by auto
>   from continuous_at_imp_cball[OF c this]
>   obtain r where r:"r > 0" " \<forall>z\<in>cball 0 r. 0 < ((\<lambda>y. f y \<bullet> f x) \<circ> l) z" by blast
>   then have rc:"\<forall>z \<in> l`{-r..r}. 0 < f z \<bullet> f x" using real_norm_def by auto 
>   define dr where "dr = min r d"
>   have t1:"l (-dr) \<noteq> l dr" unfolding l_def dr_def
>     by (smt \<open>0 < d\<close> \<open>0 < norm (f x)\<close> \<open>0 < r\<close> add_left_imp_eq divide_cancel_right norm_rot norm_zero scale_cancel_right)
>   have "x = midpoint (l (-dr)) (l dr)" unfolding midpoint_def l_def by auto
>   then have xin:"x \<in> {l (-dr)<--<(l dr)}" using t1 by auto
>       (* TODO: actually this should be equality, but l is affine ...
>      also the existing stuff about -- is a little too specific *)
>   have lsub:"{l (-dr)--l dr} \<subseteq> l`{-dr..dr}"
>   proof safe
>     fix z
>     assume "z \<in> {l (- dr)--l dr}"
>     then obtain u where u: "0 \<le> u" "u \<le> 1" "z = (1 - u) *\<^sub>R (l (-dr)) + u *\<^sub>R (l dr)"
>       unfolding in_segment by blast
>     then have "z = x - (1-u) *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x) + u *\<^sub>R  (dr/norm(f x)) *\<^sub>R rot (f x) "
>       unfolding l_def
>       by (simp add: l_def scaleR_add_right scale_right_diff_distrib u(3))
>     also have "... = x - (1 - 2 * u) *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x)"
>       by (auto simp add: algebra_simps divide_simps simp flip: scaleR_add_left)
>     also have "... =  x + (((2 * u - 1) * dr)/norm(f x)) *\<^sub>R rot (f x)"
>       by (smt add_uminus_conv_diff scaleR_scaleR scale_minus_left times_divide_eq_right)
>     finally have zeq: "z = l ((2*u-1)*dr)" unfolding l_def .
>     have ub: " 2* u - 1 \<le> 1 \<and> -1 \<le>  2* u - 1 " using u by linarith
>     thus "z \<in> l ` {- dr..dr}" using zeq
>       by (smt atLeastAtMost_iff d(1) dr_def image_eqI mult.commute mult_left_le mult_minus_left r(1)) 
>   qed
>   have t2: "{l (- dr)--l dr} \<subseteq> X" using lsub
>     by (smt atLeastAtMost_iff d(2) dist_commute distl dr_def image_subset_iff mem_cball order_trans)
>   have "l (- dr) - l dr = -2 *\<^sub>R (dr/norm(f x)) *\<^sub>R rot (f x)" unfolding l_def
>     by (simp add: algebra_simps flip: scaleR_add_left)
>   then have req: "rot (l (- dr) - l dr) = (2 * dr/norm(f x)) *\<^sub>R f x"
>     by auto (metis add.inverse_inverse rot_rot rot_scaleR)
>   have "l`{-dr..dr} \<subseteq> l ` {-r ..r}"
>     by (simp add: dr_def image_mono)
>   then have "{l (- dr)--l dr} \<subseteq> l ` {-r .. r}" using lsub by auto
>   then have "\<forall>z \<in> {l (- dr)--l dr}. 0 < f z \<bullet> f x" using rc by blast
>   moreover have "(dr / norm (f x)) > 0"
>     using \<open>0 < norm (f x)\<close> d(1) dr_def r(1) by auto 
>   ultimately have t3: "\<forall>z \<in> {l (- dr)--l dr}. f z \<bullet> rot (l (- dr)- l dr) > 0" unfolding req
>     by (smt divide_divide_eq_right inner_scaleR_right mult_2 norm_not_less_zero scaleR_2 times_divide_eq_left times_divide_eq_right zero_less_divide_iff)
>   have "transversal_segment (l (-dr)) (l dr)" using t1 t2 t3 unfolding transversal_segment_def by auto
>   thus ?thesis using xin
>     using that by auto 
> qed
> 
> text \<open>Perko Section 3.7 Lemma 2 part 1.\<close> 
> lemma flow_transversal_segment_finite_intersections:
>   assumes "transversal_segment a b"
>   assumes "t \<le> t'" "{t .. t'} \<subseteq> existence_ivl0 x"
>   shows "finite {s\<in>{t..t'}. flow0 x s \<in> {a--b}}"
> proof -
>   from assms have "a \<noteq> b" by (simp add: transversal_segment_def)
>   show ?thesis
>     unfolding closed_segment_surface[OF \<open>a \<noteq> b\<close>]
>     apply (rule flow_transversal_surface_finite_intersections[where Ds="\<lambda>_. blinfun_inner_left (rot (b - a))"])
>     by
>       (use assms in \<open>auto intro!: closed_Collect_conj closed_halfspace_component_ge closed_halfspace_component_le
>         derivative_eq_intros
>         simp: transversal_segment_def nrm_reverse[where x=a] in_closed_segment_iff_rot\<close>)
> qed
> 
> lemma transversal_bound_posE:
>   assumes transversal: "transversal_segment a b"
>   assumes direction: "z \<in> {a -- b}" "f z \<bullet> (rot (a - b)) > 0"
>   obtains d B where "d > 0" "0 < B"
>     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (a - b)) \<ge> B"
> proof -
>   let ?a = "(\<lambda>y. (f y) \<bullet> (rot (a - b)))"
>   from transversal_segment_posD[OF transversal direction]
>   have seg: "a \<noteq> b" "{a--b} \<subseteq> X" "z \<in> {a--b} \<Longrightarrow> 0 < f z \<bullet> rot (a - b)" for z
>     by auto
>   {
>     fix x
>     assume "x \<in> {a--b}"
>     then have "x \<in> X" "f x \<noteq> 0" "a \<noteq> b" using transversal by (auto simp: transversal_segment_def)
>     then have "?a \<midarrow>x\<rightarrow> ?a x"
>       by (auto intro!: tendsto_eq_intros)
>     moreover have "?a x > 0"
>       using seg \<open>x \<in> {a -- b}\<close> \<open>f x \<noteq> 0\<close>
>       by (auto simp: simp del: divide_const_simps
>           intro!: divide_pos_pos mult_pos_pos)
>     ultimately have "\<forall>\<^sub>F x in at x. ?a x > 0"
>       by (rule order_tendstoD)
>     moreover have "\<forall>\<^sub>F x in at x. x \<in> X"
>       by (rule topological_tendstoD[OF tendsto_ident_at open_dom \<open>x \<in> X\<close>])
>     moreover have "\<forall>\<^sub>F x in at x. f x \<noteq> 0"
>       by (rule tendsto_imp_eventually_ne tendsto_intros \<open>x \<in> X\<close> \<open>f x \<noteq> 0\<close>)+
>     ultimately have "\<forall>\<^sub>F x in at x. ?a x>0 \<and> x \<in> X \<and> f x \<noteq> 0" by eventually_elim auto
>     then obtain d where d: "0 < d" "\<And>y. y \<in> cball x d \<Longrightarrow> ?a y > 0 \<and> y \<in> X \<and> f y \<noteq> 0"
>       using \<open>?a x > 0\<close> \<open>x \<in> X\<close>
>       by (force simp: eventually_at_le dist_commute)
> 
>     have "continuous_on (cball x d) ?a"
>       using d \<open>a \<noteq> b\<close>
>       by (auto intro!: continuous_intros)
>     from compact_continuous_image[OF this compact_cball]
>     have "compact (?a ` cball x d)" .
>     from compact_attains_inf[OF this] obtain s where "s \<in> cball x d" "\<forall>x\<in>cball x d. ?a x \<ge> ?a s"
>       using \<open>d > 0\<close>
>       by auto
>     then have "\<exists>d>0. \<exists>b>0. \<forall>x \<in> cball x d. ?a x \<ge> b"
>       using d
>       by (force simp: intro: exI[where x="?a s"])
>   } then obtain dx Bx where dB:
>     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> y\<in>cball x (dx x) \<Longrightarrow> ?a y \<ge> Bx x"
>     "\<And>x. x \<in> {a -- b} \<Longrightarrow> Bx x > 0"
>     "\<And>x. x \<in> {a -- b} \<Longrightarrow> dx x > 0"
>     by metis
>   define d' where "d' = (\<lambda>x. dx x / 2)"
>   have d':
>     "\<And>x. x \<in> {a -- b} \<Longrightarrow> \<forall>y\<in>cball x (d' x). ?a y \<ge> Bx x"
>     "\<And>x. x \<in> {a -- b} \<Longrightarrow> d' x > 0"
>     using dB(1,3) by (force simp: d'_def)+
>   have d'B: "\<And>x. x \<in> {a -- b} \<Longrightarrow> \<forall>y\<in>cball x (d' x). ?a y \<ge> Bx x"
>     using d' by auto
>   have "{a--b} \<subseteq> \<Union>((\<lambda>x. ball x (d' x)) ` {a -- b})"
>     using d'(2) by auto
>   from compactE_image[OF compact_segment _ this]
>   obtain X where X: "X \<subseteq> {a--b}"
>     and [simp]: "finite X"
>     and cover: "{a--b} \<subseteq> (\<Union>x\<in>X. ball x (d' x))"
>     by auto
>   have [simp]: "X \<noteq> {}" using X cover by auto
>   define d where "d = Min (d' ` X)"
>   define B where "B = Min (Bx ` X)"
>   have "d > 0"
>     using X d'
>     by (auto simp: d_def d'_def)
>   moreover have "B > 0"
>     using X dB
>     by (auto simp: B_def simp del: divide_const_simps)
>   moreover have "B \<le> ?a y" if "x \<in> {a -- b}" "dist x y \<le> d" for x y
>   proof -
>     from \<open>x \<in> {a -- b}\<close> obtain xc where xc: "xc \<in> X" "x \<in> ball xc (d' xc)"
>       using cover by auto
>     have "?a y \<ge> Bx xc"
>     proof (rule dB)
>       show "xc \<in> {a -- b}" using xc \<open>X \<subseteq> _\<close> by auto
>       have "dist xc y \<le> dist xc x + dist x y" by norm
>       also have "dist xc x \<le> d' xc" using xc by auto
>       also note \<open>dist x y \<le> d\<close>
>       also have "d \<le> d' xc"
>         using xc
>         by (auto simp: d_def)
>       also have "d' xc + d' xc = dx xc" by (simp add: d'_def)
>       finally show "y \<in> cball xc (dx xc)" by simp
>     qed
>     also have "B \<le> Bx xc"
>       using xc
>       unfolding B_def
>       by (auto simp: B_def)
>     finally (xtrans) show ?thesis .
>   qed
>   ultimately show ?thesis ..
> qed
> 
> lemma transversal_bound_negE:
>   assumes transversal: "transversal_segment a b"
>   assumes direction: "z \<in> {a -- b}" "f z \<bullet> (rot (a - b)) < 0"
>   obtains d B where "d > 0" "0 < B"
>     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (b - a)) \<ge> B"
> proof -
>   from direction have "z \<in> {b -- a}" "f z \<bullet> (rot (b - a)) > 0"
>     by (auto simp: closed_segment_commute rot_diff_commute[of b a])
>   from transversal_bound_posE[OF transversal_segment_reverse[OF transversal] this]
>   obtain d B where "d > 0" "0 < B"
>     "\<And>x y. x \<in> {a -- b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> f y \<bullet> (rot (b - a)) \<ge> B"
>     by (auto simp: closed_segment_commute)
>   then show ?thesis ..
> qed
> 
> lemma leaves_transversal_segmentE:
>   assumes transversal: "transversal_segment a b"
>   obtains T n where "T > 0" "n = a - b \<or> n = b - a"
>     "\<And>x. x \<in> {a -- b} \<Longrightarrow> {-T..T} \<subseteq> existence_ivl0 x"
>     "\<And>x s. x \<in> {a -- b} \<Longrightarrow> 0 < s \<Longrightarrow> s \<le> T \<Longrightarrow>
>     (flow0 x s - x) \<bullet> rot n > 0"
>     "\<And>x s. x \<in> {a -- b} \<Longrightarrow> -T \<le> s \<Longrightarrow> s < 0 \<Longrightarrow>
>     (flow0 x s - x) \<bullet> rot n < 0"
> proof -
>   from transversal_segmentE[OF assms(1)] obtain n
>     where n: "n = (a - b) \<or> n = (b - a)"
>       and seg: "a \<noteq> b" "{a -- b} \<subseteq> X" "\<And>z. z \<in> {a--b} \<Longrightarrow> f z \<bullet> rot n > 0"
>     by metis
>   from open_existence_ivl_on_compact[OF \<open>{a -- b} \<subseteq> X\<close>]
>   obtain t where "0 < t" and t: "x \<in> {a--b} \<Longrightarrow> {- t..t} \<subseteq> existence_ivl0 x" for x
>     by auto
>   from n obtain d B where B: "0 < d" "0 < B" "(\<And>x y. x \<in> {a--b} \<Longrightarrow> dist x y \<le> d \<Longrightarrow> B \<le> f y \<bullet> rot n)"
>   proof
>     assume n_def: "n = a - b"
>     with seg have pos:  "0 < f a \<bullet> rot (a - b)"
>       by auto
>     from transversal_bound_posE[OF transversal ends_in_segment(1) pos, folded n_def]
>     show ?thesis using that by blast
>   next
>     assume n_def: "n = b - a"
>     with seg have pos:  "0 > f a \<bullet> rot (a - b)"
>       by (auto simp: rot_diff_commute[of a b])
>     from transversal_bound_negE[OF transversal ends_in_segment(1) this, folded n_def]
>     show ?thesis using that by blast
>   qed
>   define S where "S = \<Union>((\<lambda>x. ball x d) ` {a -- b})"
>   have S: "x \<in> S \<Longrightarrow> B \<le> f x \<bullet> rot n" for x
>     by (auto simp: S_def intro!: B)
>   have "open S" by (auto simp: S_def)
>   have "{a -- b} \<subseteq> S"
>     by (auto simp: S_def \<open>0 < d\<close>)
>   have "\<forall>\<^sub>F (t, x) in at (0, x). flow0 x t \<in> S" if "x \<in> {a -- b}" for x
>     unfolding split_beta'
>     apply (rule topological_tendstoD tendsto_intros)+
>     using set_mp[OF \<open>{a -- b} \<subseteq> X\<close> that] \<open>0 < d\<close> that \<open>open S\<close> \<open>{a -- b} \<subseteq> S\<close>
>     by (force simp: )+
>   then obtain d' where d':
>     "\<And>x. x \<in> {a--b} \<Longrightarrow> d' x > 0"
>     "\<And>x y s. x \<in> {a--b} \<Longrightarrow> (s = 0 \<longrightarrow> y \<noteq> x) \<Longrightarrow> dist (s, y) (0, x) < d' x \<Longrightarrow> flow0 y s \<in> S"
>     by (auto simp: eventually_at) metis
>   define d2 where "d2 x = d' x / 2" for x
>   have d2: "\<And>x. x \<in> {a--b} \<Longrightarrow> d2 x > 0" using d' by (auto simp: d2_def)
>   have C: "{a--b} \<subseteq> \<Union>((\<lambda>x. ball x (d2 x)) ` {a -- b})"
>     using d2 by auto
>   from compactE_image[OF compact_segment _ C]
>   obtain C' where "C' \<subseteq> {a--b}" and [simp]: "finite C'"
>     and C'_cover: "{a--b} \<subseteq> (\<Union>c\<in>C'. ball c (d2 c))" by auto
> 
>   define T where "T = Min (insert t (d2 ` C'))"
> 
>   have "T > 0"
>     using \<open>0 < t\<close> d2 \<open>C' \<subseteq> _\<close> 
>     by (auto simp: T_def)
>   moreover
>   note n
>   moreover
>   have T_ex: "{-T..T} \<subseteq> existence_ivl0 x" if "x \<in> {a--b}" for x
>     by (rule order_trans[OF _ t[OF that]]) (auto simp: T_def)
>   moreover
>   have B_le: "B \<le> f (flow0 x \<xi>) \<bullet> rot n"
>     if "x \<in> {a -- b}"
>       and c': "c' \<in> C'" "x \<in> ball c' (d2 c')"
>       and "\<xi> \<noteq> 0" and \<xi>_le: "\<bar>\<xi>\<bar> < d2 c'"
>     for x c' \<xi>
>   proof -
>     have "c' \<in> {a -- b}" using c' \<open>C' \<subseteq> _\<close> by auto
>     moreover have "\<xi> = 0 \<longrightarrow> x \<noteq> c'" using \<open>\<xi> \<noteq> 0\<close> by simp
>     moreover have "dist (\<xi>, x) (0, c') < d' c'"
>     proof -
>       have "dist (\<xi>, x) (0, c') \<le> dist (\<xi>, x) (\<xi>, c') + dist (\<xi>, c') (0, c')"
>         by norm
>       also have "dist (\<xi>, x) (\<xi>, c') < d2 c'"
>         using c'
>         by (simp add: dist_prod_def dist_commute)
>       also
>       have "T \<le> d2 c'" using c'
>         by (auto simp: T_def)
>       then have "dist (\<xi>, c') (0, c') < d2 c'"
>         using \<xi>_le
>         by (simp add: dist_prod_def)
>       also have "d2 c' + d2 c' = d' c'" by (simp add: d2_def)
>       finally show ?thesis by simp
>     qed
>     ultimately have "flow0 x \<xi> \<in> S"
>       by (rule d')
>     then show ?thesis
>       by (rule S)
>   qed
>   let ?g = "(\<lambda>x t. (flow0 x t - x) \<bullet> rot n)"
>   have cont: "continuous_on {-T .. T} (?g x)"
>     if "x \<in> {a--b}" for x
>     using T_ex that
>     by (force intro!: continuous_intros)
>   have deriv: "-T \<le> s' \<Longrightarrow> s' \<le> T \<Longrightarrow> ((?g x) has_derivative
>       (\<lambda>t. t * (f (flow0 x s') \<bullet> rot n))) (at s')"
>     if "x \<in> {a--b}" for x s'
>     using T_ex that
>     by (force intro!: derivative_eq_intros simp: flowderiv_def blinfun.bilinear_simps)
> 
>   have "(flow0 x s - x) \<bullet> rot n > 0" if "x \<in> {a -- b}" "0 < s" "s \<le> T" for x s
>   proof (rule ccontr, unfold not_less)
>     have [simp]: "x \<in> X" using that \<open>{a -- b} \<subseteq> X\<close> by auto
>     assume H: "(flow0 x s - x) \<bullet> rot n \<le> 0"
>     have cont: "continuous_on {0 .. s} (?g x)"
>       using cont by (rule continuous_on_subset) (use that in auto)
>     from mvt[OF \<open>0 < s\<close> cont deriv] that
>     obtain \<xi> where \<xi>: "0 < \<xi>" "\<xi> < s" "(flow0 x s - x) \<bullet> rot n = s * (f (flow0 x \<xi>) \<bullet> rot n)"
>       by (auto intro: continuous_on_subset)
>     note \<open>0 < B\<close>
>     also
>     from C'_cover that obtain c' where c': "c' \<in> C'" "x \<in> ball c' (d2 c')" by auto
>     have "B \<le> f (flow0 x \<xi>) \<bullet> rot n"
>     proof (rule B_le[OF that(1) c'])
>       show "\<xi> \<noteq> 0" using \<open>0 < \<xi>\<close> by simp
>       have "T \<le> d2 c'" using c'
>         by (auto simp: T_def)
>       then show "\<bar>\<xi>\<bar> < d2 c'"
>         using \<open>0 < \<xi>\<close> \<open>\<xi> < s\<close> \<open>s \<le> T\<close>
>         by (simp add: dist_prod_def)
>     qed
>     also from \<xi> H have "\<dots> \<le> 0"
>       by (auto simp add: algebra_split_simps not_less split: if_splits)
>     finally show False by simp
>   qed
>   moreover
>   have "(flow0 x s - x) \<bullet> rot n < 0" if "x \<in> {a -- b}" "-T \<le> s" "s < 0" for x s
>   proof (rule ccontr, unfold not_less)
>     have [simp]: "x \<in> X" using that \<open>{a -- b} \<subseteq> X\<close> by auto
>     assume H: "(flow0 x s - x) \<bullet> rot n \<ge> 0"
>     have cont: "continuous_on {s .. 0} (?g x)"
>       using cont by (rule continuous_on_subset) (use that in auto)
>     from mvt[OF \<open>s < 0\<close> cont deriv] that
>     obtain \<xi> where \<xi>: "s < \<xi>" "\<xi> < 0" "(flow0 x s - x) \<bullet> rot n = s * (f (flow0 x \<xi>) \<bullet> rot n)"
>       by auto
>     note \<open>0 < B\<close>
>     also
>     from C'_cover that obtain c' where c': "c' \<in> C'" "x \<in> ball c' (d2 c')" by auto
>     have "B \<le> (f (flow0 x \<xi>) \<bullet> rot n)"
>     proof (rule B_le[OF that(1) c'])
>       show "\<xi> \<noteq> 0" using \<open>0 > \<xi>\<close> by simp
>       have "T \<le> d2 c'" using c'
>         by (auto simp: T_def)
>       then show "\<bar>\<xi>\<bar> < d2 c'"
>         using \<open>0 > \<xi>\<close> \<open>\<xi> > s\<close> \<open>s \<ge> - T\<close>
>         by (simp add: dist_prod_def)
>     qed
>     also from \<xi> H have "\<dots> \<le> 0"
>       by (simp add: algebra_split_simps)
>     finally show False by simp
>   qed
>   ultimately show ?thesis ..
> qed
> 
> 
> lemma inner_rot_pos_move_base: "(x - a) \<bullet> rot (a - b) > 0"
>   if "(x - y) \<bullet> rot (a - b) > 0" "y \<in> {a -- b}"
>   by (smt in_segment_inner_rot inner_diff_left inner_minus_right minus_diff_eq rot_rot that)
> 
> lemma inner_rot_neg_move_base: "(x - a) \<bullet> rot (a - b) < 0"
>   if "(x - y) \<bullet> rot (a - b) < 0" "y \<in> {a -- b}"
>   by (smt in_segment_inner_rot inner_diff_left inner_minus_right minus_diff_eq rot_rot that)
> 
> lemma inner_pos_move_base: "(x - a) \<bullet> n > 0"
>   if "(a - b) \<bullet> n = 0" "(x - y) \<bullet> n > 0" "y \<in> {a -- b}"
> proof -
>   from that(3) obtain u where y_def: "y = (1 - u) *\<^sub>R a + u *\<^sub>R b" and u: "0 \<le> u" "u \<le> 1"
>     by (auto simp: in_segment)
>   have "(x - a) \<bullet> n = (x - y) \<bullet> n - u * ((a - b) \<bullet> n)"
>     by (simp add: algebra_simps y_def)
>   also have "\<dots> = (x - y) \<bullet> n"
>     by (simp add: that)
>   also note \<open>\<dots> > 0\<close>
>   finally show ?thesis .
> qed
> 
> lemma inner_neg_move_base: "(x - a) \<bullet> n < 0"
>   if "(a - b) \<bullet> n = 0" "(x - y) \<bullet> n < 0" "y \<in> {a -- b}"
> proof -
>   from that(3) obtain u where y_def: "y = (1 - u) *\<^sub>R a + u *\<^sub>R b" and u: "0 \<le> u" "u \<le> 1"
>     by (auto simp: in_segment)
>   have "(x - a) \<bullet> n = (x - y) \<bullet> n - u * ((a - b) \<bullet> n)"
>     by (simp add: algebra_simps y_def)
>   also have "\<dots> = (x - y) \<bullet> n"
>     by (simp add: that)
>   also note \<open>\<dots> < 0\<close>
>   finally show ?thesis .
> qed
> 
> lemma rot_same_dir:
>   assumes "x1 \<in> {a<--<b}"
>   assumes "x2 \<in> {x1<--<b}"
>   shows "(y \<bullet> rot (a-b) > 0) = (y \<bullet> rot(x1-x2) > 0)"  "(y \<bullet> rot (a-b) < 0) = (y \<bullet> rot(x1-x2) < 0)"
>   using oriented_subsegment_scale[OF assms]
>    apply (smt inner_scaleR_right nrm_reverse rot_scaleR zero_less_mult_iff)
>   by (smt \<open>\<And>thesis. (\<And>e. \<lbrakk>0 < e; b - a = e *\<^sub>R (x2 - x1)\<rbrakk> \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> inner_minus_right inner_scaleR_right rot_diff_commute rot_scaleR zero_less_mult_iff)
> 
> 
> subsection \<open>Monotone Step Lemma\<close>
> 
> lemma flow0_transversal_segment_monotone_step:
>   assumes "transversal_segment a b"
>   assumes "t1 \<le> t2" "{t1..t2} \<subseteq> existence_ivl0 x"
>   assumes x1: "flow0 x t1 \<in> {a<--<b}"
>   assumes x2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
>   assumes "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
>   assumes "t > t2" "t \<in> existence_ivl0 x"
>   shows "flow0 x t \<notin> {a<--<flow0 x t2}"
> proof -
>   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
>   note t1t2 = \<open>\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}\<close>
>     (* Basic properties of the segment *)
>   have x1neqx2: "flow0 x t1 \<noteq> flow0 x t2"
>     using open_segment_def x2 by force 
>   then have t1neqt2: "t1 \<noteq> t2" by auto
> 
>   have [simp]: "a \<noteq> b" and \<open>{a -- b} \<subseteq> X\<close> using \<open>transversal_segment a b\<close>
>     by (auto simp: transversal_segment_def)
> 
>   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
>     by (auto simp: in_open_segment_iff_line)
>   from x2 obtain i2 where i2: "flow0 x t2 = line a b i2" "0 < i1" "i1 < i2"
>     by (auto simp: i1 line_open_segment_iff)
> 
> 
>   have "{a <--< flow0 x t1} \<subseteq> {a<--<b}"
>     by (simp add: open_closed_segment subset_open_segment x1) 
>   have t12sub: "{flow0 x t1--flow0 x t2} \<subseteq> {a<--<b}"
>     by (metis ends_in_segment(2) open_closed_segment subset_co_segment subset_eq subset_open_segment x1 x2)
>   have subr: "{flow0 x t1<--<flow0 x t2} \<subseteq> {flow0 x t1 <--<b}"
>     by (simp add: open_closed_segment subset_open_segment x2)
>   have "flow0 x t1 \<in> {a <--<flow0 x t2}" using x1 x2
>     by (rule open_segment_subsegment)
>   then have subl: "{flow0 x t1<--<flow0 x t2} \<subseteq> {a <--< flow0 x t2}" using x1 x2
>     by (simp add: open_closed_segment subset_open_segment x2)
>   then have subl2: "{flow0 x t1--<flow0 x t2} \<subseteq> {a <--< flow0 x t2}" using x1 x2
>     by (smt DiffE DiffI \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> half_open_segment_def insert_iff open_segment_def subset_eq)
> 
>   have sub1b: "{flow0 x t1--b} \<subseteq> {a--b}"
>     by (simp add: open_closed_segment subset_closed_segment x1)
>   have suba2: "{a--flow0 x t2} \<subseteq> {a -- b}"
>     using open_closed_segment subset_closed_segment t12sub by blast
>   then have suba2o: "{a<--<flow0 x t2} \<subseteq> {a -- b}"
>     using open_closed_segment subset_closed_segment t12sub by blast
>   have x2_notmem: "flow0 x t2 \<notin> {a--flow0 x t1}"
>     using i1 i2
>     by (auto simp: closed_segment_line_iff)
>   have suba12: "{a--flow0 x t1} \<subseteq> {a--flow0 x t2}"
>     by (simp add: \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> open_closed_segment subset_closed_segment)
>   then have suba12_open: "{a<--<flow0 x t1} \<subseteq> {a<--<flow0 x t2}"
>     using x2_notmem
>     by (auto simp: open_segment_def)
>   have "flow0 x t2 \<in> {a--b}"
>     using suba2 by auto
> 
>   have intereq: "\<And>t. t1 \<le> t \<Longrightarrow> t \<le> t2 \<Longrightarrow> flow0 x t \<in> {a<--<b} \<Longrightarrow>  t = t1 \<or> t = t2"
>   proof (rule ccontr)
>     fix t
>     assume t: "t1 \<le> t" "t \<le> t2" "flow0 x t \<in> {a<--<b}" "\<not>(t= t1 \<or> t = t2)"
>     then have "t \<in> {t1<..<t2}" by auto
>     then have "flow0 x t \<notin> {a<--<b}" using t1t2 by blast
>     thus False using t by auto
>   qed
>   then have intereqt12: "\<And>t. t1 \<le> t \<Longrightarrow> t \<le> t2 \<Longrightarrow> flow0 x t \<in> {flow0 x t1--flow0 x t2} \<Longrightarrow>  t = t1 \<or> t = t2"
>     using t12sub by blast
> 
> (* The Jordan curve *)
>   define J1 where "J1 = flow_to_path x t1 t2"
>   define J2 where "J2 = linepath (flow0 x t2) (flow0 x t1)" 
>   define J where "J = J1 +++ J2"
>     (* Proof that J is a Jordan curve *)
>   have "pathfinish J = pathstart J" unfolding J_def J1_def J2_def
>     by (auto simp add: pathstart_compose pathfinish_compose)
>   have piJ: "path_image J = path_image J1 \<union> path_image J2"
>     unfolding J_def J1_def J2_def
>     apply (rule path_image_join)
>     by auto
>   have "flow0 x t1 \<in> flow0 x ` {t1..t2} \<and> flow0 x t2 \<in> flow0 x ` {t1..t2}"
>     using atLeastAtMost_iff \<open>t1 \<le> t2\<close> by blast 
>   then have piD: "path_image J = path_image J1 \<union> {flow0 x t1 <--<flow0 x t2}"
>     unfolding piJ J1_def J2_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
>       path_image_linepath open_segment_def
>     by (smt Diff_idemp Diff_insert2 Un_Diff_cancel closed_segment_commute mk_disjoint_insert)
>   have "\<forall>s\<in>{t1<..<t2}. flow0 x s \<noteq> flow0 x t1"
>     using x1 t1t2 by fastforce
>   from flow_to_path_arc[OF \<open>t1 \<le> t2\<close> exist this x1neqx2]
>   have "arc J1" using J1_def assms flow_to_path_arc by auto
>   then have "simple_path J" unfolding J_def
>     using \<open>arc J1\<close> J1_def J2_def assms x1neqx2 t1neqt2 apply (auto intro!:simple_path_join_loop)
>     using intereqt12 closed_segment_commute by blast
> 
>   from Jordan_inside_outside_R2[OF this \<open>pathfinish J = pathstart J\<close>]
>   obtain inner outer where inner_def: "inner = inside (path_image J)"
>     and outer_def: "outer = outside (path_image J)"
>     and io:
>     "inner \<noteq> {}" "open inner" "connected inner"
>     "outer \<noteq> {}" "open outer" "connected outer"
>     "bounded inner" "\<not> bounded outer" "inner \<inter> outer = {}"
>     "inner \<union> outer = - path_image J"
>     "frontier inner = path_image J"
>     "frontier outer = path_image J" by metis
>   from io have io2: "outer \<inter> inner = {}" "outer \<union> inner = - path_image J" by auto
> 
>   have swap_side: "\<And>y t. y \<in> side2 \<Longrightarrow>
>     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
>     flow0 y t \<in> closure side1 \<Longrightarrow>
>     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> side2) \<and>
>         flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
>     if "side1 \<inter> side2 = {}"
>       "open side2"
>       "frontier side1 = path_image J"
>       "frontier side2 = path_image J"
>       "side1 \<union> side2 = - path_image J"
>     for side1 side2
>   proof -
>     fix y t
>     assume yt: "y \<in> side2" "0 \<le> t" "t \<in> existence_ivl0 y"
>       "flow0 y t \<in> closure side1"
>     define fp where "fp = flow_to_path y 0 t"
>     have ex:"{0..t} \<subseteq> existence_ivl0 y"
>       using ivl_subset_existence_ivl yt(3) by blast
>     then have y0:"flow0 y 0 = y"
>       using mem_existence_ivl_iv_defined(2) yt(3) by auto
>     then have tpos: "t > 0" using yt(2)  \<open>side1 \<inter> side2 = {}\<close>
>       using yt(1) yt(4)
>       by (metis closure_iff_nhds_not_empty less_eq_real_def order_refl that(2)) 
>     from flow_to_path_path[OF yt(2) ex]
>     have a1: "path fp" unfolding fp_def .
>     have "y \<in> closure side2" using yt(1)
>       by (simp add: assms closure_def)
>     then have a2: "pathstart fp \<in> closure side2" unfolding fp_def using y0 by auto
>     have a3:"pathfinish fp \<notin> side2" using yt(4) \<open>side1 \<inter> side2 = {}\<close>
>       unfolding fp_def apply auto
>       using closure_iff_nhds_not_empty that(2) by blast
>     from subpath_to_frontier_strong[OF a1 a3]
>     obtain u where u:"0 \<le> u" "u \<le> 1"
>       "fp u \<notin> interior side2"
>       "u = 0 \<or>
>       (\<forall>x. 0 \<le> x \<and> x < 1 \<longrightarrow>
>         subpath 0 u fp x \<in> interior side2) \<and> fp u \<in> closure side2" by blast
>     have p1:"path_image (subpath 0 u fp) =  flow0 y ` {0 ..  u*t}"
>       unfolding fp_def subpath0_flow_to_path using path_image_flow_to_path
>       by (simp add: u(1) yt(2))
>     have p2:"fp u = flow0 y (u*t)" unfolding fp_def flow_to_path_unfold by simp
>     have inout:"interior side2 = side2" using \<open>open side2\<close>
>       by (simp add: interior_eq)
>     then have iemp: "side2 \<inter> path_image J = {}"
>       using \<open>frontier side2 = path_image J\<close>
>       by (metis frontier_disjoint_eq inf_sup_aci(1) interior_eq)
>     have "u \<noteq> 0" using inout u(3) y0 p2 yt(1) by force
>     then have c1:"u * t > 0" using tpos u y0  \<open>side1 \<inter> side2 = {}\<close>
>       using frontier_disjoint_eq io(5) yt(1) zero_less_mult_iff by fastforce
>     have uim:"fp u \<in> path_image J" using u \<open>u \<noteq> 0\<close>
>       using \<open>frontier side2 = path_image J\<close>
>       by (metis ComplI IntI closure_subset frontier_closures inout subsetD) 
>     have c2:"u * t \<le> t"  using u(1-2) tpos by auto
>     have"(flow_to_path y 0 (u * t) ` {0..<1} \<subseteq> side2)"
>       using \<open>u \<noteq> 0\<close> u inout unfolding fp_def subpath0_flow_to_path by auto
>     then have c3:"\<forall>s \<in>{0..<u*t}. flow0 y s \<in> side2" by auto
>     have c4: "flow0 y (u*t) \<in> path_image J"
>       using uim path_image_join_subset
>       by (simp add: p2)
>     have "flow0 y (u*t) \<notin> path_image J1 \<or> flow0 y (u*t) = flow0 x t1"
>     proof clarsimp
>       assume "flow0 y (u*t) \<in> path_image J1"
>       then obtain s where s: "t1 \<le> s" "s \<le> t2" "flow0 x s = flow0 y (u*t)"
>         using J1_def \<open>t1 \<le> t2\<close> by auto
>       have "s = t1"
>       proof (rule ccontr)
>         assume "s \<noteq> t1"
>         then have st1:"s > t1" using s(1) by linarith
>         define sc where "sc = min (s-t1) (u*t)"
>         have scd: "s-sc \<in> {t1..t2}" unfolding sc_def
>           using c1 s(1) s(2) by auto
>         then have *:"flow0 x (s-sc) \<in> path_image J1" unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
>           by blast
>         have "flow0 x (s-sc) = flow0 (flow0 x s) (-sc)"
>           by (smt exist atLeastAtMost_iff existence_ivl_trans' flow_trans s(1) s(2) scd subsetD)
>         then have **:"flow0 (flow0 y (u*t)) (-sc)  \<in> path_image J1"
>           using s(3) * by auto
>         have b:"u*t - sc \<in> {0..<u*t}" unfolding sc_def by (simp add: st1 c1 s(1))
>         then have "u*t - sc \<in> existence_ivl0 y"
>           using c2 ex by auto 
>         then have "flow0 y (u*t - sc) \<in> path_image J1" using **
>           by (smt atLeastAtMost_iff diff_existence_ivl_trans ex flow_trans mult_left_le_one_le mult_nonneg_nonneg subset_eq u(1) u(2) yt(2))
>         thus False using b c3 iemp piJ by blast
>       qed
>       thus "flow0 y (u * t) = flow0 x t1" using s by simp
>     qed
>     thus "\<exists>T>0. T \<le> t \<and> (\<forall>s\<in>{0..<T}. flow0 y s \<in> side2) \<and>
>           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
>       using c1 c2 c3 c4 unfolding piD
>       by (metis DiffE UnE ends_in_segment(1) half_open_segment_closed_segmentI insertCI open_segment_def x1neqx2)
>   qed
>   have outside_in: "\<And>y t. y \<in> outer \<Longrightarrow>
>     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
>     flow0 y t \<in> closure inner \<Longrightarrow>
>     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> outer) \<and>
>           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
>     by (rule swap_side; (rule io | assumption))
>   have inside_out: "\<And>y t. y \<in> inner \<Longrightarrow>
>     0 \<le> t \<Longrightarrow> t \<in> existence_ivl0 y \<Longrightarrow>
>     flow0 y t \<in> closure outer \<Longrightarrow>
>     \<exists>T. 0 < T \<and> T \<le> t \<and> (\<forall>s \<in>{0..<T}. flow0 y s \<in> inner) \<and>
>           flow0 y T \<in> {flow0 x t1--<flow0 x t2}"
>     by (rule swap_side; (rule io2 io | assumption))
> 
>   from leaves_transversal_segmentE[OF assms(1)]
>   obtain d n where d: "d > (0::real)"
>     and n: "n = a - b \<or> n = b - a"
>     and d_ex: "\<And>x. x \<in> {a -- b} \<Longrightarrow> {-d..d} \<subseteq> existence_ivl0 x"
>     and d_above: "\<And>x s. x \<in> {a -- b} \<Longrightarrow> 0 < s \<Longrightarrow> s \<le> d \<Longrightarrow> (flow0 x s - x) \<bullet> rot n > 0"
>     and d_below: "\<And>x s. x \<in> {a -- b} \<Longrightarrow> -d \<le> s \<Longrightarrow> s < 0 \<Longrightarrow> (flow0 x s - x) \<bullet> rot n < 0"
>     by blast
> 
>   have ortho: "(a - b) \<bullet> rot n = 0"
>     using n by (auto simp: algebra_simps)
> 
> (* These "rectangles" are either fully inside or fully outside
>            |-----------------------|
>            |           r1          | (flow d)
>     a --- (t1) --- rp --- (t2) --- b
>     |          r2           | (flow -d)
>     |-----------------------|
>    *)
>   define r1 where "r1 = (\<lambda>(x, y). flow0 x y)`({flow0 x t1<--<b} \<times> {0<..<d}) "
>   have r1a1: "path_connected {flow0 x t1 <--<b}" by simp
>   have r1a2: "path_connected {0<..<d}" by simp
>   have "{flow0 x t1<--<b} \<subseteq> {a--b}"
>     by (simp add: open_closed_segment subset_oc_segment x1)
>   then have r1a3: "y \<in> {flow0 x t1<--<b} \<Longrightarrow> {0<..<d} \<subseteq> existence_ivl0 y" for y
>     using d_ex[of y]
>     by force
>   from flow0_path_connected[OF r1a1 r1a2 r1a3]
>   have pcr1:"path_connected r1" unfolding r1_def by auto
>   have pir1J1: "r1 \<inter> path_image J1 = {}"
>     unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
>   proof (rule ccontr)
>     assume "r1 \<inter> flow0 x ` {t1..t2} \<noteq> {}"
>     then obtain xx tt ss where
>       eq: "flow0 xx tt = flow0 x ss"
>       and xx: "xx \<in> {flow0 x t1<--<b}"
>       and ss: "t1 \<le> ss" "ss \<le> t2"
>       and tt: "0 < tt" "tt < d"
>       unfolding r1_def
>       by force
>     have "xx \<in> {a -- b}"
>       using sub1b
>       apply (rule set_mp)
>       using xx by (simp add: open_closed_segment)
>     then have [simp]: "xx \<in> X" using \<open>transversal_segment a b\<close> by (auto simp: transversal_segment_def)
>     from ss have ss_ex: "ss \<in> existence_ivl0 x" using exist
>       by auto
>     from d_ex[OF \<open>xx \<in> {a -- b}\<close>] tt
>     have tt_ex: "tt \<in> existence_ivl0 xx" by auto
>     then have neg_tt_ex: "- tt \<in> existence_ivl0 (flow0 xx tt)"
>       by (rule existence_ivl_reverse[simplified])
>     from eq have "flow0 (flow0 xx tt) (-tt) = flow0 (flow0 x ss) (-tt)"
>       by simp
>     then have "xx = flow0 x (ss - tt)"
>       apply (subst (asm) flow_trans[symmetric])
>         apply (rule tt_ex)
>        apply (rule neg_tt_ex)
>       apply (subst (asm) flow_trans[symmetric])
>         apply (rule ss_ex)
>        apply (subst eq[symmetric])
>        apply (rule neg_tt_ex)
>       by simp
>     moreover
>     define e where "e = ss - t1"
>     consider "e > tt" | "e \<le> tt" by arith
>     then show False
>     proof cases
>       case 1
>       have "flow0 (flow0 x ss) (-tt) \<notin> {a<--<b}"
>         apply (subst flow_trans[symmetric])
>           apply fact
>         subgoal using neg_tt_ex eq by simp
>         apply (rule t1t2)
>         using 1 ss tt
>         unfolding e_def
>         by auto
>       moreover have "flow0 (flow0 x ss) (-tt) \<in> {a<--<b}"
>         unfolding eq[symmetric] using tt_ex xx
>         apply (subst flow_trans[symmetric])
>           apply (auto simp add: neg_tt_ex)
>         by (metis (no_types, hide_lams) sub1b subset_eq subset_open_segment)
>       ultimately show ?thesis by simp
>     next
>       case 2
>       have les: "0 \<le> tt - e" "tt - e \<le> d"
>         using tt ss 2 e_def
>         by auto
>       have xxtte: "flow0 xx (tt - e) = flow0 x t1"
>         apply (simp add: e_def)
>         by (smt \<open>0 \<le> tt - e\<close> \<open>{- d..d} \<subseteq> existence_ivl0 xx\<close> atLeastAtMost_iff e_def eq
>             local.existence_ivl_reverse local.existence_ivl_trans local.flow_trans ss(1) ss_ex subset_iff tt(2))
>       show False
>       proof (cases "tt = e")
>         case True
>         with xxtte have "xx = flow0 x t1"
>           by (simp add: )
>         with xx show ?thesis
>           apply auto
>           by (auto simp: open_segment_def)
>       next
>         case False
>         with les have "0 < tt - e" by (simp)
>         from d_above[OF \<open>xx \<in> {a -- b}\<close> this \<open>tt - e \<le> d\<close>]
>         have "flow0 xx (tt - e) \<notin> {a -- b}"
>           apply (simp add: in_closed_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
>               not_le )
>           by (smt \<open>xx \<in> {a--b}\<close> inner_minus_right inner_rot_neg_move_base inner_rot_pos_move_base n rot_diff_commute)
>         with xxtte show ?thesis
>           using \<open>flow0 x t1 \<in> {a<--<flow0 x t2}\<close> suba2o by auto
>       qed
>     qed
>   qed
>     (* for sufficiently small d, the flow does not return to the line *)
>   moreover
>   have pir1J2: "r1 \<inter> path_image J2 = {}"
>   proof -
>     have "r1 \<subseteq> {x. (x - a) \<bullet> rot n > 0}"
>       unfolding r1_def
>     proof safe
>       fix aa ba
>       assume "aa \<in> {flow0 x t1<--<b}" "ba \<in> {0<..<d}"
>       with sub1b show "0 < (flow0 aa ba - a) \<bullet> rot n"
>         using segment_open_subset_closed[of "flow0 x t1" b]
>         by (intro inner_pos_move_base[OF ortho d_above]) auto
>     qed
>     also have "\<dots> \<inter> {a -- b} = {}"
>       using in_segment_inner_rot in_segment_inner_rot2 n by auto
>     finally show ?thesis
>       unfolding J2_def path_image_linepath
>       using t12sub open_closed_segment
>       by (force simp: closed_segment_commute)
>   qed
>   ultimately have pir1:"r1 \<inter> (path_image J) = {}" unfolding J_def
>     by (metis disjoint_iff_not_equal not_in_path_image_join)
> 
>   define r2 where "r2 =(\<lambda>(x, y). flow0 x y)`({a <--< flow0 x t2} \<times> {-d<..<0})"
>   have r2a1:"path_connected {a <--< flow0 x t2}" by simp
>   have r2a2:"path_connected {-d<..<0}" by simp
>   have "{a <--< flow0 x t2} \<subseteq> {a -- b}"
>     by (meson ends_in_segment(1) open_closed_segment subset_co_segment subset_oc_segment t12sub)
>   then have r2a3: "y \<in> {a <--< flow0 x t2} \<Longrightarrow> {-d<..<0} \<subseteq> existence_ivl0 y" for y
>     using d_ex[of y]
>     by force
>   from flow0_path_connected[OF r2a1 r2a2 r2a3]
>   have pcr2:"path_connected r2" unfolding r2_def by auto
>   have pir2J2: "r2 \<inter> path_image J1 = {}"
>     unfolding J1_def path_image_flow_to_path[OF \<open>t1 \<le> t2\<close>]
>   proof (rule ccontr)
>     assume "r2 \<inter> flow0 x ` {t1..t2} \<noteq> {}"
>     then obtain xx tt ss where
>       eq: "flow0 xx tt = flow0 x ss"
>       and xx: "xx \<in> {a<--<flow0 x t2}"
>       and ss: "t1 \<le> ss" "ss \<le> t2"
>       and tt: "-d < tt" "tt < 0"
>       unfolding r2_def
>       by force
>     have "xx \<in> {a -- b}"
>       using suba2
>       apply (rule set_mp)
>       using xx by (simp add: open_closed_segment)
>     then have [simp]: "xx \<in> X" using \<open>transversal_segment a b\<close> by (auto simp: transversal_segment_def)
>     from ss have ss_ex: "ss \<in> existence_ivl0 x" using exist
>       by auto
>     from d_ex[OF \<open>xx \<in> {a -- b}\<close>] tt
>     have tt_ex: "tt \<in> existence_ivl0 xx" by auto
>     then have neg_tt_ex: "- tt \<in> existence_ivl0 (flow0 xx tt)"
>       by (rule existence_ivl_reverse[simplified])
>     from eq have "flow0 (flow0 xx tt) (-tt) = flow0 (flow0 x ss) (-tt)"
>       by simp
>     then have "xx = flow0 x (ss - tt)"
>       apply (subst (asm) flow_trans[symmetric])
>         apply (rule tt_ex)
>        apply (rule neg_tt_ex)
>       apply (subst (asm) flow_trans[symmetric])
>         apply (rule ss_ex)
>        apply (subst eq[symmetric])
>        apply (rule neg_tt_ex)
>       by simp
>     moreover
>     define e where "e = t2 - ss"
>     consider "e > - tt" | "e \<le> -tt" by arith
>     then show False
>     proof cases
>       case 1
>       have "flow0 (flow0 x ss) (-tt) \<notin> {a<--<b}"
>         apply (subst flow_trans[symmetric])
>           apply fact
>         subgoal using neg_tt_ex eq by simp
>         apply (rule t1t2)
>         using 1 ss tt
>         unfolding e_def
>         by auto
>       moreover have "flow0 (flow0 x ss) (-tt) \<in> {a<--<b}"
>         unfolding eq[symmetric] using tt_ex xx
>         apply (subst flow_trans[symmetric])
>           apply (auto simp add: neg_tt_ex)
>         by (metis (no_types, hide_lams) suba2 subset_eq subset_open_segment)
>       ultimately show ?thesis by simp
>     next
>       case 2
>       have les: "tt + e \<le> 0" "-d \<le> tt + e"
>         using tt ss 2 e_def
>         by auto
>       have xxtte: "flow0 xx (tt + e) = flow0 x t2"
>         apply (simp add: e_def)
>         by (smt atLeastAtMost_iff calculation eq exist local.existence_ivl_trans' local.flow_trans neg_tt_ex ss_ex subset_iff \<open>t1 \<le> t2\<close>)
>       show False
>       proof (cases "tt=-e")
>         case True
>         with xxtte have "xx = flow0 x t2"
>           by (simp add: )
>         with xx show ?thesis
>           apply auto
>           by (auto simp: open_segment_def)
>       next
>         case False
>         with les have "tt+e < 0" by simp
>         from d_below[OF \<open>xx \<in> {a -- b}\<close>  \<open>-d \<le> tt + e\<close> this]
>         have "flow0 xx (tt + e) \<notin> {a -- b}"
>           apply (simp add: in_closed_segment_iff_rot[OF \<open>a \<noteq> b\<close>]
>               not_le )
>           by (smt \<open>xx \<in> {a--b}\<close> inner_minus_right inner_rot_neg_move_base inner_rot_pos_move_base n rot_diff_commute)
>         with xxtte show ?thesis
>           using \<open>flow0 x t2 \<in> {a--b}\<close> by simp
>       qed
>     qed
>   qed
>   moreover
>   have pir2J2: "r2 \<inter> path_image J2 = {}"
>   proof -
>     have "r2 \<subseteq> {x. (x - a) \<bullet> rot n < 0}"
>       unfolding r2_def
>     proof safe
>       fix aa ba
>       assume "aa \<in> {a<--<flow0 x t2}" "ba \<in> {-d<..<0}"
>       with suba2 show "0 > (flow0 aa ba - a) \<bullet> rot n"
>         using segment_open_subset_closed[of a "flow0 x t2"]
>         by (intro inner_neg_move_base[OF ortho d_below]) auto
>     qed
>     also have "\<dots> \<inter> {a -- b} = {}"
>       using in_segment_inner_rot in_segment_inner_rot2 n by auto
>     finally show ?thesis
>       unfolding J2_def path_image_linepath
>       using t12sub open_closed_segment
>       by (force simp: closed_segment_commute)
>   qed
>   ultimately have pir2:"r2 \<inter> (path_image J) = {}"
>     unfolding J_def
>     by (metis disjoint_iff_not_equal not_in_path_image_join)
> 
>   define rp where "rp = midpoint (flow0 x t1) (flow0 x t2)"
>   have rpi: "rp \<in> {flow0 x t1<--<flow0 x t2}" unfolding rp_def
>     by (simp add: x1neqx2)
>   have "rp \<in> {a -- b}"
>     using rpi suba2o subl by blast
>   then have [simp]: "rp \<in> X"
>     using \<open>{a--b} \<subseteq> X\<close> by blast
> 
> (* The fundamental case distinction *)
>   have *: "pathfinish J1 = flow0 x t2"
>     "pathstart J1 = flow0 x t1"
>     "rp \<in> {flow0 x t2<--<flow0 x t1}"
>     using rpi
>     by (auto simp: open_segment_commute J1_def)
>   have "{y. 0 < (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1)} = {y. 0 < (y - rp) \<bullet> rot (flow0 x t2 - flow0 x t1)}"
>     by (smt Collect_cong in_open_segment_rotD inner_diff_left nrm_dot rpi)
>   also have "... =  {y. 0 > (y - rp) \<bullet> rot (flow0 x t1 - flow0 x t2)}"
>     by (smt Collect_cong inner_minus_left nrm_reverse)
>   also have " ... = {y. 0 > (y - rp) \<bullet> rot (a - b) }"
>     by (metis rot_same_dir(2) x1 x2)
>   finally have side1: "{y. 0 < (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1)} = {y. 0 > (y - rp) \<bullet> rot (a - b) }"
>     (is "_ = ?lower1") .
>   have "{y. (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0} = {y. (y - rp) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0}"
>     by (smt Collect_cong in_open_segment_rotD inner_diff_left nrm_dot rpi)
>   also have "... =  {y. (y - rp) \<bullet> rot (flow0 x t1 - flow0 x t2) > 0}"
>     by (smt Collect_cong inner_minus_left nrm_reverse)
>   also have " ... = {y. 0 < (y - rp) \<bullet> rot (a - b) }"
>     by (metis rot_same_dir(1) x1 x2)
>   finally have side2: "{y. (y - flow0 x t2) \<bullet> rot (flow0 x t2 - flow0 x t1) < 0} = {y. 0 < (y - rp) \<bullet> rot (a - b) }"
>     (is "_ = ?upper1") .
>   from linepath_ball_inside_outside[OF \<open>simple_path J\<close>[unfolded J_def J2_def] *,
>       folded J2_def J_def, unfolded side1 side2]
>   obtain e where e0: "0 < e"
>     "ball rp e \<inter> path_image J1 = {}"
>     "ball rp e \<inter> ?lower1 \<subseteq> inner \<and>
>         ball rp e \<inter> ?upper1 \<subseteq> outer \<or>
>         ball rp e \<inter> ?upper1 \<subseteq> inner \<and>
>         ball rp e \<inter> ?lower1 \<subseteq> outer"
>     by (auto simp: inner_def outer_def)
> 
>   let ?lower = "{y. 0 > (y - rp) \<bullet> rot n }"
>   let ?upper = "{y. 0 < (y - rp) \<bullet> rot n }"
>   have "?lower1 = {y. 0 < (y - rp) \<bullet> rot n } \<and> ?upper1 = {y. 0 > (y - rp) \<bullet> rot n } \<or>
>       ?lower1 = {y. 0 > (y - rp) \<bullet> rot n } \<and> ?upper1 =  {y. 0 < (y - rp) \<bullet> rot n }"
>     using n rot_diff_commute[of a b]
>     by auto
>   from this e0 have e: "0 < e"
>     "ball rp e \<inter> path_image J1 = {}"
>     "ball rp e \<inter> ?lower \<subseteq> inner \<and>
>         ball rp e \<inter> ?upper \<subseteq> outer \<or>
>         ball rp e \<inter> ?upper \<subseteq> inner \<and>
>         ball rp e \<inter> ?lower \<subseteq> outer"
>     by auto
> 
>   have "\<forall>\<^sub>F t in at_right 0. t < d"
>     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
>   then have evr: "\<forall>\<^sub>F t in at_right 0. 0 < (flow0 rp t - rp) \<bullet> rot n"
>     unfolding eventually_at_filter
>     by eventually_elim (auto intro!: \<open>rp \<in> {a--b}\<close> d_above)
>   have "\<forall>\<^sub>F t in at_left 0. t > -d"
>     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
>   then have evl: "\<forall>\<^sub>F t in at_left 0. 0 > (flow0 rp t - rp) \<bullet> rot n"
>     unfolding eventually_at_filter
>     by eventually_elim (auto intro!: \<open>rp \<in> {a--b}\<close> d_below)
>   have "\<forall>\<^sub>F t in at 0. flow0 rp t \<in> ball rp e"
>     unfolding mem_ball
>     apply (subst dist_commute)
>     apply (rule tendstoD)
>     by (auto intro!: tendsto_eq_intros \<open>0 < e\<close>)
>   then have evl2: "(\<forall>\<^sub>F t in at_left 0. flow0 rp t \<in> ball rp e)"
>     and evr2: "(\<forall>\<^sub>F t in at_right 0. flow0 rp t \<in> ball rp e)"
>     unfolding eventually_at_split by auto
>   have evl3: "(\<forall>\<^sub>F t in at_left 0. t > -d)"
>     and evr3: "(\<forall>\<^sub>F t in at_right 0. t < d)"
>     by (auto intro!: order_tendstoD \<open>0 < d\<close>)
>   have evl4: "(\<forall>\<^sub>F t in at_left 0. t < 0)"
>     and evr4: "(\<forall>\<^sub>F t in at_right 0. t > 0)"
>     by (auto simp: eventually_at_filter)
>   from evl evl2 evl3 evl4
>   have "\<forall>\<^sub>F t in at_left 0. (flow0 rp t - rp) \<bullet> rot n < 0 \<and> flow0 rp t \<in> ball rp e \<and> t > -d \<and> t < 0"
>     by eventually_elim auto
>   from eventually_happens[OF this]
>   obtain dl where dl: "(flow0 rp dl - rp) \<bullet> rot n < 0" "flow0 rp dl \<in> ball rp e" "- d < dl" "dl < 0"
>     by auto
>   from evr evr2 evr3 evr4
>   have "\<forall>\<^sub>F t in at_right 0. (flow0 rp t - rp) \<bullet> rot n > 0 \<and> flow0 rp t \<in> ball rp e \<and> t < d \<and> t > 0"
>     by eventually_elim auto
>   from eventually_happens[OF this]
>   obtain dr where dr: "(flow0 rp dr - rp) \<bullet> rot n > 0" "flow0 rp dr \<in> ball rp e" "d > dr" "dr > 0"
>     by auto
> 
>   have "rp \<in> {flow0 x t1<--<b}" using rpi subr by auto
>   then have rpr1:"flow0 rp (dr) \<in> r1" unfolding r1_def using \<open>d > dr\<close> \<open>dr > 0\<close>
>     by auto
>   have "rp \<in> {a<--<flow0 x t2}" using rpi subl by auto
>   then have rpr2:"flow0 rp (dl) \<in> r2" unfolding r2_def using \<open>-d < dl\<close> \<open>dl < 0\<close>
>     by auto
> 
>   from e(3) dr dl
>   have "flow0 rp (dr) \<in> outer \<and> flow0 rp (dl) \<in> inner \<or> flow0 rp (dr) \<in> inner \<and> flow0 rp (dl) \<in> outer"
>     by auto
>   moreover {
>     assume "flow0 rp dr \<in> outer" "flow0 rp dl \<in> inner"
>     then have
>       r1o: "r1 \<inter> outer \<noteq> {}" and
>       r2i: "r2 \<inter> inner \<noteq> {}" using rpr1 rpr2 by auto
>     from path_connected_not_frontier_subset[OF pcr1 r1o]
>     have "r1 \<subseteq> outer" using pir1 by (simp add: io(12))
>     from path_connected_not_frontier_subset[OF pcr2 r2i]
>     have "r2 \<subseteq> inner" using pir2 by (simp add: io(11))
>     have "(\<lambda>(x, y). flow0 x y)`({flow0 x t2} \<times> {0<..<d}) \<subseteq> r1" unfolding r1_def
>       by (auto intro!:image_mono simp add: x2)
>     then have *:"\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 (flow0 x t2) t \<in> outer"
>       by (smt \<open>r1 \<subseteq> outer\<close> greaterThanLessThan_iff mem_Sigma_iff pair_imageI r1_def subset_eq x2)
> 
>     then have t2o: "\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 x (t2 + t) \<in> outer"
>       using r1a3[OF x2] exist flow_trans
>       by (metis (no_types, hide_lams) closed_segment_commute ends_in_segment(1) local.existence_ivl_trans' local.flow_undefined0 real_Icc_closed_segment subset_eq \<open>t1 \<le> t2\<close>)
> 
> (* Construct a sequence of times converging to these points in r2 \<subseteq> inner *)
>     have inner: "{a <--< flow0 x t2} \<subseteq> closure inner"
>     proof (rule subsetI)
>       fix y
>       assume y: "y \<in> {a <--< flow0 x t2}"
>       have [simp]: "y \<in> X"
>         using y suba12_open suba2o \<open>{a -- b} \<subseteq> X\<close>
>         by auto
>       have "(\<forall>n. flow0 y (- d / real (Suc (Suc n))) \<in> inner)"
>         using y
>         using suba12_open \<open>0 < d\<close> suba2o \<open>{a -- b} \<subseteq> X\<close>
>         by (auto intro!: set_mp[OF \<open>r2 \<subseteq> inner\<close>] image_eqI[where x="(y, -d/Suc (Suc n))" for n]
>             simp: r2_def divide_simps) 
>       moreover
>       have d_over_0: "(\<lambda>s. - d / real (Suc (Suc s))) \<longlonglongrightarrow> 0"
>         by (rule real_tendsto_divide_at_top)
>           (auto intro!: filterlim_tendsto_add_at_top filterlim_real_sequentially)
>       have "(\<lambda>n. flow0 y (- d / real (Suc (Suc n)))) \<longlonglongrightarrow> y"
>         apply (rule tendsto_eq_intros)
>            apply (rule tendsto_intros)
>           apply (rule d_over_0)
>         by auto
>       ultimately show "y \<in> closure inner"
>         unfolding closure_sequential
>         by (intro exI[where x="\<lambda>n. flow0 y (-d/Suc (Suc n))"]) (rule conjI)
>     qed
>     then have "{a <--< flow0 x t1} \<subseteq> closure inner"
>       using suba12_open by blast
>     then have "{flow0 x t1 -- flow0 x t2} \<subseteq> closure inner"
>       by (metis (no_types, lifting) closure_closure closure_mono closure_open_segment dual_order.trans inner subl x1neqx2)
>     have outer:"\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> outer"
>     proof (rule ccontr)
>       fix t
>       assume t: "t > t2" "t \<in> existence_ivl0 x" "flow0 x t \<notin> outer"
>       have "0 \<le> t- (t2+d)" using t2o t  by smt 
>       then have a2:"0 \<le> t - (t2+dr)" using d \<open>0 < dr\<close> \<open>dr < d\<close> by linarith
>       have t2d2_ex: "t2 + dr \<in> existence_ivl0 x"
>         using \<open>t1 \<le> t2\<close> exist d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a--b}\<close> \<open>0 < d\<close> \<open>0 < dr\<close> \<open>dr < d\<close> 
>         by (intro existence_ivl_trans) auto
>       then have a3: "t - (t2 + dr) \<in> existence_ivl0 (flow0 x (t2 + dr))"
>         using t(2)
>         by (intro diff_existence_ivl_trans) auto
>       then have "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) = flow0 x t"
>         by (subst flow_trans[symmetric]) (auto simp: t2d2_ex)
>       moreover have "flow0 x t \<in> closure inner" using t(3) io
>         by (metis ComplI Un_iff closure_Un_frontier)
>       ultimately have a4: "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) \<in> closure inner" by auto
>       have a1: "flow0 x (t2+dr) \<in> outer"
>         by (simp add: d t2o \<open>0 < dr\<close> \<open>dr < d\<close>)
>       from outside_in[OF a1 a2 a3 a4]
>       obtain T where T: "T > 0" "T \<le> t - (t2 + dr)"
>         "(\<forall>s\<in>{0..<T}. flow0 (flow0 x (t2 + dr)) s \<in> outer)"
>         "flow0 (flow0 x (t2 + dr)) T \<in> {flow0 x t1 --< flow0 x t2}" by blast
>       define y where "y = flow0 (flow0 x (t2 + dr)) T"
>       have "y \<in> {a <--< flow0 x t2}" unfolding y_def using T(4)
>         using subl2 by blast 
>       then have "(\<lambda>(x, y). flow0 x y)`({y} \<times> {-d<..<0}) \<subseteq> r2" unfolding r2_def
>         by (auto intro!:image_mono)
>       then have *:"\<And>t. -d < t \<Longrightarrow> t < 0 \<Longrightarrow> flow0 y t \<in> r2"
>         by (simp add: pair_imageI subsetD)
>       have "max (-T/2) dl < 0" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
>       moreover have "-d < max (-T/2) dl" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
>       ultimately have inner: "flow0 y (max (-T/2) dl) \<in> inner" using * \<open>r2 \<subseteq> inner\<close> by blast 
>       have "0\<le>(T+(max (-T/2) dl))" using T(1) by linarith
>       moreover have "(T+(max (-T/2) dl)) < T" using T(1) d \<open>0 > dl\<close> \<open>dl > -d\<close> by linarith
>       ultimately have outer: " flow0 (flow0 x (t2 + dr)) (T+(max (-T/2) dl)) \<in> outer"
>         using T by auto
>       have T_ex: "T \<in> existence_ivl0 (flow0 x (t2 + dr))"
>         apply (subst flow_trans)
>         using exist \<open>t1 \<le> t2\<close>
>         using d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a -- b}\<close> \<open>d > 0\<close> T \<open>0 < dr\<close> \<open>dr < d\<close>
>           apply (auto simp: )
>         apply (rule set_rev_mp[where A="{0 .. t - (t2 + dr)}"], force)
>         apply (rule ivl_subset_existence_ivl)
>         apply (rule existence_ivl_trans')
>          apply (rule existence_ivl_trans')
>         by (auto simp: t)
>       have T_ex2: "dr + T \<in> existence_ivl0 (flow0 x t2)"
>         by (smt T_ex ends_in_segment(2) exist local.existence_ivl_trans local.existence_ivl_trans' real_Icc_closed_segment subset_eq t2d2_ex \<open>t1 \<le> t2\<close>)
>       thus False using T \<open>t1 \<le> t2\<close> exist
>         by (smt T_ex diff_existence_ivl_trans disjoint_iff_not_equal inner io(9) local.flow_trans local.flow_undefined0 outer y_def)
>     qed
>     have "closure inner \<inter> outer = {}"
>       by (simp add: inf_sup_aci(1) io(5) io(9) open_Int_closure_eq_empty) 
>     then have "flow0 x t \<notin> {a<--<flow0 x t2}"
>       using \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close> inner outer by blast
>   }
>   moreover {
>     assume "flow0 rp dr \<in> inner" "flow0 rp dl \<in> outer"
>     then have
>       r1i: "r1 \<inter> inner \<noteq> {}" and
>       r2o: "r2 \<inter> outer \<noteq> {}" using rpr1 rpr2 by auto
>     from path_connected_not_frontier_subset[OF pcr1 r1i]
>     have "r1 \<subseteq> inner" using pir1 by (simp add: io(11))
>     from path_connected_not_frontier_subset[OF pcr2 r2o]
>     have "r2 \<subseteq> outer" using pir2 by (simp add: io(12))
> 
>     have "(\<lambda>(x, y). flow0 x y)`({flow0 x t2} \<times> {0<..<d}) \<subseteq> r1" unfolding r1_def
>       by (auto intro!:image_mono simp add: x2)
>     then have
>       *:"\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 (flow0 x t2) t \<in> inner"
>       by (smt \<open>r1 \<subseteq> inner\<close> greaterThanLessThan_iff mem_Sigma_iff pair_imageI r1_def subset_eq x2)
> 
>     then have t2o: "\<And>t. 0 < t \<Longrightarrow> t < d \<Longrightarrow> flow0 x (t2 + t) \<in> inner"
>       using r1a3[OF x2] exist flow_trans
>       by (metis (no_types, hide_lams) closed_segment_commute ends_in_segment(1) local.existence_ivl_trans' local.flow_undefined0 real_Icc_closed_segment subset_eq \<open>t1 \<le> t2\<close>)
> 
> (* Construct a sequence of times converging to these points in r2 \<subseteq> outer *)
>     have outer: "{a <--< flow0 x t2} \<subseteq> closure outer"
>     proof (rule subsetI)
>       fix y
>       assume y: "y \<in> {a <--< flow0 x t2}"
>       have [simp]: "y \<in> X"
>         using y suba12_open suba2o \<open>{a -- b} \<subseteq> X\<close>
>         by auto
>       have "(\<forall>n. flow0 y (- d / real (Suc (Suc n))) \<in> outer)"
>         using y
>         using suba12_open \<open>0 < d\<close> suba2o \<open>{a -- b} \<subseteq> X\<close>
>         by (auto intro!: set_mp[OF \<open>r2 \<subseteq> outer\<close>] image_eqI[where x="(y, -d/Suc (Suc n))" for n]
>             simp: r2_def divide_simps) 
>       moreover
>       have d_over_0: "(\<lambda>s. - d / real (Suc (Suc s))) \<longlonglongrightarrow> 0"
>         by (rule real_tendsto_divide_at_top)
>           (auto intro!: filterlim_tendsto_add_at_top filterlim_real_sequentially)
>       have "(\<lambda>n. flow0 y (- d / real (Suc (Suc n)))) \<longlonglongrightarrow> y"
>         apply (rule tendsto_eq_intros)
>            apply (rule tendsto_intros)
>           apply (rule d_over_0)
>         by auto
>       ultimately show "y \<in> closure outer"
>         unfolding closure_sequential
>         by (intro exI[where x="\<lambda>n. flow0 y (-d/Suc (Suc n))"]) (rule conjI)
>     qed
>     then have "{a <--< flow0 x t1} \<subseteq> closure outer"
>       using suba12_open by blast
>     then have "{flow0 x t1 -- flow0 x t2} \<subseteq> closure outer"
>       by (metis (no_types, lifting) closure_closure closure_mono closure_open_segment dual_order.trans outer subl x1neqx2)
> 
>     have inner:"\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<in> inner"
>     proof (rule ccontr)
>       fix t
>       assume t: "t > t2" "t \<in> existence_ivl0 x" "flow0 x t \<notin> inner"
>       have "0 \<le> t- (t2+d)" using t2o t by smt 
>       then have a2:"0 \<le> t - (t2+dr)" using d \<open>0 < dr\<close> \<open>dr < d\<close> by linarith
>       have t2d2_ex: "t2 + dr \<in> existence_ivl0 x"
>         using \<open>t1 \<le> t2\<close> exist d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a--b}\<close> \<open>0 < d\<close> \<open>0 < dr\<close> \<open>dr < d\<close> 
>         by (intro existence_ivl_trans) auto
>       then have a3: "t - (t2 + dr) \<in> existence_ivl0 (flow0 x (t2 + dr))"
>         using t(2)
>         by (intro diff_existence_ivl_trans) auto
>       then have "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) = flow0 x t"
>         by (subst flow_trans[symmetric]) (auto simp: t2d2_ex)
>       moreover have "flow0 x t \<in> closure outer" using t(3) io
>         by (metis ComplI Un_iff closure_Un_frontier)
>       ultimately have a4: "flow0 (flow0 x (t2 + dr)) (t - (t2 + dr)) \<in> closure outer" by auto
>       have a1: "flow0 x (t2+dr) \<in> inner"
>         by (simp add: d t2o \<open>0 < dr\<close> \<open>dr < d\<close>)
>       from inside_out[OF a1 a2 a3 a4]
>       obtain T where T: "T > 0" "T \<le> t - (t2 + dr)"
>         "(\<forall>s\<in>{0..<T}. flow0 (flow0 x (t2 + dr)) s \<in> inner)"
>         "flow0 (flow0 x (t2 + dr)) T \<in> {flow0 x t1 --< flow0 x t2}" by blast
>       define y where "y = flow0 (flow0 x (t2 + dr)) T"
>       have "y \<in> {a <--< flow0 x t2}" unfolding y_def using T(4)
>         using subl2 by blast 
>       then have "(\<lambda>(x, y). flow0 x y)`({y} \<times> {-d<..<0}) \<subseteq> r2" unfolding r2_def
>         by (auto intro!:image_mono)
>       then have *:"\<And>t. -d < t \<Longrightarrow> t < 0 \<Longrightarrow> flow0 y t \<in> r2"
>         by (simp add: pair_imageI subsetD)
>       have "max (-T/2) dl < 0" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
>       moreover have "-d < max (-T/2) dl" using d T \<open>0 > dl\<close> \<open>dl > -d\<close> by auto
>       ultimately have outer: "flow0 y (max (-T/2) dl) \<in> outer" using * \<open>r2 \<subseteq> outer\<close> by blast 
>       have "0\<le>(T+(max (-T/2) dl))" using T(1) by linarith
>       moreover have "(T+(max (-T/2) dl)) < T" using T(1) d \<open>0 > dl\<close> \<open>dl > -d\<close> by linarith
>       ultimately have inner: " flow0 (flow0 x (t2 + dr)) (T+(max (-T/2) dl)) \<in> inner"
>         using T by auto
>       have T_ex: "T \<in> existence_ivl0 (flow0 x (t2 + dr))"
>         apply (subst flow_trans)
>         using exist \<open>t1 \<le> t2\<close>
>         using d_ex[of "flow0 x t2"] \<open>flow0 x t2 \<in> {a -- b}\<close> \<open>d > 0\<close> T \<open>0 < dr\<close> \<open>dr < d\<close>
>           apply (auto simp: )
>         apply (rule set_rev_mp[where A="{0 .. t - (t2 + dr)}"], force)
>         apply (rule ivl_subset_existence_ivl)
>         apply (rule existence_ivl_trans')
>          apply (rule existence_ivl_trans')
>         by (auto simp: t)
>       have T_ex2: "dr + T \<in> existence_ivl0 (flow0 x t2)"
>         by (smt T_ex ends_in_segment(2) exist local.existence_ivl_trans local.existence_ivl_trans' real_Icc_closed_segment subset_eq t2d2_ex \<open>t1 \<le> t2\<close>)
>       thus False using T \<open>t1 \<le> t2\<close> exist
>         by (smt T_ex diff_existence_ivl_trans disjoint_iff_not_equal inner io(9) local.flow_trans local.flow_undefined0 outer y_def)
>     qed
>     have "closure outer \<inter> inner = {}"
>       by (metis inf_sup_aci(1) io(2) io2(1) open_Int_closure_eq_empty)
>     then have "flow0 x t \<notin> {a<--<flow0 x t2}"
>       using \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close> inner outer by blast
>   }
>   ultimately show
>     "flow0 x t \<notin> {a<--<flow0 x t2}" by auto
> qed
> 
> lemma open_segment_trichotomy:
>   fixes x y a b::'a
>   assumes x:"x \<in> {a<--<b}"
>   assumes y:"y \<in> {a<--<b}"
>   shows "x = y \<or> y \<in> {x<--<b} \<or> y \<in> {a<--<x}"
> proof -
>   from Un_open_segment[OF y]
>   have "{a<--<y} \<union> {y} \<union> {y<--<b} = {a<--<b}" .
>   then have "x \<in> {a<--<y} \<or> x = y \<or> x \<in> {y <--<b}" using x by blast
>   moreover {
>     assume "x \<in> {a<--<y}"
>     then have "y \<in> {x<--<b}" using open_segment_subsegment
>       using open_segment_commute y by blast
>   }
>   moreover {
>     assume "x \<in> {y<--<b}"
>     from open_segment_subsegment[OF y this]
>     have "y \<in> {a<--<x}" .
>   }
>   ultimately show ?thesis by blast
> qed
> 
> sublocale rev: c1_on_open_R2 "-f" "-f'" rewrites "-(-f) = f" and "-(-f') = f'"
>   by unfold_locales (auto simp: dim2)
> 
> lemma rev_transversal_segment: "rev.transversal_segment a b = transversal_segment a b"
>   by (auto simp: transversal_segment_def rev.transversal_segment_def)
> 
> lemma flow0_transversal_segment_monotone_step_reverse:
>   assumes "transversal_segment a b"
>   assumes "t1 \<le> t2"
>   assumes "{t1..t2} \<subseteq> existence_ivl0 x"
>   assumes x1: "flow0 x t1 \<in> {a<--<b}"
>   assumes x2: "flow0 x t2 \<in> {a<--<flow0 x t1}"
>   assumes "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
>   assumes "t < t1" "t \<in> existence_ivl0 x"
>   shows "flow0 x t \<notin> {a<--<flow0 x t1}"
> proof -
>   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
>   note t1t2 = \<open>\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}\<close>
>   from \<open>transversal_segment a b\<close> have [simp]: "a \<noteq> b" by (simp add: transversal_segment_def)
>   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
>     by (auto simp: in_open_segment_iff_line)
>   from x2 obtain i2 where i2: "flow0 x t2 = line a b i2" "0 < i2" "i2 < i1"
>     by (auto simp: i1 open_segment_line_iff)
> 
>   have t2_exist[simp]: "t2 \<in> existence_ivl0 x"
>     using \<open>t1 \<le> t2\<close> exist by auto
>   have t2_mem: "flow0 x t2 \<in> {a<--<b}"
>     and x1_mem: "flow0 x t1 \<in> {flow0 x t2<--<b}"
>     using i1 i2
>     by (auto simp: line_in_subsegment line_line1)
> 
>   have transversal': "rev.transversal_segment a b"
>     using \<open>transversal_segment a b\<close> unfolding rev_transversal_segment .
>   have time': "0 \<le> t2 - t1" using \<open>t1 \<le> t2\<close> by simp
>   have [simp, intro]: "flow0 x t2 \<in> X"
>     using exist \<open>t1 \<le> t2\<close>
>     by auto
>   have exivl': "{0..t2 - t1} \<subseteq> rev.existence_ivl0 (flow0 x t2)"
>     using exist \<open>t1 \<le> t2\<close>
>     by (force simp add: rev_existence_ivl_eq0 intro!: existence_ivl_trans')
>   have step': "rev.flow0 (flow0 x t2) (t2-t) \<notin>  {a<--<rev.flow0 (flow0 x t2) (t2 - t1)}"
>     apply (rule rev.flow0_transversal_segment_monotone_step[OF transversal' time' exivl'])
>     using exist \<open>t1 \<le> t2\<close> x1 x2 t2_mem x1_mem t1t2 \<open>t < t1\<close> \<open>t \<in> existence_ivl0 x\<close>
>         apply (auto simp: rev_existence_ivl_eq0 rev_eq_flow existence_ivl_trans' flow_trans[symmetric])
>     by (subst (asm) flow_trans[symmetric]) (auto intro!: existence_ivl_trans')
>   then show ?thesis
>     unfolding rev_eq_flow
>     using \<open>t1 \<le> t2\<close> exist \<open>t < t1\<close> \<open>t \<in> existence_ivl0 x\<close>
>     by (auto simp: flow_trans[symmetric] existence_ivl_trans')
> qed
> 
> lemma flow0_transversal_segment_monotone_step_reverse2:
>   assumes transversal: "transversal_segment a b"
>   assumes time: "t1 \<le> t2"
>   assumes exist: "{t1..t2} \<subseteq> existence_ivl0 x"
>   assumes t1: "flow0 x t1 \<in> {a<--<b}"
>   assumes t2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
>   assumes t1t2: "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
>   assumes t: "t < t1" "t \<in> existence_ivl0 x"
>   shows "flow0 x t \<notin> {flow0 x t1<--<b}"
>   using flow0_transversal_segment_monotone_step_reverse[of b a, OF _ time exist, of t]
>     assms
>   by (auto simp: open_segment_commute transversal_segment_commute)
> 
> lemma flow0_transversal_segment_monotone_step2:
>   assumes transversal: "transversal_segment a b"
>   assumes time: "t1 \<le> t2"
>   assumes exist: "{t1..t2} \<subseteq> existence_ivl0 x"
>   assumes t1: "flow0 x t1 \<in> {a<--<b}"
>   assumes t2: "flow0 x t2 \<in> {a<--<flow0 x t1}"
>   assumes t1t2: "\<And>t. t \<in> {t1<..<t2} \<Longrightarrow> flow0 x t \<notin> {a<--<b}"
>   shows "\<And>t. t > t2 \<Longrightarrow> t \<in> existence_ivl0 x \<Longrightarrow> flow0 x t \<notin> {flow0 x t2<--<b}"
>   using flow0_transversal_segment_monotone_step[of b a, OF _ time exist]
>     assms
>   by (auto simp: transversal_segment_commute open_segment_commute)
> 
> lemma flow0_transversal_segment_monotone:
>   assumes "transversal_segment a b"
>   assumes "t1 \<le> t2"
>   assumes "{t1..t2} \<subseteq> existence_ivl0 x"
>   assumes x1: "flow0 x t1 \<in> {a<--<b}"
>   assumes x2: "flow0 x t2 \<in> {flow0 x t1<--<b}"
>   assumes "t > t2" "t \<in> existence_ivl0 x"
>   shows "flow0 x t \<notin> {a<--<flow0 x t2}"
> proof -
>   note exist = \<open>{t1..t2} \<subseteq> existence_ivl0 x\<close>
>   note t = \<open>t > t2\<close> \<open>t \<in> existence_ivl0 x\<close>
>   have x1neqx2: "flow0 x t1 \<noteq> flow0 x t2"
>     using open_segment_def x2 by force 
>   then have t1neqt2: "t1 \<noteq> t2" by auto
>   with \<open>t1 \<le> t2\<close> have "t1 < t2" by simp
> 
>   from \<open>transversal_segment a b\<close> have [simp]: "a \<noteq> b" by (simp add: transversal_segment_def)
>   from x1 obtain i1 where i1: "flow0 x t1 = line a b i1" "0 < i1" "i1 < 1"
>     by (auto simp: in_open_segment_iff_line)
>   from x2 i1 obtain i2 where i2: "flow0 x t2 = line a b i2" "i1 < i2" "i2 < 1"
>     by (auto simp: line_open_segment_iff)
>   have t2_in: "flow0 x t2 \<in> {a<--<b}"
>     using i1 i2
>     by simp
> 
>   let ?T = "{s \<in> {t1..t2}. flow0 x s \<in> {a--b}}"
>   let ?T' = "{s \<in> {t1..<t2}. flow0 x s \<in> {a<--<b}}"
>   from flow_transversal_segment_finite_intersections[OF \<open>transversal_segment a b\<close> \<open>t1 \<le> t2\<close> exist]
>   have "finite ?T" .
>   then have "finite ?T'" by (rule finite_subset[rotated]) (auto simp: open_closed_segment)
>   have "?T' \<noteq> {}"
>     by (auto intro!: exI[where x=t1] \<open>t1 < t2\<close> x1)
>   note tm_defined = \<open>finite ?T'\<close> \<open>?T' \<noteq> {}\<close>
>   define tm where "tm = Max ?T'"
>   have "tm \<in> ?T'"
>     unfolding tm_def
>     using tm_defined by (rule Max_in)
>   have tm_in: "flow0 x tm \<in> {a<--<b}"
>     using \<open>tm \<in> ?T'\<close>
>     by auto
>   have tm: "t1 \<le> tm" "tm < t2" "tm \<le> t2"
>     using \<open>tm \<in> ?T'\<close> by auto
>   have tm_Max: "t \<le> tm" if "t \<in> ?T'" for t
>     unfolding tm_def
>     using tm_defined(1) that
>     by (rule Max_ge)
> 
>   have tm_exclude: "flow0 x t \<notin> {a<--<b}" if "t \<in> {tm<..<t2}" for t
>     using \<open>tm \<in> ?T'\<close> tm_Max that
>     by auto (meson approximation_preproc_push_neg(2) dual_order.strict_trans2 le_cases)
>   have "{tm..t2} \<subseteq> existence_ivl0 x"
>     using exist tm by auto
> 
>   from open_segment_trichotomy[OF tm_in t2_in]
>   consider
>     "flow0 x t2 \<in> {flow0 x tm<--<b}" |
>     "flow0 x t2 \<in> {a<--<flow0 x tm}" |
>     "flow0 x tm = flow0 x t2"
>     by blast
>   then show "flow0 x t \<notin> {a<--<flow0 x t2}"
>   proof cases
>     case 1
>     from flow0_transversal_segment_monotone_step[OF \<open>transversal_segment a b\<close> \<open>tm \<le> t2\<close>
>         \<open>{tm..t2} \<subseteq> existence_ivl0 x\<close> tm_in 1 tm_exclude t]
>     show ?thesis .
>   next
>     case 2
>     have "t1 \<noteq> tm"
>       using 2 x2 i1 i2
>       by (auto simp: line_in_subsegment line_in_subsegment2)
>     then have "t1 < tm" using \<open>t1 \<le> tm\<close> by simp
>     from flow0_transversal_segment_monotone_step_reverse[OF \<open>transversal_segment a b\<close> \<open>tm \<le> t2\<close>
>         \<open>{tm..t2} \<subseteq> existence_ivl0 x\<close> tm_in 2 tm_exclude \<open>t1 < tm\<close>] exist \<open>t1 \<le> t2\<close>
>     have "flow0 x t1 \<notin> {a<--<flow0 x tm}" by auto
>     then have False
>       using x1 x2 2 i1 i2
>       apply (auto simp: line_in_subsegment line_in_subsegment2)
>       by (smt greaterThanLessThan_iff in_open_segment_iff_line line_in_subsegment2 tm_in)
>     then show ?thesis by simp
>   next
>     case 3
>     have "t1 \<noteq> tm"
>       using 3 x2
>       by (auto simp: open_segment_def)
>     then have "t1 < tm" using \<open>t1 \<le> tm\<close> by simp
>     have "range (flow0 x) = flow0 x ` {tm..t2}"
>       apply (rule recurrence_time_restricts_compact_flow'[OF \<open>tm < t2\<close> _ _ 3])
>       using exist \<open>t1 \<le> t2\<close> \<open>t1 < tm\<close> \<open>tm < t2\<close>
>       by auto
>     also have "\<dots> = flow0 x ` (insert t2 {tm<..<t2})"
>       using \<open>tm \<le> t2\<close> 3
>       apply (auto simp: )
>       by (smt greaterThanLessThan_iff image_eqI)
>     finally have "flow0 x t1 \<in> flow0 x ` (insert t2 {tm<..<t2})"
>       by auto
>     then have "flow0 x t1 \<in> flow0 x ` {tm<..<t2}" using x1neqx2
>       by auto
>     moreover have "\<dots> \<inter> {a<--<b} = {}"
>       using tm_exclude
>       by auto
>     ultimately have False using x1 by auto
>     then show ?thesis by blast
>   qed
> qed
> 
> subsection \<open>Straightening\<close>
> 
> text \<open> This lemma uses the implicit function theorem \<close>
> lemma cross_time_continuous:
>   assumes "transversal_segment a b"
>   assumes "x \<in> {a<--<b}"
>   assumes "e > 0"
>   obtains d t where "d > 0" "continuous_on (ball x d) t"
>     "\<And>y. y \<in> ball x d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b}"
>     "\<And>y. y \<in> ball x d \<Longrightarrow> \<bar>t y\<bar> < e"
>     "continuous_on (ball x d) t"
>     "t x = 0"
> proof -
>   have "x \<in> X" using assms segment_open_subset_closed[of a b]
>     by (auto simp: transversal_segment_def)
>   have "a \<noteq> b" using assms by auto
>   define s where "s x = (x - a) \<bullet> rot (b - a)" for x
>   have "s x = 0"
>     unfolding s_def
>     by (subst in_segment_inner_rot) (auto intro!: assms open_closed_segment)
>   have Ds: "(s has_derivative blinfun_inner_left (rot (b - a))) (at x)"
>     (is "(_ has_derivative blinfun_apply (?Ds x)) _")
>     for x
>     unfolding s_def
>     by (auto intro!: derivative_eq_intros)
>   have Dsc: "isCont ?Ds x" by (auto intro!: continuous_intros)
>   have nz: "?Ds x (f x) \<noteq> 0"
>     using assms  apply auto
>     unfolding transversal_segment_def
>     by (smt inner_minus_left nrm_reverse open_closed_segment)
> 
>   from flow_implicit_function_at[OF \<open>x \<in> X\<close>, of s, OF \<open>s x = 0\<close> Ds Dsc nz \<open>e > 0\<close>]
>   obtain t d1 where "0 < d1"
>     and t0: "t x = 0"
>     and d1: "(\<And>y. y \<in> cball x d1 \<Longrightarrow> s (flow0 y (t y)) = 0)"
>     "(\<And>y. y \<in> cball x d1 \<Longrightarrow> \<bar>t y\<bar> < e)"
>     "(\<And>y. y \<in> cball x d1 \<Longrightarrow> t y \<in> existence_ivl0 y)"
>     and tc: "continuous_on (cball x d1) t"
>     and t': "(t has_derivative
>         (- blinfun_inner_left (rot (b - a)) /\<^sub>R (blinfun_inner_left (rot (b - a))) (f x)))
>       (at x)"
>     by metis
>   from tc
>   have "t \<midarrow>x\<rightarrow> 0"
>     using \<open>0 < d1\<close>
>     by (auto simp: continuous_on_def at_within_interior t0 dest!: bspec[where x=x])
>   then have ftc: "((\<lambda>y. flow0 y (t y)) \<longlongrightarrow> x) (at x)"
>     by (auto intro!: tendsto_eq_intros simp: \<open>x \<in> X\<close>)
> 
> 
> 
>   define e2 where "e2 = min (dist a x) (dist b x)"
>   have "e2 > 0"
>     using assms
>     by (auto simp: e2_def open_segment_def)
> 
>   from tendstoD[OF ftc this] have "\<forall>\<^sub>F y in at x. dist (flow0 y (t y)) x < e2" .
>   moreover
>   let ?S = "{x. a \<bullet> (b - a) < x \<bullet> (b - a) \<and> x \<bullet> (b - a) < b \<bullet> (b - a)}"
>   have "open ?S" "x \<in> ?S"
>     using \<open>x \<in> {a<--<b}\<close>
>     by (auto simp add: open_segment_line_hyperplanes \<open>a \<noteq> b\<close>
>         intro!: open_Collect_conj open_halfspace_component_gt open_halfspace_component_lt)
>   from topological_tendstoD[OF ftc this] have "\<forall>\<^sub>F y in at x. flow0 y (t y) \<in> ?S" .
>   ultimately
>   have "\<forall>\<^sub>F y in at x. flow0 y (t y) \<in> ball x e2 \<inter> ?S" by eventually_elim (auto simp: dist_commute)
>   then obtain d2 where "0 < d2" and "\<And>y. x \<noteq> y \<Longrightarrow> dist y x < d2 \<Longrightarrow> flow0 y (t y) \<in> ball x e2 \<inter> ?S"
>     by (force simp: eventually_at)
>   then have d2: "dist y x < d2 \<Longrightarrow> flow0 y (t y) \<in> ball x e2 \<inter> ?S" for y
>     using \<open>0 < e2\<close> \<open>x \<in> X\<close> t0 \<open>x \<in> ?S\<close>
>     by (cases "y = x") auto
> 
>   define d where "d = min d1 d2"
>   have "d > 0" using \<open>0 < d1\<close> \<open>0 < d2\<close> by (simp add: d_def)
>   moreover have "continuous_on (ball x d) t"
>     by (auto intro!:continuous_on_subset[OF tc] simp add: d_def)
>   moreover
>   have "ball x e2 \<inter> ?S \<inter> {x. s x = 0} \<subseteq> {a<--<b}"
>     by (auto simp add: in_open_segment_iff_rot \<open>a \<noteq> b\<close>) (auto simp: s_def e2_def in_segment)
>   then have "\<And>y. y \<in> ball x d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b}"
>     apply (rule set_mp)
>     using d1 d2 \<open>0 < d2\<close>
>     by (auto simp: d_def e2_def dist_commute)
>   moreover have "\<And>y. y \<in> ball x d \<Longrightarrow> \<bar>t y\<bar> < e"
>     using d1 by (auto simp: d_def)
>   moreover have "continuous_on (ball x d) t"
>     using tc by (rule continuous_on_subset) (auto simp: d_def)
>   moreover have "t x = 0" by (simp add: t0)
>   ultimately show ?thesis ..
> qed
> 
> lemma \<omega>_limit_crossings:
>   assumes "transversal_segment a b"
>   assumes pos_ex: "{0..} \<subseteq> existence_ivl0 x"
>   assumes "\<omega>_limit_point x p"
>   assumes "p \<in> {a<--<b}"
>   obtains s where 
>     "s \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b} \<and> s n \<in> existence_ivl0 x"
> proof -
>   from assms have "p \<in> X" by (auto simp: transversal_segment_def open_closed_segment)
>   from assms(3)
>   obtain t where
>     "t \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>" "(flow0 x \<circ> t) \<longlonglongrightarrow> p"
>     by (auto simp: \<omega>_limit_point_def)
>   note t = \<open>t \<longlonglongrightarrow>\<^bsub>\<^esub> \<infinity>\<close> \<open>(flow0 x \<circ> t) \<longlonglongrightarrow> p\<close>
>   note [tendsto_intros] = t(2)
>   from cross_time_continuous[OF assms(1,4) zero_less_one\<comment> \<open>TODO ??\<close>]
>   obtain \<tau> \<delta>
>     where "0 < \<delta>" "continuous_on (ball p \<delta>) \<tau>" 
>       "\<tau> p = 0" "(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> \<bar>\<tau> y\<bar> < 1)"
>       "(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> flow0 y (\<tau> y) \<in> {a<--<b})"
>     by metis
>   note \<tau> =
>     \<open>(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> flow0 y (\<tau> y) \<in> {a<--<b})\<close>
>     \<open>(\<And>y. y \<in> ball p \<delta> \<Longrightarrow> \<bar>\<tau> y\<bar> < 1)\<close>
>     \<open>continuous_on (ball p \<delta>) \<tau>\<close> \<open>\<tau> p = 0\<close>
>   define s where "s n = t n + \<tau> (flow0 x (t n))" for n
>   have ev_in_ball: "\<forall>\<^sub>F n in at_top. flow0 x (t n) \<in> ball p \<delta>"
>     apply (simp add: )
>     apply (subst dist_commute)
>     apply (rule tendstoD)
>      apply (rule t[unfolded o_def])
>     apply (rule \<open>0 < \<delta>\<close>)
>     done
>   have "filterlim s at_top sequentially"
>   proof (rule filterlim_at_top_mono)
>     show "filterlim (\<lambda>n. -1 + t n) at_top sequentially"
>       by (rule filterlim_tendsto_add_at_top) (auto intro!: filterlim_tendsto_add_at_top t)
>     from ev_in_ball show "\<forall>\<^sub>F x in sequentially. -1 + t x \<le> s x"
>       apply eventually_elim
>       using \<tau>
>       by (force simp : s_def)
>   qed
>   moreover
>   have \<tau>_cont: "\<tau> \<midarrow>p\<rightarrow> \<tau> p"
>     using \<tau>(3) \<open>0 < \<delta>\<close>
>     by (auto simp: continuous_on_def at_within_ball dest!: bspec[where x=p])
>   note [tendsto_intros] = tendsto_compose_at[OF _ this, simplified]
>   have ev1: "\<forall>\<^sub>F n in sequentially. t n > 1"
>     using filterlim_at_top_dense t(1) by auto
>   then have ev_eq: "\<forall>\<^sub>F n in sequentially. flow0 ((flow0 x o t) n) ((\<tau> o (flow0 x o t)) n) = (flow0 x o s) n"
>     using ev_in_ball
>     apply (eventually_elim)
>     apply (drule \<tau>(2))
>     unfolding o_def
>     apply (subst flow_trans[symmetric])
>     using pos_ex
>       apply (auto simp: s_def)
>     apply (rule existence_ivl_trans')
>     by auto
>   then
>   have "\<forall>\<^sub>F n in sequentially.
>   (flow0 x o s) n = flow0 ((flow0 x o t) n) ((\<tau> o (flow0 x o t)) n)"
>     by (simp add: eventually_mono)
>   from \<open>(flow0 x \<circ> t) \<longlonglongrightarrow> p\<close> and \<open>\<tau> \<midarrow>p\<rightarrow> \<tau> p\<close>
>   have
>     "(\<lambda>n. flow0 ((flow0 x \<circ> t) n) ((\<tau> \<circ> (flow0 x \<circ> t)) n))
>   \<longlonglongrightarrow>
>   flow0 p (\<tau> p)"
>     using \<open>\<tau> p = 0\<close> \<tau>_cont \<open>p \<in> X\<close>
>     by (intro tendsto_eq_intros) auto
>   then have "(flow0 x o s) \<longlonglongrightarrow> flow0 p (\<tau> p)"
>     using ev_eq by (rule Lim_transform_eventually)
>   then have "(flow0 x o s) \<longlonglongrightarrow> p"
>     using \<open>p \<in> X\<close> \<open>\<tau> p = 0\<close>
>     by simp
>   moreover
>   {
>     have "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b}"
>       using ev_eq ev_in_ball
>       apply eventually_elim
>       apply (drule sym)
>       apply simp
>       apply (rule \<tau>) by simp
>     moreover have "\<forall>\<^sub>F n in sequentially. s n \<in> existence_ivl0 x"
>       using ev_in_ball ev1
>       apply (eventually_elim)
>       apply (drule \<tau>(2))
>       using pos_ex
>       by (auto simp: s_def)
>     ultimately have "\<forall>\<^sub>F n in sequentially. flow0 x (s n) \<in> {a<--<b} \<and> s n \<in> existence_ivl0 x"
>       by eventually_elim auto
>   }
>   ultimately show ?thesis ..
> qed
> 
> (* Obvious but frequently used step *)
> lemma filterlim_at_top_tendstoE:
>   assumes "e > 0"
>   assumes "filterlim s at_top sequentially"
>   assumes "(flow0 x \<circ> s) \<longlonglongrightarrow> u"
>   assumes "\<forall>\<^sub>F n in sequentially. P (s n)"
>   obtains m where "m > b" "P m" "dist (flow0 x m) u < e"
> proof -
>   from assms(2) have "\<forall>\<^sub>F n in sequentially. b < s n"
>     by (simp add: filterlim_at_top_dense)
>   moreover have "\<forall>\<^sub>F n in sequentially. norm ((flow0 x \<circ> s) n - u) < e"
>     using assms(3)[THEN tendstoD, OF assms(1)] by (simp add: dist_norm)
>   moreover note assms(4)
>   ultimately have "\<forall>\<^sub>F n in sequentially. b < s n \<and> norm ((flow0 x \<circ> s) n - u) < e \<and> P (s n)"
>     by eventually_elim auto
>   then obtain m where "m > b" "P m" "dist (flow0 x m) u < e"
>     by (auto simp add: eventually_sequentially dist_norm)
>   then show ?thesis ..
> qed
> 
> lemma open_segment_separate_left:
>   fixes u v x a b::'a
>   assumes u:"u \<in> {a <--< b}"
>   assumes v:"v \<in> {u <--< b}"
>   assumes x: "dist x u < dist u v" "x \<in> {a <--< b}"
>   shows "x \<in> {a <--< v}"
> proof -
>   have "v \<noteq> x"
>     by (smt dist_commute x(1)) 
>   moreover have "x \<notin> {v<--<b}"
>     by (smt dist_commute dist_in_open_segment open_segment_subsegment v x(1))
>   moreover have "v \<in> {a<--<b}" using v
>     by (metis ends_in_segment(1) segment_open_subset_closed subset_eq subset_segment(4) u)
>   ultimately show ?thesis using open_segment_trichotomy[OF _ x(2)]
>     by blast
> qed
> 
> lemma open_segment_separate_right:
>   fixes u v x a b::'a
>   assumes u:"u \<in> {a <--< b}"
>   assumes v:"v \<in> {a <--< u}"
>   assumes x: "dist x u < dist u v" "x \<in> {a <--< b}"
>   shows "x \<in> {v <--< b}"
> proof -
>   have "v \<noteq> x"
>     by (smt dist_commute x(1))
>   moreover have "x \<notin> {a<--<v}"
>     by (smt dist_commute dist_in_open_segment open_segment_commute open_segment_subsegment v x(1))
>   moreover have "v \<in> {a<--<b}" using v
>     by (metis ends_in_segment(1) segment_open_subset_closed subset_eq subset_segment(4) u)
>   ultimately show ?thesis using open_segment_trichotomy[OF _ x(2)]
>     by blast
> qed
> 
> lemma no_two_\<omega>_limit_points:
>   assumes transversal: "transversal_segment a b"
>   assumes ex_pos: "{0..} \<subseteq> existence_ivl0 x"
>   assumes u: "\<omega>_limit_point x u" "u \<in> {a<--<b}"
>   assumes v: "\<omega>_limit_point x v" "v \<in> {a<--<b}"
>   assumes uv: "v \<in> {u<--<b}"
>   shows False
> proof -
>   have unotv: "u \<noteq> v" using uv
>     using dist_in_open_segment by blast 
>   define duv where "duv = dist u v / 2"
>   have duv: "duv > 0" unfolding duv_def using unotv by simp
>   from \<omega>_limit_crossings[OF transversal ex_pos u]
>   obtain su where su: "filterlim su at_top sequentially"
>     "(flow0 x \<circ> su) \<longlonglongrightarrow> u"
>     "\<forall>\<^sub>F n in sequentially. flow0 x (su n) \<in> {a<--<b} \<and> su n \<in> existence_ivl0 x" by blast
>   from \<omega>_limit_crossings[OF transversal ex_pos v]
>   obtain sv where sv: "filterlim sv at_top sequentially"
>     "(flow0 x \<circ> sv) \<longlonglongrightarrow> v"
>     "\<forall>\<^sub>F n in sequentially. flow0 x (sv n) \<in> {a<--<b} \<and> sv n \<in> existence_ivl0 x" by blast
>   from filterlim_at_top_tendstoE[OF duv su]
>   obtain su1 where su1:"su1 > 0" "flow0 x su1 \<in> {a<--<b}"
>     "su1 \<in> existence_ivl0 x" "dist (flow0 x su1) u < duv" by auto
>   from filterlim_at_top_tendstoE[OF duv sv, of su1]
>   obtain su2 where su2:"su2 > su1" "flow0 x su2 \<in> {a<--<b}"
>     "su2 \<in> existence_ivl0 x" "dist (flow0 x su2) v < duv" by auto
>   from filterlim_at_top_tendstoE[OF duv su, of su2]
>   obtain su3 where su3:"su3 > su2" "flow0 x su3 \<in> {a<--<b}"
>     "su3 \<in> existence_ivl0 x" "dist (flow0 x su3) u < duv" by auto
>   have *: "su1 \<le> su2" "{su1..su2} \<subseteq> existence_ivl0 x" using su1 su2
>      apply linarith
>     by (metis atLeastatMost_empty_iff empty_iff mvar.closed_segment_subset_domain real_Icc_closed_segment su1(3) su2(3) subset_eq)
> 
> (* by construction *)
>   have d1: "dist (flow0 x su1) v \<ge> (dist u v)/2" using su1(4) duv unfolding duv_def
>     by (smt dist_triangle_half_r)
>   have "dist (flow0 x su1) u < dist u v" using su1(4) duv unfolding duv_def by linarith
>   from open_segment_separate_left[OF u(2) uv this su1(2)]
>   have su1l:"flow0 x su1 \<in> {a<--<v}" .
>   have "dist (flow0 x su2) v < dist v (flow0 x su1)" using d1
>     by (smt dist_commute duv_def su2(4))
>   from open_segment_separate_right[OF v(2) su1l this su2(2)]
>   have su2l:"flow0 x su2 \<in> {flow0 x su1<--<b}" .
>   then have su2ll:"flow0 x su2 \<in> {u<--<b}"
>     by (smt dist_commute dist_pos_lt duv_def open_segment_subsegment pos_half_less open_segment_separate_right su2(2) su2(4) u(2) uv v(2) unotv)
> 
>   have "dist (flow0 x su2) u \<ge> (dist u v)/2" using su2(4) duv unfolding duv_def
>     by (smt dist_triangle_half_r)
>   then have "dist (flow0 x su3) u < dist u (flow0 x su2)"
>     by (smt dist_commute duv_def su3(4)) 
>   from open_segment_separate_left[OF u(2) su2ll this su3(2)]
>   have su3l:"flow0 x su3 \<in> {a<--<flow0 x su2}" .
> 
>   from flow0_transversal_segment_monotone[OF transversal * su1(2) su2l su3(1) su3(3)]
>   have "flow0 x su3 \<notin> {a <--<flow0 x su2}" .
>   thus False using su3l by auto
> qed
> 
> 
> subsection \<open>Unique Intersection\<close>
> 
> text \<open>Perko Section 3.7 Remark 2\<close>
> lemma unique_transversal_segment_intersection:
>   assumes "transversal_segment a b"
>   assumes "{0..} \<subseteq> existence_ivl0 x"
>   assumes "u \<in> \<omega>_limit_set x \<inter> {a<--<b}"
>   shows "\<omega>_limit_set x \<inter> {a<--<b} = {u}"
> proof (rule ccontr)
>   assume "\<omega>_limit_set x \<inter> {a<--<b} \<noteq> {u}"
>   then
>   obtain v where uv: "u \<noteq> v"
>     and v: "\<omega>_limit_point x v" "v \<in> {a<--<b}" using assms unfolding \<omega>_limit_set_def
>     by fastforce
>   have u:"\<omega>_limit_point x u" "u \<in> {a<--<b}" using assms unfolding \<omega>_limit_set_def
>     by auto
>   show False using no_two_\<omega>_limit_points[OF \<open>transversal_segment a b\<close>]
>     by (smt dist_commute dist_in_open_segment open_segment_trichotomy u uv v assms)
> qed
> 
> text \<open>Adapted from Perko Section 3.7 Lemma 4 (+ Chicone )\<close>
> lemma periodic_imp_\<omega>_limit_set:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes "periodic_orbit y"
>     "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x"
>   shows "flow0 y `UNIV = \<omega>_limit_set x"
> proof (rule ccontr)
>   note y = \<open>periodic_orbit y\<close> \<open>flow0 y ` UNIV \<subseteq> \<omega>_limit_set x\<close>
>   from trapped_sol_right[OF assms(1-4)] 
>   have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
>   assume "flow0 y `UNIV \<noteq> \<omega>_limit_set x"
>   obtain p where p: "p \<in> \<omega>_limit_set x" "p \<notin> flow0 y ` UNIV"
>     using y(2) apply auto
>     using \<open>range (flow0 y) \<noteq> \<omega>_limit_set x\<close> by blast
>   from \<omega>_limit_set_in_compact_connected[OF assms(1-4)] have
>     wcon: "connected (\<omega>_limit_set x)" .
>   from \<omega>_limit_set_invariant have
>     "invariant (\<omega>_limit_set x)" .
>   from \<omega>_limit_set_in_compact_compact[OF assms(1-4)] have
>     "compact (\<omega>_limit_set x)" .
>   then have sc: "seq_compact (\<omega>_limit_set x)"
>     using compact_imp_seq_compact by blast
>   have y1:"closed (flow0 y ` UNIV)"
>     using closed_orbit_\<omega>_limit_set periodic_orbit_def \<omega>_limit_set_closed y(1) by auto
>   have y2: "flow0 y ` UNIV \<noteq> {}" by simp 
>   let ?py = "infdist p (range (flow0 y))"
>   have "0 < ?py"
>     using y1 y2 p(2)
>     by (rule infdist_pos_not_in_closed)
>   have "\<forall>n::nat. \<exists>z. z \<in> \<omega>_limit_set x - flow0 y ` UNIV \<and>
>     infdist z (flow0 y ` UNIV) < ?py/2^n"
>   proof (rule ccontr)
>     assume " \<not> (\<forall>n. \<exists>z. z \<in> \<omega>_limit_set x - range (flow0 y) \<and>
>                 infdist z (range (flow0 y))
>                 < infdist p (range (flow0 y)) / 2 ^ n) "
>     then obtain n where n: "(\<forall>z \<in> \<omega>_limit_set x - range (flow0 y).
>       infdist z (range (flow0 y)) \<ge> ?py / 2 ^ n)"
>       using not_less by blast
>     define A where "A = flow0 y ` UNIV"
>     define B where "B = {z. infdist z (range (flow0 y)) \<ge> ?py / 2 ^ n}"
>     have Ac:"closed A" unfolding A_def using y1 by auto
>     have Bc:"closed B" unfolding B_def using infdist_closed by auto
>     have "A \<inter> B = {}"
>     proof (rule ccontr)
>       assume "A \<inter> B \<noteq> {}"
>       then obtain q where q: "q \<in> A" "q \<in> B" by blast
>       have qz:"infdist q (range(flow0 y)) = 0" using q(1) unfolding A_def
>         by simp
>       note \<open>0 < ?py\<close>
>       moreover have "2 ^ n > (0::real)" by auto
>       ultimately have "infdist p (range (flow0 y)) / 2 ^ n > (0::real)"
>         by simp
>       then have qnz: "infdist q(range (flow0 y)) > 0" using q(2) unfolding B_def
>         by auto
>       show False using qz qnz by auto
>     qed
>     then have a1:"A \<inter> B \<inter> \<omega>_limit_set x = {}" by auto
>     have "\<omega>_limit_set x - range(flow0 y) \<subseteq> B" using n B_def by blast
>     then have a2:"\<omega>_limit_set x \<subseteq> A \<union> B" using A_def by auto
>     from connected_closedD[OF wcon a1 a2 Ac Bc]
>     have "A \<inter> \<omega>_limit_set x = {} \<or> B \<inter> \<omega>_limit_set x = {}" .
>     moreover {
>       assume "A \<inter> \<omega>_limit_set x = {}"
>       then have False unfolding A_def using y(2) by blast
>     }
>     moreover {
>       assume "B \<inter> \<omega>_limit_set x = {}"
>       then have False unfolding B_def using p
>         using A_def B_def a2 by blast
>     }
>     ultimately show False by blast
>   qed
>   then obtain s where s: "\<forall>n::nat. (s::nat \<Rightarrow> _) n \<in> \<omega>_limit_set x - flow0 y ` UNIV \<and>
>                       infdist (s n) (flow0 y ` UNIV) < ?py/2^n"
>     by metis
>   then have "\<forall>n. s n \<in> \<omega>_limit_set x" by blast
>   from seq_compactE[OF sc this]
>   obtain l r where lr: "l \<in> \<omega>_limit_set x" "strict_mono r" "(s \<circ> r) \<longlonglongrightarrow> l" by blast
>   have "\<And>n. infdist (s n) (range (flow0 y)) \<le> ?py / 2 ^ n" using s
>     using less_eq_real_def by blast
>   then have "\<And>n. norm(infdist (s n) (range (flow0 y))) \<le> ?py / 2 ^ n"
>     by (auto simp add: infdist_nonneg)
>   from LIMSEQ_norm_0_pow[OF \<open>0 < ?py\<close> _ this]
>   have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> s) \<longlonglongrightarrow> 0"
>     by (auto simp add:o_def)
>   from LIMSEQ_subseq_LIMSEQ[OF this lr(2)]
>   have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> (s \<circ> r)) \<longlonglongrightarrow> 0" by (simp add: o_assoc)
>   moreover have "((\<lambda>z. infdist z (flow0 y ` UNIV)) \<circ> (s \<circ> r)) \<longlonglongrightarrow> infdist l (flow0 y ` UNIV)"
>     by (auto intro!: tendsto_eq_intros tendsto_compose_at[OF lr(3)])
>   ultimately have "infdist l (flow0 y `UNIV) = 0" using LIMSEQ_unique by auto
>   then have lu: "l \<in> flow0 y ` UNIV" using in_closed_iff_infdist_zero[OF y1 y2] by auto
>   then have l1:"l \<in> X"
>     using closed_orbit_global_existence periodic_orbit_def y(1) by auto
>       (* TODO: factor out as periodic_orbitE *)
>   have l2:"f l \<noteq> 0"
>     by (smt \<open>l \<in> X\<close> \<open>l \<in> range (flow0 y)\<close> closed_orbit_global_existence fixed_point_imp_closed_orbit_period_zero(2) fixpoint_sol(2) image_iff local.flows_reverse periodic_orbit_def y(1))
>   from transversal_segment_exists[OF l1 l2]
>   obtain a b where ab: "transversal_segment a b" "l \<in> {a<--<b}" by blast
>   then have "l \<in> \<omega>_limit_set x \<inter> {a<--<b}" using lr by auto
>   from unique_transversal_segment_intersection[OF ab(1) ex_pos this]
>   have luniq: "\<omega>_limit_set x \<inter> {a<--<b} = {l} " .
>   from cross_time_continuous[OF ab, of 1]
>   obtain d t where dt: "0 < d"
>     "(\<And>y. y \<in> ball l d \<Longrightarrow> flow0 y (t y) \<in> {a<--<b})"
>     "(\<And>y. y \<in> ball l d \<Longrightarrow> \<bar>t y\<bar> < 1)"
>     "continuous_on (ball l d) t" "t l = 0"
>     by auto
>   obtain n where "(s \<circ> r) n \<in> ball l d" using lr(3) dt(1) unfolding LIMSEQ_iff_nz
>     by (metis dist_commute mem_ball order_refl)
>   then have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> {a<--<b}" using dt by auto
>   moreover have sr: "(s \<circ> r) n \<in> \<omega>_limit_set x" "(s \<circ> r) n \<notin> flow0 y ` UNIV"
>     using s by auto
>   moreover have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> \<omega>_limit_set x"
>     using \<open>invariant (\<omega>_limit_set x)\<close> calculation unfolding invariant_def trapped_def
>     by (smt \<omega>_limit_set_in_compact_subset \<open>invariant (\<omega>_limit_set x)\<close> assms(1-4) invariant_def order_trans range_eqI subsetD trapped_iff_on_existence_ivl0 trapped_sol)
>   ultimately have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) \<in> \<omega>_limit_set x \<inter> {a<--<b}" by auto
>   from unique_transversal_segment_intersection[OF ab(1) ex_pos this]
>   have "flow0 ((s \<circ> r) n) (t ((s \<circ> r) n )) = l" using luniq by auto
>   then have "((s \<circ> r) n) = flow0 l (-(t ((s \<circ> r) n ))) "
>     by (smt UNIV_I \<open>(s \<circ> r) n \<in> \<omega>_limit_set x\<close> flows_reverse \<omega>_limit_set_in_compact_existence assms(1-4)) 
>   thus False using sr(2) lu
>       \<open>flow0 ((s \<circ> r) n) (t ((s \<circ> r) n)) = l\<close> \<open>flow0 ((s \<circ> r) n) (t ((s \<circ> r) n)) \<in> \<omega>_limit_set x\<close>
>       closed_orbit_global_existence image_iff local.flow_trans periodic_orbit_def \<omega>_limit_set_in_compact_existence range_eqI assms y(1)
>     by smt
> qed
> 
> end context c1_on_open_R2 begin
> 
> lemma \<alpha>_limit_crossings:
>   assumes "transversal_segment a b"
>   assumes pos_ex: "{..0} \<subseteq> existence_ivl0 x"
>   assumes "\<alpha>_limit_point x p"
>   assumes "p \<in> {a<--<b}"
>   obtains s where
>     "s \<longlonglongrightarrow>\<^bsub>\<^esub> -\<infinity>"
>     "(flow0 x \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>\<^sub>F n in sequentially.
>     flow0 x (s n) \<in> {a<--<b} \<and>
>     s n \<in> existence_ivl0 x"
> proof -
>   from pos_ex have "{0..} \<subseteq> uminus ` existence_ivl0 x" by force
>   from rev.\<omega>_limit_crossings[unfolded rev_transversal_segment rev_existence_ivl_eq0 rev_eq_flow
>       \<alpha>_limit_point_eq_rev[symmetric], OF assms(1) this assms(3,4)]
>   obtain s where "filterlim s at_top sequentially" "((\<lambda>t. flow0 x (- t)) \<circ> s) \<longlonglongrightarrow> p"
>     "\<forall>\<^sub>F n in sequentially. flow0 x (- s n) \<in> {a<--<b} \<and> s n \<in> uminus ` existence_ivl0 x" .
>   then have "filterlim (-s) at_bot sequentially"
>     "(flow0 x \<circ> (-s)) \<longlonglongrightarrow> p"
>     "\<forall>\<^sub>F n in sequentially. flow0 x ((-s) n) \<in> {a<--<b} \<and> (-s) n \<in> existence_ivl0 x"
>     by (auto simp: fun_Compl_def o_def filterlim_uminus_at_top)
>   then show ?thesis ..
> qed
> 
> text \<open>If a positive limit point has a regular point in its positive limit set then it is periodic\<close>
> lemma \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes y: "y \<in> \<omega>_limit_set x" "f y \<noteq> 0"
>   assumes z: "z \<in> \<omega>_limit_set y \<union> \<alpha>_limit_set y" "f z \<noteq> 0"
>   shows "periodic_orbit y \<and> flow0 y ` UNIV = \<omega>_limit_set x"
> proof -
>   from trapped_sol_right[OF assms(1-4)] have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
>   from \<omega>_limit_set_in_compact_existence[OF assms(1-4) y(1)]
>   have yex: "existence_ivl0 y = UNIV" .
>   from \<omega>_limit_set_invariant
>   have "invariant (\<omega>_limit_set x)" .
>   then have yinv: "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x" using yex unfolding invariant_def
>     using trapped_iff_on_existence_ivl0 y(1) by blast 
> 
>   have zy: "\<omega>_limit_point y z \<or> \<alpha>_limit_point y z"
>     using z unfolding \<omega>_limit_set_def \<alpha>_limit_set_def by auto
> 
>   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
>     \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained[OF assms(1-4)]
>   have zx:"z \<in> \<omega>_limit_set x" using zy y
>     using z(1) by blast
>   then have "z \<in> X"
>     by (metis UNIV_I local.existence_ivl_initial_time_iff \<omega>_limit_set_in_compact_existence assms(1-4))
>   from transversal_segment_exists[OF this z(2)]
>   obtain a b where ab: "transversal_segment a b" "z \<in> {a<--<b}" by blast
> 
>   from zy
>   obtain t1 t2 where t1: "flow0 y t1 \<in> {a<--<b}" and t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
>   proof
>     assume zy: "\<omega>_limit_point y z"
>     from \<omega>_limit_crossings[OF ab(1) _ zy ab(2), unfolded yex]
>     obtain s where s: "filterlim s at_top sequentially"
>       "(flow0 y \<circ> s) \<longlonglongrightarrow> z"
>       "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b}"
>       by auto
>     from eventually_happens[OF this(3)] obtain t1 where t1: "flow0 y t1 \<in> {a<--<b}" by auto
>     have "\<forall>\<^sub>F n in sequentially. s n > t1"
>       using filterlim_at_top_dense s(1) by auto
>     with s(3) have "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b} \<and> s n > t1"
>       by eventually_elim simp
>     from eventually_happens[OF this] obtain t2 where t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
>       by auto
>     from t1 this show ?thesis ..
>   next
>     assume zy: "\<alpha>_limit_point y z"
>     from \<alpha>_limit_crossings[OF ab(1) _ zy ab(2), unfolded yex]
>     obtain s where s: "filterlim s at_bot sequentially"
>       "(flow0 y \<circ> s) \<longlonglongrightarrow> z"
>       "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b}"
>       by auto
>     from eventually_happens[OF this(3)] obtain t1 where t1: "flow0 y t1 \<in> {a<--<b}" by auto
>     have "\<forall>\<^sub>F n in sequentially. s n < t1"
>       using filterlim_at_bot_dense s(1) by auto
>     with s(3) have "\<forall>\<^sub>F n in sequentially. flow0 y (s n) \<in> {a<--<b} \<and> s n < t1"
>       by eventually_elim simp
>     from eventually_happens[OF this] obtain t2 where t2: "flow0 y t2 \<in> {a<--<b}" and "t1 \<noteq> t2"
>       by auto
>     from t1 this show ?thesis ..
>   qed
>   have "flow0 y t1 \<in> \<omega>_limit_set x \<inter> {a<--<b}" using t1 UNIV_I yinv by auto
>   moreover have "flow0 y t2 \<in> \<omega>_limit_set x \<inter> {a<--<b}" using t2 UNIV_I yinv by auto
>   ultimately have feq:"flow0 y t1 = flow0 y t2"
>     using unique_transversal_segment_intersection[OF \<open>transversal_segment a b\<close> ex_pos]
>     by blast
>   have "t1 \<noteq> t2" "t1 \<in> existence_ivl0 y" "t2 \<in> existence_ivl0 y" using \<open>t1 \<noteq>  t2\<close>
>       apply blast
>      apply (simp add: yex)
>     by (simp add: yex)
>   from periodic_orbitI[OF this feq y(2)]
>   have 1: "periodic_orbit y" .
>   from periodic_imp_\<omega>_limit_set[OF assms(1-4) this yinv]
>   have 2: "flow0 y` UNIV = \<omega>_limit_set x" .
>   show ?thesis using 1 2 by auto
> qed
> 
> subsection \<open>Poincare Bendixson Theorems\<close>
> text \<open>Perko Section 3.7 Theorem 1\<close>
> theorem poincare_bendixson:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes "0 \<notin> f ` (\<omega>_limit_set x)"
>   obtains y where "periodic_orbit y"
>     "flow0 y ` UNIV = \<omega>_limit_set x"
> proof -
>   note f = \<open>0 \<notin> f ` (\<omega>_limit_set x)\<close>
>   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-4)]
>   obtain y where y: "y \<in> \<omega>_limit_set x" by fastforce
>   from \<omega>_limit_set_in_compact_existence[OF  assms(1-4) y]
>   have yex: "existence_ivl0 y = UNIV" .
>   from \<omega>_limit_set_invariant
>   have "invariant (\<omega>_limit_set x)" .
>   then have yinv: "flow0 y ` UNIV \<subseteq> \<omega>_limit_set x" using yex unfolding invariant_def
>     using trapped_iff_on_existence_ivl0 y by blast
>   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
>   have "\<omega>_limit_set x \<subseteq> K" .
>   then have "flow0 y ` UNIV \<subseteq> K" using yinv by auto
>   then have yk:"trapped_forward y K"
>     by (simp add: image_subsetI range_subsetD trapped_forward_def)
>   have "y \<in> X"
>     by (simp add: local.mem_existence_ivl_iv_defined(2) yex)
> 
>   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-2) this _]
>   obtain z where z: "z \<in> \<omega>_limit_set y" using yk by blast
>   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
>   have zx:"z \<in> \<omega>_limit_set x" using \<open>z \<in> \<omega>_limit_set y\<close> y by auto
> 
>   have yreg : "f y \<noteq> 0" using f y
>     by (metis rev_image_eqI)
>   have zreg : "f z \<noteq> 0" using f zx
>     by (metis rev_image_eqI) 
>   from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) y yreg _ zreg] z
>   show ?thesis using that by blast
> qed
> 
> lemma fixed_point_in_\<omega>_limit_set_imp_\<omega>_limit_set_singleton_fixed_point:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes fp: "yfp \<in> \<omega>_limit_set x" "f yfp = 0"
>   assumes zpx: "z \<in> \<omega>_limit_set x"
>   assumes finite_fp: "finite {y \<in> K. f y = 0}" (is "finite ?S")
>   shows "(\<exists>p1 \<in> \<omega>_limit_set x. f p1 = 0 \<and> \<omega>_limit_set z = {p1}) \<and>
>     (\<exists>p2 \<in> \<omega>_limit_set x. f p2 = 0 \<and> \<alpha>_limit_set z = {p2})"
> proof -
>   let ?weq = "{y \<in> \<omega>_limit_set x. f y = 0}"
>   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
>   have wxK: "\<omega>_limit_set x \<subseteq> K" .
>   from \<omega>_limit_set_in_compact_\<omega>_limit_set_contained[OF assms(1-4)]
>   have zx: "\<omega>_limit_set z \<subseteq> \<omega>_limit_set x" using zpx by auto
>   have zX: "z \<in> X" using subset_trans[OF wxK assms(2)]
>     by (metis subset_iff zpx)
>   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
>   have "?weq \<subseteq> ?S"
>     by (smt Collect_mono_iff Int_iff inf.absorb_iff1)
>   then have "finite ?weq" using \<open>finite ?S\<close>
>     by (blast intro: rev_finite_subset) 
> 
>   consider "f z = 0" | "f z \<noteq> 0" by auto
>   then show ?thesis
>   proof cases
>     assume "f z = 0"
>     from fixed_point_imp_\<omega>_limit_set[OF zX this]
>       fixed_point_imp_\<alpha>_limit_set[OF zX this]
>     show ?thesis
>       by (metis (mono_tags) \<open>f z = 0\<close> zpx)
>   next
>     assume "f z \<noteq> 0"
>     have zweq: "\<omega>_limit_set z \<subseteq> ?weq"
>       apply clarsimp
>     proof (rule ccontr)
>       fix k assume k: "k \<in> \<omega>_limit_set z" "\<not> (k \<in> \<omega>_limit_set x \<and> f k = 0)"
>       then have "f k \<noteq> 0" using zx k by auto
>       from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) zpx \<open>f z \<noteq> 0\<close> _ this] k(1)
>       have "periodic_orbit z" "range(flow0 z) = \<omega>_limit_set x" by auto
>       then have "0 \<notin> f ` (\<omega>_limit_set x)"
>         by (metis image_iff periodic_orbit_imp_flow0_regular)
>       thus False using fp
>         by (metis (mono_tags, lifting) empty_Collect_eq image_eqI)
>     qed
>     have zweq0: "\<alpha>_limit_set z \<subseteq> ?weq"
>       apply clarsimp
>     proof (rule ccontr)
>       fix k assume k: "k \<in> \<alpha>_limit_set z" "\<not> (k \<in> \<omega>_limit_set x \<and> f k = 0)"
>       then have "f k \<noteq> 0" using zx k
>           \<omega>_limit_set_in_compact_\<alpha>_limit_set_contained[OF assms(1-4), of z] zpx
>         by auto
>       from \<omega>_limit_point_\<omega>_limit_set_regular_imp_periodic[OF assms(1-4) zpx \<open>f z \<noteq> 0\<close> _ this] k(1)
>       have "periodic_orbit z" "range(flow0 z) = \<omega>_limit_set x" by auto
>       then have "0 \<notin> f ` (\<omega>_limit_set x)"
>         by (metis image_iff periodic_orbit_imp_flow0_regular)
>       thus False using fp
>         by (metis (mono_tags, lifting) empty_Collect_eq image_eqI)
>     qed
>     from \<omega>_limit_set_in_compact_existence[OF assms(1-4) zpx]
>     have zex: "existence_ivl0 z = UNIV" .
>     from \<omega>_limit_set_invariant
>     have "invariant (\<omega>_limit_set x)" .
>     then have zinv: "flow0 z ` UNIV \<subseteq> \<omega>_limit_set x" using zex unfolding invariant_def
>       using trapped_iff_on_existence_ivl0 zpx by blast
>     then have "flow0 z ` UNIV \<subseteq> K" using wxK by auto
>     then have a2: "trapped_forward z K" "trapped_backward z K"
>       using trapped_def trapped_iff_on_existence_ivl0 apply fastforce
>       using \<open>range (flow0 z) \<subseteq> K\<close> trapped_def trapped_iff_on_existence_ivl0 by blast
>     have a3: "finite (\<omega>_limit_set z)"
>       by (metis \<open>finite ?weq\<close> finite_subset zweq)
>     from finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-2) zX a2(1) a3]
>     obtain p1 where p1: "\<omega>_limit_set z = {p1}" "f p1 = 0" by blast
>     then have "p1 \<in> ?weq" using zweq by blast
>     moreover
>     have "finite (\<alpha>_limit_set z)"
>       by (metis \<open>finite ?weq\<close> finite_subset zweq0)
>     from finite_\<alpha>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-2) zX a2(2) this]
>     obtain p2 where p2: "\<alpha>_limit_set z = {p2}" "f p2 = 0" by blast
>     then have "p2 \<in> ?weq" using zweq0 by blast
>     ultimately show ?thesis
>       by (simp add: p1 p2)
>   qed
> qed
> 
> end context c1_on_open_R2 begin
> 
> text \<open>Perko Section 3.7 Theorem 2\<close>
> theorem poincare_bendixson_general:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> X" "trapped_forward x K"
>   assumes "S = {y \<in> K. f y = 0}" "finite S"
>   shows
>     "(\<exists>y \<in> S. \<omega>_limit_set x = {y}) \<or>
>   (\<exists>y. periodic_orbit y \<and>
>     flow0 y ` UNIV = \<omega>_limit_set x) \<or>
>   (\<exists>P R. \<omega>_limit_set x = P \<union> R \<and>
>     P \<subseteq> S \<and> 0 \<notin> f ` R \<and> R \<noteq> {} \<and>
>     (\<forall>z \<in> R.
>       (\<exists>p1 \<in> P. \<omega>_limit_set z = {p1}) \<and>
>       (\<exists>p2 \<in> P. \<alpha>_limit_set z = {p2})))"
> proof -
>   note S = \<open>S = {y \<in> K. f y = 0}\<close>
>   let ?wreg = "{y \<in> \<omega>_limit_set x. f y \<noteq> 0}"
>   let ?weq = "{y \<in> \<omega>_limit_set x. f y = 0}"
>   have wreqweq: "?wreg \<union> ?weq = \<omega>_limit_set x"
>     by (smt Collect_cong Collect_disj_eq mem_Collect_eq \<omega>_limit_set_def)
> 
>   from trapped_sol_right[OF assms(1-4)] have ex_pos: "{0..} \<subseteq> existence_ivl0 x" by blast
>   from \<omega>_limit_set_in_compact_subset[OF assms(1-4)]
>   have wxK: "\<omega>_limit_set x \<subseteq> K" .
>   then have "?weq \<subseteq> S" using S
>     by (smt Collect_mono_iff Int_iff inf.absorb_iff1)
>   then have "finite ?weq" using \<open>finite S\<close>
>     by (metis rev_finite_subset) 
>   from \<omega>_limit_set_invariant
>   have xinv: "invariant (\<omega>_limit_set x)" .
> 
>   from \<omega>_limit_set_in_compact_nonempty[OF assms(1-4)] wreqweq
>   consider "?wreg = {}" |
>     "?weq = {}" |
>     "?weq \<noteq> {}" "?wreg \<noteq> {}" by auto
>   then show ?thesis
>   proof cases
>     (* If w has no regular points then it is equal to a single unique fixed point *)
>     assume "?wreg = {}"
>     then have "finite (\<omega>_limit_set x)"
>       by (metis (mono_tags, lifting) \<open>{y \<in> \<omega>_limit_set x. f y = 0} \<subseteq> S\<close> \<open>finite S\<close> rev_finite_subset sup_bot.left_neutral wreqweq)
>     from finite_\<omega>_limit_set_in_compact_imp_unique_fixed_point[OF assms(1-4) this]
>     obtain y where y: "\<omega>_limit_set x = {y}" "f y = 0" by blast
>     then have "y \<in> S"
>       by (metis Un_empty_left \<open>?weq \<subseteq> S\<close> \<open>?wreg = {}\<close> insert_subset wreqweq)
>     then show ?thesis using y by auto
>   next
>     (* If w has no fixed points, then the Poincare Bendixson theorem applies *)
>     assume "?weq = {}"
>     then have " 0 \<notin> f ` \<omega>_limit_set x"
>       by (smt empty_Collect_eq imageE)
>     from poincare_bendixson[OF assms(1-4) this]
>     have "(\<exists>y. periodic_orbit y \<and> flow0 y ` UNIV = \<omega>_limit_set x)"
>       by metis
>     then show ?thesis by blast
>   next
>     (* Otherwise, all points in the limit set converge to a finite subset of the fixed points *)
>     assume "?weq \<noteq> {}" "?wreg \<noteq> {}"
>     then obtain yfp where yfp: "yfp \<in> \<omega>_limit_set x" "f yfp = 0" by auto
>     have "0 \<notin> f ` ?wreg" by auto
>     have "(\<exists>p1\<in>\<omega>_limit_set x. f p1 = 0 \<and> \<omega>_limit_set z = {p1}) \<and>
>       (\<exists>p2\<in>\<omega>_limit_set x. f p2 = 0 \<and> \<alpha>_limit_set z = {p2})"
>       if zpx: "z \<in> \<omega>_limit_set x" for z
>       using fixed_point_in_\<omega>_limit_set_imp_\<omega>_limit_set_singleton_fixed_point[
>           OF assms(1-4) yfp zpx \<open>finite S\<close>[unfolded S]] by auto
>     then have "\<omega>_limit_set x = ?weq \<union> ?wreg \<and>
>         ?weq \<subseteq> S \<and> 0 \<notin> f ` ?wreg \<and> ?wreg \<noteq> {} \<and>
>         (\<forall>z \<in> ?wreg.
>          (\<exists>p1 \<in> ?weq. \<omega>_limit_set z = {p1}) \<and>
>          (\<exists>p2 \<in> ?weq. \<alpha>_limit_set z = {p2}))"
>       using wreqweq \<open>?weq \<subseteq> S\<close> \<open>?wreg \<noteq> {}\<close> \<open>0 \<notin> f ` ?wreg\<close>
>       by blast
>     then show ?thesis by blast
>   qed
> qed
> 
> corollary poincare_bendixson_applied:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "K \<noteq> {}" "positively_invariant K"
>   assumes "0 \<notin> f ` K"
>   obtains y where "periodic_orbit y" "flow0 y ` UNIV \<subseteq> K"
> proof -
>   from assms(1-4) obtain x where "x \<in> K" "x \<in> X" by auto
>   have *: "trapped_forward x K"
>     using assms(4) \<open>x \<in> K\<close>
>     by (auto simp: positively_invariant_def)
>   have subs: "\<omega>_limit_set x \<subseteq> K"
>     by (rule \<omega>_limit_set_in_compact_subset[OF assms(1-2) \<open>x \<in> X\<close> *])
>   with assms(5) have "0 \<notin> f ` \<omega>_limit_set x" by auto
>   from poincare_bendixson[OF assms(1-2) \<open>x \<in> X\<close> * this]
>   obtain y where "periodic_orbit y" "range (flow0 y) = \<omega>_limit_set x"
>     by force
>   then have "periodic_orbit y" "flow0 y ` UNIV \<subseteq> K" using subs by auto
>   then show ?thesis ..
> qed
> 
> (*
>   Limit cycles are periodic orbits that is the \<omega> (or \<alpha>)-limit set of some point not in the cycle.
>   As with periodic_orbit, limit_cycles are defined for a representative point y
> *)
> definition "limit_cycle y \<longleftrightarrow>
>   periodic_orbit y \<and>
>   (\<exists>x. x \<notin> flow0 y ` UNIV \<and>
>   (flow0 y ` UNIV = \<omega>_limit_set x \<or> flow0 y ` UNIV = \<alpha>_limit_set x))"
> 
> corollary poincare_bendixson_limit_cycle:
>   assumes "compact K" "K \<subseteq> X"
>   assumes "x \<in> K" "positively_invariant K"
>   assumes "0 \<notin> f ` K"
>   assumes "rev.flow0 x t \<notin> K"
>   obtains y where "limit_cycle y" "flow0 y ` UNIV \<subseteq> K"
> proof -
>   have "x \<in> X" using assms(2-3) by blast
>   have *: "trapped_forward x K"
>     using assms(3-4)
>     by (auto simp: positively_invariant_def)
>   have subs: "\<omega>_limit_set x \<subseteq> K"
>     by (rule \<omega>_limit_set_in_compact_subset[OF assms(1-2) \<open>x \<in> X\<close> *])
>   with assms(5) have "0 \<notin> f ` \<omega>_limit_set x" by auto
>   from poincare_bendixson[OF assms(1-2) \<open>x \<in> X\<close> * this]
>   obtain y where y: "periodic_orbit y" "range (flow0 y) = \<omega>_limit_set x"
>     by force
>   then have c2: "flow0 y ` UNIV \<subseteq> K" using subs by auto
>   have exy: "existence_ivl0 y = UNIV"
>     using closed_orbit_global_existence periodic_orbit_def y(1) by blast
>   have "x \<notin> flow0 y ` UNIV"
>   proof clarsimp
>     fix tt
>     assume "x = flow0 y tt"
>     then have "rev.flow0 (flow0 y tt) t \<notin> K" using assms(6) by auto
>     moreover have "rev.flow0 (flow0 y tt) t \<in> flow0 y ` UNIV" using exy unfolding rev_eq_flow
>       using UNIV_I \<open>x = flow0 y tt\<close> closed_orbit_\<omega>_limit_set closed_orbit_flow0 periodic_orbit_def y by auto
>     ultimately show False using c2 by blast
>   qed
>   then have "limit_cycle y" "flow0 y ` UNIV \<subseteq> K" using y c2 unfolding limit_cycle_def by auto
>   then show ?thesis ..
> qed
> 
> end
> 
> end
==========
Poincare_Disc
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Disc/Poincare_Between.thy ../../AFPs/afp-2020/thys/Poincare_Disc/Poincare_Between.thy
248c248
<         apply (rule_tac x="Re u' / Re x" in exI, simp add: divide_neg_pos sign_simps)
---
>         apply (rule_tac x="Re u' / Re x" in exI, simp add: divide_neg_pos algebra_split_simps)
282c282
<       by (auto simp add: divide_less_0_iff sign_simps)
---
>       by (auto simp add: divide_less_0_iff algebra_split_simps)
586,587c586
<       by (smt linordered_field_class.sign_simps(45) minus_divide_left zero_less_divide_iff zero_less_mult_iff)
<   
---
>       by (smt algebra_split_simps(24) minus_divide_left zero_less_divide_iff zero_less_mult_iff)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Disc/Poincare_Circles.thy ../../AFPs/afp-2020/thys/Poincare_Disc/Poincare_Circles.thy
83c83
<       by (smt arith_geo_mean_sqrt linordered_field_class.sign_simps(45) power_divide real_sqrt_four real_sqrt_pow2)
---
>       by (smt arith_geo_mean_sqrt power_divide real_sqrt_four real_sqrt_pow2 zero_le_mult_iff)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Poincare_Disc/Poincare.thy ../../AFPs/afp-2020/thys/Poincare_Disc/Poincare.thy
185c185
< definition "(uniformity_p_point :: (p_point \<times> p_point) filter) = (INF e:{0<..}. principal {(x, y). dist_class.dist x y < e})"
---
> definition "(uniformity_p_point :: (p_point \<times> p_point) filter) = (INF e\<in>{0<..}. principal {(x, y). dist_class.dist x y < e})"
==========
Polynomial_Factorization
Only in ../../AFPs/afp-2020/thys/Polynomial_Factorization: Lib
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Factorization/Missing_Polynomial_Factorial.thy ../../AFPs/afp-2020/thys/Polynomial_Factorization/Missing_Polynomial_Factorial.thy
22c22
< lemma gcd_smult: fixes f g :: "'a :: factorial_ring_gcd poly"
---
> lemma gcd_smult: fixes f g :: "'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
56c56,57
<   also have "\<dots> = gcd (?na * F) G * normalize H" unfolding gcd_mult_right gcd.commute[of G] by simp
---
>   also have "\<dots> = gcd (?na * F) G * normalize H" unfolding gcd_mult_right gcd.commute[of G]
>     by (simp add: normalize_mult)
84,85c85,88
< lemma primitive_part_idemp[simp]: "primitive_part (primitive_part f) = primitive_part f"
<   by (metis content_primitive_part primitive_part_eq_0_iff primitive_part_prim)
---
> lemma primitive_part_idemp[simp]:
>   fixes f :: "'a :: {semiring_gcd,normalization_semidom_multiplicative} poly"
>   shows "primitive_part (primitive_part f) = primitive_part f"
>   by (metis content_primitive_part[of f] primitive_part_eq_0_iff primitive_part_prim)
129c132,134
< lemma primitive_part_normalize: "primitive_part (normalize f) = normalize (primitive_part f)"
---
> lemma primitive_part_normalize: 
>   fixes f :: "'a :: {semiring_gcd,idom_divide,normalization_semidom_multiplicative} poly"
>   shows "primitive_part (normalize f) = normalize (primitive_part f)"
223c228
<   fixes fs :: "'a :: {factorial_semiring,semiring_Gcd} poly list"
---
>   fixes fs :: "'a :: {factorial_semiring,semiring_Gcd,normalization_semidom_multiplicative} poly list"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Factorization/Prime_Factorization.thy ../../AFPs/afp-2020/thys/Polynomial_Factorization/Prime_Factorization.thy
632a633
>   fixes A :: "'a :: {factorial_semiring_multiplicative} multiset"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Factorization/Square_Free_Factorization.thy ../../AFPs/afp-2020/thys/Polynomial_Factorization/Square_Free_Factorization.thy
80c80
<   assumes sep: "separable (f :: 'a::{field, factorial_ring_gcd} poly)" 
---
>   assumes sep: "separable (f :: 'a::{field, factorial_ring_gcd, semiring_gcd_mult_normalize} poly)" 
119c119
<   fixes fs :: "'a :: {field,euclidean_ring_gcd} poly set"
---
>   fixes fs :: "'a :: {field,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly set"
158c158
<   fixes f :: "'a :: {field,factorial_ring_gcd} poly"
---
>   fixes f :: "'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
200c200
< lemma square_free_imp_separable: fixes f :: "'a :: {field_char_0,factorial_ring_gcd} poly"
---
> lemma square_free_imp_separable: fixes f :: "'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
213c213
<   "square_free (f :: 'a :: {field_char_0,factorial_ring_gcd} poly) = separable f"
---
>   "square_free (f :: 'a :: {field_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) = separable f"
309c309
<   fixes as :: "('a :: {field_char_0,euclidean_ring_gcd} poly \<times> nat) set"
---
>   fixes as :: "('a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly \<times> nat) set"
361c361
< lemma coprime_generic: 
---
> lemma coprime_generic:
876c876,877
< lemma square_free_monic_poly: assumes "monic (p :: 'a :: {field_char_0, euclidean_ring_gcd} poly)"
---
> lemma square_free_monic_poly:
>   assumes "monic (p :: 'a :: {field_char_0, euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)"
883c884,885
< lemma yun_factorization_induct: assumes base: "\<And> bn cn. bn = 1 \<Longrightarrow> P bn cn"
---
> lemma yun_factorization_induct: 
>   assumes base: "\<And> bn cn. bn = 1 \<Longrightarrow> P bn cn"
887c889
<   and monic: "monic (p :: 'a :: {field_char_0,euclidean_ring_gcd} poly)"
---
>   and monic: "monic (p :: 'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly)"
911c913,914
< lemma yun_monic_factorization: fixes p :: "'a :: {field_char_0,euclidean_ring_gcd} poly" 
---
> lemma yun_monic_factorization:
>   fixes p :: "'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly" 
969c972
<   assumes "SORT_CONSTRAINT('a :: {field, factorial_ring_gcd})" 
---
>   assumes "SORT_CONSTRAINT('a :: {field, factorial_ring_gcd,semiring_gcd_mult_normalize})" 
1361c1364,1365
<   for hom :: "'a :: {field_char_0,euclidean_ring_gcd} \<Rightarrow> 'b :: {field_char_0,euclidean_ring_gcd}"
---
>   for hom :: "'a :: {field_char_0,field_gcd} \<Rightarrow>
>               'b :: {field_char_0,field_gcd}"
1397c1401,1402
<   "square_free (p :: 'a :: {field,factorial_ring_gcd} poly) \<Longrightarrow> degree p \<noteq> 0 \<Longrightarrow> square_free_factorization p (1,[(p,0)])"
---
>   "square_free (p :: 'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly) \<Longrightarrow> 
>      degree p \<noteq> 0 \<Longrightarrow> square_free_factorization p (1,[(p,0)])"
==========
Polynomial_Interpolation
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Polynomial.thy ../../AFPs/afp-2020/thys/Polynomial_Interpolation/Missing_Polynomial.thy
247c247
<   fixes p :: "'a :: {field,factorial_ring_gcd} poly"
---
>   fixes p :: "'a :: {field,factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
1265,1266c1265,1266
<       unfolding irreducible\<^sub>d_def
<       by (smt add.left_neutral degree_mult_not_eq leading_coeff_0_iff sign_simps(4) mult_eq_0_iff)
---
>       by (simp add: irreducible\<^sub>d_def)
>         (metis degree_mult_eq degree_mult_eq_0 mult.left_commute plus_nat.add_0)
1399c1399,1401
<   "monic (f::'a::{field,euclidean_ring_gcd} poly) \<Longrightarrow> irreducible f \<Longrightarrow> gcd f u \<in> {1,f}"
---
>   "monic (f::'a::{field,euclidean_ring_gcd,semiring_gcd_mult_normalize,
>                   normalization_euclidean_semiring_multiplicative} poly) \<Longrightarrow>
>    irreducible f \<Longrightarrow> gcd f u \<in> {1,f}"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Interpolation/Missing_Unsorted.thy ../../AFPs/afp-2020/thys/Polynomial_Interpolation/Missing_Unsorted.thy
176c176,177
<             unfolding mult_le_cancel_left1 using b p by (simp add:sign_simps one_le_inverse)
---
>             unfolding mult_le_cancel_left1 using b p
>             by (simp add: algebra_split_simps one_le_inverse)
261c262
<   by (simp add: Gcd_mult)
---
>   by (simp add: Gcd_mult abs_mult)
276c277
<   by (simp add: lcm_mult_left)
---
>   by (simp add: lcm_mult_left abs_mult)
281c282
<   by (simp add: Lcm_mult)
---
>   by (simp add: Lcm_mult abs_mult)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomial_Interpolation/Ring_Hom_Poly.thy ../../AFPs/afp-2020/thys/Polynomial_Interpolation/Ring_Hom_Poly.thy
371c371
<   for hom :: "'a :: {field,euclidean_ring_gcd} \<Rightarrow> 'b :: {field,euclidean_ring_gcd}"
---
>   for hom :: "'a :: {field_gcd} \<Rightarrow> 'b :: {field_gcd}"
==========
Polynomials
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Polynomials/MPoly_PM.thy ../../AFPs/afp-2020/thys/Polynomials/MPoly_PM.thy
440c440
<   where "indets p = UNION (keys p) keys"
---
>   where "indets p = \<Union> (keys ` keys p)"
2843c2843
<   assumes "x \<notin> UNION F indets"
---
>   assumes "x \<notin> \<Union> (indets ` F)"
==========
Prim_Dijkstra_Simple
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Prim_Dijkstra_Simple/Common.thy ../../AFPs/afp-2020/thys/Prim_Dijkstra_Simple/Common.thy
98c98
< lemma INF_of_enat_infty_iff1: "(INF x:A. enat (f x)) = \<infinity> \<longleftrightarrow> A={}"
---
> lemma INF_of_enat_infty_iff1: "(INF x \<in> A. enat (f x)) = \<infinity> \<longleftrightarrow> A={}"
105c105
<   "\<infinity> = (INF x:A. enat (f x)) \<longleftrightarrow> A={}"  
---
>   "\<infinity> = (INF x \<in> A. enat (f x)) \<longleftrightarrow> A={}"  
112c112
<   shows "(INF x:A. enat (f x)) = enat d \<longleftrightarrow> (\<exists>x\<in>A. d = f x \<and> (\<forall>y\<in>A. f x \<le> f y))"  
---
>   shows "(INF x \<in> A. enat (f x)) = enat d \<longleftrightarrow> (\<exists>x\<in>A. d = f x \<and> (\<forall>y\<in>A. f x \<le> f y))"  
131c131
<   shows "enat d = (INF x:A. enat (f x)) \<longleftrightarrow> (\<exists>x\<in>A. d = f x \<and> (\<forall>y\<in>A. f x \<le> f y))"  
---
>   shows "enat d = (INF x \<in> A. enat (f x)) \<longleftrightarrow> (\<exists>x\<in>A. d = f x \<and> (\<forall>y\<in>A. f x \<le> f y))"  
140c140
<   shows "\<exists>x\<in>S. (INF x:S. f x) = f x"
---
>   shows "\<exists>x\<in>S. (INF x \<in> S. f x) = f x"
147c147
<   \<Longrightarrow> a = (INF x:S. f x) \<longleftrightarrow> (if S={} then a=top else \<exists>x\<in>S. a=f x \<and> (\<forall>y\<in>S. a \<le> f y))"
---
>   \<Longrightarrow> a = (INF x \<in> S. f x) \<longleftrightarrow> (if S={} then a=top else \<exists>x\<in>S. a=f x \<and> (\<forall>y\<in>S. a \<le> f y))"
210,211d209
< 
< 
==========
Prime_Distribution_Elementary
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Prime_Distribution_Elementary/Partial_Zeta_Bounds.thy ../../AFPs/afp-2020/thys/Prime_Distribution_Elementary/Partial_Zeta_Bounds.thy
83,84c83,84
<       ultimately show "(\<lambda>b. (\<Sum>k=1..b. real k powr -s) - real b powr (1 - s) / (1 - s))
<                           \<longlonglongrightarrow> Re (zeta s)" by (rule Lim_transform_eventually)
---
>       ultimately show "(\<lambda>b. (\<Sum>k=1..b. real k powr -s) - real b powr (1 - s) / (1 - s)) \<longlonglongrightarrow> Re (zeta s)" 
>         by (blast intro: Lim_transform_eventually)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Prime_Distribution_Elementary/PNT_Consequences.thy ../../AFPs/afp-2020/thys/Prime_Distribution_Elementary/PNT_Consequences.thy
130c130
<     by (rule Lim_transform_eventually [rotated])
---
>     by (rule Lim_transform_eventually)
139c139
<     by (rule Lim_transform_eventually [rotated])
---
>     by (rule Lim_transform_eventually)
==========
Prime_Number_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Prime_Number_Theorem/Prime_Counting_Functions.thy ../../AFPs/afp-2020/thys/Prime_Number_Theorem/Prime_Counting_Functions.thy
949c949
<     by (intro integral_combine [symmetric] integrable_continuous_real)
---
>     by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] integrable_continuous_real)
1169,1180c1169,1179
<   from assms have "((\<lambda>x. \<pi> x * ln (\<pi> x) / x) \<longlongrightarrow> 1) at_top"
<     by (rule asymp_equivD_strong[OF _ eventually_mono[OF eventually_gt_at_top[of 1]]]) auto
<   hence "((\<lambda>x. ln (\<pi> x * ln (\<pi> x) / x)) \<longlongrightarrow> ln 1) at_top"
<     by (rule tendsto_ln) auto
<   moreover have "eventually (\<lambda>x. ln (\<pi> x * ln (\<pi> x) / x) =
<                    ln (\<pi> x) * (1 + ln (ln (\<pi> x)) / ln (\<pi> x) - ln x / ln (\<pi> x))) at_top"
<       (is "eventually (\<lambda>x. _ = _ * ?f x) _")
<     using eventually_gt_at_top[of 0] ev
<     by eventually_elim (simp add: field_simps ln_mult ln_div)
<   ultimately have "((\<lambda>x. ln (\<pi> x) * ?f x) \<longlongrightarrow> ln 1) at_top"
<     by (rule Lim_transform_eventually [rotated])
< 
---
>   let ?f = "\<lambda>x. 1 + ln (ln (\<pi> x)) / ln (\<pi> x) - ln x / ln (\<pi> x)"
>   have "((\<lambda>x. ln (\<pi> x) * ?f x) \<longlongrightarrow> ln 1) at_top"
>   proof (rule Lim_transform_eventually)
>     from assms have "((\<lambda>x. \<pi> x * ln (\<pi> x) / x) \<longlongrightarrow> 1) at_top"
>       by (rule asymp_equivD_strong[OF _ eventually_mono[OF eventually_gt_at_top[of 1]]]) auto
>     then show "((\<lambda>x. ln (\<pi> x * ln (\<pi> x) / x)) \<longlongrightarrow> ln 1) at_top"
>       by (rule tendsto_ln) auto
>     show "\<forall>\<^sub>F x in at_top. ln (\<pi> x * ln (\<pi> x) / x) = ln (\<pi> x) * ?f x"
>       using eventually_gt_at_top[of 0] ev
>       by eventually_elim (simp add: field_simps ln_mult ln_div)
>   qed
1188c1187
<     by (rule Lim_transform_eventually [rotated])
---
>     by (rule Lim_transform_eventually)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Prime_Number_Theorem/Prime_Number_Theorem_Library.thy ../../AFPs/afp-2020/thys/Prime_Number_Theorem/Prime_Number_Theorem_Library.thy
20,26d19
< (* TODO: replace in library *)
< lemma real_root_decreasing: "0 < n \<Longrightarrow> n \<le> N \<Longrightarrow> 1 \<le> x \<Longrightarrow> root N x \<le> root n x"
<   by (auto simp add: order_le_less real_root_strict_decreasing)
< 
< lemma real_root_increasing: "0 < n \<Longrightarrow> n \<le> N \<Longrightarrow> 0 \<le> x \<Longrightarrow> x \<le> 1 \<Longrightarrow> root n x \<le> root N x"
<   by (auto simp add: order_le_less real_root_strict_increasing)
< 
289c282
<     show ?rhs by (simp add: field_simps vector_add_divide_simps)
---
>     show ?rhs by (simp add: vector_add_divide_simps) (simp add: field_simps)
312c305
<   also have "(\<dots> has_integral I /\<^sub>R (Re b - Re a)) {0..1} \<longleftrightarrow> 
---
>   also have "(\<dots> has_integral I /\<^sub>R (Re b - Re a)) {0..1} \<longleftrightarrow>
878c871
<     
---
> 
972c965
<   assumes "a < b" 
---
>   assumes "a < b"
984c977
<     moreover from x have "nat \<lfloor>x\<rfloor> \<ge> a" "nat \<lfloor>x\<rfloor> < b" by linarith+ 
---
>     moreover from x have "nat \<lfloor>x\<rfloor> \<ge> a" "nat \<lfloor>x\<rfloor> < b" by linarith+
1348c1341
<     also have "(\<Sum>\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) = 
---
>     also have "(\<Sum>\<^sub>ak. (fds_nth f p / nat_power p s) ^ Suc k) =
1358c1351
<   also have "?this \<longleftrightarrow> (\<lambda>p. -(of_real (ln (real p)) * 
---
>   also have "?this \<longleftrightarrow> (\<lambda>p. -(of_real (ln (real p)) *
1371c1364
<      using bij_betw_primepows unfolding case_prod_unfold 
---
>      using bij_betw_primepows unfolding case_prod_unfold
1373c1366
<   also have "\<dots> = (\<Sum>\<^sub>a(p,k)\<in>(?P \<times> UNIV). 
---
>   also have "\<dots> = (\<Sum>\<^sub>a(p,k)\<in>(?P \<times> UNIV).
1376c1369
<        (auto simp: f.mult f.power mangoldt_def aprimedivisor_prime_power ln_realpow prime_gt_0_nat 
---
>        (auto simp: f.mult f.power mangoldt_def aprimedivisor_prime_power ln_realpow prime_gt_0_nat
1378c1371
<   also have "\<dots> = (\<Sum>\<^sub>ap | prime p. \<Sum>\<^sub>ak. 
---
>   also have "\<dots> = (\<Sum>\<^sub>ap | prime p. \<Sum>\<^sub>ak.
1385c1378
< qed    
---
> qed
1434c1427
<   "abs_conv_abscissa (f :: 'a :: dirichlet_series fds) \<le> d \<Longrightarrow> abs_conv_abscissa g \<le> d \<Longrightarrow> 
---
>   "abs_conv_abscissa (f :: 'a :: dirichlet_series fds) \<le> d \<Longrightarrow> abs_conv_abscissa g \<le> d \<Longrightarrow>
1475c1468
< qed 
---
> qed
1478c1471
<   assumes "continuous_on A f" "a > 0" 
---
>   assumes "continuous_on A f" "a > 0"
1487c1480
<   assumes "continuous (at x within A) f" "a > 0" 
---
>   assumes "continuous (at x within A) f" "a > 0"
1520c1513
<   
---
> 
1652c1645
<       using elim b' by (intro integral_combine [symmetric] assms) auto
---
>       using elim b' by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] assms) auto
1703c1696
<       using elim b' by (intro integral_combine [symmetric] assms) auto
---
>       using elim b' by (intro Henstock_Kurzweil_Integration.integral_combine [symmetric] assms) auto
1920c1913
<   show ?th2 using assms 
---
>   show ?th2 using assms
1942c1935
<       by (intro add_strict_right_mono mult_strict_left_mono) 
---
>       by (intro add_strict_right_mono mult_strict_left_mono)
2048c2041
< end
\ No newline at end of file
---
> end
==========
Priority_Queue_Braun
Only in ../../AFPs/afp-2020/thys/Priority_Queue_Braun: Priority_Queue_Braun2.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy ../../AFPs/afp-2020/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy
19c19
< Paulsons's implementation (with small simplifications), including the logarithmic bounds.\<close>
---
> Paulsons's implementation, with small simplifications.\<close>
40,47d39
< lemma get_min_in:
<   "h \<noteq> Leaf \<Longrightarrow> value h \<in> set_tree h"
< by(auto simp add: neq_Leaf_iff)
< 
< lemma get_min_min:
<   "\<lbrakk> heap h; x \<in> set_tree h \<rbrakk> \<Longrightarrow> value h \<le> x"
< by(cases h)(auto)
< 
49c41
< by (auto simp add: eq_Min_iff get_min_in get_min_min)
---
> by (auto simp add: eq_Min_iff neq_Leaf_iff)
68c60
< lemma set_insert[simp]: "set_tree(insert x t) = Set.insert x (set_tree t)"
---
> lemma set_insert[simp]: "set_tree(insert x t) = {x} \<union> (set_tree t)"
95,96c87,88
<   \<Longrightarrow> mset_tree t' = mset_tree t - {#x#}"
<   by (auto dest: del_left_mset_plus)
---
>   \<Longrightarrow> x \<in># mset_tree t \<and> mset_tree t' = mset_tree t - {#x#}"
> by (simp add: del_left_mset_plus)
100,101c92
<   by (induction t arbitrary: x t' rule: del_left.induct;
<     fastforce split: prod.splits)
---
> by(simp add: del_left_mset_plus flip: set_mset_tree)
120a112,113
> text \<open>Slightly simpler definition: \<open>_\<close> instead of @{const Leaf} because of Braun invariant.\<close>
> 
122,123c115,116
< "sift_down Leaf a Leaf = Node Leaf a Leaf" |
< "sift_down (Node Leaf x Leaf) a Leaf =
---
> "sift_down Leaf a _ = Node Leaf a Leaf" |
> "sift_down (Node Leaf x _) a Leaf =
187c180
< lemma mset_del_min: assumes "braun t" "heap t" "t \<noteq> Leaf"
---
> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf"
216c209
<   case (2 q) show ?case by (cases q) auto
---
>   case 2 show ?case by simp
Only in ../../AFPs/afp-2020/thys/Priority_Queue_Braun: Sorting_Braun.thy
==========
Priority_Search_Trees
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Priority_Search_Trees/PST_General.thy ../../AFPs/afp-2020/thys/Priority_Search_Trees/PST_General.thy
23c23
<   of the form @{term "Node l kp b r"} where \<open>l\<close> and \<open>r\<close> are subtrees, \<open>kp\<close> is 
---
>   of the form @{term "Node l (kp, b) r"} where \<open>l\<close> and \<open>r\<close> are subtrees, \<open>kp\<close> is 
26c26
<   of the form \<^term>\<open>Node l kp (b,kp') r\<close>.
---
>   of the form \<^term>\<open>Node l (kp, (b,kp')) r\<close>.
29c29
< type_synonym ('k,'p,'c) pstree = "('k\<times>'p, 'c \<times> ('k \<times> 'p)) tree"
---
> type_synonym ('k,'p,'c) pstree = "(('k\<times>'p) \<times> ('c \<times> ('k \<times> 'p))) tree"
38c38
< | "invpst (Node l x (_,mkp) r) \<longleftrightarrow> invpst l \<and> invpst r
---
> | "invpst (Node l (x, _,mkp) r) \<longleftrightarrow> invpst l \<and> invpst r
44c44
< "pst_getmin (Node _ _ (_,a) _) = a"
---
> "pst_getmin (Node _ (_, _,a) _) = a"
47c47
<   "invpst t \<Longrightarrow> t\<noteq>Leaf \<Longrightarrow> is_min2 (pst_getmin t) (set (inorder t))"
---
>   "invpst t \<Longrightarrow> t\<noteq>Leaf \<Longrightarrow> is_min2 (pst_getmin t) (set_tree t)"
57,59c57,59
<   \<^item> Every pattern @{term "Node l kp b r"} in \<open>pats\<close> and \<open>e\<close> is replaced by
<     @{term "Node l kp (b,DUMMY) r"} to obtain \<open>pats'\<close> and \<open>e\<^sub>2\<close>.
<   \<^item> To obtain \<open>e'\<close>, every expression @{term "Node l kp b r"} in \<open>e\<^sub>2\<close> is 
---
>   \<^item> Every pattern @{term "Node l (kp, b) r"} in \<open>pats\<close> and \<open>e\<close> is replaced by
>     @{term "Node l (kp, (b,DUMMY)) r"} to obtain \<open>pats'\<close> and \<open>e\<^sub>2\<close>.
>   \<^item> To obtain \<open>e'\<close>, every expression @{term "Node l (kp, b) r"} in \<open>e\<^sub>2\<close> is 
67,69c67,69
< | (Leaf,Node _ _ (_,kpr) _) \<Rightarrow> min2 a kpr
< | (Node _ _ (_,kpl) _,Leaf) \<Rightarrow> min2 a kpl
< | (Node _ _ (_,kpl) _,Node _ _ (_,kpr) _) \<Rightarrow> min2 a (min2 kpl kpr)"
---
> | (Leaf,Node _ (_, (_,kpr)) _) \<Rightarrow> min2 a kpr
> | (Node _ (_, (_,kpl)) _,Leaf) \<Rightarrow> min2 a kpl
> | (Node _ (_, (_,kpl)) _,Node _ (_, (_,kpr)) _) \<Rightarrow> min2 a (min2 kpl kpr)"
71c71
< definition "mkNode c l a r \<equiv> Node l a (c,min_kp a l r) r"
---
> definition "mkNode c l a r \<equiv> Node l (a, (c,min_kp a l r)) r"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Priority_Search_Trees/PST_RBT.thy ../../AFPs/afp-2020/thys/Priority_Search_Trees/PST_RBT.thy
25c25
< type_synonym ('k,'p) rbth = "('k\<times>'p,tcolor \<times> ('k \<times> 'p)) tree"
---
> type_synonym ('k,'p) rbth = "(('k\<times>'p) \<times> (tcolor \<times> ('k \<times> 'p))) tree"
27,28c27,28
< abbreviation R where "R mkp l a r \<equiv> Node l a (Red,mkp) r"
< abbreviation B where "B mkp l a r \<equiv> Node l a (Black,mkp) r"
---
> abbreviation R where "R mkp l a r \<equiv> Node l (a, Red,mkp) r"
> abbreviation B where "B mkp l a r \<equiv> Node l (a, Black,mkp) r"
47c47
< "paint c (Node l a (_,mkp) r) = Node l a (c,mkp) r"
---
> "paint c (Node l (a, (_,mkp)) r) = Node l (a, (c,mkp)) r"
85c85
< "color (Node _ _ (c,_) _) = c"
---
> "color (Node _ (_, (c,_)) _) = c"
106c106
< "del x (Node l (a,b) (c,_) r) = (case cmp x a of
---
> "del x (Node l ((a,b), (c,_)) r) = (case cmp x a of
121c121
< "bheight (Node l x (c,_) r) = (if c = Black then bheight l + 1 else bheight l)"
---
> "bheight (Node l (x, (c,_)) r) = (if c = Black then bheight l + 1 else bheight l)"
125c125
< "invc (Node l a (c,_) r) =
---
> "invc (Node l (a, (c,_)) r) =
130c130
< "invc2 (Node l a _ r) = (invc l \<and> invc r)"
---
> "invc2 (Node l (a, _) r) = (invc l \<and> invc r)"
134c134
< "invh (Node l x _ r) = (invh l \<and> invh r \<and> bheight l = bheight r)"
---
> "invh (Node l (x, _) r) = (invh l \<and> invh r \<and> bheight l = bheight r)"
337c337
< lemma neq_LeafD: "t \<noteq> Leaf \<Longrightarrow> \<exists>c l x r. t = Node c l x r"
---
> lemma neq_LeafD: "t \<noteq> Leaf \<Longrightarrow> \<exists>l x c r. t = Node l (x,c) r"
388c388
<   "rbt t \<Longrightarrow> t\<noteq>Leaf \<Longrightarrow> is_min2 (pst_getmin t) (set (inorder t))"
---
>   "rbt t \<Longrightarrow> t\<noteq>Leaf \<Longrightarrow> is_min2 (pst_getmin t) (set_tree t)"
==========
Probabilistic_Noninterference
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Probabilistic_Noninterference/Language_Semantics.thy ../../AFPs/afp-2020/thys/Probabilistic_Noninterference/Language_Semantics.thy
702c702
<   by (metis div_by_0 le_cases neq0_conv not_one_le_zero of_nat_0 sum_not_0 sum_equal)
---
>   by (metis div_by_0 le_cases neq0_conv not_one_le_zero of_nat_0 sum.neutral sum_equal)
==========
Probabilistic_Prime_Tests
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy ../../AFPs/afp-2020/thys/Probabilistic_Prime_Tests/Algebraic_Auxiliaries.thy
391c391,392
<   "size (prime_factorization n) = Suc 0 \<longleftrightarrow> prime_elem n"
---
>   fixes n :: "'a :: factorial_semiring_multiplicative"
>   shows "size (prime_factorization n) = Suc 0 \<longleftrightarrow> prime_elem n"
393d393
<   define u where "u = unit_factor n"
400,406c400,406
<   have "n = u * prod_mset (prime_factorization n)"
<     unfolding u_def by (rule prime_decomposition [symmetric])
<   with * have "n = u * p" by simp
<   also from p have "prime_elem \<dots>"
<     by (subst prime_elem_mult_unit_left)
<        (auto simp: u_def prime_imp_prime_elem in_prime_factors_iff)
<   finally show "prime_elem n" by auto
---
>   have "prime_elem (normalize p)"
>     using p by (auto simp: in_prime_factors_iff)
>   also have "p = prod_mset (prime_factorization n)"
>     using * by simp
>   also have "normalize \<dots> = normalize n"
>     by (rule prod_mset_prime_factorization_weak) auto
>   finally show "prime_elem n" by simp
440c440,442
< lemma one_prime_factor_iff_primepow: "card (prime_factors n) = Suc 0 \<longleftrightarrow> primepow (normalize n)"
---
> lemma one_prime_factor_iff_primepow:
>   fixes n :: "'a :: factorial_semiring_multiplicative"
>   shows "card (prime_factors n) = Suc 0 \<longleftrightarrow> primepow (normalize n)"
464a467
>   fixes x :: "'a :: factorial_semiring_multiplicative"
==========
Probabilistic_System_Zoo
Only in ../../AFPs/afp-2019/thys/Probabilistic_System_Zoo/document: BNFs
Only in ../../AFPs/afp-2019/thys/Probabilistic_System_Zoo/document: Hierarchy
Only in ../../AFPs/afp-2019/thys/Probabilistic_System_Zoo/document: Non_BNFs
Only in ../../AFPs/afp-2020/thys/Probabilistic_System_Zoo/document: root_bnfs.tex
Only in ../../AFPs/afp-2020/thys/Probabilistic_System_Zoo/document: root_non_bnfs.tex
==========
Probabilistic_Timed_Automata
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Probabilistic_Timed_Automata/library/Lib.thy ../../AFPs/afp-2020/thys/Probabilistic_Timed_Automata/library/Lib.thy
701c701,702
< using assms by (metis dual_order.trans frac_eq frac_lt_1 le_less not_le)
---
>   using assms less_trans [of "frac x" 1 x]
>   by (auto simp add: le_less frac_eq not_less frac_lt_1)
706c707
< using assms by (metis dual_order.trans frac_eq frac_of_int le_less of_int_simps(2))
---
>   using assms dual_order.trans frac_le_self by auto
==========
Projective_Geometry
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Projective_Geometry/Matroid_Rank_Properties.thy ../../AFPs/afp-2020/thys/Projective_Geometry/Matroid_Rank_Properties.thy
158c158
<         add.right_neutral add_Suc_right assms linorder_antisym_conv1 matroid_ax_2 matroid_ax_2_alt 
---
>         add.right_neutral add_Suc_right assms antisym_conv1 matroid_ax_2 matroid_ax_2_alt 
==========
Promela
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Promela/PromelaDatastructures.thy ../../AFPs/afp-2020/thys/Promela/PromelaDatastructures.thy
5c5
<   "../CAVA_Automata/CAVA_Base/Lexord_List"
---
>   CAVA_Base.Lexord_List
==========
Psi_Calculi
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Psi_Calculi/Semantics.thy ../../AFPs/afp-2020/thys/Psi_Calculi/Semantics.thy
10c10
<   BOut "'a::fs_name" "('a, 'b::fs_name, 'c::fs_name) psi" ("_ \<prec>' _" [110, 110] 110)
---
>   BOut "'a::fs_name" "('a, 'b::fs_name, 'c::fs_name) psi" ("_ \<prec>'' _" [110, 110] 110)
==========
Ptolemys_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Ptolemys_Theorem/Ptolemys_Theorem.thy ../../AFPs/afp-2020/thys/Ptolemys_Theorem/Ptolemys_Theorem.thy
7c7
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
==========
QHLProver
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/QHLProver/Matrix_Limit.thy ../../AFPs/afp-2020/thys/QHLProver/Matrix_Limit.thy
1406c1406
<       using tendsto_intros(12)[of "\<lambda>n. f n $$ (i, j)" "matrix_seq.lowner_lub f $$ (i, j)" sequentially "\<lambda>n. g n $$ (i, j)" "matrix_seq.lowner_lub g $$ (i, j)"] by auto
---
>       using tendsto_add[of "\<lambda>n. f n $$ (i, j)" "matrix_seq.lowner_lub f $$ (i, j)" sequentially "\<lambda>n. g n $$ (i, j)" "matrix_seq.lowner_lub g $$ (i, j)"] by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/QHLProver/Quantum_Hoare.thy ../../AFPs/afp-2020/thys/QHLProver/Quantum_Hoare.thy
1286c1286
<         unfolding seq_def seqlim_def using tendsto_intros(15)[OF limPm limm]  by auto
---
>         unfolding seq_def seqlim_def using tendsto_diff[OF limPm limm]  by auto
==========
Quaternions
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Quaternions/Quaternions.thy ../../AFPs/afp-2020/thys/Quaternions/Quaternions.thy
9c9,10
<   imports "HOL-Analysis.Analysis"
---
>   imports
>     "HOL-Analysis.Multivariate_Analysis"
==========
Random_Graph_Subgraph_Threshold
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Random_Graph_Subgraph_Threshold/Ugraph_Misc.thy ../../AFPs/afp-2020/thys/Random_Graph_Subgraph_Threshold/Ugraph_Misc.thy
175c175
< by (auto simp: image_iff)
---
>   by auto
249,250c249
<     by (rule Lim_transform_eventually) simp
< 
---
>     by (fastforce intro: Lim_transform_eventually)
==========
Refine_Imperative_HOL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Refine_Imperative_HOL/IICF/Impl/IICF_MS_Array_List.thy ../../AFPs/afp-2020/thys/Refine_Imperative_HOL/IICF/Impl/IICF_MS_Array_List.thy
5c5
<   "../../../Separation_Logic_Imperative_HOL/Examples/Default_Insts"
---
>   Separation_Logic_Imperative_HOL.Default_Insts
Only in ../../AFPs/afp-2020/thys/Refine_Imperative_HOL: Sepref_Basic
Only in ../../AFPs/afp-2020/thys/Refine_Imperative_HOL: Sepref_IICF
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Refine_Imperative_HOL/Sepref_Intf_Util.thy ../../AFPs/afp-2020/thys/Refine_Imperative_HOL/Sepref_Intf_Util.thy
853c853
<                 val ctxt = Variable.auto_fixes param_mop_t lthy 
---
>                 val ctxt = Proof_Context.augment param_mop_t lthy 
Only in ../../AFPs/afp-2020/thys/Refine_Imperative_HOL: Sepref_Prereq
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Refine_Imperative_HOL/Sepref.thy ../../AFPs/afp-2020/thys/Refine_Imperative_HOL/Sepref.thy
8c8
<   "../Separation_Logic_Imperative_HOL/Examples/Default_Insts"
---
>   Separation_Logic_Imperative_HOL.Default_Insts
==========
Relation_Algebra
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Relation_Algebra/Relation_Algebra.thy ../../AFPs/afp-2020/thys/Relation_Algebra/Relation_Algebra.thy
29c29
<     and unit :: "'a" ("1'")
---
>     and unit :: "'a" ("1''")
==========
Residuated_Lattices
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Residuated_Lattices/Involutive_Residuated.thy ../../AFPs/afp-2020/thys/Residuated_Lattices/Involutive_Residuated.thy
13c13
<   fixes uminus' :: "'a \<Rightarrow> 'a" ("-' _" [81] 80)
---
>   fixes uminus' :: "'a \<Rightarrow> 'a" ("-'' _" [81] 80)
==========
Root_Balanced_Tree
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy ../../AFPs/afp-2020/thys/Root_Balanced_Tree/Root_Balanced_Tree.thy
1809,1810c1809,1810
<       by(simp add: delete2_def2 t_delete2_def2 \<Phi>_wbalanced bal_tree)
<     also have "\<dots> = t_del x t + 4 * size t - \<Phi> t - 4*dl/cd"
---
>       by(simp add: delete2_def2 t_delete2_def2 \<Phi>_wbalanced bal_tree assms size_del)
>     also have "\<dots> = t_del x t + 4 * size t - \<Phi> t - 4*dl/cd"       
==========
ROOTS
0a1,2
> ADS_Functor
> AI_Planning_Languages_Semantics
2,3d3
< Auto2_HOL
< Auto2_Imperative_HOL
18a19
> Amicable_Numbers
26a28,30
> Attack_Trees
> Auto2_HOL
> Auto2_Imperative_HOL
27a32
> Automated_Stateful_Protocol_Verification
30a36
> BNF_CC
31a38
> Banach_Steinhaus
41c48,49
< BNF_CC
---
> BirdKMP
> Blue_Eyes
72a81
> Chandy_Lamport
84d92
< Completeness
85a94
> Completeness
98a108
> Core_SC_DOM
101a112
> CSP_RefTK
109a121
> Delta_System_Lemma
124d135
< Discrete_Summation
125a137
> Discrete_Summation
141,142c153,154
< Factored_Transition_System_Bounding
< Farkas
---
> Extended_Finite_State_Machine_Inference
> Extended_Finite_State_Machines
147a160
> Factored_Transition_System_Bounding
148a162
> Farkas
154a169
> Finite-Map-Extras
163a179
> Forcing
179a196
> Gaussian_Integers
187a205,207
> Goedel_HFSet_Semantic
> Goedel_HFSet_Semanticless
> Goedel_Incompleteness
223a244
> Inductive_Inference
229a251
> Irrational_Series_Erdos_Straus
231a254
> Isabelle_Marries_Dirac
232a256
> IsaGeoCoq
234a259
> JinjaDCI
245a271
> Knuth_Bendix_Order
253a280,281
> LTL_Master_Theorem
> LTL_Normal_Form
256d283
< LTL_Master_Theorem
259a287
> Lambda_Free_EPO
261a290
> Lambert_W
266d294
< Lambda_Free_EPO
267a296
> Laws_of_Large_Numbers
288a318
> Lucas_Theorem
289a320,321
> MFODL_Monitor_Optimized
> MFOTL_Monitor
293a326
> Matrices_for_ODEs
301,302d333
< MFODL_Monitor_Optimized
< MFOTL_Monitor
315d345
< Multirelations
316a347
> Multirelations
318a350
> Nash_Williams
335d366
< Open_Induction
336a368
> Open_Induction
342a375
> Ordinal_Partitions
344a378
> PAC_Checker
347d380
< Pell
355a389
> Pell
357a392
> Physical_Quantities
360a396,397
> Poincare_Bendixson
> Poincare_Disc
364,365d400
< Poincare_Bendixson
< Poincare_Disc
368a404
> Power_Sum_Polynomials
382d417
< Projective_Geometry
383a419
> Projective_Geometry
402d437
< Randomised_BSTs
403a439
> Randomised_BSTs
406a443
> Recursion-Addition
415a453,456
> Relational_Disjoint_Set_Forests
> Relational_Method
> Relational_Minimum_Spanning_Trees
> Relational_Paths
421a463
> Robinson_Arithmetic
425a468
> SC_DOM_Components
429a473
> Safe_Distance
439a484
> Shadow_SC_DOM
451a497
> Smith_Normal_Form
459a506
> Stateful_Protocol_Composition_and_Typing
480a528
> Syntax_Independent_Logic
487a536
> Topological_Semantics
503d551
< Universal_Turing_Machine
506d553
< UpDown_Scheme
507a555,556
> Universal_Turing_Machine
> UpDown_Scheme
511a561
> Verified_SAT_Based_AI_Planning
516a567
> WOOT_Strong_Eventual_Consistency
521d571
< WOOT_Strong_Eventual_Consistency
525,526d574
< Zeta_Function
< Zeta_3_Irrational
527a576,577
> Zeta_3_Irrational
> Zeta_Function
==========
Safe_OCL
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Safe_OCL/OCL_Examples.thy ../../AFPs/afp-2020/thys/Safe_OCL/OCL_Examples.thy
214,215c214
<   using zero_enat_def numeral_eq_enat
<   by (auto simp flip: enat_numeral simp: one_enat_def)
---
>   using zero_enat_def one_enat_def numeral_eq_enat by auto
==========
Saturation_Framework
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Saturation_Framework/Consequence_Relations_and_Inference_Systems.thy ../../AFPs/afp-2020/thys/Saturation_Framework/Consequence_Relations_and_Inference_Systems.thy
36c36
< lemma entail_unions: "(\<forall>i \<in> I. N \<Turnstile> Ni i) \<longleftrightarrow> N \<Turnstile> UNION I Ni"
---
> lemma entail_unions: "(\<forall>i \<in> I. N \<Turnstile> Ni i) \<longleftrightarrow> N \<Turnstile> \<Union> (Ni ` I)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Saturation_Framework/Labeled_Lifting_to_Non_Ground_Calculi.thy ../../AFPs/afp-2020/thys/Saturation_Framework/Labeled_Lifting_to_Non_Ground_Calculi.thy
212c212
<   "\<G>_set_L_q q N \<equiv> UNION N (\<G>_F_L_q q)"
---
>   "\<G>_set_L_q q N \<equiv> \<Union> (\<G>_F_L_q q ` N)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Saturation_Framework/Lifting_to_Non_Ground_Calculi.thy ../../AFPs/afp-2020/thys/Saturation_Framework/Lifting_to_Non_Ground_Calculi.thy
41c41
<   \<open>\<G>_set N \<equiv> UNION N \<G>_F\<close>
---
>   \<open>\<G>_set N \<equiv> \<Union> (\<G>_F ` N)\<close>
603c603
<   "\<G>_set_q q N \<equiv> UNION N (\<G>_F_q q)"
---
>   "\<G>_set_q q N \<equiv> \<Union> (\<G>_F_q q ` N)"
==========
Shivers-CFA
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Shivers-CFA/Computability.thy ../../AFPs/afp-2020/thys/Shivers-CFA/Computability.thy
148c148
< (* discrete_cpo, otherwise x \<mapsto> {x} not continous *)
---
> (* discrete_cpo, otherwise x \<mapsto> {x} not continuous *)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Shivers-CFA/FixTransform.thy ../../AFPs/afp-2020/thys/Shivers-CFA/FixTransform.thy
89c89
< Generally, lambda abstractions with discrete domain are continous and can be resolved immediately.
---
> Generally, lambda abstractions with discrete domain are continuous and can be resolved immediately.
==========
Sigma_Commit_Crypto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Sigma_Commit_Crypto/Rivest.thy ../../AFPs/afp-2020/thys/Sigma_Commit_Crypto/Rivest.thy
167c167
<         by (metis (no_types) \<open>[int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)\<close> cong_trans linordered_field_class.sign_simps(20) semiring_normalization_rules(7))
---
>         by (metis (no_types, hide_lams) Groups.mult_ac(2) \<open>[int a * int x1 - int a' * int x1 = int b' - int b] (mod int q)\<close> cong_def mod_diff_left_eq mod_diff_right_eq mod_mult_right_eq)
==========
Simpl
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Simpl/hoare.ML ../../AFPs/afp-2020/thys/Simpl/hoare.ML
1076c1076
<    fun mk_def_eq _ read_term name =
---
>    fun mk_def_eq thy read_term name =
1090a1091
>            val consts = Sign.consts_of thy;
1092c1093
<              YXML.string_of_body (Term_XML.Encode.term (map_types (K dummyT) eq));
---
>             YXML.string_of_body (Term_XML.Encode.term consts (Consts.dummy_types consts eq));
==========
Simplex
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Simplex/QDelta.thy ../../AFPs/afp-2020/thys/Simplex/QDelta.thy
11,13c11,12
< primrec qdfst :: "QDelta \<Rightarrow> rat"
<   where
<     "qdfst (QDelta a b) = a"
---
> primrec qdfst :: "QDelta \<Rightarrow> rat" where
>   "qdfst (QDelta a b) = a"
15,17c14,15
< primrec qdsnd :: "QDelta \<Rightarrow> rat"
<   where
<     "qdsnd (QDelta a b) = b"
---
> primrec qdsnd :: "QDelta \<Rightarrow> rat" where
>   "qdsnd (QDelta a b) = b"
==========
Skew_Heap
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Skew_Heap/Skew_Heap.thy ../../AFPs/afp-2020/thys/Skew_Heap/Skew_Heap.thy
26,33d25
< lemma get_min_in:
<   "h \<noteq> Leaf \<Longrightarrow> get_min h \<in> set_tree h"
< by(auto simp add: neq_Leaf_iff)
< 
< lemma get_min_min:
<   "\<lbrakk> heap h; x \<in> set_tree h \<rbrakk> \<Longrightarrow> get_min h \<le> x"
< by(cases h)(auto)
< 
35c27
< by (auto simp add: eq_Min_iff get_min_in get_min_min)
---
> by (auto simp add: eq_Min_iff neq_Leaf_iff)
==========
Skip_Lists
Only in ../../AFPs/afp-2019/thys/Skip_Lists: Draft.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Skip_Lists/Geometric_PMF.thy ../../AFPs/afp-2020/thys/Skip_Lists/Geometric_PMF.thy
48a49,50
>   hence "summable (\<lambda>x. (1 - p) ^ x * real x)"
>     by (rule summable_mult_D) (use assms in auto)
51c53,54
<     by (subst integrable_density) (auto simp: integrable_count_space_nat_iff mult_ac)
---
>     by (subst integrable_density)
>        (auto simp: integrable_count_space_nat_iff mult_ac)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Skip_Lists/Skip_List.thy ../../AFPs/afp-2020/thys/Skip_Lists/Skip_List.thy
426c426
<         using q by (metis greaterThanLessThan_iff powr_int powr_mult_base zero_le_floor)
---
>         using q by (subst powr_realpow [symmetric]) (auto simp: powr_add)
==========
Smooth_Manifolds
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Smooth_Manifolds/Analysis_More.thy ../../AFPs/afp-2020/thys/Smooth_Manifolds/Analysis_More.thy
3c3
<   imports "HOL-Analysis.Analysis"
---
>   imports "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
313,350d312
< lemma univ_second_countable:
<   obtains \<B> :: "'a::second_countable_topology set set"
<   where "countable \<B>" "\<And>C. C \<in> \<B> \<Longrightarrow> open C"
<     "\<And>S. open S \<Longrightarrow> \<exists>U. U \<subseteq> \<B> \<and> S = \<Union>U"
<   by (metis ex_countable_basis topological_basis_def)
< 
< proposition Lindelof:
<   fixes \<F> :: "'a::second_countable_topology set set"
<   assumes \<F>: "\<And>S. S \<in> \<F> \<Longrightarrow> open S"
<   obtains \<F>' where "\<F>' \<subseteq> \<F>" "countable \<F>'" "\<Union>\<F>' = \<Union>\<F>"
< proof -
<   obtain \<B> :: "'a set set"
<     where "countable \<B>" "\<And>C. C \<in> \<B> \<Longrightarrow> open C"
<       and \<B>: "\<And>S. open S \<Longrightarrow> \<exists>U. U \<subseteq> \<B> \<and> S = \<Union>U"
<     using univ_second_countable by auto
<   define \<D> where "\<D> \<equiv> {S. S \<in> \<B> \<and> (\<exists>U. U \<in> \<F> \<and> S \<subseteq> U)}"
<   have "countable \<D>"
<     apply (rule countable_subset [OF _ \<open>countable \<B>\<close>])
<     apply (force simp: \<D>_def)
<     done
<   have "\<And>S. \<exists>U. S \<in> \<D> \<longrightarrow> U \<in> \<F> \<and> S \<subseteq> U"
<     by (simp add: \<D>_def)
<   then obtain G where G: "\<And>S. S \<in> \<D> \<longrightarrow> G S \<in> \<F> \<and> S \<subseteq> G S"
<     by metis
<   have "\<Union>\<F> \<subseteq> \<Union>\<D>"
<     unfolding \<D>_def by (blast dest: \<F> \<B>)
<   moreover have "\<Union>\<D> \<subseteq> \<Union>\<F>"
<     using \<D>_def by blast
<   ultimately have eq1: "\<Union>\<F> = \<Union>\<D>" ..
<   have eq2: "\<Union>\<D> = \<Union> (G ` \<D>)"
<     using G eq1 by auto
<   show ?thesis
<     apply (rule_tac \<F>' = "G ` \<D>" in that)
<     using G \<open>countable \<D>\<close>  apply (auto simp: eq1 eq2)
<     done
< qed
< 
< 
403,413c365,366
<     from this(1) show ?case
<       apply rule
<       subgoal
<         apply (rule exI[where x=UNIV])
<         by (auto simp: generate_topology.UNIV)
<       subgoal
<         apply clarsimp
<         subgoal for B
<           apply (rule exI[where x="B"]) by (auto simp: generate_topology.Basis)
<         done
<       done
---
>     then show ?case
>       using generate_topology.UNIV generate_topology.Basis by blast
476c429
<   by (cases "finite S") (auto simp: support_on_def dest!: sum_not_0)
---
> by (cases "finite S") (auto simp: support_on_def, meson sum.neutral)
481c434
<   by (auto simp: support_on_def dest!: sum_not_0)
---
>   by (auto simp: support_on_def, meson sum.neutral)
1042,1050c995
<     apply (rule Lim_transform_eventually)
<     defer
<      apply assumption
<     subgoal premises prems
<       using prems(2)
<       apply eventually_elim 
<       apply auto
<       done
<     done
---
>     by (simp add: eventually_mono Lim_transform_eventually)
1150a1096,1104
> lemmas frechet_derivative_worksI = frechet_derivative_works[THEN iffD1]
> 
> lemma sin_differentiable_at: "(\<lambda>x. sin (f x::real)) differentiable at x within X"
>   if "f differentiable at x within X"
>   using differentiable_def has_derivative_sin that by blast
> 
> lemma cos_differentiable_at: "(\<lambda>x. cos (f x::real)) differentiable at x within X"
>   if "f differentiable at x within X"
>   using differentiable_def has_derivative_cos that by blast
1152d1105
< subsection \<open>Frechet derivative\<close>
1154,1161c1107
< lemma frechet_derivative_transform_within_open:
<   "frechet_derivative f (at x) = frechet_derivative g (at x)"
<   if "open X" "x \<in> X" "\<And>x. x \<in> X \<Longrightarrow> f x = g x"
<     "f differentiable at x"
<   apply (rule frechet_derivative_at)
<   apply (rule has_derivative_transform_within_open[OF _ that(1-3)])
<   unfolding frechet_derivative_works[symmetric]
<   by fact
---
> subsection \<open>Frechet derivative\<close>
1166d1111
< 
1168,1176d1112
< lemmas frechet_derivative_worksI = frechet_derivative_works[THEN iffD1]
< 
< lemma frechet_derivative_const: "frechet_derivative (\<lambda>x. c) (at a) = (\<lambda>x. 0)"
<   by (rule frechet_derivative_at')
<     (auto intro!: derivative_eq_intros frechet_derivative_worksI)
< 
< lemma frechet_derivative_id: "frechet_derivative (\<lambda>x. x) (at a) = (\<lambda>x. x)"
<   by (rule frechet_derivative_at')
<     (auto intro!: derivative_eq_intros frechet_derivative_worksI)
1189a1126,1137
> lemma frechet_derivative_sin:
>   "frechet_derivative (\<lambda>x. sin (f x)) (at x) = (\<lambda>xa. frechet_derivative f (at x) xa * cos (f x))"
>   if "f differentiable (at x)"
>   for f::"_\<Rightarrow>real"
>   by (rule frechet_derivative_at'[OF has_derivative_sin[OF frechet_derivative_worksI[OF that]]])
> 
> lemma frechet_derivative_cos:
>   "frechet_derivative (\<lambda>x. cos (f x)) (at x) = (\<lambda>xa. frechet_derivative f (at x) xa * - sin (f x))"
>   if "f differentiable (at x)"
>   for f::"_\<Rightarrow>real"
>   by (rule frechet_derivative_at'[OF has_derivative_cos[OF frechet_derivative_worksI[OF that]]])
> 
1227,1233c1175
<   apply (rule frechet_derivative_at')
<   apply (rule diff_chain_at)
<    apply (rule frechet_derivative_worksI)
<   apply (rule that)
<   apply (rule frechet_derivative_worksI)
<   apply (rule that)
<   done
---
>   by (meson diff_chain_at frechet_derivative_at' frechet_derivative_works that)
1385a1328,1392
> 
> 
> subsection \<open>Extensional function space\<close>
> 
> text \<open>f is zero outside A. We use such functions to canonically represent
>   functions whose domain is A\<close>
> definition extensional0 :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b::zero) \<Rightarrow> bool"
>   where "extensional0 A f = (\<forall>x. x \<notin> A \<longrightarrow> f x = 0)"
> 
> lemma extensional0_0[intro, simp]: "extensional0 X 0"
>   by (auto simp: extensional0_def)
> 
> lemma extensional0_UNIV[intro, simp]: "extensional0 UNIV f"
>   by (auto simp: extensional0_def)
> 
> lemma ext_extensional0:
>   "f = g" if "extensional0 S f" "extensional0 S g" "\<And>x. x \<in> S \<Longrightarrow> f x = g x"
>   using that by (force simp: extensional0_def fun_eq_iff)
> 
> lemma extensional0_add[intro, simp]:
>   "extensional0 S f \<Longrightarrow> extensional0 S g \<Longrightarrow> extensional0 S (f + g::_\<Rightarrow>'a::comm_monoid_add)"
>   by (auto simp: extensional0_def)
> 
> lemma extensinoal0_mult[intro, simp]:
>   "extensional0 S x \<Longrightarrow> extensional0 S y \<Longrightarrow> extensional0 S (x * y)"
>   for x y::"_\<Rightarrow>'a::mult_zero"
>   by (auto simp: extensional0_def)
> 
> lemma extensional0_scaleR[intro, simp]: "extensional0 S f \<Longrightarrow> extensional0 S (c *\<^sub>R f::_\<Rightarrow>'a::real_vector)"
>   by (auto simp: extensional0_def)
> 
> lemma extensional0_outside: "x \<notin> S \<Longrightarrow> extensional0 S f \<Longrightarrow> f x = 0"
>   by (auto simp: extensional0_def)
> 
> lemma subspace_extensional0: "subspace (Collect (extensional0 X))"
>   by (auto simp: subspace_def)
> 
> text \<open>Send the function f to its canonical representative as a function with domain A\<close>
> definition restrict0 :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b::zero) \<Rightarrow> 'a \<Rightarrow> 'b"
>   where "restrict0 A f x = (if x \<in> A then f x else 0)"
> 
> lemma restrict0_UNIV[simp]: "restrict0 UNIV = (\<lambda>x. x)"
>   by (intro ext) (auto simp: restrict0_def)
> 
> lemma extensional0_restrict0[intro, simp]: "extensional0 A (restrict0 A f)"
>   by (auto simp: extensional0_def restrict0_def)
> 
> lemma restrict0_times: "restrict0 A (x * y) = restrict0 A x * restrict0 A y"
>   for x::"'a\<Rightarrow>'b::mult_zero"
>   by (auto simp: restrict0_def[abs_def])
> 
> lemma restrict0_apply_in[simp]: "x \<in> A \<Longrightarrow> restrict0 A f x = f x"
>   by (auto simp: restrict0_def)
> 
> lemma restrict0_apply_out[simp]: "x \<notin> A \<Longrightarrow> restrict0 A f x = 0"
>   by (auto simp: restrict0_def)
> 
> lemma restrict0_scaleR: "restrict0 A (c *\<^sub>R f::_\<Rightarrow>'a::real_vector) = c *\<^sub>R restrict0 A f"
>   by (auto simp: restrict0_def[abs_def])
> 
> lemma restrict0_add: "restrict0 A (f + g::_\<Rightarrow>'a::real_vector) = restrict0 A f + restrict0 A g"
>   by (auto simp: restrict0_def[abs_def])
> 
> lemma restrict0_restrict0: "restrict0 X (restrict0 Y f) = restrict0 (X \<inter> Y) f"
>   by (auto simp: restrict0_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Smooth_Manifolds/Bump_Function.thy ../../AFPs/afp-2020/thys/Smooth_Manifolds/Bump_Function.thy
3a4
>     "HOL-Analysis.Weierstrass_Theorems"
55,59c56,57
<       subgoal by (auto simp: eventually_at_filter)
<       subgoal
<         apply (intro tendsto_mult_right_zero)
<         by (rule Suc)
<       done
---
>       using Suc.hyps tendsto_mult_right_zero apply blast
>       by (auto simp: eventually_at_filter)
77c75
<     by (rule Lim_transform_eventually)
---
>     by (blast intro: Lim_transform_eventually)
86c84
<     by (rule Lim_transform_eventually) auto
---
>     by (blast intro: Lim_transform_eventually) 
104,105c102
<       apply (rule Lim_transform_eventually)
<       using \<open>x < 0\<close> by (auto simp: f_def)
---
>       using \<open>x < 0\<close> by (auto simp: f_def intro: Lim_transform_eventually)
113,115c110,113
<     then show ?thesis
<       apply (rule Lim_transform_eventually)
<       using \<open>x > 0\<close> by (auto simp: f_def intro!: tendsto_intros)
---
>     moreover have "(\<lambda>t. exp (- inverse t)) \<midarrow>x\<rightarrow> f x"
>       using \<open>x > 0\<close> by (auto simp: f_def tendsto_intros )
>     ultimately show ?thesis
>       by (blast intro: Lim_transform_eventually)
208,209c206,207
<   "x < 0 \<Longrightarrow> frechet_derivative f (at x) = (\<lambda>x. 0)"
<   by (rule frechet_derivative_at') (rule f_has_derivative_at_neg)
---
>   "x \<in> {..<0} \<Longrightarrow> frechet_derivative f (at x) = (\<lambda>x. 0)"
>   by (rule frechet_derivative_at') (rule f_has_derivative_at_neg, simp)
215,217c213,217
<   then show ?case
<     apply (auto simp: higher_differentiable_on.simps f_def)
<     apply (subst continuous_on_cong[OF refl]) by auto
---
>   have rewr: "a \<in> {..<0} \<Longrightarrow> \<not>0 < a" for a::real by simp
>   show ?case
>     by (auto simp: higher_differentiable_on.simps f_def rewr
>         simp del: lessThan_iff
>         cong: continuous_on_cong)
220,230c220,233
<   then show ?case
<     apply (auto simp: higher_differentiable_on.simps f_differentiable_at_neg)
<      apply (rule higher_differentiable_on_cong)
<        apply simp prefer 2
<       apply (subst frechet_derivative_f_at_neg)
<        apply auto
<     apply (subst frechet_derivative_nth_derivative_commute[symmetric])
<     apply (subst frechet_derivative_transform_within_open[where X="{..<0}" and g =0])
<         apply auto
<      apply (rule differentiable_eqI[where g=0 and X="{..<0}"])
<     by (auto simp: zero_fun_def frechet_derivative_const)
---
>   have "t < 0 \<Longrightarrow> (\<lambda>x. nth_derivative k f x 1) differentiable at t" for t
>     by (rule differentiable_eqI[where g=0 and X="{..<0}"])
>       (auto simp: zero_fun_def frechet_derivative_const Suc.IH)
>   then have "frechet_derivative (\<lambda>x. nth_derivative k f x 1) (at t) 1 = 0" if "t < 0" for t
>     using that Suc.IH
>     by (subst frechet_derivative_transform_within_open[where X="{..<0}" and g =0])
>       (auto simp: frechet_derivative_zero_fun)
>   with Suc show ?case
>     by (auto simp: higher_differentiable_on.simps f_differentiable_at_neg
>         frechet_derivative_f_at_neg zero_fun_def
>         simp flip: frechet_derivative_nth_derivative_commute
>         simp del: lessThan_iff
>         intro!: higher_differentiable_on_const
>         cong: higher_differentiable_on_cong)
317,324c320,327
<        apply (simp add: eventually_at_filter divide_simps)
<       apply (rule tendsto_eq_intros)
<         apply (rule real_polynomial_function_tendsto[THEN tendsto_eq_rhs])
<          apply fact
<         apply (rule refl)
<        apply (subst at_within_eq_at_right)
<        apply (rule exp_inv_limit_0_right_gen)
<       by simp
---
>        apply (rule tendsto_eq_intros)
>          apply (rule real_polynomial_function_tendsto[THEN tendsto_eq_rhs])
>           apply fact
>          apply (rule refl)
>         apply (subst at_within_eq_at_right)
>         apply (rule exp_inv_limit_0_right_gen)
>       apply (auto simp add: eventually_at_filter divide_simps)
>       done
371c374
<             by (rule Lim_transform_eventually) auto
---
>             by (blast intro: Lim_transform_eventually) 
375,380c378
<           have "\<forall>\<^sub>F x in at_right 0. p x * (exp (- inverse x) / x ^ (2 * Suc k)) =
<             nth_derivative (Suc k) f x 1"
<             using p
<             by (auto simp: eventually_at_filter)
<           then show ?thesis
<             apply (rule Lim_transform_eventually)
---
>           have "((\<lambda>x. p x * (exp (- inverse x) / x ^ (2 * Suc k))) \<longlongrightarrow> 0) (at_right 0)"
385a384,390
>           moreover
>           have "\<forall>\<^sub>F x in at_right 0. p x * (exp (- inverse x) / x ^ (2 * Suc k)) =
>             nth_derivative (Suc k) f x 1"
>             using p
>             by (auto simp: eventually_at_filter)
>           ultimately show ?thesis
>             by (rule Lim_transform_eventually)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Smooth_Manifolds/Cotangent_Space.thy ../../AFPs/afp-2020/thys/Smooth_Manifolds/Cotangent_Space.thy
619c619
<      apply (rule has_vector_derivative_at_within)
---
>     apply (rule has_vector_derivative_at_within)
622c622,623
<     apply simp
---
>       apply simp
>      apply simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Smooth_Manifolds/Smooth.thy ../../AFPs/afp-2020/thys/Smooth_Manifolds/Smooth.thy
87c87
< lemma higher_differentiable_on_cong:
---
> lemma higher_differentiable_on_congI:
103,106c103
<     apply (rule fun_cong[where x = v])
<     apply (rule frechet_derivative_transform_within_open[OF assms(1) that Suc(3)])
<     using 3 that assms(1)
<     by (auto simp: differentiable_on_eq_differentiable_at)
---
>     using "3" Suc.prems(2) assms(1) frechet_derivative_transform_within_open_ext that by blast
110a108,114
> lemma higher_differentiable_on_cong:
>   assumes "open S" "S = T"
>     and "\<And>x. x \<in> T \<Longrightarrow> f x = g x"
>   shows "higher_differentiable_on S f n \<longleftrightarrow> higher_differentiable_on T g n"
>   using higher_differentiable_on_congI assms by auto
> 
> 
153c157
<   by (cases n) (auto simp: continuous_intros frechet_derivative_id higher_differentiable_on_const)
---
>   by (cases n) (auto simp: frechet_derivative_works higher_differentiable_on_const)
174,178c178,181
<     apply (auto simp: intro!: derivative_intros f g)
<     apply (rule higher_differentiable_on_cong)
<     apply (rule that) defer
<      apply (subst frechet_derivative_plus)
<     using f g \<open>open S\<close> by (auto simp: differentiable_on_openD Suc.IH hf hg)
---
>     using f g \<open>open S\<close>
>     by (auto simp: frechet_derivative_plus
>         intro!: derivative_intros f g Suc.IH hf hg
>         cong: higher_differentiable_on_cong)
227,246c230,234
<     apply (auto simp: intro!: derivative_intros f g differentiable)
<      apply (rule higher_differentiable_on_cong)
<      apply (rule that) defer
<      apply (subst frechet_derivative)
<     subgoal using f \<open>open S\<close> by (auto simp: differentiable_on_openD)
<     subgoal using g \<open>open S\<close> by (auto simp: differentiable_on_openD)
<     apply simp
<     apply (rule higher_differentiable_on_add)
<     apply (rule Suc.IH)
<     apply (rule higher_differentiable_on_SucD)
<     apply (rule Suc)
<     apply (rule hg)
<     apply (rule that)
<     apply (rule Suc.IH)
<     apply (rule hf)
<     apply (rule higher_differentiable_on_SucD)
<     apply (rule Suc)
<     apply (rule that)
<     apply (rule that)
<     done
---
>     using f g \<open>open S\<close> Suc
>     by (auto simp: frechet_derivative
>         intro!: derivative_intros f g differentiable higher_differentiable_on_add Suc.IH
>         intro: higher_differentiable_on_SucD
>         cong: higher_differentiable_on_cong)
289,312c277,288
<     using \<open>g ` _ \<subseteq> _\<close>
<     apply (auto simp del: o_apply intro!: differentiable_chain_within f g intro: differentiable_at_withinI)
<     using \<open>open S\<close>
<     apply (rule higher_differentiable_on_cong)
<      defer
<      apply (subst frechet_derivative_compose_eucl)
<     subgoal using g by (auto simp: differentiable_on_eq_differentiable_at \<open>open S\<close>)
<     subgoal using f by (auto simp: differentiable_on_eq_differentiable_at \<open>open T\<close>)
<      apply simp
<     using _ \<open>open S\<close>
<     apply (rule higher_differentiable_on_sum)
<     apply (rule higher_differentiable_on_scaleR)
<       apply (rule higher_differentiable_on_inner)
<     apply (rule hg)
<        apply (rule higher_differentiable_on_const)
<       apply (rule that)
<     apply (rule Suc.IH[where f="\<lambda>x. frechet_derivative f (at x) v"
<         and g = "\<lambda>x. g x" for v, unfolded o_def])
<        apply (rule hf)
<     apply (rule higher_differentiable_on_SucD)
<       apply (rule Suc.prems)
<      apply assumption
<     apply (rule that)
<     done
---
>     using \<open>g ` _ \<subseteq> _\<close> \<open>open S\<close> f g \<open>open T\<close> Suc
>       Suc.IH[where f="\<lambda>x. frechet_derivative f (at x) v"
>         and g = "\<lambda>x. g x" for v, unfolded o_def]
>       higher_differentiable_on_SucD[OF Suc.prems(2)]
>     by (auto
>         simp: frechet_derivative_compose_eucl subset_iff
>         simp del: o_apply
>         intro!: differentiable_chain_within higher_differentiable_on_sum
>           higher_differentiable_on_scaleR higher_differentiable_on_inner
>           higher_differentiable_on_const
>         intro: differentiable_at_withinI
>         cong: higher_differentiable_on_cong)
314a291,305
> 
> lemma higher_differentiable_on_uminus:
>   "higher_differentiable_on S (\<lambda>x. - f x) n"
>   if "higher_differentiable_on S f n" "open S"
>   using higher_differentiable_on_scaleR[of S "\<lambda>x. -1" n f] that
>   by (auto simp: higher_differentiable_on_const)
> 
> lemma higher_differentiable_on_minus:
>   "higher_differentiable_on S (\<lambda>x. f x - g x) n"
>   if "higher_differentiable_on S f n"
>     "higher_differentiable_on S g n"
>     "open S"
>   using higher_differentiable_on_add[OF _ higher_differentiable_on_uminus, OF that(1,2,3,3)]
>   by simp
> 
327,350c318,322
<     apply (auto simp: continuous_on_inverse intro!: differentiable_inverse)
<     apply (rule higher_differentiable_on_cong)
<       apply (rule that)
<      prefer 2
<      apply (subst frechet_derivative_inverse)
<        apply force
<       apply force
<      apply (rule refl)
<     apply (rule higher_differentiable_on_mult)
<       apply (subst divide_inverse)
<       apply (rule higher_differentiable_on_mult)
<         apply (rule higher_differentiable_on_const)
<        apply (rule Suc.IH)
<     unfolding power2_eq_square
<          apply (rule higher_differentiable_on_mult)
<            apply (rule fn)
<           apply (rule fn)
<          apply assumption
<         apply force
<        apply assumption
<       apply assumption
<      apply force
<     apply assumption
<     done
---
>     by (auto simp: continuous_on_inverse image_iff power2_eq_square
>         frechet_derivative_inverse divide_inverse
>         intro!: differentiable_inverse higher_differentiable_on_uminus higher_differentiable_on_mult
>           Suc.IH fn
>         cong: higher_differentiable_on_cong)
352a325,336
> lemma higher_differentiable_on_divide:
>   "higher_differentiable_on S (\<lambda>x. f x / g x) n"
>   if
>     "higher_differentiable_on S f n"
>     "higher_differentiable_on S g n"
>     "\<And>x. x \<in> S \<Longrightarrow> g x \<noteq> 0"
>     "open S"
>   for f::"_\<Rightarrow>_::real_normed_field"
>   using higher_differentiable_on_mult[OF _ higher_differentiable_on_inverse, OF that(1,2) _ that(4,4)]
>     that(3)
>   by (auto simp: divide_inverse image_iff)
> 
400c384
<   with \<open>open S\<close> have op: "open (S \<inter> f -` {0<..})"
---
>   with \<open>open S\<close> have op: "open (S \<inter> f -` {0<..})" (is "open ?op")
402c386
<   from \<open>open S\<close> \<open>continuous_on S f\<close> have on: "open (S \<inter> f -` {..<0})"
---
>   from \<open>open S\<close> \<open>continuous_on S f\<close> have on: "open (S \<inter> f -` {..<0})" (is "open ?on")
404,421c388,393
<   have i: "higher_differentiable_on (S \<inter> f -` {0<..} \<union> S \<inter> f -` {..<0}) (\<lambda>x. if 0 < f x then 1::real else - 1) n"
<     apply (rule higher_differentiable_on_open_Un)
<     subgoal
<       apply (rule higher_differentiable_on_cong)
<         apply fact
<        apply (rule higher_differentiable_on_const)
<       apply force
<       done
<     subgoal
<       apply (rule higher_differentiable_on_cong)
<         apply fact
<        apply (rule higher_differentiable_on_const)
<       apply force
<       done
<     subgoal by fact
<     subgoal by fact
<     done
<   also have "(S \<inter> f -` {0<..} \<union> S \<inter> f -` {..<0}) = S" using Suc by auto
---
>   have op': "higher_differentiable_on ?op (\<lambda>x. 1) n" and on': "higher_differentiable_on ?on (\<lambda>x. -1) n"
>      by (rule higher_differentiable_on_const)+
>   then have i: "higher_differentiable_on (?op \<union> ?on) (\<lambda>x. if 0 < f x then 1::real else - 1) n"
>     by (auto intro!: higher_differentiable_on_open_Un op on
>           higher_differentiable_on_congI[OF _ op'] higher_differentiable_on_congI[OF _ on'])
>   also have "?op \<union> ?on = S" using Suc by auto
424,448c396,399
<     apply (auto simp: sqrt_differentiable_on intro!: sqrt_differentiable)
<     apply (rule higher_differentiable_on_cong)
<       apply simp prefer 2
<      apply (subst frechet_derivative_sqrt)
<        apply (simp add: differentiable_on_openD)
<       apply force
<      apply (rule refl)
<     apply (rule higher_differentiable_on_mult)
<     unfolding divide_inverse
<       apply (rule higher_differentiable_on_mult)
<         apply assumption
<        apply (rule higher_differentiable_on_inverse)
<          apply (rule higher_differentiable_on_mult)
<            apply (rule higher_differentiable_on_const)
<           apply (rule Suc.IH)
<             apply assumption
<            apply force
<           apply assumption
<          apply assumption
<         apply force
<        apply assumption
<       apply assumption
<      apply force
<     apply assumption
<     done
---
>     by (auto simp: sqrt_differentiable_on image_iff frechet_derivative_sqrt
>         intro!: sqrt_differentiable higher_differentiable_on_mult higher_differentiable_on_inverse
>           higher_differentiable_on_divide higher_differentiable_on_const
>         cong: higher_differentiable_on_cong)
458,463d408
< lemma higher_differentiable_on_uminus:
<   "higher_differentiable_on S (\<lambda>x. - f x) n"
<   if "higher_differentiable_on S f n" "open S"
<   using higher_differentiable_on_scaleR[of S "\<lambda>x. -1" n f] that
<   by (auto simp: higher_differentiable_on_const)
< 
476,564c421,425
<     apply (auto simp: continuous_on_norm intro!: differentiable_norm_compose_at)
<     apply (rule higher_differentiable_on_cong)
<       apply (rule that)
<      prefer 2
<      apply (subst frechet_derivative_norm)
<        apply force
<       apply force
<      apply (rule refl)
<     apply (rule higher_differentiable_on_inner)
<     apply force
<       apply (subst sgn_div_norm)
<       apply (rule higher_differentiable_on_scaleR)
<         apply (rule higher_differentiable_on_inverse)
<          apply (rule Suc.IH)
<            apply (rule fn)
<           apply assumption
<          apply assumption
<         apply force
<        apply assumption
<       apply (rule fn)
<      apply assumption
<     apply assumption
<     done
< qed
< 
< lemma higher_differentiable_on_minus:
<   "higher_differentiable_on S (\<lambda>x. f x - g x) n"
<   if "higher_differentiable_on S f n"
<     "higher_differentiable_on S g n"
<     "open S"
<   unfolding diff_conv_add_uminus
<   apply (rule higher_differentiable_on_add)
<     apply (rule that)
<    apply (rule higher_differentiable_on_uminus)
<     apply (rule that)
<    apply (rule that)
<   apply (rule that)
<   done
< 
< lemma higher_differentiable_on_divide:
<   "higher_differentiable_on S (\<lambda>x. f x / g x) n"
<   if
<     "higher_differentiable_on S f n"
<     "higher_differentiable_on S g n"
<     "\<And>x. x \<in> S \<Longrightarrow> g x \<noteq> 0"
<     "open S"
<   for f::"_\<Rightarrow>_::real_normed_field"
<   using that
< proof (induction n arbitrary: f g)
<   case 0
<   then show ?case by (auto intro!: continuous_intros)
< next
<   case (Suc n)
<   from Suc.prems have
<     f: "\<And>x. x\<in>S \<Longrightarrow> f differentiable (at x)"
<     and hf: "higher_differentiable_on S (\<lambda>x. frechet_derivative f (at x) v) n"
<     and g: "\<And>x. x\<in>S \<Longrightarrow> g differentiable (at x)"
<     and hg: "higher_differentiable_on S (\<lambda>x. frechet_derivative g (at x) v) n"
<     for v
<     by auto
<   show ?case
<     apply (auto simp: Suc intro!: derivative_intros f g)
<     apply (rule higher_differentiable_on_cong)
<       apply (rule that) defer
<      apply (subst frechet_derivative_divide)
<     subgoal using f \<open>open S\<close> by (auto simp: differentiable_on_openD)
<     subgoal using g \<open>open S\<close> by (auto simp: differentiable_on_openD)
<     subgoal by (auto simp: Suc)
<      apply (simp add: power2_eq_square)
<     apply (rule higher_differentiable_on_minus)
<       apply (rule Suc.IH)
<          apply (rule hf)
<         apply (rule higher_differentiable_on_SucD)
<         apply (rule Suc)
<        apply (rule Suc, assumption)
<       apply (rule that)
<      apply (rule Suc.IH)
<         apply (rule higher_differentiable_on_mult)
<           apply (rule hg)
<          apply (rule higher_differentiable_on_SucD)
<          apply (rule Suc)
<         apply (rule Suc)
<        apply (rule higher_differentiable_on_mult)
<          apply (rule higher_differentiable_on_SucD)
<          apply (rule Suc)
<         apply (rule higher_differentiable_on_SucD)
<         apply (rule Suc)
<        apply (rule Suc)
<     using Suc by auto
---
>     by (auto simp: continuous_on_norm frechet_derivative_norm image_iff sgn_div_norm
>         cong: higher_differentiable_on_cong
>         intro!: differentiable_norm_compose_at higher_differentiable_on_inner
>           higher_differentiable_on_inverse
>           higher_differentiable_on_mult Suc.IH fn)
580c441
<   then show ?case
---
>   then show ?case using that
582,584c443
<     apply auto
<     apply (rule higher_differentiable_on_cong[OF that])
<     by (auto simp: frechet_derivative_pair[of f _ g])
---
>     by (auto simp: frechet_derivative_pair[of f _ g] cong: higher_differentiable_on_cong)
613,614c472,473
< lemma higher_differentiable_on_snd_comp:
<   "higher_differentiable_on S (\<lambda>x. snd (f x)) k"
---
> lemma higher_differentiable_on_fst_comp:
>   "higher_differentiable_on S (\<lambda>x. fst (f x)) k"
617,622c476,479
<   apply (induction k arbitrary: f)
<    apply (auto intro!: continuous_intros differentiable_at_snd simp: higher_differentiable_on.simps)
<   using \<open>open S\<close>
<   apply (rule higher_differentiable_on_cong) prefer 2
<    apply (subst frechet_derivative_snd)
<   by auto
---
>   by (induction k arbitrary: f)
>     (auto intro!: continuous_intros differentiable_at_fst
>       cong: higher_differentiable_on_cong
>       simp: higher_differentiable_on.simps frechet_derivative_fst)
624,625c481,482
< lemma higher_differentiable_on_fst_comp:
<   "higher_differentiable_on S (\<lambda>x. fst (f x)) k"
---
> lemma higher_differentiable_on_snd_comp:
>   "higher_differentiable_on S (\<lambda>x. snd (f x)) k"
628,633c485,488
<   apply (induction k arbitrary: f)
<    apply (auto intro!: continuous_intros differentiable_at_fst simp: higher_differentiable_on.simps)
<   using \<open>open S\<close>
<   apply (rule higher_differentiable_on_cong) prefer 2
<    apply (subst frechet_derivative_fst)
<   by auto
---
>   by (induction k arbitrary: f)
>     (auto intro!: continuous_intros differentiable_at_snd
>       cong: higher_differentiable_on_cong
>       simp: higher_differentiable_on.simps frechet_derivative_snd)
640,645c495,520
<   using that apply (auto intro!: higher_differentiable_on_Pair open_Times)
<   apply (rule higher_differentiable_on_compose'[where f=f and T=S])
<   using that apply (auto intro: open_Times higher_differentiable_on_fst)
<   apply (rule higher_differentiable_on_compose'[where f=g and T=T])
<   using that apply (auto intro: open_Times higher_differentiable_on_snd)
<   done
---
>   by (auto intro!: higher_differentiable_on_Pair open_Times S T
>       higher_differentiable_on_fst
>       higher_differentiable_on_snd
>       higher_differentiable_on_compose'[where f=f and T=S]
>       higher_differentiable_on_compose'[where f=g and T=T])
> 
> 
> lemma higher_differentiable_on_sin: "higher_differentiable_on S (\<lambda>x. sin (f x::real)) n"
>   and higher_differentiable_on_cos: "higher_differentiable_on S (\<lambda>x. cos (f x::real)) n"
>   if f: "higher_differentiable_on S f n" and S: "open S"
>   unfolding atomize_conj
>   using f
> proof (induction n)
>   case (Suc n)
>   then have "higher_differentiable_on S f n"
>     "higher_differentiable_on S (\<lambda>x. sin (f x)) n"
>     "higher_differentiable_on S (\<lambda>x. cos (f x)) n"
>     "\<And>x. x \<in> S \<Longrightarrow> f differentiable at x"
>     using higher_differentiable_on_SucD
>     by (auto simp: higher_differentiable_on.simps)
>   with Suc show ?case
>     by (auto simp: higher_differentiable_on.simps sin_differentiable_at cos_differentiable_at
>         frechet_derivative_sin frechet_derivative_cos S
>         intro!: higher_differentiable_on_mult higher_differentiable_on_uminus
>         cong: higher_differentiable_on_cong[OF S])
> qed (auto simp: higher_differentiable_on.simps intro!: continuous_intros)
729c604
<   if "f differentiable (at x)"
---
>   if "f differentiable (at x)" "NO_MATCH 1 v"
738,746c613,616
<   apply (auto simp: higher_differentiable_on.simps)
<   subgoal for v
<     using \<open>open S\<close>
<     apply (rule higher_differentiable_on_cong) defer
<      apply (rule frechet_derivative_at_real_eq_scaleR)
<     apply force
<     using \<open>open S\<close>
<     by (auto simp: intro!: higher_differentiable_on_scaleR higher_differentiable_on_const)
<   done
---
>   using \<open>open S\<close>
>   by (auto simp: higher_differentiable_on.simps frechet_derivative_at_real_eq_scaleR
>       intro!: higher_differentiable_on_scaleR higher_differentiable_on_const
>       cong: higher_differentiable_on_cong)
770c640
<       intro: higher_differentiable_on_real_SucI )
---
>       intro: higher_differentiable_on_real_SucI)
841a712,723
>   have eq: "\<And>x. x \<in> Basis \<Longrightarrow>
>          frechet_derivative
>           (\<lambda>x. \<Sum>i\<in>Basis. v \<bullet> i * frechet_derivative f (at x) i) (at a) x =
>          (\<Sum>j\<in>Basis. frechet_derivative (\<lambda>a. frechet_derivative f (at a) j) (at a) x * (v \<bullet> j))"
>     apply (subst frechet_derivative_sum)
>     subgoal by (auto intro!: differentiable_mult diff)
>     apply (rule sum.cong)
>      apply simp
>     apply (subst frechet_derivative_times)
>     subgoal by simp
>     subgoal by (rule diff)
>     by (simp add: frechet_derivative_const)
850,852c732,733
<     using S
<      apply (rule frechet_derivative_transform_within_open_ext)
<       apply (subst frechet_derivative_componentwise)
---
>      apply (rule frechet_derivative_transform_within_open_ext [OF _ S frechet_derivative_componentwise])
>     apply (simp add: diff)
854,863c735,736
<       apply (rule refl)
<     apply (rule diff)
<     apply (subst frechet_derivative_sum)
<     subgoal by (auto intro!: differentiable_mult diff)
<     apply (rule sum.cong)
<      apply simp
<     apply (subst frechet_derivative_times)
<     subgoal by simp
<     subgoal by (rule diff)
<     by (simp add: frechet_derivative_const)
---
>     apply (simp add: eq)
>     done
1072,1077c945
<       apply (rule higher_differentiable_on_cong)
<       prefer 2
<        apply (subst *)
<         apply assumption apply (rule refl)
<       apply (rule **)
<       done
---
>       by (auto simp: * ** cong: higher_differentiable_on_cong)
1129c997
<   by (auto intro: higher_differentiable_on_cong)
---
>   by (auto cong: higher_differentiable_on_cong)
1284a1153,1159
> lemma smooth_on_sin: "n-smooth_on S (\<lambda>x. sin (f x::real))" if "n-smooth_on S f" "open S"
>   using that
>   by (auto simp: smooth_on_def intro!: higher_differentiable_on_sin)
> 
> lemma smooth_on_cos: "n-smooth_on S (\<lambda>x. cos (f x::real))" if "n-smooth_on S f" "open S"
>   using that
>   by (auto simp: smooth_on_def intro!: higher_differentiable_on_cos)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Smooth_Manifolds/Tangent_Space.thy ../../AFPs/afp-2020/thys/Smooth_Manifolds/Tangent_Space.thy
23,85d22
< subsection \<open>Extensional function space\<close>
< 
< text \<open>f is zero outside A. We use such functions to canonically represent
<   functions whose domain is A\<close>
< definition extensional0 :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b::zero) \<Rightarrow> bool"
<   where "extensional0 A f = (\<forall>x. x \<notin> A \<longrightarrow> f x = 0)"
< 
< lemma extensional0_0[intro, simp]: "extensional0 X 0"
<   by (auto simp: extensional0_def)
< 
< lemma extensional0_UNIV[intro, simp]: "extensional0 UNIV f"
<   by (auto simp: extensional0_def)
< 
< lemma ext_extensional0:
<   "f = g" if "extensional0 S f" "extensional0 S g" "\<And>x. x \<in> S \<Longrightarrow> f x = g x"
<   using that by (force simp: extensional0_def fun_eq_iff)
< 
< lemma extensional0_add[intro, simp]:
<   "extensional0 S f \<Longrightarrow> extensional0 S g \<Longrightarrow> extensional0 S (f + g::_\<Rightarrow>'a::comm_monoid_add)"
<   by (auto simp: extensional0_def)
< 
< lemma extensinoal0_mult[intro, simp]:
<   "extensional0 S x \<Longrightarrow> extensional0 S y \<Longrightarrow> extensional0 S (x * y)"
<   for x y::"_\<Rightarrow>'a::mult_zero"
<   by (auto simp: extensional0_def)
< 
< lemma extensional0_scaleR[intro, simp]: "extensional0 S f \<Longrightarrow> extensional0 S (c *\<^sub>R f::_\<Rightarrow>'a::real_vector)"
<   by (auto simp: extensional0_def)
< 
< lemma extensional0_outside: "x \<notin> S \<Longrightarrow> extensional0 S f \<Longrightarrow> f x = 0"
<   by (auto simp: extensional0_def)
< 
< lemma subspace_extensional0: "subspace (Collect (extensional0 X))"
<   by (auto simp: subspace_def)
< 
< text \<open>Send the function f to its canonical representative as a function with domain A\<close>
< definition restrict0 :: "'a set \<Rightarrow> ('a \<Rightarrow> 'b::zero) \<Rightarrow> 'a \<Rightarrow> 'b"
<   where "restrict0 A f x = (if x \<in> A then f x else 0)"
< 
< lemma restrict0_UNIV[simp]: "restrict0 UNIV = (\<lambda>x. x)"
<   by (intro ext) (auto simp: restrict0_def)
< 
< lemma extensional0_restrict0[intro, simp]: "extensional0 A (restrict0 A f)"
<   by (auto simp: extensional0_def restrict0_def)
< 
< lemma restrict0_times: "restrict0 A (x * y) = restrict0 A x * restrict0 A y"
<   for x::"'a\<Rightarrow>'b::mult_zero"
<   by (auto simp: restrict0_def[abs_def])
< 
< lemma restrict0_apply_in[simp]: "x \<in> A \<Longrightarrow> restrict0 A f x = f x"
<   by (auto simp: restrict0_def)
< 
< lemma restrict0_apply_out[simp]: "x \<notin> A \<Longrightarrow> restrict0 A f x = 0"
<   by (auto simp: restrict0_def)
< 
< lemma restrict0_scaleR: "restrict0 A (c *\<^sub>R f::_\<Rightarrow>'a::real_vector) = c *\<^sub>R restrict0 A f"
<   by (auto simp: restrict0_def[abs_def])
< 
< lemma restrict0_add: "restrict0 A (f + g::_\<Rightarrow>'a::real_vector) = restrict0 A f + restrict0 A g"
<   by (auto simp: restrict0_def[abs_def])
< 
< lemma restrict0_restrict0: "restrict0 X (restrict0 Y f) = restrict0 (X \<inter> Y) f"
<   by (auto simp: restrict0_def)
==========
Source_Coding_Theorem
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy ../../AFPs/afp-2020/thys/Source_Coding_Theorem/Source_Coding_Theorem.thy
532,533c532,533
<       using log_mult_ext2[OF pos_pi] b_gt_1
<       by (simp add: linordered_field_class.sign_simps(36))
---
>       using log_mult_ext2 [OF pos_pi, of i] b_gt_1
>       by simp (simp add: algebra_simps)
==========
Splay_Tree
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Splay_Tree/Splay_Tree.thy ../../AFPs/afp-2020/thys/Splay_Tree/Splay_Tree.thy
51,54c51,53
<   (if x=b
<    then Node AB b CD
<    else if x < b
<         then case AB of
---
>   (case cmp x b of
>    EQ \<Rightarrow> Node AB b CD |
>    LT \<Rightarrow> (case AB of
57,59c56,57
<             (if x=a then Node A a (Node B b CD)
<              else if x < a
<                   then if A = Leaf then Node A a (Node B b CD)
---
>             (case cmp x a of EQ \<Rightarrow> Node A a (Node B b CD) |
>              LT \<Rightarrow>  if A = Leaf then Node A a (Node B b CD)
61,62c59,60
<                          Node A\<^sub>1 a' A\<^sub>2 \<Rightarrow> Node A\<^sub>1 a' (Node A\<^sub>2 a (Node B b CD))
<                   else if B = Leaf then Node A a (Node B b CD)
---
>                          Node A\<^sub>1 a' A\<^sub>2 \<Rightarrow> Node A\<^sub>1 a' (Node A\<^sub>2 a (Node B b CD)) |
>              GT \<Rightarrow> if B = Leaf then Node A a (Node B b CD)
64,65c62,63
<                          Node B\<^sub>1 b' B\<^sub>2 \<Rightarrow> Node (Node A a B\<^sub>1) b' (Node B\<^sub>2 b CD))
<         else case CD of
---
>                          Node B\<^sub>1 b' B\<^sub>2 \<Rightarrow> Node (Node A a B\<^sub>1) b' (Node B\<^sub>2 b CD))) |
>    GT \<Rightarrow> (case CD of
68,70c66,67
<             (if x=c then Node (Node AB b C) c D
<              else if x < c
<                   then if C = Leaf then Node (Node AB b C) c D
---
>             (case cmp x c of EQ \<Rightarrow> Node (Node AB b C) c D |
>              LT \<Rightarrow> if C = Leaf then Node (Node AB b C) c D
72,73c69,70
<                          Node C\<^sub>1 c' C\<^sub>2 \<Rightarrow> Node (Node AB b C\<^sub>1) c' (Node C\<^sub>2 c D)
<                   else if D=Leaf then Node (Node AB b C) c D
---
>                          Node C\<^sub>1 c' C\<^sub>2 \<Rightarrow> Node (Node AB b C\<^sub>1) c' (Node C\<^sub>2 c D) |
>              GT \<Rightarrow> if D=Leaf then Node (Node AB b C) c D
75c72
<                          Node D\<^sub>1 d D\<^sub>2 \<Rightarrow> Node (Node (Node AB b C) c D\<^sub>1) d D\<^sub>2))"
---
>                          Node D\<^sub>1 d D\<^sub>2 \<Rightarrow> Node (Node (Node AB b C) c D\<^sub>1) d D\<^sub>2)))"
121,123c118,119
<      if x = a
<      then if l = Leaf then r else case splay_max l of Node l' m r' \<Rightarrow> Node l' m r
<      else Node l a r)"
---
>      if x \<noteq> a then Node l a r
>      else if l = Leaf then r else case splay_max l of Node l' m r' \<Rightarrow> Node l' m r)"
==========
Sqrt_Babylonian
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Sqrt_Babylonian/Sqrt_Babylonian_Auxiliary.thy ../../AFPs/afp-2020/thys/Sqrt_Babylonian/Sqrt_Babylonian_Auxiliary.thy
34,50d33
< lemma log_pow_cancel[simp]: "a > 0 \<Longrightarrow> a \<noteq> 1 \<Longrightarrow> log a (a ^ b) = b" 
<   by (metis monoid_mult_class.mult.right_neutral log_eq_one log_nat_power)
< 
< lemma real_of_rat_floor[simp]: "floor (real_of_rat x) = floor x"
<   by (metis Ratreal_def real_floor_code)
< 
< lemma abs_of_rat[simp]: "\<bar>real_of_rat x\<bar> = real_of_rat \<bar>x\<bar>" 
< proof (cases "x \<ge> 0")
<   case False
<   define y where "y = - x"
<   from False have y: "y \<ge> 0" "x = - y" by (auto simp: y_def)
<   thus ?thesis by (auto simp: of_rat_minus)
< qed auto
< 
< lemma real_of_rat_ceiling[simp]: "ceiling (real_of_rat x) = ceiling x"
<   unfolding ceiling_def by (metis of_rat_minus real_of_rat_floor)
< 
==========
Stellar_Quorums
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stellar_Quorums/Stellar_Quorums.thy ../../AFPs/afp-2020/thys/Stellar_Quorums/Stellar_Quorums.thy
12,13c12,13
<   fixes quorum_of :: "'node \<Rightarrow> 'node set \<Rightarrow> bool"
<   assumes quorum_assm:"\<And> p p' . \<lbrakk>p \<in> W; quorum_of p Q; p' \<in> Q\<inter>W\<rbrakk> \<Longrightarrow> quorum_of p' Q"
---
>   fixes quorum_of :: "'node \<Rightarrow> 'node set \<Rightarrow> bool" 
>   assumes quorum_assm:"\<And> p p' . \<lbrakk>quorum_of p Q; p' \<in> Q\<rbrakk> \<Longrightarrow> quorum_of p' Q"
97,99c97,98
< definition stellar_intact where
<   \<comment> \<open>This is equivalent to the notion of intact set presented in the Stellar Whitepaper~\cite{MazieresStellarConsensusProtocol2015}\<close>
<   "stellar_intact I \<equiv> I \<subseteq> W \<and> (\<forall> p \<in> I . \<exists> Q \<subseteq> I . quorum_of p Q)
---
> definition strong_consensus_cluster where
>   "strong_consensus_cluster I \<equiv> I \<subseteq> W \<and> (\<forall> p \<in> I . \<exists> Q \<subseteq> I . quorum_of p Q)
102c101
< lemma stellar_intact_imp_cons_cluster:
---
> lemma strong_consensus_cluster_imp_cons_cluster:
104,105c103,104
<   shows "stellar_intact I \<Longrightarrow> is_cons_cluster I" 
<   unfolding stellar_intact_def is_cons_cluster_def
---
>   shows "strong_consensus_cluster I \<Longrightarrow> is_cons_cluster I" 
>   unfolding strong_consensus_cluster_def is_cons_cluster_def
108,110c107,109
< lemma cons_cluster_not_intact:
<   \<comment> \<open>Some consensus clusters are not intact and have no intact superset.\<close>
<   shows "is_cons_cluster C \<and> (\<forall> J . C \<subseteq> J \<longrightarrow> \<not>stellar_intact J)" nitpick[falsify=false, card 'node=3, expect=genuine]
---
> lemma cons_cluster_neq_cons_cluster:
>   \<comment> \<open>Some consensus clusters are not strong consensus clusters and have no superset that is a strong consensus cluster.\<close>
>   shows "is_cons_cluster I \<and> (\<forall> J . I \<subseteq> J \<longrightarrow> \<not>strong_consensus_cluster J)" nitpick[falsify=false, card 'node=3, expect=genuine]
152a152,192
> text \<open>Similarly, the union of two strong consensus clusters is a strong consensus cluster.\<close>
> lemma strong_cluster_union:
>   assumes "strong_consensus_cluster C\<^sub>1" and "strong_consensus_cluster C\<^sub>2" and "C\<^sub>1 \<inter> C\<^sub>2 \<noteq> {}"
>   shows "strong_consensus_cluster (C\<^sub>1\<union> C\<^sub>2)"
> proof -
>   have "C\<^sub>1 \<union> C\<^sub>2 \<subseteq> W"
>     using assms(1) assms(2) strong_consensus_cluster_def by auto 
>   moreover
>   have "\<forall> p \<in> (C\<^sub>1\<union>C\<^sub>2) . \<exists> Q \<subseteq> (C\<^sub>1\<union>C\<^sub>2) . quorum_of p Q" 
>     using \<open>strong_consensus_cluster C\<^sub>1\<close> \<open>strong_consensus_cluster C\<^sub>2\<close> unfolding strong_consensus_cluster_def
>     by (meson UnE le_supI1 le_supI2)
>   moreover
>   have "(C\<^sub>1\<union>C\<^sub>2) \<inter> Q\<^sub>1 \<inter> Q\<^sub>2 \<noteq> {}"
>     if "quorum_of_set (C\<^sub>1\<union>C\<^sub>2) Q\<^sub>1" and "quorum_of_set (C\<^sub>1\<union>C\<^sub>2) Q\<^sub>2" 
>     for Q\<^sub>1 Q\<^sub>2
>   proof -
>     have "C \<inter> Q\<^sub>1 \<inter> Q\<^sub>2 \<noteq> {}" if "quorum_of_set C Q\<^sub>1" and "quorum_of_set C Q\<^sub>2" and "C = C\<^sub>1 \<or> C = C\<^sub>2" for C
>       using \<open>strong_consensus_cluster C\<^sub>1\<close> \<open>strong_consensus_cluster C\<^sub>2\<close> that
>       unfolding quorum_of_set_def strong_consensus_cluster_def by metis
>     hence "(C\<^sub>1\<union>C\<^sub>2) \<inter> Q\<^sub>1 \<inter> Q\<^sub>2 \<noteq> {}" if "quorum_of_set C Q\<^sub>1" and "quorum_of_set C Q\<^sub>2" and "C = C\<^sub>1 \<or> C = C\<^sub>2" for C
>       by (metis Int_Un_distrib2 disjoint_eq_subset_Compl sup.boundedE that)
>     moreover
>     have \<open>(C\<^sub>1\<union>C\<^sub>2) \<inter> Q\<^sub>1 \<inter> Q\<^sub>2 \<noteq> {}\<close>  if "strong_consensus_cluster C\<^sub>1" and "strong_consensus_cluster C\<^sub>2"
>       and "C\<^sub>1 \<inter> C\<^sub>2 \<noteq> {}" and "quorum_of_set C\<^sub>1 Q\<^sub>1" and "quorum_of_set C\<^sub>2 Q\<^sub>2"
>     for C\<^sub>1 C\<^sub>2 \<comment> \<open>We generalize to avoid repeating the argument twice\<close>
>     proof -
>       obtain p Q where "quorum_of p Q" and "p \<in> C\<^sub>1 \<inter> C\<^sub>2" and "Q \<subseteq> C\<^sub>2" 
>         using \<open>C\<^sub>1 \<inter> C\<^sub>2 \<noteq> {}\<close> \<open>strong_consensus_cluster C\<^sub>2\<close> unfolding strong_consensus_cluster_def by blast
>       have "Q \<inter> Q\<^sub>1 \<noteq> {}" using \<open>strong_consensus_cluster C\<^sub>1\<close> \<open>quorum_of_set C\<^sub>1 Q\<^sub>1\<close> \<open>quorum_of p Q\<close> \<open>p \<in> C\<^sub>1 \<inter> C\<^sub>2\<close>
>         unfolding strong_consensus_cluster_def quorum_of_set_def
>         by (metis Int_assoc Int_iff inf_bot_right)
>       hence "quorum_of_set C\<^sub>2 Q\<^sub>1"  using \<open>Q \<subseteq> C\<^sub>2\<close> \<open>quorum_of_set C\<^sub>1 Q\<^sub>1\<close> quorum_assm unfolding quorum_of_set_def by blast 
>       thus "(C\<^sub>1\<union>C\<^sub>2) \<inter> Q\<^sub>1 \<inter> Q\<^sub>2 \<noteq> {}" using \<open>strong_consensus_cluster C\<^sub>2\<close> \<open>quorum_of_set C\<^sub>2 Q\<^sub>2\<close>
>         unfolding strong_consensus_cluster_def by blast
>     qed
>     ultimately show ?thesis using assms that unfolding quorum_of_set_def by auto 
>   qed
>   ultimately show ?thesis using assms
>     unfolding strong_consensus_cluster_def by simp
> qed
> 
159c199
<     and W :: "'node set" \<comment> \<open>the correct participants\<close>
---
>     and W :: "'node set" \<comment> \<open>the well-behaved nodes\<close>
265c305
<   shows "quorum Q"  
---
>   shows "quorum Q"
271c311,312
<     thus ?thesis  using blocking_min.intros not_blocked.intros(2) that unfolding Q_def by (simp; smt Ball_Collect)
---
>     thus ?thesis  using blocking_min.intros not_blocked.intros(2) that unfolding Q_def 
>       by (simp; metis mem_Collect_eq subsetI)
273c314
<   thus ?thesis by (simp add: quorum_def) 
---
>   thus ?thesis by (simp add: quorum_def)
275a317
> 
320c362
< section \<open>Reachability through a set\<close>
---
> subsection \<open>Reachability through a set\<close>
362c404
< section "Elementary quorums"
---
> subsection "Elementary quorums"
436a479,608
> qed
> 
> 
> end
> 
> subsection \<open>The intact sets of the Stellar Whitepaper\<close>
> 
> definition project where 
>   "project slices S n \<equiv> {Sl \<inter> S | Sl . Sl \<in> slices n}" 
>   \<comment> \<open>Projecting on @{term S} is the same as deleting the complement of @{term S}, where deleting is understood as in the Stellar Whitepaper.\<close>
> 
> subsubsection \<open>Intact and the Cascade Theorem\<close>
> 
> locale intact = \<comment> \<open>Here we fix an intact set @{term I} and prove the cascade theorem.\<close>
>   orig:stellar slices W 
>   + proj:stellar "project slices I" W \<comment> \<open>We consider the projection of the system on @{term I}.\<close>
>   for slices W I +  \<comment> \<open>An intact set is a set @{term I} satisfying the three assumptions below:\<close>
>   assumes intact_wb:"I \<subseteq> W"
>     and q_avail:"orig.quorum I" \<comment> \<open>@{term I} is a quorum in the original system.\<close>
>     and q_inter:"\<And> Q Q' . \<lbrakk>proj.quorum Q; proj.quorum Q'; Q \<inter> I \<noteq> {}; Q' \<inter> I \<noteq> {}\<rbrakk>  \<Longrightarrow> Q \<inter> Q' \<inter> I \<noteq> {}" 
>     \<comment> \<open>Any two sets that intersect @{term I} and that are quorums in the projected system intersect in @{term I}.
> Note that requiring that @{text \<open>Q \<inter> Q' \<noteq> {}\<close>} instead of @{text \<open>Q \<inter> Q' \<inter> I \<noteq> {}\<close>} would be equivalent.\<close>
> begin
> 
> theorem blocking_safe: \<comment> \<open>A set that blocks an intact node contains an intact node. 
> If this were not the case, quorum availability would trivially be violated.\<close>
>   fixes S n
>   assumes "n\<in>I" and "\<forall> Sl\<in> slices n .Sl\<inter>S \<noteq> {}"
>   shows "S \<inter> I \<noteq> {}"
>   using assms q_avail intact_wb unfolding orig.quorum_def 
>   by auto (metis inf.absorb_iff2 inf_assoc inf_bot_right inf_sup_aci(1)) 
> 
> theorem cascade:
> \<comment> \<open>If @{term U} is a quorum of an intact node and @{term S} is a super-set of @{term U}, then either @{term S} includes 
> all intact nodes or there is an intact node outside of @{term S} which is blocked by the intact members of @{term S}.
> This shows that, in SCP, once the intact members of a quorum accept a statement, 
> a cascading effect occurs and all intact nodes eventually accept it regardless of what befouled and faulty nodes do.\<close>
>   fixes U S
>   assumes "orig.quorum U" and "U \<inter> I \<noteq> {}" and "U \<subseteq> S"
>   obtains "I \<subseteq> S" | "\<exists> n \<in> I - S . \<forall> Sl \<in> slices n . Sl \<inter> S \<inter> I \<noteq> {}"
> proof -
>   have False if 1:"\<forall> n \<in> I - S . \<exists> Sl \<in> slices n . Sl \<inter> S \<inter> I = {}" and 2:"\<not>(I \<subseteq> S)"
>   proof -
>     text \<open>First we show that @{term \<open>I-S\<close>} is a quorum in the projected system. This is immediate from the definition of quorum and assumption 1.\<close>
>     have "proj.quorum (I-S)" using 1
>       unfolding proj.quorum_def project_def 
>       by (auto; smt DiffI Diff_Compl Diff_Int_distrib Diff_eq Diff_eq_empty_iff Int_commute)
>     text \<open>Then we show that U is also a quorum in the projected system:\<close>
>     moreover have "proj.quorum U" using \<open>orig.quorum U\<close> 
>       unfolding proj.quorum_def orig.quorum_def project_def 
>       by (simp; meson Int_commute inf.coboundedI2)
>     text \<open>Since quorums of @{term I} must intersect, we get a contradiction:\<close>
>     ultimately show False using \<open>U \<subseteq> S\<close> \<open>U \<inter> I \<noteq> {}\<close> \<open>\<not>(I\<subseteq>S)\<close> q_inter by auto
>   qed
>   thus ?thesis using that by blast
> qed
> 
> end
> 
> subsubsection "The Union Theorem"
> 
> text \<open>Here we prove that the union of two intact sets that intersect is intact.
> This implies that maximal intact sets are disjoint.\<close>
> 
> locale intersecting_intact = 
>   i1:intact slices W I\<^sub>1 + i2:intact slices W I\<^sub>2 \<comment> \<open>We fix two intersecting intact sets @{term I\<^sub>1} and @{term I\<^sub>2}.\<close>
>   + proj:stellar "project slices (I\<^sub>1\<union>I\<^sub>2)" W \<comment> \<open>We consider the projection of the system on @{term \<open>I\<^sub>1\<union>I\<^sub>2\<close>}.\<close>
>   for slices W I\<^sub>1 I\<^sub>2 +
> assumes inter:"I\<^sub>1 \<inter> I\<^sub>2 \<noteq> {}"
> begin
> 
> theorem union_quorum: "i1.orig.quorum (I\<^sub>1\<union>I\<^sub>2)" \<comment> \<open>@{term \<open>I\<^sub>1\<union>I\<^sub>2\<close>} is a quorum in the original system.\<close>
>   using i1.intact_axioms i2.intact_axioms
>   unfolding  intact_def stellar_def intact_axioms_def i1.orig.quorum_def
>   by (metis Int_iff Un_iff le_supI1 le_supI2)
> 
> theorem union_quorum_intersection: 
>   assumes "proj.quorum Q\<^sub>1" and "proj.quorum Q\<^sub>2" and "Q\<^sub>1 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}" and "Q\<^sub>2 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}"
>   shows "Q\<^sub>1 \<inter> Q\<^sub>2 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}"
>     \<comment> \<open>Any two sets that intersect @{term \<open>I\<^sub>1\<union>I\<^sub>2\<close>} and that are quorums in the system projected on @{term \<open>I\<^sub>1\<union>I\<^sub>2\<close>} intersect in @{term \<open>I\<^sub>1\<union>I\<^sub>2\<close>}.\<close>
> proof -
>   text \<open>First we show that @{term Q\<^sub>1} and @{term Q\<^sub>2} are quorums in the projections on @{term I\<^sub>1} and @{term I\<^sub>2}.\<close>
>   have "i1.proj.quorum Q\<^sub>1" using \<open>proj.quorum Q\<^sub>1\<close> 
>     unfolding i1.proj.quorum_def proj.quorum_def project_def
>     by auto (metis Int_Un_distrib Int_iff Un_subset_iff) 
>   moreover have "i2.proj.quorum Q\<^sub>2" using \<open>proj.quorum Q\<^sub>2\<close> 
>     unfolding i2.proj.quorum_def proj.quorum_def project_def
>     by auto (metis Int_Un_distrib Int_iff Un_subset_iff) 
>   moreover have "i2.proj.quorum Q\<^sub>1" using \<open>proj.quorum Q\<^sub>1\<close>
>     unfolding proj.quorum_def i2.proj.quorum_def project_def
>     by auto (metis Int_Un_distrib Int_iff Un_subset_iff) 
>   moreover have "i1.proj.quorum Q\<^sub>2" using \<open>proj.quorum Q\<^sub>2\<close>
>     unfolding proj.quorum_def i1.proj.quorum_def project_def
>     by auto (metis Int_Un_distrib Int_iff Un_subset_iff) 
>   text \<open>Next we show that @{term Q\<^sub>1} and @{term Q\<^sub>2} intersect if they are quorums of, respectively, @{term I\<^sub>1} and @{term I\<^sub>2}. 
> This is the only interesting part of the proof.\<close> 
>   moreover have "Q\<^sub>1 \<inter> Q\<^sub>2 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}" 
>     if "i1.proj.quorum Q\<^sub>1" and "i2.proj.quorum Q\<^sub>2" and "i2.proj.quorum Q\<^sub>1"
>       and "Q\<^sub>1 \<inter> I\<^sub>1 \<noteq> {}" and "Q\<^sub>2 \<inter> I\<^sub>2 \<noteq> {}"
>     for Q\<^sub>1 Q\<^sub>2
>   proof -
>     have "i1.proj.quorum I\<^sub>2" 
>     proof -
>       have "i1.orig.quorum I\<^sub>2" by (simp add: i2.q_avail)
>       thus ?thesis unfolding i1.orig.quorum_def i1.proj.quorum_def project_def
>         by auto (meson Int_commute Int_iff inf_le2 subset_trans)
>     qed
>     moreover note \<open>i1.proj.quorum Q\<^sub>1\<close>
>     ultimately have "Q\<^sub>1 \<inter> I\<^sub>2 \<noteq> {}" using i1.q_inter inter \<open>Q\<^sub>1 \<inter> I\<^sub>1 \<noteq> {}\<close> by blast
> 
>     moreover note \<open>i2.proj.quorum Q\<^sub>2\<close>  
>     moreover note \<open>i2.proj.quorum Q\<^sub>1\<close>
>     ultimately have "Q\<^sub>1 \<inter> Q\<^sub>2 \<inter> I\<^sub>2 \<noteq> {}" using i2.q_inter \<open>Q\<^sub>2 \<inter> I\<^sub>2 \<noteq> {}\<close> by blast 
>     thus ?thesis by (simp add: inf_sup_distrib1)
>   qed
>   text \<open>Next  we show that @{term Q\<^sub>1} and @{term Q\<^sub>2} intersect if they are quorums of the same intact set. This is obvious.\<close>
>   moreover
>   have "Q\<^sub>1 \<inter> Q\<^sub>2 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}" 
>     if "i1.proj.quorum Q\<^sub>1" and "i1.proj.quorum Q\<^sub>2" and "Q\<^sub>1 \<inter> I\<^sub>1 \<noteq> {}" and "Q\<^sub>2 \<inter> I\<^sub>1 \<noteq> {}"
>     for Q\<^sub>1 Q\<^sub>2
>     by (simp add: Int_Un_distrib i1.q_inter that)  
>   moreover
>   have "Q\<^sub>1 \<inter> Q\<^sub>2 \<inter> (I\<^sub>1\<union>I\<^sub>2) \<noteq> {}"
>     if "i2.proj.quorum Q\<^sub>1" and "i2.proj.quorum Q\<^sub>2" and "Q\<^sub>1 \<inter> I\<^sub>2 \<noteq> {}" and "Q\<^sub>2 \<inter> I\<^sub>2 \<noteq> {}"
>     for Q\<^sub>1 Q\<^sub>2
>     by (simp add: Int_Un_distrib i2.q_inter that)
>   text \<open>Finally we have covered all the cases and get the final result:\<close>
>   ultimately
>   show ?thesis
>     by (smt Int_Un_distrib Int_commute assms(3,4) sup_bot.right_neutral) 
==========
Stirling_Formula
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy ../../AFPs/afp-2020/thys/Stirling_Formula/Ln_Gamma_Asymptotics.thy
10c10
<   "HOL-Analysis.Analysis"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
198c198
<     by (rule has_vector_derivative_real_complex) (auto intro!: derivative_eq_intros)
---
>     by (rule has_vector_derivative_real_field) (auto intro!: derivative_eq_intros)
284c284
<          (auto intro!: derivative_eq_intros has_vector_derivative_real_complex
---
>          (auto intro!: derivative_eq_intros has_vector_derivative_real_field
510c510
<       by (auto intro!: derivative_eq_intros has_vector_derivative_real_complex simp: divide_simps power_add [symmetric]
---
>       by (auto intro!: derivative_eq_intros has_vector_derivative_real_field simp: divide_simps power_add [symmetric]
875c875
<       by (auto intro!: derivative_intros has_vector_derivative_real_complex
---
>       by (auto intro!: derivative_intros has_vector_derivative_real_field
909c909
<       by (intro derivative_intros has_vector_derivative_real_complex field_differentiable_derivI
---
>       by (intro derivative_intros has_vector_derivative_real_field field_differentiable_derivI
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stirling_Formula/Stirling_Formula.thy ../../AFPs/afp-2020/thys/Stirling_Formula/Stirling_Formula.thy
192c192
<     by (rule Lim_transform_eventually)
---
>     by (blast intro: Lim_transform_eventually)
245c245
< proof -
---
> proof (rule Lim_transform_eventually)
248c248
<   hence "(\<lambda>n. \<Sum>r<n. D (real r + x)) \<longlonglongrightarrow> P x" by (simp add: sums_def)
---
>   then show "(\<lambda>n. \<Sum>r<n. D (real r + x)) \<longlonglongrightarrow> P x" by (simp add: sums_def)
250c250
<     have "eventually (\<lambda>n. (\<Sum>r<n. D (real r + x)) = p n x) at_top"
---
>   show "eventually (\<lambda>n. (\<Sum>r<n. D (real r + x)) = p n x) at_top"
252d251
<   ultimately show ?thesis by (rule Lim_transform_eventually [rotated])
280c279
<     by (rule Lim_transform_eventually)
---
>     by (blast intro: Lim_transform_eventually)
408,410c407,408
<     show "\<forall>x\<in>{a..}. (\<lambda>n. f n x) \<longlonglongrightarrow> P x"
<     proof safe
<       fix x :: real assume x: "x \<ge> a"
---
>     show "(\<lambda>n. f n x) \<longlonglongrightarrow> P x" if "x\<in>{a..}" for x
>     proof -
413c411
<       with x have "eventually (\<lambda>n. f n x = P x) at_top"
---
>       with that have "eventually (\<lambda>n. f n x = P x) at_top"
415c413
<       thus "(\<lambda>n. f n x) \<longlonglongrightarrow> P x" by (simp add: Lim_eventually)
---
>       thus "(\<lambda>n. f n x) \<longlonglongrightarrow> P x" by (simp add: tendsto_eventually)
565,566c563
<       by (intro prod.cong refl) 
<          (simp add: divide_simps, (simp add: field_simps power2_eq_square eval_nat_numeral))
---
>       by (rule prod.cong) (simp_all add: power2_eq_square eval_nat_numeral)
==========
Stone_Algebras
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Algebras/Filters.thy ../../AFPs/afp-2020/thys/Stone_Algebras/Filters.thy
76a77,120
> abbreviation filters :: "'a set set"
>   where "filters \<equiv> { F::'a set . filter F }"
> 
> lemma filter_map_filter:
>   assumes "filter F"
>       and "mono f"
>       and "\<forall>x y . f x \<le> y \<longrightarrow> (\<exists>z . x \<le> z \<and> y = f z)"
>     shows "filter (f ` F)"
> proof (unfold ord_class.filter_def, intro conjI)
>   show "f ` F \<noteq> {}"
>     using assms(1) ord_class.filter_def by auto
> next
>   show "\<forall>x\<in>f ` F . \<forall>y\<in>f ` F . \<exists>z\<in>f ` F . z \<le> x \<and> z \<le> y"
>   proof (intro ballI)
>     fix x y
>     assume "x \<in> f ` F" and "y \<in> f ` F"
>     then obtain u v where 1: "x = f u \<and> u \<in> F \<and> y = f v \<and> v \<in> F"
>       by auto
>     then obtain w where "w \<le> u \<and> w \<le> v \<and> w \<in> F"
>       by (meson assms(1) ord_class.filter_def)
>     thus "\<exists>z\<in>f ` F . z \<le> x \<and> z \<le> y"
>       using 1 assms(2) mono_def image_eqI by blast
>   qed
> next
>   show "is_up_set (f ` F)"
>   proof
>     fix x
>     assume "x \<in> f ` F"
>     then obtain u where 1: "x = f u \<and> u \<in> F"
>       by auto
>     show "\<forall>y . x \<le> y \<longrightarrow> y \<in> f ` F"
>     proof (rule allI, rule impI)
>       fix y
>       assume "x \<le> y"
>       hence "f u \<le> y"
>         using 1 by simp
>       then obtain z where "u \<le> z \<and> y = f z"
>         using assms(3) by auto
>       thus "y \<in> f ` F"
>         by (meson 1 assms(1) image_iff ord_class.filter_def)
>     qed
>   qed
> qed
> 
318c362
< abbreviation "filter_sup F G \<equiv> { z . \<exists>x\<in>F . \<exists>y\<in>G . x \<sqinter> y \<le> z }"
---
> definition "filter_sup F G \<equiv> { z . \<exists>x\<in>F . \<exists>y\<in>G . x \<sqinter> y \<le> z }"
328c372
<     by blast
---
>     using filter_sup_def by blast
334c378
<       by auto
---
>       using filter_sup_def by auto
340c384
<         by auto
---
>         using filter_sup_def by auto
345c389
<         using assms 3 4 filter_inf_closed by blast
---
>         unfolding filter_sup_def using assms 3 4 filter_inf_closed by blast
351c395
<     using order_trans by blast
---
>     unfolding filter_sup_def using order_trans by blast
363c407
<     using inf.cobounded1 by blast
---
>     unfolding filter_sup_def using inf.cobounded1 by blast
368c412
<   using inf.commute by fastforce
---
>   unfolding filter_sup_def using inf.commute by fastforce
383c427
<     by auto
---
>     using filter_sup_def by auto
394c438
<   by blast
---
>   unfolding filter_sup_def by blast
398c442
<   by blast
---
>   unfolding filter_sup_def by blast
402c446
<   by blast
---
>   unfolding filter_sup_def by blast
408c452
<     by blast
---
>     unfolding filter_sup_def by blast
415c459
<       by auto
---
>       using filter_sup_def by auto
521,531c565,576
<   apply (simp add: less_eq_filter.rep_eq less_filter.rep_eq inf.less_le_not_le)
<   apply (simp add: less_eq_filter.rep_eq)
<   apply (simp add: less_eq_filter.rep_eq)
<   apply (simp add: Rep_filter_inject less_eq_filter.rep_eq)
<   apply (simp add: inf_filter.rep_eq less_eq_filter.rep_eq)
<   apply (simp add: inf_filter.rep_eq less_eq_filter.rep_eq)
<   apply (simp add: inf_filter.rep_eq less_eq_filter.rep_eq)
<   apply (simp add: less_eq_filter.rep_eq filter_sup_left_upper_bound sup_filter.rep_eq)
<   apply (simp add: less_eq_filter.rep_eq filter_sup_right_upper_bound sup_filter.rep_eq)
<   apply (simp add: less_eq_filter.rep_eq filter_sup_least_upper_bound sup_filter.rep_eq)
<   by (simp add: less_eq_filter.rep_eq top_filter.rep_eq)
---
>   subgoal apply transfer by (simp add: less_le_not_le)
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by (simp add: filter_sup_left_upper_bound)
>   subgoal apply transfer by (simp add: filter_sup_right_upper_bound)
>   subgoal apply transfer by (simp add: filter_sup_least_upper_bound)
>   subgoal apply transfer by simp
>   done
553c598,600
<   by intro_classes (simp add: less_eq_filter.rep_eq bot_filter.rep_eq)
---
>   apply intro_classes
>   apply transfer
>   by simp
603,637c650
< proof (unfold filter_def, intro conjI)
<   show "f ` Rep_filter F \<noteq> {}"
<     by (metis empty_is_image filter_def simp_filter)
< next
<   show "\<forall>x\<in>f ` Rep_filter F . \<forall>y\<in>f ` Rep_filter F . \<exists>z\<in>f ` Rep_filter F . z \<le> x \<and> z \<le> y"
<   proof (intro ballI)
<     fix x y
<     assume "x \<in> f ` Rep_filter F" and "y \<in> f ` Rep_filter F"
<     then obtain u v where 1: "x = f u \<and> u \<in> Rep_filter F \<and> y = f v \<and> v \<in> Rep_filter F"
<       by auto
<     then obtain w where "w \<le> u \<and> w \<le> v \<and> w \<in> Rep_filter F"
<       by (meson filter_def simp_filter)
<     thus "\<exists>z\<in>f ` Rep_filter F . z \<le> x \<and> z \<le> y"
<       using 1 assms(1) mono_def rev_image_eqI by blast
<   qed
< next
<   show "is_up_set (f ` Rep_filter F)"
<   proof
<     fix x
<     assume "x \<in> f ` Rep_filter F"
<     then obtain u where 1: "x = f u \<and> u \<in> Rep_filter F"
<       by auto
<     show "\<forall>y . x \<le> y \<longrightarrow> y \<in> f ` Rep_filter F"
<     proof (rule allI, rule impI)
<       fix y
<       assume "x \<le> y"
<       hence "f u \<le> y"
<         using 1 by simp
<       then obtain z where "u \<le> z \<and> y = f z"
<         using assms(2) by auto
<       thus "y \<in> f ` Rep_filter F"
<         using 1 by (meson image_iff filter_def simp_filter)
<     qed
<   qed
< qed
---
>   by (simp add: assms inf.filter_map_filter)
658c671
<     using filter_sup_right_isotone_var by blast
---
>     unfolding filter_sup_def using filter_sup_right_isotone_var by blast
665c678
<       by auto
---
>       using filter_sup_def by auto
679c692
<       using 2 3 by blast
---
>       unfolding filter_sup_def using 2 3 by blast
694c707
<     using order_refl by blast
---
>     unfolding filter_sup_def using order_refl by blast
717c730
<     using 2 inf.cobounded1 inf.cobounded2 by blast
---
>     unfolding filter_sup_def using 2 inf.cobounded1 inf.cobounded2 by blast
735c748
<         using 2 inf.cobounded1 by blast
---
>         unfolding filter_sup_def using 2 inf.cobounded1 by blast
845a859,889
> lemma up_dist_inf_inter:
>   assumes "is_up_set S"
>     shows "\<up>(x \<sqinter> y) \<inter> S = filter_sup (\<up>x \<inter> S) (\<up>y \<inter> S) \<inter> S"
> proof
>   show "\<up>(x \<sqinter> y) \<inter> S \<subseteq> filter_sup (\<up>x \<inter> S) (\<up>y \<inter> S) \<inter> S"
>   proof
>     fix z
>     let ?x = "x \<squnion> z"
>     let ?y = "y \<squnion> z"
>     assume "z \<in> \<up>(x \<sqinter> y) \<inter> S"
>     hence 1: "x \<sqinter> y \<le> z \<and> z \<in> S"
>       by auto
>     hence "?x \<in> (\<up>x \<inter> S) \<and> ?y \<in> (\<up>y \<inter> S) \<and> ?x \<sqinter> ?y \<le> z"
>       using assms sup_absorb2 sup_inf_distrib2 by fastforce
>     thus "z \<in> filter_sup (\<up>x \<inter> S) (\<up>y \<inter> S) \<inter> S"
>       using filter_sup_def 1 by fastforce
>   qed
> next
>   show "filter_sup (\<up>x \<inter> S) (\<up>y \<inter> S) \<inter> S \<subseteq> \<up>(x \<sqinter> y) \<inter> S"
>   proof
>     fix z
>     assume "z \<in> filter_sup (\<up>x \<inter> S) (\<up>y \<inter> S) \<inter> S"
>     then obtain u v where 2: "u\<in>\<up>x \<and> v\<in>\<up>y \<and> u \<sqinter> v \<le> z \<and> z \<in> S"
>       using filter_sup_def by auto
>     hence "x \<sqinter> y \<le> z"
>       using order.trans inf_mono by blast
>     thus "z \<in> \<up>(x \<sqinter> y) \<inter> S"
>       using 2 by blast
>   qed
> qed
> 
892,906c936,938
< proof
<   fix x y z :: "'a filter"
<   have "Rep_filter (x \<squnion> (y \<sqinter> z)) = filter_sup (Rep_filter x) (Rep_filter (y \<sqinter> z))"
<     by (simp add: sup_filter.rep_eq)
<   also have "... = filter_sup (Rep_filter x) (Rep_filter y \<inter> Rep_filter z)"
<     by (simp add: inf_filter.rep_eq)
<   also have "... = filter_sup (Rep_filter x) (Rep_filter y) \<inter> filter_sup (Rep_filter x) (Rep_filter z)"
<     by (simp add: filter_sup_left_dist_inf)
<   also have "... = Rep_filter (x \<squnion> y) \<inter> Rep_filter (x \<squnion> z)"
<     by (simp add: sup_filter.rep_eq)
<   also have "... = Rep_filter ((x \<squnion> y) \<sqinter> (x \<squnion> z))"
<     by (simp add: inf_filter.rep_eq)
<   finally show "x \<squnion> (y \<sqinter> z) = (x \<squnion> y) \<sqinter> (x \<squnion> z)"
<     by (simp add: Rep_filter_inject)
< qed
---
>   apply intro_classes
>   apply transfer
>   by (simp add: filter_sup_left_dist_inf)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Algebras/Lattice_Basics.thy ../../AFPs/afp-2020/thys/Stone_Algebras/Lattice_Basics.thy
17a18,19
> subsection \<open>General Facts and Notations\<close>
> 
21a24,28
> lemma imp_as_conj:
>   assumes "P x \<Longrightarrow> Q x"
>   shows "P x \<and> Q x \<longleftrightarrow> P x"
>   using assms by auto
> 
84a92,93
> subsection \<open>Orders\<close>
> 
151a161,162
> subsection \<open>Semilattices\<close>
> 
233a245,246
> subsection \<open>Lattices\<close>
> 
319a333,334
> subsection \<open>Linear Orders\<close>
> 
419a435,436
> subsection \<open>Non-trivial Algebras\<close>
> 
444a462,555
> 
> subsection \<open>Homomorphisms\<close>
> 
> text \<open>
> This section gives definitions of lattice homomorphisms and isomorphisms and basic properties.
> \<close>
> 
> class sup_inf_top_bot_uminus = sup + inf + top + bot + uminus
> class sup_inf_top_bot_uminus_ord = sup_inf_top_bot_uminus + ord
> 
> context boolean_algebra
> begin
> 
> subclass sup_inf_top_bot_uminus_ord .
> 
> end
> 
> abbreviation sup_homomorphism :: "('a::sup \<Rightarrow> 'b::sup) \<Rightarrow> bool"
>   where "sup_homomorphism f \<equiv> \<forall>x y . f (x \<squnion> y) = f x \<squnion> f y"
> 
> abbreviation inf_homomorphism :: "('a::inf \<Rightarrow> 'b::inf) \<Rightarrow> bool"
>   where "inf_homomorphism f \<equiv> \<forall>x y . f (x \<sqinter> y) = f x \<sqinter> f y"
> 
> abbreviation bot_homomorphism :: "('a::bot \<Rightarrow> 'b::bot) \<Rightarrow> bool"
>   where "bot_homomorphism f \<equiv> f bot = bot"
> 
> abbreviation top_homomorphism :: "('a::top \<Rightarrow> 'b::top) \<Rightarrow> bool"
>   where "top_homomorphism f \<equiv> f top = top"
> 
> abbreviation minus_homomorphism :: "('a::minus \<Rightarrow> 'b::minus) \<Rightarrow> bool"
>   where "minus_homomorphism f \<equiv> \<forall>x y . f (x - y) = f x - f y"
> 
> abbreviation uminus_homomorphism :: "('a::uminus \<Rightarrow> 'b::uminus) \<Rightarrow> bool"
>   where "uminus_homomorphism f \<equiv> \<forall>x . f (-x) = -f x"
> 
> abbreviation sup_inf_homomorphism :: "('a::{sup,inf} \<Rightarrow> 'b::{sup,inf}) \<Rightarrow> bool"
>   where "sup_inf_homomorphism f \<equiv> sup_homomorphism f \<and> inf_homomorphism f"
> 
> abbreviation sup_inf_top_homomorphism :: "('a::{sup,inf,top} \<Rightarrow> 'b::{sup,inf,top}) \<Rightarrow> bool"
>   where "sup_inf_top_homomorphism f \<equiv> sup_inf_homomorphism f \<and> top_homomorphism f"
> 
> abbreviation sup_inf_top_bot_homomorphism :: "('a::{sup,inf,top,bot} \<Rightarrow> 'b::{sup,inf,top,bot}) \<Rightarrow> bool"
>   where "sup_inf_top_bot_homomorphism f \<equiv> sup_inf_top_homomorphism f \<and> bot_homomorphism f"
> 
> abbreviation bounded_lattice_homomorphism :: "('a::bounded_lattice \<Rightarrow> 'b::bounded_lattice) \<Rightarrow> bool"
>   where "bounded_lattice_homomorphism f \<equiv> sup_inf_top_bot_homomorphism f"
> 
> abbreviation sup_inf_top_bot_uminus_homomorphism :: "('a::sup_inf_top_bot_uminus \<Rightarrow> 'b::sup_inf_top_bot_uminus) \<Rightarrow> bool"
>   where "sup_inf_top_bot_uminus_homomorphism f \<equiv> sup_inf_top_bot_homomorphism f \<and> uminus_homomorphism f"
> 
> abbreviation sup_inf_top_bot_uminus_ord_homomorphism :: "('a::sup_inf_top_bot_uminus_ord \<Rightarrow> 'b::sup_inf_top_bot_uminus_ord) \<Rightarrow> bool"
>   where "sup_inf_top_bot_uminus_ord_homomorphism f \<equiv> sup_inf_top_bot_uminus_homomorphism f \<and> (\<forall>x y . x \<le> y \<longrightarrow> f x \<le> f y)"
> 
> abbreviation sup_inf_top_isomorphism :: "('a::{sup,inf,top} \<Rightarrow> 'b::{sup,inf,top}) \<Rightarrow> bool"
>   where "sup_inf_top_isomorphism f \<equiv> sup_inf_top_homomorphism f \<and> bij f"
> 
> abbreviation bounded_lattice_top_isomorphism :: "('a::bounded_lattice_top \<Rightarrow> 'b::bounded_lattice_top) \<Rightarrow> bool"
>   where "bounded_lattice_top_isomorphism f \<equiv> sup_inf_top_isomorphism f"
> 
> abbreviation sup_inf_top_bot_uminus_isomorphism :: "('a::sup_inf_top_bot_uminus \<Rightarrow> 'b::sup_inf_top_bot_uminus) \<Rightarrow> bool"
>   where "sup_inf_top_bot_uminus_isomorphism f \<equiv> sup_inf_top_bot_uminus_homomorphism f \<and> bij f"
> 
> abbreviation boolean_algebra_isomorphism :: "('a::boolean_algebra \<Rightarrow> 'b::boolean_algebra) \<Rightarrow> bool"
>   where "boolean_algebra_isomorphism f \<equiv> sup_inf_top_bot_uminus_isomorphism f \<and> minus_homomorphism f"
> 
> lemma sup_homomorphism_mono:
>   "sup_homomorphism (f::'a::semilattice_sup \<Rightarrow> 'b::semilattice_sup) \<Longrightarrow> mono f"
>   by (metis le_iff_sup monoI)
> 
> lemma sup_isomorphism_ord_isomorphism:
>   assumes "sup_homomorphism (f::'a::semilattice_sup \<Rightarrow> 'b::semilattice_sup)"
>       and "bij f"
>     shows "x \<le> y \<longleftrightarrow> f x \<le> f y"
> proof
>   assume "x \<le> y"
>   thus "f x \<le> f y"
>     by (metis assms(1) le_iff_sup)
> next
>   assume "f x \<le> f y"
>   hence "f (x \<squnion> y) = f y"
>     by (simp add: assms(1) le_iff_sup)
>   hence "x \<squnion> y = y"
>     by (metis injD bij_is_inj assms(2))
>   thus "x \<le> y"
>     by (simp add: le_iff_sup)
> qed
> 
> lemma minus_homomorphism_default:
>   assumes "\<forall>x y::'a::{inf,minus,uminus} . x - y = x \<sqinter> -y"
>       and "\<forall>x y::'b::{inf,minus,uminus} . x - y = x \<sqinter> -y"
>       and "inf_homomorphism (f::'a \<Rightarrow> 'b)"
>       and "uminus_homomorphism f"
>     shows "minus_homomorphism f"
>   by (simp add: assms)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Algebras/P_Algebras.thy ../../AFPs/afp-2020/thys/Stone_Algebras/P_Algebras.thy
46a47,48
> subclass sup_inf_top_bot_uminus_ord .
> 
778a781,783
> 
> abbreviation stone_algebra_isomorphism :: "('a::stone_algebra \<Rightarrow> 'b::stone_algebra) \<Rightarrow> bool"
>   where "stone_algebra_isomorphism f \<equiv> sup_inf_top_bot_uminus_isomorphism f"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Algebras/Stone_Construction.thy ../../AFPs/afp-2020/thys/Stone_Algebras/Stone_Construction.thy
51,128d50
< subsection \<open>Triples\<close>
< 
< text \<open>
< This section gives definitions of lattice homomorphisms and isomorphisms and basic properties.
< It concludes with a locale that represents triples as discussed above.
< \<close>
< 
< class sup_inf_top_bot_uminus = sup + inf + top + bot + uminus
< class sup_inf_top_bot_uminus_ord = sup_inf_top_bot_uminus + ord
< 
< context p_algebra
< begin
< 
< subclass sup_inf_top_bot_uminus_ord .
< 
< end
< 
< abbreviation sup_homomorphism :: "('a::sup \<Rightarrow> 'b::sup) \<Rightarrow> bool"
<   where "sup_homomorphism f \<equiv> \<forall>x y . f (x \<squnion> y) = f x \<squnion> f y"
< 
< abbreviation inf_homomorphism :: "('a::inf \<Rightarrow> 'b::inf) \<Rightarrow> bool"
<   where "inf_homomorphism f \<equiv> \<forall>x y . f (x \<sqinter> y) = f x \<sqinter> f y"
< 
< abbreviation sup_inf_homomorphism :: "('a::{sup,inf} \<Rightarrow> 'b::{sup,inf}) \<Rightarrow> bool"
<   where "sup_inf_homomorphism f \<equiv> sup_homomorphism f \<and> inf_homomorphism f"
< 
< abbreviation sup_inf_top_homomorphism :: "('a::{sup,inf,top} \<Rightarrow> 'b::{sup,inf,top}) \<Rightarrow> bool"
<   where "sup_inf_top_homomorphism f \<equiv> sup_inf_homomorphism f \<and> f top = top"
< 
< abbreviation sup_inf_top_bot_homomorphism :: "('a::{sup,inf,top,bot} \<Rightarrow> 'b::{sup,inf,top,bot}) \<Rightarrow> bool"
<   where "sup_inf_top_bot_homomorphism f \<equiv> sup_inf_top_homomorphism f \<and> f bot = bot"
< 
< abbreviation bounded_lattice_homomorphism :: "('a::bounded_lattice \<Rightarrow> 'b::bounded_lattice) \<Rightarrow> bool"
<   where "bounded_lattice_homomorphism f \<equiv> sup_inf_top_bot_homomorphism f"
< 
< abbreviation sup_inf_top_bot_uminus_homomorphism :: "('a::sup_inf_top_bot_uminus \<Rightarrow> 'b::sup_inf_top_bot_uminus) \<Rightarrow> bool"
<   where "sup_inf_top_bot_uminus_homomorphism f \<equiv> sup_inf_top_bot_homomorphism f \<and> (\<forall>x . f (-x) = -f x)"
< 
< abbreviation sup_inf_top_bot_uminus_ord_homomorphism :: "('a::sup_inf_top_bot_uminus_ord \<Rightarrow> 'b::sup_inf_top_bot_uminus_ord) \<Rightarrow> bool"
<   where "sup_inf_top_bot_uminus_ord_homomorphism f \<equiv> sup_inf_top_bot_uminus_homomorphism f \<and> (\<forall>x y . x \<le> y \<longrightarrow> f x \<le> f y)"
< 
< abbreviation sup_inf_top_isomorphism :: "('a::{sup,inf,top} \<Rightarrow> 'b::{sup,inf,top}) \<Rightarrow> bool"
<   where "sup_inf_top_isomorphism f \<equiv> sup_inf_top_homomorphism f \<and> bij f"
< 
< abbreviation bounded_lattice_top_isomorphism :: "('a::bounded_lattice_top \<Rightarrow> 'b::bounded_lattice_top) \<Rightarrow> bool"
<   where "bounded_lattice_top_isomorphism f \<equiv> sup_inf_top_isomorphism f"
< 
< abbreviation sup_inf_top_bot_uminus_isomorphism :: "('a::sup_inf_top_bot_uminus \<Rightarrow> 'b::sup_inf_top_bot_uminus) \<Rightarrow> bool"
<   where "sup_inf_top_bot_uminus_isomorphism f \<equiv> sup_inf_top_bot_uminus_homomorphism f \<and> bij f"
< 
< abbreviation stone_algebra_isomorphism :: "('a::stone_algebra \<Rightarrow> 'b::stone_algebra) \<Rightarrow> bool"
<   where "stone_algebra_isomorphism f \<equiv> sup_inf_top_bot_uminus_isomorphism f"
< 
< abbreviation boolean_algebra_isomorphism :: "('a::boolean_algebra \<Rightarrow> 'b::boolean_algebra) \<Rightarrow> bool"
<   where "boolean_algebra_isomorphism f \<equiv> sup_inf_top_bot_uminus_isomorphism f"
< 
< lemma sup_homomorphism_mono:
<   "sup_homomorphism (f::'a::semilattice_sup \<Rightarrow> 'b::semilattice_sup) \<Longrightarrow> mono f"
<   by (metis le_iff_sup monoI)
< 
< lemma sup_isomorphism_ord_isomorphism:
<   assumes "sup_homomorphism (f::'a::semilattice_sup \<Rightarrow> 'b::semilattice_sup)"
<       and "bij f"
<     shows "x \<le> y \<longleftrightarrow> f x \<le> f y"
< proof
<   assume "x \<le> y"
<   thus "f x \<le> f y"
<     by (metis assms(1) le_iff_sup)
< next
<   assume "f x \<le> f y"
<   hence "f (x \<squnion> y) = f y"
<     by (simp add: assms(1) le_iff_sup)
<   hence "x \<squnion> y = y"
<     by (metis injD bij_is_inj assms(2))
<   thus "x \<le> y"
<     by (simp add: le_iff_sup)
< qed
< 
188,203c110,126
<   apply (simp add: less_eq_regular.rep_eq less_regular.rep_eq inf.less_le_not_le)
<   apply (simp add: less_eq_regular.rep_eq)
<   apply (simp add: less_eq_regular.rep_eq)
<   apply (simp add: Rep_regular_inject less_eq_regular.rep_eq)
<   apply (simp add: inf_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: inf_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: inf_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: sup_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: sup_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: sup_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: bot_regular.rep_eq less_eq_regular.rep_eq)
<   apply (simp add: top_regular.rep_eq less_eq_regular.rep_eq)
<   apply (metis (mono_tags) Rep_regular_inject inf_regular.rep_eq sup_inf_distrib1 sup_regular.rep_eq)
<   apply (metis (mono_tags) Rep_regular_inverse bot_regular.abs_eq inf_regular.rep_eq inf_p uminus_regular.rep_eq)
<   apply (metis (mono_tags) top_regular.abs_eq Rep_regular_inverse simp_regular stone sup_regular.rep_eq uminus_regular.rep_eq)
<   by (metis (mono_tags) Rep_regular_inject inf_regular.rep_eq minus_regular.rep_eq uminus_regular.rep_eq)
---
>   subgoal apply transfer by (simp add: less_le_not_le)
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by (simp add: sup_inf_distrib1)
>   subgoal apply transfer by simp
>   subgoal apply transfer by auto
>   subgoal apply transfer by simp
>   done
256,267c179,191
<   apply (simp add: less_eq_dense.rep_eq less_dense.rep_eq inf.less_le_not_le)
<   apply (simp add: less_eq_dense.rep_eq)
<   apply (simp add: less_eq_dense.rep_eq)
<   apply (simp add: Rep_dense_inject less_eq_dense.rep_eq)
<   apply (simp add: inf_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: inf_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: inf_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: sup_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: sup_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: sup_dense.rep_eq less_eq_dense.rep_eq)
<   apply (simp add: top_dense.rep_eq less_eq_dense.rep_eq)
<   by (metis (mono_tags, lifting) Rep_dense_inject sup_inf_distrib1 inf_dense.rep_eq sup_dense.rep_eq)
---
>   subgoal apply transfer by (simp add: inf.less_le_not_le)
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by (simp add: sup_inf_distrib1)
>   done
307,319c231,244
<   apply (simp add: less_eq_dense_filter_type.rep_eq less_dense_filter_type.rep_eq inf.less_le_not_le)
<   apply (simp add: less_eq_dense_filter_type.rep_eq)
<   apply (simp add: less_eq_dense_filter_type.rep_eq inf.order_lesseq_imp)
<   apply (simp add: Rep_dense_filter_type_inject less_eq_dense_filter_type.rep_eq)
<   apply (simp add: inf_dense_filter_type.rep_eq less_eq_dense_filter_type.rep_eq)
<   apply (simp add: inf_dense_filter_type.rep_eq less_eq_dense_filter_type.rep_eq)
<   apply (simp add: inf_dense_filter_type.rep_eq less_eq_dense_filter_type.rep_eq)
<   apply (simp add: less_eq_dense_filter_type.rep_eq sup_dense_filter_type.rep_eq)
<   apply (simp add: less_eq_dense_filter_type.rep_eq sup_dense_filter_type.rep_eq)
<   apply (simp add: less_eq_dense_filter_type.rep_eq sup_dense_filter_type.rep_eq)
<   apply (simp add: less_eq_dense_filter_type.rep_eq bot_dense_filter_type.rep_eq)
<   apply (simp add: top_dense_filter_type.rep_eq less_eq_dense_filter_type.rep_eq)
<   by (metis (mono_tags, lifting) Rep_dense_filter_type_inject sup_inf_distrib1 inf_dense_filter_type.rep_eq sup_dense_filter_type.rep_eq)
---
>   subgoal apply transfer by (simp add: inf.less_le_not_le)
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by simp
>   subgoal apply transfer by (simp add: sup_inf_distrib1)
>   done
331,332c256,257
< abbreviation stone_phi_set :: "'a::stone_algebra regular \<Rightarrow> 'a dense set"
<   where "stone_phi_set x \<equiv> { y . -Rep_regular x \<le> Rep_dense y }"
---
> abbreviation stone_phi_base :: "'a::stone_algebra regular \<Rightarrow> 'a dense set"
>   where "stone_phi_base x \<equiv> { y . -Rep_regular x \<le> Rep_dense y }"
334,335c259,260
< lemma stone_phi_set_filter:
<   "filter (stone_phi_set x)"
---
> lemma stone_phi_base_filter:
>   "filter (stone_phi_base x)"
342c267
<   where "stone_phi x = Abs_filter (stone_phi_set x)"
---
>   where "stone_phi x = Abs_filter (stone_phi_base x)"
363c288
<     have "stone_phi_set (x \<squnion> y) = filter_sup (stone_phi_set x) (stone_phi_set y)"
---
>     have "stone_phi_base (x \<squnion> y) = filter_sup (stone_phi_base x) (stone_phi_base y)"
366c291
<       assume 2: "z \<in> stone_phi_set (x \<squnion> y)"
---
>       assume 2: "z \<in> stone_phi_base (x \<squnion> y)"
371c296
<       have 3: "?v \<in> stone_phi_set x \<and> ?w \<in> stone_phi_set y"
---
>       have 3: "?v \<in> stone_phi_base x \<and> ?w \<in> stone_phi_base y"
381,382c306,307
<       finally show "z \<in> filter_sup (stone_phi_set x) (stone_phi_set y)"
<         using 3 mem_Collect_eq order_refl by fastforce
---
>       finally show "z \<in> filter_sup (stone_phi_base x) (stone_phi_base y)"
>         using 3 mem_Collect_eq order_refl filter_sup_def by fastforce
385,387c310,312
<       assume "z \<in> filter_sup (stone_phi_set x) (stone_phi_set y)"
<       then obtain v w where 4: "v \<in> stone_phi_set x \<and> w \<in> stone_phi_set y \<and> v \<sqinter> w \<le> z"
<         by auto
---
>       assume "z \<in> filter_sup (stone_phi_base x) (stone_phi_base y)"
>       then obtain v w where 4: "v \<in> stone_phi_base x \<and> w \<in> stone_phi_base y \<and> v \<sqinter> w \<le> z"
>         unfolding filter_sup_def by auto
398c323
<       finally show "z \<in> stone_phi_set (x \<squnion> y)"
---
>       finally show "z \<in> stone_phi_base (x \<squnion> y)"
402c327
<       by (simp add: stone_phi_def eq_onp_same_args stone_phi_set_filter sup_filter.abs_eq)
---
>       by (simp add: stone_phi_def eq_onp_same_args stone_phi_base_filter sup_filter.abs_eq)
410c335
<     hence "stone_phi_set (x \<sqinter> y) = (stone_phi_set x) \<inter> (stone_phi_set y)"
---
>     hence "stone_phi_base (x \<sqinter> y) = (stone_phi_base x) \<inter> (stone_phi_base y)"
413c338
<       by (simp add: stone_phi_def eq_onp_same_args stone_phi_set_filter inf_filter.abs_eq)
---
>       by (simp add: stone_phi_def eq_onp_same_args stone_phi_base_filter inf_filter.abs_eq)
458a384,386
> fun pairs_minus :: "('a \<times> 'b filter) \<Rightarrow> ('a \<times> 'b filter) \<Rightarrow> ('a \<times> 'b filter)"
>   where "pairs_minus (x,y) (z,w) = (x \<sqinter> -z,y \<squnion> phi z)"
> 
1056c984
< lift_definition less_stone_phi_pair :: "'a stone_phi_pair \<Rightarrow> 'a stone_phi_pair \<Rightarrow> bool" is "\<lambda>xf yf . triple.pairs_less_eq xf yf \<and> \<not> triple.pairs_less_eq yf xf" .
---
> lift_definition less_stone_phi_pair :: "'a stone_phi_pair \<Rightarrow> 'a stone_phi_pair \<Rightarrow> bool" is triple.pairs_less .
1061a990,1015
> (*
> instantiation stone_phi_pair :: (stone_algebra) stone_algebra
> begin
> 
> instance
>   apply intro_classes
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by (metis (no_types, lifting) Pair_inject compl_bot_eq heyting.implies_order stone_phi.pairs_less_eq.elims(3) stone_phi.phi_top stone_phi.triple_axioms sup_top_left top_greatest triple_def)
>   subgoal apply transfer by (metis (no_types, lifting) Pair_inject stone_phi.pairs_less_eq.elims(3) top.extremum bot_least bot_filter.abs_eq)
>   subgoal apply transfer using stone_phi.triple_axioms triple.pairs_sup_dist_inf by fastforce
>   subgoal apply transfer using stone_phi.pairs_uminus_galois by fastforce
>   subgoal apply transfer using stone_phi.pairs_stone by fastforce
>   done
> 
> end
> *)
> 
1324a1279,1282
> lemma stone_phi_embed_strict_order_isomorphism:
>   "x < y \<longleftrightarrow> stone_phi_embed x < stone_phi_embed y"
>   by (smt less_eq_stone_phi_pair.rep_eq less_le_not_le less_stone_phi_pair.rep_eq stone_phi.pairs_less.elims(2,3) stone_phi_embed_homomorphism stone_phi_embed_order_injective)
> 
1336c1294
<   apply (simp add: less_stone_phi_pair.rep_eq less_eq_stone_phi_pair.rep_eq)
---
>   apply (metis (mono_tags, lifting) stone_phi_embed_homomorphism stone_phi_embed_strict_order_isomorphism stone_phi_embed_order_injective less_le_not_le)
1381,1382c1339,1340
<     also have "... = stone_phi_set (Abs_regular (-x)) \<inter> \<up>(Abs_dense (y \<squnion> -y))"
<       by (metis Abs_filter_inverse mem_Collect_eq up_filter stone_phi_set_filter stone_phi_def)
---
>     also have "... = stone_phi_base (Abs_regular (-x)) \<inter> \<up>(Abs_dense (y \<squnion> -y))"
>       by (metis Abs_filter_inverse mem_Collect_eq up_filter stone_phi_base_filter stone_phi_def)
1407c1365
<   have "\<up>(Abs_dense (x \<squnion> -x)) \<le> stone_phi_set (Abs_regular (--x))"
---
>   have "\<up>(Abs_dense (x \<squnion> -x)) \<le> stone_phi_base (Abs_regular (--x))"
1416c1374
<     thus "z \<in> stone_phi_set (Abs_regular (--x))"
---
>     thus "z \<in> stone_phi_base (Abs_regular (--x))"
1420c1378
<     by (unfold stone_phi_def, subst less_eq_filter.abs_eq, simp_all add: eq_onp_same_args stone_phi_set_filter)
---
>     by (unfold stone_phi_def, subst less_eq_filter.abs_eq, simp_all add: eq_onp_same_args stone_phi_base_filter)
1468,1469c1426,1427
<     also have "... = stone_phi_set x"
<       by (simp add: stone_phi_def Abs_filter_inverse stone_phi_set_filter)
---
>     also have "... = stone_phi_base x"
>       by (simp add: stone_phi_def Abs_filter_inverse stone_phi_base_filter)
1563c1521
<       finally have "?u \<in> stone_phi_set (Abs_regular (-y))"
---
>       finally have "?u \<in> stone_phi_base (Abs_regular (-y))"
1566c1524
<         by (metis mem_Collect_eq stone_phi_def stone_phi_set_filter Abs_filter_inverse)
---
>         by (metis mem_Collect_eq stone_phi_def stone_phi_base_filter Abs_filter_inverse)
1572c1530
<         using 4 5 sup_filter.rep_eq by blast
---
>         using 4 5 sup_filter.rep_eq filter_sup_def by blast
1746,1761c1704,1720
<   apply (simp add: less_eq_lifted_boolean_algebra.rep_eq less_lifted_boolean_algebra.rep_eq)
<   apply (simp add: less_eq_lifted_boolean_algebra.rep_eq)
<   using less_eq_lifted_boolean_algebra.rep_eq order_trans apply fastforce
<   apply (metis less_eq_lifted_boolean_algebra.rep_eq antisym ext Rep_lifted_boolean_algebra_inject)
<   apply (simp add: inf_lifted_boolean_algebra.rep_eq less_eq_lifted_boolean_algebra.rep_eq)
<   apply (simp add: inf_lifted_boolean_algebra.rep_eq less_eq_lifted_boolean_algebra.rep_eq)
<   apply (simp add: inf_lifted_boolean_algebra.rep_eq less_eq_lifted_boolean_algebra.rep_eq)
<   apply (simp add: sup_lifted_boolean_algebra.rep_eq less_eq_lifted_boolean_algebra.rep_eq)
<   apply (simp add: less_eq_lifted_boolean_algebra.rep_eq sup_lifted_boolean_algebra.rep_eq)
<   apply (simp add: less_eq_lifted_boolean_algebra.rep_eq sup_lifted_boolean_algebra.rep_eq)
<   apply (simp add: bot_lifted_boolean_algebra.rep_eq less_eq_lifted_boolean_algebra.rep_eq)
<   apply (simp add: less_eq_lifted_boolean_algebra.rep_eq top_lifted_boolean_algebra.rep_eq)
<   apply (unfold Rep_lifted_boolean_algebra_inject[THEN sym] sup_lifted_boolean_algebra.rep_eq inf_lifted_boolean_algebra.rep_eq, simp add: sup_inf_distrib1)
<   apply (unfold Rep_lifted_boolean_algebra_inject[THEN sym] inf_lifted_boolean_algebra.rep_eq uminus_lifted_boolean_algebra.rep_eq bot_lifted_boolean_algebra.rep_eq, simp)
<   apply (unfold Rep_lifted_boolean_algebra_inject[THEN sym] sup_lifted_boolean_algebra.rep_eq uminus_lifted_boolean_algebra.rep_eq top_lifted_boolean_algebra.rep_eq, simp)
<   by (unfold Rep_lifted_boolean_algebra_inject[THEN sym] inf_lifted_boolean_algebra.rep_eq uminus_lifted_boolean_algebra.rep_eq minus_lifted_boolean_algebra.rep_eq, simp add: diff_eq)
---
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer using order_trans by blast
>   subgoal apply transfer using antisym ext by blast
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by (simp add: sup_inf_distrib1)
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by (simp add: diff_eq)
>   done
1862d1820
< next
1865d1822
< next
1885,1886c1842
< next
<   show "\<forall>pf qf . Abs_lifted_boolean_algebra (\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf \<sqinter> qf)) f)) = Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \<sqinter> Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))"
---
>   show 1: "\<forall>pf qf . Abs_lifted_boolean_algebra (\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf \<sqinter> qf)) f)) = Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \<sqinter> Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))"
1905d1860
< next
1925c1880,1881
< next
---
>   thus "\<forall>pf qf . Abs_lifted_boolean_algebra (\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf - qf)) f)) = Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) - Abs_lifted_boolean_algebra (\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))"
>     using 1 by (simp add: diff_eq)
1957,1968c1913,1925
<   apply (simp add: less_eq_lifted_distrib_lattice_top.rep_eq less_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: less_eq_lifted_distrib_lattice_top.rep_eq)
<   using less_eq_lifted_distrib_lattice_top.rep_eq order_trans apply fastforce
<   apply (metis less_eq_lifted_distrib_lattice_top.rep_eq antisym ext Rep_lifted_distrib_lattice_top_inject)
<   apply (simp add: inf_lifted_distrib_lattice_top.rep_eq less_eq_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: inf_lifted_distrib_lattice_top.rep_eq less_eq_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: inf_lifted_distrib_lattice_top.rep_eq less_eq_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: sup_lifted_distrib_lattice_top.rep_eq less_eq_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: less_eq_lifted_distrib_lattice_top.rep_eq sup_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: less_eq_lifted_distrib_lattice_top.rep_eq sup_lifted_distrib_lattice_top.rep_eq)
<   apply (simp add: less_eq_lifted_distrib_lattice_top.rep_eq top_lifted_distrib_lattice_top.rep_eq)
<   by (unfold Rep_lifted_distrib_lattice_top_inject[THEN sym] sup_lifted_distrib_lattice_top.rep_eq inf_lifted_distrib_lattice_top.rep_eq, simp add: sup_inf_distrib1)
---
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer using order_trans by blast
>   subgoal apply transfer using antisym ext by blast
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by auto
>   subgoal apply transfer by (simp add: sup_inf_distrib1)
>   done
2340c2297
<   have "Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f))) = { z . \<exists>qf\<in>stone_phi_set pf . z = get_dense qf f }"
---
>   have "Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f))) = { z . \<exists>qf\<in>stone_phi_base pf . z = get_dense qf f }"
2342c2299
<   hence "?r (fst (Rep_lifted_pair (Rep_regular pf) f)) = Abs_filter { z . \<exists>qf\<in>stone_phi_set pf . z = get_dense qf f }"
---
>   hence "?r (fst (Rep_lifted_pair (Rep_regular pf) f)) = Abs_filter { z . \<exists>qf\<in>stone_phi_base pf . z = get_dense qf f }"
2345c2302
<     using 13 by (simp add: Abs_filter_inverse stone_phi_set_filter stone_phi_def Abs_lifted_boolean_algebra_inverse)
---
>     using 13 by (simp add: Abs_filter_inverse stone_phi_base_filter stone_phi_def Abs_lifted_boolean_algebra_inverse)
==========
Stone_Kleene_Relation_Algebras
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Kleene_Relation_Algebras/Kleene_Algebras.thy ../../AFPs/afp-2020/thys/Stone_Kleene_Relation_Algebras/Kleene_Algebras.thy
585c585,598
<   by (simp add: assms cancel_separate_1 cancel_separate_eq local.sup_commute)
---
>   by (simp add: assms cancel_separate_1 cancel_separate_eq sup_commute)
> 
> lemma star_separate_3:
>   assumes "y * x\<^sup>\<star> * y \<le> y"
>     shows "(x \<squnion> y)\<^sup>\<star> = x\<^sup>\<star> \<squnion> x\<^sup>\<star> * y * x\<^sup>\<star>"
> proof (rule antisym)
>   have "x\<^sup>\<star> * y * (x\<^sup>\<star> * y)\<^sup>\<star> * x\<^sup>\<star> \<le> x\<^sup>\<star> * y * x\<^sup>\<star>"
>     by (metis assms mult_left_isotone mult_right_isotone star_right_induct_mult mult_assoc)
>   thus "(x \<squnion> y)\<^sup>\<star> \<le> x\<^sup>\<star> \<squnion> x\<^sup>\<star> * y * x\<^sup>\<star>"
>     by (metis antisym semiring.add_left_mono star.circ_sup_2 star.circ_sup_sub star.circ_unfold_sum star_decompose_3 star_slide mult_assoc)
> next
>   show "x\<^sup>\<star> \<squnion> x\<^sup>\<star> * y * x\<^sup>\<star> \<le> (x \<squnion> y)\<^sup>\<star>"
>     using mult_isotone star.circ_increasing star.circ_sub_dist star.circ_sup_9 by auto
> qed
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Kleene_Relation_Algebras/Kleene_Relation_Algebras.thy ../../AFPs/afp-2020/thys/Stone_Kleene_Relation_Algebras/Kleene_Relation_Algebras.thy
86a87,91
> lemma reflexive_inf_star:
>   assumes "reflexive y"
>     shows "y \<sqinter> x\<^sup>\<star> = 1 \<squnion> (y \<sqinter> x\<^sup>+)"
>   by (simp add: assms star_left_unfold_equal sup.absorb2 sup_inf_distrib1)
> 
391c396
<   by (simp add: local.dual_order.trans local.pseudo_complement local.schroeder_5_p local.star.circ_increasing)
---
>   by (simp add: dual_order.trans pseudo_complement schroeder_5_p star.circ_increasing)
895c900
<     by (simp add: assms(1) local.p_antitone local.p_antitone_iff local.point_injective)
---
>     by (simp add: assms(1) p_antitone p_antitone_iff point_injective)
1081c1086
<       using mult_left_isotone top.extremum local.inf_mono by presburger
---
>       using mult_left_isotone top.extremum inf_mono by presburger
1344c1349
<     using local.le_supI1 by blast
---
>     using le_supI1 by blast
1350a1356,1400
> lemma forests_bot_1:
>   assumes "equivalence e"
>       and "forest f"
>     shows "(-e \<sqinter> f) * (e \<sqinter> f)\<^sup>T = bot"
> proof -
>   have "f * f\<^sup>T \<le> e"
>     using assms dual_order.trans by blast
>   hence "f * (e \<sqinter> f)\<^sup>T \<le> e"
>     by (metis conv_dist_inf inf.boundedE inf.cobounded2 inf.orderE mult_right_isotone)
>   hence "-e \<sqinter> f * (e \<sqinter> f)\<^sup>T = bot"
>     by (simp add: p_antitone pseudo_complement)
>   thus ?thesis
>     by (metis assms(1) comp_isotone conv_dist_inf equivalence_comp_right_complement inf.boundedI inf.cobounded1 inf.cobounded2 le_bot)
> qed
> 
> lemma forests_bot_2:
>   assumes "equivalence e"
>       and "forest f"
>     shows "(-e \<sqinter> f\<^sup>T) * x \<sqinter> (e \<sqinter> f\<^sup>T) * y = bot"
> proof -
>   have "(-e \<sqinter> f) * (e \<sqinter> f\<^sup>T) = bot"
>     using assms forests_bot_1 conv_dist_inf by simp
>   thus ?thesis
>     by (smt assms(1) comp_associative comp_inf.semiring.mult_not_zero conv_complement conv_dist_comp conv_dist_inf conv_involutive dedekind_1 inf.cobounded2 inf.sup_monoid.add_commute le_bot mult_right_zero p_antitone_iff pseudo_complement semiring.mult_not_zero symmetric_top_closed top.extremum)
> qed
> 
> lemma forests_bot_3:
>   assumes "equivalence e"
>       and "forest f"
>     shows "x * (-e \<sqinter> f) \<sqinter> y * (e \<sqinter> f) = bot"
> proof -
>   have "(e \<sqinter> f) * (-e \<sqinter> f\<^sup>T) = bot"
>     using assms forests_bot_1 conv_dist_inf conv_complement by (smt conv_dist_comp conv_involutive conv_order coreflexive_bot_closed coreflexive_symmetric)
>   hence "y * (e \<sqinter> f) * (-e \<sqinter> f\<^sup>T) = bot"
>     by (simp add: comp_associative)
>   hence 1: "x \<sqinter> y * (e \<sqinter> f) * (-e \<sqinter> f\<^sup>T) = bot"
>     using comp_inf.semiring.mult_not_zero by blast
>   hence "(x \<sqinter> y * (e \<sqinter> f) * (-e \<sqinter> f\<^sup>T)) * (-e \<sqinter> f) = bot"
>     using semiring.mult_not_zero by blast
>   hence "x * (-e \<sqinter> f\<^sup>T)\<^sup>T \<sqinter> y * (e \<sqinter> f) = bot"
>     using 1 dedekind_2 inf_commute schroeder_2 by auto
>   thus ?thesis
>     by (simp add: assms(1) conv_complement conv_dist_inf)
> qed
> 
1370a1421,1424
> lemma fc_comp_eq_fc:
>   "-forest_components (--f) = -forest_components f"
>   by (metis conv_complement p_comp_pp p_pp_comp pp_dist_star)
> 
2138c2192
<     using assms(2) local.dual_order.trans local.pp_increasing local.schroeder_4_p by blast
---
>     using assms(2) dual_order.trans pp_increasing schroeder_4_p by blast
3058c3112
<       and "symmetric h"
---
>       and "symmetric g"
3070c3124
<     using assms(2,3) inf.sup_right_isotone pp_isotone by simp
---
>     by (metis assms(2,3) inf.sup_right_isotone pp_isotone conv_isotone)
==========
Stone_Relation_Algebras
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stone_Relation_Algebras/Relation_Algebras.thy ../../AFPs/afp-2020/thys/Stone_Relation_Algebras/Relation_Algebras.thy
839a840,858
> lemma arc_eq_1:
>   assumes "arc x"
>     shows "x = x * x\<^sup>T * x"
> proof -
>   have "x * x\<^sup>T * x \<le> x * top * x"
>     by (simp add: mult_left_isotone mult_right_isotone)
>   also have "... \<le> x"
>     by (simp add: assms arc_top_arc)
>   finally have "x * x\<^sup>T * x \<le> x"
>     by simp
>   thus ?thesis
>     by (simp add: antisym ex231c)
> qed
> 
> lemma arc_eq_2:
>   assumes "arc x"
>     shows "x\<^sup>T = x\<^sup>T * x * x\<^sup>T"
>   using arc_eq_1 assms conv_involutive by fastforce
> 
1087c1106
< abbreviation coreflexive_complement :: "'a \<Rightarrow> 'a" ("_ '" [80] 80)
---
> abbreviation coreflexive_complement :: "'a \<Rightarrow> 'a" ("_ ''" [80] 80)
1783a1803,1872
> qed
> 
> lemma point_in_vector_or_pseudo_complement:
>   assumes "point p"
>       and "vector v"
>     shows "p \<le> --v \<or> p \<le> -v"
> proof (rule disjCI)
>   assume "\<not>(p \<le> -v)"
>   hence "top * (p \<sqinter> --v) = top"
>     by (smt assms bijective_regular regular_closed_inf regular_closed_p shunting_1_pp tarski vector_complement_closed vector_inf_closed vector_mult_closed)
>   thus "p \<le> --v"
>     by (metis assms(1) epm_3 inf.absorb_iff1 inf.cobounded1 inf_top.right_neutral)
> qed
> 
> lemma point_in_vector_or_complement:
>   assumes "point p"
>       and "vector v"
>       and "regular v"
>     shows "p \<le> v \<or> p \<le> -v"
>   using assms point_in_vector_or_pseudo_complement by fastforce
> 
> lemma point_in_vector_sup:
>   assumes "point p"
>       and "vector v"
>       and "regular v"
>       and "p \<le> v \<squnion> w"
>     shows "p \<le> v \<or> p \<le> w"
>   by (metis assms inf.absorb1 shunting_var_p sup_commute point_in_vector_or_complement)
> 
> lemma arc_in_arc_or_complement:
>   assumes "arc x"
>       and "arc y"
>       and "\<not> x \<le> y"
>     shows "x \<le> -y"
>   using assms arc_in_partition arc_regular by force
> 
> lemma arc_in_sup_arc:
>   assumes "arc x"
>       and "arc y"
>       and "x \<le> z \<squnion> y"
>     shows "x \<le> z \<or> x \<le> y"
> proof (cases "x \<le> y")
>   case True
>   thus ?thesis
>     by simp
> next
>   case False
>   hence "x \<le> -y"
>     using assms(1,2) arc_in_arc_or_complement by blast
>   hence "x \<le> -y \<sqinter> (z \<squnion> y)"
>     using assms(3) by simp
>   hence "x \<le> z"
>     by (metis inf.boundedE inf.sup_monoid.add_commute maddux_3_13 sup_commute)
>   thus ?thesis
>     by simp
> qed
> 
> lemma different_arc_in_sup_arc:
>   assumes "arc x"
>       and "arc y"
>       and "x \<le> z \<squnion> y"
>       and "x \<noteq> y"
>     shows "x \<le> z"
> proof -
>   have "x \<le> -y"
>     using arc_in_arc_or_complement assms(1,2,4) eq_iff p_antitone_iff by blast
>   hence "x \<le> -y \<sqinter> (z \<squnion> y)"
>     using assms arc_in_sup_arc by simp
>   thus ?thesis
>     by (metis order_lesseq_imp p_inf_sup_below sup_commute)
==========
Sturm_Sequences
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Sturm_Sequences/Lib/Misc_Polynomial.thy ../../AFPs/afp-2020/thys/Sturm_Sequences/Lib/Misc_Polynomial.thy
85c85
<   assumes "pderiv (p::('a::{field_char_0,euclidean_ring_gcd}) poly) \<noteq> 0"
---
>   assumes "pderiv (p::('a::{field_char_0,field_gcd}) poly) \<noteq> 0"
191c191
<   assumes "(p :: ('a::{field_char_0,euclidean_ring_gcd}) poly) \<noteq> 0"
---
>   assumes "(p :: ('a::{field_char_0,field_gcd}) poly) \<noteq> 0"
==========
Sturm_Tarski
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Sturm_Tarski/PolyMisc.thy ../../AFPs/afp-2020/thys/Sturm_Tarski/PolyMisc.thy
149c149
<   fixes p q::"'a::factorial_ring_gcd poly"
---
>   fixes p q::"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize} poly"
==========
Stuttering_Equivalence
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Stuttering_Equivalence/PLTL.thy ../../AFPs/afp-2020/thys/Stuttering_Equivalence/PLTL.thy
5c5
< section \<open>Stuttering Invariant PLTL Formulas\<close>
---
> section \<open>Stuttering Invariant LTL Formulas\<close>
8,10c8,9
<   We define the syntax and semantics of propositional linear-time
<   temporal logic PLTL and show that its next-free fragment is
<   invariant to finite stuttering.
---
>   We show that the next-free fragment of propositional linear-time
>   temporal logic PLTL is invariant to finite stuttering.
13,20c12
< notation False_ltlp ("false")
<   and Implies_ltlp ("implies")
<   and Atom_ltlp ("atom")
<   and Until_ltlp ("until")
<   and Next_ltlp ("next")
<   and atoms_pltl ("atoms")
< 
< subsection \<open>Finite Conjunctions and Disjunctions\<close>
---
> subsection \<open>Finite Conjunctions and Disjunctions in PLTL\<close>
197c189
<     show "stutter_invariant false" by auto
---
>     show "stutter_invariant false\<^sub>p" by auto
200c192
<   show "stutter_invariant (atom p)"
---
>   show "stutter_invariant (atom\<^sub>p(p))"
203,204c195,196
<     assume "\<sigma> \<approx> \<tau>" "\<sigma> \<Turnstile>\<^sub>p atom p"
<     thus "\<tau> \<Turnstile>\<^sub>p atom p" by (simp add: stutter_equiv_0)
---
>     assume "\<sigma> \<approx> \<tau>" "\<sigma> \<Turnstile>\<^sub>p atom\<^sub>p(p)"
>     thus "\<tau> \<Turnstile>\<^sub>p atom\<^sub>p(p)" by (simp add: stutter_equiv_0)
210,211c202,203
<   assume "next_free (implies \<phi> \<psi>)"
<   with ih show "stutter_invariant (implies \<phi> \<psi>)" by auto
---
>   assume "next_free (\<phi> implies\<^sub>p \<psi>)"
>   with ih show "stutter_invariant (\<phi> implies\<^sub>p \<psi>)" by auto
214,215c206,207
<   assume "next_free (next \<phi>)"  \<comment> \<open>hence contradiction\<close>
<   thus "stutter_invariant (next \<phi>)" by simp
---
>   assume "next_free (X\<^sub>p \<phi>)"  \<comment> \<open>hence contradiction\<close>
>   thus "stutter_invariant (X\<^sub>p \<phi>)" by simp
220c212
<   assume "next_free (until \<phi> \<psi>)"
---
>   assume "next_free (\<phi> U\<^sub>p \<psi>)"
222c214
<   show "stutter_invariant (until \<phi> \<psi>)"
---
>   show "stutter_invariant (\<phi> U\<^sub>p \<psi>)"
225c217
<     assume st: "\<sigma> \<approx> \<tau>" and unt: "\<sigma> \<Turnstile>\<^sub>p until \<phi> \<psi>"
---
>     assume st: "\<sigma> \<approx> \<tau>" and unt: "\<sigma> \<Turnstile>\<^sub>p \<phi> U\<^sub>p \<psi>"
227c219
<       where 1: "\<sigma>[m..] \<Turnstile>\<^sub>p \<psi>" and 2: "\<forall>j<m. \<sigma>[j..] \<Turnstile>\<^sub>p \<phi>" by auto
---
>       where 1: "\<sigma>[m..] \<Turnstile>\<^sub>p \<psi>" and 2: "\<forall>j<m. (\<sigma>[j..] \<Turnstile>\<^sub>p \<phi>)" by auto
229c221
<       where 3: "\<sigma>[m..] \<approx> \<tau>[n..]" and 4: "\<forall>i<n. \<exists>j<m. \<sigma>[j..] \<approx> \<tau>[i..]"
---
>       where 3: "(\<sigma>[m..]) \<approx> (\<tau>[n..])" and 4: "\<forall>i<n. \<exists>j<m. (\<sigma>[j..]) \<approx> (\<tau>[i..])"
233,234c225,226
<     from 2 4 stinv have "\<forall>i<n. \<tau>[i..] \<Turnstile>\<^sub>p \<phi>" by force
<     ultimately show "\<tau> \<Turnstile>\<^sub>p until \<phi> \<psi>" by auto
---
>     from 2 4 stinv have "\<forall>i<n. (\<tau>[i..] \<Turnstile>\<^sub>p \<phi>)" by force
>     ultimately show "\<tau> \<Turnstile>\<^sub>p \<phi> U\<^sub>p \<psi>" by auto
254c246
< lemma atoms_OR [simp]: 
---
> lemma atoms_pltl_OR [simp]:
256c248
<   shows "atoms (OR \<Phi>) = (\<Union>\<phi>\<in>\<Phi>. atoms \<phi>)"
---
>   shows "atoms_pltl (OR \<Phi>) = (\<Union>\<phi>\<in>\<Phi>. atoms_pltl \<phi>)"
261c253
<     hence "atoms \<psi> = (\<Union>\<phi>\<in>\<Phi>. atoms \<phi>)"
---
>     hence "atoms_pltl \<psi> = (\<Union>\<phi>\<in>\<Phi>. atoms_pltl \<phi>)"
267c259
< lemma atoms_AND [simp]: 
---
> lemma atoms_pltl_AND [simp]:
269c261
<   shows "atoms (AND \<Phi>) = (\<Union>\<phi>\<in>\<Phi>. atoms \<phi>)"
---
>   shows "atoms_pltl (AND \<Phi>) = (\<Union>\<phi>\<in>\<Phi>. atoms_pltl \<phi>)"
274c266
<     hence "atoms \<psi> = (\<Union>\<phi>\<in>\<Phi>. atoms \<phi>)"
---
>     hence "atoms_pltl \<psi> = (\<Union>\<phi>\<in>\<Phi>. atoms_pltl \<phi>)"
334c326
< lemma pltl_seq_sim: "\<sigma> \<simeq>(atoms \<phi>)\<simeq> \<tau> \<Longrightarrow> (\<sigma> \<Turnstile>\<^sub>p \<phi>) = (\<tau> \<Turnstile>\<^sub>p \<phi>)"
---
> lemma pltl_seq_sim: "\<sigma> \<simeq> atoms_pltl \<phi> \<simeq> \<tau> \<Longrightarrow> (\<sigma> \<Turnstile>\<^sub>p \<phi>) = (\<tau> \<Turnstile>\<^sub>p \<phi>)"
338c330
<   show "?P \<sigma> false \<tau>" by simp
---
>   show "?P \<sigma> false\<^sub>p \<tau>" by simp
341c333
<   assume "?sim \<sigma> (atom p) \<tau>" thus "?P \<sigma> (atom p) \<tau>"
---
>   assume "?sim \<sigma> (atom\<^sub>p(p)) \<tau>" thus "?P \<sigma> (atom\<^sub>p(p)) \<tau>"
347c339
<      and sim: "?sim \<sigma> (implies \<phi> \<psi>) \<tau>"
---
>      and sim: "?sim \<sigma> (\<phi> implies\<^sub>p \<psi>) \<tau>"
350c342
<   with ih show "?P \<sigma> (implies \<phi> \<psi>) \<tau>" by simp
---
>   with ih show "?P \<sigma> (\<phi> implies\<^sub>p \<psi>) \<tau>" by simp
354,355c346,347
<      and sim: "\<sigma> \<simeq>atoms (next \<phi>)\<simeq> \<tau>"
<   from sim have "\<sigma>[1..] \<simeq>atoms \<phi>\<simeq> \<tau>[1..]"
---
>      and sim: "\<sigma> \<simeq> atoms_pltl (X\<^sub>p \<phi>) \<simeq> \<tau>"
>   from sim have "(\<sigma>[1..]) \<simeq> atoms_pltl \<phi> \<simeq> (\<tau>[1..])"
357c349
<   with ih show "?P \<sigma> (next \<phi>) \<tau>" by auto
---
>   with ih show "?P \<sigma> (X\<^sub>p \<phi>) \<tau>" by auto
362,363c354,355
<      and sim: "?sim \<sigma> (until \<phi> \<psi>) \<tau>"
<   from sim have "\<forall>i. \<sigma>[i..] \<simeq>atoms \<phi>\<simeq> \<tau>[i..]" "\<forall>j. \<sigma>[j..] \<simeq> atoms \<psi> \<simeq> \<tau>[j..]"
---
>      and sim: "?sim \<sigma> (\<phi> U\<^sub>p \<psi>) \<tau>"
>   from sim have "\<forall>i. (\<sigma>[i..]) \<simeq> atoms_pltl \<phi> \<simeq> (\<tau>[i..])" "\<forall>j. (\<sigma>[j..]) \<simeq> atoms_pltl \<psi> \<simeq> (\<tau>[j..])"
367c359
<   thus "?P \<sigma> (until \<phi> \<psi>) \<tau>" 
---
>   thus "?P \<sigma> (\<phi> U\<^sub>p \<psi>) \<tau>"
449c441
<    ((AND { atom p | p . p \<in> A \<and> p s }) and\<^sub>p (AND { not\<^sub>p (atom p) | p . p \<in> A \<and> \<not>(p s) }))"
---
>    ((AND { atom\<^sub>p(p) | p . p \<in> A \<and> p s }) and\<^sub>p (AND { not\<^sub>p (atom\<^sub>p(p)) | p . p \<in> A \<and> \<not>(p s) }))"
481c473
<   canonical sequences (w.r.t. some \<open>A \<supseteq> atoms \<phi>\<close>).
---
>   canonical sequences (w.r.t. some \<open>A \<supseteq> atoms_pltl \<phi>\<close>).
485,486c477,478
<   assumes A: "atoms \<phi> \<subseteq> A" and fin: "finite A"
<   shows "\<exists>\<psi>. next_free \<psi> \<and> atoms \<psi> \<subseteq> A \<and>
---
>   assumes A: "atoms_pltl \<phi> \<subseteq> A" and fin: "finite A"
>   shows "\<exists>\<psi>. next_free \<psi> \<and> atoms_pltl \<psi> \<subseteq> A \<and>
491,492c483,484
<   have "?P false false" by auto
<   thus "\<exists>\<psi>. ?P false \<psi>" ..
---
>   have "?P false\<^sub>p false\<^sub>p" by auto
>   thus "\<exists>\<psi>. ?P false\<^sub>p \<psi>" ..
495,497c487,489
<   assume "atoms (atom p) \<subseteq> A"
<   hence "?P (atom p) (atom p)" by auto
<   thus "\<exists>\<psi>. ?P (atom p) \<psi>" ..
---
>   assume "atoms_pltl (atom\<^sub>p(p)) \<subseteq> A"
>   hence "?P (atom\<^sub>p(p)) (atom\<^sub>p(p))" by auto
>   thus "\<exists>\<psi>. ?P (atom\<^sub>p(p)) \<psi>" ..
501,503c493,495
<   assume "atoms \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<phi>'. ?P \<phi> \<phi>'"
<      and "atoms \<psi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>'. ?P \<psi> \<psi>'"
<      and "atoms (implies \<phi> \<psi>) \<subseteq> A"
---
>   assume "atoms_pltl \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<phi>'. ?P \<phi> \<phi>'"
>      and "atoms_pltl \<psi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>'. ?P \<psi> \<psi>'"
>      and "atoms_pltl (\<phi> implies\<^sub>p \<psi>) \<subseteq> A"
505,506c497,498
<   hence "?P (implies \<phi> \<psi>) (implies \<phi>' \<psi>')" by auto
<   thus "\<exists>\<chi>. ?P (implies \<phi> \<psi>) \<chi>" ..
---
>   hence "?P (\<phi> implies\<^sub>p \<psi>) (\<phi>' implies\<^sub>p \<psi>')" by auto
>   thus "\<exists>\<chi>. ?P (\<phi> implies\<^sub>p \<psi>) \<chi>" ..
510,512c502,504
<   assume "atoms \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<phi>'. ?P \<phi> \<phi>'"
<      and "atoms \<psi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>'. ?P \<psi> \<psi>'"
<      and "atoms (until \<phi> \<psi>) \<subseteq> A"
---
>   assume "atoms_pltl \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<phi>'. ?P \<phi> \<phi>'"
>      and "atoms_pltl \<psi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>'. ?P \<psi> \<psi>'"
>      and "atoms_pltl (\<phi> U\<^sub>p \<psi>) \<subseteq> A"
523c515
<     hence "(\<sigma> \<Turnstile>\<^sub>p until \<phi>' \<psi>') = (\<sigma> \<Turnstile>\<^sub>p until \<phi> \<psi>)"
---
>     hence "(\<sigma> \<Turnstile>\<^sub>p \<phi>' U\<^sub>p \<psi>') = (\<sigma> \<Turnstile>\<^sub>p \<phi> U\<^sub>p \<psi>)"
526,527c518,519
<   with 1 2 have "?P (until \<phi> \<psi>) (until \<phi>' \<psi>')" by auto
<   thus "\<exists>\<chi>. ?P (until \<phi> \<psi>) \<chi>" ..
---
>   with 1 2 have "?P (\<phi> U\<^sub>p \<psi>) (\<phi>' U\<^sub>p \<psi>')" by auto
>   thus "\<exists>\<chi>. ?P (\<phi> U\<^sub>p \<psi>) \<chi>" ..
531c523
<   assume ih: "atoms \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>. ?P \<phi> \<psi>" and at: "atoms (next \<phi>) \<subseteq> A"
---
>   assume ih: "atoms_pltl \<phi> \<subseteq> A \<Longrightarrow> \<exists>\<psi>. ?P \<phi> \<psi>" and at: "atoms_pltl (X\<^sub>p \<phi>) \<subseteq> A"
536c528
<     \<open>psi'\<close> that we will prove to be equivalent to \<open>next \<phi>\<close> over
---
>     \<open>psi'\<close> that we will prove to be equivalent to \<open>X\<^sub>p \<phi>\<close> over
539,542c531,534
<   define chi where "chi = (\<lambda>val. ((AND {atom p | p . p \<in> val}) and\<^sub>p
<                         (AND {not\<^sub>p (atom p) | p . p \<in> A - val})))"
<   define psi' where "psi' = (Or_ltlp (\<psi> and\<^sub>p (OR {G\<^sub>p (chi val) | val . val \<subseteq> A }))
<                   (OR {(chi val) and\<^sub>p (until (chi val) ( \<psi> and\<^sub>p (chi val'))) | val val'.
---
>   define chi where "chi = (\<lambda>val. ((AND {atom\<^sub>p(p) | p . p \<in> val}) and\<^sub>p
>                         (AND {not\<^sub>p (atom\<^sub>p(p)) | p . p \<in> A - val})))"
>   define psi' where "psi' = ((\<psi> and\<^sub>p (OR {G\<^sub>p (chi val) | val . val \<subseteq> A })) or\<^sub>p
>                   (OR {(chi val) and\<^sub>p ((chi val) U\<^sub>p ( \<psi> and\<^sub>p (chi val'))) | val val'.
544c536
<         (is "_ = (Or_ltlp ( _ and\<^sub>p (OR ?ALW)) (OR ?UNT))")
---
>         (is "_ = (( _ and\<^sub>p (OR ?ALW)) or\<^sub>p (OR ?UNT))")
546,547c538,539
<   have "\<And>s. {not\<^sub>p (atom p) | p . p \<in> A - stval s}
<            = {not\<^sub>p (atom p) | p . p \<in> A \<and> \<not>(p s)}"
---
>   have "\<And>s. {not\<^sub>p (atom\<^sub>p(p)) | p . p \<in> A - stval s}
>            = {not\<^sub>p (atom\<^sub>p(p)) | p . p \<in> A \<and> \<not>(p s)}"
559c551
<   have "?UNT \<subseteq> (\<lambda>(val,val'). (chi val) and\<^sub>p (until (chi val) (\<psi> and\<^sub>p (chi val'))))
---
>   have "?UNT \<subseteq> (\<lambda>(val,val'). (chi val) and\<^sub>p ((chi val) U\<^sub>p (\<psi> and\<^sub>p (chi val'))))
574c566
<   have atoms: "atoms psi' \<subseteq> A"
---
>   have atoms_pltl: "atoms_pltl psi' \<subseteq> A"
576c568
<     from fin have at_chi: "\<And>val. val \<subseteq> A \<Longrightarrow> atoms (chi val) \<subseteq> A"
---
>     from fin have at_chi: "\<And>val. val \<subseteq> A \<Longrightarrow> atoms_pltl (chi val) \<subseteq> A"
578c570
<     with fin psi have at_alw: "atoms (\<psi> and\<^sub>p (OR ?ALW)) \<subseteq> A"
---
>     with fin psi have at_alw: "atoms_pltl (\<psi> and\<^sub>p (OR ?ALW)) \<subseteq> A"
580c572
<     from fin fin_UNT psi at_chi have "atoms (OR ?UNT) \<subseteq> A"
---
>     from fin fin_UNT psi at_chi have "atoms_pltl (OR ?UNT) \<subseteq> A"
588c580
<     have "(\<sigma> \<Turnstile>\<^sub>p next \<phi>) = (\<sigma> \<Turnstile>\<^sub>p psi')"
---
>     have "(\<sigma> \<Turnstile>\<^sub>p X\<^sub>p \<phi>) = (\<sigma> \<Turnstile>\<^sub>p psi')"
613c605
<       with st can psi have 1: "(\<sigma> \<Turnstile>\<^sub>p next \<phi>) = (\<sigma> \<Turnstile>\<^sub>p \<psi>)" by simp
---
>       with st can psi have 1: "(\<sigma> \<Turnstile>\<^sub>p X\<^sub>p \<phi>) = (\<sigma> \<Turnstile>\<^sub>p \<psi>)" by simp
639c631
<       txt \<open>Otherwise, \<open>\<sigma> \<Turnstile>\<^sub>p next \<phi>\<close> is equivalent to \<open>\<sigma>\<close> satisfying
---
>       txt \<open>Otherwise, \<open>\<sigma> \<Turnstile>\<^sub>p X\<^sub>p \<phi>\<close> is equivalent to \<open>\<sigma>\<close> satisfying
648c640
<         assume phi: "\<sigma> \<Turnstile>\<^sub>p next \<phi>"
---
>         assume phi: "\<sigma> \<Turnstile>\<^sub>p X\<^sub>p \<phi>"
659c651
<         from 1 2 3 have "\<sigma> \<Turnstile>\<^sub>p And_ltlp (chi ?val) (until (chi ?val) (And_ltlp \<psi> (chi ?val')))"
---
>         from 1 2 3 have "\<sigma> \<Turnstile>\<^sub>p And_ltlp (chi ?val) ((chi ?val) U\<^sub>p (And_ltlp \<psi> (chi ?val')))"
673c665
<           with fin obtain val where 1: "val \<subseteq> A" and 2: "\<forall>n. \<sigma>[n..] \<Turnstile>\<^sub>p chi val"
---
>           with fin obtain val where 1: "val \<subseteq> A" and 2: "\<forall>n. (\<sigma>[n..] \<Turnstile>\<^sub>p chi val)"
688c680
<           i: "\<forall>i<k. \<sigma>[i..] \<Turnstile>\<^sub>p chi val"
---
>           i: "\<forall>i<k. (\<sigma>[i..] \<Turnstile>\<^sub>p chi val)"
717c709
<         ultimately show "\<sigma> \<Turnstile>\<^sub>p next \<phi>" using \<open>\<sigma>[k..] \<Turnstile>\<^sub>p \<psi>\<close> psi by auto
---
>         ultimately show "\<sigma> \<Turnstile>\<^sub>p X\<^sub>p \<phi>" using \<open>\<sigma>[k..] \<Turnstile>\<^sub>p \<psi>\<close> psi by auto
721c713
<   with nf atoms show "\<exists>\<psi>'. ?P (next \<phi>) \<psi>'" by blast
---
>   with nf atoms_pltl show "\<exists>\<psi>'. ?P (X\<^sub>p \<phi>) \<psi>'" by blast
726c718
<   formulas \<open>next \<phi>\<close> with the one that appears in~\cite{peled:ltl-x},
---
>   formulas \<open>X\<^sub>p \<phi>\<close> with the one that appears in~\cite{peled:ltl-x},
731c723
<     \<open>until (chi val) (and \<psi> (chi val'))\<close>
---
>     \<open>(chi val) U\<^sub>p (\<psi> and\<^sub>p (chi val'))\<close>
747c739
<   can be expressed without the \<open>next\<close> operator.
---
>   can be expressed without the \<open>X\<^sub>p\<close> operator.
752c744
<   obtains \<psi> where "next_free \<psi>" "atoms \<psi> \<subseteq> atoms \<phi>"
---
>   obtains \<psi> where "next_free \<psi>" "atoms_pltl \<psi> \<subseteq> atoms_pltl \<phi>"
755c747
<   have "atoms \<phi> \<subseteq> atoms \<phi>" "finite (atoms \<phi>)" by simp_all
---
>   have "atoms_pltl \<phi> \<subseteq> atoms_pltl \<phi>" "finite (atoms_pltl \<phi>)" by simp_all
757,758c749,750
<     psi: "next_free \<psi>" "atoms \<psi> \<subseteq> atoms \<phi>" and
<     equiv: "\<forall>\<sigma>. stutter_free \<sigma> \<and> canonical_sequence (atoms \<phi>) \<sigma> \<longrightarrow> (\<sigma> \<Turnstile>\<^sub>p \<psi>) = (\<sigma> \<Turnstile>\<^sub>p \<phi>)"
---
>     psi: "next_free \<psi>" "atoms_pltl \<psi> \<subseteq> atoms_pltl \<phi>" and
>     equiv: "\<forall>\<sigma>. stutter_free \<sigma> \<and> canonical_sequence (atoms_pltl \<phi>) \<sigma> \<longrightarrow> (\<sigma> \<Turnstile>\<^sub>p \<psi>) = (\<sigma> \<Turnstile>\<^sub>p \<phi>)"
764c756
<     obtain \<tau> where 1: "\<tau> \<simeq> atoms \<phi> \<simeq> \<sigma>" and 2: "canonical_sequence (atoms \<phi>) \<tau>"
---
>     obtain \<tau> where 1: "\<tau> \<simeq> atoms_pltl \<phi> \<simeq> \<sigma>" and 2: "canonical_sequence (atoms_pltl \<phi>) \<tau>"
766c758
<     from 1 \<open>atoms \<psi> \<subseteq> atoms \<phi>\<close> have 3: "\<tau> \<simeq> atoms \<psi> \<simeq> \<sigma>"
---
>     from 1 \<open>atoms_pltl \<psi> \<subseteq> atoms_pltl \<phi>\<close> have 3: "\<tau> \<simeq> atoms_pltl \<psi> \<simeq> \<sigma>"
789c781
<    (\<exists>\<psi>. next_free \<psi> \<and> atoms \<psi> \<subseteq> atoms \<phi> \<and> (\<forall>\<sigma>. \<sigma> \<Turnstile>\<^sub>p \<psi> \<longleftrightarrow> \<sigma> \<Turnstile>\<^sub>p \<phi>))"
---
>    (\<exists>\<psi>. next_free \<psi> \<and> atoms_pltl \<psi> \<subseteq> atoms_pltl \<phi> \<and> (\<forall>\<sigma>. \<sigma> \<Turnstile>\<^sub>p \<psi> \<longleftrightarrow> \<sigma> \<Turnstile>\<^sub>p \<phi>))"
793c785
<     hence "\<exists>\<psi>. next_free \<psi> \<and> atoms \<psi> \<subseteq> atoms \<phi> \<and> (\<forall>\<sigma>. \<sigma> \<Turnstile>\<^sub>p \<psi> \<longleftrightarrow> \<sigma> \<Turnstile>\<^sub>p \<phi>)"
---
>     hence "\<exists>\<psi>. next_free \<psi> \<and> atoms_pltl \<psi> \<subseteq> atoms_pltl \<phi> \<and> (\<forall>\<sigma>. \<sigma> \<Turnstile>\<^sub>p \<psi> \<longleftrightarrow> \<sigma> \<Turnstile>\<^sub>p \<phi>)"
803a796,841
> qed
> 
> 
> subsection \<open>Stutter Invariance for LTL with Syntactic Sugar\<close>
> 
> text \<open>We lift the results for PLTL to an extensive version of LTL.\<close>
> 
> primrec ltlc_next_free :: "'a ltlc \<Rightarrow> bool"
>   where
>     "ltlc_next_free true\<^sub>c = True"
>   | "ltlc_next_free false\<^sub>c = True"
>   | "ltlc_next_free (prop\<^sub>c(q)) = True"
>   | "ltlc_next_free (not\<^sub>c \<phi>) = ltlc_next_free \<phi>"
>   | "ltlc_next_free (\<phi> and\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (\<phi> or\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (\<phi> implies\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (X\<^sub>c \<phi>) = False"
>   | "ltlc_next_free (F\<^sub>c \<phi>) = ltlc_next_free \<phi>"
>   | "ltlc_next_free (G\<^sub>c \<phi>) = ltlc_next_free \<phi>"
>   | "ltlc_next_free (\<phi> U\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (\<phi> R\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (\<phi> W\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
>   | "ltlc_next_free (\<phi> M\<^sub>c \<psi>) = (ltlc_next_free \<phi> \<and> ltlc_next_free \<psi>)"
> 
> lemma ltlc_next_free_iff[simp]: "next_free (ltlc_to_pltl \<phi>) \<longleftrightarrow> ltlc_next_free \<phi>"
>   by (induction \<phi>) auto
> 
> text \<open>A next free formula cannot distinguish between stutter-equivalent runs.\<close>
> 
> theorem ltlc_next_free_stutter_invariant:
>   assumes next_free: "ltlc_next_free \<phi>"
>   assumes eq: "r \<approx> r'"
>   shows "r \<Turnstile>\<^sub>c \<phi> \<longleftrightarrow> r' \<Turnstile>\<^sub>c \<phi>"
> proof -
>   {
>     fix r r'
>     assume eq: "r \<approx> r'" and holds: "r \<Turnstile>\<^sub>c \<phi>"
>     then have "r \<Turnstile>\<^sub>p (ltlc_to_pltl \<phi>)"by simp
> 
>     from next_free_stutter_invariant[of "ltlc_to_pltl \<phi>"] next_free
>     have "PLTL.stutter_invariant (ltlc_to_pltl \<phi>)" by simp
>     from stutter_invariantD[OF this eq] holds have "r' \<Turnstile>\<^sub>c \<phi>" by simp
>   } note aux=this
> 
>   from aux[of r r'] aux[of r' r] eq stutter_equiv_sym[OF eq] show ?thesis
>     by blast
==========
Subresultants
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Subresultants/Subresultant_Gcd.thy ../../AFPs/afp-2020/thys/Subresultants/Subresultant_Gcd.thy
29c29
<        F :: "nat \<Rightarrow> 'a :: factorial_ring_gcd fract poly"
---
>        F :: "nat \<Rightarrow> 'a ::  {factorial_ring_gcd,semiring_gcd_mult_normalize} fract poly"
==========
Surprise_Paradox
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Surprise_Paradox/Surprise_Paradox.thy ../../AFPs/afp-2020/thys/Surprise_Paradox/Surprise_Paradox.thy
89c89
<  | "quot_hfm (HFm A) = \<lceil>A\<rceil>"
---
>  | "quot_hfm (HFm A) = \<guillemotleft>A\<guillemotright>"
96c96
< lemma subst_quot_hfm[simp]: "subst i \<lceil>P\<rceil> \<lceil>A\<rceil> = \<lceil>A(i:::=P)\<rceil>"
---
> lemma subst_quot_hfm[simp]: "subst i \<guillemotleft>P\<guillemotright> \<guillemotleft>A\<guillemotright> = \<guillemotleft>A(i:::=P)\<guillemotright>"
121c121
< lemma quot_closed_hfm[simp]: "closed_hfm A \<Longrightarrow> \<lceil>A\<rceil> = \<lceil>hfm_to_fm A\<rceil>"
---
> lemma quot_closed_hfm[simp]: "closed_hfm A \<Longrightarrow> \<guillemotleft>A\<guillemotright> = \<guillemotleft>hfm_to_fm A\<guillemotright>"
145,146c145,146
<     "H = Q\<^sub>1 AND Neg (PfP \<lceil>HVar X0 HIMP HFm Q\<^sub>1\<rceil>) XOR 
<      Q\<^sub>2 AND Neg (PfP \<lceil>HVar X0 HAND HNeg (HFm Q\<^sub>1) HIMP (HFm Q\<^sub>2)\<rceil>)"
---
>     "H = Q\<^sub>1 AND Neg (PfP \<guillemotleft>HVar X0 HIMP HFm Q\<^sub>1\<guillemotright>) XOR 
>      Q\<^sub>2 AND Neg (PfP \<guillemotleft>HVar X0 HAND HNeg (HFm Q\<^sub>1) HIMP (HFm Q\<^sub>2)\<guillemotright>)"
148c148
<   definition P where "P = (SOME P. {} \<turnstile> P IFF H(X0 ::= \<lceil>P\<rceil>))"
---
>   definition P where "P = (SOME P. {} \<turnstile> P IFF H(X0 ::= \<guillemotleft>P\<guillemotright>))"
150c150
<   lemma P': "{} \<turnstile> P IFF H(X0 ::= \<lceil>P\<rceil>)"
---
>   lemma P': "{} \<turnstile> P IFF H(X0 ::= \<guillemotleft>P\<guillemotright>)"
153c153
<     obtain \<delta> where "{} \<turnstile> \<delta> IFF H(X0 ::= \<lceil>\<delta>\<rceil>)".
---
>     obtain \<delta> where "{} \<turnstile> \<delta> IFF H(X0 ::= \<guillemotleft>\<delta>\<guillemotright>)".
163,164c163,164
<      (Q\<^sub>1 AND Neg (PfP \<lceil>P IMP Q\<^sub>1\<rceil>) XOR
<       Q\<^sub>2 AND Neg (PfP \<lceil>P AND Neg Q\<^sub>1 IMP Q\<^sub>2\<rceil>))"
---
>      (Q\<^sub>1 AND Neg (PfP \<guillemotleft>P IMP Q\<^sub>1\<guillemotright>) XOR
>       Q\<^sub>2 AND Neg (PfP \<guillemotleft>P AND Neg Q\<^sub>1 IMP Q\<^sub>2\<guillemotright>))"
176c176
<   lemma 10: "{} \<turnstile> PfP \<lceil>(P AND Neg Q\<^sub>1) IMP Q\<^sub>2\<rceil>"
---
>   lemma 10: "{} \<turnstile> PfP \<guillemotleft>(P AND Neg Q\<^sub>1) IMP Q\<^sub>2\<guillemotright>"
183c183
<   lemma 12: "{} \<turnstile> PfP \<lceil>P IMP Q\<^sub>1\<rceil>"
---
>   lemma 12: "{} \<turnstile> PfP \<guillemotleft>P IMP Q\<^sub>1\<guillemotright>"
206c206
<    subst i \<lceil>t\<rceil> (vquot_dbtm {i} (trans_tm is t')) =
---
>    subst i \<guillemotleft>t\<guillemotright> (vquot_dbtm {i} (trans_tm is t')) =
215c215
<    subst i \<lceil>t\<rceil> (vquot_dbfm {i} (trans_fm is A)) =
---
>    subst i \<guillemotleft>t\<guillemotright> (vquot_dbfm {i} (trans_fm is A)) =
221c221
<   "subst i \<lceil>t\<rceil> \<lfloor>A\<rfloor>{i} = \<lceil>A(i ::= t)\<rceil>"
---
>   "subst i \<guillemotleft>t\<guillemotright> \<lfloor>A\<rfloor>{i} = \<guillemotleft>A(i ::= t)\<guillemotright>"
==========
Tarskis_Geometry
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Tarskis_Geometry/Metric.thy ../../AFPs/afp-2020/thys/Tarskis_Geometry/Metric.thy
9c9
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Multivariate_Analysis"
==========
Taylor_Models
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Taylor_Models/Experiments.thy ../../AFPs/afp-2020/thys/Taylor_Models/Experiments.thy
7a8
> context includes interval.lifting begin
21a23
> end
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Taylor_Models/Float_Topology.thy ../../AFPs/afp-2020/thys/Taylor_Models/Float_Topology.thy
4c4
<     "HOL-Analysis.Analysis"
---
>     "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Taylor_Models/Horner_Eval.thy ../../AFPs/afp-2020/thys/Taylor_Models/Horner_Eval.thy
3c3
<   imports Interval
---
>   imports "HOL-Library.Interval"
Only in ../../AFPs/afp-2019/thys/Taylor_Models: Interval_Approximation.thy
Only in ../../AFPs/afp-2019/thys/Taylor_Models: Interval.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Taylor_Models/Polynomial_Expression_Additional.thy ../../AFPs/afp-2020/thys/Taylor_Models/Polynomial_Expression_Additional.thy
2c2
<   imports Interval_Approximation
---
>   imports
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Taylor_Models/Taylor_Models.thy ../../AFPs/afp-2020/thys/Taylor_Models/Taylor_Models.thy
2c2
<   imports "Interval_Approximation"
---
>   imports
23,26c23
<   where "compute_bound_fa prec f I =
<   (case approx prec f (map (Some o (\<lambda>x. (lower x, upper x))) I) of
<     Some (a, b) \<Rightarrow> (if a \<le> b then Some (Ivl a b) else None)
<   | _ \<Rightarrow> None)"
---
>   where "compute_bound_fa prec f I = approx prec f (map Some I)"
34c31
<   have bounded: "bounded_by i (map (Some \<circ> (\<lambda>x. (lower x, upper x))) I)"
---
>   have bounded: "bounded_by i (map Some I)"
38c35
<   from that have Some: "approx prec f (map (Some \<circ> (\<lambda>x. (lower x, upper x))) I) = Some (lower ivl, upper ivl)"
---
>   from that have Some: "approx prec f (map Some I) = Some ivl"
40c37
<   from approx[OF bounded Some[symmetric]]
---
>   from approx[OF bounded Some]
141c138
<   by transfer auto
---
>   by (simp add: interval_eqI)
144c141
<   by transfer auto
---
>   by (simp add: interval_eqI)
147c144
<   by transfer auto
---
>   by (simp add: interval_eqI)
163,165d159
< lemma real_interval_times: "real_interval (a * b) = real_interval a * real_interval b"
<   by transfer (auto simp: Let_def min_def max_def)
< 
172c166
<   by transfer simp
---
>   by (simp add: interval_eqI)
175c169
<   by transfer simp
---
>   by (simp add: interval_eqI)
579c573
<   by transfer auto
---
>   by (simp add: set_of_eq)
597c591
<   by transfer auto
---
>   by (simp add: interval_eqI)
600c594
<   by transfer auto
---
>   by (simp add: interval_eqI)
603c597
<   by transfer auto
---
>   by (simp add: interval_eqI)
609c603
<   by transfer (simp add: Let_def)
---
>   by (simp add: lower_times upper_times interval_eqI)
630c624
<   by transfer auto
---
>   by (auto simp: set_of_eq)
==========
Transcendence_Series_Hancl_Rucki
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transcendence_Series_Hancl_Rucki/Transcendence_Series.thy ../../AFPs/afp-2020/thys/Transcendence_Series_Hancl_Rucki/Transcendence_Series.thy
7c7
<     "HOL-Analysis.Analysis"
---
>     "HOL-Analysis.Multivariate_Analysis"
769c769
<       by (auto simp:powr_powr divide_simps algebra_simps powr_divide)
---
>       by (auto simp:powr_powr divide_simps algebra_simps powr_divide less_imp_le)
==========
Transition_Systems_and_Automata
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DBA/DBA_Combine.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DBA/DBA_Combine.thy
4c4
< imports "DBA" "DGBA"
---
> imports DBA DGBA
7,166c7,70
<   definition dbgail :: "('label, 'state) dba list \<Rightarrow> ('label, 'state list) dgba" where
<     "dbgail AA \<equiv> dgba
<       (INTER (set AA) dba.alphabet)
<       (map dba.initial AA)
<       (\<lambda> a pp. map2 (\<lambda> A p. dba.succ A a p) AA pp)
<       (map (\<lambda> k pp. dba.accepting (AA ! k) (pp ! k)) [0 ..< length AA])"
< 
<   lemma dbgail_trace_smap:
<     assumes "length pp = length AA" "k < length AA"
<     shows "smap (\<lambda> pp. pp ! k) (dgba.trace (dbgail AA) w pp) = dba.trace (AA ! k) w (pp ! k)"
<     using assms unfolding dbgail_def by (coinduction arbitrary: w pp) (force)
<   lemma dbgail_nodes_length:
<     assumes "pp \<in> DGBA.nodes (dbgail AA)"
<     shows "length pp = length AA"
<     using assms unfolding dbgail_def by induct auto
<   lemma dbgail_nodes[intro]:
<     assumes "pp \<in> DGBA.nodes (dbgail AA)" "k < length pp"
<     shows "pp ! k \<in> DBA.nodes (AA ! k)"
<     using assms unfolding dbgail_def by induct auto
< 
<   lemma dbgail_nodes_finite[intro]:
<     assumes "list_all (finite \<circ> DBA.nodes) AA"
<     shows "finite (DGBA.nodes (dbgail AA))"
<   proof (rule finite_subset)
<     show "DGBA.nodes (dbgail AA) \<subseteq> listset (map DBA.nodes AA)"
<       by (force simp: listset_member list_all2_conv_all_nth dbgail_nodes_length)
<     have "finite (listset (map DBA.nodes AA)) \<longleftrightarrow> list_all finite (map DBA.nodes AA)"
<       by (rule listset_finite) (auto simp: list_all_iff)
<     then show "finite (listset (map DBA.nodes AA))" using assms by (simp add: list.pred_map)
<   qed
<   lemma dbgail_nodes_card:
<     assumes "list_all (finite \<circ> DBA.nodes) AA"
<     shows "card (DGBA.nodes (dbgail AA)) \<le> prod_list (map (card \<circ> DBA.nodes) AA)"
<   proof -
<     have "card (DGBA.nodes (dbgail AA)) \<le> card (listset (map DBA.nodes AA))"
<     proof (rule card_mono)
<       have "finite (listset (map DBA.nodes AA)) \<longleftrightarrow> list_all finite (map DBA.nodes AA)"
<         by (rule listset_finite) (auto simp: list_all_iff)
<       then show "finite (listset (map DBA.nodes AA))" using assms by (simp add: list.pred_map)
<       show "DGBA.nodes (dbgail AA) \<subseteq> listset (map DBA.nodes AA)"
<         by (force simp: listset_member list_all2_conv_all_nth dbgail_nodes_length)
<     qed
<     also have "\<dots> = prod_list (map (card \<circ> DBA.nodes) AA)" by simp
<     finally show ?thesis by this
<   qed
< 
<   lemma dbgail_language[simp]: "DGBA.language (dbgail AA) = INTER (set AA) DBA.language"
<   proof safe
<     fix w A
<     assume 1: "w \<in> DGBA.language (dbgail AA)" "A \<in> set AA"
<     obtain 2:
<       "dgba.run (dbgail AA) w (dgba.initial (dbgail AA))"
<       "gen infs (dgba.accepting (dbgail AA)) (dgba.trace (dbgail AA) w (dgba.initial (dbgail AA)))"
<       using 1(1) by rule
<     obtain k where 3: "A = AA ! k" "k < length AA" using 1(2) unfolding in_set_conv_nth by auto
<     have 4: "(\<lambda> pp. dba.accepting A (pp ! k)) \<in> set (dgba.accepting (dbgail AA))"
<       using 3 unfolding dbgail_def by auto
<     show "w \<in> DBA.language A"
<     proof
<       show "dba.run A w (dba.initial A)"
<         using 1(2) 2(1) unfolding DBA.run_alt_def DGBA.run_alt_def dbgail_def by auto
<       have "True \<longleftrightarrow> infs (\<lambda> pp. dba.accepting A (pp ! k)) (dgba.trace (dbgail AA) w (map dba.initial AA))"
<         using 2(2) 4 unfolding dbgail_def by auto
<       also have "\<dots> \<longleftrightarrow> infs (dba.accepting A) (smap (\<lambda> pp. pp ! k)
<         (dgba.trace (dbgail AA) w (map dba.initial AA)))" by (simp add: comp_def)
<       also have "smap (\<lambda> pp. pp ! k) (dgba.trace (dbgail AA) w (map dba.initial AA)) =
<         dba.trace (AA ! k) w (map dba.initial AA ! k)" using 3(2) by (fastforce intro: dbgail_trace_smap)
<       also have "\<dots> = dba.trace A w (dba.initial A)" using 3 by auto
<       finally show "infs (dba.accepting A) (dba.trace A w (dba.initial A))" by simp
<     qed
<   next
<     fix w
<     assume 1: "w \<in> INTER (set AA) DBA.language"
<     have 2: "dba.run A w (dba.initial A)" "infs (dba.accepting A) (dba.trace A w (dba.initial A))"
<       if "A \<in> set AA" for A using 1 that by auto
<     show "w \<in> DGBA.language (dbgail AA)"
<     proof (intro DGBA.language ballI gen)
<       show "dgba.run (dbgail AA) w (dgba.initial (dbgail AA))"
<         using 2(1) unfolding DBA.run_alt_def DGBA.run_alt_def dbgail_def by auto
<     next
<       fix P
<       assume 3: "P \<in> set (dgba.accepting (dbgail AA))"
<       obtain k where 4: "P = (\<lambda> pp. dba.accepting (AA ! k) (pp ! k))" "k < length AA"
<         using 3 unfolding dbgail_def by auto
<       have "True \<longleftrightarrow> infs (dba.accepting (AA ! k)) (dba.trace (AA ! k) w (map dba.initial AA ! k))"
<         using 2(2) 4(2) by auto
<       also have "dba.trace (AA ! k) w (map dba.initial AA ! k) =
<         smap (\<lambda> pp. pp ! k) (dgba.trace (dbgail AA) w (map dba.initial AA))"
<         using 4(2) by (fastforce intro: dbgail_trace_smap[symmetric])
<       also have "infs (dba.accepting (AA ! k)) \<dots> \<longleftrightarrow> infs P (dgba.trace (dbgail AA) w (map dba.initial AA))"
<         unfolding 4(1) by (simp add: comp_def)
<       also have "map dba.initial AA = dgba.initial (dbgail AA)" unfolding dbgail_def by simp
<       finally show "infs P (dgba.trace (dbgail AA) w (dgba.initial (dbgail AA)))" by simp
<     qed
<   qed
< 
<   definition dbail :: "('label, 'state) dba list \<Rightarrow> ('label, 'state list degen) dba" where
<     "dbail = degen \<circ> dbgail"
< 
<   lemma dbail_nodes_finite[intro]:
<     assumes "list_all (finite \<circ> DBA.nodes) AA"
<     shows "finite (DBA.nodes (dbail AA))"
<     using dbgail_nodes_finite assms unfolding dbail_def by auto
<   lemma dbail_nodes_card:
<     assumes"list_all (finite \<circ> DBA.nodes) AA"
<     shows "card (DBA.nodes (dbail AA)) \<le> max 1 (length AA) * prod_list (map (card \<circ> DBA.nodes) AA)"
<   proof -
<     have "card (DBA.nodes (dbail AA)) \<le>
<       max 1 (length (dgba.accepting (dbgail AA))) * card (DGBA.nodes (dbgail AA))"
<       unfolding dbail_def using degen_nodes_card by simp
<     also have "length (dgba.accepting (dbgail AA)) = length AA" unfolding dbgail_def by simp
<     also have "card (DGBA.nodes (dbgail AA)) \<le> prod_list (map (card \<circ> DBA.nodes) AA)"
<       using dbgail_nodes_card assms by this
<     finally show ?thesis by simp
<   qed
< 
<   lemma dbail_language[simp]: "DBA.language (dbail AA) = INTER (set AA) DBA.language"
<     unfolding dbail_def using degen_language dbgail_language by auto
< 
<   definition dbau :: "('label, 'state\<^sub>1) dba \<Rightarrow> ('label, 'state\<^sub>2) dba \<Rightarrow>
<     ('label, 'state\<^sub>1 \<times> 'state\<^sub>2) dba" where
<     "dbau A B \<equiv> dba
<       (dba.alphabet A \<union> dba.alphabet B)
<       (dba.initial A, dba.initial B)
<       (\<lambda> a (p, q). (dba.succ A a p, dba.succ B a q))
<       (\<lambda> (p, q). dba.accepting A p \<or> dba.accepting B q)"
< 
<   lemma dbau_fst[iff]: "infs (P \<circ> fst) (dba.trace (dbau A B) w (p, q)) \<longleftrightarrow> infs P (dba.trace A w p)"
<   proof -
<     let ?t = "dba.trace (dbau A B) w (p, q)"
<     have "infs (P \<circ> fst) ?t \<longleftrightarrow> infs P (smap fst ?t)" by simp
<     also have "smap fst ?t = dba.trace A w p" unfolding dbau_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dbau_snd[iff]: "infs (P \<circ> snd) (dba.trace (dbau A B) w (p, q)) \<longleftrightarrow> infs P (dba.trace B w q)"
<   proof -
<     let ?t = "dba.trace (dbau A B) w (p, q)"
<     have "infs (P \<circ> snd) ?t \<longleftrightarrow> infs P (smap snd ?t)" by simp
<     also have "smap snd ?t = dba.trace B w q" unfolding dbau_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dbau_nodes_fst[intro]:
<     assumes "dba.alphabet A = dba.alphabet B"
<     shows "fst ` DBA.nodes (dbau A B) \<subseteq> DBA.nodes A"
<   proof (rule subsetI, erule imageE)
<     fix pq p
<     assume "pq \<in> DBA.nodes (dbau A B)" "p = fst pq"
<     then show "p \<in> DBA.nodes A" using assms unfolding dbau_def by (induct arbitrary: p) (auto)
<   qed
<   lemma dbau_nodes_snd[intro]:
<     assumes "dba.alphabet A = dba.alphabet B"
<     shows "snd ` DBA.nodes (dbau A B) \<subseteq> DBA.nodes B"
<   proof (rule subsetI, erule imageE)
<     fix pq q
<     assume "pq \<in> DBA.nodes (dbau A B)" "q = snd pq"
<     then show "q \<in> DBA.nodes B" using assms unfolding dbau_def by (induct arbitrary: q) (auto)
<   qed
< 
<   lemma dbau_nodes_finite[intro]:
<     assumes "dba.alphabet A = dba.alphabet B"
---
>   global_interpretation degeneralization: automaton_degeneralization_run
>     dgba dgba.alphabet dgba.initial dgba.transition dgba.accepting "\<lambda> P w r p. gen infs P (p ## r)"
>     dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     fst id
>     defines degeneralize = degeneralization.degeneralize
>     by (unfold_locales) (auto simp flip: sscan_smap)
> 
>   lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DBA.language_def]
>   lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DBA.nodes_def]
>   lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DBA.nodes_def]
> 
>   global_interpretation intersection: automaton_intersection_run
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dgba.dgba dgba.alphabet dgba.initial dgba.transition dgba.accepting "\<lambda> P w r p. gen infs P (p ## r)"
>     "\<lambda> c\<^sub>1 c\<^sub>2. [c\<^sub>1 \<circ> fst, c\<^sub>2 \<circ> snd]"
>     defines intersect' = intersection.product
>     by unfold_locales auto
> 
>   lemmas intersect'_language[simp] = intersection.product_language[folded DGBA.language_def]
>   lemmas intersect'_nodes_finite = intersection.product_nodes_finite[folded DGBA.nodes_def]
>   lemmas intersect'_nodes_card = intersection.product_nodes_card[folded DGBA.nodes_def]
> 
>   global_interpretation union: automaton_union_run
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     "\<lambda> c\<^sub>1 c\<^sub>2 pq. (c\<^sub>1 \<circ> fst) pq \<or> (c\<^sub>2 \<circ> snd) pq"
>     defines union = union.product
>     by (unfold_locales) (simp del: comp_apply)
> 
>   lemmas union_language = union.product_language
>   lemmas union_nodes_finite = union.product_nodes_finite
>   lemmas union_nodes_card = union.product_nodes_card
> 
>   global_interpretation intersection_list: automaton_intersection_list_run
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dgba.dgba dgba.alphabet dgba.initial dgba.transition dgba.accepting "\<lambda> P w r p. gen infs P (p ## r)"
>     "\<lambda> cs. map (\<lambda> k pp. (cs ! k) (pp ! k)) [0 ..< length cs]"
>     defines intersect_list' = intersection_list.product
>     by (unfold_locales) (auto simp: gen_def comp_def)
> 
>   lemmas intersect_list'_language[simp] = intersection_list.product_language[folded DGBA.language_def]
>   lemmas intersect_list'_nodes_finite = intersection_list.product_nodes_finite[folded DGBA.nodes_def]
>   lemmas intersect_list'_nodes_card = intersection_list.product_nodes_card[folded DGBA.nodes_def]
> 
>   global_interpretation union_list: automaton_union_list_run
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     "\<lambda> cs pp. \<exists> k < length cs. (cs ! k) (pp ! k)"
>     defines union_list = union_list.product
>     by (unfold_locales) (simp add: comp_def)
> 
>   lemmas union_list_language = union_list.product_language
>   lemmas union_list_nodes_finite = union_list.product_nodes_finite
>   lemmas union_list_nodes_card = union_list.product_nodes_card
> 
>   (* TODO: these compound definitions are annoying, can we move those into Deterministic theory *)
> 
>   abbreviation intersect where "intersect A B \<equiv> degeneralize (intersect' A B)"
> 
>   lemma intersect_language[simp]: "DBA.language (intersect A B) = DBA.language A \<inter> DBA.language B"
>     by simp
>   lemma intersect_nodes_finite:
168,175c72,74
<     shows "finite (DBA.nodes (dbau A B))"
<   proof (rule finite_subset)
<     show "DBA.nodes (dbau A B) \<subseteq> DBA.nodes A \<times> DBA.nodes B"
<       using dbau_nodes_fst[OF assms(1)] dbau_nodes_snd[OF assms(1)] unfolding image_subset_iff by force
<     show "finite (DBA.nodes A \<times> DBA.nodes B)" using assms(2, 3) by simp
<   qed
<   lemma dbau_nodes_card[intro]:
<     assumes "dba.alphabet A = dba.alphabet B"
---
>     shows "finite (DBA.nodes (intersect A B))"
>     using intersect'_nodes_finite assms by simp
>   lemma intersect_nodes_card:
177c76
<     shows "card (DBA.nodes (dbau A B)) \<le> card (DBA.nodes A) * card (DBA.nodes B)"
---
>     shows "card (DBA.nodes (intersect A B)) \<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)"
179,200c78,84
<     have "card (DBA.nodes (dbau A B)) \<le> card (DBA.nodes A \<times> DBA.nodes B)"
<     proof (rule card_mono)
<       show "finite (DBA.nodes A \<times> DBA.nodes B)" using assms(2, 3) by simp
<       show "DBA.nodes (dbau A B) \<subseteq> DBA.nodes A \<times> DBA.nodes B"
<         using dbau_nodes_fst[OF assms(1)] dbau_nodes_snd[OF assms(1)] unfolding image_subset_iff by force
<     qed
<     also have "\<dots> = card (DBA.nodes A) * card (DBA.nodes B)" using card_cartesian_product by this
<     finally show ?thesis by this
<   qed
< 
<   lemma dbau_language[simp]:
<     assumes "dba.alphabet A = dba.alphabet B"
<     shows "DBA.language (dbau A B) = DBA.language A \<union> DBA.language B"
<   proof -
<     have 1: "dba.alphabet (dbau A B) = dba.alphabet A \<union> dba.alphabet B" unfolding dbau_def by simp
<     have 2: "dba.initial (dbau A B) = (dba.initial A, dba.initial B)" unfolding dbau_def by simp
<     have 3: "dba.accepting (dbau A B) = (\<lambda> pq. (dba.accepting A \<circ> fst) pq \<or> (dba.accepting B \<circ> snd) pq)"
<       unfolding dbau_def by auto
<     have 4: "infs (dba.accepting (dbau A B)) (DBA.trace (dbau A B) w (p, q)) \<longleftrightarrow>
<       infs (dba.accepting A) (DBA.trace A w p) \<or> infs (dba.accepting B) (DBA.trace B w q)" for w p q
<       unfolding 3 by blast
<     show ?thesis using assms unfolding DBA.language_def DBA.run_alt_def 1 2 4 by auto
---
>     have "card (DBA.nodes (intersect A B)) \<le>
>       max 1 (length (dgba.accepting (intersect' A B))) * card (DGBA.nodes (intersect' A B))"
>       using degeneralize_nodes_card by this
>     also have "length (dgba.accepting (intersect' A B)) = 2" by simp
>     also have "card (DGBA.nodes (intersect' A B)) \<le> card (DBA.nodes A) * card (DBA.nodes B)"
>       using intersect'_nodes_card assms by this
>     finally show ?thesis by simp
203,222c87
<   definition dbaul :: "('label, 'state) dba list \<Rightarrow> ('label, 'state list) dba" where
<     "dbaul AA \<equiv> dba
<       (UNION (set AA) dba.alphabet)
<       (map dba.initial AA)
<       (\<lambda> a pp. map2 (\<lambda> A p. dba.succ A a p) AA pp)
<       (\<lambda> pp. \<exists> k < length AA. dba.accepting (AA ! k) (pp ! k))"
< 
<   lemma dbaul_trace_smap:
<     assumes "length pp = length AA" "k < length AA"
<     shows "smap (\<lambda> pp. pp ! k) (dba.trace (dbaul AA) w pp) = dba.trace (AA ! k) w (pp ! k)"
<     using assms unfolding dbaul_def by (coinduction arbitrary: w pp) (force)
<   lemma dbaul_nodes_length:
<     assumes "pp \<in> DBA.nodes (dbaul AA)"
<     shows "length pp = length AA"
<     using assms unfolding dbaul_def by induct auto
<   lemma dbaul_nodes[intro]:
<     assumes "INTER (set AA) dba.alphabet = UNION (set AA) dba.alphabet"
<     assumes "pp \<in> DBA.nodes (dbaul AA)" "k < length pp"
<     shows "pp ! k \<in> DBA.nodes (AA ! k)"
<     using assms(2, 3, 1) unfolding dbaul_def by induct force+
---
>   abbreviation intersect_list where "intersect_list AA \<equiv> degeneralize (intersect_list' AA)"
224,225c89,91
<   lemma dbaul_nodes_finite[intro]:
<     assumes "INTER (set AA) dba.alphabet = UNION (set AA) dba.alphabet"
---
>   lemma intersect_list_language[simp]: "DBA.language (intersect_list AA) = \<Inter> (DBA.language ` set AA)"
>     by simp
>   lemma intersect_list_nodes_finite:
227,236c93,95
<     shows "finite (DBA.nodes (dbaul AA))"
<   proof (rule finite_subset)
<     show "DBA.nodes (dbaul AA) \<subseteq> listset (map DBA.nodes AA)"
<       using assms(1) by (force simp: listset_member list_all2_conv_all_nth dbaul_nodes_length)
<     have "finite (listset (map DBA.nodes AA)) \<longleftrightarrow> list_all finite (map DBA.nodes AA)"
<       by (rule listset_finite) (auto simp: list_all_iff)
<     then show "finite (listset (map DBA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<   qed
<   lemma dbaul_nodes_card:
<     assumes "INTER (set AA) dba.alphabet = UNION (set AA) dba.alphabet"
---
>     shows "finite (DBA.nodes (intersect_list AA))"
>     using intersect_list'_nodes_finite assms by simp
>   lemma intersect_list_nodes_card:
238c97
<     shows "card (DBA.nodes (dbaul AA)) \<le> prod_list (map (card \<circ> DBA.nodes) AA)"
---
>     shows "card (DBA.nodes (intersect_list AA)) \<le> max 1 (length AA) * prod_list (map (card \<circ> DBA.nodes) AA)"
240,299c99,105
<     have "card (DBA.nodes (dbaul AA)) \<le> card (listset (map DBA.nodes AA))"
<     proof (rule card_mono)
<       have "finite (listset (map DBA.nodes AA)) \<longleftrightarrow> list_all finite (map DBA.nodes AA)"
<         by (rule listset_finite) (auto simp: list_all_iff)
<       then show "finite (listset (map DBA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<       show "DBA.nodes (dbaul AA) \<subseteq> listset (map DBA.nodes AA)"
<         using assms(1) by (force simp: listset_member list_all2_conv_all_nth dbaul_nodes_length)
<     qed
<     also have "\<dots> = prod_list (map (card \<circ> DBA.nodes) AA)" by simp
<     finally show ?thesis by this
<   qed
< 
<   lemma dbaul_language[simp]:
<     assumes "INTER (set AA) dba.alphabet = UNION (set AA) dba.alphabet"
<     shows "DBA.language (dbaul AA) = UNION (set AA) DBA.language"
<   proof safe
<     fix w
<     assume 1: "w \<in> DBA.language (dbaul AA)"
<     obtain 2:
<       "dba.run (dbaul AA) w (dba.initial (dbaul AA))"
<       "infs (dba.accepting (dbaul AA)) (dba.trace (dbaul AA) w (dba.initial (dbaul AA)))"
<       using 1 by rule
<     obtain k where 3:
<       "k < length AA"
<       "infs (\<lambda> pp. dba.accepting (AA ! k) (pp ! k)) (dba.trace (dbaul AA) w (map dba.initial AA))"
<       using 2(2) unfolding dbaul_def by auto
<     show "w \<in> UNION (set AA) DBA.language"
<     proof (intro UN_I DBA.language)
<       show "AA ! k \<in> set AA" using 3(1) by simp
<       show "dba.run (AA ! k) w (dba.initial (AA ! k))"
<         using assms 2(1) 3(1) unfolding DBA.run_alt_def DGBA.run_alt_def dbaul_def by force
<       have "True \<longleftrightarrow> infs (\<lambda> pp. dba.accepting (AA ! k) (pp ! k))
<         (dba.trace (dbaul AA) w (map dba.initial AA))" using 3(2) by auto
<       also have "\<dots> \<longleftrightarrow> infs (dba.accepting (AA ! k))
<         (smap (\<lambda> pp. pp ! k) (dba.trace (dbaul AA) w (map dba.initial AA)))" by (simp add: comp_def)
<       also have "smap (\<lambda> pp. pp ! k) (dba.trace (dbaul AA) w (map dba.initial AA)) =
<         dba.trace (AA ! k) w (map dba.initial AA ! k)" using 3(1) by (fastforce intro: dbaul_trace_smap)
<       also have "\<dots> = dba.trace (AA ! k) w (dba.initial (AA ! k))" using 3 by auto
<       finally show "infs (dba.accepting (AA ! k)) (dba.trace (AA ! k) w (dba.initial (AA ! k)))" by simp
<     qed
<   next
<     fix A w
<     assume 1: "A \<in> set AA" "w \<in> DBA.language A"
<     obtain 2: "dba.run A w (dba.initial A)" "infs (dba.accepting A) (dba.trace A w (dba.initial A))"
<       using 1(2) by rule
<     obtain k where 3: "A = AA ! k" "k < length AA" using 1(1) unfolding in_set_conv_nth by auto
<     show "w \<in> DBA.language (dbaul AA)"
<     proof
<       show "dba.run (dbaul AA) w (dba.initial (dbaul AA))"
<         using 1(1) 2(1) unfolding DBA.run_alt_def DGBA.run_alt_def dbaul_def by auto
<       have "True \<longleftrightarrow> infs (dba.accepting (AA ! k)) (dba.trace (AA ! k) w (map dba.initial AA ! k))"
<         using 2(2) 3 by auto
<       also have "dba.trace (AA ! k) w (map dba.initial AA ! k) =
<         smap (\<lambda> pp. pp ! k) (dba.trace (dbaul AA) w (map dba.initial AA))"
<         using 3(2) by (fastforce intro: dbaul_trace_smap[symmetric])
<       also have "infs (dba.accepting (AA ! k)) \<dots> \<longleftrightarrow> infs (\<lambda> pp. dba.accepting (AA ! k) (pp ! k))
<         (dba.trace (dbaul AA) w (map dba.initial AA))" by (simp add: comp_def)
<       finally show "infs (dba.accepting (dbaul AA)) (dba.trace (dbaul AA) w (dba.initial (dbaul AA)))"
<         using 3(2) unfolding dbaul_def by auto
<     qed
---
>     have "card (DBA.nodes (intersect_list AA)) \<le>
>       max 1 (length (dgba.accepting (intersect_list' AA))) * card (DGBA.nodes (intersect_list' AA))"
>       using degeneralize_nodes_card by this
>     also have "length (dgba.accepting (intersect_list' AA)) = length AA" by simp
>     also have "card (DGBA.nodes (intersect_list' AA)) \<le> prod_list (map (card \<circ> DBA.nodes) AA)"
>       using intersect_list'_nodes_card assms by this
>     finally show ?thesis by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DBA/DBA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DBA/DBA.thy
4,9c4
< imports
<   "../../Basic/Sequence_Zip"
<   "../../Basic/Acceptance"
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Deterministic"
15c10
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
18,23c13,20
<   global_interpretation dba: transition_system_initial
<     "succ A" "\<lambda> a p. a \<in> alphabet A" "\<lambda> p. p = initial A"
<     for A
<     defines path = dba.path and run = dba.run and reachable = dba.reachable and nodes = dba.nodes and
<       enableds = dba.enableds and paths = dba.paths and runs = dba.runs
<     by this
---
>   (* TODO: if we interpret everything at once, some abbreviations don't get folded back
>     see DBA_Combine.intersection_list.combine_finite *)
>   global_interpretation dba: automaton dba alphabet initial transition accepting
>     defines path = dba.path and run = dba.run and reachable = dba.reachable and nodes = dba.nodes
>     by unfold_locales auto
>   global_interpretation dba: automaton_run dba alphabet initial transition accepting "\<lambda> P w r p. infs P (p ## r)"
>     defines language = dba.language
>     by standard
28,60c25,27
< 
<   abbreviation successors :: "('label, 'state) dba \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dba.successors TYPE('label)"
< 
<   lemma path_alt_def: "path A w p \<longleftrightarrow> set w \<subseteq> alphabet A"
<   unfolding lists_iff_set[symmetric]
<   proof
<     show "w \<in> lists (alphabet A)" if "path A w p" using that by (induct arbitrary: p) (auto)
<     show "path A w p" if "w \<in> lists (alphabet A)" using that by (induct arbitrary: p) (auto)
<   qed
<   lemma run_alt_def: "run A w p \<longleftrightarrow> sset w \<subseteq> alphabet A"
<   unfolding streams_iff_sset[symmetric]
<   proof
<     show "w \<in> streams (alphabet A)" if "run A w p"
<       using that by (coinduction arbitrary: w p) (force elim: dba.run.cases)
<     show "run A w p" if "w \<in> streams (alphabet A)"
<       using that by (coinduction arbitrary: w p) (force elim: streams.cases)
<   qed
< 
<   definition language :: "('label, 'state) dba \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w. run A w (initial A) \<and> infs (accepting A) (trace A w (initial A))}"
< 
<   lemma language[intro]:
<     assumes "run A w (initial A)" "infs (accepting A) (trace A w (initial A))"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "run A w (initial A)" "infs (accepting A) (trace A w (initial A))"
<     using assms unfolding language_def by auto
< 
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def run_alt_def using sset_streams by auto
---
>   (* TODO: why does this happen? if I can fix it here, why can't the interpretation do it?
>     same happens with reachable, requiring the use of defines directives *)
>   abbreviation successors where "successors \<equiv> dba.successors TYPE('label)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DBA/DGBA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DBA/DGBA.thy
4,6c4
< imports
<   "DBA"
<   "../../Transition_Systems/Transition_System_Degeneralization"
---
> imports "../Deterministic"
12c10
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
15,22c13,18
<   global_interpretation dgba: transition_system_initial_generalized
<     "succ A" "\<lambda> a p. a \<in> alphabet A" "\<lambda> p. p = initial A" "accepting A"
<     for A
<     defines path = dgba.path and run = dgba.run and reachable = dgba.reachable and nodes = dgba.nodes and
<       enableds = dgba.enableds and paths = dgba.paths and runs = dgba.runs and
<       dexecute = dgba.dexecute and denabled = dgba.denabled and dinitial = dgba.dinitial and
<       daccepting = dgba.dcondition
<     by this
---
>   global_interpretation dgba: automaton dgba alphabet initial transition accepting
>     defines path = dgba.path and run = dgba.run and reachable = dgba.reachable and nodes = dgba.nodes
>     by unfold_locales auto
>   global_interpretation dgba: automaton_run dgba alphabet initial transition accepting "\<lambda> P w r p. gen infs P (p ## r)"
>     defines language = dgba.language
>     by standard
27,88c23
< 
<   abbreviation successors :: "('label, 'state) dgba \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dgba.successors TYPE('label)"
< 
<   lemma path_alt_def: "path A w p \<longleftrightarrow> set w \<subseteq> alphabet A"
<   unfolding lists_iff_set[symmetric]
<   proof
<     show "w \<in> lists (alphabet A)" if "path A w p" using that by (induct arbitrary: p) (auto)
<     show "path A w p" if "w \<in> lists (alphabet A)" using that by (induct arbitrary: p) (auto)
<   qed
<   lemma run_alt_def: "run A w p \<longleftrightarrow> sset w \<subseteq> alphabet A"
<   unfolding streams_iff_sset[symmetric]
<   proof
<     show "w \<in> streams (alphabet A)" if "run A w p"
<       using that by (coinduction arbitrary: w p) (force elim: dgba.run.cases)
<     show "run A w p" if "w \<in> streams (alphabet A)"
<       using that by (coinduction arbitrary: w p) (force elim: streams.cases)
<   qed
< 
<   definition language :: "('label, 'state) dgba \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w. run A w (initial A) \<and> gen infs (accepting A) (trace A w (initial A))}"
< 
<   lemma language[intro]:
<     assumes "run A w (initial A)" "gen infs (accepting A) (trace A w (initial A))"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "run A w (initial A)" "gen infs (accepting A) (trace A w (initial A))"
<     using assms unfolding language_def by auto
< 
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def run_alt_def using sset_streams by auto
< 
<   definition degen :: "('label, 'state) dgba \<Rightarrow> ('label, 'state degen) dba" where
<     "degen A \<equiv> dba (alphabet A) (The (dinitial A)) (dexecute A) (daccepting A)"
< 
<   lemma degen_simps[simp]:
<     "dba.alphabet (degen A) = alphabet A"
<     "dba.initial (degen A) = (initial A, 0)"
<     "dba.succ (degen A) = dexecute A"
<     "dba.accepting (degen A) = daccepting A"
<     unfolding degen_def dgba.dinitial_def by auto
< 
<   lemma degen_trace[simp]: "dba.trace (degen A) = dgba.degen.trace A" unfolding degen_simps by rule
<   lemma degen_run[simp]: "dba.run (degen A) = dgba.degen.run A"
<     unfolding DBA.run_def degen_simps dgba.denabled_def case_prod_beta' by rule
<   lemma degen_nodes[simp]: "DBA.nodes (degen A) = dgba.degen.nodes TYPE('label) A"
<     unfolding DBA.nodes_def degen_simps
<     unfolding dgba.denabled_def dgba.dinitial_def
<     unfolding prod_eq_iff case_prod_beta' prod.sel
<     by rule
< 
<   lemma degen_nodes_finite[iff]: "finite (DBA.nodes (degen A)) \<longleftrightarrow> finite (DGBA.nodes A)" by simp
<   lemma degen_nodes_card: "card (DBA.nodes (degen A)) \<le> max 1 (length (accepting A)) * card (DGBA.nodes A)"
<     using dgba.degen_nodes_card by simp
< 
<   lemma degen_language[simp]: "DBA.language (degen A) = DGBA.language A"
<     unfolding DBA.language_def DGBA.language_def degen_simps
<     unfolding degen_trace degen_run
<     unfolding dgba.degen_run dgba.degen_infs gen_def
<     by rule
---
>   abbreviation successors where "successors \<equiv> dgba.successors TYPE('label)"
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata: DBTA
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DCA/DCA_Combine.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DCA/DCA_Combine.thy
4c4
< imports "DCA" "DGCA"
---
> imports DCA DGCA
7,42c7,70
<   definition dcai :: "('label, 'state\<^sub>1) dca \<Rightarrow> ('label, 'state\<^sub>2) dca \<Rightarrow>
<     ('label, 'state\<^sub>1 \<times> 'state\<^sub>2) dca" where
<     "dcai A B \<equiv> dca
<       (dca.alphabet A \<inter> dca.alphabet B)
<       (dca.initial A, dca.initial B)
<       (\<lambda> a (p, q). (dca.succ A a p, dca.succ B a q))
<       (\<lambda> (p, q). dca.rejecting A p \<or> dca.rejecting B q)"
< 
<   lemma dcai_fst[iff]: "infs (P \<circ> fst) (dca.trace (dcai A B) w (p, q)) \<longleftrightarrow> infs P (dca.trace A w p)"
<   proof -
<     let ?t = "dca.trace (dcai A B) w (p, q)"
<     have "infs (P \<circ> fst) ?t \<longleftrightarrow> infs P (smap fst ?t)" by simp
<     also have "smap fst ?t = dca.trace A w p" unfolding dcai_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dcai_snd[iff]: "infs (P \<circ> snd) (dca.trace (dcai A B) w (p, q)) \<longleftrightarrow> infs P (dca.trace B w q)"
<   proof -
<     let ?t = "dca.trace (dcai A B) w (p, q)"
<     have "infs (P \<circ> snd) ?t \<longleftrightarrow> infs P (smap snd ?t)" by simp
<     also have "smap snd ?t = dca.trace B w q" unfolding dcai_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dcai_nodes_fst[intro]: "fst ` DCA.nodes (dcai A B) \<subseteq> DCA.nodes A"
<   proof (rule subsetI, erule imageE)
<     fix pq p
<     assume "pq \<in> DCA.nodes (dcai A B)" "p = fst pq"
<     then show "p \<in> DCA.nodes A" unfolding dcai_def by (induct arbitrary: p) (auto)
<   qed
<   lemma dcai_nodes_snd[intro]: "snd ` DCA.nodes (dcai A B) \<subseteq> DCA.nodes B"
<   proof (rule subsetI, erule imageE)
<     fix pq q
<     assume "pq \<in> DCA.nodes (dcai A B)" "q = snd pq"
<     then show "q \<in> DCA.nodes B" unfolding dcai_def by (induct arbitrary: q) (auto)
<   qed
< 
<   lemma dcai_nodes_finite[intro]:
---
>   global_interpretation degeneralization: automaton_degeneralization_run
>     dgca dgca.alphabet dgca.initial dgca.transition dgca.rejecting "\<lambda> P w r p. cogen fins P (p ## r)"
>     dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     fst id
>     defines degeneralize = degeneralization.degeneralize
>     by (unfold_locales) (auto simp flip: sscan_smap)
> 
>   lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DCA.language_def]
>   lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DCA.nodes_def]
>   lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DCA.nodes_def]
> 
>   global_interpretation intersection: automaton_intersection_run
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     "\<lambda> c\<^sub>1 c\<^sub>2 pq. (c\<^sub>1 \<circ> fst) pq \<or> (c\<^sub>2 \<circ> snd) pq"
>     defines intersect = intersection.product
>     by (unfold_locales) (simp del: comp_apply)
> 
>   lemmas intersect_language = intersection.product_language
>   lemmas intersect_nodes_finite = intersection.product_nodes_finite
>   lemmas intersect_nodes_card = intersection.product_nodes_card
> 
>   global_interpretation union: automaton_union_run
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dgca.dgca dgca.alphabet dgca.initial dgca.transition dgca.rejecting "\<lambda> P w r p. cogen fins P (p ## r)"
>     "\<lambda> c\<^sub>1 c\<^sub>2. [c\<^sub>1 \<circ> fst, c\<^sub>2 \<circ> snd]"
>     defines union' = union.product
>     by unfold_locales auto
> 
>   lemmas union'_language[simp] = union.product_language[folded DGCA.language_def]
>   lemmas union'_nodes_finite = union.product_nodes_finite[folded DGCA.nodes_def]
>   lemmas union'_nodes_card = union.product_nodes_card[folded DGCA.nodes_def]
> 
>   global_interpretation intersection_list: automaton_intersection_list_run
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     "\<lambda> cs pp. \<exists> k < length cs. (cs ! k) (pp ! k)"
>     defines intersect_list = intersection_list.product
>     by (unfold_locales) (simp add: comp_def)
> 
>   lemmas intersect_list_language = intersection_list.product_language
>   lemmas intersect_list_nodes_finite = intersection_list.product_nodes_finite
>   lemmas intersect_list_nodes_card = intersection_list.product_nodes_card
> 
>   global_interpretation union_list: automaton_union_list_run
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dgca.dgca dgca.alphabet dgca.initial dgca.transition dgca.rejecting "\<lambda> P w r p. cogen fins P (p ## r)"
>     "\<lambda> cs. map (\<lambda> k pp. (cs ! k) (pp ! k)) [0 ..< length cs]"
>     defines union_list' = union_list.product
>     by (unfold_locales) (auto simp: cogen_def comp_def)
> 
>   lemmas union_list'_language[simp] = union_list.product_language[folded DGCA.language_def]
>   lemmas union_list'_nodes_finite = union_list.product_nodes_finite[folded DGCA.nodes_def]
>   lemmas union_list'_nodes_card = union_list.product_nodes_card[folded DGCA.nodes_def]
> 
>   abbreviation union where "union A B \<equiv> degeneralize (union' A B)"
> 
>   lemma union_language[simp]:
>     assumes "dca.alphabet A = dca.alphabet B"
>     shows "DCA.language (union A B) = DCA.language A \<union> DCA.language B"
>     using assms by simp
>   lemma union_nodes_finite:
44,50c72,74
<     shows "finite (DCA.nodes (dcai A B))"
<   proof (rule finite_subset)
<     show "DCA.nodes (dcai A B) \<subseteq> DCA.nodes A \<times> DCA.nodes B"
<       using dcai_nodes_fst dcai_nodes_snd unfolding image_subset_iff by force
<     show "finite (DCA.nodes A \<times> DCA.nodes B)" using assms by simp
<   qed
<   lemma dcai_nodes_card[intro]:
---
>     shows "finite (DCA.nodes (union A B))"
>     using union'_nodes_finite assms by simp
>   lemma union_nodes_card:
52c76
<     shows "card (DCA.nodes (dcai A B)) \<le> card (DCA.nodes A) * card (DCA.nodes B)"
---
>     shows "card (DCA.nodes (union A B)) \<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)"
54,268c78,84
<     have "card (DCA.nodes (dcai A B)) \<le> card (DCA.nodes A \<times> DCA.nodes B)"
<     proof (rule card_mono)
<       show "finite (DCA.nodes A \<times> DCA.nodes B)" using assms by simp
<       show "DCA.nodes (dcai A B) \<subseteq> DCA.nodes A \<times> DCA.nodes B"
<         using dcai_nodes_fst dcai_nodes_snd unfolding image_subset_iff by force
<     qed
<     also have "\<dots> = card (DCA.nodes A) * card (DCA.nodes B)" using card_cartesian_product by this
<     finally show ?thesis by this
<   qed
< 
<   lemma dcai_language[simp]: "DCA.language (dcai A B) = DCA.language A \<inter> DCA.language B"
<   proof -
<     have 1: "dca.alphabet (dcai A B) = dca.alphabet A \<inter> dca.alphabet B" unfolding dcai_def by simp
<     have 2: "dca.initial (dcai A B) = (dca.initial A, dca.initial B)" unfolding dcai_def by simp
<     have 3: "dca.rejecting (dcai A B) = (\<lambda> pq. (dca.rejecting A \<circ> fst) pq \<or> (dca.rejecting B \<circ> snd) pq)"
<       unfolding dcai_def by auto
<     have 4: "infs (dca.rejecting (dcai A B)) (DCA.trace (dcai A B) w (p, q)) \<longleftrightarrow>
<       infs (dca.rejecting A) (DCA.trace A w p) \<or> infs (dca.rejecting B) (DCA.trace B w q)" for w p q
<       unfolding 3 by blast
<     show ?thesis unfolding DCA.language_def DCA.run_alt_def 1 2 4 by auto
<   qed
< 
<   definition dcail :: "('label, 'state) dca list \<Rightarrow> ('label, 'state list) dca" where
<     "dcail AA \<equiv> dca
<       (INTER (set AA) dca.alphabet)
<       (map dca.initial AA)
<       (\<lambda> a pp. map2 (\<lambda> A p. dca.succ A a p) AA pp)
<       (\<lambda> pp. \<exists> k < length AA. dca.rejecting (AA ! k) (pp ! k))"
< 
<   lemma dcail_trace_smap:
<     assumes "length pp = length AA" "k < length AA"
<     shows "smap (\<lambda> pp. pp ! k) (dca.trace (dcail AA) w pp) = dca.trace (AA ! k) w (pp ! k)"
<     using assms unfolding dcail_def by (coinduction arbitrary: w pp) (force)
<   lemma dcail_nodes_length:
<     assumes "pp \<in> DCA.nodes (dcail AA)"
<     shows "length pp = length AA"
<     using assms unfolding dcail_def by induct auto
<   lemma dcail_nodes[intro]:
<     assumes "pp \<in> DCA.nodes (dcail AA)" "k < length pp"
<     shows "pp ! k \<in> DCA.nodes (AA ! k)"
<     using assms unfolding dcail_def by induct auto
< 
<   lemma dcail_finite[intro]:
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "finite (DCA.nodes (dcail AA))"
<   proof (rule finite_subset)
<     show "DCA.nodes (dcail AA) \<subseteq> listset (map DCA.nodes AA)"
<       by (force simp: listset_member list_all2_conv_all_nth dcail_nodes_length)
<     have "finite (listset (map DCA.nodes AA)) \<longleftrightarrow> list_all finite (map DCA.nodes AA)"
<       by (rule listset_finite) (auto simp: list_all_iff)
<     then show "finite (listset (map DCA.nodes AA))" using assms by (simp add: list.pred_map)
<   qed
<   lemma dcail_nodes_card:
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "card (DCA.nodes (dcail AA)) \<le> prod_list (map (card \<circ> DCA.nodes) AA)"
<   proof -
<     have "card (DCA.nodes (dcail AA)) \<le> card (listset (map DCA.nodes AA))"
<     proof (rule card_mono)
<       have "finite (listset (map DCA.nodes AA)) \<longleftrightarrow> list_all finite (map DCA.nodes AA)"
<         by (rule listset_finite) (auto simp: list_all_iff)
<       then show "finite (listset (map DCA.nodes AA))" using assms by (simp add: list.pred_map)
<       show "DCA.nodes (dcail AA) \<subseteq> listset (map DCA.nodes AA)"
<         by (force simp: listset_member list_all2_conv_all_nth dcail_nodes_length)
<     qed
<     also have "\<dots> = prod_list (map (card \<circ> DCA.nodes) AA)" by simp
<     finally show ?thesis by this
<   qed
< 
<   lemma dcail_language[simp]: "DCA.language (dcail AA) = INTER (set AA) DCA.language"
<   proof safe
<     fix A w
<     assume 1: "w \<in> DCA.language (dcail AA)" "A \<in> set AA"
<     obtain 2:
<       "dca.run (dcail AA) w (dca.initial (dcail AA))"
<       "\<not> infs (dca.rejecting (dcail AA)) (dca.trace (dcail AA) w (dca.initial (dcail AA)))"
<       using 1(1) by rule
<     obtain k where 3: "A = AA ! k" "k < length AA" using 1(2) unfolding in_set_conv_nth by auto
<     have 4: "\<not> infs (\<lambda> pp. dca.rejecting A (pp ! k)) (dca.trace (dcail AA) w (map dca.initial AA))"
<       using 2(2) 3 unfolding dcail_def by auto
<     show "w \<in> DCA.language A"
<     proof
<       show "dca.run A w (dca.initial A)"
<         using 1(2) 2(1) unfolding DCA.run_alt_def dcail_def by auto
<       have "True \<longleftrightarrow> \<not> infs (\<lambda> pp. dca.rejecting A (pp ! k)) (dca.trace (dcail AA) w (map dca.initial AA))"
<         using 4 by simp
<       also have "\<dots> \<longleftrightarrow> \<not> infs (dca.rejecting A) (smap (\<lambda> pp. pp ! k)
<         (dca.trace (dcail AA) w (map dca.initial AA)))" by (simp add: comp_def)
<       also have "smap (\<lambda> pp. pp ! k) (dca.trace (dcail AA) w (map dca.initial AA)) =
<         dca.trace (AA ! k) w (map dca.initial AA ! k)" using 3(2) by (fastforce intro: dcail_trace_smap)
<       also have "\<dots> = dca.trace A w (dca.initial A)" using 3 by auto
<       finally show "\<not> infs (dca.rejecting A) (DCA.trace A w (dca.initial A))" by simp
<     qed
<   next
<     fix w
<     assume 1: "w \<in> INTER (set AA) DCA.language"
<     have 2: "dca.run A w (dca.initial A)" "\<not> infs (dca.rejecting A) (dca.trace A w (dca.initial A))"
<       if "A \<in> set AA" for A using 1 that by auto
<     have 3: "\<not> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k)) (dca.trace (dcail AA) w (map dca.initial AA))"
<       if "k < length AA" for k
<     proof -
<       have "True \<longleftrightarrow> \<not> infs (dca.rejecting (AA ! k)) (dca.trace (AA ! k) w (map dca.initial AA ! k))"
<         using 2(2) that by auto
<       also have "dca.trace (AA ! k) w (map dca.initial AA ! k) =
<         smap (\<lambda> pp. pp ! k) (dca.trace (dcail AA) w (map dca.initial AA))"
<         using that by (fastforce intro: dcail_trace_smap[symmetric])
<       also have "infs (dca.rejecting (AA ! k)) \<dots> \<longleftrightarrow> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k))
<         (dca.trace (dcail AA) w (map dca.initial AA))" by (simp add: comp_def)
<       finally show ?thesis by simp
<     qed
<     show "w \<in> DCA.language (dcail AA)"
<     proof
<       show "dca.run (dcail AA) w (dca.initial (dcail AA))"
<         using 2(1) unfolding DCA.run_alt_def dcail_def by auto
<       show "\<not> infs (dca.rejecting (dcail AA)) (dca.trace (dcail AA) w (dca.initial (dcail AA)))"
<         using 3 unfolding dcail_def by auto
<     qed
<   qed
< 
<   definition dcgaul :: "('label, 'state) dca list \<Rightarrow> ('label, 'state list) dgca" where
<     "dcgaul AA \<equiv> dgca
<       (UNION (set AA) dca.alphabet)
<       (map dca.initial AA)
<       (\<lambda> a pp. map2 (\<lambda> A p. dca.succ A a p) AA pp)
<       (map (\<lambda> k pp. dca.rejecting (AA ! k) (pp ! k)) [0 ..< length AA])"
< 
<   lemma dcgaul_trace_smap:
<     assumes "length pp = length AA" "k < length AA"
<     shows "smap (\<lambda> pp. pp ! k) (dgca.trace (dcgaul AA) w pp) = dca.trace (AA ! k) w (pp ! k)"
<     using assms unfolding dcgaul_def by (coinduction arbitrary: w pp) (force)
<   lemma dcgaul_nodes_length:
<     assumes "pp \<in> DGCA.nodes (dcgaul AA)"
<     shows "length pp = length AA"
<     using assms unfolding dcgaul_def by induct auto
<   lemma dcgaul_nodes[intro]:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     assumes "pp \<in> DGCA.nodes (dcgaul AA)" "k < length pp"
<     shows "pp ! k \<in> DCA.nodes (AA ! k)"
<     using assms(2, 3, 1) unfolding dcgaul_def by induct force+
< 
<   lemma dcgaul_nodes_finite[intro]:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "finite (DGCA.nodes (dcgaul AA))"
<   proof (rule finite_subset)
<     show "DGCA.nodes (dcgaul AA) \<subseteq> listset (map DCA.nodes AA)"
<       using assms(1) by (force simp: listset_member list_all2_conv_all_nth dcgaul_nodes_length)
<     have "finite (listset (map DCA.nodes AA)) \<longleftrightarrow> list_all finite (map DCA.nodes AA)"
<       by (rule listset_finite) (auto simp: list_all_iff)
<     then show "finite (listset (map DCA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<   qed
<   lemma dcgaul_nodes_card:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "card (DGCA.nodes (dcgaul AA)) \<le> prod_list (map (card \<circ> DCA.nodes) AA)"
<   proof -
<     have "card (DGCA.nodes (dcgaul AA)) \<le> card (listset (map DCA.nodes AA))"
<     proof (rule card_mono)
<       have "finite (listset (map DCA.nodes AA)) \<longleftrightarrow> list_all finite (map DCA.nodes AA)"
<         by (rule listset_finite) (auto simp: list_all_iff)
<       then show "finite (listset (map DCA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<       show "DGCA.nodes (dcgaul AA) \<subseteq> listset (map DCA.nodes AA)"
<         using assms(1) by (force simp: listset_member list_all2_conv_all_nth dcgaul_nodes_length)
<     qed
<     also have "\<dots> = prod_list (map (card \<circ> DCA.nodes) AA)" by simp
<     finally show ?thesis by this
<   qed
< 
<   lemma dcgaul_language[simp]:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     shows "DGCA.language (dcgaul AA) = UNION (set AA) DCA.language"
<   proof safe
<     fix w
<     assume 1: "w \<in> DGCA.language (dcgaul AA)"
<     obtain k where 2:
<       "dgca.run (dcgaul AA) w (dgca.initial (dcgaul AA))"
<       "k < length AA"
<       "\<not> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k)) (dgca.trace (dcgaul AA) w (dgca.initial (dcgaul AA)))"
<       using 1 unfolding dcgaul_def by force
<     show "w \<in> UNION (set AA) DCA.language"
<     proof (intro UN_I DCA.language)
<       show "AA ! k \<in> set AA" using 2(2) by simp
<       show "dca.run (AA ! k) w (dca.initial (AA ! k))"
<         using assms 2(1, 2) unfolding DCA.run_alt_def DGCA.run_alt_def dcgaul_def by force
<       have "True \<longleftrightarrow> \<not> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k))
<         (dgca.trace (dcgaul AA) w (map dca.initial AA))" using 2(3) unfolding dcgaul_def by auto
<       also have "\<dots> \<longleftrightarrow> \<not> infs (dca.rejecting (AA ! k))
<         (smap (\<lambda> pp. pp ! k) (dgca.trace (dcgaul AA) w (map dca.initial AA)))" by (simp add: comp_def)
<       also have "smap (\<lambda> pp. pp ! k) (dgca.trace (dcgaul AA) w (map dca.initial AA)) =
<         dca.trace (AA ! k) w (map dca.initial AA ! k)" using 2(2) by (fastforce intro: dcgaul_trace_smap)
<       also have "\<dots> = dca.trace (AA ! k) w (dca.initial (AA ! k))" using 2(2) by auto
<       finally show "\<not> infs (dca.rejecting (AA ! k)) (dca.trace (AA ! k) w (dca.initial (AA ! k)))" by simp
<     qed
<   next
<     fix A w
<     assume 1: "A \<in> set AA" "w \<in> DCA.language A"
<     obtain 2: "dca.run A w (dca.initial A)" "\<not> infs (dca.rejecting A) (dca.trace A w (dca.initial A))"
<       using 1(2) by rule
<     obtain k where 3: "A = AA ! k" "k < length AA" using 1(1) unfolding in_set_conv_nth by auto
<     show "w \<in> DGCA.language (dcgaul AA)"
<     proof (intro DGCA.language bexI cogen)
<       show "dgca.run (dcgaul AA) w (dgca.initial (dcgaul AA))"
<         using 1(1) 2(1) unfolding DCA.run_alt_def DGCA.run_alt_def dcgaul_def by auto
<       have "True \<longleftrightarrow> \<not> infs (dca.rejecting (AA ! k)) (dca.trace (AA ! k) w (map dca.initial AA ! k))"
<         using 2(2) 3 by auto
<       also have "dca.trace (AA ! k) w (map dca.initial AA ! k) =
<         smap (\<lambda> pp. pp ! k) (dgca.trace (dcgaul AA) w (map dca.initial AA))"
<         using 3(2) by (fastforce intro: dcgaul_trace_smap[symmetric])
<       also have "\<not> infs (dca.rejecting (AA ! k)) \<dots> \<longleftrightarrow> \<not> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k))
<         (dgca.trace (dcgaul AA) w (map dca.initial AA))" by (simp add: comp_def)
<       also have "map dca.initial AA = dgca.initial (dcgaul AA)" unfolding dcgaul_def by simp
<       finally show "\<not> infs (\<lambda> pp. dca.rejecting (AA ! k) (pp ! k)) (dgca.trace (dcgaul AA) w (dgca.initial (dcgaul AA)))"
<         by simp
<       show "(\<lambda> pp. dca.rejecting (AA ! k) (pp ! k)) \<in> set (dgca.rejecting (dcgaul AA))"
<         unfolding dcgaul_def using 3(2) by simp
<     qed
---
>     have "card (DCA.nodes (union A B)) \<le>
>       max 1 (length (dgca.rejecting (union' A B))) * card (DGCA.nodes (union' A B))"
>       using degeneralize_nodes_card by this
>     also have "length (dgca.rejecting (union' A B)) = 2" by simp
>     also have "card (DGCA.nodes (union' A B)) \<le> card (DCA.nodes A) * card (DCA.nodes B)"
>       using union'_nodes_card assms by this
>     finally show ?thesis by simp
271,272c87
<   definition dcaul :: "('label, 'state) dca list \<Rightarrow> ('label, 'state list degen) dca" where
<     "dcaul = degen \<circ> dcgaul"
---
>   abbreviation union_list where "union_list AA \<equiv> degeneralize (union_list' AA)"
274,289c89,106
<   lemma dcaul_nodes_finite[intro]:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "finite (DCA.nodes (dcaul AA))"
<     using dcgaul_nodes_finite assms unfolding dcaul_def by auto
<   lemma dcaul_nodes_card:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     assumes "list_all (finite \<circ> DCA.nodes) AA"
<     shows "card (DCA.nodes (dcaul AA)) \<le> max 1 (length AA) * prod_list (map (card \<circ> DCA.nodes) AA)"
<   proof -
<     have "card (DCA.nodes (dcaul AA)) \<le>
<       max 1 (length (dgca.rejecting (dcgaul AA))) * card (DGCA.nodes (dcgaul AA))"
<       unfolding dcaul_def using degen_nodes_card by simp
<     also have "length (dgca.rejecting (dcgaul AA)) = length AA" unfolding dcgaul_def by simp
<     also have "card (DGCA.nodes (dcgaul AA)) \<le> prod_list (map (card \<circ> DCA.nodes) AA)"
<       using dcgaul_nodes_card assms by this
---
>   lemma union_list_language[simp]:
>     assumes "\<Inter> (dca.alphabet ` set AA) = \<Union> (dca.alphabet ` set AA)"
>     shows "DCA.language (union_list AA) = \<Union> (DCA.language ` set AA)"
>     using assms by simp
>   lemma union_list_nodes_finite:
>     assumes "list_all (finite \<circ> DCA.nodes) AA"
>     shows "finite (DCA.nodes (union_list AA))"
>     using union_list'_nodes_finite assms by simp
>   lemma union_list_nodes_card:
>     assumes "list_all (finite \<circ> DCA.nodes) AA"
>     shows "card (DCA.nodes (union_list AA)) \<le> max 1 (length AA) * prod_list (map (card \<circ> DCA.nodes) AA)"
>   proof -
>     have "card (DCA.nodes (union_list AA)) \<le>
>       max 1 (length (dgca.rejecting (union_list' AA))) * card (DGCA.nodes (union_list' AA))"
>       using degeneralize_nodes_card by this
>     also have "length (dgca.rejecting (union_list' AA)) = length AA" by simp
>     also have "card (DGCA.nodes (union_list' AA)) \<le> prod_list (map (card \<circ> DCA.nodes) AA)"
>       using union_list'_nodes_card assms by this
292,296d108
< 
<   lemma dcaul_language[simp]:
<     assumes "INTER (set AA) dca.alphabet = UNION (set AA) dca.alphabet"
<     shows "DCA.language (dcaul AA) = UNION (set AA) DCA.language"
<     unfolding dcaul_def using degen_language dcgaul_language[OF assms] by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DCA/DCA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DCA/DCA.thy
4,9c4
< imports
<   "../../Basic/Sequence_Zip"
<   "../../Basic/Acceptance"
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Deterministic"
15c10
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
18,23c13,18
<   global_interpretation dca: transition_system_initial
<     "succ A" "\<lambda> a p. a \<in> alphabet A" "\<lambda> p. p = initial A"
<     for A
<     defines path = dca.path and run = dca.run and reachable = dca.reachable and nodes = dca.nodes and
<       enableds = dca.enableds and paths = dca.paths and runs = dca.runs
<     by this
---
>   global_interpretation dca: automaton dca alphabet initial transition rejecting
>     defines path = dca.path and run = dca.run and reachable = dca.reachable and nodes = dca.nodes
>     by unfold_locales auto
>   global_interpretation dca: automaton_run dca alphabet initial transition rejecting "\<lambda> P w r p. fins P (p ## r)"
>     defines language = dca.language
>     by standard
28,60c23
< 
<   abbreviation successors :: "('label, 'state) dca \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dca.successors TYPE('label)"
< 
<   lemma path_alt_def: "path A w p \<longleftrightarrow> set w \<subseteq> alphabet A"
<   unfolding lists_iff_set[symmetric]
<   proof
<     show "w \<in> lists (alphabet A)" if "path A w p" using that by (induct arbitrary: p) (auto)
<     show "path A w p" if "w \<in> lists (alphabet A)" using that by (induct arbitrary: p) (auto)
<   qed
<   lemma run_alt_def: "run A w p \<longleftrightarrow> sset w \<subseteq> alphabet A"
<   unfolding streams_iff_sset[symmetric]
<   proof
<     show "w \<in> streams (alphabet A)" if "run A w p"
<       using that by (coinduction arbitrary: w p) (force elim: dca.run.cases)
<     show "run A w p" if "w \<in> streams (alphabet A)"
<       using that by (coinduction arbitrary: w p) (force elim: streams.cases)
<   qed
< 
<   definition language :: "('label, 'state) dca \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w. run A w (initial A) \<and> \<not> infs (rejecting A) (trace A w (initial A))}"
< 
<   lemma language[intro]:
<     assumes "run A w (initial A)" "\<not> infs (rejecting A) (trace A w (initial A))"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "run A w (initial A)" "\<not> infs (rejecting A) (trace A w (initial A))"
<     using assms unfolding language_def by auto
< 
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def run_alt_def using sset_streams by auto
---
>   abbreviation successors where "successors \<equiv> dca.successors TYPE('label)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DCA/DGCA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DCA/DGCA.thy
4,6c4
< imports
<   "DCA"
<   "../../Transition_Systems/Transition_System_Degeneralization"
---
> imports "../Deterministic"
12c10
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
15,22c13,18
<   global_interpretation dgca: transition_system_initial_generalized
<     "succ A" "\<lambda> a p. a \<in> alphabet A" "\<lambda> p. p = initial A" "rejecting A"
<     for A
<     defines path = dgca.path and run = dgca.run and reachable = dgca.reachable and nodes = dgca.nodes and
<       enableds = dgca.enableds and paths = dgca.paths and runs = dgca.runs and
<       dexecute = dgca.dexecute and denabled = dgca.denabled and dinitial = dgca.dinitial and
<       drejecting = dgca.dcondition
<     by this
---
>   global_interpretation dgca: automaton dgca alphabet initial transition rejecting
>     defines path = dgca.path and run = dgca.run and reachable = dgca.reachable and nodes = dgca.nodes
>     by unfold_locales auto
>   global_interpretation dgca: automaton_run dgca alphabet initial transition rejecting "\<lambda> P w r p. cogen fins P (p ## r)"
>     defines language = dgca.language
>     by standard
27,89c23
< 
<   abbreviation successors :: "('label, 'state) dgca \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dgca.successors TYPE('label)"
< 
<   lemma path_alt_def: "path A w p \<longleftrightarrow> set w \<subseteq> alphabet A"
<   unfolding lists_iff_set[symmetric]
<   proof
<     show "w \<in> lists (alphabet A)" if "path A w p" using that by (induct arbitrary: p) (auto)
<     show "path A w p" if "w \<in> lists (alphabet A)" using that by (induct arbitrary: p) (auto)
<   qed
<   lemma run_alt_def: "run A w p \<longleftrightarrow> sset w \<subseteq> alphabet A"
<   unfolding streams_iff_sset[symmetric]
<   proof
<     show "w \<in> streams (alphabet A)" if "run A w p"
<       using that by (coinduction arbitrary: w p) (force elim: dgca.run.cases)
<     show "run A w p" if "w \<in> streams (alphabet A)"
<       using that by (coinduction arbitrary: w p) (force elim: streams.cases)
<   qed
< 
<   definition language :: "('label, 'state) dgca \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w. run A w (initial A) \<and> cogen fins (rejecting A) (trace A w (initial A))}"
< 
<   lemma language[intro]:
<     assumes "run A w (initial A)" "cogen fins (rejecting A) (trace A w (initial A))"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "run A w (initial A)" "cogen fins (rejecting A) (trace A w (initial A))"
<     using assms unfolding language_def by auto
< 
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def run_alt_def using sset_streams by auto
< 
<   definition degen :: "('label, 'state) dgca \<Rightarrow> ('label, 'state degen) dca" where
<     "degen A \<equiv> dca (alphabet A) (The (dinitial A)) (dexecute A) (drejecting A)"
< 
<   lemma degen_simps[simp]:
<     "dca.alphabet (degen A) = alphabet A"
<     "dca.initial (degen A) = (initial A, 0)"
<     "dca.succ (degen A) = dexecute A"
<     "dca.rejecting (degen A) = drejecting A"
<     unfolding degen_def dgca.dinitial_def by auto
< 
<   lemma degen_trace[simp]: "dca.trace (degen A) = dgca.degen.trace A" unfolding degen_simps by rule
<   lemma degen_run[simp]: "dca.run (degen A) = dgca.degen.run A"
<     unfolding DCA.run_def degen_simps dgca.denabled_def case_prod_beta' by rule
<   lemma degen_nodes[simp]: "DCA.nodes (degen A) = dgca.degen.nodes TYPE('label) A"
<     unfolding DCA.nodes_def degen_simps
<     unfolding dgca.denabled_def dgca.dinitial_def
<     unfolding prod_eq_iff case_prod_beta' prod.sel
<     by rule
< 
<   lemma degen_nodes_finite[iff]: "finite (DCA.nodes (degen A)) \<longleftrightarrow> finite (DGCA.nodes A)" by simp
<   lemma degen_nodes_card: "card (DCA.nodes (degen A)) \<le> max 1 (length (rejecting A)) * card (DGCA.nodes A)"
<     using dgca.degen_nodes_card by simp
< 
<   lemma degen_language[simp]: "DCA.language (degen A) = DGCA.language A"
<     unfolding DCA.language_def DGCA.language_def degen_simps
<     unfolding degen_trace degen_run
<     unfolding dgca.degen_run dgca.degen_infs cogen_def
<     unfolding ball_simps(10)
<     by rule
---
>   abbreviation successors where "successors \<equiv> dgca.successors TYPE('label)"
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata: Deterministic.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DFA/DFA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DFA/DFA.thy
4,7c4
< imports
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Deterministic"
10,13c7,11
<   record ('label, 'state) dfa =
<     succ :: "'label \<Rightarrow> 'state \<Rightarrow> 'state"
<     initial :: "'state"
<     accepting :: "'state set"
---
>   datatype ('label, 'state) dfa = dfa
>     (alphabet: "'label set")
>     (initial: "'state")
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
>     (accepting: "'state pred")
15,16c13
<   global_interpretation dfa: transition_system_initial "succ A" "top" "\<lambda> p. p = initial A"
<     for A
---
>   global_interpretation dfa: automaton dfa alphabet initial transition accepting
18c15,46
<     by this
---
>     by unfold_locales auto
>   global_interpretation dfa: automaton_path dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     defines language = dfa.language
>     by standard
> 
>   abbreviation target where "target \<equiv> dfa.target"
>   abbreviation states where "states \<equiv> dfa.states"
>   abbreviation trace where "trace \<equiv> dfa.trace"
>   abbreviation successors where "successors \<equiv> dfa.successors TYPE('label)"
> 
>   global_interpretation intersection: automaton_intersection_path
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     "\<lambda> c\<^sub>1 c\<^sub>2 (p, q). c\<^sub>1 p \<and> c\<^sub>2 q"
>     defines intersect = intersection.product
>     by (unfold_locales) (auto simp: zip_eq_Nil_iff)
> 
>   global_interpretation union: automaton_union_path
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     "\<lambda> c\<^sub>1 c\<^sub>2 (p, q). c\<^sub>1 p \<or> c\<^sub>2 q"
>     defines union = union.product
>     by (unfold_locales) (auto simp: zip_eq_Nil_iff)
> 
>   global_interpretation complement: automaton_complement_path
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     dfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     "\<lambda> c p. \<not> c p"
>     defines complement = complement.complement
>     by unfold_locales auto
20,73c48
<   abbreviation target :: "('label, 'state, 'more) dfa_scheme \<Rightarrow> 'label list \<Rightarrow> 'state \<Rightarrow> 'state" where
<     "target \<equiv> dfa.target TYPE('more)"
<   abbreviation states :: "('label, 'state, 'more) dfa_scheme \<Rightarrow> 'label list \<Rightarrow> 'state \<Rightarrow> 'state list" where
<     "states \<equiv> dfa.states TYPE('more)"
<   abbreviation trace :: "('label, 'state, 'more) dfa_scheme \<Rightarrow> 'label stream \<Rightarrow> 'state \<Rightarrow> 'state stream" where
<     "trace \<equiv> dfa.trace TYPE('more)"
< 
<   abbreviation successors :: "('label, 'state, 'more) dfa_scheme \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dfa.successors TYPE('label) TYPE('more)"
< 
<   definition language :: "('label, 'state) dfa \<Rightarrow> 'label list set" where
<     "language A \<equiv> {w. target A w (initial A) \<in> accepting A}"
< 
<   lemma language[intro]:
<     assumes "target A w (initial A) \<in> accepting A"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "target A w (initial A) \<in> accepting A"
<     using assms unfolding language_def by auto
< 
<   definition complement :: "('label, 'state) dfa \<Rightarrow> ('label, 'state) dfa" where
<     "complement A \<equiv> \<lparr> succ = succ A, initial = initial A, accepting = - accepting A \<rparr>"
< 
<   lemma complement_simps[simp]:
<     "succ (complement A) = succ A"
<     "initial (complement A) = initial A"
<     "accepting (complement A) = - accepting A"
<     unfolding complement_def by simp+
< 
<   lemma complement_language[simp]: "language (complement A) = - language A" by force
< 
<   definition product :: "('label, 'state\<^sub>1) dfa \<Rightarrow> ('label, 'state\<^sub>2) dfa \<Rightarrow>
<     ('label, 'state\<^sub>1 \<times> 'state\<^sub>2) dfa" where
<     "product A B \<equiv>
<     \<lparr>
<       succ = \<lambda> a (p\<^sub>1, p\<^sub>2). (succ A a p\<^sub>1, succ B a p\<^sub>2),
<       initial = (initial A, initial B),
<       accepting = accepting A \<times> accepting B
<     \<rparr>"
< 
<   lemma product_simps[simp]:
<     "succ (product A B) a (p\<^sub>1, p\<^sub>2) = (succ A a p\<^sub>1, succ B a p\<^sub>2)"
<     "initial (product A B) = (initial A, initial B)"
<     "accepting (product A B) = accepting A \<times> accepting B"
<     unfolding product_def by simp+
< 
<   lemma product_target[simp]: "target (product A B) r (p\<^sub>1, p\<^sub>2) = (target A r p\<^sub>1, target B r p\<^sub>2)"
<     by (induct r arbitrary: p\<^sub>1 p\<^sub>2) (auto)
< 
<   lemma product_language[simp]: "language (product A B) = language A \<inter> language B" by force
< 
< end
---
> end
\ No newline at end of file
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Combine.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Combine.thy
7,221c7,31
<   definition from_dba :: "('label, 'state) dba \<Rightarrow> ('label, 'state) dra" where
<     "from_dba A \<equiv> dra (dba.alphabet A) (dba.initial A) (dba.succ A) [(dba.accepting A, bot)]"
< 
<   lemma from_dba_language[simp]: "DRA.language (from_dba A) = DBA.language A"
<     unfolding DBA.language_def DRA.language_def from_dba_def DBA.run_def DRA.run_def by (auto 0 3)
< 
<   definition from_dca :: "('label, 'state) dca \<Rightarrow> ('label, 'state) dra" where
<     "from_dca A \<equiv> dra (dca.alphabet A) (dca.initial A) (dca.succ A) [(top, dca.rejecting A)]"
< 
<   lemma from_dca_language[simp]: "DRA.language (from_dca A) = DCA.language A"
<     unfolding DCA.language_def DRA.language_def from_dca_def DCA.run_def DRA.run_def by (auto 0 3)
< 
<   definition dbcrai :: "('label, 'state\<^sub>1) dba \<Rightarrow> ('label, 'state\<^sub>2) dca \<Rightarrow> ('label, 'state\<^sub>1 \<times> 'state\<^sub>2) dra" where
<     "dbcrai A B \<equiv> dra
<       (dba.alphabet A \<inter> dca.alphabet B)
<       (dba.initial A, dca.initial B)
<       (\<lambda> a (p, q). (dba.succ A a p, dca.succ B a q))
<       [(dba.accepting A \<circ> fst, dca.rejecting B \<circ> snd)]"
< 
<   lemma dbcrai_fst[iff]: "infs (P \<circ> fst) (dra.trace (dbcrai A B) w (p, q)) \<longleftrightarrow> infs P (dba.trace A w p)"
<   proof -
<     let ?t = "dra.trace (dbcrai A B) w (p, q)"
<     have "infs (P \<circ> fst) ?t \<longleftrightarrow> infs P (smap fst ?t)" by simp
<     also have "smap fst ?t = dba.trace A w p" unfolding dbcrai_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dbcrai_snd[iff]: "infs (P \<circ> snd) (dra.trace (dbcrai A B) w (p, q)) \<longleftrightarrow> infs P (dca.trace B w q)"
<   proof -
<     let ?t = "dra.trace (dbcrai A B) w (p, q)"
<     have "infs (P \<circ> snd) ?t \<longleftrightarrow> infs P (smap snd ?t)" by simp
<     also have "smap snd ?t = dca.trace B w q" unfolding dbcrai_def by (coinduction arbitrary: w p q) (auto)
<     finally show ?thesis by this
<   qed
<   lemma dbcrai_nodes_fst[intro]: "fst ` DRA.nodes (dbcrai A B) \<subseteq> DBA.nodes A"
<   proof (rule subsetI, erule imageE)
<     fix pq p
<     assume "pq \<in> DRA.nodes (dbcrai A B)" "p = fst pq"
<     then show "p \<in> DBA.nodes A" unfolding dbcrai_def by (induct arbitrary: p) (auto)
<   qed
<   lemma dbcrai_nodes_snd[intro]: "snd ` DRA.nodes (dbcrai A B) \<subseteq> DCA.nodes B"
<   proof (rule subsetI, erule imageE)
<     fix pq q
<     assume "pq \<in> DRA.nodes (dbcrai A B)" "q = snd pq"
<     then show "q \<in> DCA.nodes B" unfolding dbcrai_def by (induct arbitrary: q) (auto)
<   qed
< 
<   lemma dbcrai_nodes_finite[intro]:
<     assumes "finite (DBA.nodes A)" "finite (DCA.nodes B)"
<     shows "finite (DRA.nodes (dbcrai A B))"
<   proof (rule finite_subset)
<     show "DRA.nodes (dbcrai A B) \<subseteq> DBA.nodes A \<times> DCA.nodes B"
<       using dbcrai_nodes_fst dbcrai_nodes_snd unfolding image_subset_iff by force
<     show "finite (DBA.nodes A \<times> DCA.nodes B)" using assms by simp
<   qed
<   lemma dbcrai_nodes_card[intro]:
<     assumes "finite (DBA.nodes A)" "finite (DCA.nodes B)"
<     shows "card (DRA.nodes (dbcrai A B)) \<le> card (DBA.nodes A) * card (DCA.nodes B)"
<   proof -
<     have "card (DRA.nodes (dbcrai A B)) \<le> card (DBA.nodes A \<times> DCA.nodes B)"
<     proof (rule card_mono)
<       show "finite (DBA.nodes A \<times> DCA.nodes B)" using assms by simp
<       show "DRA.nodes (dbcrai A B) \<subseteq> DBA.nodes A \<times> DCA.nodes B"
<         using dbcrai_nodes_fst dbcrai_nodes_snd unfolding image_subset_iff by force
<     qed
<     also have "\<dots> = card (DBA.nodes A) * card (DCA.nodes B)" using card_cartesian_product by this
<     finally show ?thesis by this
<   qed
< 
<   lemma dbcrai_language[simp]: "DRA.language (dbcrai A B) = DBA.language A \<inter> DCA.language B"
<   proof -
<     have 1: "dra.alphabet (dbcrai A B) = dba.alphabet A \<inter> dca.alphabet B" unfolding dbcrai_def by simp
<     have 2: "dra.initial (dbcrai A B) = (dba.initial A, dca.initial B)" unfolding dbcrai_def by simp
<     have 3: "dra.accepting (dbcrai A B) = [(dba.accepting A \<circ> fst, dca.rejecting B \<circ> snd)]"
<       unfolding dbcrai_def by simp
<     have 4: "cogen rabin (dra.accepting (dbcrai A B)) (DRA.trace (dbcrai A B) w (p, q)) \<longleftrightarrow>
<       infs (dba.accepting A) (DBA.trace A w p) \<and> fins (rejecting B) (DCA.trace B w q)" for w p q
<       unfolding cogen_def rabin_def 3 by simp
<     show ?thesis
<       unfolding DRA.language_def DBA.language_def DCA.language_def
<       unfolding DRA.run_alt_def DBA.run_alt_def DCA.run_alt_def
<       unfolding 1 2 4 by auto
<   qed
< 
<   abbreviation (input) "get k pp \<equiv> pp ! k"
< 
<   definition draul :: "('label, 'state) dra list \<Rightarrow> ('label, 'state list) dra" where
<     "draul AA \<equiv> dra
<       (UNION (set AA) dra.alphabet)
<       (map dra.initial AA)
<       (\<lambda> a pp. map2 (\<lambda> A p. dra.succ A a p) AA pp)
<       (do { k \<leftarrow> [0 ..< length AA]; (f, g) \<leftarrow> dra.accepting (AA ! k); [(f \<circ> get k, g \<circ> get k)] })"
< 
<   lemma draul_get:
<     assumes "length pp = length AA" "k < length AA"
<     shows "infs (P \<circ> get k) (dra.trace (draul AA) w pp) \<longleftrightarrow>
<       infs P (dra.trace (AA ! k) w (pp ! k))"
<   proof -
<     have "infs (P \<circ> get k) (dra.trace (draul AA) w pp) \<longleftrightarrow>
<       infs P (smap (get k) (dra.trace (draul AA) w pp))" by simp
<     also have "smap (get k) (dra.trace (draul AA) w pp) = dra.trace (AA ! k) w (pp ! k)"
<       using assms unfolding draul_def by (coinduction arbitrary: w pp) (force)
<     finally show ?thesis by this
<   qed
<   lemma draul_nodes_length:
<     assumes "pp \<in> DRA.nodes (draul AA)"
<     shows "length pp = length AA"
<     using assms unfolding draul_def by induct auto
<   lemma draul_nodes[intro]:
<     assumes "INTER (set AA) dra.alphabet = UNION (set AA) dra.alphabet"
<     assumes "pp \<in> DRA.nodes (draul AA)" "k < length pp"
<     shows "pp ! k \<in> DRA.nodes (AA ! k)"
<     using assms(2, 3, 1) unfolding draul_def by induct force+
< 
<   lemma draul_nodes_finite[intro]:
<     assumes "INTER (set AA) dra.alphabet = UNION (set AA) dra.alphabet"
<     assumes "list_all (finite \<circ> DRA.nodes) AA"
<     shows "finite (DRA.nodes (draul AA))"
<   proof (rule finite_subset)
<     show "DRA.nodes (draul AA) \<subseteq> listset (map DRA.nodes AA)"
<       using assms(1) by (force simp: listset_member list_all2_conv_all_nth draul_nodes_length)
<     have "finite (listset (map DRA.nodes AA)) \<longleftrightarrow> list_all finite (map DRA.nodes AA)"
<       by (rule listset_finite) (auto simp: list_all_iff)
<     then show "finite (listset (map DRA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<   qed
<   lemma draul_nodes_card:
<     assumes "INTER (set AA) dra.alphabet = UNION (set AA) dra.alphabet"
<     assumes "list_all (finite \<circ> DRA.nodes) AA"
<     shows "card (DRA.nodes (draul AA)) \<le> prod_list (map (card \<circ> DRA.nodes) AA)"
<   proof -
<     have "card (DRA.nodes (draul AA)) \<le> card (listset (map DRA.nodes AA))"
<     proof (rule card_mono)
<       have "finite (listset (map DRA.nodes AA)) \<longleftrightarrow> list_all finite (map DRA.nodes AA)"
<         by (rule listset_finite) (auto simp: list_all_iff)
<       then show "finite (listset (map DRA.nodes AA))" using assms(2) by (simp add: list.pred_map)
<       show "DRA.nodes (draul AA) \<subseteq> listset (map DRA.nodes AA)"
<         using assms(1) by (force simp: listset_member list_all2_conv_all_nth draul_nodes_length)
<     qed
<     also have "\<dots> = prod_list (map (card \<circ> DRA.nodes) AA)" by simp
<     finally show ?thesis by this
<   qed
< 
<   lemma draul_language[simp]:
<     assumes "INTER (set AA) dra.alphabet = UNION (set AA) dra.alphabet"
<     shows "DRA.language (draul AA) = UNION (set AA) DRA.language"
<   proof safe
<     fix w
<     assume 1: "w \<in> DRA.language (draul AA)"
<     obtain 2:
<       "dra.run (draul AA) w (dra.initial (draul AA))"
<       "cogen rabin (dra.accepting (draul AA)) (dra.trace (draul AA) w (dra.initial (draul AA)))"
<       using 1 by rule
<     obtain I F where 3:
<       "(I, F) \<in> set (dra.accepting (draul AA))"
<       "infs I (dra.trace (draul AA) w (dra.initial (draul AA)))"
<       "fins F (dra.trace (draul AA) w (dra.initial (draul AA)))"
<       using 2(2) by blast
<     obtain k P Q where 4:
<       "k < length AA" "I = P \<circ> get k" "F = Q \<circ> get k" "(P, Q) \<in> set (dra.accepting (AA ! k))"
<       using 3(1) unfolding draul_def List.bind_def by (auto simp: comp_def)
<     show "w \<in> UNION (set AA) DRA.language"
<     proof (intro UN_I DRA.language cogen rabin)
<       show "AA ! k \<in> set AA" using 4(1) by auto
<       show "DRA.run (AA ! k) w (dra.initial (AA ! k))"
<         using assms 2(1) 4(1) unfolding DRA.run_alt_def draul_def by force
<       show "(P, Q) \<in> set (dra.accepting (AA ! k))" using 4(4) by this
<       show "(P, Q) = (P, Q)" by rule
<       have "True \<longleftrightarrow> infs (P \<circ> get k) (dra.trace (draul AA) w (map dra.initial AA))"
<         using 3(2) unfolding draul_def 4(2) by simp
<       also have "\<dots> \<longleftrightarrow> infs P (dra.trace (AA ! k) w (map dra.initial AA ! k))"
<         using 4(1) by (force intro!: draul_get)
<       also have "map dra.initial AA ! k = dra.initial (AA ! k)" using 4(1) by simp
<       finally show "infs P (dra.trace (AA ! k) w (dra.initial (AA ! k)))" by simp
<       have "False \<longleftrightarrow> infs (Q \<circ> get k) (dra.trace (draul AA) w (map dra.initial AA))"
<         using 3(3) unfolding draul_def 4(3) by simp
<       also have "\<dots> \<longleftrightarrow> infs Q (dra.trace (AA ! k) w (map dra.initial AA ! k))"
<         using 4(1) by (force intro!: draul_get)
<       also have "map dra.initial AA ! k = dra.initial (AA ! k)" using 4(1) by simp
<       finally show "fins Q (dra.trace (AA ! k) w (dra.initial (AA ! k)))" by simp
<     qed
<   next
<     fix A w
<     assume 1: "A \<in> set AA" "w \<in> DRA.language A"
<     obtain 2:
<       "dra.run A w (dra.initial A)"
<       "cogen rabin (dra.accepting A) (dra.trace A w (dra.initial A))"
<       using 1(2) by rule
<     obtain I F where 3:
<       "(I, F) \<in> set (dra.accepting A)"
<       "infs I (dra.trace A w (dra.initial A))"
<       "fins F (dra.trace A w (dra.initial A))"
<       using 2(2) by blast
<     obtain k where 4: "A = AA ! k" "k < length AA" using 1(1) unfolding in_set_conv_nth by auto
<     show "w \<in> DRA.language (draul AA)"
<     proof (intro DRA.language cogen rabin)
<       show "dra.run (draul AA) w (dra.initial (draul AA))"
<         using 1(1) 2(1) unfolding DRA.run_alt_def draul_def by auto
<       show "(I \<circ> get k, F \<circ> get k) \<in> set (dra.accepting (draul AA))"
<         unfolding draul_def List.bind_def using 3(1) 4 by (force simp: comp_def)
<       show "(I \<circ> get k, F \<circ> get k) = (I \<circ> get k, F \<circ> get k)" by rule
<       have "infs (I \<circ> get k) (dra.trace (draul AA) w (dra.initial (draul AA))) \<longleftrightarrow>
<         infs (I \<circ> get k) (dra.trace (draul AA) w (map dra.initial AA))"
<         unfolding draul_def by simp
<       also have "\<dots> \<longleftrightarrow> infs I (dra.trace (AA ! k) w (map dra.initial AA ! k))"
<         using 4(2) by (force intro!: draul_get)
<       also have "\<dots> \<longleftrightarrow> True" using 3(2) 4 by simp
<       finally show "infs (I \<circ> get k) (dra.trace (draul AA) w (dra.initial (draul AA)))" by simp
<       have "infs (F \<circ> get k) (dra.trace (draul AA) w (dra.initial (draul AA))) \<longleftrightarrow>
<         infs (F \<circ> get k) (dra.trace (draul AA) w (map dra.initial AA))"
<         unfolding draul_def by simp
<       also have "\<dots> \<longleftrightarrow> infs F (dra.trace (AA ! k) w (map dra.initial AA ! k))"
<         using 4(2) by (force intro!: draul_get)
<       also have "\<dots> \<longleftrightarrow> False" using 3(3) 4 by simp
<       finally show "fins (F \<circ> get k) (dra.trace (draul AA) w (dra.initial (draul AA)))" by simp
<     qed
<   qed
---
>   global_interpretation intersection_bc: automaton_intersection_run
>     dba.dba dba.alphabet dba.initial dba.transition dba.accepting "\<lambda> P w r p. infs P (p ## r)"
>     dca.dca dca.alphabet dca.initial dca.transition dca.rejecting "\<lambda> P w r p. fins P (p ## r)"
>     dra.dra dra.alphabet dra.initial dra.transition dra.condition "\<lambda> P w r p. cogen rabin P (p ## r)"
>     "\<lambda> c\<^sub>1 c\<^sub>2. [(c\<^sub>1 \<circ> fst, c\<^sub>2 \<circ> snd)]"
>     defines intersect_bc = intersection_bc.product
>     by (unfold_locales) (simp add: cogen_def rabin_def)
> 
>   (* TODO: why are only the constants of the first interpretation folded back correctly? *)
>   lemmas intersect_bc_language[simp] = intersection_bc.product_language[folded DCA.language_def DRA.language_def]
>   lemmas intersect_bc_nodes_finite = intersection_bc.product_nodes_finite[folded DCA.nodes_def DRA.nodes_def]
>   lemmas intersect_bc_nodes_card = intersection_bc.product_nodes_card[folded DCA.nodes_def DRA.nodes_def]
> 
>   (* TODO: are there some statements about the rabin constant hidden in here?
>     same for gen/cogen, also in other combinations, shouldn't have to unfold those *)
>   global_interpretation union_list: automaton_union_list_run
>     dra.dra dra.alphabet dra.initial dra.transition dra.condition "\<lambda> P w r p. cogen rabin P (p ## r)"
>     dra.dra dra.alphabet dra.initial dra.transition dra.condition "\<lambda> P w r p. cogen rabin P (p ## r)"
>     "\<lambda> cs. do { k \<leftarrow> [0 ..< length cs]; (f, g) \<leftarrow> cs ! k; [(\<lambda> pp. f (pp ! k), \<lambda> pp. g (pp ! k))] }"
>     defines union_list = union_list.product
>     by (unfold_locales) (auto simp: cogen_def rabin_def comp_def split_beta)
> 
>   lemmas union_list_language = union_list.product_language
>   lemmas union_list_nodes_finite = union_list.product_nodes_finite
>   lemmas union_list_nodes_card = union_list.product_nodes_card
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Explicit.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Explicit.thy
10,11c10,11
<     (transe: "('state \<times> 'label \<times> 'state) set")
<     (acceptinge: "('state set \<times> 'state set) list")
---
>     (transitione: "('state \<times> 'label \<times> 'state) set")
>     (conditione: "('state set \<times> 'state set) list")
17,18c17,18
<       (transe A\<^sub>1, transe A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel \<and>
<       (acceptinge A\<^sub>1, acceptinge A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> set_rel \<times>\<^sub>r \<langle>S\<rangle> set_rel\<rangle> list_rel}"
---
>       (transitione A\<^sub>1, transitione A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel \<and>
>       (conditione A\<^sub>1, conditione A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> set_rel \<times>\<^sub>r \<langle>S\<rangle> set_rel\<rangle> list_rel}"
25,26c25,26
<     "(transe, transe) \<in> \<langle>L, S\<rangle> drae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel"
<     "(acceptinge, acceptinge) \<in> \<langle>L, S\<rangle> drae_rel \<rightarrow> \<langle>\<langle>S\<rangle> set_rel \<times>\<^sub>r \<langle>S\<rangle> set_rel\<rangle> list_rel"
---
>     "(transitione, transitione) \<in> \<langle>L, S\<rangle> drae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel"
>     "(conditione, conditione) \<in> \<langle>L, S\<rangle> drae_rel \<rightarrow> \<langle>\<langle>S\<rangle> set_rel \<times>\<^sub>r \<langle>S\<rangle> set_rel\<rangle> list_rel"
37,39c37,39
<       "(transe A, c) \<in> \<langle>S\<^sub>1 \<times>\<^sub>r L\<^sub>1 \<times>\<^sub>r S\<^sub>1\<rangle> set_rel" "(c, transe B) \<in> \<langle>S\<^sub>2 \<times>\<^sub>r L\<^sub>2 \<times>\<^sub>r S\<^sub>2\<rangle> set_rel"
<       "(acceptinge A, d) \<in> \<langle>\<langle>S\<^sub>1\<rangle> set_rel \<times>\<^sub>r \<langle>S\<^sub>1\<rangle> set_rel\<rangle> list_rel"
<       "(d, acceptinge B) \<in> \<langle>\<langle>S\<^sub>2\<rangle> set_rel \<times>\<^sub>r \<langle>S\<^sub>2\<rangle> set_rel\<rangle> list_rel"
---
>       "(transitione A, c) \<in> \<langle>S\<^sub>1 \<times>\<^sub>r L\<^sub>1 \<times>\<^sub>r S\<^sub>1\<rangle> set_rel" "(c, transitione B) \<in> \<langle>S\<^sub>2 \<times>\<^sub>r L\<^sub>2 \<times>\<^sub>r S\<^sub>2\<rangle> set_rel"
>       "(conditione A, d) \<in> \<langle>\<langle>S\<^sub>1\<rangle> set_rel \<times>\<^sub>r \<langle>S\<^sub>1\<rangle> set_rel\<rangle> list_rel"
>       "(d, conditione B) \<in> \<langle>\<langle>S\<^sub>2\<rangle> set_rel \<times>\<^sub>r \<langle>S\<^sub>2\<rangle> set_rel\<rangle> list_rel"
65,66c65,66
<       "transe ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_drae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>S, \<langle>L, S\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_set"
<       "acceptinge ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_drae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>\<langle>S\<rangle>\<^sub>i i_set, \<langle>S\<rangle>\<^sub>i i_set\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_list"
---
>       "transitione ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_drae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>S, \<langle>L, S\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_set"
>       "conditione ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_drae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>\<langle>S\<rangle>\<^sub>i i_set, \<langle>S\<rangle>\<^sub>i i_set\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_list"
74,75c74,75
<     (transei: "('state \<times> 'label \<times> 'state) list")
<     (acceptingei: "('state list \<times> 'state list) list")
---
>     (transitionei: "('state \<times> 'label \<times> 'state) list")
>     (conditionei: "('state list \<times> 'state list) list")
81,82c81,82
<       (transei A\<^sub>1, transei A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel \<and>
<       (acceptingei A\<^sub>1, acceptingei A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> list_rel \<times>\<^sub>r \<langle>S\<rangle> list_rel\<rangle> list_rel}"
---
>       (transitionei A\<^sub>1, transitionei A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel \<and>
>       (conditionei A\<^sub>1, conditionei A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> list_rel \<times>\<^sub>r \<langle>S\<rangle> list_rel\<rangle> list_rel}"
89,90c89,90
<     "(transei, transei) \<in> \<langle>L, S\<rangle> draei_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel"
<     "(acceptingei, acceptingei) \<in> \<langle>L, S\<rangle> draei_rel \<rightarrow> \<langle>\<langle>S\<rangle> list_rel \<times>\<^sub>r \<langle>S\<rangle> list_rel\<rangle> list_rel"
---
>     "(transitionei, transitionei) \<in> \<langle>L, S\<rangle> draei_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel"
>     "(conditionei, conditionei) \<in> \<langle>L, S\<rangle> draei_rel \<rightarrow> \<langle>\<langle>S\<rangle> list_rel \<times>\<^sub>r \<langle>S\<rangle> list_rel\<rangle> list_rel"
97,98c97,98
<       (transei A\<^sub>1, transe A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel \<and>
<       (acceptingei A\<^sub>1, acceptinge A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> list_set_rel \<times>\<^sub>r \<langle>S\<rangle> list_set_rel\<rangle> list_rel}"
---
>       (transitionei A\<^sub>1, transitione A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel \<and>
>       (conditionei A\<^sub>1, conditione A\<^sub>2) \<in> \<langle>\<langle>S\<rangle> list_set_rel \<times>\<^sub>r \<langle>S\<rangle> list_set_rel\<rangle> list_rel}"
107,108c107,108
<     "(transei, transe) \<in> \<langle>L, S\<rangle> draei_drae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel"
<     "(acceptingei, acceptinge) \<in> \<langle>L, S\<rangle> draei_drae_rel \<rightarrow> \<langle>\<langle>S\<rangle> list_set_rel \<times>\<^sub>r \<langle>S\<rangle> list_set_rel\<rangle> list_rel"
---
>     "(transitionei, transitione) \<in> \<langle>L, S\<rangle> draei_drae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel"
>     "(conditionei, conditione) \<in> \<langle>L, S\<rangle> draei_drae_rel \<rightarrow> \<langle>\<langle>S\<rangle> list_set_rel \<times>\<^sub>r \<langle>S\<rangle> list_set_rel\<rangle> list_rel"
113c113
<       (set (transei A)) (map (map_prod set set) (acceptingei A))"
---
>       (set (transitionei A)) (map (map_prod set set) (conditionei A))"
120c120
<       (set (transei Ai)) (map (map_prod set set) (acceptingei Ai))" unfolding draei_drae_def by rule
---
>       (set (transitionei Ai)) (map (map_prod set set) (conditionei Ai))" unfolding draei_drae_def by rule
122c122
<       (id (transe A)) (map (map_prod id id) (acceptinge A))" by simp
---
>       (id (transitione A)) (map (map_prod id id) (conditione A))" by simp
140,141c140,141
<     (transitions (alphabet A) (nodes A) (succ A))
<     (map (\<lambda> (P, Q). (Set.filter P (nodes A), Set.filter Q (nodes A))) (accepting A))"
---
>     (transitions (alphabet A) (nodes A) (transition A))
>     (map (\<lambda> (P, Q). (Set.filter P (nodes A), Set.filter Q (nodes A))) (condition A))"
143c143
<     (succs (transe A)) (map (\<lambda> (I, F). (\<lambda> p. p \<in> I, \<lambda> p. p \<in> F)) (acceptinge A))"
---
>     (succs (transitione A)) (map (\<lambda> (I, F). (\<lambda> p. p \<in> I, \<lambda> p. p \<in> F)) (conditione A))"
151c151
<     assumes "wft (Range L) (Range S) (transe B)"
---
>     assumes "wft (Range L) (Range S) (transitione B)"
155c155
<     have 1: "(wft (Domain L) (Domain S) (transe A), wft (Range L) (Range S) (transe B)) \<in> bool_rel"
---
>     have 1: "(wft (Domain L) (Domain S) (transitione A), wft (Range L) (Range S) (transitione B)) \<in> bool_rel"
157c157
<     have 2: "wft (Domain L) (Domain S) (transe A)" using assms(3) 1 by simp
---
>     have 2: "wft (Domain L) (Domain S) (transitione A)" using assms(3) 1 by simp
188,189c188,189
<       ((succs \<circ> transitions (alphabet A) (nodes A)) (succ A))
<       (map (\<lambda> (P, Q). (\<lambda> p. p \<in> Set.filter P (nodes A), \<lambda> p. p \<in> Set.filter Q (nodes A))) (accepting A))"
---
>       ((succs \<circ> transitions (alphabet A) (nodes A)) (transition A))
>       (map (\<lambda> (P, Q). (\<lambda> p. p \<in> Set.filter P (nodes A), \<lambda> p. p \<in> Set.filter Q (nodes A))) (condition A))"
191c191
<     also have "(\<dots>, dra (alphabet A) (initial A) (id (succ A)) (map id (accepting A))) \<in>
---
>     also have "(\<dots>, dra (alphabet A) (initial A) (id (transition A)) (map id (condition A))) \<in>
193c193
<     also have "dra (alphabet A) (initial A) (id (succ A)) (map id (accepting A)) = id A" by simp
---
>     also have "dra (alphabet A) (initial A) (id (transition A)) (map id (condition A)) = id A" by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Implement.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Implement.thy
12,13c12,13
<     (succi: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
<     (acceptingi: "'state rabin gen")
---
>     (transitioni: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
>     (conditioni: "'state rabin gen")
20,21c20,21
<       (succi A\<^sub>1, succi A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
<       (acceptingi A\<^sub>1, acceptingi A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
---
>       (transitioni A\<^sub>1, transitioni A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
>       (conditioni A\<^sub>1, conditioni A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
28,29c28,29
<     "(succi, succi) \<in> \<langle>L, S\<rangle> drai_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
<     "(acceptingi, acceptingi) \<in> \<langle>L, S\<rangle> drai_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
---
>     "(transitioni, transitioni) \<in> \<langle>L, S\<rangle> drai_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
>     "(conditioni, conditioni) \<in> \<langle>L, S\<rangle> drai_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
37,38c37,38
<       (succi A\<^sub>1, succ A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
<       (acceptingi A\<^sub>1, accepting A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
---
>       (transitioni A\<^sub>1, transition A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
>       (conditioni A\<^sub>1, condition A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
45,46c45,46
<     "(succi, succ) \<in> \<langle>L, S\<rangle> drai_dra_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
<     "(acceptingi, accepting) \<in> \<langle>L, S\<rangle> drai_dra_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
---
>     "(transitioni, transition) \<in> \<langle>L, S\<rangle> drai_dra_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
>     "(conditioni, condition) \<in> \<langle>L, S\<rangle> drai_dra_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
50c50
<     "drai_dra A \<equiv> dra (set (alphabeti A)) (initiali A) (succi A) (acceptingi A)"
---
>     "drai_dra A \<equiv> dra (set (alphabeti A)) (initiali A) (transitioni A) (conditioni A)"
58c58
<     have 2: "drai_dra Ai = dra (set (alphabeti Ai)) (initiali Ai) (succi Ai) (acceptingi Ai)"
---
>     have 2: "drai_dra Ai = dra (set (alphabeti Ai)) (initiali Ai) (transitioni Ai) (conditioni Ai)"
60c60
<     have 3: "id A = dra (id (alphabet A)) (initial A) (succ A) (accepting A)" by simp
---
>     have 3: "id A = dra (id (alphabet A)) (initial A) (transition A) (condition A)" by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Nodes.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Nodes.thy
28c28
<       ((\<lambda> a. succ A a p ::: S) ` alphabet A ::: \<langle>S\<rangle> ahs_rel bhc)), g_V0 = {initial A} \<rparr>"
---
>       ((\<lambda> a. transition A a p ::: S) ` alphabet A ::: \<langle>S\<rangle> ahs_rel bhc)), g_V0 = {initial A} \<rparr>"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Refine.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Refine.thy
15,16c15,16
<       (succ A\<^sub>1, succ A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
<       (accepting A\<^sub>1, accepting A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
---
>       (transition A\<^sub>1, transition A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> S \<and>
>       (condition A\<^sub>1, condition A\<^sub>2) \<in> \<langle>rabin_rel S\<rangle> list_rel}"
23,24c23,24
<     "(succ, succ) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
<     "(accepting, accepting) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
---
>     "(transition, transition) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> L \<rightarrow> S \<rightarrow> S"
>     "(condition, condition) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> \<langle>rabin_rel S\<rangle> list_rel"
32,34c32,34
<     have "(accepting A, accepting B) \<in> \<langle>rabin_rel S\<^sub>1\<rangle> list_rel" by parametricity
<     also have "(accepting B, accepting C) \<in> \<langle>rabin_rel S\<^sub>2\<rangle> list_rel" by parametricity
<     finally have 1: "(accepting A, accepting C) \<in> \<langle>rabin_rel S\<^sub>1 O rabin_rel S\<^sub>2\<rangle> list_rel" by simp
---
>     have "(condition A, condition B) \<in> \<langle>rabin_rel S\<^sub>1\<rangle> list_rel" by parametricity
>     also have "(condition B, condition C) \<in> \<langle>rabin_rel S\<^sub>2\<rangle> list_rel" by parametricity
>     finally have 1: "(condition A, condition C) \<in> \<langle>rabin_rel S\<^sub>1 O rabin_rel S\<^sub>2\<rangle> list_rel" by simp
36,39c36,39
<     have 3: "(accepting A, accepting C) \<in> \<langle>rabin_rel (S\<^sub>1 O S\<^sub>2)\<rangle> list_rel" using 1 2 list_rel_mono by blast
<     have "(succ A, succ B) \<in> L\<^sub>1 \<rightarrow> S\<^sub>1 \<rightarrow> S\<^sub>1" by parametricity
<     also have "(succ B, succ C) \<in> L\<^sub>2 \<rightarrow> S\<^sub>2 \<rightarrow> S\<^sub>2" by parametricity
<     finally have 4: "(succ A, succ C) \<in> L\<^sub>1 O L\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2" by this
---
>     have 3: "(condition A, condition C) \<in> \<langle>rabin_rel (S\<^sub>1 O S\<^sub>2)\<rangle> list_rel" using 1 2 list_rel_mono by blast
>     have "(transition A, transition B) \<in> L\<^sub>1 \<rightarrow> S\<^sub>1 \<rightarrow> S\<^sub>1" by parametricity
>     also have "(transition B, transition C) \<in> L\<^sub>2 \<rightarrow> S\<^sub>2 \<rightarrow> S\<^sub>2" by parametricity
>     finally have 4: "(transition A, transition C) \<in> L\<^sub>1 O L\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2" by this
59,64c59,64
<   lemma enableds_param[param]: "(enableds, enableds) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>L\<rangle> set_rel"
<     using dra_param(2, 4) unfolding dra.enableds_def fun_rel_def set_rel_def by fastforce
<   lemma paths_param[param]: "(paths, paths) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L\<rangle> list_rel\<rangle> set_rel"
<     unfolding paths_def by (intro fun_relI paths_param, fold enableds_def) (parametricity+)
<   lemma runs_param[param]: "(runs, runs) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L\<rangle> stream_rel\<rangle> set_rel"
<     unfolding runs_def by (intro fun_relI runs_param, fold enableds_def) (parametricity+)
---
>   lemma enableds_param[param]: "(dra.enableds, dra.enableds) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>L\<rangle> set_rel"
>     unfolding dra.enableds_def Collect_mem_eq by parametricity
>   lemma paths_param[param]: "(dra.paths, dra.paths) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L\<rangle> list_rel\<rangle> set_rel"
>     using enableds_param[param_fo] by parametricity
>   lemma runs_param[param]: "(dra.runs, dra.runs) \<in> \<langle>L, S\<rangle> dra_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L\<rangle> stream_rel\<rangle> set_rel"
>     using enableds_param[param_fo] by parametricity
68c68
<     have 1: "reachable A p = (\<lambda> w. target A w p) ` paths A p" for A :: "('label, 'state) dra" and p
---
>     have 1: "reachable A p = (\<lambda> w. target A w p) ` dra.paths A p" for A :: "('label, 'state) dra" and p
70c70
<     show ?thesis unfolding 1 by parametricity
---
>     show ?thesis unfolding 1 using enableds_param[param_fo] by parametricity
81,82c81,82
<     have 1: "language A = (\<Union> w \<in> runs A (initial A).
<       if cogen rabin (accepting A) (trace A w (initial A)) then {w} else {})"
---
>     have 1: "language A = (\<Union> w \<in> dra.runs A (initial A).
>       if cogen rabin (condition A) (initial A ## trace A w (initial A)) then {w} else {})"
84,85c84,85
<       unfolding language_def dra.runs_def image_def by auto
<     show ?thesis unfolding 1 by parametricity
---
>       unfolding dra.language_def dra.runs_def by auto
>     show ?thesis unfolding 1 using enableds_param[param_fo] by parametricity
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA.thy
4,9c4
< imports
<   "../../Basic/Sequence_Zip"
<   "../../Basic/Acceptance"
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Deterministic"
15,16c10,11
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
<     (accepting: "'state rabin gen")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state")
>     (condition: "'state rabin gen")
18,23c13,18
<   global_interpretation dra: transition_system_initial
<     "succ A" "\<lambda> a p. a \<in> alphabet A" "\<lambda> p. p = initial A"
<     for A
<     defines path = dra.path and run = dra.run and reachable = dra.reachable and nodes = dra.nodes and
<       enableds = dra.enableds and paths = dra.paths and runs = dra.runs
<     by this
---
>   global_interpretation dra: automaton dra alphabet initial transition condition
>     defines path = dra.path and run = dra.run and reachable = dra.reachable and nodes = dra.nodes
>     by unfold_locales auto
>   global_interpretation dra: automaton_run dra alphabet initial transition condition "\<lambda> P w r p. cogen rabin P (p ## r)"
>     defines language = dra.language
>     by standard
28,60c23
< 
<   abbreviation successors :: "('label, 'state) dra \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> dra.successors TYPE('label)"
< 
<   lemma path_alt_def: "path A w p \<longleftrightarrow> set w \<subseteq> alphabet A"
<   unfolding lists_iff_set[symmetric]
<   proof
<     show "w \<in> lists (alphabet A)" if "path A w p" using that by (induct arbitrary: p) (auto)
<     show "path A w p" if "w \<in> lists (alphabet A)" using that by (induct arbitrary: p) (auto)
<   qed
<   lemma run_alt_def: "run A w p \<longleftrightarrow> sset w \<subseteq> alphabet A"
<   unfolding streams_iff_sset[symmetric]
<   proof
<     show "w \<in> streams (alphabet A)" if "run A w p"
<       using that by (coinduction arbitrary: w p) (force elim: dra.run.cases)
<     show "run A w p" if "w \<in> streams (alphabet A)"
<       using that by (coinduction arbitrary: w p) (force elim: streams.cases)
<   qed
< 
<   definition language :: "('label, 'state) dra \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w. run A w (initial A) \<and> cogen rabin (accepting A) (trace A w (initial A))}"
< 
<   lemma language[intro]:
<     assumes "run A w (initial A)" "cogen rabin (accepting A) (trace A w (initial A))"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains "run A w (initial A)" "cogen rabin (accepting A) (trace A w (initial A))"
<     using assms unfolding language_def by auto
< 
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def run_alt_def using sset_streams by auto
---
>   abbreviation successors where "successors \<equiv> dra.successors TYPE('label)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Translate.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Translate.thy
17c17
<     ((\<lambda> (p, a, q). (f p, a, f q)) ` transe A) (map (map_prod (image f) (image f)) (acceptinge A))"
---
>     ((\<lambda> (p, a, q). (f p, a, f q)) ` transitione A) (map (map_prod (image f) (image f)) (conditione A))"
25,26c25,26
<     (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p})
<     (map (\<lambda> (P, Q). (f ` {p \<in> nodes A. P p}, f ` {p \<in> nodes A. Q p})) (accepting A))"
---
>     (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p})
>     (map (\<lambda> (P, Q). (f ` {p \<in> nodes A. P p}, f ` {p \<in> nodes A. Q p})) (condition A))"
32c32
<     "trans_spec A f \<equiv> \<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}"
---
>     "trans_spec A f \<equiv> \<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}"
48c48
<     assumes "N = nodes A" "L = alphabet A" "S = succ A"
---
>     assumes "N = nodes A" "L = alphabet A" "S = transition A"
53,55c53,55
<     show "(\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}) =
<       (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p})" by rule
<     show "(\<Union> p \<in> {}. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}) = {}" by simp
---
>     show "(\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}) =
>       (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p})" by rule
>     show "(\<Union> p \<in> {}. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}) = {}" by simp
59,64c59,64
<     show "(\<Union> a \<in> {}. f ` {x} \<times> {a} \<times> f ` {succ A a x}) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}) =
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p})"
<       "(\<Union> a \<in> alphabet A. f ` {x} \<times> {a} \<times> f ` {succ A a x}) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}) =
<       (\<Union> p \<in> insert x T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p})" by auto
---
>     show "(\<Union> a \<in> {}. f ` {x} \<times> {a} \<times> f ` {transition A a x}) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}) =
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p})"
>       "(\<Union> a \<in> alphabet A. f ` {x} \<times> {a} \<times> f ` {transition A a x}) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}) =
>       (\<Union> p \<in> insert x T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p})" by auto
67,68c67,68
<     show "(f x, xa, f (succ A xa x)) \<notin> (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` {succ A a x}) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p})"
---
>     show "(f x, xa, f (transition A xa x)) \<notin> (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` {transition A a x}) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p})"
70,73c70,73
<     show "(\<Union> a \<in> insert xa Ta. f ` {x} \<times> {a} \<times> f ` {succ A a x}) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}) =
<       insert (f x, xa, f (succ A xa x)) ((\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` {succ A a x}) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {succ A a p}))"
---
>     show "(\<Union> a \<in> insert xa Ta. f ` {x} \<times> {a} \<times> f ` {transition A a x}) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}) =
>       insert (f x, xa, f (transition A xa x)) ((\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` {transition A a x}) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` {transition A a p}))"
93,94c93,94
<         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. f (succ A a p) \<noteq> None);
<         T \<leftarrow> trans_algo N (alphabet A) (succ A) (\<lambda> x. the (f x));
---
>         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. f (transition A a p) \<noteq> None);
>         T \<leftarrow> trans_algo N (alphabet A) (transition A) (\<lambda> x. the (f x));
96c96
<           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> N. P p}, (\<lambda> x. the (f x)) ` {p \<in> N. Q p})) (accepting A)))
---
>           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> N. P p}, (\<lambda> x. the (f x)) ` {p \<in> N. Q p})) (condition A)))
121,122c121,122
<         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. f (succ A a p) \<noteq> None);
<         T \<leftarrow> trans_algo N (alphabet A) (succ A) (\<lambda> x. the (f x));
---
>         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. f (transition A a p) \<noteq> None);
>         T \<leftarrow> trans_algo N (alphabet A) (transition A) (\<lambda> x. the (f x));
124c124
<           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> N. P p}, (\<lambda> x. the (f x)) ` {p \<in> N. Q p})) (accepting A)))
---
>           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> N. P p}, (\<lambda> x. the (f x)) ` {p \<in> N. Q p})) (condition A)))
129c129
<           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> nodes A. P p}, (\<lambda> x. the (f x)) ` {p \<in> nodes A. Q p})) (accepting A)))
---
>           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> nodes A. P p}, (\<lambda> x. the (f x)) ` {p \<in> nodes A. Q p})) (condition A)))
137c137
<           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> nodes A. P p}, (\<lambda> x. the (f x)) ` {p \<in> nodes A. Q p})) (accepting A)))
---
>           (map (\<lambda> (P, Q). ((\<lambda> x. the (f x)) ` {p \<in> nodes A. P p}, (\<lambda> x. the (f x)) ` {p \<in> nodes A. Q p})) (condition A)))
210c210
<       have 3: "wft (alphabet A) (nodes A) (transe (dra_drae A))"
---
>       have 3: "wft (alphabet A) (nodes A) (transitione (dra_drae A))"
212,213c212,213
<       have 4: "(wft (alphabet A) (f ` nodes A) (transe (drae_image f (dra_drae A))),
<         wft (alphabet A) (id ` nodes A) (transe (drae_image id (dra_drae A)))) \<in> bool_rel"
---
>       have 4: "(wft (alphabet A) (f ` nodes A) (transitione (drae_image f (dra_drae A))),
>         wft (alphabet A) (id ` nodes A) (transitione (drae_image id (dra_drae A)))) \<in> bool_rel"
215c215
<       have 5: "wft (alphabet A) (f ` nodes A) (transe (drae_image f (dra_drae A)))" using 3 4 by simp
---
>       have 5: "wft (alphabet A) (f ` nodes A) (transitione (drae_image f (dra_drae A)))" using 3 4 by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Algorithms.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Algorithms.thy
22c22
<   definition [simp]: "op_empty A \<equiv> language A = {}"
---
>   definition [simp]: "op_language_empty A \<equiv> language A = {}"
24c24
<   lemmas [autoref_op_pat] = op_empty_def[symmetric]
---
>   lemmas [autoref_op_pat] = op_language_empty_def[symmetric]
34,35c34,36
<       ((\<Union> a \<in> alphabet A. succ A a p ::: \<langle>S\<rangle> list_set_rel) ::: \<langle>S\<rangle> ahs_rel bhc)), g_V0 = initial A \<rparr>"
<       unfolding nba_g_def successors_alt_def CAST_def id_apply autoref_tag_defs by rule
---
>       ((\<Union> a \<in> alphabet A. transition A a p ::: \<langle>S\<rangle> list_set_rel) ::: \<langle>S\<rangle> ahs_rel bhc)),
>       g_V0 = initial A \<rparr>"
>       unfolding nba_g_def nba.successors_alt_def CAST_def id_apply autoref_tag_defs by rule
81c82
<       ((\<Union> a \<in> alphabet A. succ A a p ::: \<langle>S\<rangle> list_set_rel) ::: \<langle>S\<rangle> ahs_rel bhc)), g_V0 = initial A,
---
>       ((\<Union> a \<in> alphabet A. transition A a p ::: \<langle>S\<rangle> list_set_rel) ::: \<langle>S\<rangle> ahs_rel bhc)), g_V0 = initial A,
83c84
<       unfolding nba_g_def nba_igbg_def successors_alt_def CAST_def id_apply autoref_tag_defs
---
>       unfolding nba_g_def nba_igbg_def nba.successors_alt_def CAST_def id_apply autoref_tag_defs
106,107c107,108
<     schematic_goal nba_empty:
<       fixes A :: "('label, 'state :: hashable) nba"
---
>     schematic_goal nba_language_empty:
>       fixes S :: "('statei \<times> 'state) set"
109c110,113
<       assumes [autoref_rules]: "(Ai, A) \<in> \<langle>L, Id\<rangle> nbai_nba_rel"
---
>       assumes [autoref_ga_rules]: "is_bounded_hashcode S seq bhs"
>       assumes [autoref_ga_rules]: "is_valid_def_hm_size TYPE('statei) hms"
>       assumes [autoref_rules]: "(seq, HOL.eq) \<in> S \<rightarrow> S \<rightarrow> bool_rel"
>       assumes [autoref_rules]: "(Ai, A) \<in> \<langle>L, S\<rangle> nbai_nba_rel"
112,117c116,125
<     concrete_definition nba_empty uses nba_empty
<     lemma nba_empty_refine[autoref_rules]:
<       assumes "SIDE_PRECOND (igb_fr_graph (nba_igbg A))"
<       assumes "(Ai, A) \<in> \<langle>L, Id\<rangle> nbai_nba_rel"
<       shows "(NBA_Algorithms.nba_empty Ai,
<         (OP op_empty ::: \<langle>L, S\<rangle> nbai_nba_rel \<rightarrow> bool_rel) $ A) \<in> bool_rel"
---
>     concrete_definition nba_language_empty uses nba_language_empty
>     lemma nba_language_empty_refine[autoref_rules]:
>       fixes S :: "('statei \<times> 'state) set"
>       assumes "SIDE_PRECOND (finite (nodes A))"
>       assumes "SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)"
>       assumes "SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)"
>       assumes "GEN_OP seq HOL.eq (S \<rightarrow> S \<rightarrow> bool_rel)"
>       assumes "(Ai, A) \<in> \<langle>L, S\<rangle> nbai_nba_rel"
>       shows "(NBA_Algorithms.nba_language_empty seq bhc hms Ai,
>         (OP op_language_empty ::: \<langle>L, S\<rangle> nbai_nba_rel \<rightarrow> bool_rel) $ A) \<in> bool_rel"
119,120c127,131
<       interpret igb_fr_graph "nba_igbg A" using assms(1) by simp
<       have "(RETURN (NBA_Algorithms.nba_empty Ai),
---
>       have 1: "nodes A = op_reachable (nba_g A)" by (auto simp: nba_g_V0 nba_g_E_rtrancl)
>       have 2: "finite ((g_E (nba_g A))\<^sup>* `` g_V0 (nba_g A))" using assms(1) unfolding 1 by simp
>       interpret igb_fr_graph "nba_igbg A"
>         using 2 unfolding nba_igbg_def nba_g_def graph_rec.defs by unfold_locales auto
>       have "(RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),
122c133
<         using nba_empty.refine assms by simp
---
>         using nba_language_empty.refine assms igb_fr_graph_axioms by simp
126c137
<       finally have "NBA_Algorithms.nba_empty Ai \<longleftrightarrow> \<not> Ex is_lasso_prpl"
---
>       finally have "NBA_Algorithms.nba_language_empty seq bhc hms Ai \<longleftrightarrow> \<not> Ex is_lasso_prpl"
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA: NBA_Combine.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Explicit.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Explicit.thy
10c10
<     (transe: "('state \<times> 'label \<times> 'state) set")
---
>     (transitione: "('state \<times> 'label \<times> 'state) set")
17c17
<       (transe A\<^sub>1, transe A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel \<and>
---
>       (transitione A\<^sub>1, transitione A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel \<and>
25c25
<     "(transe, transe) \<in> \<langle>L, S\<rangle> nbae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel"
---
>     "(transitione, transitione) \<in> \<langle>L, S\<rangle> nbae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> set_rel"
37c37
<       "(transe A, c) \<in> \<langle>S\<^sub>1 \<times>\<^sub>r L\<^sub>1 \<times>\<^sub>r S\<^sub>1\<rangle> set_rel" "(c, transe B) \<in> \<langle>S\<^sub>2 \<times>\<^sub>r L\<^sub>2 \<times>\<^sub>r S\<^sub>2\<rangle> set_rel"
---
>       "(transitione A, c) \<in> \<langle>S\<^sub>1 \<times>\<^sub>r L\<^sub>1 \<times>\<^sub>r S\<^sub>1\<rangle> set_rel" "(c, transitione B) \<in> \<langle>S\<^sub>2 \<times>\<^sub>r L\<^sub>2 \<times>\<^sub>r S\<^sub>2\<rangle> set_rel"
64c64
<       "transe ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nbae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>S, \<langle>L, S\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_set"
---
>       "transitione ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nbae_scheme \<rightarrow>\<^sub>i \<langle>\<langle>S, \<langle>L, S\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_prod\<rangle>\<^sub>i i_set"
73c73
<     (transei: "('state \<times> 'label \<times> 'state) list")
---
>     (transitionei: "('state \<times> 'label \<times> 'state) list")
80c80
<       (transei A\<^sub>1, transei A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel \<and>
---
>       (transitionei A\<^sub>1, transitionei A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel \<and>
88c88
<     "(transei, transei) \<in> \<langle>L, S\<rangle> nbaei_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel"
---
>     "(transitionei, transitionei) \<in> \<langle>L, S\<rangle> nbaei_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_rel"
96c96
<       (transei A\<^sub>1, transe A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel \<and>
---
>       (transitionei A\<^sub>1, transitione A\<^sub>2) \<in> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel \<and>
106c106
<     "(transei, transe) \<in> \<langle>L, S\<rangle> nbaei_nbae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel"
---
>     "(transitionei, transitione) \<in> \<langle>L, S\<rangle> nbaei_nbae_rel \<rightarrow> \<langle>S \<times>\<^sub>r L \<times>\<^sub>r S\<rangle> list_set_rel"
112c112
<       (set (transei A)) (set (acceptingei A))"
---
>       (set (transitionei A)) (set (acceptingei A))"
119c119
<       (set (transei Ai)) (set (acceptingei Ai))" unfolding nbaei_nbae_def by rule
---
>       (set (transitionei Ai)) (set (acceptingei Ai))" unfolding nbaei_nbae_def by rule
121c121
<       (id (transe A)) (id (acceptinge A))" by simp
---
>       (id (transitione A)) (id (acceptinge A))" by simp
129c129
<     (transitions (alphabet A) (nodes A) (succ A)) (Set.filter (accepting A) (nodes A))"
---
>     (transitions (alphabet A) (nodes A) (transition A)) (Set.filter (accepting A) (nodes A))"
131c131
<     (succs (transe A)) (\<lambda> p. p \<in> acceptinge A)"
---
>     (succs (transitione A)) (\<lambda> p. p \<in> acceptinge A)"
144c144
<       (succs (transitions (alphabet A) (nodes A) (succ A))) (\<lambda> p. p \<in> Set.filter (accepting A) (nodes A))"
---
>       (succs (transitions (alphabet A) (nodes A) (transition A))) (\<lambda> p. p \<in> Set.filter (accepting A) (nodes A))"
146c146
<     also have "(\<dots>, nba (alphabet A) (initial A) (succ A) (accepting A)) \<in>
---
>     also have "(\<dots>, nba (alphabet A) (initial A) (transition A) (accepting A)) \<in>
149c149
<     also have  "nba (alphabet A) (initial A) (succ A) (accepting A) = id A" by simp
---
>     also have  "nba (alphabet A) (initial A) (transition A) (accepting A) = id A" by simp
158c158,161
<   schematic_goal nbae_nba_impl: "(?f, nbae_nba) \<in> \<langle>Id, Id\<rangle> nbaei_nbae_rel \<rightarrow> \<langle>Id, Id\<rangle> nbai_nba_rel"
---
>   schematic_goal nbae_nba_impl:
>     assumes [autoref_rules]: "(leq, HOL.eq) \<in> L \<rightarrow> L \<rightarrow> bool_rel"
>     assumes [autoref_rules]: "(seq, HOL.eq) \<in> S \<rightarrow> S \<rightarrow> bool_rel"
>     shows "(?f, nbae_nba) \<in> \<langle>L, S\<rangle> nbaei_nbae_rel \<rightarrow> \<langle>L, S\<rangle> nbai_nba_rel"
160a164,168
>   lemma nbae_nba_impl_refine[autoref_rules]:
>     assumes "GEN_OP leq HOL.eq (L \<rightarrow> L \<rightarrow> bool_rel)"
>     assumes "GEN_OP seq HOL.eq (S \<rightarrow> S \<rightarrow> bool_rel)"
>     shows "(nbae_nba_impl leq seq, nbae_nba) \<in> \<langle>L, S\<rangle> nbaei_nbae_rel \<rightarrow> \<langle>L, S\<rangle> nbai_nba_rel"
>     using nbae_nba_impl.refine assms unfolding autoref_tag_defs by this
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Graphs.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Graphs.thy
38c38
<       obtain a where 1: "a \<in> alphabet A" "y \<in> succ A a x" using base by auto
---
>       obtain a where 1: "a \<in> alphabet A" "y \<in> transition A a x" using base by auto
48c48
<       obtain a where 2: "a \<in> alphabet A" "z \<in> succ A a y" using step(2) by auto
---
>       obtain a where 2: "a \<in> alphabet A" "z \<in> transition A a y" using step(2) by auto
65c65
<     have 1: "\<exists> a \<in> alphabet A. r (Suc i) \<in> succ A a (r i)" for i
---
>     have 1: "\<exists> a \<in> alphabet A. r (Suc i) \<in> transition A a (r i)" for i
69c69
<       show "\<exists> aq. (fst aq \<in> alphabet A \<and> snd aq \<in> succ A (fst aq) p) \<and> snd aq = r (Suc i) \<and> True"
---
>       show "\<exists> aq. (fst aq \<in> alphabet A \<and> snd aq \<in> transition A (fst aq) p) \<and> snd aq = r (Suc i) \<and> True"
79c79
<       also have "\<dots> = smap snd wr !! i" unfolding trace_alt_def by simp
---
>       also have "\<dots> = smap snd wr !! i" unfolding nba.trace_alt_def by simp
92c92
<     have 1: "w !! i \<in> alphabet A" "r !! i \<in> succ A (w !! i) (target (stake i (w ||| r)) p)"
---
>     have 1: "w !! i \<in> alphabet A" "r !! i \<in> transition A (w !! i) (target (stake i (w ||| r)) p)"
95c95
<       using 1 unfolding sscan_scons_snth[symmetric] trace_alt_def by auto
---
>       using 1 unfolding sscan_scons_snth[symmetric] nba.trace_alt_def by auto
120,122c120,121
<       have 4: "r 0 ## trace (w ||| smap (r \<circ> Suc) nats) (r 0) = smap r nats"
<         unfolding trace_alt_def by (simp) (metis stream.map_comp smap_siterate)
<       have 5: "infs (accepting A) (r 0 ## trace (w ||| smap (r \<circ> Suc) nats) (r 0))"
---
>       have 4: "r 0 ## smap (r \<circ> Suc) nats = smap r nats" by (simp) (metis stream.map_comp smap_siterate)
>       have 5: "infs (accepting A) (r 0 ## smap (r \<circ> Suc) nats)"
128c127
<         show "infs (accepting A) (trace (w ||| smap (r \<circ> Suc) nats) (r 0))" using 5 by simp
---
>         show "infs (accepting A) (r 0 ## smap (r \<circ> Suc) nats)" using 5 by simp
135,138c134,135
<       obtain r p where 2:
<         "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (trace (w ||| r) p)"
<         using 1 by rule
<       have 3: "infs (accepting A) (p ## trace (w ||| r) p)" using 2(3) by simp
---
>       obtain r p where 2: "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (p ## r)" using 1 by rule
>       have 3: "infs (accepting A) (p ## r)" using 2(3) by simp
144c141
<         show "is_acc (snth (p ## r))" using 3 unfolding infs_infm is_acc_def trace_alt_def by simp
---
>         show "is_acc (snth (p ## r))" using 3 unfolding infs_infm is_acc_def by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Implement.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Implement.thy
8a9,26
>   consts i_nba_scheme :: "interface \<Rightarrow> interface \<Rightarrow> interface"
> 
>   context
>   begin
> 
>     interpretation autoref_syn by this
> 
>     lemma nba_scheme_itype[autoref_itype]:
>       "nba ::\<^sub>i \<langle>L\<rangle>\<^sub>i i_set \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set \<rightarrow>\<^sub>i (L \<rightarrow>\<^sub>i S \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set) \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set \<rightarrow>\<^sub>i
>         \<langle>L, S\<rangle>\<^sub>i i_nba_scheme"
>       "alphabet ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nba_scheme \<rightarrow>\<^sub>i \<langle>L\<rangle>\<^sub>i i_set"
>       "initial ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nba_scheme \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set"
>       "transition ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nba_scheme \<rightarrow>\<^sub>i L \<rightarrow>\<^sub>i S \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set"
>       "accepting ::\<^sub>i \<langle>L, S\<rangle>\<^sub>i i_nba_scheme \<rightarrow>\<^sub>i \<langle>S\<rangle>\<^sub>i i_set"
>       by auto
> 
>   end
> 
12c30
<     (succi: "'label \<Rightarrow> 'state \<Rightarrow> 'state list")
---
>     (transitioni: "'label \<Rightarrow> 'state \<Rightarrow> 'state list")
20c38
<       (succi A\<^sub>1, succi A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_rel \<and>
---
>       (transitioni A\<^sub>1, transitioni A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_rel \<and>
23c41
<   lemma nbai_param[param]:
---
>   lemma nbai_param[param, autoref_rules]:
28c46
<     "(succi, succi) \<in> \<langle>L, S\<rangle> nbai_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_rel"
---
>     "(transitioni, transitioni) \<in> \<langle>L, S\<rangle> nbai_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_rel"
37c55
<       (succi A\<^sub>1, succ A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_set_rel \<and>
---
>       (transitioni A\<^sub>1, transition A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_set_rel \<and>
39a58,60
>   lemmas [autoref_rel_intf] = REL_INTFI[of nbai_nba_rel i_nba_scheme]
> 
>   (* TODO: why is there a warning? *)
45c66
<     "(succi, succ) \<in> \<langle>L, S\<rangle> nbai_nba_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_set_rel"
---
>     "(transitioni, transition) \<in> \<langle>L, S\<rangle> nbai_nba_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> list_set_rel"
50c71
<     "nbai_nba A \<equiv> nba (set (alphabeti A)) (set (initiali A)) (\<lambda> a p. set (succi A a p)) (acceptingi A)"
---
>     "nbai_nba A \<equiv> nba (set (alphabeti A)) (set (initiali A)) (\<lambda> a p. set (transitioni A a p)) (acceptingi A)"
52c73
<     "nbai_invar A \<equiv> distinct (alphabeti A) \<and> distinct (initiali A) \<and> (\<forall> a p. distinct (succi A a p))"
---
>     "nbai_invar A \<equiv> distinct (alphabeti A) \<and> distinct (initiali A) \<and> (\<forall> a p. distinct (transitioni A a p))"
59c80
<       (\<lambda> a p. set (succi Ai a p)) (acceptingi Ai)" unfolding nbai_nba_def by rule
---
>       (\<lambda> a p. set (transitioni Ai a p)) (acceptingi Ai)" unfolding nbai_nba_def by rule
61c82
<       (\<lambda> a p. id (succ A a p)) (accepting A)" by simp
---
>       (\<lambda> a p. id (transition A a p)) (accepting A)" by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Refine.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Refine.thy
14c14
<       (succ A\<^sub>1, succ A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> set_rel \<and>
---
>       (transition A\<^sub>1, transition A\<^sub>2) \<in> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> set_rel \<and>
22c22
<     "(succ, succ) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> set_rel"
---
>     "(transition, transition) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> L \<rightarrow> S \<rightarrow> \<langle>S\<rangle> set_rel"
34,36c34,36
<     have "(succ A, succ B) \<in> L\<^sub>1 \<rightarrow> S\<^sub>1 \<rightarrow> \<langle>S\<^sub>1\<rangle> set_rel" by parametricity
<     also have "(succ B, succ C) \<in> L\<^sub>2 \<rightarrow> S\<^sub>2 \<rightarrow> \<langle>S\<^sub>2\<rangle> set_rel" by parametricity
<     finally have 2: "(succ A, succ C) \<in> L\<^sub>1 O L\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2 \<rightarrow> \<langle>S\<^sub>1\<rangle> set_rel O \<langle>S\<^sub>2\<rangle> set_rel" by simp
---
>     have "(transition A, transition B) \<in> L\<^sub>1 \<rightarrow> S\<^sub>1 \<rightarrow> \<langle>S\<^sub>1\<rangle> set_rel" by parametricity
>     also have "(transition B, transition C) \<in> L\<^sub>2 \<rightarrow> S\<^sub>2 \<rightarrow> \<langle>S\<^sub>2\<rangle> set_rel" by parametricity
>     finally have 2: "(transition A, transition C) \<in> L\<^sub>1 O L\<^sub>2 \<rightarrow> S\<^sub>1 O S\<^sub>2 \<rightarrow> \<langle>S\<^sub>1\<rangle> set_rel O \<langle>S\<^sub>2\<rangle> set_rel" by simp
56c56
<   lemma enableds_param[param]: "(enableds, enableds) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>L \<times>\<^sub>r S\<rangle> set_rel"
---
>   lemma enableds_param[param]: "(nba.enableds, nba.enableds) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>L \<times>\<^sub>r S\<rangle> set_rel"
58,61c58,61
<   lemma paths_param[param]: "(paths, paths) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L \<times>\<^sub>r S\<rangle> list_rel\<rangle> set_rel"
<     unfolding paths_def by (intro fun_relI paths_param, fold enableds_def) (parametricity+)
<   lemma runs_param[param]: "(runs, runs) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L \<times>\<^sub>r S\<rangle> stream_rel\<rangle> set_rel"
<     unfolding runs_def by (intro fun_relI runs_param, fold enableds_def) (parametricity+)
---
>   lemma paths_param[param]: "(nba.paths, nba.paths) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L \<times>\<^sub>r S\<rangle> list_rel\<rangle> set_rel"
>     using enableds_param[param_fo] by parametricity
>   lemma runs_param[param]: "(nba.runs, nba.runs) \<in> \<langle>L, S\<rangle> nba_rel \<rightarrow> S \<rightarrow> \<langle>\<langle>L \<times>\<^sub>r S\<rangle> stream_rel\<rangle> set_rel"
>     using enableds_param[param_fo] by parametricity
65c65
<     have 1: "reachable A p = (\<lambda> wr. target wr p) ` paths A p" for A :: "('label, 'state) nba" and p
---
>     have 1: "reachable A p = (\<lambda> wr. target wr p) ` nba.paths A p" for A :: "('label, 'state) nba" and p
67c67
<     show ?thesis unfolding 1 by parametricity
---
>     show ?thesis unfolding 1 using enableds_param[param_fo] by parametricity
74,75c74,75
<     have 1: "language A = (\<Union> p \<in> initial A. \<Union> wr \<in> runs A p.
<       if infs (accepting A) (trace wr p) then {smap fst wr} else {})"
---
>     have 1: "language A = (\<Union> p \<in> initial A. \<Union> wr \<in> nba.runs A p.
>       if infs (accepting A) (p ## smap snd wr) then {smap fst wr} else {})"
77,78c77,79
<       unfolding language_def nba.runs_def image_def by (auto iff: split_szip_ex)
<     show ?thesis unfolding 1 by parametricity
---
>       unfolding nba.language_def nba.runs_def image_def
>       by (auto iff: split_szip_ex simp del: alw_smap)
>     show ?thesis unfolding 1 using enableds_param[param_fo] by parametricity
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA.thy
4,9c4
< imports
<   "../../Basic/Sequence_Zip"
<   "../../Basic/Acceptance"
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Nondeterministic"
15c10
<     (succ: "'label \<Rightarrow> 'state \<Rightarrow> 'state set")
---
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state set")
18,64c13,23
<   global_interpretation nba: transition_system_initial
<     "\<lambda> a p. snd a" "\<lambda> a p. fst a \<in> alphabet A \<and> snd a \<in> succ A (fst a) p" "\<lambda> p. p \<in> initial A"
<     for A
<     defines path = nba.path and run = nba.run and reachable = nba.reachable and nodes = nba.nodes and
<       enableds = nba.enableds and paths = nba.paths and runs = nba.runs
<     by this
< 
<   abbreviation "target \<equiv> nba.target"
<   abbreviation "states \<equiv> nba.states"
<   abbreviation "trace \<equiv> nba.trace"
< 
<   lemma states_alt_def: "states r p = map snd r" by (induct r arbitrary: p) (auto)
<   lemma trace_alt_def: "trace r p = smap snd r" by (coinduction arbitrary: r p) (auto)
< 
<   abbreviation successors :: "('label, 'state) nba \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> nba.successors TYPE('label)"
< 
<   lemma successors_alt_def: "successors A p = (\<Union> a \<in> alphabet A. succ A a p)" by auto
< 
<   lemma reachable_succ[intro]:
<     assumes "a \<in> alphabet A" "q \<in> reachable A p" "r \<in> succ A a q"
<     shows "r \<in> reachable A p"
<     using nba.reachable.execute assms by force
<   lemma nodes_succ[intro]:
<     assumes "a \<in> alphabet A" "p \<in> nodes A" "q \<in> succ A a p"
<     shows "q \<in> nodes A"
<     using nba.nodes.execute assms by force
< 
<   definition language :: "('label, 'state) nba \<Rightarrow> 'label stream set" where
<     "language A \<equiv> {w |w r p. p \<in> initial A \<and> run A (w ||| r) p \<and> infs (accepting A) (trace (w ||| r) p)}"
< 
<   lemma language[intro]:
<     assumes "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (trace (w ||| r) p)"
<     shows "w \<in> language A"
<     using assms unfolding language_def by auto
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains r p
<     where "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (trace (w ||| r) p)"
<     using assms unfolding language_def by auto
< 
<   lemma run_alphabet:
<     assumes "run A (w ||| r) p"
<     shows "w \<in> streams (alphabet A)"
<     using assms by (coinduction arbitrary: w r p) (metis nba.run.cases stream.map szip_smap szip_smap_fst)
<   lemma language_alphabet: "language A \<subseteq> streams (alphabet A)"
<     unfolding language_def by (auto dest: run_alphabet)
---
>   global_interpretation nba: automaton nba alphabet initial transition accepting
>     defines path = nba.path and run = nba.run and reachable = nba.reachable and nodes = nba.nodes
>     by unfold_locales auto
>   global_interpretation nba: automaton_run nba alphabet initial transition accepting "\<lambda> P w r p. infs P (p ## r)"
>     defines language = nba.language
>     by standard
> 
>   abbreviation target where "target \<equiv> nba.target"
>   abbreviation states where "states \<equiv> nba.states"
>   abbreviation trace where "trace \<equiv> nba.trace"
>   abbreviation successors where "successors \<equiv> nba.successors TYPE('label)"
71c30
<         succ A \<le> succ B \<and> accepting A \<le> accepting B"
---
>         transition A \<le> transition B \<and> accepting A \<le> accepting B"
85c44
<     have 4: "succ A a p \<subseteq> succ B a p" for a p using 1 unfolding less_eq_nba_def le_fun_def by auto
---
>     have 4: "transition A a p \<subseteq> transition B a p" for a p using 1 unfolding less_eq_nba_def le_fun_def by auto
96c55
<     have 4: "succ A a p \<subseteq> succ B a p" for a p using 1 unfolding less_eq_nba_def le_fun_def by auto
---
>     have 4: "transition A a p \<subseteq> transition B a p" for a p using 1 unfolding less_eq_nba_def le_fun_def by auto
106c65
<     assumes "\<And> a p p' q. p' \<in> succ A a p \<Longrightarrow> (p, q) \<in> R \<Longrightarrow> \<exists> q' \<in> succ B a q. (p', q') \<in> R"
---
>     assumes "\<And> a p p' q. p' \<in> transition A a p \<Longrightarrow> (p, q) \<in> R \<Longrightarrow> \<exists> q' \<in> transition B a q. (p', q') \<in> R"
112,113c71
<     obtain r p where 2: "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (trace (w ||| r) p)"
<       using 1 by rule
---
>     obtain r p where 2: "p \<in> initial A" "run A (w ||| r) p" "infs (accepting A) (p ## r)" using 1 by rule
121c79
<         by (metis id_stake_snth_sdrop snth_szip sscan_snth szip_smap_snd trace_alt_def)
---
>         by (metis id_stake_snth_sdrop snth_szip sscan_snth szip_smap_snd nba.trace_alt_def)
123c81
<       finally show "\<exists> a. (fst a \<in> alphabet B \<and> snd a \<in> succ B (fst a) q) \<and>
---
>       finally show "\<exists> a. (fst a \<in> alphabet B \<and> snd a \<in> transition B (fst a) q) \<and>
136,138c94,96
<       have 8: "stream_all2 (\<lambda> a b. accepting A a \<longrightarrow> accepting B b)
<         (trace (w ||| r) p) (trace (w ||| s) q)" using stream.rel_mono 6 7 by auto
<       show "infs (accepting B) (trace (w ||| s) q)" using infs_mono_strong 8 2(3) by this
---
>       have 8: "stream_all2 (\<lambda> a b. accepting A a \<longrightarrow> accepting B b) r s"
>         using stream.rel_mono 6 7 unfolding nba.trace_alt_def by auto
>       show "infs (accepting B) (q ## s)" using infs_mono_strong 8 2(3) by simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Translate.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Translate.thy
15a16
>   (* TODO: this should not be needed, only use nba_image *)
17c18
<     ((\<lambda> (p, a, q). (f p, a, f q)) ` transe A) (f ` acceptinge A)"
---
>     ((\<lambda> (p, a, q). (f p, a, f q)) ` transitione A) (f ` acceptinge A)"
25c26
<     (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)
---
>     (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)
32c33
<     "trans_spec A f \<equiv> \<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p"
---
>     "trans_spec A f \<equiv> \<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p"
50c51
<     assumes "N = nodes A" "L = alphabet A" "S = succ A"
---
>     assumes "N = nodes A" "L = alphabet A" "S = transition A"
55,57c56,58
<     show "(\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
<       (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)" by rule
<     show "(\<Union> p \<in> {}. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) = {}" by simp
---
>     show "(\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
>       (\<Union> p \<in> nodes A. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)" by rule
>     show "(\<Union> p \<in> {}. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) = {}" by simp
61,66c62,67
<     show "(\<Union> a \<in> {}. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)"
<       "(\<Union> a \<in> alphabet A. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
<       (\<Union> p \<in> insert x T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)" by auto
---
>     show "(\<Union> a \<in> {}. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)"
>       "(\<Union> a \<in> alphabet A. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
>       (\<Union> p \<in> insert x T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)" by auto
69,74c70,75
<     show "finite (succ A xa x)" using 1 2 assms(1) by (meson infinite_subset nodes_succ subsetI)
<     show "(f ` {x} \<times> {xa} \<times> f ` succ A xa x) \<union>
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
<       (\<Union> a \<in> insert xa Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)"
---
>     show "finite (transition A xa x)" using 1 2 assms(1) by (meson infinite_subset nba.nodes_transition subsetI)
>     show "(f ` {x} \<times> {xa} \<times> f ` transition A xa x) \<union>
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
>       (\<Union> a \<in> insert xa Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)"
77,80c78,81
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)"
---
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)"
83c84
<     assume 3: "Tb \<subseteq> succ A xa x" "xb \<in> succ A xa x" "xb \<notin> Tb"
---
>     assume 3: "Tb \<subseteq> transition A xa x" "xb \<in> transition A xa x" "xb \<notin> Tb"
85,86c86,87
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p)"
---
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p)"
89,90c90,91
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p) =
---
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p) =
92,93c93,94
<       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` succ A a x) \<union>
<       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` succ A a p))"
---
>       (\<Union> a \<in> Ta. f ` {x} \<times> {a} \<times> f ` transition A a x) \<union>
>       (\<Union> p \<in> T. \<Union> a \<in> alphabet A. f ` {p} \<times> {a} \<times> f ` transition A a p))"
97,98c98,134
<   definition to_nbaei :: "('state, 'label) nba \<Rightarrow> ('state, 'label) nba"
<     where "to_nbaei \<equiv> id"
---
>   (* TODO: move this to nondeterministic automaton
>     there, it will have to be treated more elementarily
>     at least until we abstract from NBA_Refine to do that there aswell *)
>   definition nba_image :: "('state\<^sub>1 \<Rightarrow> 'state\<^sub>2) \<Rightarrow> ('label, 'state\<^sub>1) nba \<Rightarrow> ('label, 'state\<^sub>2) nba" where
>     "nba_image f A \<equiv> nba
>       (alphabet A)
>       (f ` initial A)
>       (\<lambda> a p. f ` transition A a (inv_into (nodes A) f p))
>       (\<lambda> p. accepting A (inv_into (nodes A) f p))"
> 
>   lemma nba_image_rel[param]:
>     assumes "inj_on f (nodes A)"
>     shows "(A, nba_image f A) \<in> \<langle>Id_on (alphabet A), br f (\<lambda> p. p \<in> nodes A)\<rangle> nba_rel"
>   proof -
>     have "A = nba (alphabet A) (initial A) (transition A) (accepting A)" by simp
>     also have "(\<dots>, nba_image f A) \<in> \<langle>Id_on (alphabet A), br f (\<lambda> p. p \<in> nodes A)\<rangle> nba_rel"
>       using assms unfolding nba_image_def
>       by (parametricity) (auto intro: nba_rel_eq simp: in_br_conv br_set_rel_alt)
>     finally show ?thesis by this
>   qed
> 
>   lemma nba_image_nodes[simp]:
>     assumes "inj_on f (nodes A)"
>     shows "nodes (nba_image f A) = f ` nodes A"
>   proof -
>     have "(nodes A, nodes (nba_image f A)) \<in> \<langle>br f (\<lambda> p. p \<in> nodes A)\<rangle> set_rel"
>       using assms by parametricity
>     then show ?thesis unfolding br_set_rel_alt by simp
>   qed
>   lemma nba_image_language[simp]:
>     assumes "inj_on f (nodes A)"
>     shows "language (nba_image f A) = language A"
>   proof -
>     have "(language A, language (nba_image f A)) \<in> \<langle>\<langle>Id_on (alphabet A)\<rangle> stream_rel\<rangle> set_rel"
>       using assms by parametricity
>     then show ?thesis by simp
>   qed
100c136,180
<   (* TODO: make separate implementations for "nba_nbae" and "op_set_enumerate \<bind> nbae_image" *)
---
>   lemma nba_image_nbae:
>     assumes "inj_on f (nodes A)"
>     shows "nbae_image f (nba_nbae A) = nba_nbae (nba_image f A)"
>     unfolding nbae_image_nba_nbae
>     unfolding nba_nbae_def
>     unfolding nba_image_nodes[OF assms]
>     unfolding nbae.simps
>     unfolding nba_image_def
>     unfolding nba.sel
>     using assms by auto
> 
>   (* TODO: with this, maybe much of the nbae infrastructure is obsolete?
>     since now there is very little happening in terms of relations, maybe we can even make do
>     with just the abstraction function *)
>   (* TODO: maybe the specification for translation is just that the translated automaton
>     is related in \<langle>Id_on (alphabet A), ???\<rangle> nba_rel? *)
>   definition op_translate :: "('label, 'state) nba \<Rightarrow> ('label, nat) nbae nres" where
>     "op_translate A \<equiv> SPEC (\<lambda> B. \<exists> f. inj_on f (nodes A) \<and> B = nba_nbae (nba_image f A))"
> 
>   lemma op_translate_language:
>     assumes "(RETURN Ai, op_translate A) \<in> \<langle>\<langle>Id, nat_rel\<rangle> nbaei_nbae_rel\<rangle> nres_rel"
>     shows "language (nbae_nba (nbaei_nbae Ai)) = language A"
>   proof -
>     (* TODO: can we leave all this inside the nres without explicit obtain? *)
>     obtain f where 1:
>       "(Ai, nba_nbae (nba_image f A)) \<in> \<langle>Id, nat_rel\<rangle> nbaei_nbae_rel" "inj_on f (nodes A)"
>       using assms[unfolded in_nres_rel_iff op_translate_def, THEN RETURN_ref_SPECD]
>       by metis
>     let ?C = "nba_image f A"
>     have "(nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae ?C))) \<in> \<langle>Id, nat_rel\<rangle> nba_rel"
>       using 1(1) by parametricity auto
>     also have "nbae_nba (id (nba_nbae ?C)) = (nbae_nba \<circ> nba_nbae) ?C" by simp
>     also have "(\<dots>, id ?C) \<in> \<langle>Id_on (alphabet ?C), Id_on (nodes ?C)\<rangle> nba_rel" by parametricity
>     finally have 2: "(nbae_nba (nbaei_nbae Ai), ?C) \<in>
>       \<langle>Id_on (alphabet ?C), Id_on (nodes ?C)\<rangle> nba_rel" by simp
>     have "(language (nbae_nba (nbaei_nbae Ai)), language ?C) \<in>
>       \<langle>\<langle>Id_on (alphabet ?C)\<rangle> stream_rel\<rangle> set_rel"
>       using 2 by parametricity
>     also have "language ?C = language A" using 1(2) by simp
>     finally show ?thesis by simp
>   qed
> 
>   (* TODO: make separate implementations for "nba_nbae" and "op_set_enumerate \<bind> nbae_image"
>     make sure to do regression tests along the way *)
>   (* TODO: since we have translate_impl, maybe just having a good nba_nbae implementation is enough? *)
113,114c193,194
<         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. \<forall> q \<in> succ A a p. f q \<noteq> None);
<         T \<leftarrow> trans_algo N (alphabet A) (succ A) (\<lambda> x. the (f x));
---
>         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. \<forall> q \<in> transition A a p. f q \<noteq> None);
>         T \<leftarrow> trans_algo N (alphabet A) (transition A) (\<lambda> x. the (f x));
120,231d199
<   lemma to_nbaei_impl_refine'':
<     fixes S :: "('statei \<times> 'state) set"
<     assumes "finite (nodes A)"
<     assumes "is_bounded_hashcode S seq bhc"
<     assumes "is_valid_def_hm_size TYPE('statei) hms"
<     assumes "(seq, HOL.eq) \<in> S \<rightarrow> S \<rightarrow> bool_rel"
<     assumes "(Ai, A) \<in> \<langle>L, S\<rangle> nbai_nba_rel"
<     shows "(RETURN (to_nbaei_impl seq bhc hms Ai), do {
<         f \<leftarrow> op_set_enumerate (nodes A);
<         RETURN (nbae_image (the \<circ> f) (nba_nbae A))
<       }) \<in> \<langle>\<langle>L, nat_rel\<rangle> nbaei_nbae_rel\<rangle> nres_rel"
<   proof -
<     have 1: "finite (alphabet A)"
<       using nbai_nba_param(2)[param_fo, OF assms(5)] list_set_rel_finite
<       unfolding finite_set_rel_def by auto
<     note to_nbaei_impl.refine[OF assms]
<     also have "(do {
<         let N = nodes A;
<         f \<leftarrow> op_set_enumerate N;
<         ASSERT (dom f = N);
<         ASSERT (\<forall> p \<in> initial A. f p \<noteq> None);
<         ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. \<forall> q \<in> succ A a p. f q \<noteq> None);
<         T \<leftarrow> trans_algo N (alphabet A) (succ A) (\<lambda> x. the (f x));
<         RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> N. accepting A p}))
<       }, do {
<         f \<leftarrow> op_set_enumerate (nodes A);
<         T \<leftarrow> SPEC (HOL.eq (trans_spec A (\<lambda> x. the (f x))));
<         RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> nodes A. accepting A p}))
<       }) \<in> \<langle>Id\<rangle> nres_rel"
<       unfolding Let_def comp_apply op_set_enumerate_def using assms(1) 1
<       by (refine_vcg vcg0[OF trans_algo_refine]) (auto intro!: inj_on_map_the[unfolded comp_apply])
<     also have "(do {
<         f \<leftarrow> op_set_enumerate (nodes A);
<         T \<leftarrow> SPEC (HOL.eq (trans_spec A (\<lambda> x. the (f x))));
<         RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> nodes A. accepting A p}))
<       },  do {
<         f \<leftarrow> op_set_enumerate (nodes A);
<         RETURN (nbae_image (the \<circ> f) (nba_nbae A))
<       }) \<in> \<langle>Id\<rangle> nres_rel"
<       unfolding trans_spec_def nbae_image_nba_nbae by refine_vcg force
<     finally show ?thesis unfolding nres_rel_comp by simp
<   qed
< 
<   (* TODO: generalize L *)
<   context
<     fixes Ai A
<     fixes seq bhc hms
<     fixes S :: "('statei \<times> 'state) set"
<     assumes a: "finite (nodes A)"
<     assumes b: "is_bounded_hashcode S seq bhc"
<     assumes c: "is_valid_def_hm_size TYPE('statei) hms"
<     assumes d: "(seq, HOL.eq) \<in> S \<rightarrow> S \<rightarrow> bool_rel"
<     assumes e: "(Ai, A) \<in> \<langle>Id, S\<rangle> nbai_nba_rel"
<   begin
< 
<     definition f' where "f' \<equiv> SOME f'.
<       (to_nbaei_impl seq bhc hms Ai, nbae_image (the \<circ> f') (nba_nbae A)) \<in> \<langle>Id, nat_rel\<rangle> nbaei_nbae_rel \<and>
<       dom f' = nodes A \<and> inj_on f' (nodes A)"
< 
<     lemma 1: "\<exists> f'. (to_nbaei_impl seq bhc hms Ai, nbae_image (the \<circ> f') (nba_nbae A)) \<in>
<       \<langle>Id, nat_rel\<rangle> nbaei_nbae_rel \<and> dom f' = nodes A \<and> inj_on f' (nodes A)"
<       using to_nbaei_impl_refine''[
<         OF a b c d e,
<         unfolded op_set_enumerate_def bind_RES_RETURN_eq,
<         THEN nres_relD,
<         THEN RETURN_ref_SPECD]
<       by force
< 
<     lemma f'_refine: "(to_nbaei_impl seq bhc hms Ai, nbae_image (the \<circ> f') (nba_nbae A)) \<in>
<       \<langle>Id, nat_rel\<rangle> nbaei_nbae_rel" using someI_ex[OF 1, folded f'_def] by auto
<     lemma f'_dom: "dom f' = nodes A" using someI_ex[OF 1, folded f'_def] by auto
<     lemma f'_inj: "inj_on f' (nodes A)" using someI_ex[OF 1, folded f'_def] by auto
< 
<     definition f where "f \<equiv> the \<circ> f'"
<     definition g where "g = inv_into (nodes A) f"
<     lemma inj_f[intro!, simp]: "inj_on f (nodes A)"
<       using f'_inj f'_dom unfolding f_def by (simp add: inj_on_map_the)
<     lemma inj_g[intro!, simp]: "inj_on g (f ` nodes A)"
<       unfolding g_def by (simp add: inj_on_inv_into)
< 
<     definition rel where "rel \<equiv> {(f p, p) |p. p \<in> nodes A}"
<     lemma rel_alt_def: "rel = (br f (\<lambda> p. p \<in> nodes A))\<inverse>"
<       unfolding rel_def by (auto simp: in_br_conv)
<     lemma rel_inv_def: "rel = br g (\<lambda> k. k \<in> f ` nodes A)"
<       unfolding rel_alt_def g_def by (auto simp: in_br_conv)
<     lemma rel_domain[simp]: "Domain rel = f ` nodes A" unfolding rel_def by force
<     lemma rel_range[simp]: "Range rel = nodes A" unfolding rel_def by auto
<     lemma [intro!, simp]: "bijective rel" unfolding rel_inv_def by (simp add: bijective_alt)
<     lemma [simp]: "Id_on (f ` nodes A) O rel = rel" unfolding rel_def by auto
<     lemma [simp]: "rel O Id_on (nodes A) = rel" unfolding rel_def by auto
< 
<     lemma [param]: "(f, f) \<in> Id_on (Range rel) \<rightarrow> Id_on (Domain rel)" unfolding rel_alt_def by auto
<     lemma [param]: "(g, g) \<in> Id_on (Domain rel) \<rightarrow> Id_on (Range rel)" unfolding rel_inv_def by auto
<     lemma [param]: "(id, f) \<in> rel \<rightarrow> Id_on (Domain rel)" unfolding rel_alt_def by (auto simp: in_br_conv)
<     lemma [param]: "(f, id) \<in> Id_on (Range rel) \<rightarrow> rel" unfolding rel_alt_def by (auto simp: in_br_conv)
<     lemma [param]: "(id, g) \<in> Id_on (Domain rel) \<rightarrow> rel" unfolding rel_inv_def by (auto simp: in_br_conv)
<     lemma [param]: "(g, id) \<in> rel \<rightarrow> Id_on (Range rel)" unfolding rel_inv_def by (auto simp: in_br_conv)
< 
<     lemma to_nbaei_impl_refine':
<       "(to_nbaei_impl seq bhc hms Ai, to_nbaei A) \<in> \<langle>Id_on (alphabet A), rel\<rangle> nbaei_nba_rel"
<     proof -
<       have "(nbae_nba (nbaei_nbae (to_nbaei_impl seq bhc hms Ai)), nbae_nba (id (nbae_image f (nba_nbae A)))) \<in>
<         \<langle>Id, nat_rel\<rangle> nba_rel" using f'_refine[folded f_def] by parametricity auto
<       also have "(nbae_nba (id (nbae_image f (nba_nbae A))), nbae_nba (id (nbae_image id (nba_nbae A)))) \<in>
<         \<langle>Id_on (alphabet A), rel\<rangle> nba_rel" using nba_rel_eq by parametricity auto
<       also have "nbae_nba (id (nbae_image id (nba_nbae A))) = (nbae_nba \<circ> nba_nbae) A" by simp
<       also have "(\<dots>, id A) \<in> \<langle>Id_on (alphabet A), Id_on (nodes A)\<rangle> nba_rel" by parametricity
<       also have "id A = to_nbaei A" unfolding to_nbaei_def by simp
<       finally show ?thesis unfolding nbaei_nba_rel_def by simp
<     qed
< 
<   end
244,249c212,260
<       assumes "(Ai, A) \<in> \<langle>Id, S\<rangle> nbai_nba_rel"
<       shows "(to_nbaei_impl seq bhc hms Ai,
<         (OP to_nbaei ::: \<langle>Id, S\<rangle> nbai_nba_rel \<rightarrow>
<         \<langle>Id_on (alphabet A), rel Ai A seq bhc hms\<rangle> nbaei_nba_rel) $ A) \<in>
<         \<langle>Id_on (alphabet A), rel Ai A seq bhc hms\<rangle> nbaei_nba_rel"
<       using to_nbaei_impl_refine' assms unfolding autoref_tag_defs by this
---
>       assumes "(Ai, A) \<in> \<langle>L, S\<rangle> nbai_nba_rel"
>       shows "(RETURN (to_nbaei_impl seq bhc hms Ai),
>         (OP op_translate ::: \<langle>L, S\<rangle> nbai_nba_rel \<rightarrow> \<langle>\<langle>L, nat_rel\<rangle> nbaei_nbae_rel\<rangle> nres_rel) $ A) \<in>
>         \<langle>\<langle>L, nat_rel\<rangle> nbaei_nbae_rel\<rangle> nres_rel"
>     proof -
>       have 1: "finite (alphabet A)"
>         using nbai_nba_param(2)[param_fo, OF assms(5)] list_set_rel_finite
>         unfolding finite_set_rel_def by auto
>       note to_nbaei_impl.refine[OF assms[unfolded autoref_tag_defs]]
>       also have "(do {
>           let N = nodes A;
>           f \<leftarrow> op_set_enumerate N;
>           ASSERT (dom f = N);
>           ASSERT (\<forall> p \<in> initial A. f p \<noteq> None);
>           ASSERT (\<forall> a \<in> alphabet A. \<forall> p \<in> dom f. \<forall> q \<in> transition A a p. f q \<noteq> None);
>           T \<leftarrow> trans_algo N (alphabet A) (transition A) (\<lambda> x. the (f x));
>           RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> N. accepting A p}))
>         }, do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           T \<leftarrow> SPEC (HOL.eq (trans_spec A (\<lambda> x. the (f x))));
>           RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> nodes A. accepting A p}))
>         }) \<in> \<langle>Id\<rangle> nres_rel"
>         unfolding Let_def comp_apply op_set_enumerate_def using assms(1) 1
>         by (refine_vcg vcg0[OF trans_algo_refine]) (auto intro!: inj_on_map_the[unfolded comp_apply])
>       also have "(do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           T \<leftarrow> SPEC (HOL.eq (trans_spec A (\<lambda> x. the (f x))));
>           RETURN (nbae (alphabet A) ((\<lambda> x. the (f x)) ` initial A) T ((\<lambda> x. the (f x)) ` {p \<in> nodes A. accepting A p}))
>         }, do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           RETURN (nbae_image (the \<circ> f) (nba_nbae A))
>         }) \<in> \<langle>Id\<rangle> nres_rel"
>         unfolding trans_spec_def nbae_image_nba_nbae by refine_vcg force
>       also have "(do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           RETURN (nbae_image (the \<circ> f) (nba_nbae A))
>         }, do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           RETURN (nba_nbae (nba_image (the \<circ> f) A))
>         }) \<in> \<langle>Id\<rangle> nres_rel"
>         unfolding op_set_enumerate_def by (refine_vcg) (simp add: inj_on_map_the nba_image_nbae)
>       also have "(do {
>           f \<leftarrow> op_set_enumerate (nodes A);
>           RETURN (nba_nbae (nba_image (the \<circ> f) A))
>         }, op_translate A) \<in> \<langle>Id\<rangle> nres_rel"
>         unfolding op_set_enumerate_def op_translate_def
>         by (refine_vcg) (metis Collect_mem_eq inj_on_map_the subset_Collect_conv)
>       finally show ?thesis unfolding nres_rel_comp by simp
>     qed
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA: NGBA_Algorithms.thy
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA: NGBA_Implement.thy
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA: NGBA_Refine.thy
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NBA: NGBA.thy
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata: NBTA
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Automata/NFA/NFA.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata/NFA/NFA.thy
4,8c4
< imports
<   "../../Basic/Sequence_Zip"
<   "../../Transition_Systems/Transition_System"
<   "../../Transition_Systems/Transition_System_Extra"
<   "../../Transition_Systems/Transition_System_Construction"
---
> imports "../Nondeterministic"
11,67c7,11
<   record ('label, 'state) nfa =
<     succ :: "'label \<Rightarrow> 'state \<Rightarrow> 'state set"
<     initial :: "'state set"
<     accepting :: "'state set"
< 
<   global_interpretation nfa: transition_system_initial
<     "\<lambda> a p. snd a" "\<lambda> a p. snd a \<in> succ A (fst a) p" "\<lambda> p. p \<in> initial A"
<     for A
<     defines path = nfa.path and run = nfa.run and reachable = nfa.reachable and nodes = nfa.nodes
<     by this
< 
<   abbreviation "target \<equiv> nfa.target"
<   abbreviation "states \<equiv> nfa.states"
<   abbreviation "trace \<equiv> nfa.trace"
< 
<   abbreviation successors :: "('label, 'state, 'more) nfa_scheme \<Rightarrow> 'state \<Rightarrow> 'state set" where
<     "successors \<equiv> nfa.successors TYPE('label) TYPE('more)"
< 
<   lemma states_alt_def: "states r p = map snd r" by (induct r arbitrary: p) (auto)
<   lemma trace_alt_def: "trace r p = smap snd r" by (coinduction arbitrary: r p) (auto)
< 
<   definition language :: "('label, 'state) nfa \<Rightarrow> 'label list set" where
<     "language A \<equiv> {map fst r |r p. path A r p \<and> p \<in> initial A \<and> target r p \<in> accepting A}"
< 
<   lemma language[intro]:
<     assumes "path A (w || r) p" "p \<in> initial A" "target (w || r) p \<in> accepting A" "length w = length r"
<     shows "w \<in> language A"
<     using assms unfolding language_def by (force iff: split_zip_ex)
<   lemma language_elim[elim]:
<     assumes "w \<in> language A"
<     obtains r p
<     where "path A (w || r) p" "p \<in> initial A" "target (w || r) p \<in> accepting A" "length w = length r"
<     using assms unfolding language_def by (force iff: split_zip_ex)
< 
<   definition product :: "('label, 'state\<^sub>1) nfa \<Rightarrow> ('label, 'state\<^sub>2) nfa \<Rightarrow>
<     ('label, 'state\<^sub>1 \<times> 'state\<^sub>2) nfa" where
<     "product A B \<equiv>
<     \<lparr>
<       succ = \<lambda> a (p\<^sub>1, p\<^sub>2). succ A a p\<^sub>1 \<times> succ B a p\<^sub>2,
<       initial = initial A \<times> initial B,
<       accepting = accepting A \<times> accepting B
<     \<rparr>"
< 
<   lemma product_simps[simp]:
<     "succ (product A B) a (p\<^sub>1, p\<^sub>2) = succ A a p\<^sub>1 \<times> succ B a p\<^sub>2"
<     "initial (product A B) = initial A \<times> initial B"
<     "accepting (product A B) = accepting A \<times> accepting B"
<     unfolding product_def by simp+
< 
<   lemma product_target[simp]:
<     assumes "length w = length r\<^sub>1" "length r\<^sub>1 = length r\<^sub>2"
<     shows "target (w || r\<^sub>1 || r\<^sub>2) (p\<^sub>1, p\<^sub>2) = (target (w || r\<^sub>1) p\<^sub>1, target (w || r\<^sub>2) p\<^sub>2)"
<     using assms by (induct arbitrary: p\<^sub>1 p\<^sub>2 rule: list_induct3) (auto)
<   lemma product_path[iff]:
<     assumes "length w = length r\<^sub>1" "length r\<^sub>1 = length r\<^sub>2"
<     shows "path (product A B) (w || r\<^sub>1 || r\<^sub>2) (p\<^sub>1, p\<^sub>2) \<longleftrightarrow> path A (w || r\<^sub>1) p\<^sub>1 \<and> path B (w || r\<^sub>2) p\<^sub>2"
<     using assms by (induct arbitrary: p\<^sub>1 p\<^sub>2 rule: list_induct3) (auto)
---
>   datatype ('label, 'state) nfa = nfa
>     (alphabet: "'label set")
>     (initial: "'state set")
>     (transition: "'label \<Rightarrow> 'state \<Rightarrow> 'state set")
>     (accepting: "'state pred")
69,70c13,40
<   lemma product_language[simp]: "language (product A B) = language A \<inter> language B"
<     by (fastforce iff: split_zip)
---
>   global_interpretation nfa: automaton nfa alphabet initial transition accepting
>     defines path = nfa.path and run = nfa.run and reachable = nfa.reachable and nodes = nfa.nodes
>     by unfold_locales auto
>   global_interpretation nfa: automaton_path nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     defines language = nfa.language
>     by standard
> 
>   abbreviation target where "target \<equiv> nfa.target"
>   abbreviation states where "states \<equiv> nfa.states"
>   abbreviation trace where "trace \<equiv> nfa.trace"
>   abbreviation successors where "successors \<equiv> nfa.successors TYPE('label)"
> 
>   (* TODO: going from target to last requires states as intermediate step, used in other places too *)
>   global_interpretation nfa: automaton_intersection_path
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     "\<lambda> c\<^sub>1 c\<^sub>2 (p, q). c\<^sub>1 p \<and> c\<^sub>2 q"
>     defines intersect = nfa.product
>     by (unfold_locales) (auto simp: zip_eq_Nil_iff)
> 
>   global_interpretation nfa: automaton_union_path
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     nfa alphabet initial transition accepting "\<lambda> P w r p. P (last (p # r))"
>     case_sum
>     defines union = nfa.sum
>     by (unfold_locales) (auto simp: last_map)
72c42
< end
---
> end
\ No newline at end of file
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Automata: Nondeterministic.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Basic/Acceptance.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic/Acceptance.thy
2c2
< imports "Sequence_LTL"
---
> imports Sequence_LTL
8d7
<   type_synonym 'a degen = "'a \<times> nat"
24c23
<     "gen P xs w \<equiv> \<forall> x \<in> set xs. P x w"
---
>     "gen P cs w \<equiv> \<forall> c \<in> set cs. P c w"
27,28c26,27
<     assumes "\<And> x. x \<in> set xs \<Longrightarrow> P x w"
<     shows "gen P xs w"
---
>     assumes "\<And> c. c \<in> set cs \<Longrightarrow> P c w"
>     shows "gen P cs w"
31,32c30,31
<     assumes "gen P xs w"
<     obtains "\<And> x. x \<in> set xs \<Longrightarrow> P x w"
---
>     assumes "gen P cs w"
>     obtains "\<And> c. c \<in> set cs \<Longrightarrow> P c w"
36c35
<     "cogen P xs w \<equiv> \<exists> x \<in> set xs. P x w"
---
>     "cogen P cs w \<equiv> \<exists> c \<in> set cs. P c w"
39,40c38,39
<     assumes "x \<in> set xs" "P x w"
<     shows "cogen P xs w"
---
>     assumes "c \<in> set cs" "P c w"
>     shows "cogen P cs w"
43,45c42,44
<     assumes "cogen P xs w"
<     obtains x
<     where "x \<in> set xs" "P x w"
---
>     assumes "cogen P cs w"
>     obtains c
>     where "c \<in> set cs" "P c w"
46a46,47
> 
>   lemma cogen_alt_def: "cogen P cs w \<longleftrightarrow> \<not> gen (\<lambda> c w. Not (P c w)) cs w" by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Basic/Basic.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic/Basic.thy
12a13,16
>   lemma prod_singleton:
>     "fst ` A = {x} \<Longrightarrow> A = fst ` A \<times> snd ` A"
>     "snd ` A = {y} \<Longrightarrow> A = fst ` A \<times> snd ` A"
>     by force+
23,24c27
<     assume "finite A"
<     then show "False" using assms by (induct rule: finite_psubset_induct) (auto)
---
>     show "False" if "finite A" using that assms by (induct rule: finite_psubset_induct) (auto)
Only in ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic: Degeneralization.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Basic/Sequence_LTL.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic/Sequence_LTL.thy
11c11
<   text \<open>Avoid destroying the constant @{term holds} prematurely.\<close>
---
>   text \<open>Avoid destroying the constant @{const holds} prematurely.\<close>
13a14,17
>   (* TODO: these cannot be applied successively to simplify infs due to introduction of \<circ>
>     avoid or add extra simplification rules for infs *)
>   lemma ev_smap[iff]: "ev P (smap f w) \<longleftrightarrow> ev (P \<circ> smap f) w" using ev_smap unfolding comp_apply by this
>   lemma alw_smap[iff]: "alw P (smap f w) \<longleftrightarrow> alw (P \<circ> smap f) w" using alw_smap unfolding comp_apply by this
16c20
<   lemmas [iff] = ev_sconst alw_sconst ev_smap alw_smap hld_smap'
---
>   lemmas [iff] = ev_sconst alw_sconst hld_smap'
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Basic/Sequence.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic/Sequence.thy
32a33,40
>   lemma ball_bind[iff]: "Ball (set (xs \<bind> f)) P \<longleftrightarrow> (\<forall> x \<in> set xs. \<forall> y \<in> set (f x). P y)"
>     unfolding set_list_bind by simp
>   lemma bex_bind[iff]: "Bex (set (xs \<bind> f)) P \<longleftrightarrow> (\<exists> x \<in> set xs. \<exists> y \<in> set (f x). P y)"
>     unfolding set_list_bind by simp
> 
>   lemma list_choice: "list_all (\<lambda> x. \<exists> y. P x y) xs \<longleftrightarrow> (\<exists> ys. list_all2 P xs ys)"
>     by (induct xs) (auto simp: list_all2_Cons1)
> 
53a62,65
>   lemma listset_finite'[intro]:
>     assumes "list_all finite XS"
>     shows "finite (listset XS)"
>     using infinite_imp_nonempty assms by blast
266a279,280
>   lemma streams_int[simp]: "streams (A \<inter> B) = streams A \<inter> streams B" by (auto iff: streams_iff_sset)
>   lemma streams_Int[simp]: "streams (\<Inter> S) = \<Inter> (streams ` S)" by (auto iff: streams_iff_sset)
273c287
<   subsection \<open>The @{term scan} Function\<close>
---
>   subsection \<open>The scan Function\<close>
290a305
>   (* TODO: figure out how this is used, should it be a simp rule? or flipped? also target_alt_def *)
292a308,309
>   lemma scan_butlast[simp]: "scan f (butlast xs) a = butlast (scan f xs a)"
>     by (induct xs arbitrary: a) (auto simp: butlast.simps)
333a351,370
> 
>   subsection \<open>Transposing Streams\<close>
> 
>   primcorec (transfer) stranspose :: "'a stream list \<Rightarrow> 'a list stream" where
>     "stranspose ws = map shd ws ## stranspose (map stl ws)"
> 
>   lemma stranspose_eq_scons[iff]: "stranspose ws = a ## w \<longleftrightarrow> map shd ws = a \<and> stranspose (map stl ws) = w"
>     using stranspose.ctr stream.inject by metis
>   lemma scons_eq_stranspose[iff]: "a ## w = stranspose ws \<longleftrightarrow> a = map shd ws \<and> w = stranspose (map stl ws)"
>     using stranspose.ctr stream.inject by metis
> 
>   lemma stranspose_nil[simp]: "stranspose [] = sconst []" by coinduction auto
>   lemma stranspose_cons[simp]: "stranspose (w # ws) = smap2 Cons w (stranspose ws)"
>     by (coinduction arbitrary: w ws) (metis list.simps(9) smap2.simps stranspose.simps stream.sel)
> 
>   lemma snth_stranspose[simp]: "stranspose ws !! k = map (\<lambda> w. w !! k) ws" by (induct k arbitrary: ws) (auto)
>   lemma stranspose_nth[simp]:
>     assumes "k < length ws"
>     shows "smap (\<lambda> xs. xs ! k) (stranspose ws) = ws ! k"
>     using assms by (auto intro: eqI_snth)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Basic/Sequence_Zip.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Basic/Sequence_Zip.thy
4c4
< imports "Sequence"
---
> imports "Sequence_LTL"
34a35,50
>   lemma list_rel_pred_zip: "list_all2 P xs ys \<longleftrightarrow> length xs = length ys \<and> list_all (case_prod P) (xs || ys)"
>     unfolding list_all2_conv_all_nth list_all_length by auto
> 
>   lemma list_choice_zip: "list_all (\<lambda> x. \<exists> y. P x y) xs \<longleftrightarrow>
>     (\<exists> ys. length ys = length xs \<and> list_all (case_prod P) (xs || ys))"
>     unfolding list_choice list_rel_pred_zip by metis
>   lemma list_choice_pair: "list_all (\<lambda> xy. case_prod (\<lambda> x y. \<exists> z. P x y z) xy) (xs || ys) \<longleftrightarrow>
>     (\<exists> zs. length zs = min (length xs) (length ys) \<and> list_all (\<lambda> (x, y, z). P x y z) (xs || ys || zs))"
>   proof -
>     have 1: "list_all (\<lambda> (xy, z). case xy of (x, y) \<Rightarrow> P x y z) ((xs || ys) || zs) \<longleftrightarrow>
>       list_all (\<lambda> (x, y, z). P x y z) (xs || ys || zs)" for zs
>       unfolding zip_assoc list.pred_map by (auto intro!: list.pred_cong)
>     have 2: "(\<lambda> (x, y). \<exists> z. P x y z) = (\<lambda> xy. \<exists> z. case xy of (x, y) \<Rightarrow> P x y z)" by auto
>     show ?thesis unfolding list_choice_zip 1 2 by force
>   qed
> 
66a83,84
>   lemma smap_szip_same: "smap f (xs ||| xs) = smap (\<lambda> x. f (x, x)) xs" by (coinduction arbitrary: xs) (auto)
> 
70a89,98
>   lemma szip_smap_both: "smap f xs ||| smap g ys = smap (map_prod f g) (xs ||| ys)" by (coinduction arbitrary: xs ys) (auto)
>   lemma szip_smap_left: "smap f xs ||| ys = smap (apfst f) (xs ||| ys)" by (coinduction arbitrary: xs ys) (auto)
>   lemma szip_smap_right: "xs ||| smap f ys = smap (apsnd f) (xs ||| ys)" by (coinduction arbitrary: xs ys) (auto)
>   lemmas szip_smap_fold = szip_smap_both szip_smap_left szip_smap_right
> 
>   lemma szip_sconst_smap_fst: "sconst a ||| xs = smap (Pair a) xs"
>     by (coinduction arbitrary: xs) (auto)
>   lemma szip_sconst_smap_snd: "xs ||| sconst a = smap (prod.swap \<circ> Pair a) xs"
>     by (coinduction arbitrary: xs) (auto)
> 
128c156,171
< end
---
>   lemma infs_szip_fst[iff]: "infs (P \<circ> fst) (u ||| v) \<longleftrightarrow> infs P u"
>   proof -
>     have "infs (P \<circ> fst) (u ||| v) \<longleftrightarrow> infs P (smap fst (u ||| v))"
>       by (simp add: comp_def del: szip_smap_fst)
>     also have "\<dots> \<longleftrightarrow> infs P u" by simp
>     finally show ?thesis by this
>   qed
>   lemma infs_szip_snd[iff]: "infs (P \<circ> snd) (u ||| v) \<longleftrightarrow> infs P v"
>   proof -
>     have "infs (P \<circ> snd) (u ||| v) \<longleftrightarrow> infs P (smap snd (u ||| v))"
>       by (simp add: comp_def del: szip_smap_snd)
>     also have "\<dots> \<longleftrightarrow> infs P v" by simp
>     finally show ?thesis by this
>   qed
> 
> end
\ No newline at end of file
Only in ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Transition_Systems: Transition_System_Degeneralization.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Transition_Systems_and_Automata/Transition_Systems/Transition_System_Extra.thy ../../AFPs/afp-2020/thys/Transition_Systems_and_Automata/Transition_Systems/Transition_System_Extra.thy
37a38,40
>     lemma run_alt_def_snth: "run r p \<longleftrightarrow> (\<forall> k. enabled (r !! k) (target (stake k r) p))"
>       using snth_run run_snth by blast
> 
47,79d49
< 
<     lemma infs_trace_coinduct[case_names infs_trace, consumes 1]:
<       assumes "R r p"
<       assumes "\<And> r p. R r p \<Longrightarrow>
<         (\<exists> u s. r = u @- s \<and> P (target u p)) \<and>
<         (\<exists> u s. r = u @- s \<and> u \<noteq> [] \<and> R s (target u p))"
<       shows "infs P (trace r p)"
<     proof -
<       have "infs P (p ## trace r p)"
<       using assms(1)
<       proof (coinduction arbitrary: r p)
<         case infs
<         obtain u r\<^sub>1 v r\<^sub>2 where 1:
<           "r = u @- r\<^sub>1" "P (target u p)"
<           "r = v @- r\<^sub>2" "v \<noteq> []" "R r\<^sub>2 (target v p)"
<           using assms(2) infs by blast
<         show ?case
<         unfolding ev_stl_alt_def
<         proof (intro exI conjI bexI)
<           show "P (target u p)" using 1(2) by this
<           show "target u p \<in> sset (p ## trace r p)" unfolding target_alt_def 1(1) by simp
<           show "R r\<^sub>2 (target v p)" using 1(5) by this
<           have "trace r p = states v p @- trace r\<^sub>2 (target v p)" unfolding 1(3) by simp
<           also have "states v p = butlast (states v p) @ [target v p]"
<             unfolding target_alt_def using 1(4) by simp
<           finally show "p ## trace r p =
<             (p # butlast (states v p)) @- target v p ## trace r\<^sub>2 (target v p)" by simp
<           show "p # butlast (states v p) \<noteq> []" by simp
<           show "target v p ## trace r\<^sub>2 (target v p) = target v p ## trace r\<^sub>2 (target v p)" by simp
<         qed
<       qed
<       then show ?thesis by simp
<     qed
==========
Triangle
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Triangle/Angles.thy ../../AFPs/afp-2020/thys/Triangle/Angles.thy
11c11
<   "HOL-Analysis.Analysis"
---
>   "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Triangle/Triangle.thy ../../AFPs/afp-2020/thys/Triangle/Triangle.thy
12,13d11
<   Complex_Main
<   "HOL-Analysis.Topology_Euclidean_Space"
==========
UpDown_Scheme
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UpDown_Scheme/Grid_Point.thy ../../AFPs/afp-2020/thys/UpDown_Scheme/Grid_Point.thy
4c4
< imports "HOL-Analysis.Analysis"
---
> imports "HOL-Analysis.Multivariate_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UpDown_Scheme/Triangular_Function.thy ../../AFPs/afp-2020/thys/UpDown_Scheme/Triangular_Function.thy
4c4,6
< imports "HOL-Analysis.Analysis" Grid
---
> imports
>  "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
>  Grid
==========
UTP
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/toolkit/Countable_Set_Extra.thy ../../AFPs/afp-2020/thys/UTP/toolkit/Countable_Set_Extra.thy
104,106c104,106
< lift_definition cINTER :: "'a cset \<Rightarrow> ('a \<Rightarrow> 'b cset) \<Rightarrow> 'b cset" is
< "\<lambda> A f. if (A = {}) then {} else INTER A f"
<   by (auto)
---
> lift_definition cInter :: "'a cset cset \<Rightarrow> 'a cset"  ("\<Inter>\<^sub>c_" [900] 900)
>   is "\<lambda>A. if A = {} then {} else \<Inter> A"
>   using countable_INT [of _ _ id] by auto
108,109c108,109
< definition cInter :: "'a cset cset \<Rightarrow> 'a cset" ("\<Inter>\<^sub>c_" [900] 900) where
< "\<Inter>\<^sub>c A = cINTER A id"
---
> abbreviation (input) cINTER :: "'a cset \<Rightarrow> ('a \<Rightarrow> 'b cset) \<Rightarrow> 'b cset"
>   where "cINTER A f \<equiv> cInter (cimage f A)"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/utp/utp_alphabet.thy ../../AFPs/afp-2020/thys/UTP/utp/utp_alphabet.thy
287c287
<   by (simp add: in_var_def prod_as_plus lens_comp_assoc fst_lens_plus)
---
>   by (simp add: in_var_def prod_as_plus lens_comp_assoc[THEN sym] fst_lens_plus)
291c291
<   apply (simp add: out_var_def prod_as_plus lens_comp_assoc)
---
>   apply (simp add: out_var_def prod_as_plus lens_comp_assoc[THEN sym])
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/utp/utp_expr.thy ../../AFPs/afp-2020/thys/UTP/utp/utp_expr.thy
178,179d177
<   
< abbreviation (input) "ulens_override x f g \<equiv> lens_override f g x"
201c199
<   "_ulens_ovrd f g a" => "CONST bop (CONST ulens_override a) f g"
---
>   "_ulens_ovrd f g a" => "CONST bop (CONST lens_override a) f g"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/utp/utp_healthy.thy ../../AFPs/afp-2020/thys/UTP/utp/utp_healthy.thy
63c63
<   "A \<subseteq> \<lbrakk>H\<rbrakk>\<^sub>H \<Longrightarrow> SUPREMUM A H = \<Sqinter> A"
---
>   "A \<subseteq> \<lbrakk>H\<rbrakk>\<^sub>H \<Longrightarrow> Sup (H ` A) = \<Sqinter> A"
67c67
<   "A \<subseteq> \<lbrakk>H\<rbrakk>\<^sub>H \<Longrightarrow> INFIMUM A H = \<Squnion> A"
---
>   "A \<subseteq> \<lbrakk>H\<rbrakk>\<^sub>H \<Longrightarrow> Inf (H ` A) = \<Squnion> A"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/utp/utp_pred.thy ../../AFPs/afp-2020/thys/UTP/utp/utp_pred.thy
190c190
<   is "\<lambda> PS A. INF P:PS. P(A)" .
---
>   is "\<lambda> PS A. INF P\<in>PS. P(A)" .
192c192
<   is "\<lambda> PS A. SUP P:PS. P(A)" .
---
>   is "\<lambda> PS A. SUP P\<in>PS. P(A)" .
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/UTP/utp/utp_rel_laws.thy ../../AFPs/afp-2020/thys/UTP/utp/utp_rel_laws.thy
723c723
<   moreover have "\<Sqinter> (P ` insert 0 {1..}) = P(0) \<sqinter> SUPREMUM {1..} P"
---
>   moreover have "\<Sqinter> (P ` insert 0 {1..}) = P(0) \<sqinter> \<Sqinter> (P ` {1..})"
725c725
<   moreover have "SUPREMUM {1..} P = (\<Sqinter>i. P(i+1))"
---
>   moreover have "\<Sqinter> (P ` {1..}) = (\<Sqinter>i. P(i+1))"
==========
VerifyThis2018
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/VerifyThis2018/lib/Exc_Nres_Monad.thy ../../AFPs/afp-2020/thys/VerifyThis2018/lib/Exc_Nres_Monad.thy
38,39c38,39
< notation (output) bind_doE (infixr "\<bind>" 54)
< notation (ASCII output) bind_doE (infixr ">>=" 54)
---
> notation (output) bind_doE (infixl "\<bind>" 54)
> notation (ASCII output) bind_doE (infixl ">>=" 54)
50c50
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr "\<then>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl "\<then>" 54)
54c54
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr ">>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl ">>" 54)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/VerifyThis2018/lib/VTcomp.thy ../../AFPs/afp-2020/thys/VerifyThis2018/lib/VTcomp.thy
65,66c65,66
< notation (output) bind_doN (infixr "\<bind>" 54)
< notation (ASCII output) bind_doN (infixr ">>=" 54)
---
> notation (output) bind_doN (infixl "\<bind>" 54)
> notation (ASCII output) bind_doN (infixl ">>=" 54)
76c76
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr "\<then>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl "\<then>" 54)
80c80
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr ">>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl ">>" 54)
==========
VerifyThis2019
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/VerifyThis2019/lib/Exc_Nres_Monad.thy ../../AFPs/afp-2020/thys/VerifyThis2019/lib/Exc_Nres_Monad.thy
38,39c38,39
< notation (output) bind_doE (infixr "\<bind>" 54)
< notation (ASCII output) bind_doE (infixr ">>=" 54)
---
> notation (output) bind_doE (infixl "\<bind>" 54)
> notation (ASCII output) bind_doE (infixl ">>=" 54)
50c50
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr "\<then>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl "\<then>" 54)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/VerifyThis2019/lib/VTcomp.thy ../../AFPs/afp-2020/thys/VerifyThis2019/lib/VTcomp.thy
68,69c68,69
< notation (output) bind_doN (infixr "\<bind>" 54)
< notation (ASCII output) bind_doN (infixr ">>=" 54)
---
> notation (output) bind_doN (infixl "\<bind>" 54)
> notation (ASCII output) bind_doN (infixl ">>=" 54)
79c79
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr "\<then>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl "\<then>" 54)
83c83
<   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixr ">>" 54)
---
>   "_thenM" :: "['a, 'b] \<Rightarrow> 'c" (infixl ">>" 54)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/VerifyThis2019/Parallel_Multiset_Fold.thy ../../AFPs/afp-2020/thys/VerifyThis2019/Parallel_Multiset_Fold.thy
108c108
<     apply (rule order_class.acyclicI_order[where f = "\<lambda>x. n - card (dom x)"])
---
>     apply (rule preorder_class.acyclicI_order[where f = "\<lambda>x. n - card (dom x)"])
==========
Weight_Balanced_Trees
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Weight_Balanced_Trees/Weight_Balanced_Trees.thy ../../AFPs/afp-2020/thys/Weight_Balanced_Trees/Weight_Balanced_Trees.thy
15c15
< lemma neq_Leaf2_iff: "t \<noteq> Leaf \<longleftrightarrow> (\<exists>n l a r. t = Node n l a r)"
---
> lemma neq_Leaf2_iff: "t \<noteq> Leaf \<longleftrightarrow> (\<exists>l a n r. t = Node l (a,n) r)"
18c18
< type_synonym 'a wbt = "('a,nat) tree"
---
> type_synonym 'a wbt = "('a * nat) tree"
22c22
< "size_wbt (Node _ _ n _) = n"
---
> "size_wbt (Node _ (_, n) _) = n"
27c27
< "N l a r = Node l a (size_wbt l + size_wbt r + 1) r"
---
> "N l a r = Node l (a, size_wbt l + size_wbt r + 1) r"
38c38
< "rot2 A a (Node B1 b _ B2) c C = N (N A a B1) b (N B2 c C)"
---
> "rot2 A a (Node B1 (b,_) B2) c C = N (N A a B1) b (N B2 c C)"
112c112
< "wbt (Node l _ n r) =
---
> "wbt (Node l (_, n) r) =
124c124
< "rotateL A a (Node B b _ C) =
---
> "rotateL A a (Node B (b, _) C) =
131c131
< "rotateR (Node A a _ B) b C =
---
> "rotateR (Node A (a, _) B) b C =
138,139c138,139
< "insert x Leaf = Node Leaf x 1 Leaf" |
< "insert x (Node l a n r) =
---
> "insert x Leaf = Node Leaf (x, 1) Leaf" |
> "insert x (Node l (a, n) r) =
143c143
<       EQ \<Rightarrow> Node l a n r )"
---
>       EQ \<Rightarrow> Node l (a, n) r )"
146c146
< "split_min (Node l a _ r) =
---
> "split_min (Node l (a, _) r) =
150c150
< "del_max (Node l a _ r) =
---
> "del_max (Node l (a, _) r) =
165c165
< "delete x (Node l a _ r) =
---
> "delete x (Node l (a, _) r) =
256c256
< by (induction t) (auto simp: not_Leaf_if_not_balanced1)
---
> by (induction t rule: tree2_induct) (auto simp: not_Leaf_if_not_balanced1)
261c261
< proof (induction t)
---
> proof (induction t rule: tree2_induct)
326c326
< proof (induction t)
---
> proof (induction t rule: tree2_induct)
342c342
<       then obtain k ll' al' rl' where [simp]: "?l' = (Node ll' al' k rl')"
---
>       then obtain k ll' al' rl' where [simp]: "?l' = (Node ll' (al', k) rl')"
350,351c350,351
<         then obtain k llr' alr' rlr' where [simp]: "rl' = (Node llr' alr' k rlr')"
<           using not_Leaf_if_not_single tree.exhaust by blast
---
>         then obtain k llr' alr' rlr' where [simp]: "rl' = (Node llr' (alr', k) rlr')"
>           using not_Leaf_if_not_single tree2_cases by blast
365c365
<       then obtain k lr' ar' rr' where [simp]: "?r' = (Node lr' ar' k rr')"
---
>       then obtain k lr' ar' rr' where [simp]: "?r' = (Node lr' (ar', k) rr')"
389c389
<   assumes "wbt (Node l a n r)" "wbt l'" "size l = size l' + 1"
---
>   assumes "wbt (Node l (a, n) r)" "wbt l'" "size l = size l' + 1"
400c400
<     then obtain k lr ar rr where [simp]: "r = Node lr ar k rr" by(meson neq_Leaf2_iff)
---
>     then obtain k lr ar rr where [simp]: "r = Node lr (ar, k) rr" by(meson neq_Leaf2_iff)
411c411
<       then obtain k2 llr alr rlr where [simp]: "lr = (Node llr alr k2 rlr)"
---
>       then obtain k2 llr alr rlr where [simp]: "lr = (Node llr (alr, k2) rlr)"
422c422
<   assumes "wbt (Node l a n r)" "wbt r'" "size r = size r' + 1"
---
>   assumes "wbt (Node l (a, n) r)" "wbt r'" "size r = size r' + 1"
433c433
<     then obtain k ll al rl where [simp]: "l = (Node ll al k rl)" by(meson neq_Leaf2_iff)
---
>     then obtain k ll al rl where [simp]: "l = (Node ll (al, k) rl)" by(meson neq_Leaf2_iff)
444c444
<       then obtain k lrl arl rrl where [simp]: "rl = (Node lrl arl k rrl)"
---
>       then obtain k lrl arl rrl where [simp]: "rl = (Node lrl (arl, k) rrl)"
458c458
<   proof (cases l)
---
>   proof (cases l rule: tree2_cases)
462,463c462,463
<     let ?l' = "snd (split_min (Node ll al n rl))"
<     have delBalanceL: "snd (split_min (Node l a m r)) = balanceL ?l' a r"
---
>     let ?l' = "snd (split_min (Node ll (al, n) rl))"
>     have delBalanceL: "snd (split_min (Node l (a, m) r)) = balanceL ?l' a r"
467c467
<       using Node size_split_min by fastforce
---
>       using Node size_split_min by (metis Suc_eq_plus1 neq_Leaf2_iff)
478c478
<   proof (cases r)
---
>   proof (cases r rule: tree2_cases)
482c482
<     then obtain r' where delMaxR: "r' = snd (del_max (Node lr ar n rr))"
---
>     then obtain r' where delMaxR: "r' = snd (del_max (Node lr (ar, n) rr))"
484c484
<     hence delBalanceR: "snd (del_max (Node l a m r)) = balanceR l a r'"
---
>     hence delBalanceR: "snd (del_max (Node l (a, m) r)) = balanceR l a r'"
496c496
< proof (induction t)
---
> proof (induction t rule: tree2_induct)
501c501
<   proof (cases "isin (Node l a n r) x")
---
>   proof (cases "isin (Node l (a, n) r) x")
525c525
<       hence xCombine: "delete x (Node l a n r) = combine l r" by simp
---
>       hence xCombine: "delete x (Node l (a, n) r) = combine l r" by simp
543c543
<           where [simp]: "l = (Node ll al kl rl)" "r = (Node lr ar kr rr)"
---
>           where [simp]: "l = (Node ll (al, kl) rl)" "r = (Node lr (ar, kr) rr)"
==========
Well_Quasi_Orders
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Well_Quasi_Orders/Minimal_Bad_Sequences.thy ../../AFPs/afp-2020/thys/Well_Quasi_Orders/Minimal_Bad_Sequences.thy
93c93
< interpretation min_elt_size?: minimal_element "measure_on size UNIV" A
---
> sublocale min_elt_size?: minimal_element "measure_on size UNIV" A
==========
Winding_Number_Eval
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Winding_Number_Eval/Cauchy_Index_Theorem.thy ../../AFPs/afp-2020/thys/Winding_Number_Eval/Cauchy_Index_Theorem.thy
8c8
<   "HOL-Analysis.Analysis"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
2583c2583
<       using Lim_eventually by auto
---
>       using tendsto_eventually by auto
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Algebraic.thy ../../AFPs/afp-2020/thys/Winding_Number_Eval/Missing_Algebraic.thy
10c10
<   "HOL-Analysis.Analysis"
---
>   "HOL-Complex_Analysis.Complex_Analysis"
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Analysis.thy ../../AFPs/afp-2020/thys/Winding_Number_Eval/Missing_Analysis.thy
7c7,8
< theory Missing_Analysis imports "HOL-Analysis.Analysis"
---
> theory Missing_Analysis
>   imports "HOL-Complex_Analysis.Complex_Analysis"
118,120c119
<     apply (auto intro!:contour_integral_eq simp add:field_simps)
<     apply (subst deriv_linear[of "-1",simplified])
<     by (simp add: minus_divide_right)
---
>     by (auto intro!:contour_integral_eq simp add:field_simps minus_divide_right)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Winding_Number_Eval/Missing_Topology.thy ../../AFPs/afp-2020/thys/Winding_Number_Eval/Missing_Topology.thy
7c7
< theory Missing_Topology imports "HOL-Analysis.Analysis"
---
> theory Missing_Topology imports "HOL-Analysis.Multivariate_Analysis"
182c182
<       by (meson linordered_field_class.sign_simps(42) pos_divide_le_eq)
---
>       by (auto simp add: field_simps)
184c184
<       by (metis linordered_field_class.sign_simps(24) real_affinity_le)
---
>       by (metis mult.commute real_affinity_le)
195c195
<       using linordered_field_class.sign_simps(42) neg_le_divide_eq by blast
---
>       using \<open>c < 0\<close> by (meson False diff_le_eq le_divide_eq)
257c257,258
<       by (metis linordered_field_class.sign_simps(24) real_le_affinity)  
---
>       apply auto
>       by (metis mult.commute real_le_affinity) 
265,266c266,267
<     subgoal unfolding eventually_at_bot_linorder filterlim_at_top 
<       by (meson linordered_field_class.sign_simps(42) neg_le_divide_eq)
---
>     subgoal unfolding eventually_at_bot_linorder filterlim_at_top
>       by (auto simp add: field_simps)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Winding_Number_Eval/Winding_Number_Eval_Examples.thy ../../AFPs/afp-2020/thys/Winding_Number_Eval/Winding_Number_Eval_Examples.thy
64c64
<     using order_asms by (metis diff_gt_0_iff_gt mult_pos_pos order.asym zero_less_mult_pos2)
---
>     using order_asms by (simp add: algebra_simps crossproduct_eq)
67c67
<     using order_asms by (metis diff_gt_0_iff_gt linordered_field_class.sign_simps(44) order.asym)
---
>     using order_asms by (simp add: algebra_simps crossproduct_eq)
70c70
<     using order_asms by (metis diff_less_0_iff_less linordered_field_class.sign_simps(44) order.asym)
---
>     using order_asms by (simp add: algebra_simps crossproduct_eq)
73c73
<     using order_asms by (metis diff_less_0_iff_less linordered_field_class.sign_simps(44) order.asym)
---
>     using order_asms by (simp add: algebra_simps crossproduct_eq)
==========
Word_Lib
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Aligned.thy ../../AFPs/afp-2020/thys/Word_Lib/Aligned.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
793c789
<   "m \<le> n \<Longrightarrow> is_aligned (x && ~~ mask n) m"
---
>   "m \<le> n \<Longrightarrow> is_aligned (x && ~~ (mask n)) m"
797,798c793
<   "unat (- (x :: ('a :: len) word))
<     = (if x = 0 then 0 else (2 ^ size x) - unat x)"
---
>   "unat (- (x :: 'a :: len word)) = (if x = 0 then 0 else 2 ^ size x - unat x)"
814c809
<     \<forall>n' \<ge> n. n' < LENGTH('a) \<longrightarrow> \<not> p !! n'\<rbrakk> \<Longrightarrow> x + p && ~~mask n = x"
---
>     \<forall>n' \<ge> n. n' < LENGTH('a) \<longrightarrow> \<not> p !! n'\<rbrakk> \<Longrightarrow> x + p && ~~ (mask n) = x"
846c841
<   "is_aligned p n \<Longrightarrow> p && ~~ mask n = p"
---
>   "is_aligned p n \<Longrightarrow> p && ~~ (mask n) = p"
863a859,892
> 
> lemma mask_zero:
>   "is_aligned x a \<Longrightarrow> x && mask a = 0"
>   by (metis is_aligned_mask)
> 
> lemma is_aligned_neg_mask_eq_concrete:
>   "\<lbrakk> is_aligned p n; msk && ~~(mask n) = ~~(mask n) \<rbrakk>
>    \<Longrightarrow> p && msk = p"
>   by (metis word_bw_assocs(1) word_bw_comms(1) is_aligned_neg_mask_eq)
> 
> lemma is_aligned_and_not_zero:
>   "\<lbrakk> is_aligned n k; n \<noteq> 0 \<rbrakk> \<Longrightarrow> 2 ^ k \<le> n"
>   using is_aligned_less_sz leI by blast
> 
> lemma is_aligned_and_2_to_k:
>   "(n && 2 ^ k - 1) = 0 \<Longrightarrow> is_aligned (n :: 'a :: len word) k"
>   by (simp add: is_aligned_mask mask_def)
> 
> lemma is_aligned_power2:
>   "b \<le> a \<Longrightarrow> is_aligned (2 ^ a) b"
>   by (metis is_aligned_triv is_aligned_weaken)
> 
> lemma aligned_sub_aligned':
>   "\<lbrakk> is_aligned (a :: 'a :: len word) n; is_aligned b n; n < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> is_aligned (a - b) n"
>   by (simp add: aligned_sub_aligned)
> 
> lemma is_aligned_neg_mask_weaken:
>   "\<lbrakk> is_aligned p n; m \<le> n \<rbrakk> \<Longrightarrow> p && ~~(mask m) = p"
>    using is_aligned_neg_mask_eq is_aligned_weaken by blast
> 
> lemma is_aligned_neg_mask2[simp]:
>   "is_aligned (a && ~~(mask n)) n"
>   by (simp add: and_not_mask is_aligned_shift)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Enumeration.thy ../../AFPs/afp-2020/thys/Word_Lib/Enumeration.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Hex_Words.thy ../../AFPs/afp-2020/thys/Word_Lib/Hex_Words.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/HOL_Lemmas.thy ../../AFPs/afp-2020/thys/Word_Lib/HOL_Lemmas.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
223a220,227
> 
> lemma nat_le_Suc_less:
>   "0 < y \<Longrightarrow> (x \<le> y - Suc 0) = (x < y)"
>   by arith
> 
> lemma nat_power_minus_less:
>   "a < 2 ^ (x - n) \<Longrightarrow> (a :: nat) < 2 ^ x"
>   by (erule order_less_le_trans) simp
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/More_Divides.thy ../../AFPs/afp-2020/thys/Word_Lib/More_Divides.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Norm_Words.thy ../../AFPs/afp-2020/thys/Word_Lib/Norm_Words.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Signed_Words.thy ../../AFPs/afp-2020/thys/Word_Lib/Signed_Words.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/WordBitwise_Signed.thy ../../AFPs/afp-2020/thys/Word_Lib/WordBitwise_Signed.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Enum.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Enum.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
57c53
< lemma length_word_enum: "length (enum :: ('a :: len) word list) = 2 ^ LENGTH('a)"
---
> lemma length_word_enum: "length (enum :: 'a :: len word list) = 2 ^ LENGTH('a)"
60c56
< lemma toEnum_of_nat[simp]: "n < 2 ^ LENGTH('a) \<Longrightarrow> ((toEnum n) :: ('a :: len) word) = of_nat n"
---
> lemma toEnum_of_nat[simp]: "n < 2 ^ LENGTH('a) \<Longrightarrow> (toEnum n :: 'a :: len word) = of_nat n"
Only in ../../AFPs/afp-2020/thys/Word_Lib: Word_EqI.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Lemmas_32.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Lemmas_32.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
287a284,285
> 
> lemmas word_ctz_not_minus_1_32 = word_ctz_not_minus_1[where 'a=32, simplified]
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Lemmas_64.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Lemmas_64.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
135,146d130
< lemma unat_ucast_8_64:
<   fixes x :: "word8"
<   shows "unat (ucast x :: word64) = unat x"
<   unfolding ucast_def unat_def
<   apply (subst int_word_uint)
<   apply (subst mod_pos_pos_trivial)
<     apply simp
<    apply (rule lt2p_lem)
<    apply simp
<   apply simp
<   done
< 
281a266,267
> 
> lemmas word_ctz_not_minus_1_64 = word_ctz_not_minus_1[where 'a=64, simplified]
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Lemmas.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Lemmas.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
15,16c11
<     Complex_Main
<     Word_Next
---
>     Word_EqI
21,69d15
< text \<open>Set up quickcheck to support words\<close>
< 
< quickcheck_generator word
<   constructors:
<     "zero_class.zero :: ('a::len) word",
<     "numeral :: num \<Rightarrow> ('a::len) word",
<     "uminus :: ('a::len) word \<Rightarrow> ('a::len) word"
< 
< instantiation Enum.finite_1 :: len
< begin
<   definition "len_of_finite_1 (x :: Enum.finite_1 itself) \<equiv> (1 :: nat)"
<   instance
<     by (standard, auto simp: len_of_finite_1_def)
< end
< 
< instantiation Enum.finite_2 :: len
< begin
<   definition "len_of_finite_2 (x :: Enum.finite_2 itself) \<equiv> (2 :: nat)"
<   instance
<     by (standard, auto simp: len_of_finite_2_def)
< end
< 
< instantiation Enum.finite_3 :: len
< begin
<   definition "len_of_finite_3 (x :: Enum.finite_3 itself) \<equiv> (4 :: nat)"
<   instance
<     by (standard, auto simp: len_of_finite_3_def)
< end
< 
< (* Provide wf and less_induct for word.
<    wf may be more useful in loop proofs, less_induct in recursion proofs. *)
< lemma word_less_wf: "wf {(a, b). a < (b :: ('a::len) word)}"
<   apply (rule wf_subset)
<   apply (rule wf_measure)
<   apply safe
<   apply (subst in_measure)
<   apply (erule unat_mono)
<   done
< 
< lemma word_less_induct:
<   "\<lbrakk> \<And>x::('a::len) word. (\<And>y. y < x \<Longrightarrow> P y) \<Longrightarrow> P x \<rbrakk> \<Longrightarrow> P a"
<   using word_less_wf  by induct blast
< 
< instantiation word :: (len) wellorder
< begin
< instance by (intro_classes) (metis word_less_induct)
< end
< 
< 
75,131d20
< lemma word_2p_mult_inc:
<   assumes x: "2 * 2 ^ n < (2::'a::len word) * 2 ^ m"
<   assumes suc_n: "Suc n < LENGTH('a::len)"
<   assumes suc_m: "Suc m < LENGTH('a::len)"
<   assumes 2: "unat (2::'a::len word) = 2"
<   shows "2^n < (2::'a::len word)^m"
< proof -
<   from suc_n
<   have "(2::nat) * 2 ^ n mod 2 ^ LENGTH('a::len) = 2 * 2^n"
<     apply (subst mod_less)
<      apply (subst power_Suc[symmetric])
<      apply (rule power_strict_increasing)
<       apply simp
<      apply simp
<     apply simp
<     done
<   moreover
<   from suc_m
<   have "(2::nat) * 2 ^ m mod 2 ^ LENGTH('a::len) = 2 * 2^m"
<     apply (subst mod_less)
<      apply (subst power_Suc[symmetric])
<      apply (rule power_strict_increasing)
<       apply simp
<      apply simp
<     apply simp
<     done
<   ultimately
<   have "2 * 2 ^ n < (2::nat) * 2 ^ m" using x
<     apply (unfold word_less_nat_alt)
<     apply simp
<     apply (subst (asm) unat_word_ariths(2))+
<     apply (subst (asm) 2)+
<     apply (subst (asm) word_unat_power, subst (asm) unat_of_nat)+
<     apply (simp add: mod_mult_right_eq)
<     done
<   with suc_n suc_m
<   show ?thesis
<     unfolding word_less_nat_alt
<     apply (subst word_unat_power, subst unat_of_nat)+
<     apply simp
<     done
< qed
< 
< lemma word_power_increasing:
<   assumes x: "2 ^ x < (2 ^ y::'a::len word)" "x < LENGTH('a::len)" "y < LENGTH('a::len)"
<   assumes 2: "unat (2::'a::len word) = 2"
<   shows "x < y" using x
<   apply (induct x arbitrary: y)
<    apply (case_tac y; simp)
<   apply (case_tac y; clarsimp)
<    apply (subst (asm) power_Suc [symmetric])
<    apply (subst (asm) p2_eq_0)
<    apply simp
<   apply (drule (2) word_2p_mult_inc, rule 2)
<   apply simp
<   done
< 
153,156c42
<   apply (simp add: no_plus_overflow_uint_size word_less_alt uint_word_ariths word_size)
<   apply (subst(asm) zmod_zminus1_eq_if)
<   apply (simp split: if_split_asm)
<   done
---
>   by (metis diff_minus_eq_add less_imp_le sub_wrap_lt)
159,165c45,47
<   fixes x :: "'a::len word"
<   fixes y :: "'b::len word"
<   shows
<     "\<lbrakk> ucast x = (ucast (ucast y::'a::len word)::'c::len word);
<       LENGTH('a) \<le> LENGTH('b);
<       LENGTH('b) \<le> LENGTH('c) \<rbrakk> \<Longrightarrow>
<     x = ucast y"
---
>   "\<lbrakk> ucast x = (ucast (ucast y::'a word)::'c::len word); LENGTH('a) \<le> LENGTH('b);
>      LENGTH('b) \<le> LENGTH('c) \<rbrakk> \<Longrightarrow>
>    x = ucast y" for x :: "'a::len word" and y :: "'b::len word"
167a50,52
> lemma ucast_0_I:
>   "x = 0 \<Longrightarrow> ucast x = 0"
>   by simp
204,206c89
<   apply (clarsimp simp: bang_eq test_bit_of_bl rev_nth cong: rev_conj_cong)
<   apply (safe, simp_all add: word_size to_bl_nth)
<   done
---
>   by (simp add: of_bl_drop word_size_bl)
220,221c103,104
<      by (rule order_less_le_trans [OF unat_mono [OF yv] order_eq_refl],
<        rule unat_power_lower[OF nv])
---
>     by (rule order_less_le_trans [OF unat_mono [OF yv] order_eq_refl],
>         rule unat_power_lower[OF nv])
224,225c107,108
<      by (rule order_less_le_trans [OF unat_mono [OF xv] order_eq_refl],
<        rule unat_power_lower[OF mv])
---
>     by (rule order_less_le_trans [OF unat_mono [OF xv] order_eq_refl],
>         rule unat_power_lower[OF mv])
228,237c111,118
<   apply (subst word_less_nat_alt)
<   apply (subst unat_word_ariths)+
<   apply (subst mod_less)
<    apply simp
<    apply (subst mult.commute)
<    apply (rule nat_less_power_trans [OF _ order_less_imp_le [OF nv]])
<     apply (rule order_less_le_trans [OF unat_mono [OF xv']])
<     apply (cases "n = 0")
<        apply simp
<       apply simp
---
>     apply (subst word_less_nat_alt)
>     apply (subst unat_word_ariths)+
>     apply (subst mod_less)
>      apply simp
>      apply (subst mult.commute)
>      apply (rule nat_less_power_trans [OF _ order_less_imp_le [OF nv]])
>      apply (rule order_less_le_trans [OF unat_mono [OF xv']])
>      apply (cases "n = 0"; simp)
240,246c121,126
<    apply (erule order_less_le_trans [OF nat_add_offset_less], assumption)
<     apply (rule mn)
<    apply simp
<   apply (simp add: mn mnv)
<   apply (erule nat_add_offset_less)
<   apply simp+
<   done
---
>      apply (erule order_less_le_trans [OF nat_add_offset_less], assumption)
>       apply (rule mn)
>      apply simp
>     apply (simp add: mn mnv)
>     apply (erule nat_add_offset_less; simp)
>     done
273,290d152
< lemma word_less_sub_le[simp]:
<   fixes x :: "'a :: len word"
<   assumes nv: "n < LENGTH('a)"
<   shows "(x \<le> 2 ^ n - 1) = (x < 2 ^ n)"
< proof -
<   have "Suc (unat ((2::'a word) ^ n - 1)) = unat ((2::'a word) ^ n)" using nv
<     by (metis Suc_pred' power_2_ge_iff unat_gt_0 unat_minus_one word_not_simps(1))
< 
<   then show ?thesis using nv
<     apply -
<     apply (subst word_le_nat_alt)
<     apply (subst less_Suc_eq_le [symmetric])
<     apply (erule ssubst)
<     apply (subst word_less_nat_alt)
<     apply (rule refl)
<     done
< qed
< 
297c159,160
<     by (rule order_less_le_trans [where y = 1], simp, subst unat_1 [symmetric], rule iffD1 [OF word_le_nat_alt lt])
---
>     by (rule order_less_le_trans [where y = 1], simp, subst unat_1 [symmetric],
>         rule iffD1 [OF word_le_nat_alt lt])
471c334
<   assumes szv: "sz < len_of (TYPE('a))"
---
>   assumes szv: "sz < LENGTH('a)"
508,509c371
<   "\<lbrakk>x = z; x < y; Suc (unat y) < 2 ^ LENGTH('a)\<rbrakk>
<    \<Longrightarrow> [x::'a::len word .e. y] = z # [x + 1 .e. y]"
---
>   "x < y \<Longrightarrow> [x::'a::len word .e. y] = x # [x + 1 .e. y]"
511,523c373,377
<   apply (subst upt_conv_Cons)
<    apply (simp)
<    apply (drule unat_mono)
<    apply arith
<   apply (simp only: list.map)
<   apply (subst list.inject)
<   apply rule
<    apply (rule to_from_enum)
<    apply (subst upto_enum_red)
<   apply (rule map_cong [OF _ refl])
<   apply (rule arg_cong2 [where f = "\<lambda>x y. [x ..< y]"])
<    apply unat_arith
<   apply simp
---
>   apply (subst upt_conv_Cons, unat_arith)
>   apply (simp only: list.map list.inject upto_enum_red to_from_enum simp_thms)
>   apply (rule map_cong[OF _ refl])
>   apply (rule arg_cong2[where f = "\<lambda>x y. [x ..< y]"], unat_arith)
>   apply (rule refl)
638,644c492,493
<   "(x && ~~ mask y) >> y = x >> y"
<   apply (rule word_eqI)
<   apply (simp add: nth_shiftr word_size)
<   apply safe
<   apply (drule test_bit.Rep[simplified, rule_format])
<   apply (simp add: word_size word_ops_nth_size)
<   done
---
>   "(x && ~~ (mask y)) >> y = x >> y"
>   by word_eqI
739a589,594
> lemma ucast_shiftl_eq_0:
>   fixes w :: "'a :: len word"
>   shows "\<lbrakk> n \<ge> LENGTH('b) \<rbrakk> \<Longrightarrow> ucast (w << n) = (0 :: 'b :: len word)"
>   by (case_tac "size w \<le> n", clarsimp simp: shiftl_zero_size)
>      (clarsimp simp: not_le ucast_bl bl_shiftl bang_eq test_bit_of_bl rev_nth nth_append)
> 
846a702,710
> lemma length_upto_enum_cases:
>   fixes a :: "'a::len word"
>   shows "length [a .e. b] = (if a \<le> b then Suc (unat b) - unat a else 0)"
>   apply (case_tac "a \<le> b")
>    apply (clarsimp)
>   apply (clarsimp simp: upto_enum_def)
>   apply unat_arith
>   done
> 
1301a1166,1172
> (* shadows the slightly weaker Word.nth_ucast *)
> lemma nth_ucast:
>   "(ucast (w::'a::len0 word)::'b::len0 word) !! n =
>    (w !! n \<and> n < min LENGTH('a) LENGTH('b))"
>   by (simp add: ucast_def test_bit_bin word_ubin.eq_norm nth_bintr word_size)
>      (fast elim!: bin_nth_uint_imp)
> 
1305,1311c1176
<   apply (subst mask_eq_iff_w2p[symmetric])
<    apply (simp add: word_size)
<   apply (rule word_eqI)
<   apply (simp add: word_size nth_ucast)
<   apply safe
<   apply (simp add: test_bit.Rep[simplified])
<   done
---
>   by (meson Word.nth_ucast test_bit_conj_lt le_def upper_bits_unset_is_l2p)
1315,1316c1180
<    range (ucast :: 'a word \<Rightarrow> 'b word)
<        = {x. x < 2 ^ len_of TYPE ('a)}"
---
>    range (ucast :: 'a word \<Rightarrow> 'b word) = {x. x < 2 ^ len_of TYPE ('a)}"
1321,1325c1185
<   apply (drule less_mask_eq)
<   apply (rule word_eqI)
<   apply (drule_tac x=n in word_eqD)
<   apply (clarsimp simp: word_size nth_ucast)
<   done
---
>   by word_eqI_solve
1525a1386,1392
> lemma nat_uint_less_helper:
>   "nat (uint y) = z \<Longrightarrow> x < y \<Longrightarrow> nat (uint x) < z"
>   apply (erule subst)
>   apply (subst unat_def [symmetric])
>   apply (subst unat_def [symmetric])
>   by (simp add: unat_mono)
> 
1527c1394
<   "\<lbrakk>of_nat n = (0::('a::len) word); n < 2 ^ len_of (TYPE('a))\<rbrakk> \<Longrightarrow> n = 0"
---
>   "\<lbrakk>of_nat n = (0::'a::len word); n < 2 ^ LENGTH('a)\<rbrakk> \<Longrightarrow> n = 0"
1530,1538c1397
< lemma minus_one_helper3:
<   "x < y \<Longrightarrow> x \<le> (y :: 'a :: len word) - 1"
<   apply (simp add: word_less_nat_alt word_le_nat_alt)
<   apply (subst unat_minus_one)
<    apply clarsimp
<   apply arith
<   done
< 
< lemma minus_one_helper:
---
> lemma word_leq_le_minus_one:
1548,1570d1406
< lemma minus_one_helper5:
<   fixes x :: "'a::len word"
<   shows "\<lbrakk>y \<noteq> 0; x \<le> y - 1 \<rbrakk> \<Longrightarrow> x < y"
<   using le_m1_iff_lt word_neq_0_conv by blast
< 
< lemma not_greatest_aligned:
<   "\<lbrakk> x < y; is_aligned x n; is_aligned y n \<rbrakk>
<       \<Longrightarrow> x + 2 ^ n \<noteq> 0"
<   apply (rule notI)
<   apply (erule is_aligned_get_word_bits[where p=y])
<    apply (simp add: eq_diff_eq[symmetric])
<    apply (frule minus_one_helper3)
<    apply (drule le_minus'[where a="x" and c="y - x" and b="- 1" for x y, simplified])
<    apply (simp add: field_simps)
<    apply (frule is_aligned_less_sz[where a=y])
<      apply clarsimp
<    apply (erule notE)
<    apply (rule minus_one_helper5)
<     apply simp
<    apply (metis is_aligned_no_overflow minus_one_helper3 order_le_less_trans)
<   apply simp
<   done
< 
1660c1496
<   "\<lbrakk> is_aligned p sz; sz < len_of (TYPE('a)); us \<le> sz \<rbrakk>
---
>   "\<lbrakk> is_aligned p sz; sz < LENGTH('a); us \<le> sz \<rbrakk>
1694,1702c1530,1534
<   fixes x :: "'a :: len word"
<   shows "\<lbrakk> x && mask (n + m) = x; m < LENGTH('a) \<rbrakk>
<               \<Longrightarrow> (x >> n) < 2 ^ m"
<   apply (subst mask_eq_iff_w2p[symmetric])
<    apply (simp add: word_size)
<   apply (rule word_eqI)
<   apply (drule_tac x="na + n" in word_eqD)
<   apply (simp add: nth_shiftr word_size)
<   apply safe
---
>   "\<lbrakk> x && mask (n + m) = x; m < LENGTH('a) \<rbrakk> \<Longrightarrow> x >> n < 2 ^ m" for x :: "'a :: len word"
>   apply (simp add: word_size mask_eq_iff_w2p[symmetric])
>   apply word_eqI
>   apply (erule_tac x="na + n" in allE)
>   apply fastforce
1706,1707c1538
<   fixes x :: "'a :: len word"
<   shows "x < 2 ^ (n + m) \<Longrightarrow> (x >> n) < 2 ^ m"
---
>   "x < 2 ^ (n + m) \<Longrightarrow> x >> n < 2 ^ m" for x :: "'a :: len word"
1725c1556
<   "n+m \<ge> LENGTH('a :: len) \<Longrightarrow> ((w::'a::len word) >> n) && ~~ mask m = 0"
---
>   "n+m \<ge> LENGTH('a :: len) \<Longrightarrow> ((w::'a::len word) >> n) && ~~ (mask m) = 0"
1736,1745c1567,1570
<   apply (subst mask_eq_iff_w2p[symmetric])
<    apply (simp add: word_size)
<   apply (drule less_mask_eq)
<   apply (rule word_eqI)
<   apply (drule_tac x="na - n" in word_eqD)
<   apply (simp add: nth_shiftl word_size)
<   apply (cases "n \<le> m")
<    apply safe
<    apply simp
<   apply simp
---
>   apply (simp add: word_size mask_eq_iff_w2p[symmetric])
>   apply word_eqI
>   apply (erule_tac x="na - n" in allE)
>   apply auto
1754,1756c1579
<   apply (rule word_eqI)
<   apply (simp add: nth_ucast word_size)
<   done
---
>   by word_eqI
1763a1587,1590
> lemma ucast_ucast_id:
>   "LENGTH('a) < LENGTH('b) \<Longrightarrow> ucast (ucast (x::'a::len word)::'b::len word) = x"
>   by (auto intro: ucast_up_ucast_id simp: is_up_def source_size_def target_size_def word_size)
> 
1777c1604
<   "LENGTH('a) < LENGTH('b) \<Longrightarrow>
---
>   "LENGTH('a) \<le> LENGTH('b) \<Longrightarrow>
1786a1614,1617
> \<comment> \<open>This weaker version was previously called @{text ucast_less_ucast}. We retain it to
>     support existing proofs.\<close>
> lemmas ucast_less_ucast_weak = ucast_less_ucast[OF order.strict_implies_order]
> 
1829,1835c1660
<   apply (rule word_plus_and_or_coroll)
<   apply (erule is_aligned_get_word_bits)
<    apply (rule word_eqI)
<    apply (clarsimp simp add: is_aligned_nth)
<    apply (frule(1) nth_bounded)
<     apply simp+
<   done
---
>   by (rule word_plus_and_or_coroll, word_eqI) blast
1865c1690
<      apply (rule minus_one_helper)
---
>      apply (rule word_leq_le_minus_one)
1906c1731
<   "(x && ~~ mask n) = x - (x && mask n)"
---
>   "(x && ~~ (mask n)) = x - (x && (mask n))"
2009c1834
<   "(w && ~~ mask n) && ~~ mask m = w && ~~ mask (max m n)"
---
>   "(w && ~~ (mask n)) && ~~ (mask m) = w && ~~ (mask (max m n))"
2032c1857
<   by (rule word_eqI) (simp add: word_size)
---
>   by word_eqI
2088,2091c1913
<   apply safe
<   apply (rule word_eqI)
<   apply (drule_tac x=n in word_eqD)+
<   by (auto simp: word_size word_ops_nth_size)
---
>   by safe word_eqI_solve
2099,2108c1921,1922
<   apply (induct xs arbitrary: n)
<    apply simp
<   apply (case_tac n)
<    apply simp_all
<   done
< 
< lemma word_or_zero:
<   "(a || b = 0) = (a = 0 \<and> b = 0)"
<   apply (safe, simp_all)
<    apply (rule word_eqI, drule_tac x=n in word_eqD, simp)+
---
>   apply (induct xs arbitrary: n, simp)
>   apply (case_tac n; simp)
2112,2117c1926,1927
<   fixes x :: "'a :: len word" shows
<   "x && (1 << n) = (if x !! n then (1 << n) else 0)"
<   apply (rule word_eqI)
<   apply (simp add: word_size nth_shiftl del: shiftl_1)
<   apply auto
<   done
---
>   "x && (1 << n) = (if x !! n then (1 << n) else 0)" for x :: "'a :: len word"
>   by word_eqI_solve
2128,2131c1938
<   apply (rule word_eqI)
<   apply (simp add: word_size nth_shiftl nth_shiftr)
<   apply auto
<   done
---
>   by word_eqI_solve
2174a1982,1986
> lemma word_leq_minus_one_le:
>   fixes x :: "'a::len word"
>   shows "\<lbrakk>y \<noteq> 0; x \<le> y - 1 \<rbrakk> \<Longrightarrow> x < y"
>   using le_m1_iff_lt word_neq_0_conv by blast
> 
2179c1991
<    apply (drule minus_one_helper3)
---
>    apply (drule word_le_minus_one_leq)
2183c1995
<   apply (erule minus_one_helper5)
---
>   apply (erule word_leq_minus_one_le)
2187c1999
< lemma minus_one_helper2:
---
> lemma word_minus_one_le_leq:
2227,2231c2039,2040
<   fixes m :: "'a :: len word"
<   shows "m < n \<Longrightarrow> m div n = 0"
<   apply (rule word_unat.Rep_eqD)
<   apply (simp add: word_less_nat_alt unat_div)
<   done
---
>   "m < n \<Longrightarrow> m div n = 0" for m :: "'a :: len word"
>   by (simp add: unat_mono word_arith_nat_defs(6))
2235,2240c2044
<   apply (rule ccontr)
<   apply (drule(1) order_trans)
<   apply (drule word_sub_1_le)
<   apply (drule(1) order_antisym)
<   apply simp
<   done
---
>   using dual_order.trans sub_wrap word_less_1 by blast
2243,2253c2047,2048
<   "\<lbrakk> {a :: 'a :: len word .. b} \<subseteq> {c .. d}; b \<ge> a \<rbrakk>
<      \<Longrightarrow> d \<ge> c \<and> d - c \<ge> b - a"
<   apply (subgoal_tac "a \<in> {a .. b}")
<    apply (frule(1) range_subset_lower)
<    apply (frule(1) range_subset_upper)
<    apply (rule context_conjI, simp)
<    apply (rule word_sub_mono, assumption+)
<     apply (erule word_sub_le)
<    apply (erule word_sub_le)
<   apply simp
<   done
---
>   "\<lbrakk> {a :: 'a :: len word .. b} \<subseteq> {c .. d}; b \<ge> a \<rbrakk> \<Longrightarrow> d \<ge> c \<and> d - c \<ge> b - a"
>   using word_sub_le word_sub_mono by fastforce
2268,2269c2063
<   have kn: "unat (of_nat k :: 'a word) * unat ((2::'a word) ^ n)
<             < 2 ^ LENGTH('a)"
---
>   have kn: "unat (of_nat k :: 'a word) * unat ((2::'a word) ^ n) < 2 ^ LENGTH('a)"
2324,2326c2118
<     apply (rule order_less_le_trans [OF mod_less_divisor])
<      apply simp
<     apply simp
---
>     apply (rule order_less_le_trans [OF mod_less_divisor]; simp)
2375c2167
<   apply (drule minus_one_helper3)
---
>   apply (drule word_le_minus_one_leq)
2561,2563c2353
<   apply (rule word_eqI)
<   apply (simp add: nth_shiftr cong: rev_conj_cong)
<   done
---
>   by (word_eqI cong: rev_conj_cong)
2618,2627c2408,2409
<   fixes x :: "'a :: len word"
<   shows "(x >> n) && mask (size x - n) = x >> n"
<   apply (rule word_eqI)
<   apply (clarsimp simp: word_size nth_shiftr)
<   apply (rule iffI)
<    apply clarsimp
<   apply (clarsimp)
<   apply (drule test_bit_size)
<   apply (simp add: word_size)
<   done
---
>   "(x >> n) && mask (size x - n) = x >> n" for x :: "'a :: len word"
>   by word_eqI_solve
2630,2631c2412
<   fixes x :: "'a :: len word"
<   shows "m = (size x - n) \<Longrightarrow> (x >> n) && mask m = x >> n"
---
>   "m = (size x - n) \<Longrightarrow> (x >> n) && mask m = x >> n" for x :: "'a :: len word"
2634,2644d2414
< lemma bang_big: "n \<ge> size (x::'a::len0 word) \<Longrightarrow> (x !! n) = False"
<   by (simp add: test_bit_bl word_size)
< 
< lemma bang_conj_lt:
<   fixes x :: "'a :: len word"
<   shows "(x !! m \<and> m < LENGTH('a)) = x !! m"
<   apply (cases "m < LENGTH('a)")
<    apply simp
<   apply (simp add: not_less bang_big  word_size)
<   done
< 
2666,2672d2435
< lemma neg_mask_bang:
<   "(~~ mask n :: 'a :: len word) !! m = (n \<le> m \<and> m < LENGTH('a))"
<   apply (cases "m < LENGTH('a)")
<    apply (simp add: word_ops_nth_size word_size not_less)
<   apply (simp add: not_less bang_big  word_size)
<   done
< 
2674,2675c2437,2438
<   "(w && ~~ mask n) && mask n = 0"
< by (rule word_eqI) (clarsimp simp add: word_size neg_mask_bang)
---
>   "(w && ~~ (mask n)) && mask n = 0"
>   by word_eqI
2678,2687c2441,2442
<   "(w && ~~ mask n) + (w && mask n) = w"
< apply (rule word_eqI)
< apply (rename_tac m)
< apply (simp add: word_size)
< apply (cut_tac word_plus_and_or_coroll[of "w && ~~ mask n" "w && mask n"])
<  apply (simp add: word_ao_dist2[symmetric] word_size neg_mask_bang)
< apply (rule word_eqI)
< apply (rename_tac m)
< apply (simp add: word_size neg_mask_bang)
< done
---
>   "(w && ~~ (mask n)) + (w && mask n) = w"
>   by (subst word_plus_and_or_coroll; word_eqI_solve)
2692c2447
<   and     m2: "x && ~~ mask n = y && ~~ mask n"
---
>   and     m2: "x && ~~ (mask n) = y && ~~ (mask n)"
2701c2456
<       by (simp add: word_size bang_conj_lt)
---
>       by (simp add: word_size test_bit_conj_lt)
2704c2459
<       by (simp add: word_size bang_conj_lt)
---
>       by (simp add: word_size test_bit_conj_lt)
2708,2710c2463,2465
<     then have "x !! m = ((x && ~~ mask n) !! m)"
<       by (simp add: neg_mask_bang bang_conj_lt)
<     also have "\<dots> = ((y && ~~ mask n) !! m)" using m2 by simp
---
>     then have "x !! m = ((x && ~~ (mask n)) !! m)"
>       by (simp add: neg_mask_test_bit test_bit_conj_lt)
>     also have "\<dots> = ((y && ~~ (mask n)) !! m)" using m2 by simp
2712c2467
<       by (simp add: neg_mask_bang bang_conj_lt)
---
>       by (simp add: neg_mask_test_bit test_bit_conj_lt)
2776,2777c2531
<   apply (rule word_eqI)
<   apply (simp add: nth_w2p)
---
>   apply word_eqI
2812,2851d2565
< lemma neg_mask_mono_le:
<   "(x :: 'a :: len word) \<le> y \<Longrightarrow> x && ~~ mask n \<le> y && ~~ mask n"
< proof (rule ccontr, simp add: linorder_not_le, cases "n < LENGTH('a)")
<   case False
<   show "y && ~~ mask n < x && ~~ mask n \<Longrightarrow> False"
<     using False
<     by (simp add: mask_def linorder_not_less
<                   power_overflow)
< next
<   case True
<   assume a: "x \<le> y" and b: "y && ~~ mask n < x && ~~ mask n"
<   have word_bits:
<     "n < LENGTH('a)"
<     using True by assumption
<   have "y \<le> (y && ~~ mask n) + (y && mask n)"
<     by (simp add: word_plus_and_or_coroll2 add.commute)
<   also have "\<dots> \<le> (y && ~~ mask n) + 2 ^ n"
<     apply (rule word_plus_mono_right)
<      apply (rule order_less_imp_le, rule and_mask_less_size)
<      apply (simp add: word_size word_bits)
<     apply (rule is_aligned_no_overflow'',
<            simp_all add: is_aligned_neg_mask word_bits)
<     apply (rule not_greatest_aligned, rule b)
<      apply (simp_all add: is_aligned_neg_mask)
<     done
<   also have "\<dots> \<le> x && ~~ mask n"
<     using b
<     apply -
<     apply (subst add.commute, rule le_plus)
<      apply (rule aligned_at_least_t2n_diff,
<             simp_all add: is_aligned_neg_mask)
<     apply (rule ccontr, simp add: linorder_not_le)
<     apply (drule aligned_small_is_0[rotated], simp_all add: is_aligned_neg_mask)
<     done
<   also have "\<dots> \<le> x" by (rule word_and_le2)
<   also have "x \<le> y" by fact
<   finally
<   show "False" using b by simp
< qed
< 
3163,3164c2877,2878
<      apply (clarsimp simp: sgn_if sign_simps)
<     apply (clarsimp simp: sign_simps not_less)
---
>      apply (clarsimp simp: sgn_if)
>     apply (clarsimp simp: algebra_split_simps not_less)
3168c2882
<      apply (clarsimp simp: sign_simps)
---
>      apply clarsimp
3170c2884
<     apply (clarsimp simp: sign_simps sgn_mult not_less)
---
>     apply (clarsimp simp: sgn_mult not_less)
3173c2887
<    apply (clarsimp simp: sign_simps sgn_mult not_less sgn_if split: if_splits)
---
>    apply (clarsimp simp: algebra_split_simps sgn_mult not_less sgn_if split: if_splits)
3184c2898
<      apply (clarsimp simp: sgn_if sign_simps not_less)
---
>      apply (clarsimp simp: sgn_if algebra_split_simps not_less)
3186,3187c2900,2901
<      apply (clarsimp simp: not_less sign_simps)
<     apply (clarsimp simp: sign_simps not_less)
---
>      apply (clarsimp simp: not_less algebra_split_simps)
>     apply (clarsimp simp: algebra_split_simps not_less)
3190c2904
<     apply (clarsimp simp: sign_simps not_less sgn_mult)
---
>     apply (clarsimp simp: not_less sgn_mult)
3192c2906
<     apply (clarsimp simp: sign_simps not_less sgn_mult)
---
>     apply (clarsimp simp: not_less sgn_mult)
3194c2908
<    apply (clarsimp simp: sign_simps not_less sgn_mult)
---
>    apply (clarsimp simp: not_less sgn_mult)
3313c3027
<   apply (clarsimp simp: minus_div_mult_eq_mod [symmetric] abs_sgn sgn_mult sgn_if sign_simps)
---
>   apply (clarsimp simp: minus_div_mult_eq_mod [symmetric] abs_sgn sgn_mult sgn_if algebra_split_simps)
3321,3325c3035,3038
<    apply (clarsimp simp: smod_int_alt_def sign_simps sgn_if
<               abs_if not_less add1_zle_eq [simplified add.commute])
<    apply (metis add_le_cancel_left monoid_add_class.add.right_neutral
<              int_one_le_iff_zero_less less_le_trans mod_minus_right neg_less_0_iff_less
<              neg_mod_conj not_less pos_mod_conj)
---
>    apply (auto simp: smod_int_alt_def algebra_simps sgn_if
>               abs_if not_less add1_zle_eq [simplified add.commute])[1]
>     apply (metis add_nonneg_nonneg int_one_le_iff_zero_less le_less less_add_same_cancel2 not_le pos_mod_conj)
>   apply (metis (full_types) add.inverse_inverse eucl_rel_int eucl_rel_int_iff le_less_trans neg_0_le_iff_le)
3328c3041
<   apply (clarsimp simp: smod_int_alt_def sign_simps sgn_if
---
>   apply (clarsimp simp: smod_int_alt_def algebra_simps sgn_if
3420c3133
<   apply (metis nth_w2p scast_def bang_conj_lt
---
>   apply (metis nth_w2p scast_def test_bit_conj_lt
3626c3339
<    apply (metis Suc_leI Suc_pred bang_conj_lt len_gt_0)
---
>    apply (metis Suc_leI Suc_pred len_gt_0)
3686c3399
<   apply (subst (asm) bang_conj_lt [symmetric])
---
>   apply (subst (asm) test_bit_conj_lt [symmetric])
3722c3435
<                 = (uint b < 2 ^ (len_of (TYPE('a)) - 1))"
---
>                 = (uint b < 2 ^ (LENGTH('a) - 1))"
3750,3752c3463,3464
<    apply (rule classical, erule notE, rule word_eqI)
<    apply clarsimp
<    apply (case_tac n, simp_all)[1]
---
>    apply (rule classical, erule notE, word_eqI)
>    apply (case_tac n; simp)
3806a3519,3523
> lemma from_bool_eqI:
>   "from_bool x = from_bool y \<Longrightarrow> x = y"
>   unfolding from_bool_def
>   by (auto split: bool.splits)
> 
3822,3833c3539
<   apply (subst word_plus_and_or_coroll)
<    apply (rule word_eqI)
<    apply (clarsimp simp: is_aligned_nth)
<    apply (drule(1) nth_bounded)
<     apply simp
<    apply simp
<   apply (rule word_eqI)
<   apply (simp add: nth_shiftr)
<   apply safe
<   apply (drule(1) nth_bounded)
<   apply simp+
<   done
---
>   by (subst word_plus_and_or_coroll; word_eqI, blast)
3838,3849c3544
<   apply (subst word_plus_and_or_coroll)
<    apply (rule word_eqI)
<    apply (clarsimp simp: is_aligned_nth)
<    apply (drule(1) nth_bounded)
<     apply simp
<    apply simp
<   apply (rule word_eqI)
<   apply (simp add: nth_shiftr)
<   apply safe
<   apply (drule(1) nth_bounded)
<   apply simp+
<   done
---
>   by (subst word_plus_and_or_coroll; word_eqI, blast)
3852,3872c3547,3549
<   "((x:: 'a :: len word) && ~~ mask n) + (2 ^ n - 1) = x || mask n"
<   apply (simp add:mask_2pm1[symmetric])
<   apply (rule word_eqI[rule_format])
<   apply (rule iffI)
<     apply (clarsimp simp:word_size not_less)
<     apply (cut_tac w = "((x && ~~ mask n) + mask n)" and
<       m = n and n = "na - n" in nth_shiftr[symmetric])
<     apply clarsimp
<     apply (subst (asm) aligned_shift')
<   apply (simp add:mask_lt_2pn nth_shiftr is_aligned_neg_mask word_size)+
<   apply (case_tac "na<n")
<     apply clarsimp
<     apply (subst word_plus_and_or_coroll)
<     apply (rule iffD1[OF is_aligned_mask])
<     apply (simp add:is_aligned_neg_mask word_size not_less)+
<   apply (cut_tac w = "((x && ~~ mask n) + mask n)" and
<       m = n and n = "na - n" in nth_shiftr[symmetric])
<   apply clarsimp
<   apply (subst (asm) aligned_shift')
<   apply (simp add:mask_lt_2pn is_aligned_neg_mask nth_shiftr neg_mask_bang)+
< done
---
>   "((x:: 'a :: len word) && ~~ (mask n)) + (2 ^ n - 1) = x || mask n"
>   unfolding mask_2pm1[symmetric]
>   by (subst word_plus_and_or_coroll; word_eqI_solve)
3875,3876c3552,3553
<   "p - (p && mask n) = (p && ~~ mask n)"
<   "p - (p && ~~ mask n) = (p && mask n)"
---
>   "p - (p && mask n) = (p && ~~ (mask n))"
>   "p - (p && ~~ (mask n)) = (p && mask n)"
3879,3880c3556,3557
< lemma and_neg_mask_plus_mask_mono: "(p && ~~ mask n) + mask n \<ge> p"
<   apply (rule word_le_minus_cancel[where x = "p && ~~ mask n"])
---
> lemma and_neg_mask_plus_mask_mono: "(p && ~~ (mask n)) + mask n \<ge> p"
>   apply (rule word_le_minus_cancel[where x = "p && ~~ (mask n)"])
3889c3566
<   "ptr \<le> (ptr && ~~ mask n) + (2 ^ n - 1)"
---
>   "ptr \<le> (ptr && ~~ (mask n)) + (2 ^ n - 1)"
3924c3601
<    apply (erule minus_one_helper3)
---
>    apply (erule word_le_minus_one_leq)
3930c3607
<      \<Longrightarrow> (p + d && mask n = d) \<and> (p + d && (~~ mask n) = p)"
---
>      \<Longrightarrow> (p + d && mask n = d) \<and> (p + d && (~~ (mask n)) = p)"
3934,3945c3611,3612
<    apply (subst word_plus_and_or_coroll)
<     apply (rule word_eqI)
<     apply (drule_tac x=na in word_eqD)+
<     apply (simp add: word_size)
<     apply blast
<    apply (rule word_eqI)
<    apply (drule_tac x=na in word_eqD)+
<    apply (simp add: word_ops_nth_size word_size)
<    apply blast
<   apply (insert word_plus_and_or_coroll2[where x="p + d" and w="mask n"])
<   apply simp
<   done
---
>    apply (subst word_plus_and_or_coroll; word_eqI; blast)
>   using word_plus_and_or_coroll2[where x="p + d" and w="mask n"] by simp
3949c3616
<      \<Longrightarrow> (p && mask n = d) \<and> (p && (~~ mask n) = p - d)"
---
>      \<Longrightarrow> (p && mask n = d) \<and> (p && (~~ (mask n)) = p - d)"
3954,3956c3621
<   apply (rule word_eqI)
<   apply (simp add: word_size conj_comms)
<   done
---
>   by word_eqI_solve
3973,3974c3638,3639
<   apply (subgoal_tac "(ptr + a && mask n) && ~~ mask m
<      = (ptr + a && ~~ mask m ) && mask n")
---
>   apply (subgoal_tac "(ptr + a && mask n) && ~~ (mask m)
>      = (ptr + a && ~~ (mask m) ) && mask n")
3991c3656
<       simp add: minus_one_helper3)
---
>       simp add: word_le_minus_one_leq)
3993c3658
< lemma NOT_mask_AND_mask[simp]: "(w && mask n) && ~~ mask n = 0"
---
> lemma NOT_mask_AND_mask[simp]: "(w && mask n) && ~~ (mask n) = 0"
4012c3677
< lemma mask_1[simp]: "(\<exists>x. mask x = 1)"
---
> lemma ex_mask_1[simp]: "(\<exists>x. mask x = 1)"
4052c3717
< lemma scast_nop_1:
---
> lemma scast_nop1:
4057c3722
< lemma scast_nop_2:
---
> lemma scast_nop2:
4062c3727
< lemmas scast_nop[simp] = scast_nop_1 scast_nop_2 scast_id
---
> lemmas scast_nop[simp] = scast_nop1 scast_nop2 scast_id
4069c3734
<   "((x::'a::len word) || ~~ mask n) && mask n = x && mask n"
---
>   "((x::'a::len word) || ~~ (mask n)) && mask n = x && mask n"
4073c3738
<   "\<lbrakk>n \<le> m\<rbrakk> \<Longrightarrow> ((x::'a::len word) || y && mask n) && ~~ mask m = x && ~~ mask m"
---
>   "\<lbrakk>n \<le> m\<rbrakk> \<Longrightarrow> ((x::'a::len word) || y && mask n) && ~~ (mask m) = x && ~~ (mask m)"
4075c3740
<   apply (subgoal_tac "(y && mask n) && ~~ mask m = 0")
---
>   apply (subgoal_tac "(y && mask n) && ~~ (mask m) = 0")
4079a3745,3749
> lemma and_mask_0_iff_le_mask:
>   fixes w :: "'a::len word"
>   shows "(w && ~~(mask n) = 0) = (w \<le> mask n)"
>   by (simp add: mask_eq_0_eq_x le_mask_imp_and_mask and_mask_eq_iff_le_mask)
> 
4290c3960
<   "x && mask n || x && ~~ mask n = x"
---
>   "x && mask n || x && ~~ (mask n) = x"
4303c3973
<   "\<lbrakk> is_aligned p n; q < 2 ^ n \<rbrakk> \<Longrightarrow> (p + q) && ~~ mask n = p && ~~ mask n"
---
>   "\<lbrakk> is_aligned p n; q < 2 ^ n \<rbrakk> \<Longrightarrow> (p + q) && ~~ (mask n) = p && ~~ (mask n)"
4347c4017
<     assume a1: "x \<le> word_of_int (uint (word_of_int (2 ^ len_of (TYPE('b)) - 1)::'b word))"
---
>     assume a1: "x \<le> word_of_int (uint (word_of_int (2 ^ LENGTH('b) - 1)::'b word))"
4365c4035
<     have f6: "2 ^ len_of (TYPE('b)::'b itself) + - (1::int) = - 1 + 2 ^ len_of (TYPE('b))"
---
>     have f6: "2 ^ LENGTH('b) + - (1::int) = - 1 + 2 ^ LENGTH('b)"
4405c4075
<   shows "unat (w >> n) < (2 ^ (len_of(TYPE('a)) - n))"
---
>   shows "unat (w >> n) < (2 ^ (LENGTH('a) - n))"
4411c4081
<   shows "n' < len_of(TYPE('a)) \<Longrightarrow> (~~ (2 ^ n :: ('a::len word))) !! n' = (n' \<noteq> n)"
---
>   shows "n' < LENGTH('a) \<Longrightarrow> (~~ (2 ^ n :: 'a::len word)) !! n' = (n' \<noteq> n)"
4439d4108
<   apply (rename_tac bs bit)
4441,4447c4110
<   apply (rename_tac bs' bit')
<   apply (case_tac "bit")
<    apply (case_tac "bit'", auto simp: less_eq_int_code le_Bits intro: basic_trans_rules)[1]
<   apply (case_tac bit')
<    apply (simp add: le_Bits less_eq_int_code)
<   apply (auto simp: le_Bits less_eq_int_code)
<   done
---
>   by (smt Bit_def bin_rest_BIT)
4451,4454c4114,4115
<   apply (induct n, simp)
<   apply (unfold shiftr_def)
<   apply (case_tac "(shiftr1 ^^ n) u = (shiftr1 ^^ n) v")
<    apply simp
---
>   apply (induct n; simp add: shiftr_def)
>   apply (case_tac "(shiftr1 ^^ n) u = (shiftr1 ^^ n) v", simp)
4488c4149
<   "word_clz (0::'a::len word) \<equiv> len_of (TYPE('a))"
---
>   "word_clz (0::'a::len word) = LENGTH('a)"
4493c4154
<   "word_clz (-1::'a::len word) \<equiv> 0"
---
>   "word_clz (-1::'a::len word) = 0"
4504,4534c4165
<   apply (subst le_less)
<   apply (rule iffI)
<    apply clarsimp
<    apply (subst (asm) add.commute)
<    apply (subst (asm) less_x_plus_1)
<     apply (cut_tac ?'a='a and y=n and x="unat (maxBound::'a word) - 1" in of_nat_mono_maybe')
<       apply clarsimp
<       apply (simp add: less_imp_diff_less)
<      apply (insert bound[unfolded maxBound_word, simplified])
<      using order_less_trans apply blast
<     apply (metis max_word_minus word_not_simps(3) word_of_nat_less)
<    apply clarsimp
<   apply (erule disjE)
<    apply (subgoal_tac "x < of_nat (1 + n)")
<     prefer 2
<     apply (cut_tac ?'a='a and y="unat x" and x="1 + n" in of_nat_mono_maybe)
<       apply clarsimp
<       apply (simp add: less_trans_Suc)
<      apply (simp add: less_Suc_eq unat_less_helper)
<     apply clarsimp
<    apply clarsimp
<   apply clarsimp
<   apply (cut_tac y="(of_nat n)::'a word" and x="(of_nat n)::'a word" in less_x_plus_1)
<    apply (cut_tac ?'a='a and y=n and x="unat (maxBound::'a word) - 1" in of_nat_mono_maybe')
<      apply clarsimp
<      apply (simp add: less_imp_diff_less)
<     apply (insert bound[unfolded maxBound_word, simplified])
<     using order_less_trans apply blast
<    apply (metis max_word_minus word_not_simps(3) word_of_nat_less)
<   apply (clarsimp simp: add.commute)
<   done
---
>   by (metis add.commute bound max_word_max word_Suc_leq word_not_le word_of_nat_less)
4538c4169
<   assumes uc :"LENGTH('a) \<le> LENGTH('b)"
---
>   assumes "LENGTH('a) \<le> LENGTH('b)"
4542,4546c4173,4175
<   apply (subst mod_pos_pos_trivial)
<     apply simp
<    apply (rule lt2p_lem)
<    apply (simp add: uc)
<   apply simp
---
>   apply (subst mod_pos_pos_trivial; simp?)
>   apply (rule lt2p_lem)
>   apply (simp add: assms)
4551,4554c4180
<   apply (erule order_le_less_trans[OF _ of_nat_mono_maybe,rotated])
<    apply assumption
<   apply simp
<   done
---
>   by (erule (1)  order_le_less_trans[OF _ of_nat_mono_maybe,rotated]) simp
4558,4561c4184
<   apply (rule iffI)
<    apply (simp add:unat_ucast_less_no_overflow)
<   apply (simp add:unat_less_helper)
<   done
---
>   using unat_less_helper unat_ucast_less_no_overflow by blast
4564c4187
<   assumes no_overflow : "unat b < (2 :: nat) ^ LENGTH('a)"
---
>   assumes no_overflow: "unat b < (2 :: nat) ^ LENGTH('a)"
4566,4574c4189,4209
<   shows  "(ucast (f::('a::len) word) < (b :: 'b :: len word)) = (unat f < unat b)"
<   proof -
<     have LR: "ucast f < b \<Longrightarrow> unat f < unat b"
<       apply (rule unat_less_helper)
<       apply (simp add:ucast_nat_def)
<       apply (rule_tac 'b1 = 'b in  ucast_less_ucast[THEN iffD1])
<        apply (rule upward_cast)
<       apply (simp add: ucast_ucast_mask less_mask_eq word_less_nat_alt
<                        unat_power_lower[OF upward_cast] no_overflow)
---
>   shows "(ucast (f::'a::len word) < (b :: 'b :: len word)) = (unat f < unat b)"
> proof -
>   have LR: "ucast f < b \<Longrightarrow> unat f < unat b"
>     apply (rule unat_less_helper)
>     apply (simp add:ucast_nat_def)
>     apply (rule_tac 'b1 = 'b in  ucast_less_ucast[OF order.strict_implies_order, THEN iffD1])
>      apply (rule upward_cast)
>     apply (simp add: ucast_ucast_mask less_mask_eq word_less_nat_alt
>                      unat_power_lower[OF upward_cast] no_overflow)
>     done
>   have RL: "unat f < unat b \<Longrightarrow> ucast f < b"
>   proof-
>     assume ineq: "unat f < unat b"
>     have "ucast (f::'a::len word) < ((ucast (ucast b ::'a::len word)) :: 'b :: len word)"
>       apply (simp add: ucast_less_ucast[OF order.strict_implies_order] upward_cast)
>       apply (simp add: ucast_nat_def[symmetric])
>       apply (rule unat_ucast_less_no_overflow[OF no_overflow ineq])
>       done
>     then show ?thesis
>       apply (rule order_less_le_trans)
>       apply (simp add:ucast_ucast_mask word_and_le2)
4576,4590c4211,4212
<     have RL: "unat f < unat b \<Longrightarrow> ucast f < b"
<       proof-
<       assume ineq: "unat f < unat b"
<       have ucast_rewrite: "ucast (f::('a::len) word) <
<           ((ucast (ucast b ::('a::len) word)) :: 'b :: len word)"
<         apply (simp add: ucast_less_ucast upward_cast)
<         apply (simp add: ucast_nat_def[symmetric])
<         apply (rule unat_ucast_less_no_overflow[OF no_overflow ineq])
<         done
<       then show ?thesis
<         apply (rule order_less_le_trans)
<         apply (simp add:ucast_ucast_mask word_and_le2)
<         done
<    qed
<    then show ?thesis by (simp add:RL LR iffI)
---
>   qed
>   then show ?thesis by (simp add:RL LR iffI)
4592a4215,4216
> lemmas ucast_up_mono = ucast_less_ucast[THEN iffD2]
> 
4599,4609c4223,4225
< "length (dropWhile Not (to_bl w)) \<le> LENGTH('s) \<Longrightarrow>
<  LENGTH('s) \<le> LENGTH('l) \<Longrightarrow>
<   (of_bl:: bool list \<Rightarrow> 'l::len word) (to_bl ((of_bl:: bool list \<Rightarrow> 's::len word) (to_bl w))) = w"
<   apply(rule word_uint_eqI)
<   apply(subst uint_of_bl_is_bl_to_bin)
<    apply(simp; fail)
<   apply(subst to_bl_bin)
<   apply(subst uint_of_bl_is_bl_to_bin_drop)
<    apply blast
<   apply(simp)
<   done
---
>   "\<lbrakk> length (dropWhile Not (to_bl w)) \<le> LENGTH('s); LENGTH('s) \<le> LENGTH('l) \<rbrakk> \<Longrightarrow>
>    (of_bl :: _ \<Rightarrow> 'l::len word) (to_bl ((of_bl::_ \<Rightarrow> 's::len word) (to_bl w))) = w"
>   by (rule word_uint_eqI) (simp add: uint_of_bl_is_bl_to_bin uint_of_bl_is_bl_to_bin_drop)
4619,4620c4235
<   "length (dropWhile Not (to_bl w)) \<le> LENGTH('s) \<Longrightarrow>
<    LENGTH('s) \<le> LENGTH('l) \<Longrightarrow>
---
>   "\<lbrakk> length (dropWhile Not (to_bl w)) \<le> LENGTH('s); LENGTH('s) \<le> LENGTH('l) \<rbrakk> \<Longrightarrow>
4622,4624c4237,4238
<   apply(subst Word.ucast_bl)+
<   apply(rule bl_cast_long_short_long_ingoreLeadingZero_generic)
<    apply(simp_all)
---
>   apply (subst Word.ucast_bl)+
>   apply (rule bl_cast_long_short_long_ingoreLeadingZero_generic; simp)
4642c4256
<   "n \<ge> LENGTH('a) \<Longrightarrow> (x::'a::len word) && ~~ mask n = 0"
---
>   "n \<ge> LENGTH('a) \<Longrightarrow> (x::'a::len word) && ~~ (mask n) = 0"
4668,4697d4281
< (* simp normal form would be "nat (bintrunc (LENGTH('a)) 2) = 2" *)
< lemma word_len_min_2:
<   "Suc 0 < LENGTH('a) \<Longrightarrow> unat (2::'a::len word) = 2"
<   by (metis less_trans_Suc n_less_equal_power_2 numeral_2_eq_2 of_nat_numeral unat_of_nat_len)
< 
< lemma upper_bits_unset_is_l2p:
<   "n < LENGTH('a) \<Longrightarrow>
<   (\<forall>n' \<ge> n. n' < LENGTH('a) \<longrightarrow> \<not> p !! n') = ((p::'a::len word) < 2 ^ n)"
<   apply (cases "Suc 0 < LENGTH('a)")
<    prefer 2
<    apply (subgoal_tac "LENGTH('a) = 1", auto simp: word_eq_iff)[1]
<   apply (rule iffI)
<    apply (subst mask_eq_iff_w2p [symmetric])
<     apply (clarsimp simp: word_size)
<    apply (rule word_eqI, rename_tac n')
<    apply (case_tac "n' < n"; simp add: word_size)
<   apply clarify
<   apply (drule bang_is_le)
<   apply (drule_tac y=p in order_le_less_trans, assumption)
<   apply (drule word_power_increasing; simp add: word_len_min_2[simplified])
<   done
< 
< lemma less_2p_is_upper_bits_unset:
<   "((p::'a::len word) < 2 ^ n)
<     = (n < LENGTH('a) \<and> (\<forall>n' \<ge> n. n' < LENGTH('a) \<longrightarrow> \<not> p !! n'))"
<   apply (cases "n < LENGTH('a)")
<    apply (simp add: upper_bits_unset_is_l2p)
<   apply (simp add: power_overflow)
<   done
< 
4720,4727c4304,4305
<   apply (cases "n = 0", simp)
<   apply (simp only: word_neq_0_conv word_less_nat_alt shiftl_t2n mod_0 unat_word_ariths
<                     unat_power_lower word_le_nat_alt)
<   apply (subst mod_less)
<    apply (subst mult.commute, erule nat_less_power_trans)
<    apply simp
<   apply simp
<   done
---
>   by (metis and_mask_eq_iff_shiftr_0 less_mask_eq p2_gt_0 semiring_normalization_rules(7)
>             shiftl_shiftr_id shiftl_t2n)
4795c4373
<   \<not> is_aligned (p + of_nat i) n"
---
>    \<not> is_aligned (p + of_nat i) n"
4798,4802c4376
<   apply clarsimp
<   apply (subst (asm) unat_of_nat_len)
<    apply (metis order_less_trans unat_lt2p unat_power_lower)
<   apply (metis nat_dvd_not_less)
<   done
---
>   by (metis le_unat_uoi nat_dvd_not_less order_less_imp_le unat_power_lower)
4808c4382
< unfolding upto_enum_step_def
---
>   unfolding upto_enum_step_def
4818,4822c4392
<       using lt3
<       apply simp
<       apply (rule diff_less_mono[OF unat_mono, OF lt2])
<       apply (simp add: word_le_nat_alt[symmetric])
<       done
---
>       using lt2 lt3 unat_mono word_less_minus_mono_left by blast
4830c4400
<   shows "(max_word :: 'a::len word) = mask (LENGTH('a))"
---
>   "(max_word :: 'a::len word) = mask LENGTH('a)"
4832a4403,4404
> lemmas mask_len_max = max_word_mask[symmetric]
> 
4842c4414
<   "complement (2 ^ n - 1) = ~~ mask n"
---
>   "complement (2 ^ n - 1) = ~~ (mask n)"
4847,4848c4419
<   assumes al: "is_aligned a n"
<   and   sz: "n < LENGTH('a)"
---
>   assumes "is_aligned a n" "n < LENGTH('a)"
4850,4866c4421,4422
<   using sz al unfolding alignUp_def
<   apply (simp add: complement_mask)
<   apply (subst x_power_minus_1)
<   apply (subst neg_mask_is_div)
<   apply (simp only: word_arith_nat_div  unat_word_ariths)
<   apply (simp only: unat_power_lower)
<   apply (subst power_mod_div)
<   apply (erule is_alignedE)
<   apply simp
<   apply (subst unat_mult_power_lem)
<    apply simp
<   apply (subst unat_sub)
<    apply (subst unat_arith_simps)
<    apply simp
<   apply (simp add: del: unat_1)
<   apply simp
<   done
---
>   using assms unfolding alignUp_def
>   by (metis complement_mask is_aligned_add_helper p_assoc_help power_2_ge_iff)
4878,4889c4434,4435
<     apply -
<     apply (rule div_less)
<     apply (simp add: unat_minus_one)
<     apply (rule order_less_trans)
<      apply (rule diff_Suc_less)
<      apply (erule contrapos_np)
<      apply (simp add: unat_eq_zero)
<     apply (subst unat_power_lower [symmetric, OF sz])
<     apply (subst word_less_nat_alt [symmetric])
<     apply (rule word_mod_less_divisor)
<     apply (simp add: p2_gt_0)
<     done
---
>     by (meson Euclidean_Division.div_eq_0_iff le_m1_iff_lt measure_unat order_less_trans
>               unat_less_power word_less_sub_le word_mod_less_divisor)
4938,4942c4484
<     apply -
<     apply (subst td_gal_lt [symmetric])
<      apply simp
<     apply (simp add: power_add [symmetric])
<     done
---
>     by (metis shiftr_div_2n' word_shiftr_lt)
4945,4950c4487
<     apply -
<     apply (rule nat_le_power_trans)
<     apply simp
<     apply (rule Suc_leI [OF lt0])
<     apply simp
<     done
---
>     by (metis One_nat_def Suc_leI add.right_neutral add_Suc_right lt0 nat_le_power_trans nat_less_le)
5041,5045c4578
<       apply -
<       apply (subst td_gal_lt [symmetric])
<       apply simp
<       apply (simp add: power_add [symmetric])
<       done
---
>       by (metis shiftr_div_2n' word_shiftr_lt)
5048,5053c4581,4582
<       apply -
<       apply (rule nat_le_power_trans)
<       apply simp
<       apply (rule Suc_leI [OF lt0])
<       apply simp
<       done
---
>       by (metis One_nat_def Suc_leI add.right_neutral add_Suc_right lt0 nat_le_power_trans
>                 order_less_imp_le)
5062,5067c4591
<       apply (simp add: unat_div word_less_nat_alt)
<       apply (subst (asm) unat_of_nat)
<       apply (subst (asm) mod_less)
<        apply (rule order_less_le_trans [OF kv])
<        apply simp+
<       done
---
>       by (metis unat_div unat_less_helper unat_power_lower)
5124c4648
<   "alignUp a sz = a + 2 ^ sz - 1 && ~~ mask sz"
---
>   "alignUp a sz = a + 2 ^ sz - 1 && ~~ (mask sz)"
5129,5133c4653,4654
<   "\<lbrakk> x && ~~ mask n = y; n \<le> m \<rbrakk> \<Longrightarrow> x && ~~ mask m = y && ~~ mask m"
<   apply (rule word_eqI, rename_tac n')
<   apply (drule_tac x=n' in word_eqD)
<   apply (auto simp: word_ops_nth_size word_size)
<   done
---
>   "\<lbrakk> x && ~~ (mask n) = y; n \<le> m \<rbrakk> \<Longrightarrow> x && ~~ (mask m) = y && ~~ (mask m)"
>   by word_eqI_solve
5138,5148c4659
<   apply (rule ccontr,simp add:not_less)
<   apply (drule le_shiftr[where n = n])
<   apply (simp add: aligned_shift')
<   apply (case_tac "b >> n = a >> n")
<    apply (drule arg_cong[where f = "\<lambda>x. x<<n"])
<    apply (drule le_shiftr')
<     apply (clarsimp simp:is_aligned_shiftr_shiftl)
<    apply fastforce
<   apply (drule(1) le_shiftr')
<   apply simp
<   done
---
>   by (simp add: aligned_add_offset_less)
5152c4663
<   shows "p + (q && ~~ mask n) = (p + q) && ~~ mask n"
---
>   shows "p + (q && ~~ (mask n)) = (p + q) && ~~ (mask n)"
5157,5164c4668,4669
<   "alignUp a sz = 2^ sz + (a - 1 && ~~ mask sz)" (is "?lhs = ?rhs")
<   apply (simp add:alignUp_def2)
<   apply (subgoal_tac "2 ^ sz + a - 1 && ~~ mask sz = ?rhs")
<    apply (clarsimp simp:field_simps)
<   apply (subst mask_out_add_aligned)
<    apply (rule is_aligned_triv)
<   apply (simp add:field_simps)
<   done
---
>   "alignUp a sz = 2^ sz + (a - 1 && ~~ (mask sz))"
>   by (simp add: alignUp_def2 is_aligned_triv field_simps mask_out_add_aligned)
5168,5170c4673
<   apply (clarsimp simp:alignUp_def2 add.assoc)
<   apply (simp add: mask_out_add_aligned field_simps)
<   done
---
>   by (clarsimp simp: alignUp_def2 mask_out_add_aligned field_simps)
5173,5178c4676,4677
<   "n \<le> m \<Longrightarrow> (x && ~~ mask n) && ~~ mask m = x && ~~ mask m"
<   apply (rule word_eqI)
<   apply (simp add: word_size word_ops_nth_size)
<   apply safe
<   apply simp
<   done
---
>   "n \<le> m \<Longrightarrow> (x && ~~ (mask n)) && ~~ (mask m) = x && ~~ (mask m)"
>   by word_eqI_solve
5181,5182c4680,4681
<   "(a && ~~ mask n) && ~~ mask m = a && ~~ mask (max n m)"
<   by (rule word_eqI, simp add: neg_mask_bang conj_comms)
---
>   "(a && ~~ (mask n)) && ~~ (mask m) = a && ~~ (mask (max n m))"
>   by word_eqI_solve
5185,5189c4684,4685
<   "ucast (x && ~~ mask n) = ucast x && ~~ mask n"
<   apply (rule word_eqI)
<   apply (simp add: word_size neg_mask_bang nth_ucast)
<   apply (auto simp add: test_bit_bl word_size)
<   done
---
>   "ucast (x && ~~ (mask n)) = ucast x && ~~ (mask n)"
>   by word_eqI_solve
5193,5196c4689
<   apply (rule word_eqI)
<   apply (simp add: nth_ucast)
<   apply (auto simp add: test_bit_bl word_size)
<   done
---
>   by word_eqI_solve
5200,5204c4693
<   apply (rule word_eqI)
<   apply (simp add: nth_ucast word_size)
<   apply safe
<   apply (simp add: test_bit_bl word_size)
<   done
---
>   by word_eqI
5208,5247c4697,4698
<   apply (case_tac "LENGTH('a) \<le> sz")
<    apply (simp add:alignUp_def2 mask_def power_overflow)
<   apply (case_tac "is_aligned q sz")
<    apply (clarsimp simp:alignUp_def2 p_assoc_help)
<    apply (subst mask_out_add_aligned[symmetric],simp)+
<    apply (simp add:mask_lower_twice word_and_le2)
<    apply (simp add:and_not_mask)
<    apply (subst le_mask_iff[THEN iffD1])
<     apply (simp add:mask_def)
<    apply simp
<   apply (clarsimp simp:alignUp_def3)
<   apply (subgoal_tac "2 ^ sz - (q - (q - 1 && ~~ mask sz)) \<le> 2 ^ sz - 1")
<    apply (simp add:field_simps mask_def)
<   apply (rule word_sub_mono)
<      apply simp
<     apply (rule ccontr)
<     apply (clarsimp simp:not_le)
<     apply (drule eq_refl)
<     apply (drule order_trans[OF _ word_and_le2])
<     apply (subgoal_tac "q \<noteq>  0")
<      apply (drule minus_one_helper[rotated])
<       apply simp
<      apply simp
<     apply (fastforce)
<    apply (simp add: word_sub_le_iff)
<    apply (subgoal_tac "q - 1 && ~~ mask sz = (q - 1) - (q - 1 && mask sz)")
<     apply simp
<     apply (rule order_trans)
<      apply (rule word_add_le_mono2)
<       apply (rule word_and_le1)
<      apply (subst unat_plus_simple[THEN iffD1,symmetric])
<       apply (simp add:not_le mask_def)
<       apply (rule word_sub_1_le)
<       apply simp
<      apply (rule unat_lt2p)
<     apply (simp add:mask_def)
<    apply (simp add:mask_out_sub_mask)
<   apply (rule word_sub_1_le)
<   apply simp
<   done
---
>   by (metis (no_types) add.commute add_diff_cancel_left alignUp_def2 diff_add_cancel
>                        mask_2pm1 subtract_mask(2) word_and_le1 word_sub_le_iff)
5250c4701
<   "is_aligned p sz \<Longrightarrow> (p - q && ~~ mask sz) = (p - ((alignUp q sz) && ~~ mask sz))"
---
>   "is_aligned p sz \<Longrightarrow> (p - q && ~~ (mask sz)) = (p - ((alignUp q sz) && ~~ (mask sz)))"
5252,5253c4703
<   apply (subst mask_out_add_aligned[symmetric])
<    apply simp+
---
>   apply (subst mask_out_add_aligned[symmetric]; simp)
5256,5264c4706
<   apply (subst  mask_out_add_aligned)
<    apply (simp add:is_aligned_neg_mask)
<   apply simp
<   apply (subst and_not_mask[where w = "(alignUp q sz && ~~ mask sz) - q "])
<   apply (subst le_mask_iff[THEN iffD1])
<    apply (simp add:is_aligned_neg_mask_eq)
<    apply (rule alignUp_distance)
<   apply simp
<   done
---
>   by (simp add: alignUp_distance and_mask_0_iff_le_mask is_aligned_neg_mask_eq mask_out_add_aligned)
5272,5277c4714,4715
<   "~~ ((mask len << (len_of(TYPE('a)) - len))::'a::len word) = mask (len_of(TYPE('a)) - len)"
<   apply(rule Word.word_bool_alg.compl_unique)
<    subgoal using mask_shift_and_negate by simp
<   apply (rule word_eqI)
<   apply (simp add: word_size nth_shiftl nth_shiftr)
<   by auto
---
>   "~~ (mask len << (LENGTH('a) - len) ::'a::len word) = mask (LENGTH('a) - len)"
>   by (rule Word.word_bool_alg.compl_unique, simp) word_eqI_solve
5282,5286c4720,4721
<   fixes x :: "'a::len word"
<     and y :: "'b::len word"
<   assumes "LENGTH('b) \<le> LENGTH('a)"
<   shows   "x = ucast y \<Longrightarrow> ucast x = y"
<   using assms
---
>   "LENGTH('b) \<le> LENGTH('a) \<Longrightarrow> x = ucast y \<Longrightarrow> ucast x = y"
>   for x :: "'a::len word" and y :: "'b::len word"
5290,5297c4725,4727
<   fixes x :: "'a::len word"
<     and y :: "'b::len word"
<   assumes "LENGTH('b) \<le> LENGTH('a)"
<   shows   "x \<le> ucast y \<Longrightarrow> ucast x \<le> y"
<   using assms
<   apply (simp add: word_le_nat_alt unat_ucast_up_simp[where x=y])
<   apply (simp add: unat_ucast)
<   by (rule le_trans; fastforce)
---
>   "x \<le> ucast y \<Longrightarrow> ucast x \<le> y"
>   for x :: "'a::len word" and y :: "'b::len word"
>   by (smt le_unat_uoi linorder_not_less order_less_imp_le ucast_nat_def unat_arith_simps(1))
5300,5307c4730,4732
<   fixes x :: "'a::len word"
<     and y :: "'b::len word"
<   assumes "LENGTH('b) \<le> LENGTH('a)"
<   shows   "x < ucast y \<Longrightarrow> ucast x < y"
<   using assms
<   apply (simp add: word_less_nat_alt unat_ucast_up_simp[where x=y])
<   apply (simp add: unat_ucast)
<   by (rule le_less_trans; fastforce)
---
>   "LENGTH('b) \<le> LENGTH('a) \<Longrightarrow> x < ucast y \<Longrightarrow> ucast x < y"
>   for x :: "'a::len word" and y :: "'b::len word"
>   by (metis ucast_nat_def unat_mono unat_ucast_up_simp word_of_nat_less)
5310,5321c4735,4739
<   fixes x :: "'a::len word"
<     and y :: "'a::len word"
<   assumes "LENGTH('a) \<le> LENGTH('b)"
<   shows "(ucast x \<le> (ucast y::'b::len word)) = (x \<le> y)"
<   using assms
<   apply (simp add: word_le_nat_alt unat_ucast)
<   apply (subst mod_less)
<    apply(rule less_le_trans[OF unat_lt2p], simp)
<   apply (subst mod_less)
<    apply(rule less_le_trans[OF unat_lt2p], simp)
<   apply simp
<   done
---
>   "LENGTH('a) \<le> LENGTH('b) \<Longrightarrow> (ucast x \<le> (ucast y::'b::len word)) = (x \<le> y)"
>   for x :: "'a::len word"
>   by (simp add: unat_arith_simps(1) unat_ucast_up_simp)
> 
> lemmas ucast_up_mono_le = ucast_le_ucast[THEN iffD2]
5339,5354d4756
< (* High bits w.r.t. mask operations. *)
< 
< lemma and_neg_mask_eq_iff_not_mask_le:
<   "w && ~~ mask n = ~~ mask n \<longleftrightarrow> ~~ mask n \<le> w"
<   by (metis (full_types) dual_order.antisym neg_mask_mono_le word_and_le1 word_and_le2
<                          word_bool_alg.conj_absorb)
< 
< lemma le_mask_high_bits:
<   shows "w \<le> mask n \<longleftrightarrow> (\<forall> i \<in> {n ..< size w}. \<not> w !! i)"
<   by (auto simp: word_size and_mask_eq_iff_le_mask[symmetric] word_eq_iff)
< 
< lemma neg_mask_le_high_bits:
<   shows "~~ mask n \<le> w \<longleftrightarrow> (\<forall> i \<in> {n ..< size w}. w !! i)"
<   by (auto simp: word_size and_neg_mask_eq_iff_not_mask_le[symmetric]
<                  word_eq_iff neg_mask_bang)
< 
5368,5370c4770
<   apply (simp add: word_less_nat_alt shiftr_div_2n')
<   apply (blast intro: div_le_dividend le_less_trans)
<   done
---
>   by (metis div_le_dividend le_less_trans shiftr_div_2n' unat_arith_simps(2))
5379,5383c4779
<   apply (simp add: word_size)
<   apply (rule_tac y="length (to_bl w)" in order_trans)
<    apply (rule List.length_takeWhile_le)
<   apply simp
<   done
---
>   by (metis length_takeWhile_le word_size_bl)
5395,5396c4791
<       using takeWhile_take_has_property[where n="length (to_bl w)" and xs="to_bl w" and P=Not]
<       by simp
---
>       by (metis a length_takeWhile_less less_irrefl_nat word_clz_def)
5400,5403c4795
<      apply simp
<      apply (subst (asm) to_bl_0[symmetric])
<      apply (drule Word.word_bl.Rep_eqD, assumption)
<      done
---
>       by (metis to_bl_0 word_bl.Rep_eqD word_bl_Rep')
5493c4885
<   by (simp add: sign_extend_def neg_mask_bang word_size)
---
>   by (simp add: sign_extend_def neg_mask_test_bit word_size)
5503c4895
< lemmas sign_extend_bitwise_if' = sign_extend_bitwise_if[simplified word_size]
---
> lemmas sign_extend_bitwise_if'[word_eqI_simps] = sign_extend_bitwise_if[simplified word_size]
5510,5512c4902,4903
<   "sign_extend n w = (if w !! n then w || ~~ mask (Suc n) else w && mask (Suc n))"
<   by (rule word_eqI[rule_format])
<      (auto simp: sign_extend_bitwise_if' word_size word_ops_nth_size dest: less_antisym)
---
>   "sign_extend n w = (if w !! n then w || ~~ (mask (Suc n)) else w && mask (Suc n))"
>   by word_eqI (auto dest: less_antisym)
5521,5522c4912,4913
<    apply (rule word_eqI[rule_format], rename_tac i)
<    apply (case_tac "n < i"; simp add: sign_extended_def word_size sign_extend_bitwise_if')
---
>    apply (word_eqI, rename_tac i)
>    apply (case_tac "n < i"; simp add: sign_extended_def word_size)
5532c4923
<   by (cases "m < n") (auto intro!: word_eqI simp: word_size sign_extend_bitwise_cases')
---
>   by word_eqI
5540,5541c4931
<   by (rule word_eqI, fastforce dest: word_eqD simp: sign_extend_bitwise_if' word_size)
< 
---
>   by word_eqI_solve
5572,5573c4962,4963
<   "\<lbrakk>sign_extended n ptr; m \<le> n\<rbrakk> \<Longrightarrow> sign_extended n (ptr && ~~ mask m)"
<   by (fastforce simp: sign_extended_def word_size neg_mask_bang)
---
>   "\<lbrakk>sign_extended n ptr; m \<le> n\<rbrakk> \<Longrightarrow> sign_extended n (ptr && ~~ (mask m))"
>   by (fastforce simp: sign_extended_def word_size neg_mask_test_bit)
5653c5043
<   shows "(base = NOT mask (LENGTH('a) - len) AND a) \<longleftrightarrow>
---
>   shows "(base = NOT (mask (LENGTH('a) - len)) AND a) \<longleftrightarrow>
5657c5047
<   from assms show "base = NOT mask (LENGTH('a) - len) AND a \<Longrightarrow>
---
>   from assms show "base = NOT (mask (LENGTH('a) - len)) AND a \<Longrightarrow>
5665c5055
<   show "base = NOT mask (LENGTH('a) - len) AND a"
---
>   show "base = NOT (mask (LENGTH('a) - len)) AND a"
5667c5057
<     have f2: "\<forall>x\<^sub>0. base AND NOT mask x\<^sub>0 \<le> a AND NOT mask x\<^sub>0"
---
>     have f2: "\<forall>x\<^sub>0. base AND NOT (mask x\<^sub>0) \<le> a AND NOT (mask x\<^sub>0)"
5669c5059
<     have f3: "\<forall>x\<^sub>0. a AND NOT mask x\<^sub>0 \<le> (base OR mask (LENGTH('a) - len)) AND NOT mask x\<^sub>0"
---
>     have f3: "\<forall>x\<^sub>0. a AND NOT (mask x\<^sub>0) \<le> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\<^sub>0)"
5671c5061
<     have f4: "base = base AND NOT mask (LENGTH('a) - len)"
---
>     have f4: "base = base AND NOT (mask (LENGTH('a) - len))"
5673,5674c5063,5064
<     hence f5: "\<forall>x\<^sub>6. (base OR x\<^sub>6) AND NOT mask (LENGTH('a) - len) =
<                       base OR x\<^sub>6 AND NOT mask (LENGTH('a) - len)"
---
>     hence f5: "\<forall>x\<^sub>6. (base OR x\<^sub>6) AND NOT (mask (LENGTH('a) - len)) =
>                       base OR x\<^sub>6 AND NOT (mask (LENGTH('a) - len))"
5676,5677c5066,5067
<     have f6: "\<forall>x\<^sub>2 x\<^sub>3. a AND NOT mask x\<^sub>2 \<le> x\<^sub>3 \<or>
<                       \<not> (base OR mask (LENGTH('a) - len)) AND NOT mask x\<^sub>2 \<le> x\<^sub>3"
---
>     have f6: "\<forall>x\<^sub>2 x\<^sub>3. a AND NOT (mask x\<^sub>2) \<le> x\<^sub>3 \<or>
>                       \<not> (base OR mask (LENGTH('a) - len)) AND NOT (mask x\<^sub>2) \<le> x\<^sub>3"
5679c5069
<     have "base = (base OR mask (LENGTH('a) - len)) AND NOT mask (LENGTH('a) - len)"
---
>     have "base = (base OR mask (LENGTH('a) - len)) AND NOT (mask (LENGTH('a) - len))"
5681c5071
<     hence "base = a AND NOT mask (LENGTH('a) - len)"
---
>     hence "base = a AND NOT (mask (LENGTH('a) - len))"
5683c5073
<     thus "base = NOT mask (LENGTH('a) - len) AND a"
---
>     thus "base = NOT (mask (LENGTH('a) - len)) AND a"
5714,5724c5104,5158
<   "1 < LENGTH('a) \<Longrightarrow> of_nat (word_ctz (w :: ('a :: len) word)) \<noteq> (- 1 :: ('a::len) word)"
<   apply (cut_tac w=w in word_ctz_le)
<   apply (subst word_unat.Rep_inject[symmetric])
<   apply (subst unat_of_nat_eq)
<    apply (erule order_le_less_trans, fastforce)
<   apply (subst unat_minus_one_word)
<   apply (rule less_imp_neq)
<   apply (erule order_le_less_trans)
<   apply (subst less_eq_Suc_le)
<   apply (subst le_diff_conv2, fastforce)
<   apply (clarsimp simp: le_diff_conv2 less_eq_Suc_le[symmetric] suc_le_pow_2)
---
>   "1 < LENGTH('a) \<Longrightarrow> of_nat (word_ctz (w :: 'a :: len word)) \<noteq> (- 1 :: 'a::len word)"
>   by (metis (mono_tags) One_nat_def add.right_neutral add_Suc_right le_diff_conv le_less_trans
>                         n_less_equal_power_2 not_le suc_le_pow_2 unat_minus_one_word unat_of_nat_len
>                         word_ctz_le)
> 
> lemma word_aligned_add_no_wrap_bounded:
>   "\<lbrakk> w + 2^n \<le> x; w + 2^n \<noteq> 0; is_aligned w n \<rbrakk> \<Longrightarrow> (w::'a::len word) < x"
>   by (blast dest: is_aligned_no_overflow le_less_trans word_leq_le_minus_one)
> 
> lemma mask_Suc:
>   "mask (Suc n) = 2^n + mask n"
>   by (simp add: mask_def)
> 
> lemma is_aligned_no_overflow_mask:
>   "is_aligned x n \<Longrightarrow> x \<le> x + mask n"
>   by (simp add: mask_def) (erule is_aligned_no_overflow')
> 
> lemma is_aligned_mask_offset_unat:
>   fixes off :: "('a::len) word"
>   and     x :: "'a word"
>   assumes al: "is_aligned x sz"
>   and   offv: "off \<le> mask sz"
>   shows  "unat x + unat off < 2 ^ LENGTH('a)"
> proof cases
>   assume szv: "sz < LENGTH('a)"
>   from al obtain k where xv: "x = 2 ^ sz * (of_nat k)"
>     and kl: "k < 2 ^ (LENGTH('a) - sz)"
>     by (auto elim: is_alignedE)
> 
>   from offv szv have offv': "unat off < 2 ^ sz"
>     by (simp add: mask_2pm1 unat_less_power)
> 
>   show ?thesis using szv
>     using al is_aligned_no_wrap''' offv' by blast
> next
>   assume "\<not> sz < LENGTH('a)"
>   with al have "x = 0" by - word_eqI
>   thus ?thesis by simp
> qed
> 
> lemma of_bl_max:
>   "(of_bl xs :: 'a::len word) \<le> mask (length xs)"
>   apply (induct xs)
>    apply simp
>   apply (simp add: of_bl_Cons mask_Suc)
>   apply (rule conjI; clarsimp)
>    apply (erule word_plus_mono_right)
>    apply (rule is_aligned_no_overflow_mask)
>    apply (rule is_aligned_triv)
>   apply (simp add: word_le_nat_alt)
>   apply (subst unat_add_lem')
>    apply (rule is_aligned_mask_offset_unat)
>     apply (rule is_aligned_triv)
>    apply (simp add: mask_def)
>   apply simp
5727c5161,6254
< lemmas word_ctz_not_minus_1_32 = word_ctz_not_minus_1[where 'a=32, simplified]
---
> lemma mask_over_length:
>   "LENGTH('a) \<le> n \<Longrightarrow> mask n = (-1::'a::len word)"
>   by (simp add: mask_def)
> 
> lemma is_aligned_over_length:
>   "\<lbrakk> is_aligned p n; LENGTH('a) \<le> n \<rbrakk> \<Longrightarrow> (p::'a::len word) = 0"
>   by (simp add: is_aligned_mask mask_over_length)
> 
> lemma Suc_2p_unat_mask:
>   "n < LENGTH('a) \<Longrightarrow> Suc (2 ^ n * k + unat (mask n :: 'a::len word)) = 2 ^ n * (k+1)"
>   by (simp add: unat_mask)
> 
> lemma is_aligned_add_step_le:
>   "\<lbrakk> is_aligned (a::'a::len word) n; is_aligned b n; a < b; b \<le> a + mask n \<rbrakk> \<Longrightarrow> False"
>   apply (simp flip: not_le)
>   apply (erule notE)
>   apply (cases "LENGTH('a) \<le> n")
>    apply (drule (1) is_aligned_over_length)+
>    apply (drule mask_over_length)
>    apply clarsimp
>   apply (clarsimp simp: word_le_nat_alt not_less)
>   apply (subst (asm) unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)
>   apply (clarsimp simp: is_aligned_def dvd_def word_le_nat_alt)
>   apply (drule le_imp_less_Suc)
>   apply (simp add: Suc_2p_unat_mask)
>   by (metis Groups.mult_ac(2) Suc_leI linorder_not_less mult_le_mono order_refl times_nat.simps(2))
> 
> lemma power_2_mult_step_le:
>   "\<lbrakk>n' \<le> n; 2 ^ n' * k' < 2 ^ n * k\<rbrakk> \<Longrightarrow> 2 ^ n' * (k' + 1) \<le> 2 ^ n * (k::nat)"
>   apply (cases "n'=n", simp)
>    apply (metis Suc_leI le_refl mult_Suc_right mult_le_mono semiring_normalization_rules(7))
>   apply (drule (1) le_neq_trans)
>   apply clarsimp
>   apply (subgoal_tac "\<exists>m. n = n' + m")
>    prefer 2
>    apply (simp add: le_Suc_ex)
>   apply (clarsimp simp: power_add)
>   by (metis Suc_leI mult.assoc mult_Suc_right nat_mult_le_cancel_disj)
> 
> lemma aligned_mask_step:
>   "\<lbrakk> n' \<le> n; p' \<le> p + mask n; is_aligned p n; is_aligned p' n' \<rbrakk> \<Longrightarrow>
>    (p'::'a::len word) + mask n' \<le> p + mask n"
>   apply (cases "LENGTH('a) \<le> n")
>    apply (frule (1) is_aligned_over_length)
>    apply (drule mask_over_length)
>    apply clarsimp
>   apply (simp add: not_le)
>   apply (simp add: word_le_nat_alt unat_plus_simple)
>   apply (subst unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)+
>   apply (subst (asm) unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)
>   apply (clarsimp simp: is_aligned_def dvd_def)
>   apply (rename_tac k k')
>   apply (thin_tac "unat p = x" for p x)+
>   apply (subst Suc_le_mono[symmetric])
>   apply (simp only: Suc_2p_unat_mask)
>   apply (drule le_imp_less_Suc, subst (asm) Suc_2p_unat_mask, assumption)
>   apply (erule (1) power_2_mult_step_le)
>   done
> 
> lemma mask_mono:
>   "sz' \<le> sz \<Longrightarrow> mask sz' \<le> (mask sz :: 'a::len word)"
>   by (simp add: le_mask_iff shiftr_mask_le)
> 
> lemma aligned_mask_disjoint:
>   "\<lbrakk> is_aligned (a :: 'a :: len word) n; b \<le> mask n \<rbrakk> \<Longrightarrow> a && b = 0"
>   by word_eqI_solve
> 
> lemma word_and_or_mask_aligned:
>   "\<lbrakk> is_aligned a n; b \<le> mask n \<rbrakk> \<Longrightarrow> a + b = a || b"
>   by (simp add: aligned_mask_disjoint word_plus_and_or_coroll)
> 
> lemmas word_and_or_mask_aligned2 =
>   word_and_or_mask_aligned[where a=b and b=a for a b,
>                            simplified add.commute word_bool_alg.disj.commute]
> 
> lemma is_aligned_ucastI:
>   "is_aligned w n \<Longrightarrow> is_aligned (ucast w) n"
>   by (clarsimp simp: word_eqI_simps)
> 
> lemma ucast_le_maskI:
>   "a \<le> mask n \<Longrightarrow> UCAST('a::len \<rightarrow> 'b::len) a \<le> mask n"
>   by (metis and_mask_eq_iff_le_mask ucast_and_mask)
> 
> lemma ucast_add_mask_aligned:
>   "\<lbrakk> a \<le> mask n; is_aligned b n \<rbrakk> \<Longrightarrow> UCAST ('a::len \<rightarrow> 'b::len) (a + b) = ucast a + ucast b"
>   by (metis is_aligned_ucastI ucast_le_maskI ucast_or_distrib word_and_or_mask_aligned2)
> 
> lemma ucast_shiftl:
>   "LENGTH('b) \<le> LENGTH ('a) \<Longrightarrow> UCAST ('a::len \<rightarrow> 'b::len) x << n = ucast (x << n)"
>   by word_eqI_solve
> 
> lemma ucast_leq_mask:
>   "LENGTH('a) \<le> n \<Longrightarrow> ucast (x::'a::len0 word) \<le> mask n"
>   by (clarsimp simp: le_mask_high_bits word_size nth_ucast)
> 
> lemma shiftl_inj:
>   "\<lbrakk> x << n = y << n; x \<le> mask (LENGTH('a)-n); y \<le> mask (LENGTH('a)-n) \<rbrakk> \<Longrightarrow>
>    x = (y :: 'a :: len word)"
>   apply word_eqI
>   apply (rename_tac n')
>   apply (case_tac "LENGTH('a) - n \<le> n'", simp)
>   by (metis add.commute add.right_neutral diff_add_inverse le_diff_conv linorder_not_less zero_order(1))
> 
> lemma distinct_word_add_ucast_shift_inj:
>   "\<lbrakk> p + (UCAST('a::len \<rightarrow> 'b::len) off << n) = p' + (ucast off' << n);
>      is_aligned p n'; is_aligned p' n'; n' = n + LENGTH('a); n' < LENGTH('b) \<rbrakk>
>    \<Longrightarrow> p' = p \<and> off' = off"
>   apply (simp add: word_and_or_mask_aligned le_mask_shiftl_le_mask[where n="LENGTH('a)"]
>                    ucast_leq_mask)
>   apply (simp add: is_aligned_nth)
>   apply (rule conjI; word_eqI)
>    apply (metis add.commute test_bit_conj_lt diff_add_inverse le_diff_conv nat_less_le)
>   apply (rename_tac i)
>   apply (erule_tac x="i+n" in allE)
>   apply simp
>   done
> 
> lemma aligned_add_mask_lessD:
>   "\<lbrakk> x + mask n < y; is_aligned x n \<rbrakk> \<Longrightarrow> x < y" for y::"'a::len word"
>   by (metis is_aligned_no_overflow' mask_2pm1 order_le_less_trans)
> 
> lemma aligned_add_mask_less_eq:
>   "\<lbrakk> is_aligned x n; is_aligned y n;  n < LENGTH('a) \<rbrakk> \<Longrightarrow> (x + mask n < y) = (x < y)"
>   for y::"'a::len word"
>   using aligned_add_mask_lessD is_aligned_add_step_le word_le_not_less by blast
> 
> lemma word_upto_Nil:
>   "y < x \<Longrightarrow> [x .e. y ::'a::len word] = []"
>   by (simp add: upto_enum_red not_le word_less_nat_alt)
> 
> lemma word_enum_decomp_elem:
>   assumes "[x .e. (y ::'a::len word)] = as @ a # bs"
>   shows "x \<le> a \<and> a \<le> y"
> proof -
>   have "set as \<subseteq> set [x .e. y] \<and> a \<in> set [x .e. y]"
>     using assms by (auto dest: arg_cong[where f=set])
>   then show ?thesis by auto
> qed
> 
> lemma max_word_not_less[simp]:
>    "\<not> max_word < x"
>   by (simp add: not_less)
> 
> lemma word_enum_prefix:
>   "[x .e. (y ::'a::len word)] = as @ a # bs \<Longrightarrow> as = (if x < a then [x .e. a - 1] else [])"
>   apply (induct as arbitrary: x; clarsimp)
>    apply (case_tac "x < y")
>     prefer 2
>     apply (case_tac "x = y", simp)
>     apply (simp add: not_less)
>     apply (drule (1) dual_order.not_eq_order_implies_strict)
>     apply (simp add: word_upto_Nil)
>    apply (simp add: word_upto_Cons_eq)
>   apply (case_tac "x < y")
>    prefer 2
>    apply (case_tac "x = y", simp)
>    apply (simp add: not_less)
>    apply (drule (1) dual_order.not_eq_order_implies_strict)
>    apply (simp add: word_upto_Nil)
>   apply (clarsimp simp: word_upto_Cons_eq)
>   apply (frule word_enum_decomp_elem)
>   apply clarsimp
>   apply (rule conjI)
>    prefer 2
>    apply (subst word_Suc_le[symmetric]; clarsimp)
>   apply (drule meta_spec)
>   apply (drule (1) meta_mp)
>   apply clarsimp
>   apply (rule conjI; clarsimp)
>   apply (subst (2) word_upto_Cons_eq)
>    apply unat_arith
>   apply simp
>   done
> 
> lemma word_enum_decomp_set:
>   "[x .e. (y ::'a::len word)] = as @ a # bs \<Longrightarrow> a \<notin> set as"
>   by (metis distinct_append distinct_enum_upto' not_distinct_conv_prefix)
> 
> lemma word_enum_decomp:
>   assumes "[x .e. (y ::'a::len word)] = as @ a # bs"
>   shows "x \<le> a \<and> a \<le> y \<and> a \<notin> set as \<and> (\<forall>z \<in> set as. x \<le> z \<and> z \<le> y)"
> proof -
>   from assms
>   have "set as \<subseteq> set [x .e. y] \<and> a \<in> set [x .e. y]"
>     by (auto dest: arg_cong[where f=set])
>   with word_enum_decomp_set[OF assms]
>   show ?thesis by auto
> qed
> 
> lemma of_nat_unat_le_mask_ucast:
>   "\<lbrakk>of_nat (unat t) = w; t \<le> mask LENGTH('a)\<rbrakk> \<Longrightarrow> t = UCAST('a::len \<rightarrow> 'b::len) w"
>   by (clarsimp simp: ucast_nat_def ucast_ucast_mask simp flip: and_mask_eq_iff_le_mask)
> 
> lemma fold_eq_0_to_bool:
>   "(v = 0) = (\<not> to_bool v)"
>   by (simp add: to_bool_def)
> 
> lemma less_diff_gt0:
>   "a < b \<Longrightarrow> (0 :: 'a :: len word) < b - a"
>   by unat_arith
> 
> lemma unat_plus_gt:
>   "unat ((a :: 'a :: len word) + b) \<le> unat a + unat b"
>   by (clarsimp simp: unat_plus_if_size)
> 
> lemma const_less:
>   "\<lbrakk> (a :: 'a :: len word) - 1 < b; a \<noteq> b \<rbrakk> \<Longrightarrow> a < b"
>   by (metis less_1_simp word_le_less_eq)
> 
> lemma add_mult_aligned_neg_mask:
>   "m && (2 ^ n - 1) = 0 \<Longrightarrow> (x + y * m) && ~~(mask n) = (x && ~~(mask n)) + y * m"
>   by (metis Groups.add_ac(2) is_aligned_mask mask_def mask_eqs(5) mask_out_add_aligned
>             mult_zero_right shiftl_1 word_bw_comms(1) word_log_esimps(1))
> 
> lemma unat_of_nat_minus_1:
>   "\<lbrakk> n < 2 ^ LENGTH('a); n \<noteq> 0 \<rbrakk> \<Longrightarrow> unat ((of_nat n:: 'a :: len word) - 1) = n - 1"
>   by (simp add: unat_eq_of_nat)
> 
> lemma word_eq_zeroI:
>   "a \<le> a - 1 \<Longrightarrow> a = 0" for a :: "'a :: len word"
>   by (simp add: word_must_wrap)
> 
> lemma word_add_format:
>   "(-1 :: 'a :: len  word) + b + c = b + (c - 1)"
>   by simp
> 
> lemma upto_enum_word_nth:
>   "\<lbrakk> i \<le> j; k \<le> unat (j - i) \<rbrakk> \<Longrightarrow> [i .e. j] ! k = i + of_nat k"
>   apply (clarsimp simp: upto_enum_def nth_append)
>   apply (clarsimp simp: word_le_nat_alt[symmetric])
>   apply (rule conjI, clarsimp)
>    apply (subst toEnum_of_nat, unat_arith)
>    apply unat_arith
>   apply (clarsimp simp: not_less unat_sub[symmetric])
>   apply unat_arith
>   done
> 
> lemma upto_enum_step_nth:
>   "\<lbrakk> a \<le> c; n \<le> unat ((c - a) div (b - a)) \<rbrakk>
>    \<Longrightarrow> [a, b .e. c] ! n = a + of_nat n * (b - a)"
>   by (clarsimp simp: upto_enum_step_def not_less[symmetric] upto_enum_word_nth)
> 
> lemma upto_enum_inc_1_len:
>   "a < - 1 \<Longrightarrow> [(0 :: 'a :: len word) .e. 1 + a] = [0 .e. a] @ [1 + a]"
>   apply (simp add: upto_enum_word)
>   apply (subgoal_tac "unat (1+a) = 1 + unat a")
>    apply simp
>   apply (subst unat_plus_simple[THEN iffD1])
>    apply (metis add.commute no_plus_overflow_neg olen_add_eqv)
>   apply unat_arith
>   done
> 
> lemma neg_mask_add:
>   "y && mask n = 0 \<Longrightarrow> x + y && ~~(mask n) = (x && ~~(mask n)) + y"
>   by (clarsimp simp: mask_out_sub_mask mask_eqs(7)[symmetric] mask_twice)
> 
> lemma shiftr_shiftl_shiftr[simp]:
>   "(x :: 'a :: len word)  >> a << a >> a = x >> a"
>   by word_eqI_solve
> 
> lemma add_right_shift:
>   "\<lbrakk> x && mask n = 0; y && mask n = 0; x \<le> x + y \<rbrakk>
>    \<Longrightarrow> (x + y :: ('a :: len) word) >> n = (x >> n) + (y >> n)"
>   apply (simp add: no_olen_add_nat is_aligned_mask[symmetric])
>   apply (simp add: unat_arith_simps shiftr_div_2n' split del: if_split)
>   apply (subst if_P)
>    apply (erule order_le_less_trans[rotated])
>    apply (simp add: add_mono)
>   apply (simp add: shiftr_div_2n' is_aligned_def)
>   done
> 
> lemma sub_right_shift:
>   "\<lbrakk> x && mask n = 0; y && mask n = 0; y \<le> x \<rbrakk>
>    \<Longrightarrow> (x - y) >> n = (x >> n :: 'a :: len word) - (y >> n)"
>   using add_right_shift[where x="x - y" and y=y and n=n]
>   by (simp add: aligned_sub_aligned is_aligned_mask[symmetric] word_sub_le)
> 
> lemma and_and_mask_simple:
>   "y && mask n = mask n \<Longrightarrow> (x && y) && mask n = x && mask n"
>   by (simp add: word_bool_alg.conj.assoc)
> 
> lemma and_and_mask_simple_not:
>   "y && mask n = 0 \<Longrightarrow> (x && y) && mask n = 0"
>   by (simp add: word_bool_alg.conj.assoc)
> 
> lemma word_and_le':
>   "b \<le> c \<Longrightarrow> (a :: 'a :: len word) && b \<le> c"
>   by (metis word_and_le1 order_trans)
> 
> lemma word_and_less':
>   "b < c \<Longrightarrow> (a :: 'a :: len word) && b < c"
>   by (metis word_and_le1 xtr7)
> 
> lemma shiftr_w2p:
>   "x < LENGTH('a) \<Longrightarrow> 2 ^ x = (2 ^ (LENGTH('a) - 1) >> (LENGTH('a) - 1 - x) :: 'a :: len word)"
>   by word_eqI_solve
> 
> lemma t2p_shiftr:
>   "\<lbrakk> b \<le> a; a < LENGTH('a) \<rbrakk> \<Longrightarrow> (2 :: 'a :: len word) ^ a >> b = 2 ^ (a - b)"
>   by word_eqI_solve
> 
> lemma scast_1[simp]:
>   "scast (1 :: 'a :: len signed word) = (1 :: 'a word)"
>   by simp
> 
> lemma ucast_ucast_mask_eq:
>   "\<lbrakk> UCAST('a::len \<rightarrow> 'b::len) x = y; x && mask LENGTH('b) = x \<rbrakk> \<Longrightarrow> x = ucast y"
>   by word_eqI_solve
> 
> lemma ucast_up_eq:
>   "\<lbrakk> ucast x = (ucast y::'b::len word); LENGTH('a) \<le> LENGTH ('b) \<rbrakk>
>    \<Longrightarrow> ucast x = (ucast y::'a::len word)"
>   by word_eqI_solve
> 
> lemma ucast_up_neq:
>   "\<lbrakk> ucast x \<noteq> (ucast y::'b::len word); LENGTH('b) \<le> LENGTH ('a) \<rbrakk>
>    \<Longrightarrow> ucast x \<noteq> (ucast y::'a::len word)"
>   by (fastforce dest: ucast_up_eq)
> 
> lemma mask_AND_less_0:
>   "\<lbrakk> x && mask n = 0; m \<le> n \<rbrakk> \<Longrightarrow> x && mask m = 0"
>   by (metis mask_twice2 word_and_notzeroD)
> 
> lemma mask_len_id [simp]:
>   "(x :: 'a :: len word) && mask LENGTH('a) = x"
>   using uint_lt2p [of x] by (simp add: mask_eq_iff)
> 
> lemma scast_ucast_down_same:
>   "LENGTH('b) \<le> LENGTH('a) \<Longrightarrow> SCAST('a \<rightarrow> 'b) = UCAST('a::len \<rightarrow> 'b::len)"
>   by (simp add: down_cast_same is_down)
> 
> lemma word_aligned_0_sum:
>   "\<lbrakk> a + b = 0; is_aligned (a :: 'a :: len word) n; b \<le> mask n; n < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> a = 0 \<and> b = 0"
>   by (simp add: word_plus_and_or_coroll aligned_mask_disjoint word_or_zero)
> 
> lemma mask_eq1_nochoice:
>   "\<lbrakk> LENGTH('a) > 1; (x :: 'a :: len word) && 1 = x \<rbrakk> \<Longrightarrow> x = 0 \<or> x = 1"
>   by (metis word_and_1)
> 
> lemma pow_mono_leq_imp_lt:
>   "x \<le> y \<Longrightarrow> x < 2 ^ y"
>   by (simp add: le_less_trans)
> 
> lemma unat_of_nat_ctz_mw:
>   "unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len word) = word_ctz w"
>   using word_ctz_le[where w=w, simplified] unat_of_nat_eq[where x="word_ctz w" and 'a="'a"]
>         pow_mono_leq_imp_lt
>   by simp
> 
> lemma unat_of_nat_ctz_smw:
>   "unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len sword) = word_ctz w"
>   using word_ctz_le[where w=w, simplified] unat_of_nat_eq[where x="word_ctz w" and 'a="'a"]
>         pow_mono_leq_imp_lt
>   by (metis le_unat_uoi le_unat_uoi linorder_neqE_nat nat_less_le scast_of_nat
>             word_unat.Rep_inverse)
> 
> lemma shiftr_and_eq_shiftl:
>   "(w >> n) && x = y \<Longrightarrow> w && (x << n) = (y << n)" for y :: "'a:: len word"
>   by (smt and_not_mask is_aligned_neg_mask_eq is_aligned_shift shift_over_ao_dists(4)
>           word_bool_alg.conj_assoc word_bw_comms(1))
> 
> lemma neg_mask_combine:
>   "~~(mask a) && ~~(mask b) = ~~(mask (max a b))"
>   by (auto simp: word_ops_nth_size word_size intro!: word_eqI)
> 
> lemma neg_mask_twice:
>   "x && ~~(mask n) && ~~(mask m) = x && ~~(mask (max n m))"
>   by (metis neg_mask_combine)
> 
> lemma multiple_mask_trivia:
>   "n \<ge> m \<Longrightarrow> (x && ~~(mask n)) + (x && mask n && ~~(mask m)) = x && ~~(mask m)"
>   apply (rule trans[rotated], rule_tac w="mask n" in word_plus_and_or_coroll2)
>   apply (simp add: word_bw_assocs word_bw_comms word_bw_lcs neg_mask_twice
>                    max_absorb2)
>   done
> 
> lemma add_mask_lower_bits':
>   "\<lbrakk> len = LENGTH('a); is_aligned (x :: 'a :: len word) n;
>      \<forall>n' \<ge> n. n' < len \<longrightarrow> \<not> p !! n' \<rbrakk>
>    \<Longrightarrow> x + p && ~~(mask n) = x"
>   using add_mask_lower_bits by auto
> 
> lemma neg_mask_in_mask_range:
>   "is_aligned ptr bits \<Longrightarrow> (ptr' && ~~(mask bits) = ptr) = (ptr' \<in> mask_range ptr bits)"
>   apply (erule is_aligned_get_word_bits)
>    apply (rule iffI)
>     apply (drule sym)
>     apply (simp add: word_and_le2)
>     apply (subst word_plus_and_or_coroll, word_eqI_solve)
>     apply (metis le_word_or2 neg_mask_add_mask word_bool_alg.conj.right_idem)
>    apply clarsimp
>    apply (smt add.right_neutral eq_iff is_aligned_neg_mask_eq mask_out_add_aligned neg_mask_mono_le
>               word_and_not)
>   apply (simp add: power_overflow mask_def)
>   done
> 
> lemma aligned_offset_in_range:
>   "\<lbrakk> is_aligned (x :: 'a :: len word) m; y < 2 ^ m; is_aligned p n; n \<ge> m; n < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> (x + y \<in> {p .. p + mask n}) = (x \<in> mask_range p n)"
>   apply (simp only: is_aligned_add_or flip: neg_mask_in_mask_range)
>   by (metis less_mask_eq mask_subsume)
> 
> lemma mask_range_to_bl':
>   "\<lbrakk> is_aligned (ptr :: 'a :: len word) bits; bits < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> mask_range ptr bits
>        = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}"
>   apply (rule set_eqI, rule iffI)
>    apply clarsimp
>    apply (subgoal_tac "\<exists>y. x = ptr + y \<and> y < 2 ^ bits")
>     apply clarsimp
>     apply (subst is_aligned_add_conv)
>        apply assumption
>       apply simp
>     apply simp
>    apply (rule_tac x="x - ptr" in exI)
>    apply (simp add: add_diff_eq[symmetric])
>    apply (simp only: word_less_sub_le[symmetric])
>    apply (rule word_diff_ls')
>     apply (simp add: field_simps mask_def)
>    apply assumption
>   apply simp
>   apply (subgoal_tac "\<exists>y. y < 2 ^ bits \<and> to_bl (ptr + y) = to_bl x")
>    apply clarsimp
>    apply (rule conjI)
>     apply (erule(1) is_aligned_no_wrap')
>    apply (simp only: add_diff_eq[symmetric] mask_def)
>    apply (rule word_plus_mono_right)
>     apply simp
>    apply (erule is_aligned_no_wrap')
>    apply simp
>   apply (rule_tac x="of_bl (drop (LENGTH('a) - bits) (to_bl x))" in exI)
>   apply (rule context_conjI)
>    apply (rule order_less_le_trans [OF of_bl_length])
>     apply simp
>    apply simp
>   apply (subst is_aligned_add_conv)
>      apply assumption
>     apply simp
>   apply (drule sym)
>   apply (simp add: word_rep_drop)
>   done
> 
> lemma mask_range_to_bl:
>   "is_aligned (ptr :: 'a :: len word) bits
>    \<Longrightarrow> mask_range ptr bits
>         = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}"
>   apply (erule is_aligned_get_word_bits)
>    apply (erule(1) mask_range_to_bl')
>   apply (rule set_eqI)
>   apply (simp add: power_overflow mask_def)
>   done
> 
> lemma aligned_mask_range_cases:
>   "\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n' \<rbrakk>
>    \<Longrightarrow> mask_range p n \<inter> mask_range p' n' = {} \<or>
>        mask_range p n \<subseteq> mask_range p' n' \<or>
>        mask_range p n \<supseteq> mask_range p' n'"
>   apply (simp add: mask_range_to_bl)
>   apply (rule Meson.disj_comm, rule disjCI)
>   apply (erule nonemptyE)
>   apply simp
>   apply (subgoal_tac "(\<exists>n''. LENGTH('a) - n = (LENGTH('a) - n') + n'')
>                     \<or> (\<exists>n''. LENGTH('a) - n' = (LENGTH('a) - n) + n'')")
>    apply (fastforce simp: take_add)
>   apply arith
>   done
> 
> lemma aligned_mask_range_offset_subset:
>   assumes al: "is_aligned (ptr :: 'a :: len word) sz" and al': "is_aligned x sz'"
>   and szv: "sz' \<le> sz"
>   and xsz: "x < 2 ^ sz"
>   shows "mask_range (ptr+x) sz' \<subseteq> mask_range ptr sz"
>   using al
> proof (rule is_aligned_get_word_bits)
>   assume p0: "ptr = 0" and szv': "LENGTH ('a) \<le> sz"
>   then have "(2 ::'a word) ^ sz = 0" by simp
>   show ?thesis using p0
>     by (simp add: \<open>2 ^ sz = 0\<close> mask_def)
> next
>   assume szv': "sz < LENGTH('a)"
> 
>   hence blah: "2 ^ (sz - sz') < (2 :: nat) ^ LENGTH('a)"
>     using szv by auto
>   show ?thesis using szv szv'
>     apply (intro range_subsetI)
>      apply (rule is_aligned_no_wrap' [OF al xsz])
>     apply (simp only: flip: add_diff_eq add_mask_fold)
>     apply (subst add.assoc, rule word_plus_mono_right)
>      using al' is_aligned_add_less_t2n xsz
>      apply fastforce
>     apply (simp add: field_simps szv al is_aligned_no_overflow)
>     done
> qed
> 
> lemma aligned_mask_diff:
>   "\<lbrakk> is_aligned (dest :: 'a :: len word) bits; is_aligned (ptr :: 'a :: len word) sz;
>      bits \<le> sz; sz < LENGTH('a); dest < ptr \<rbrakk>
>    \<Longrightarrow> mask bits + dest < ptr"
>   apply (frule_tac p' = ptr in aligned_mask_range_cases, assumption)
>   apply (elim disjE)
>     apply (drule_tac is_aligned_no_overflow_mask, simp)+
>     apply (simp add: algebra_split_simps word_le_not_less)
>    apply (drule is_aligned_no_overflow_mask; fastforce)
>   by (simp add: aligned_add_mask_less_eq is_aligned_weaken algebra_split_simps)
> 
> lemma aligned_mask_ranges_disjoint:
>   "\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n';
>      p && ~~(mask n') \<noteq> p'; p' && ~~(mask n) \<noteq> p \<rbrakk>
>    \<Longrightarrow> mask_range p n \<inter> mask_range p' n' = {}"
>   using aligned_mask_range_cases
>   by (auto simp: neg_mask_in_mask_range)
> 
> lemma aligned_mask_ranges_disjoint2:
>   "\<lbrakk> is_aligned p n; is_aligned ptr bits; n \<ge> m; n < size p; m \<le> bits;
>      (\<forall>y < 2 ^ (n - m). p + (y << m) \<notin> mask_range ptr bits) \<rbrakk>
>    \<Longrightarrow> mask_range p n \<inter> mask_range ptr bits = {}"
>   apply safe
>   apply (simp only: flip: neg_mask_in_mask_range)
>   apply (drule_tac x="x && mask n >> m" in spec)
>   apply (clarsimp simp: shiftr_less_t2n and_mask_less_size wsst_TYs multiple_mask_trivia
>                         word_bw_assocs neg_mask_twice max_absorb2 shiftr_shiftl1)
>   done
> 
> lemma leq_mask_shift:
>   "(x :: 'a :: len word) \<le> mask (low_bits + high_bits) \<Longrightarrow> (x >> low_bits) \<le> mask high_bits"
>   by (simp add: le_mask_iff shiftr_shiftr)
> 
> lemma ucast_ucast_eq_mask_shift:
>   "(x :: 'a :: len word) \<le> mask (low_bits + LENGTH('b))
>    \<Longrightarrow> ucast((ucast (x >> low_bits)) :: 'b :: len word) = x >> low_bits"
>   by (meson and_mask_eq_iff_le_mask eq_ucast_ucast_eq not_le_imp_less shiftr_less_t2n'
>             ucast_ucast_len)
> 
> lemma const_le_unat:
>   "\<lbrakk> b < 2 ^ LENGTH('a); of_nat b \<le> a \<rbrakk> \<Longrightarrow> b \<le> unat (a :: 'a :: len word)"
>   by (clarsimp simp: word_le_def uint_nat of_nat_inverse)
> 
> lemma upt_enum_offset_trivial:
>   "\<lbrakk> x < 2 ^ LENGTH('a) - 1 ; n \<le> unat x \<rbrakk>
>    \<Longrightarrow> ([(0 :: 'a :: len word) .e. x] ! n) = of_nat n"
>   apply (induct x arbitrary: n)
>     apply simp
>   by (simp add: upto_enum_word_nth)
> 
> lemma word_le_mask_out_plus_2sz:
>   "x \<le> (x && ~~(mask sz)) + 2 ^ sz - 1"
>   by (metis add_diff_eq word_neg_and_le)
> 
> lemma ucast_add:
>   "ucast (a + (b :: 'a :: len word)) = ucast a + (ucast b :: ('a signed word))"
>   apply (case_tac "LENGTH('a) = 1")
>    apply (clarsimp simp: ucast_def)
>    apply (metis (hide_lams, mono_tags) One_nat_def len_signed plus_word.abs_eq
>                                        uint_word_arith_bintrs(1) word_ubin.Abs_norm)
>   apply (clarsimp simp: ucast_def)
>   apply (metis le_refl len_signed plus_word.abs_eq uint_word_arith_bintrs(1) wi_bintr)
>   done
> 
> lemma ucast_minus:
>   "ucast (a - (b :: 'a :: len word)) = ucast a - (ucast b :: ('a signed word))"
>   apply (insert ucast_add[where a=a and b="-b"])
>   apply (metis (no_types, hide_lams) add_diff_eq diff_add_cancel ucast_add)
>   done
> 
> lemma scast_ucast_add_one [simp]:
>   "scast (ucast (x :: 'a::len word) + (1 :: 'a signed word)) = x + 1"
>   apply (subst ucast_1[symmetric])
>   apply (subst ucast_add[symmetric])
>   apply clarsimp
>   done
> 
> lemma word_and_le_plus_one:
>   "a > 0 \<Longrightarrow> (x :: 'a :: len word) && (a - 1) < a"
>   by (simp add: gt0_iff_gem1 word_and_less')
> 
> lemma unat_of_ucast_then_shift_eq_unat_of_shift[simp]:
>   "LENGTH('b) \<ge> LENGTH('a)
>    \<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) >> n) = unat (x >> n)"
>   by (simp add: shiftr_div_2n' unat_ucast_up_simp)
> 
> lemma unat_of_ucast_then_mask_eq_unat_of_mask[simp]:
>   "LENGTH('b) \<ge> LENGTH('a)
>    \<Longrightarrow> unat ((ucast (x :: 'a :: len word) :: 'b :: len word) && mask m) = unat (x && mask m)"
>   by (metis ucast_and_mask unat_ucast_up_simp)
> 
> lemma small_powers_of_2:
>   "x \<ge> 3 \<Longrightarrow> x < 2 ^ (x - 1)"
>   by (induct x; simp add: suc_le_pow_2)
> 
> lemma word_clz_sint_upper[simp]:
>   "LENGTH('a) \<ge> 3 \<Longrightarrow> sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a sword) \<le> int (LENGTH('a))"
>   using small_powers_of_2
>   by (smt One_nat_def diff_less le_less_trans len_gt_0 len_signed lessI n_less_equal_power_2
>            not_msb_from_less of_nat_mono sint_eq_uint uint_nat unat_of_nat_eq unat_power_lower
>            word_clz_max word_of_nat_less wsst_TYs(3))
> 
> lemma word_clz_sint_lower[simp]:
>   "LENGTH('a) \<ge> 3
>    \<Longrightarrow> - sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a signed word) \<le> int (LENGTH('a))"
>   apply (subst sint_eq_uint)
>    using small_powers_of_2 uint_nat
>    apply (simp add: order_le_less_trans[OF word_clz_max] not_msb_from_less word_of_nat_less
>                     word_size)
>   by (simp add: uint_nat)
> 
> lemma shiftr_less_t2n3:
>   "\<lbrakk> (2 :: 'a word) ^ (n + m) = 0; m < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> (x :: 'a :: len word) >> n < 2 ^ m"
>   by (fastforce intro: shiftr_less_t2n' simp: mask_def power_overflow)
> 
> lemma unat_shiftr_le_bound:
>   "\<lbrakk> 2 ^ (LENGTH('a :: len) - n) - 1 \<le> bnd; 0 < n \<rbrakk>
>    \<Longrightarrow> unat ((x :: 'a word) >> n) \<le> bnd"
>   using less_not_refl3 le_step_down_nat le_trans less_or_eq_imp_le word_shiftr_lt
>   by (metis (no_types, lifting))
> 
> lemma shiftr_eqD:
>   "\<lbrakk> x >> n = y >> n; is_aligned x n; is_aligned y n \<rbrakk>
>    \<Longrightarrow> x = y"
>   by (metis is_aligned_shiftr_shiftl)
> 
> lemma word_shiftr_shiftl_shiftr_eq_shiftr:
>   "a \<ge> b \<Longrightarrow> (x :: 'a :: len word) >> a << b >> b = x >> a"
>   by (simp add: mask_shift multi_shift_simps(5) shiftr_shiftr)
> 
> lemma of_int_uint_ucast:
>    "of_int (uint (x :: 'a::len word)) = (ucast x :: 'b::len word)"
>   by (simp add: ucast_def word_of_int)
> 
> lemma mod_mask_drop:
>   "\<lbrakk> m = 2 ^ n; 0 < m; mask n && msk = mask n \<rbrakk>
>    \<Longrightarrow> (x mod m) && msk = x mod m"
>   by (simp add: word_mod_2p_is_mask word_bw_assocs)
> 
> lemma mask_eq_ucast_eq:
>   "\<lbrakk> x && mask LENGTH('a) = (x :: ('c :: len word));
>      LENGTH('a) \<le> LENGTH('b)\<rbrakk>
>     \<Longrightarrow> ucast (ucast x :: ('a :: len word)) = (ucast x :: ('b :: len word))"
>   by (metis ucast_and_mask ucast_id ucast_ucast_mask ucast_up_eq)
> 
> lemma of_nat_less_t2n:
>   "of_nat i < (2 :: ('a :: len) word) ^ n \<Longrightarrow> n < LENGTH('a) \<and> unat (of_nat i :: 'a word) < 2 ^ n"
>   by (metis order_less_trans p2_gt_0 unat_less_power word_neq_0_conv)
> 
> lemma two_power_increasing_less_1:
>   "\<lbrakk> n \<le> m; m \<le> LENGTH('a) \<rbrakk> \<Longrightarrow> (2 :: 'a :: len word) ^ n - 1 \<le> 2 ^ m - 1"
>   by (metis diff_diff_cancel le_m1_iff_lt less_imp_diff_less p2_gt_0 two_power_increasing
>             word_1_le_power word_le_minus_mono_left word_less_sub_1)
> 
> lemma word_sub_mono4:
>   "\<lbrakk> y + x \<le> z + x; y \<le> y + x; z \<le> z + x \<rbrakk> \<Longrightarrow> y \<le> z" for y :: "'a :: len word"
>   by (simp add: word_add_le_iff2)
> 
> lemma eq_or_less_helperD:
>   "\<lbrakk> n = unat (2 ^ m - 1 :: 'a :: len word) \<or> n < unat (2 ^ m - 1 :: 'a word); m < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> n < 2 ^ m"
>   by (meson le_less_trans nat_less_le unat_less_power word_power_less_1)
> 
> lemma mask_sub:
>   "n \<le> m \<Longrightarrow> mask m - mask n = mask m && ~~(mask n)"
>   by (metis (no_types) AND_NOT_mask_plus_AND_mask_eq add_right_imp_eq diff_add_cancel
>                        and_mask_eq_iff_shiftr_0 shiftr_mask_le word_bool_alg.conj.commute)
> 
> lemma neg_mask_diff_bound:
>   "sz'\<le> sz \<Longrightarrow> (ptr && ~~(mask sz')) - (ptr && ~~(mask sz)) \<le> 2 ^ sz - 2 ^ sz'"
>   (is "_ \<Longrightarrow> ?lhs \<le> ?rhs")
> proof -
>   assume lt: "sz' \<le> sz"
>   hence "?lhs = ptr && (mask sz && ~~(mask sz'))"
>     by (metis add_diff_cancel_left' multiple_mask_trivia)
>   also have "\<dots> \<le> ?rhs" using lt
>     by (metis (mono_tags) add_diff_eq diff_eq_eq eq_iff mask_2pm1 mask_sub word_and_le')
>   finally show ?thesis by simp
> qed
> 
> lemma mask_range_subsetD:
>   "\<lbrakk> p' \<in> mask_range p n; x' \<in> mask_range p' n'; n' \<le> n; is_aligned p n; is_aligned p' n' \<rbrakk> \<Longrightarrow>
>    x' \<in> mask_range p n"
>   using aligned_mask_step by fastforce
> 
> lemma add_mult_in_mask_range:
>   "\<lbrakk> is_aligned (base :: 'a :: len word) n; n < LENGTH('a); bits \<le> n; x < 2 ^ (n - bits) \<rbrakk>
>    \<Longrightarrow> base + x * 2^bits \<in> mask_range base n"
>   by (simp add: is_aligned_no_wrap' mask_2pm1 nasty_split_lt word_less_power_trans2
>                 word_plus_mono_right)
> 
> lemma of_bl_length2:
>   "length xs + c < LENGTH('a) \<Longrightarrow> of_bl xs * 2^c < (2::'a::len word) ^ (length xs + c)"
>   by (simp add: of_bl_length word_less_power_trans2)
> 
> lemma mask_out_eq_0:
>   "\<lbrakk> idx < 2 ^ sz; sz < LENGTH('a) \<rbrakk> \<Longrightarrow> (of_nat idx :: 'a :: len word) && ~~(mask sz) = 0"
>   by (simp add: Word_Lemmas.of_nat_power less_mask_eq mask_eq_0_eq_x)
> 
> lemma is_aligned_neg_mask_eq':
>   "is_aligned ptr sz = (ptr && ~~(mask sz) = ptr)"
>   using is_aligned_mask mask_eq_0_eq_x by blast
> 
> lemma neg_mask_mask_unat:
>   "sz < LENGTH('a)
>    \<Longrightarrow> unat ((ptr :: 'a :: len word) && ~~(mask sz)) + unat (ptr && mask sz) = unat ptr"
>   by (metis AND_NOT_mask_plus_AND_mask_eq unat_plus_simple word_and_le2)
> 
> lemma unat_pow_le_intro:
>   "LENGTH('a) \<le> n \<Longrightarrow> unat (x :: 'a :: len word) < 2 ^ n"
>   by (metis lt2p_lem not_le of_nat_le_iff of_nat_numeral semiring_1_class.of_nat_power uint_nat)
> 
> lemma unat_shiftl_less_t2n:
>   "\<lbrakk> unat (x :: 'a :: len word) < 2 ^ (m - n); m < LENGTH('a) \<rbrakk> \<Longrightarrow> unat (x << n) < 2 ^ m"
>   by (metis (no_types) Word_Lemmas.of_nat_power diff_le_self le_less_trans shiftl_less_t2n
>                        unat_less_power word_unat.Rep_inverse)
> 
> lemma unat_is_aligned_add:
>   "\<lbrakk> is_aligned p n; unat d < 2 ^ n \<rbrakk>
>    \<Longrightarrow> unat (p + d && mask n) = unat d \<and> unat (p + d && ~~(mask n)) = unat p"
>   by (metis add.right_neutral and_mask_eq_iff_le_mask and_not_mask le_mask_iff mask_add_aligned
>             mask_out_add_aligned mult_zero_right shiftl_t2n shiftr_le_0)
> 
> lemma unat_shiftr_shiftl_mask_zero:
>   "\<lbrakk> c + a \<ge> LENGTH('a) + b ; c < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> unat (((q :: 'a :: len word) >> a << b) && ~~(mask c)) = 0"
>   by (fastforce intro: unat_is_aligned_add[where p=0 and n=c, simplified, THEN conjunct2]
>                        unat_shiftl_less_t2n unat_shiftr_less_t2n unat_pow_le_intro)
> 
> lemmas of_nat_ucast = ucast_of_nat[symmetric]
> 
> lemma shift_then_mask_eq_shift_low_bits:
>   "x \<le> mask (low_bits + high_bits) \<Longrightarrow> (x >> low_bits) && mask high_bits = x >> low_bits"
>   by (simp add: leq_mask_shift le_mask_imp_and_mask)
> 
> lemma leq_low_bits_iff_zero:
>   "\<lbrakk> x \<le> mask (low bits + high bits); x >> low_bits = 0 \<rbrakk> \<Longrightarrow> (x && mask low_bits = 0) = (x = 0)"
>   using and_mask_eq_iff_shiftr_0 by force
> 
> lemma unat_less_iff:
>   "\<lbrakk> unat (a :: 'a :: len word) = b; c < 2 ^ LENGTH('a) \<rbrakk> \<Longrightarrow> (a < of_nat c) = (b < c)"
>   using unat_ucast_less_no_overflow_simp by blast
> 
> lemma is_aligned_no_overflow3:
>  "\<lbrakk> is_aligned (a :: 'a :: len word) n; n < LENGTH('a); b < 2 ^ n; c \<le> 2 ^ n; b < c \<rbrakk>
>   \<Longrightarrow> a + b \<le> a + (c - 1)"
>   by (meson is_aligned_no_wrap' le_m1_iff_lt not_le word_less_sub_1 word_plus_mono_right)
> 
> lemma mask_add_aligned_right:
>   "is_aligned p n \<Longrightarrow> (q + p) && mask n = q && mask n"
>   by (simp add: mask_add_aligned add.commute)
> 
> lemma leq_high_bits_shiftr_low_bits_leq_bits_mask:
>   "x \<le> mask high_bits \<Longrightarrow> (x :: 'a :: len word) << low_bits \<le> mask (low_bits + high_bits)"
>   by (metis le_mask_shiftl_le_mask)
> 
> lemma from_to_bool_last_bit:
>   "from_bool (to_bool (x && 1)) = x && 1"
>   by (metis from_bool_to_bool_iff word_and_1)
> 
> lemma word_two_power_neg_ineq:
>   "2 ^ m \<noteq> (0 :: 'a word) \<Longrightarrow> 2 ^ n \<le> - (2 ^ m :: 'a :: len word)"
>   apply (cases "n < LENGTH('a)"; simp add: power_overflow)
>   apply (cases "m < LENGTH('a)"; simp add: power_overflow)
>   apply (simp add: word_le_nat_alt unat_minus word_size)
>   apply (cases "LENGTH('a)"; simp)
>   apply (simp add: less_Suc_eq_le)
>   apply (drule power_increasing[where a=2 and n=n] power_increasing[where a=2 and n=m], simp)+
>   apply (drule(1) add_le_mono)
>   apply simp
>   done
> 
> lemma unat_shiftl_absorb:
>   "\<lbrakk> x \<le> 2 ^ p; p + k < LENGTH('a) \<rbrakk> \<Longrightarrow> unat (x :: 'a :: len word) * 2 ^ k = unat (x * 2 ^ k)"
>   by (smt add_diff_cancel_right' add_lessD1 le_add2 le_less_trans mult.commute nat_le_power_trans
>           unat_lt2p unat_mult_lem unat_power_lower word_le_nat_alt)
> 
> lemma word_plus_mono_right_split:
>   "\<lbrakk> unat ((x :: 'a :: len word) && mask sz) + unat z < 2 ^ sz; sz < LENGTH('a) \<rbrakk>
>    \<Longrightarrow> x \<le> x + z"
>   apply (subgoal_tac "(x && ~~(mask sz)) + (x && mask sz) \<le> (x && ~~(mask sz)) + ((x && mask sz) + z)")
>    apply (simp add:word_plus_and_or_coroll2 field_simps)
>   apply (rule word_plus_mono_right)
>    apply (simp add: less_le_trans no_olen_add_nat)
>   using Word_Lemmas.of_nat_power is_aligned_no_wrap' by force
> 
> lemma mul_not_mask_eq_neg_shiftl:
>   "~~(mask n) = -1 << n"
>   by (simp add: NOT_mask shiftl_t2n)
> 
> lemma shiftr_mul_not_mask_eq_and_not_mask:
>   "(x >> n) * ~~(mask n) = - (x && ~~(mask n))"
>   by (metis NOT_mask and_not_mask mult_minus_left semiring_normalization_rules(7) shiftl_t2n)
> 
> lemma mask_eq_n1_shiftr:
>   "n \<le> LENGTH('a) \<Longrightarrow> (mask n :: 'a :: len word) = -1 >> (LENGTH('a) - n)"
>   by (metis diff_diff_cancel eq_refl mask_full shiftr_mask2)
> 
> lemma is_aligned_mask_out_add_eq:
>   "is_aligned p n \<Longrightarrow> (p + x) && ~~(mask n) = p + (x && ~~(mask n))"
>   by (simp add: mask_out_sub_mask mask_add_aligned)
> 
> lemmas is_aligned_mask_out_add_eq_sub
>     = is_aligned_mask_out_add_eq[where x="a - b" for a b, simplified field_simps]
> 
> lemma aligned_bump_down:
>   "is_aligned x n \<Longrightarrow> (x - 1) && ~~(mask n) = x - 2 ^ n"
>   by (drule is_aligned_mask_out_add_eq[where x="-1"]) (simp add: NOT_mask)
> 
> lemma unat_2tp_if:
>   "unat (2 ^ n :: ('a :: len) word) = (if n < LENGTH ('a) then 2 ^ n else 0)"
>   by (split if_split, simp_all add: power_overflow)
> 
> lemma mask_of_mask:
>   "mask (n::nat) && mask (m::nat) = mask (min m n)"
>   by word_eqI_solve
> 
> lemma unat_signed_ucast_less_ucast:
>   "LENGTH('a) \<le> LENGTH('b) \<Longrightarrow> unat (ucast (x :: 'a :: len word) :: 'b :: len signed word) = unat x"
>   by (simp add: unat_ucast_up_simp)
> 
> lemma toEnum_of_ucast:
>   "LENGTH('b) \<le> LENGTH('a) \<Longrightarrow>
>    (toEnum (unat (b::'b :: len word))::'a :: len word) = of_nat (unat b)"
>   by (simp add: unat_pow_le_intro)
> 
> lemmas unat_ucast_mask = unat_ucast_eq_unat_and_mask[where w=a for a]
> 
> lemma t2n_mask_eq_if:
>   "2 ^ n && mask m = (if n < m then 2 ^ n else 0)"
>   by (rule word_eqI, auto simp add: word_size nth_w2p split: if_split)
> 
> lemma unat_ucast_le:
>   "unat (ucast (x :: 'a :: len word) :: 'b :: len word) \<le> unat x"
>   by (simp add: ucast_nat_def word_unat_less_le)
> 
> lemma ucast_le_up_down_iff:
>   "\<lbrakk> LENGTH('a) \<le> LENGTH('b); (x :: 'b :: len word) \<le> ucast (max_word :: 'a :: len word) \<rbrakk>
>    \<Longrightarrow> (ucast x \<le> (y :: 'a word)) = (x \<le> ucast y)"
>   using le_max_word_ucast_id ucast_le_ucast by metis
> 
> lemma ucast_ucast_mask_shift:
>   "a \<le> LENGTH('a) + b
>    \<Longrightarrow> ucast (ucast (p && mask a >> b) :: 'a :: len word) = p && mask a >> b"
>   by (metis add.commute le_mask_iff shiftr_mask_le ucast_ucast_eq_mask_shift word_and_le')
> 
> lemma unat_ucast_mask_shift:
>   "a \<le> LENGTH('a) + b
>    \<Longrightarrow> unat (ucast (p && mask a >> b) :: 'a :: len word) = unat (p && mask a >> b)"
>   by (metis linear ucast_ucast_mask_shift unat_ucast_up_simp)
> 
> lemma mask_overlap_zero:
>   "a \<le> b \<Longrightarrow> (p && mask a) && ~~(mask b) = 0"
>   by (metis NOT_mask_AND_mask mask_lower_twice2 max_def)
> 
> lemma mask_shifl_overlap_zero:
>   "a + c \<le> b \<Longrightarrow> (p && mask a << c) && ~~(mask b) = 0"
>   by (metis and_not_mask le_mask_iff mask_shiftl_decompose shiftl_0 shiftl_over_and_dist
>             shiftr_mask_le word_and_le' word_bool_alg.conj_commute)
> 
> lemma mask_overlap_zero':
>   "a \<ge> b \<Longrightarrow> (p && ~~(mask a)) && mask b = 0"
>   using mask_AND_NOT_mask mask_AND_less_0 by blast
> 
> lemma mask_rshift_mult_eq_rshift_lshift:
>   "((a :: 'a :: len word) >> b) * (1 << c) = (a >> b << c)"
>   by (simp add: shiftl_t2n)
> 
> lemma shift_alignment:
>   "a \<ge> b \<Longrightarrow> is_aligned (p >> a << a) b"
>   using is_aligned_shift is_aligned_weaken by blast
> 
> lemma mask_split_sum_twice:
>   "a \<ge> b \<Longrightarrow> (p && ~~(mask a)) + ((p && mask a) && ~~(mask b)) + (p && mask b) = p"
>   by (simp add: add.commute multiple_mask_trivia word_bool_alg.conj_commute
>                 word_bool_alg.conj_left_commute word_plus_and_or_coroll2)
> 
> lemma mask_shift_eq_mask_mask:
>   "(p && mask a >> b << b) = (p && mask a) && ~~(mask b)"
>   by (simp add: and_not_mask)
> 
> lemma mask_shift_sum:
>   "\<lbrakk> a \<ge> b; unat n = unat (p && mask b) \<rbrakk>
>    \<Longrightarrow> (p && ~~(mask a)) + (p && mask a >> b) * (1 << b) + n = (p :: 'a :: len word)"
>   by (metis and_not_mask mask_rshift_mult_eq_rshift_lshift mask_split_sum_twice word_unat.Rep_eqD)
> 
> lemma is_up_compose:
>   "\<lbrakk> is_up uc; is_up uc' \<rbrakk> \<Longrightarrow> is_up (uc' \<circ> uc)"
>   unfolding is_up_def by (simp add: Word.target_size Word.source_size)
> 
> lemma of_int_sint_scast:
>   "of_int (sint (x :: 'a :: len word)) = (scast x :: 'b :: len word)"
>   by (metis scast_def word_of_int)
> 
> lemma scast_of_nat_to_signed [simp]:
>   "scast (of_nat x :: 'a :: len word) = (of_nat x :: 'a signed word)"
>   by (metis cast_simps(23) scast_scast_id(2))
> 
> lemma scast_of_nat_signed_to_unsigned_add:
>   "scast (of_nat x + of_nat y :: 'a :: len signed word) = (of_nat x + of_nat y :: 'a :: len word)"
>   by (metis of_nat_add scast_of_nat)
> 
> lemma scast_of_nat_unsigned_to_signed_add:
>   "(scast (of_nat x + of_nat y :: 'a :: len word)) = (of_nat x + of_nat y :: 'a :: len signed word)"
>   by (metis Abs_fnat_hom_add scast_of_nat_to_signed)
> 
> lemma and_mask_cases:
>   fixes x :: "'a :: len word"
>   assumes len: "n < LENGTH('a)"
>   shows "x && mask n \<in> of_nat ` set [0 ..< 2 ^ n]"
> proof -
>   have "x && mask n \<in> {0 .. 2 ^ n - 1}"
>     by (simp add: mask_def word_and_le1)
>   also
>   have "... = of_nat ` {0 .. 2 ^ n - 1}"
>     apply (rule set_eqI, rule iffI)
>      apply (clarsimp simp: image_iff)
>      apply (rule_tac x="unat x" in bexI; simp)
>      using len
>      apply (simp add: word_le_nat_alt unat_2tp_if unat_minus_one)
>     using len
>     apply (clarsimp simp: word_le_nat_alt unat_2tp_if unat_minus_one)
>     apply (subst unat_of_nat_eq; simp add: nat_le_Suc_less)
>     apply (erule less_le_trans)
>     apply simp
>     done
>   also have "{0::nat .. 2^n - 1} = set [0 ..< 2^n]" by (auto simp: nat_le_Suc_less)
>   finally show ?thesis .
> qed
> 
> lemma sint_of_nat_ge_zero:
>   "x < 2 ^ (LENGTH('a) - 1) \<Longrightarrow> sint (of_nat x :: 'a :: len word) \<ge> 0"
>   by (simp add: Word_Lemmas.of_nat_power not_msb_from_less sint_eq_uint)
> 
> lemma sint_eq_uint_2pl:
>   "\<lbrakk> (a :: 'a :: len word) < 2 ^ (LENGTH('a) - 1) \<rbrakk>
>    \<Longrightarrow> sint a = uint a"
>   by (simp add: not_msb_from_less sint_eq_uint word_2p_lem word_size)
> 
> lemma sint_of_nat_le:
>   "\<lbrakk> b < 2 ^ (LENGTH('a) - 1); a \<le> b \<rbrakk>
>    \<Longrightarrow> sint (of_nat a :: 'a :: len word) \<le> sint (of_nat b :: 'a :: len word)"
>   by (smt Word_Lemmas.of_nat_power diff_less le_less_trans len_gt_0 len_of_numeral_defs(2)
>           nat_power_minus_less of_nat_le_iff sint_eq_uint_2pl uint_nat unat_of_nat_len)
> 
> lemma int_eq_sint:
>   "x < 2 ^ (LENGTH('a) - 1) \<Longrightarrow> sint (of_nat x :: 'a :: len word) = int x"
>   by (smt Word_Lemmas.of_nat_power diff_less le_less_trans len_gt_0 len_of_numeral_defs(2)
>           nat_less_le sint_eq_uint_2pl uint_nat unat_lt2p unat_of_nat_len unat_power_lower)
> 
> lemma sint_ctz:
>   "LENGTH('a) > 2
>    \<Longrightarrow> 0 \<le> sint (of_nat (word_ctz (x :: 'a :: len word)) :: 'a signed word)
>         \<and> sint (of_nat (word_ctz x) :: 'a signed word) \<le> int (LENGTH('a))"
>   apply (subgoal_tac "LENGTH('a) < 2 ^ (LENGTH('a) - 1)")
>    apply (rule conjI)
>     apply (metis len_signed order_le_less_trans sint_of_nat_ge_zero word_ctz_le)
>    apply (metis int_eq_sint len_signed sint_of_nat_le word_ctz_le)
>   by (rule small_powers_of_2, simp)
> 
> lemma pow_sub_less:
>   "\<lbrakk> a + b \<le> LENGTH('a); unat (x :: 'a :: len word) = 2 ^ a \<rbrakk>
>    \<Longrightarrow> unat (x * 2 ^ b - 1) < 2 ^ (a + b)"
>   by (metis (mono_tags) eq_or_less_helperD not_less of_nat_numeral power_add
>                         semiring_1_class.of_nat_power unat_pow_le_intro word_unat.Rep_inverse)
> 
> lemma sle_le_2pl:
>   "\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a \<le> b \<rbrakk> \<Longrightarrow> a <=s b"
>   by (simp add: not_msb_from_less word_sle_msb_le)
> 
> lemma sless_less_2pl:
>   "\<lbrakk> (b :: 'a :: len word) < 2 ^ (LENGTH('a) - 1); a < b \<rbrakk> \<Longrightarrow> a <s b"
>   using not_msb_from_less word_sless_msb_less by blast
> 
> lemma and_mask2:
>   "w << n >> n = w && mask (size w - n)"
>   by (cases "n \<le> size w"; clarsimp simp: word_and_le2 and_mask shiftl_zero_size)
> 
> lemma unat_of_nat_word_log2:
>   "LENGTH('a) < 2 ^ LENGTH('b)
>    \<Longrightarrow> unat (of_nat (word_log2 (n :: 'a :: len word)) :: 'b :: len word) = word_log2 n"
>   by (metis less_trans unat_of_nat_eq word_log2_max word_size)
> 
> lemma aligned_sub_aligned_simple:
>   "\<lbrakk> is_aligned a n; is_aligned b n \<rbrakk> \<Longrightarrow> is_aligned (a - b) n"
>   by (simp add: aligned_sub_aligned)
> 
> lemma minus_one_shift:
>   "- (1 << n) = (-1 << n :: 'a::len word)"
>   by (simp add: mask_def NOT_eq flip: mul_not_mask_eq_neg_shiftl)
> 
> lemma ucast_eq_mask:
>   "(UCAST('a::len \<rightarrow> 'b::len) x = UCAST('a \<rightarrow> 'b) y) =
>    (x && mask LENGTH('b) = y && mask LENGTH('b))"
>   by (rule iffI; word_eqI_solve)
> 
> context
>   fixes w :: "'a::len word"
> begin
> 
> private lemma sbintrunc_uint_ucast:
>   assumes "Suc n = LENGTH('b::len)"
>   shows "sbintrunc n (uint (ucast w :: 'b word)) = sbintrunc n (uint w)"
>   by (metis assms sbintrunc_bintrunc ucast_def word_ubin.eq_norm)
> 
> private lemma test_bit_sbintrunc:
>   assumes "i < LENGTH('a)"
>   shows "(word_of_int (sbintrunc n (uint w)) :: 'a word) !! i
>            = (if n < i then w !! n else w !! i)"
>   using assms by (simp add: nth_sbintr)
>                  (simp add: test_bit_bin)
> 
> private lemma test_bit_sbintrunc_ucast:
>   assumes len_a: "i < LENGTH('a)"
>   shows "(word_of_int (sbintrunc (LENGTH('b) - 1) (uint (ucast w :: 'b word))) :: 'a word) !! i
>           = (if LENGTH('b::len) \<le> i then w !! (LENGTH('b) - 1) else w !! i)"
>   apply (subst sbintrunc_uint_ucast)
>    apply simp
>   apply (subst test_bit_sbintrunc)
>    apply (rule len_a)
>   apply (rule if_cong[OF _ refl refl])
>   using leD less_linear by fastforce
> 
> lemma scast_ucast_high_bits:
>   "scast (ucast w :: 'b::len word) = w
>      \<longleftrightarrow> (\<forall> i \<in> {LENGTH('b) ..< size w}. w !! i = w !! (LENGTH('b) - 1))"
>   unfolding scast_def sint_uint word_size
>   apply (subst word_eq_iff)
>   apply (rule iffI)
>    apply (rule ballI)
>    apply (drule_tac x=i in spec)
>    apply (subst (asm) test_bit_sbintrunc_ucast; simp)
>   apply (rule allI)
>   apply (case_tac "n < LENGTH('a)")
>    apply (subst test_bit_sbintrunc_ucast)
>     apply simp
>    apply (case_tac "n \<ge> LENGTH('b)")
>     apply (drule_tac x=n in bspec)
>   by auto
> 
> lemma scast_ucast_mask_compare:
>   "scast (ucast w :: 'b::len word) = w
>    \<longleftrightarrow> (w \<le> mask (LENGTH('b) - 1) \<or> ~~(mask (LENGTH('b) - 1)) \<le> w)"
>   apply (clarsimp simp: le_mask_high_bits neg_mask_le_high_bits scast_ucast_high_bits word_size)
>   apply (rule iffI; clarsimp)
>    apply (rename_tac i j; case_tac "i = LENGTH('b) - 1"; case_tac "j = LENGTH('b) - 1")
>   by auto
> 
> lemma ucast_less_shiftl_helper':
>   "\<lbrakk> LENGTH('b) + (a::nat) < LENGTH('a); 2 ^ (LENGTH('b) + a) \<le> n\<rbrakk>
>    \<Longrightarrow> (ucast (x :: 'b::len word) << a) < (n :: 'a::len word)"
>   apply (erule order_less_le_trans[rotated])
>   using ucast_less[where x=x and 'a='a]
>   apply (simp only: shiftl_t2n field_simps)
>   apply (rule word_less_power_trans2; simp)
>   done
> 
> end
> 
> lemma ucast_ucast_mask2:
>   "is_down (UCAST ('a \<rightarrow> 'b)) \<Longrightarrow>
>    UCAST ('b::len \<rightarrow> 'c::len) (UCAST ('a::len \<rightarrow> 'b::len) x) = UCAST ('a \<rightarrow> 'c) (x && mask LENGTH('b))"
>   by word_eqI_solve
> 
> lemma ucast_NOT:
>   "ucast (~~x) = ~~(ucast x) && mask (LENGTH('a))" for x::"'a::len word"
>   by word_eqI
> 
> lemma ucast_NOT_down:
>   "is_down UCAST('a::len \<rightarrow> 'b::len) \<Longrightarrow> UCAST('a \<rightarrow> 'b) (~~x) = ~~(UCAST('a \<rightarrow> 'b) x)"
>   by word_eqI
> 
> lemma of_bl_mult_and_not_mask_eq:
>   "\<lbrakk>is_aligned (a :: 'a::len word) n; length b + m \<le> n\<rbrakk>
>    \<Longrightarrow> a + of_bl b * (2^m) && ~~(mask n) = a"
>   by (smt add.left_neutral add_diff_cancel_right' add_mask_lower_bits and_mask_plus is_aligned_mask
>           is_aligned_weaken le_less_trans of_bl_length2 subtract_mask(1))
> 
> lemma bin_to_bl_of_bl_eq:
>   "\<lbrakk>is_aligned (a::'a::len word) n; length b + c \<le> n; length b + c < LENGTH('a)\<rbrakk>
>   \<Longrightarrow> bin_to_bl (length b) (uint ((a + of_bl b * 2^c) >> c)) = b"
>   apply (subst word_plus_and_or_coroll)
>    apply (erule is_aligned_get_word_bits)
>     apply (rule is_aligned_AND_less_0)
>      apply (simp add: is_aligned_mask)
>     apply (rule order_less_le_trans)
>      apply (rule of_bl_length2)
>      apply simp
>     apply (simp add: two_power_increasing)
>    apply simp
>   apply (rule nth_equalityI)
>    apply (simp only: len_bin_to_bl)
>   apply (clarsimp simp only: len_bin_to_bl nth_bin_to_bl word_test_bit_def[symmetric])
>   apply (simp add: nth_shiftr nth_shiftl
>                    shiftl_t2n[where n=c, simplified mult.commute, simplified, symmetric])
>   apply (simp add: is_aligned_nth[THEN iffD1, rule_format] test_bit_of_bl nth_rev)
>   apply arith
>   done
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Lib.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Lib.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
29a26,30
> (* standard notation for blocks of 2^n-1 words, usually aligned;
>    abbreviation so it simplifies directly *)
> abbreviation mask_range :: "'a::len word \<Rightarrow> nat \<Rightarrow> 'a word set" where
>   "mask_range p n \<equiv> {p .. p + mask n}"
> 
113c114
<   "sign_extend n w \<equiv> if w !! n then w || ~~mask n else w && mask n"
---
>   "sign_extend n w \<equiv> if w !! n then w || ~~ (mask n) else w && mask n"
170c171
<   "w AND NOT mask n = (w >> n) << n"
---
>   "w AND NOT (mask n) = (w >> n) << n"
224c225
<   "n < size w \<Longrightarrow> w AND NOT mask n = ((w div (2 ^ n)) * (2 ^ n))"
---
>   "n < size w \<Longrightarrow> w AND NOT (mask n) = ((w div (2 ^ n)) * (2 ^ n))"
228c229
<   "w AND NOT mask n = (w div 2^n) * 2^n"
---
>   "w AND NOT (mask n) = (w div 2^n) * 2^n"
254a256,259
> lemma add_mask_fold:
>   "x + 2 ^ n - 1 = x + mask n"
>   by (simp add: mask_def)
> 
352c357
<   "mask m << n = mask (m + n) && ~~ mask n"
---
>   "mask m << n = mask (m + n) && ~~ (mask n)"
487c492
<   shows "c \<le> b \<Longrightarrow> a >> b << c = (a >> (b - c)) AND (NOT mask c)"
---
>   shows "c \<le> b \<Longrightarrow> a >> b << c = (a >> (b - c)) AND (NOT (mask c))"
494c499
<   shows "b < c \<Longrightarrow> a >> b << c = (a << (c - b)) AND (NOT mask c)"
---
>   shows "b < c \<Longrightarrow> a >> b << c = (a << (c - b)) AND (NOT (mask c))"
515,527d519
< 
< lemma word_and_1:
<   fixes x::"'a::len word"
<   shows "(x AND 1) = (if x!!0 then 1 else 0)"
<   apply(rule word_eqI)
<   apply(simp add:word_ao_nth)
<   apply(rule conjI)
<    apply(auto)[1]
<   apply clarsimp
<   apply (case_tac n)
<    apply simp
<   apply simp
<   done
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Next.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Next.thy
0a1,2
> (* SPDX-License-Identifier: BSD-3-Clause *)
> 
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Setup_32.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Setup_32.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Setup_64.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Setup_64.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Syntax.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Syntax.thy
2c2
<  * Copyright 2014, NICTA
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(NICTA_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Word_Lib/Word_Type_Syntax.thy ../../AFPs/afp-2020/thys/Word_Lib/Word_Type_Syntax.thy
2c2
<  * Copyright 2017, Data61/CSIRO
---
>  * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
4,8c4
<  * This software may be distributed and modified according to the terms of
<  * the BSD 2-Clause license. Note that NO WARRANTY is provided.
<  * See "LICENSE_BSD2.txt" for details.
<  *
<  * @TAG(DATA61_BSD)
---
>  * SPDX-License-Identifier: BSD-2-Clause
==========
Zeta_3_Irrational
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Zeta_3_Irrational/Zeta_3_Irrational.thy ../../AFPs/afp-2020/thys/Zeta_3_Irrational/Zeta_3_Irrational.thy
14c14
<   Ap\'{e}ry's original proof of the irrationality of $\zeta(3)$ contained several 
---
>   Ap\'{e}ry's original proof of the irrationality of $\zeta(3)$ contained several
19c19
<   Both Ap\'{e}ry and Beukers make use of an asymptotic upper bound on 
---
>   Both Ap\'{e}ry and Beukers make use of an asymptotic upper bound on
21c21
<   any $c > e$, which is a consequence of the Prime Number Theorem (which, fortunately, 
---
>   any $c > e$, which is a consequence of the Prime Number Theorem (which, fortunately,
28,29c28,29
<   Mahboubi\ \emph{et al.}~\cite{mahboubi}, who followed Ap\'{e}ry's original proof, 
<   but were ultimately forced to find a more elementary way to prove the asymptotics 
---
>   Mahboubi\ \emph{et al.}~\cite{mahboubi}, who followed Ap\'{e}ry's original proof,
>   but were ultimately forced to find a more elementary way to prove the asymptotics
194c194
<   
---
> 
416c416
<   also have "\<dots> = (\<Sum>i\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i)) 
---
>   also have "\<dots> = (\<Sum>i\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i))
419,420c419,420
<   also have "\<dots> = (\<Sum>i\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i)) 
<                    (monom (pochhammer (n - i + 1) i) (n - i) * 
---
>   also have "\<dots> = (\<Sum>i\<le>k. smult ((-1) ^ (k - i) * of_nat (k choose i))
>                    (monom (pochhammer (n - i + 1) i) (n - i) *
536c536
<   by (intro borel_measurable_continuous_on1 continuous_on_Gen_Shleg)
---
>   by (intro borel_measurable_continuous_onI continuous_on_Gen_Shleg)
539c539
<   by (intro borel_measurable_continuous_on1 continuous_on_Shleg)
---
>   by (intro borel_measurable_continuous_onI continuous_on_Shleg)
948c948
<   also have **: "(\<lambda>k. 2 / (r + k + 1) ^ 3) sums 
---
>   also have **: "(\<lambda>k. 2 / (r + k + 1) ^ 3) sums
989c989
<   
---
> 
1211c1211
<   
---
> 
1304c1304
<  
---
> 
1346c1346
<   also have "(\<integral>\<^sup>+(w,x,y)\<in>D'. (1 / (1-(1-x*y)*w)) \<partial>lborel) = 
---
>   also have "(\<integral>\<^sup>+(w,x,y)\<in>D'. (1 / (1-(1-x*y)*w)) \<partial>lborel) =
1497c1497
<   case (Suc k)                                    
---
>   case (Suc k)
1501c1501
<   
---
> 
1771c1771
<       have "norm (LBINT z:{0<..<1}. norm (P x * P y / (1-(1-x*y)*z))) = 
---
>       have "norm (LBINT z:{0<..<1}. norm (P x * P y / (1-(1-x*y)*z))) =
1809c1809
<     by (intro borel_measurable_continuous_on1 continuous_intros)
---
>     by (intro borel_measurable_continuous_onI continuous_intros)
1845c1845
<     by (intro borel_measurable_continuous_on1 continuous_intros)
---
>     by (intro borel_measurable_continuous_onI continuous_intros)
1884c1884
<     by (intro borel_measurable_continuous_on1 continuous_intros)
---
>     by (intro borel_measurable_continuous_onI continuous_intros)
2068c2068
<           O(\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)" 
---
>           O(\<lambda>n. real (Lcm {1..n}) ^ 3 / 27 ^ n)"
==========
Zeta_Function
Only in ../../AFPs/afp-2020/thys/Zeta_Function: Hadjicostas_Chapman.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/Zeta_Function/Zeta_Function.thy ../../AFPs/afp-2020/thys/Zeta_Function/Zeta_Function.thy
12a13
>   Zeta_Library
245a247,249
> lemma zeta_minus_pole_eq: "s \<noteq> 1 \<Longrightarrow> zeta s - 1 / (s - 1) = pre_zeta 1 s"
>   by (simp add: zeta_def hurwitz_zeta_def)
> 
811c815
< theorem hurwitz_zeta_cnj [simp]: "a > 0 \<Longrightarrow> hurwitz_zeta a (cnj z) = cnj (hurwitz_zeta a z)"
---
> lemma hurwitz_zeta_cnj [simp]: "a > 0 \<Longrightarrow> hurwitz_zeta a (cnj z) = cnj (hurwitz_zeta a z)"
818c822
< theorem zeta_cnj [simp]: "zeta (cnj z) = cnj (zeta z)"
---
> lemma zeta_cnj [simp]: "zeta (cnj z) = cnj (zeta z)"
826a831,833
> corollary zeta_real': "z \<in> \<real> \<Longrightarrow> zeta z \<in> \<real>"
>   by (elim Reals_cases) (auto simp: zeta_real)
> 
1044,1045c1051,1052
<   from ev and this show ?thesis
<     by (rule Lim_transform_eventually)
---
>   with ev show ?thesis
>     by (blast intro: Lim_transform_eventually)
1722a1730,1762
> lemma Gamma_times_zeta_has_integral:
>   assumes "Re z > 1"
>   shows   "((\<lambda>x. x powr (z - 1) / (of_real (exp x) - 1)) has_integral (Gamma z * zeta z)) {0<..}"
>     (is "(?f has_integral _) _")
> proof -
>   have "(?f has_integral set_lebesgue_integral lebesgue {0<..} ?f) {0<..}"
>     using Gamma_times_zeta_integrable[OF assms]
>     by (intro has_integral_set_lebesgue) auto
>   also have "set_lebesgue_integral lebesgue {0<..} ?f = Gamma z * zeta z"
>     using Gamma_times_zeta_integral[OF assms] by simp
>   finally show ?thesis .
> qed
> 
> lemma Gamma_times_zeta_has_integral_real:
>   fixes z :: real
>   assumes "z > 1"
>   shows   "((\<lambda>x. x powr (z - 1) / (exp x - 1)) has_integral (Gamma z * Re (zeta z))) {0<..}"
> proof -
>   from assms have *: "Re (of_real z) > 1" by simp
>   have "((\<lambda>x. Re (complex_of_real x powr (complex_of_real z - 1)) / (exp x - 1)) has_integral
>            Gamma z * Re (zeta (complex_of_real z))) {0<..}"
>     using has_integral_linear[OF Gamma_times_zeta_has_integral[OF *] bounded_linear_Re] 
>     by (simp add: o_def Gamma_complex_of_real)
>   also have "?this \<longleftrightarrow> ?thesis"
>     using assms by (intro has_integral_cong) (auto simp: powr_Reals_eq)
>   finally show ?thesis .
> qed
> 
> lemma Gamma_integral_real':
>   assumes x: "x > (0 :: real)"
>   shows   "((\<lambda>t. t powr (x - 1) / exp t) has_integral Gamma x) {0<..}"
>   using Gamma_integral_real[OF assms] by (subst has_integral_closure [symmetric]) auto
> 
1774c1814
<       by (rule Lim_transform_eventually)
---
>       by (blast intro: Lim_transform_eventually)
1857c1897
< lemma fds_perzeta_0 [simp]: "fds_perzeta 0 = fds_zeta"
---
> lemma fds_perzeta__left_0 [simp]: "fds_perzeta 0 = fds_zeta"
1860c1900
< lemma perzeta_0 [simp]: "Re s > 1 \<Longrightarrow> perzeta 0 s = zeta s"
---
> lemma perzeta_0_left [simp]: "perzeta 0 s = zeta s"
1940a1981,2002
> lemma fds_perzeta_one_half: "fds_perzeta (1 / 2) = fds (\<lambda>n. (-1) ^ n)"
>   using Complex.DeMoivre[of pi]
>   by (intro fds_eqI) (auto simp: fds_perzeta_def exp_eq_polar mult_ac)
> 
> lemma perzeta_one_half_1 [simp]: "perzeta (1 / 2) 1 = -ln 2"
> proof (rule sums_unique2)
>   have *: "(1 / 2 :: real) \<notin> \<int>"
>     using fraction_not_in_ints[of 2 1] by auto
>   have "fds_converges (fds_perzeta (1 / 2)) 1"
>     by (rule fds_converges, rule le_less_trans, rule conv_abscissa_perzeta') (use * in auto)
>   hence "(\<lambda>n. (-1) ^ Suc n / Suc n) sums eval_fds (fds_perzeta (1 / 2)) 1"
>     unfolding fds_converges_altdef by (simp add: fds_perzeta_one_half)
>   also from * have "eval_fds (fds_perzeta (1 / 2)) 1 = perzeta (1 / 2) 1"
>     by (simp add: perzeta_def)
>   finally show "(\<lambda>n. -complex_of_real ((-1) ^ n / Suc n)) sums perzeta (1 / 2) 1"
>     by simp
>   hence "(\<lambda>n. -complex_of_real ((-1) ^ n / Suc n)) sums -of_real (ln 2)"
>     by (intro sums_minus sums_of_real alternating_harmonic_series_sums)
>   thus "(\<lambda>n. -complex_of_real ((-1) ^ n / Suc n)) sums -(ln 2)"
>     by (simp flip: Ln_of_real)
> qed
> 
2523c2585
<     by (subst integral_reflect_real [symmetric], intro integral_cong)
---
>     by (subst Henstock_Kurzweil_Integration.integral_reflect_real [symmetric], intro integral_cong)
2832c2894
<             (at_right 0)" by (rule Lim_eventually)
---
>             (at_right 0)" by (rule tendsto_eventually)
2883c2945
<       by (subst integral_reflect_real [symmetric]) simp
---
>       by (subst Henstock_Kurzweil_Integration.integral_reflect_real [symmetric]) simp
3561d3622
< 
3630a3692,3701
> 
> lemma perzeta_one_half_left: "s \<noteq> 1 \<Longrightarrow> perzeta (1 / 2) s = (2 powr (1-s) - 1) * zeta s"
>   using perzeta_conv_hurwitz_zeta_multiplication'[of 2 s 1]
>   by (simp add: eval_nat_numeral hurwitz_zeta_one_half_left powr_minus
>                 field_simps zeta_def powr_diff)
> 
> lemma perzeta_one_half_left':
>   "perzeta (1 / 2) s =
>          (if s = 1 then -ln 2 else (2 powr (1 - s) - 1) / (s - 1)) * ((s - 1) * pre_zeta 1 s + 1)"
>   by (cases "s = 1") (auto simp: perzeta_one_half_left field_simps zeta_def hurwitz_zeta_def)
Only in ../../AFPs/afp-2020/thys/Zeta_Function: Zeta_Laurent_Expansion.thy
Only in ../../AFPs/afp-2020/thys/Zeta_Function: Zeta_Library.thy
==========
ZFC_in_HOL
Only in ../../AFPs/afp-2020/thys/ZFC_in_HOL: Cantor_NF.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/ZFC_in_HOL/Kirby.thy ../../AFPs/afp-2020/thys/ZFC_in_HOL/Kirby.thy
13a14,15
> subsubsection \<open>Addition is a monoid\<close>
> 
43a46,49
> lemma Limit_add_Sup_distrib:
>   fixes x::V shows "Limit \<alpha> \<Longrightarrow> x + (SUP z\<in>elts \<alpha>. f z) = (SUP z\<in>elts \<alpha>. x + f z)"
>   using add_Sup_distrib by force
> 
83c89
<   by (simp add: lift_def set_empty)
---
>   by (simp add: lift_def)
87a94,103
> lemma add_eq_0_iff [simp]:
>   fixes x y::V
>   shows "x+y = 0 \<longleftrightarrow> x=0 \<and> y=0"
>   proof safe
>   show "x = 0" if "x + y = 0"
>     by (metis that le_imp_less_or_eq not_less_0 plus sup_ge1)
>   then show "y = 0" if "x + y = 0"
>     using that by auto
> qed auto
> 
100a117,143
> lemma succ_eq_add1: "succ x = x + 1"
>   by (simp add: plus_V_succ_right one_V_def)
> 
> lemma ord_of_nat_add: "ord_of_nat (m+n) = ord_of_nat m + ord_of_nat n"
>   by (induction n) (auto simp: plus_V_succ_right)
> 
> lemma succ_0_plus_eq [simp]:
>   assumes "\<alpha> \<in> elts \<omega>" 
>   shows "succ 0 + \<alpha> = succ \<alpha>"
> proof -
>   obtain n where "\<alpha> = ord_of_nat n"
>     using assms elts_\<omega> by blast
>   then show ?thesis
>     by (metis One_nat_def ord_of_nat.simps ord_of_nat_add plus_1_eq_Suc)
> qed
> 
> lemma omega_closed_add [intro]:
>   assumes "\<alpha> \<in> elts \<omega>" "\<beta> \<in> elts \<omega>" shows "\<alpha>+\<beta> \<in> elts \<omega>"
> proof -
>   obtain m n where "\<alpha> = ord_of_nat m" "\<beta> = ord_of_nat n"
>     using assms elts_\<omega> by auto
>   then have "\<alpha>+\<beta> = ord_of_nat (m+n)"
>     using ord_of_nat_add by auto
>   then show ?thesis
>     by (simp add: \<omega>_def)
> qed
> 
132c175
<     by (simp add: lift_def zero_V_def)
---
>     using lift_def by auto
145a189,190
> subsubsection \<open>Deeper properties of addition\<close>
> 
204a250,251
> lemma succ_less_\<omega>_imp: "succ x < \<omega> \<Longrightarrow> x < \<omega>"
>   by (metis add_le_cancel_left add.right_neutral le_0 le_less_trans succ_eq_add1)
219c266
< lemma card_add: "vcard (x + y) = vcard x \<oplus> vcard y"
---
> lemma vcard_add: "vcard (x + y) = vcard x \<oplus> vcard y"
222a270,282
> lemma countable_add:
>   assumes "countable (elts A)" "countable (elts B)"
>   shows "countable (elts (A+B))"
> proof -
>   have "vcard A \<le> \<aleph>0" "vcard B \<le> \<aleph>0"
>     using assms countable_iff_le_Aleph0 by blast+
>   then have "vcard (A+B) \<le> \<aleph>0"
>     unfolding vcard_add
>     by (metis Aleph_0 Card_\<omega> InfCard_cdouble_eq InfCard_def cadd_le_mono order_refl)
>   then show ?thesis
>     by (simp add: countable_iff_le_Aleph0)
> qed
> 
318a379,420
> lemma add_Sup_distrib_id: "A \<noteq> 0 \<Longrightarrow> x + \<Squnion>(elts A) = (SUP z\<in>elts A. x + z)"
>   by (metis add_Sup_distrib image_ident image_image)
> 
> lemma add_Limit: "Limit \<alpha> \<Longrightarrow> x + \<alpha> = (SUP z\<in>elts \<alpha>. x + z)"
>   by (metis Limit_add_Sup_distrib Limit_eq_Sup_self image_ident image_image)
> 
> lemma add_le_left:
>   assumes "Ord \<alpha>" "Ord \<beta>" shows "\<beta> \<le> \<alpha>+\<beta>"
>   using \<open>Ord \<beta>\<close>
> proof (induction rule: Ord_induct3)
>   case 0
>   then show ?case
>     by auto
> next
>   case (succ \<alpha>)
>   then show ?case
>     by (auto simp: plus_V_succ_right Ord_mem_iff_lt assms(1))
> next
>   case (Limit \<mu>)
>   then have k: "\<mu> = (SUP \<beta> \<in> elts \<mu>. \<beta>)"
>     by (simp add: Limit_eq_Sup_self)
>   also have "\<dots>  \<le> (SUP \<beta> \<in> elts \<mu>. \<alpha> + \<beta>)"
>     using Limit.IH by auto
>   also have "\<dots> = \<alpha> + (SUP \<beta> \<in> elts \<mu>. \<beta>)"
>     using Limit.hyps Limit_add_Sup_distrib by presburger
>   finally show ?case
>     using k by simp
> qed
> 
> lemma plus_\<omega>_equals_\<omega>:
>   assumes "\<alpha> \<in> elts \<omega>"  shows "\<alpha> + \<omega> = \<omega>"
> proof (rule antisym)
>   show "\<alpha> + \<omega> \<le> \<omega>"
>     using Ord_trans assms by (auto simp: elim!: mem_plus_V_E)
>   show "\<omega> \<le> \<alpha> + \<omega>"
>     by (simp add: add_le_left assms)
> qed
> 
> lemma one_plus_\<omega>_equals_\<omega> [simp]: "1 + \<omega> = \<omega>"
>   by (simp add: one_V_def plus_\<omega>_equals_\<omega>)
> 
> subsubsection \<open>Cancellation / set subtraction\<close>
418a521,701
> lemma vle_iff_le_Ord:
>   assumes "Ord \<alpha>" "Ord \<beta>"
>   shows "\<alpha> \<unlhd> \<beta> \<longleftrightarrow> \<alpha> \<le> \<beta>"
> proof
>   show "\<alpha> \<le> \<beta>" if "\<alpha> \<unlhd> \<beta>"
>     using that by (simp add: vle1)
>   show "\<alpha> \<unlhd> \<beta>" if "\<alpha> \<le> \<beta>"
>     using \<open>Ord \<alpha>\<close> \<open>Ord \<beta>\<close> that
>   proof (induction \<alpha> arbitrary: \<beta> rule: Ord_induct)
>     case (step \<gamma>)
>     then show ?case
>       unfolding vle_def
>       by (metis Ord_add Ord_linear add_le_left mem_not_refl mem_plus_V_E vsubsetD)
>   qed
> qed
> 
> lemma add_le_cancel_left0 [iff]:
>   fixes x::V shows "x \<le> x+z"
>   by (simp add: vle1 vle_def)
> 
> lemma add_less_cancel_left0 [iff]:
>   fixes x::V shows "x < x+z \<longleftrightarrow> 0<z"
>   by (metis add_less_cancel_left add.right_neutral)
> 
> lemma le_Ord_diff:
>   assumes "\<alpha> \<le> \<beta>" "Ord \<alpha>" "Ord \<beta>"
>   obtains \<gamma> where "\<alpha>+\<gamma> = \<beta>" "\<gamma> \<le> \<beta>" "Ord \<gamma>"
> proof -
>   obtain \<gamma> where \<gamma>: "\<alpha>+\<gamma> = \<beta>" "\<gamma> \<le> \<beta>"
>     by (metis add_le_cancel_left add_le_left assms vle_def vle_iff_le_Ord)
>   then have "Ord \<gamma>"
>     using Ord_def Transset_def \<open>Ord \<beta>\<close> by force
>   with \<gamma> that show thesis by blast
> qed
> 
> lemma plus_Ord_le:
>   assumes "\<alpha> \<in> elts \<omega>" "Ord \<beta>" shows "\<alpha>+\<beta> \<le> \<beta>+\<alpha>"
> proof (cases "\<beta> \<in> elts \<omega>")
>   case True
>   with assms have "\<alpha>+\<beta> = \<beta>+\<alpha>"
>     by (auto simp: elts_\<omega> add.commute ord_of_nat_add [symmetric])
>   then show ?thesis by simp
> next
>   case False
>   then have "\<omega> \<le> \<beta>" 
>     using Ord_linear2 Ord_mem_iff_lt \<open>Ord \<beta>\<close> by auto
>   then obtain \<gamma> where "\<omega>+\<gamma> = \<beta>" "\<gamma> \<le> \<beta>" "Ord \<gamma>"
>     using \<open>Ord \<beta>\<close> le_Ord_diff by auto
>   then have "\<alpha>+\<beta> = \<beta>"
>     by (metis add.assoc assms(1) plus_\<omega>_equals_\<omega>)
>   then show ?thesis
>     by simp
> qed
> 
> lemma add_right_mono: "\<lbrakk>\<alpha> \<le> \<beta>; Ord \<alpha>; Ord \<beta>; Ord \<gamma>\<rbrakk> \<Longrightarrow> \<alpha>+\<gamma> \<le> \<beta>+\<gamma>"
>   by (metis add_le_cancel_left add.assoc add_le_left le_Ord_diff)
> 
> lemma add_strict_mono: "\<lbrakk>\<alpha> < \<beta>; \<gamma> < \<delta>; Ord \<alpha>; Ord \<beta>; Ord \<gamma>; Ord \<delta>\<rbrakk> \<Longrightarrow> \<alpha>+\<gamma> < \<beta>+\<delta>"
>   by (metis order.strict_implies_order add_less_cancel_left add_right_mono le_less_trans)
> 
> lemma add_right_strict_mono: "\<lbrakk>\<alpha> \<le> \<beta>; \<gamma> < \<delta>; Ord \<alpha>; Ord \<beta>; Ord \<gamma>; Ord \<delta>\<rbrakk> \<Longrightarrow> \<alpha>+\<gamma> < \<beta>+\<delta>"
>   using add_strict_mono le_imp_less_or_eq by blast
> 
> lemma Limit_add_Limit [simp]:
>   assumes "Limit \<mu>" "Ord \<beta>" shows "Limit (\<beta> + \<mu>)"
>   unfolding Limit_def
>   proof (intro conjI allI impI)
>   show "Ord (\<beta> + \<mu>)"
>     using Limit_def assms by auto
>   show "0 \<in> elts (\<beta> + \<mu>)"
>     using Limit_def add_le_left assms by auto
> next
>   fix \<gamma>
>   assume "\<gamma> \<in> elts (\<beta> + \<mu>)"
>   then consider "\<gamma> \<in> elts \<beta>" | \<xi> where "\<xi> \<in> elts \<mu>" "\<gamma> = \<beta> + \<xi>"
>     using mem_plus_V_E by blast
>   then show "succ \<gamma> \<in> elts (\<beta> + \<mu>)"
>   proof cases
>     case 1
>     then show ?thesis
>       by (metis Kirby.add_strict_mono Limit_def Ord_add Ord_in_Ord Ord_mem_iff_lt assms one_V_def succ_eq_add1)
>   next
>     case 2
>     then show ?thesis
>       by (metis Limit_def add_mem_right_cancel assms(1) plus_V_succ_right)
>   qed
> qed
> 
> 
> subsection \<open>Generalised Difference\<close>
> 
> definition odiff where "odiff y x \<equiv> THE z::V. (x+z = y) \<or> (z=0 \<and> \<not> x \<unlhd> y)"
> 
> lemma vle_imp_odiff_eq: "x \<unlhd> y \<Longrightarrow> x + (odiff y x) = y"
>   by (auto simp: vle_def odiff_def)
> 
> lemma not_vle_imp_odiff_0: "\<not> x \<unlhd> y \<Longrightarrow> (odiff y x) = 0"
>   by (auto simp: vle_def odiff_def)
> 
> lemma Ord_odiff_eq:
>   assumes "\<alpha> \<le> \<beta>" "Ord \<alpha>" "Ord \<beta>"
>   shows "\<alpha> + odiff \<beta> \<alpha> = \<beta>"
>   by (simp add: assms vle_iff_le_Ord vle_imp_odiff_eq)
> 
> lemma Ord_odiff:
>   assumes "Ord \<alpha>" "Ord \<beta>" shows "Ord (odiff \<beta> \<alpha>)"
> proof (cases "\<alpha> \<unlhd> \<beta>")
>   case True
>   then show ?thesis
>     by (metis add_right_cancel assms le_Ord_diff vle1 vle_imp_odiff_eq)
> next
>   case False
>   then show ?thesis
>     by (simp add: odiff_def vle_def)
> qed
> 
> lemma Ord_odiff_le:
>   assumes  "Ord \<alpha>" "Ord \<beta>" shows "odiff \<beta> \<alpha> \<le> \<beta>"
> proof (cases "\<alpha> \<unlhd> \<beta>")
>   case True
>   then show ?thesis
>     by (metis add_right_cancel assms le_Ord_diff vle1 vle_imp_odiff_eq)
> next
>   case False
>   then show ?thesis 
>     by (simp add: odiff_def vle_def)
> qed
> 
> 
> lemma odiff_0_right [simp]: "odiff x 0 = x"
>   by (metis add.left_neutral vle_def vle_imp_odiff_eq)
> 
> lemma odiff_succ: "y \<unlhd> x \<Longrightarrow> odiff (succ x) y = succ (odiff x y)"
>   unfolding odiff_def
>   by (metis add_right_cancel odiff_def plus_V_succ_right vle_def vle_imp_odiff_eq)
> 
> lemma odiff_eq_iff: "z \<unlhd> x \<Longrightarrow> odiff x z = y \<longleftrightarrow> x = z + y"
>   by (auto simp: odiff_def vle_def)
> 
> lemma odiff_le_iff: "z \<unlhd> x \<Longrightarrow> odiff x z \<le> y \<longleftrightarrow> x \<le> z + y"
>   by (auto simp: odiff_def vle_def)
> 
> lemma odiff_less_iff: "z \<unlhd> x \<Longrightarrow> odiff x z < y \<longleftrightarrow> x < z + y"
>   by (auto simp: odiff_def vle_def)
> 
> lemma odiff_ge_iff: "z \<unlhd> x \<Longrightarrow> odiff x z \<ge> y \<longleftrightarrow> x \<ge> z + y"
>   by (auto simp: odiff_def vle_def)
> 
> lemma Ord_odiff_le_iff: "\<lbrakk>\<alpha> \<le> x; Ord x; Ord \<alpha>\<rbrakk> \<Longrightarrow> odiff x \<alpha> \<le> y \<longleftrightarrow> x \<le> \<alpha> + y"
>   by (simp add: odiff_le_iff vle_iff_le_Ord)
> 
> lemma odiff_le_odiff:
>   assumes "x \<unlhd> y" shows "odiff x z \<le> odiff y z"
> proof (cases "z \<unlhd> x")
>   case True
>   then show ?thesis
>     using assms odiff_le_iff vle1 vle_imp_odiff_eq vle_trans by presburger
> next
>   case False
>   then show ?thesis
>     by (simp add: not_vle_imp_odiff_0)
> qed
> 
> lemma Ord_odiff_le_odiff: "\<lbrakk>x \<le> y; Ord x; Ord y\<rbrakk> \<Longrightarrow> odiff x \<alpha> \<le> odiff y \<alpha>"
>   by (simp add: odiff_le_odiff vle_iff_le_Ord)
> 
> lemma Ord_odiff_less_odiff: "\<lbrakk>\<alpha> \<le> x; x < y; Ord x; Ord y; Ord \<alpha>\<rbrakk> \<Longrightarrow> odiff x \<alpha> < odiff y \<alpha>"
>   by (metis Ord_odiff_eq Ord_odiff_le_odiff dual_order.strict_trans less_V_def)
> 
> lemma Ord_odiff_less_imp_less: "\<lbrakk>odiff x \<alpha> < odiff y \<alpha>; Ord x; Ord y\<rbrakk> \<Longrightarrow> x < y"
>   by (meson Ord_linear2 leD odiff_le_odiff vle_iff_le_Ord)
> 
> lemma odiff_add_cancel [simp]: "odiff (x + y) x = y"
>   by (simp add: odiff_eq_iff vle_def)
> 
> lemma odiff_add_cancel_0 [simp]: "odiff x x = 0"
>   by (simp add: odiff_eq_iff)
> 
> lemma odiff_add_cancel_both [simp]: "odiff (x + y) (x + z) = odiff y z"
>   by (simp add: add.assoc odiff_def vle_def)
> 
448a732,752
> lemma ord_of_nat_mult: "ord_of_nat (m*n) = ord_of_nat m * ord_of_nat n"
> proof (induction n)
>   case (Suc n)
>   then show ?case
>     by (simp add: add.commute [of m]) (simp add: ord_of_nat_add mult_succ)
> qed auto
> 
> lemma omega_closed_mult [intro]:
>   assumes "\<alpha> \<in> elts \<omega>" "\<beta> \<in> elts \<omega>" shows "\<alpha>*\<beta> \<in> elts \<omega>"
> proof -
>   obtain m n where "\<alpha> = ord_of_nat m" "\<beta> = ord_of_nat n"
>     using assms elts_\<omega> by auto
>   then have "\<alpha>*\<beta> = ord_of_nat (m*n)"
>     by (simp add: ord_of_nat_mult)
>   then show ?thesis
>     by (simp add: \<omega>_def)
> qed
> 
> lemma zero_imp_le_mult: "0 \<in> elts y \<Longrightarrow> x \<le> x*y"
>   by (auto simp: mult [of x y])
>   
464c768
< lemma mult_Sup_distrib: "small Y \<Longrightarrow> x * (\<Squnion>Y) = \<Squnion> ((*) x ` Y)"
---
> lemma mult_Sup_distrib: "small Y \<Longrightarrow> x * (\<Squnion>Y) = \<Squnion> ((*) x ` Y)" for Y:: "V set"
488a793,795
> lemma mult_Limit: "Limit \<gamma> \<Longrightarrow> x * \<gamma> = \<Squnion> ((*) x ` elts \<gamma>)"
>   by (metis Limit_eq_Sup_self mult_Sup_distrib small_elts)
> 
522a830,846
> lemma le_mult:
>   assumes "Ord \<beta>" "\<beta> \<noteq> 0" shows "\<alpha> \<le> \<alpha> * \<beta>"
>   using assms
> proof (induction rule: Ord_induct3)
>   case (succ \<alpha>)
>   then show ?case
>     using mult_insert succ_def by fastforce
> next
>   case (Limit \<mu>)
>   have "\<alpha> \<in> (*) \<alpha> ` elts \<mu>"
>     using Limit.hyps Limit_def one_V_def by (metis imageI mult.right_neutral)
>   then have "\<alpha> \<le> \<Squnion> ((*) \<alpha> ` elts \<mu>)"
>     by auto
>   then show ?case
>     by (simp add: Limit.hyps mult_Limit)
> qed auto
> 
543c867
<     by (force simp: mult_Sup_distrib intro: Ord_Sup)
---
>     by (metis Ord_Sup imageE mult_Sup_distrib small_elts)
547a872
> 
640a966,982
> lemma elts_mult_\<omega>E:
>   assumes "x \<in> elts (y * \<omega>)"
>   obtains n where "n \<noteq> 0" "x \<in> elts (y * ord_of_nat n)" "\<And>m. m < n \<Longrightarrow> x \<notin> elts (y * ord_of_nat m)"
> proof -
>   obtain k where k:  "k \<noteq> 0 \<and> x \<in> elts (y * ord_of_nat k)"
>     using assms
>     apply (simp add: mult_Limit elts_\<omega>)
>     by (metis mult_eq_0_iff elts_0 ex_in_conv ord_of_eq_0_iff that)
>   define n where "n \<equiv> (LEAST k. k \<noteq> 0 \<and> x \<in> elts (y * ord_of_nat k))"
>   show thesis
>   proof
>     show "n \<noteq> 0" "x \<in> elts (y * ord_of_nat n)"
>       unfolding n_def by (metis (mono_tags, lifting) LeastI_ex k)+
>     show "\<And>m. m < n \<Longrightarrow> x \<notin> elts (y * ord_of_nat m)"
>       by (metis (mono_tags, lifting) mult_eq_0_iff elts_0 empty_iff n_def not_less_Least ord_of_eq_0_iff)
>   qed
> qed
952c1294
<   by (force simp: less_TC_def inf_V_def zero_V_def lift_def image_iff dest: mult_cancellation_lemma)
---
>   by (auto simp: less_TC_def inf_V_def lift_def image_iff dest: mult_cancellation_lemma)
977c1319
< lemma mult_add_mem_0: "a*x \<in> elts (a*y) \<longleftrightarrow> x \<in> elts y \<and> 0 \<in> elts a"
---
> lemma mult_add_mem_0 [simp]: "a*x \<in> elts (a*y) \<longleftrightarrow> x \<in> elts y \<and> 0 \<in> elts a"
989a1332,1385
> lemma zero_mem_mult_iff: "0 \<in> elts (x*y) \<longleftrightarrow> 0 \<in> elts x \<and> 0 \<in> elts y" 
>   by (metis Kirby.mult_zero_right mult_add_mem_0)
> 
> lemma zero_less_mult_iff [simp]: "0 < x*y \<longleftrightarrow> 0 < x \<and> 0 < y" if "Ord x" 
>   using Kirby.mult_eq_0_iff ZFC_in_HOL.neq0_conv by blast
> 
> lemma mult_cancel_less_iff [simp]:
>   "\<lbrakk>Ord \<alpha>; Ord \<beta>; Ord \<gamma>\<rbrakk> \<Longrightarrow> \<alpha>*\<beta> < \<alpha>*\<gamma> \<longleftrightarrow> \<beta> < \<gamma> \<and> 0 < \<alpha>"
>   using mult_add_mem_0 [of \<alpha> \<beta> \<gamma>]
>   by (meson Ord_0 Ord_mem_iff_lt Ord_mult)
> 
> lemma mult_cancel_le_iff [simp]:
>   "\<lbrakk>Ord \<alpha>; Ord \<beta>; Ord \<gamma>\<rbrakk> \<Longrightarrow> \<alpha>*\<beta> \<le> \<alpha>*\<gamma> \<longleftrightarrow> \<beta> \<le> \<gamma> \<or> \<alpha>=0"
>   by (metis Ord_linear2 Ord_mult eq_iff leD mult_cancel_less_iff mult_cancellation)
> 
> lemma mult_Suc_add_less: "\<lbrakk>\<alpha> < \<gamma>; \<beta> < \<gamma>; Ord \<alpha>; Ord \<beta>; Ord \<gamma>\<rbrakk>  \<Longrightarrow> \<gamma> * ord_of_nat m + \<alpha> < \<gamma> * ord_of_nat (Suc m) + \<beta>"
>   apply (simp add: mult_succ add.assoc)
>   by (meson Ord_add Ord_linear2 le_less_trans not_add_less_right)
> 
> lemma mult_nat_less_add_less:
>   assumes "m < n" "\<alpha> < \<gamma>" "\<beta> < \<gamma>" and ord: "Ord \<alpha>" "Ord \<beta>" "Ord \<gamma>"
>     shows "\<gamma> * ord_of_nat m + \<alpha> < \<gamma> * ord_of_nat n + \<beta>"
> proof -
>   have "Suc m \<le> n"
>     using \<open>m < n\<close> by auto
>   have "\<gamma> * ord_of_nat m + \<alpha> < \<gamma> * ord_of_nat (Suc m) + \<beta>"
>     using assms mult_Suc_add_less by blast
>   also have "\<dots> \<le> \<gamma> * ord_of_nat n + \<beta>"
>     using Ord_mult Ord_ord_of_nat add_right_mono \<open>Suc m \<le> n\<close> ord mult_cancel_le_iff ord_of_nat_mono_iff by presburger
>   finally show ?thesis .
> qed
> 
> lemma add_mult_less_add_mult:
>   assumes "x < y" "x \<in> elts \<beta>" "y \<in> elts \<beta>" "\<mu> \<in> elts \<alpha>" "\<nu> \<in> elts \<alpha>" "Ord \<alpha>" "Ord \<beta>"
>     shows "\<alpha>*x + \<mu> < \<alpha>*y + \<nu>"
> proof -
>   obtain "Ord x" "Ord y"
>     using Ord_in_Ord assms by blast
>   then obtain \<delta> where "0 \<in> elts \<delta>" "y = x + \<delta>"
>     by (metis add.right_neutral \<open>x < y\<close> le_Ord_diff less_V_def mem_0_Ord)
>   then show ?thesis
>     apply (simp add: add_mult_distrib add.assoc)
>     by (meson OrdmemD add_le_cancel_left0 \<open>\<mu> \<in> elts \<alpha>\<close> \<open>Ord \<alpha>\<close> less_le_trans zero_imp_le_mult)
> qed
> 
> lemma add_mult_less:
>   assumes "\<gamma> \<in> elts \<alpha>" "\<nu> \<in> elts \<beta>" "Ord \<alpha>" "Ord \<beta>"
>     shows "\<alpha> * \<nu> + \<gamma> \<in> elts (\<alpha> * \<beta>)"
> proof -
>   have "Ord \<nu>" 
>     using Ord_in_Ord assms by blast
>   with assms show ?thesis
>     by (metis Ord_mem_iff_lt Ord_succ add_mem_right_cancel mult_cancel_le_iff mult_succ succ_le_iff vsubsetD)
> qed
1064a1461,1526
> qed
> 
> lemma countable_mult:
>   assumes "countable (elts A)" "countable (elts B)"
>   shows "countable (elts (A*B))"
> proof -
>   have "vcard A \<le> \<aleph>0" "vcard B \<le> \<aleph>0"
>     using assms countable_iff_le_Aleph0 by blast+
>   then have "vcard (A*B) \<le> \<aleph>0"
>     unfolding vcard_mult
>     by (metis InfCard_csquare_eq cmult_le_mono Aleph_0 Card_\<omega> InfCard_def order_refl)
>   then show ?thesis
>     by (simp add: countable_iff_le_Aleph0)
> qed
> 
> subsection \<open>Ordertype properties\<close>
> 
> lemma ordertype_image_plus:
>   assumes "Ord \<alpha>"
>   shows "ordertype ((+) u ` elts \<alpha>) VWF = \<alpha>"
> proof (subst ordertype_VWF_eq_iff)
>     have 1: "(u + x, u + y) \<in> VWF" if "x \<in> elts \<alpha>" "y \<in> elts \<alpha>" "x < y" for x y
>       using that
>       by (meson Ord_in_Ord Ord_mem_iff_lt add_mem_right_cancel assms mem_imp_VWF)
>   then have 2: "x < y"
>     if "x \<in> elts \<alpha>" "y \<in> elts \<alpha>" "(u + x, u + y) \<in> VWF" for x y
>     using that by (metis Ord_in_Ord Ord_linear_lt VWF_asym assms)
>   show "\<exists>f. bij_betw f ((+) u ` elts \<alpha>) (elts \<alpha>) \<and> (\<forall>x\<in>(+) u ` elts \<alpha>. \<forall>y\<in>(+) u ` elts \<alpha>. (f x < f y) = ((x, y) \<in> VWF))"
>     using 1 2 unfolding bij_betw_def inj_on_def
>     by (rule_tac x="\<lambda>x. odiff x u" in exI) (auto simp: image_iff)
> qed (use assms in auto)
> 
> lemma ordertype_diff:
>   assumes "\<beta> + \<delta> = \<alpha>" and \<alpha>: "\<delta> \<in> elts \<alpha>" "Ord \<alpha>"
>   shows "ordertype (elts \<alpha> - elts \<beta>) VWF = \<delta>"
> proof -
>   have *: "elts \<alpha> - elts \<beta> = ((+)\<beta>) ` elts \<delta>"
>   proof
>     show "elts \<alpha> - elts \<beta> \<subseteq> (+) \<beta> ` elts \<delta>"
>       by clarsimp (metis assms(1) image_iff mem_plus_V_E)
>     show "(+) \<beta> ` elts \<delta> \<subseteq> elts \<alpha> - elts \<beta>"
>       using assms(1) not_add_mem_right by force
>   qed
>   have "ordertype ((+) \<beta> ` elts \<delta>) VWF = \<delta>"
>   proof (subst ordertype_VWF_inc_eq)
>     show "elts \<delta> \<subseteq> ON" "ordertype (elts \<delta>) VWF = \<delta>"
>       using \<alpha> elts_subset_ON ordertype_eq_Ord by blast+
>   qed (use "*" assms elts_subset_ON in auto)
>   then show ?thesis
>     by (simp add: *)
> qed
> 
> lemma ordertype_interval_eq:
>   assumes \<alpha>: "Ord \<alpha>" and \<beta>: "Ord \<beta>"
>   shows "ordertype ({\<alpha> ..< \<alpha>+\<beta>} \<inter> ON) VWF = \<beta>"
> proof -
>   have ON: "(+) \<alpha> ` elts \<beta> \<subseteq> ON"
>     using assms Ord_add Ord_in_Ord by blast
>   have "({\<alpha> ..< \<alpha>+\<beta>} \<inter> ON) = (+) \<alpha> ` elts \<beta>"
>     using assms
>     apply (simp add: image_def set_eq_iff)
>     by (metis add_less_cancel_left Ord_add Ord_in_Ord Ord_linear2 Ord_mem_iff_lt le_Ord_diff not_add_less_right)
>   moreover have "ordertype (elts \<beta>) VWF = ordertype ((+) \<alpha> ` elts \<beta>) VWF"
>     using ON \<beta> elts_subset_ON ordertype_VWF_inc_eq by auto
>   ultimately show ?thesis
>     using \<beta> by auto
Only in ../../AFPs/afp-2020/thys/ZFC_in_HOL: Ordinal_Exp.thy
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/ZFC_in_HOL/ZFC_Cardinals.thy ../../AFPs/afp-2020/thys/ZFC_in_HOL/ZFC_Cardinals.thy
7a8,10
> declare [[coercion_enabled]]
> declare [[coercion "ord_of_nat :: nat \<Rightarrow> V"]]
> 
92c95
<   by (auto simp: VSigma_def UN UNION_singleton_eq_range)
---
>   by (auto simp: VSigma_def UNION_singleton_eq_range)
148c151
< text\<open>Introduction rules for the injections (as equivalences)\<close>
---
> subsubsection\<open>Equivalences for the injections and an elimination rule\<close>
156,157d158
< text \<open>Elimination rule\<close>
< 
163c164
< text \<open>Injection and freeness equivalences, for rewriting\<close>
---
> subsubsection \<open>Injection and freeness equivalences, for rewriting\<close>
226a228,276
> subsubsection \<open>Applications of disjoint sums and pairs: general union theorems for small sets\<close>
> 
> lemma small_Un:
>   assumes X: "small X" and Y: "small Y"
>   shows "small (X \<union> Y)"
> proof -
>   obtain f g :: "'a\<Rightarrow>V" where f: "inj_on f X" and g: "inj_on g Y" 
>     by (meson assms small_def)
>   define h where "h \<equiv> \<lambda>z. if z \<in> X then Inl (f z) else Inr (g z)"
>   show ?thesis
>     unfolding small_def
>   proof (intro exI conjI)
>     show "inj_on h (X \<union> Y)"
>       using f g by (auto simp add: inj_on_def h_def)
>     show "h ` (X \<union> Y) \<in> range elts"
>       by (metis X Y image_Un replacement small_iff_range small_sup_iff)
>   qed
> qed
> 
> lemma small_UN [simp,intro]:
>   assumes X: "small X" and B: "\<And>x. x \<in> X \<Longrightarrow> small (B x)"
>   shows "small (\<Union>x\<in>X. B x)"
> proof -
>   obtain f :: "'a\<Rightarrow>V" where f: "inj_on f X" 
>     by (meson assms small_def)
>   have "\<exists>g. inj_on g (B x) \<and> g ` (B x) \<in> range elts" if "x \<in> X" for x
>     using B small_def that by auto
>   then obtain g::"'a \<Rightarrow> 'b \<Rightarrow> V" where g: "\<And>x. x \<in> X \<Longrightarrow> inj_on (g x) (B x)" 
>     by metis
>   define \<phi> where "\<phi> \<equiv> \<lambda>y. @x. x \<in> X \<and> y \<in> B x"
>   have \<phi>: "\<phi> y \<in> X \<and> y \<in> B (\<phi> y)" if "y \<in> (\<Union>x\<in>X. B x)" for y
>     unfolding \<phi>_def by (metis (mono_tags, lifting) UN_E someI that)
>   define h where "h \<equiv> \<lambda>y. \<langle>f (\<phi> y), g (\<phi> y) y\<rangle>"
>   show ?thesis
>     unfolding small_def
>   proof (intro exI conjI)
>     show "inj_on h (\<Union> (B ` X))"
>       using f g \<phi> unfolding h_def inj_on_def by (metis vpair_inject)
>   have "small (h ` \<Union> (B ` X))"
>     by (simp add: B X image_UN)
>   then show "h ` \<Union> (B ` X) \<in> range elts"
>     using small_iff_range by blast
>   qed
> qed
> 
> lemma small_Union [simp,intro]:
>   assumes "\<A> \<subseteq> Collect small" "small \<A>"
>   shows "small (\<Union> \<A>)"
>   using small_UN [of \<A> "\<lambda>x. x"] assms by (simp add: subset_iff)
462c512,514
<     by (smt Transset_TC Transset_def less_TC_def inf.bounded_iff inf.cobounded1 inf.commute inf_idem local.step vsubsetD vsubsetI)
---
>     using Transset_TC
>     unfolding Transset_def
>     by (metis inf.bounded_iff less_TC_def less_eq_V_def local.step subsetI vsubsetD) 
501a554,556
> lemma Ord_iff_rank: "Ord x \<longleftrightarrow> rank x = x"
>   using Ord_rank [of x] rank_of_Ord by fastforce
> 
504c559
<   by (metis (no_types, lifting) Ord_mem_iff_lt Ord_rank UN UN_iff elts_of_set elts_succ insert_iff rank small_elts)
---
>   by (metis (no_types, lifting) Ord_mem_iff_lt Ord_rank small_UN UN_iff elts_of_set elts_succ insert_iff rank small_elts)
522c577
<   using rank [of a] rank [of b] UN by auto
---
>   using rank [of a] rank [of b] small_UN by auto
711c766,874
< subsubsection\<open>Order types\<close>
---
> subsubsection \<open>Transitive Closure and VWO\<close>
> 
> lemma mem_imp_VWO: "x \<in> elts y \<Longrightarrow> (x,y) \<in> VWO"
>   using VWO by blast
> 
> lemma less_TC_imp_VWO: "x \<sqsubset> y \<Longrightarrow> (x,y) \<in> VWO"
>   unfolding less_TC_def
> proof (induction y arbitrary: x rule: eps_induct)
>   case (step y' u)
>   then consider "u \<in> elts y'" | v where "v \<in> elts y'" "u \<in> elts (TC v)"
>     by (auto simp: TC [of y'])
>   then show ?case
>   proof cases
>     case 2
>     then show ?thesis
>       by (meson mem_imp_VWO step.IH transD trans_VWO)
>   qed (use mem_imp_VWO in blast)
> qed
> 
> lemma le_TC_imp_VWO: "x \<sqsubseteq> y \<Longrightarrow> (x,y) \<in> VWO"
>   apply (auto simp: le_TC_def less_TC_imp_VWO)
>   by (metis Diff_iff Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO)
> 
> lemma le_TC_0_iff [simp]: "x \<sqsubseteq> 0 \<longleftrightarrow> x = 0"
>   by (simp add: le_TC_def)
> 
> lemma less_TC_succ: " x \<sqsubset> succ \<beta> \<longleftrightarrow> x \<sqsubset> \<beta> \<or> x = \<beta>"
>   by (metis elts_succ insert_iff le_TC_def less_TC_iff)
> 
> lemma le_TC_succ: "x \<sqsubseteq> succ \<beta> \<longleftrightarrow> x \<sqsubseteq> \<beta> \<or> x = succ \<beta>"
>   by (simp add: le_TC_def less_TC_succ)
> 
> lemma Transset_TC_eq [simp]: "Transset x \<Longrightarrow> TC x = x"
>   by (simp add: TC_least arg_subset_TC eq_iff)
> 
> lemma Ord_TC_less_iff: "\<lbrakk>Ord \<alpha>; Ord \<beta>\<rbrakk> \<Longrightarrow> \<beta> \<sqsubset> \<alpha> \<longleftrightarrow> \<beta> < \<alpha>"
>   by (metis Ord_def Ord_mem_iff_lt Transset_TC_eq less_TC_def)
> 
> lemma Ord_mem_iff_less_TC: "Ord l \<Longrightarrow> k \<in> elts l \<longleftrightarrow> k \<sqsubset> l"
>   by (simp add: Ord_def less_TC_def)
> 
> lemma le_TC_Ord: "\<lbrakk>\<beta> \<sqsubseteq> \<alpha>; Ord \<alpha>\<rbrakk> \<Longrightarrow> Ord \<beta>"
>   by (metis Ord_def Ord_in_Ord Transset_TC_eq le_TC_def less_TC_def)
> 
> lemma Ord_less_TC_mem:
>   assumes "Ord \<alpha>" "\<beta> \<sqsubset> \<alpha>" shows "\<beta> \<in> elts \<alpha>"
>   using Ord_def assms less_TC_def by auto
> 
> lemma VWO_TC_le: "\<lbrakk>Ord \<alpha>; Ord \<beta>; (\<beta>, \<alpha>) \<in> VWO\<rbrakk> \<Longrightarrow> \<beta> \<sqsubseteq> \<alpha>"
> proof (induct \<alpha> arbitrary: \<beta> rule: Ord_induct)
>   case (step \<alpha>)
>   then show ?case
>     by (metis Diff_iff Linear_order_VWO Linear_order_in_diff_Id Ord_TC_less_iff Ord_linear2 UNIV_I VWO le_TC_def le_less less_TC_imp_VWO pair_in_Id_conv)
> qed
> 
> lemma VWO_iff_Ord_le [simp]: "\<lbrakk>Ord \<alpha>; Ord \<beta>\<rbrakk> \<Longrightarrow> (\<beta>, \<alpha>) \<in> VWO \<longleftrightarrow> \<beta> \<le> \<alpha>"
>   by (metis VWO_TC_le Ord_TC_less_iff le_TC_def le_TC_imp_VWO le_less)
> 
> lemma zero_TC_le [iff]: "0 \<sqsubseteq> y"
>   using le_TC_def nonzero_less_TC by auto
> 
> lemma succ_le_TC_iff: "Ord j \<Longrightarrow> succ i \<sqsubseteq> j \<longleftrightarrow> i \<sqsubset> j"
>   by (metis Ord_in_Ord Ord_linear Ord_mem_iff_less_TC Ord_succ le_TC_def less_TC_succ less_asym_TC)
> 
> lemma VWO_0_iff [simp]: "(x,0) \<in> VWO \<longleftrightarrow> x=0"
> proof
>   show "x = 0" if "(x, 0) \<in> VWO"
>     using zero_TC_le [of x] le_TC_imp_VWO that
>     by (metis DiffI Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO pair_in_Id_conv)
> qed auto
> 
> lemma VWO_antisym:
>   assumes "(x,y) \<in> VWO" "(y,x) \<in> VWO" shows "x=y"
>   by (metis Diff_iff IdD Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO assms)
> 
> subsubsection \<open>Relation VWF\<close>
> 
> definition VWF where "VWF \<equiv> VWO - Id"
> 
> lemma wf_VWF [iff]: "wf VWF"
>   by (simp add: VWF_def wf_VWO)
> 
> lemma trans_VWF [iff]: "trans VWF"
>   by (simp add: VWF_def antisym_VWO trans_VWO trans_diff_Id)
> 
> lemma asym_VWF [iff]: "asym VWF"
>   by (metis VWF_def asym.intros irrefl_diff_Id wf_VWF wf_not_sym)
> 
> lemma total_VWF [iff]: "total VWF"
>   using VWF_def total_VWOId by auto
> 
> lemma total_on_VWF [iff]: "total_on A VWF"
>   by (meson UNIV_I total_VWF total_on_def)
> 
> lemma VWF_asym:
>   assumes "(x,y) \<in> VWF" "(y,x) \<in> VWF" shows False
>   using VWF_def assms wf_VWO wf_not_sym by fastforce
> 
> lemma VWF_non_refl [iff]: "(x,x) \<notin> VWF"
>   by simp
> 
> lemma VWF_iff_Ord_less [simp]: "\<lbrakk>Ord \<alpha>; Ord \<beta>\<rbrakk> \<Longrightarrow> (\<alpha>,\<beta>) \<in> VWF \<longleftrightarrow> \<alpha> < \<beta>"
>   by (simp add: VWF_def less_V_def)
> 
> lemma mem_imp_VWF: "x \<in> elts y \<Longrightarrow> (x,y) \<in> VWF"
>   using VWF_def mem_imp_VWO by fastforce
> 
> 
> subsection\<open>Order types\<close>
713,714c876,877
< definition ordermap :: "[V set, (V \<times> V) set, V] \<Rightarrow> V"
<     where "ordermap A r \<equiv> wfrec r (\<lambda>f x. set (f ` {y \<in> A. (y,x) \<in> r}))"
---
> definition ordermap :: "'a set \<Rightarrow> ('a \<times> 'a) set \<Rightarrow> 'a \<Rightarrow> V"
>   where "ordermap A r \<equiv> wfrec r (\<lambda>f x. set (f ` {y \<in> A. (y,x) \<in> r}))"
716,717c879,880
< definition ordertype :: "[V set, (V \<times> V) set] \<Rightarrow> V"  where
<    "ordertype A r \<equiv> set (ordermap A r ` A)"
---
> definition ordertype :: "'a set \<Rightarrow> ('a \<times> 'a) set \<Rightarrow> V"
>   where "ordertype A r \<equiv> set (ordermap A r ` A)"
722a886,888
> lemma ordermap_in_ordertype [intro]: "\<lbrakk>a \<in> A; small A\<rbrakk> \<Longrightarrow> ordermap A r a \<in> elts (ordertype A r)"
>   by (simp add: ordertype_def)
> 
727c893
< lemma Ord_ordermap [iff]: assumes "wf r" "trans r" "x \<in> A" shows "Ord (ordermap A r x)"
---
> lemma Ord_ordermap [iff]: assumes "wf r" "trans r" shows "Ord (ordermap A r x)"
737,738c903,906
<       have "x \<in> ordermap A r ` {z \<in> A. (z, y) \<in> r}"
<         by (metis (no_types, lifting) elts_of_set empty_iff \<open>wf r\<close> ordermap x)
---
>       have "ordermap A r y = ZFC_in_HOL.set (ordermap A r ` {a \<in> A. (a, y) \<in> r})"
>         using ordermap assms(1) by force
>       then have "x \<in> ordermap A r ` {z \<in> A. (z, y) \<in> r}"
>         by (metis (no_types, lifting) elts_of_set empty_iff x)
749c917
<     by (metis (no_types, lifting) OrdI Ord_is_Transset \<open>wf r\<close> ordermap)
---
>     by (metis (full_types) Ord_def ordermap assms(1))
763,764c931,943
< lemma Ord_ordertype: "Ord(ordertype A (VWO - Id))"
<   using antisym_VWO trans_VWO trans_diff_Id wf_Ord_ordertype wf_VWO by blast
---
> lemma Ord_ordertype [simp]: "Ord(ordertype A VWF)"
>   using wf_Ord_ordertype by blast
> 
> lemma ordertype_singleton [simp]:
>   assumes "wf r" 
>   shows "ordertype {x} r = 1"
> proof -
>   have \<dagger>: "{y. y = x \<and> (y, x) \<in> r} = {}"
>     using assms by auto
>   show ?thesis
>     by (auto simp add: ordertype_def assms \<dagger> ordermap [where a=x])
> qed
> 
769,770c948,956
<      "\<lbrakk>(w, x) \<in> r; wf r; w \<in> A; small A\<rbrakk> \<Longrightarrow> ordermap A r w \<in> elts (ordermap A r x)"
<   by (simp add: ordermap [of r A])
---
>   assumes wx: "(w, x) \<in> r" and "wf r" "w \<in> A" "small A"
>     shows "ordermap A r w \<in> elts (ordermap A r x)"
> proof -
>   have "small {a \<in> A. (a, x) \<in> r} \<and> w \<in> A \<and> (w, x) \<in> r"
>     by (simp add: assms)
>   then show ?thesis
>     using assms ordermap [of r A]
>     by (metis (no_types, lifting) elts_of_set image_eqI mem_Collect_eq replacement)
> qed
773c959
<   assumes "ordermap A r y \<in> elts (ordermap A r x)" "wf r" "total r" "y \<in> A" "x \<in> A" "small A"
---
>   assumes "ordermap A r y \<in> elts (ordermap A r x)" "wf r" "total_on A r" "x \<in> A" "y \<in> A" "small A"
782c968
<     using \<open>total r\<close> by (meson UNIV_I total_on_def)
---
>     using \<open>total_on A r\<close> assms by (meson UNIV_I total_on_def)
784,785c970
<     using ordermap_mono
<     by (meson assms(1) assms(2) assms(5) assms(6) mem_not_sym)
---
>     by (meson ordermap_mono assms mem_not_sym)
792c977
<   assumes "wf r" "total r" "small A"
---
>   assumes "wf r" "total_on A r" "small A"
796,798c981,982
<   show "inj_on (ordermap A r) A"
<     apply (rule inj_onI)
<     by (metis UNIV_I assms mem_not_refl ordermap_mono total_on_def)
---
>     show "inj_on (ordermap A r) A"
>     unfolding inj_on_def by (metis assms mem_not_refl ordermap_mono total_on_def)
800c984,998
<     by (simp add: assms(3) ordertype_def)
---
>     by (metis ordertype_def \<open>small A\<close> elts_of_set replacement)
> qed
> 
> lemma ordermap_eq_iff [simp]: 
>   "\<lbrakk>x \<in> A; y \<in> A; wf r; total_on A r; small A\<rbrakk> \<Longrightarrow> ordermap A r x = ordermap A r y \<longleftrightarrow> x = y"
>   by (metis bij_betw_iff_bijections ordermap_bij)
> 
> lemma ordertype_nat_imp_finite:
>   assumes "ordertype A r = ord_of_nat m" "small A" "wf r" "total_on A r"
>   shows "finite A"
> proof -
>   have "A \<approx> elts m"
>     using eqpoll_def assms ordermap_bij by fastforce 
>   then show ?thesis
>     using eqpoll_finite_iff finite_Ord_omega by blast
804c1002
<   assumes "wf r" "total r" "small A"
---
>   assumes "wf r" "total_on A r" "small A"
810,811c1008,1581
<   shows "elts (ordertype A (VWO - Id)) \<approx> A"
<   using assms total_VWOId wf_VWO wf_ordertype_eqpoll by auto
---
>   shows "elts (ordertype A VWF) \<approx> A"
>   using assms wf_ordertype_eqpoll total_VWF wf_VWF
>   by (simp add: wf_ordertype_eqpoll total_on_def)
> 
> subsection \<open>More advanced @{term ordertype} and @{term ordermap} results\<close>
> 
> lemma ordermap_VWF_0 [simp]: "ordermap A VWF 0 = 0"
>   by (simp add: ordermap wf_VWO VWF_def)
> 
> lemma ordertype_empty [simp]: "ordertype {} r = 0"
>   by (simp add: ordertype_def)
> 
> lemma ordertype_eq_0_iff [simp]: "\<lbrakk>small X; wf r\<rbrakk> \<Longrightarrow> ordertype X r = 0 \<longleftrightarrow> X = {}"
>   by (metis ordertype_def elts_of_set replacement image_is_empty zero_V_def)
> 
> lemma ordermap_mono_less:
>   assumes "(w, x) \<in> r"
>       and "wf r" "trans r"
>       and "w \<in> A" "x \<in> A"
>       and "small A"
>     shows "ordermap A r w < ordermap A r x"
>   by (simp add: OrdmemD assms ordermap_mono)
> 
> lemma ordermap_mono_le:
>   assumes "(w, x) \<in> r \<or> w=x"
>       and "wf r" "trans r"
>       and "w \<in> A" "x \<in> A"
>       and "small A"
>     shows "ordermap A r w \<le> ordermap A r x"
>   by (metis assms dual_order.strict_implies_order eq_refl ordermap_mono_less)
> 
> lemma converse_ordermap_le_mono:
>   assumes "ordermap A r y \<le> ordermap A r x" "wf r" "total r"  "x \<in> A" "small A"
>   shows "(y, x) \<in> r \<or> y=x"
>   by (meson UNIV_I assms mem_not_refl ordermap_mono total_on_def vsubsetD)
> 
> lemma ordertype_mono:
>   assumes "X \<subseteq> Y" and r: "wf r" "trans r" and "small Y"
>   shows "ordertype X r \<le> ordertype Y r"
> proof -
>   have "small X"
>     using assms smaller_than_small by fastforce 
>   have *: "ordermap X r x \<le> ordermap Y r x" for x
>     using \<open>wf r\<close>
>   proof (induction x rule: wf_induct_rule)
>     case (less x)
>     have "ordermap X r z < ordermap Y r x" if "z \<in> X" and zx: "(z,x) \<in> r" for z
>       using less [OF zx] assms
>       by (meson Ord_linear2 OrdmemD Ord_ordermap ordermap_mono in_mono leD that(1) vsubsetD zx)
>     then show ?case
>       by (auto simp add: ordermap [of _ X x] \<open>small X\<close> Ord_mem_iff_lt set_image_le_iff less_eq_V_def r)
>   qed
>   show ?thesis
>   proof -
>     have "ordermap Y r ` Y = elts (ordertype Y r)"
>       by (metis ordertype_def \<open>small Y\<close> elts_of_set replacement)
>     then have "ordertype Y r \<notin> ordermap X r ` X"
>       using "*" \<open>X \<subseteq> Y\<close> by fastforce
>     then show ?thesis
>       by (metis Ord_linear2 Ord_mem_iff_lt ordertype_def wf_Ord_ordertype \<open>small X\<close> elts_of_set replacement r)
>   qed
> qed
> 
> corollary ordertype_VWF_mono:
>   assumes "X \<subseteq> Y" "small Y"
>   shows "ordertype X VWF \<le> ordertype Y VWF"
>   using assms by (simp add: ordertype_mono)
> 
> lemma ordertype_UNION_ge:
>   assumes "A \<in> \<A>" "wf r" "trans r" "\<A> \<subseteq> Collect small" "small \<A>"
>   shows "ordertype A r \<le> ordertype (\<Union>\<A>) r" 
>   by (rule ordertype_mono) (use assms in auto)
> 
> lemma inv_ordermap_mono_less:
>   assumes "(inv_into M (ordermap M r) \<alpha>, inv_into M (ordermap M r) \<beta>) \<in> r" 
>     and "small M" and \<alpha>: "\<alpha> \<in> elts (ordertype M r)" and \<beta>: "\<beta> \<in> elts (ordertype M r)"
>     and "wf r" "trans r"
>   shows "\<alpha> < \<beta>"
> proof -
>   have "\<alpha> = ordermap M r (inv_into M (ordermap M r) \<alpha>)"
>     by (metis \<alpha> f_inv_into_f ordermap_surj subset_eq)
>   also have "\<dots> < ordermap M r (inv_into M (ordermap M r) \<beta>)"
>     by (meson \<alpha> \<beta> assms in_mono inv_into_into ordermap_mono_less ordermap_surj)
>   also have "\<dots> = \<beta>"
>     by (meson \<beta> f_inv_into_f in_mono ordermap_surj)
>   finally show ?thesis .
> qed
> 
> lemma inv_ordermap_mono_eq:
>   assumes "inv_into M (ordermap M r) \<alpha> = inv_into M (ordermap M r) \<beta>" 
>     and "\<alpha> \<in> elts (ordertype M r)" "\<beta> \<in> elts (ordertype M r)"
>   shows "\<alpha> = \<beta>"
>   by (metis assms f_inv_into_f ordermap_surj subsetD)
> 
> lemma inv_ordermap_VWF_mono_le:
>   assumes "inv_into M (ordermap M VWF) \<alpha> \<le> inv_into M (ordermap M VWF) \<beta>" 
>     and "M \<subseteq> ON" "small M" and \<alpha>: "\<alpha> \<in> elts (ordertype M VWF)" and \<beta>: "\<beta> \<in> elts (ordertype M VWF)"
>   shows "\<alpha> \<le> \<beta>"
> proof -
>   have "\<alpha> = ordermap M VWF (inv_into M (ordermap M VWF) \<alpha>)"
>     by (metis \<alpha> f_inv_into_f ordermap_surj subset_eq)
>   also have "\<dots> \<le> ordermap M VWF (inv_into M (ordermap M VWF) \<beta>)"
>     by (metis ON_imp_Ord VWF_iff_Ord_less assms dual_order.strict_implies_order elts_of_set eq_refl inv_into_into order.not_eq_order_implies_strict ordermap_mono_less ordertype_def replacement trans_VWF wf_VWF)
>   also have "\<dots> = \<beta>"
>     by (meson \<beta> f_inv_into_f in_mono ordermap_surj)
>   finally show ?thesis .
> qed
> 
> lemma strict_mono_on_ordertype:
>   assumes "M \<subseteq> ON" "small M"
>   obtains f where "f \<in> elts (ordertype M VWF) \<rightarrow> M" "strict_mono_on f (elts (ordertype M VWF))"
> proof 
>   show "inv_into M (ordermap M VWF) \<in> elts (ordertype M VWF) \<rightarrow> M"
>     by (meson Pi_I' in_mono inv_into_into ordermap_surj)
>   show "strict_mono_on (inv_into M (ordermap M VWF)) (elts (ordertype M VWF))"
>   proof (clarsimp simp: strict_mono_on_def)
>     fix x y
>     assume "x \<in> elts (ordertype M VWF)" "y \<in> elts (ordertype M VWF)" "x < y"
>     then show "inv_into M (ordermap M VWF) x < inv_into M (ordermap M VWF) y"
>       using assms by (meson ON_imp_Ord Ord_linear2 inv_into_into inv_ordermap_VWF_mono_le leD ordermap_surj subsetD)
>   qed
> qed
> 
> lemma ordermap_inc_eq:
>   assumes "x \<in> A" "small A"
>     and \<pi>: "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (x,y) \<in> r\<rbrakk> \<Longrightarrow> (\<pi> x, \<pi> y) \<in> s"
>     and r: "wf r" "total_on A r" and "wf s" 
>   shows "ordermap (\<pi> ` A) s (\<pi> x) = ordermap A r x"
>   using \<open>wf r\<close> \<open>x \<in> A\<close>
> proof (induction x rule: wf_induct_rule)
>   case (less x)
>   then have 1: "{y \<in> A. (y, x) \<in> r} = A \<inter> {y. (y, x) \<in> r}"
>     using r by auto
>   have 2: "{y \<in> \<pi> ` A. (y, \<pi> x) \<in> s} = \<pi> ` A \<inter> {y. (y, \<pi> x) \<in> s}"
>     by auto
>   have inv\<pi>: "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (\<pi> x, \<pi> y) \<in> s\<rbrakk> \<Longrightarrow> (x, y) \<in> r"
>     by (metis \<pi> \<open>wf s\<close> \<open>total_on A r\<close> total_on_def wf_not_sym)
>   have eq: "f ` (\<pi> ` A \<inter> {y. (y, \<pi> x) \<in> s}) = (f \<circ> \<pi>) ` (A \<inter> {y. (y, x) \<in> r})" for f :: "'b \<Rightarrow> V"
>     using less by (auto simp: image_subset_iff inv\<pi> \<pi>)
>   show ?case
>     using less
>     by (simp add: ordermap [OF \<open>wf r\<close>, of _ x] ordermap [OF \<open>wf s\<close>, of _ "\<pi> x"] 1 2 eq)
> qed
> 
> lemma ordertype_inc_eq:
>   assumes "small A"
>     and \<pi>: "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (x,y) \<in> r\<rbrakk> \<Longrightarrow> (\<pi> x, \<pi> y) \<in> s"
>     and r: "wf r" "total_on A r" and "wf s" 
>   shows "ordertype (\<pi> ` A) s = ordertype A r"
> proof -
>   have "ordermap (\<pi> ` A) s (\<pi> x) = ordermap A r x" if "x \<in> A" for x
>     using assms that by (auto simp: ordermap_inc_eq)
>   then show ?thesis
>     unfolding ordertype_def
>     by (metis (no_types, lifting) image_cong image_image)
> qed
> 
> lemma ordertype_inc_le:
>   assumes "small A" "small B"
>     and \<pi>: "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (x,y) \<in> r\<rbrakk> \<Longrightarrow> (\<pi> x, \<pi> y) \<in> s"
>     and r: "wf r" "total_on A r" and "wf s" "trans s"
>     and "\<pi> ` A \<subseteq> B"
>   shows "ordertype A r \<le> ordertype B s"
>   by (metis assms ordertype_inc_eq ordertype_mono)
> 
> corollary ordertype_VWF_inc_eq:
>   assumes "A \<subseteq> ON" "\<pi> ` A \<subseteq> ON" "small A" and "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; x<y\<rbrakk> \<Longrightarrow> \<pi> x < \<pi> y"
>   shows "ordertype (\<pi> ` A) VWF = ordertype A VWF"
> proof (rule ordertype_inc_eq)
>   show "(\<pi> x, \<pi> y) \<in> VWF"
>     if "x \<in> A" "y \<in> A" "(x, y) \<in> VWF" for x y
>     using that ON_imp_Ord assms by auto
>   show "total_on A VWF"
>     by (meson UNIV_I total_VWF total_on_def)
> qed (use assms in auto)
> 
> lemma ordertype_image_ordermap:
>   assumes "small A" "X \<subseteq> A" "wf r" "trans r" "total_on X r"
>   shows "ordertype (ordermap A r ` X) VWF = ordertype X r"
> proof (rule ordertype_inc_eq)
>   show "small X"
>     by (meson assms smaller_than_small)
>   show "(ordermap A r x, ordermap A r y) \<in> VWF"
>     if "x \<in> X" "y \<in> X" "(x, y) \<in> r" for x y
>     by (meson that Ord_ordermap VWF_iff_Ord_less assms ordermap_mono_less subsetD)
> qed (use assms in auto)
>     
> lemma ordertype_map_image:
>   assumes "B \<subseteq> A" "small A"
>   shows "ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF = ordertype (A - B) VWF"
> proof -
>   have "ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)"
>     using assms by auto
>   then have "ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF = ordertype (ordermap A VWF ` (A - B)) VWF"
>     by simp
>   also have "\<dots> = ordertype (A - B) VWF"
>     using \<open>small A\<close> ordertype_image_ordermap by fastforce
>   finally show ?thesis .
> qed
> 
> proposition ordertype_le_ordertype:
>   assumes r: "wf r" "total_on A r" and "small A"
>   assumes s: "wf s" "total_on B s" "trans s" and "small B"
>   shows "ordertype A r \<le> ordertype B s \<longleftrightarrow>
>          (\<exists>f \<in> A \<rightarrow> B. inj_on f A \<and> (\<forall>x \<in> A. \<forall>y \<in> A. ((x,y) \<in> r \<longrightarrow> (f x, f y) \<in> s)))"
>     (is "?lhs = ?rhs")
> proof
>   assume L: ?lhs
>   define f where "f \<equiv> inv_into B (ordermap B s) \<circ> ordermap A r"
>   show ?rhs
>   proof (intro bexI conjI ballI impI)
>     have AB: "elts (ordertype A r) \<subseteq> ordermap B s ` B"
>       by (metis L assms(7) ordertype_def replacement set_of_elts small_elts subset_iff_less_eq_V)
>     have bijA: "bij_betw (ordermap A r) A (elts (ordertype A r))"
>       using ordermap_bij \<open>small A\<close> r by blast
>     have "inv_into B (ordermap B s) (ordermap A r i) \<in> B" if "i \<in> A" for i
>       by (meson L \<open>small A\<close> inv_into_into ordermap_in_ordertype ordermap_surj subsetD that vsubsetD)
>     then show "f \<in> A \<rightarrow> B"
>       by (auto simp: Pi_iff f_def)
>     show "inj_on f A"
>     proof (clarsimp simp add: f_def inj_on_def)
>       fix x y
>       assume "x \<in> A" "y \<in> A"
>         and "inv_into B (ordermap B s) (ordermap A r x) = inv_into B (ordermap B s) (ordermap A r y)"
>       then have "ordermap A r x = ordermap A r y"
>         by (meson AB \<open>small A\<close> inv_into_injective ordermap_in_ordertype subsetD)
>       then show "x = y"
>         by (metis \<open>x \<in> A\<close> \<open>y \<in> A\<close> bijA bij_betw_inv_into_left)
>     qed
>   next
>     fix x y
>     assume "x \<in> A" "y \<in> A" and "(x, y) \<in> r"
>     have \<ddagger>: "ordermap A r y \<in> ordermap B s ` B"
>       by (meson L \<open>y \<in> A\<close> \<open>small A\<close> in_mono ordermap_in_ordertype ordermap_surj vsubsetD)
>     moreover have \<dagger>: "\<And>x. inv_into B (ordermap B s) (ordermap A r x) = f x"
>       by (simp add: f_def)
>     then have *: "ordermap B s (f y) = ordermap A r y"
>       using \<ddagger> by (metis f_inv_into_f)
>     moreover have "ordermap A r x \<in> ordermap B s ` B"
>       by (meson L \<open>x \<in> A\<close> \<open>small A\<close> in_mono ordermap_in_ordertype ordermap_surj vsubsetD)
>     moreover have "ordermap A r x < ordermap A r y"
>       using * r s by (metis (no_types) Ord_ordermap OrdmemD \<open>(x, y) \<in> r\<close> \<open>x \<in> A\<close> \<open>small A\<close> ordermap_mono)
>     ultimately show "(f x, f y) \<in> s"
>       using \<dagger> s by (metis assms(7) f_inv_into_f inv_into_into less_asym ordermap_mono_less total_on_def)
>   qed
> next
>   assume R: ?rhs
>   then obtain f where f: "f\<in>A \<rightarrow> B" "inj_on f A" "\<forall>x\<in>A. \<forall>y\<in>A. (x, y) \<in> r \<longrightarrow> (f x, f y) \<in> s"
>     by blast
>   show ?lhs
>     by (rule ordertype_inc_le [where \<pi>=f]) (use f assms in auto)
> qed
> 
> lemma ordertype_infinite_ge_\<omega>:
>   assumes "infinite A" "small A"
>   shows "ordertype A VWF \<ge> \<omega>"
> proof -
>   have "inj_on (ordermap A VWF) A"
>     by (meson ordermap_bij \<open>small A\<close> bij_betw_def total_on_VWF wf_VWF)
>   then have "infinite (ordermap A VWF ` A)"
>     using \<open>infinite A\<close> finite_image_iff by blast
>   then show ?thesis
>     using Ord_ordertype \<open>small A\<close> infinite_Ord_omega by (auto simp: ordertype_def)
> qed
> 
> lemma ordertype_eqI:
>   assumes "wf r" "total_on A r" "small A" "wf s" 
>           "bij_betw f A B" "(\<forall>x \<in> A. \<forall>y \<in> A. (f x, f y) \<in> s \<longleftrightarrow> (x,y) \<in> r)"
>   shows "ordertype A r = ordertype B s"
>   by (metis assms bij_betw_imp_surj_on ordertype_inc_eq)
> 
> lemma ordermap_eq_self:
>   assumes "Ord \<alpha>" and x: "x \<in> elts \<alpha>" 
>   shows "ordermap (elts \<alpha>) VWF x = x" 
>   using Ord_in_Ord [OF assms] x 
> proof (induction x rule: Ord_induct)
>   case (step x)
>   have 1: "{y \<in> elts \<alpha>. (y, x) \<in> VWF} = elts x" (is "?A = _")
>   proof
>     show "?A \<subseteq> elts x"
>       using \<open>Ord \<alpha>\<close> by clarify (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less step.hyps)
>     show "elts x \<subseteq> ?A"
>       using \<open>Ord \<alpha>\<close> by clarify (meson Ord_in_Ord Ord_trans OrdmemD VWF_iff_Ord_less step.prems)
>   qed
>   show ?case
>     using step
>     by (simp add: ordermap [OF wf_VWF, of _ x] 1 Ord_trans [of _ _ \<alpha>] step.prems \<open>Ord \<alpha>\<close> cong: image_cong)
> qed
> 
> lemma ordertype_eq_Ord [simp]:
>   assumes "Ord \<alpha>" 
>   shows "ordertype (elts \<alpha>) VWF = \<alpha>"
>   using assms ordermap_eq_self [OF assms] by (simp add: ordertype_def)
> 
> 
> proposition ordertype_eq_iff:
>   assumes \<alpha>: "Ord \<alpha>" and r: "wf r" and "small A" "total_on A r" "trans r"
>   shows "ordertype A r = \<alpha> \<longleftrightarrow>
>          (\<exists>f. bij_betw f A (elts \<alpha>) \<and> (\<forall>x \<in> A. \<forall>y \<in> A. f x < f y \<longleftrightarrow> (x,y) \<in> r))"
>     (is "?lhs = ?rhs")
> proof safe
>   assume eq: "\<alpha> = ordertype A r"
>   show "\<exists>f. bij_betw f A (elts (ordertype A r)) \<and> (\<forall>x\<in>A. \<forall>y\<in>A. f x < f y \<longleftrightarrow> ((x, y) \<in> r))"
>   proof (intro exI conjI ballI)
>     show "bij_betw (ordermap A r) A (elts (ordertype A r))"
>       by (simp add: assms ordermap_bij)
>     then show "ordermap A r x < ordermap A r y \<longleftrightarrow> (x, y) \<in> r"
>       if "x \<in> A" "y \<in> A" for x y
>       using that assms
>       by (metis order.asym ordermap_mono_less total_on_def)
>   qed
> next
>   fix f 
>   assume f: "bij_betw f A (elts \<alpha>)" "\<forall>x\<in>A. \<forall>y\<in>A. f x < f y \<longleftrightarrow> (x, y) \<in> r"
>   have "ordertype A r = ordertype (elts \<alpha>) VWF"
>   proof (rule ordertype_eqI)
>     show "\<forall>x\<in>A. \<forall>y\<in>A. ((f x, f y) \<in> VWF) = ((x, y) \<in> r)"
>       by (meson Ord_in_Ord VWF_iff_Ord_less \<alpha> bij_betwE f)
>   qed (use assms f in auto)
>   then show ?lhs
>     by (simp add: \<alpha>)
> qed
> 
> corollary ordertype_VWF_eq_iff:
>   assumes "Ord \<alpha>" "small A"
>   shows "ordertype A VWF = \<alpha> \<longleftrightarrow>
>          (\<exists>f. bij_betw f A (elts \<alpha>) \<and> (\<forall>x \<in> A. \<forall>y \<in> A. f x < f y \<longleftrightarrow> (x,y) \<in> VWF))"
>   by (metis UNIV_I assms ordertype_eq_iff total_VWF total_on_def trans_VWF wf_VWF)
> 
> 
> lemma ordertype_le_Ord:
>   assumes "Ord \<alpha>" "X \<subseteq> elts \<alpha>"
>   shows "ordertype X VWF \<le> \<alpha>"
>   by (metis assms ordertype_VWF_mono ordertype_eq_Ord small_elts)
> 
> lemma ordertype_inc_le_Ord:
>   assumes "small A" "Ord \<alpha>"
>     and \<pi>: "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (x,y) \<in> r\<rbrakk> \<Longrightarrow> \<pi> x < \<pi> y"
>     and "wf r" "total_on A r" 
>     and sub: "\<pi> ` A \<subseteq> elts \<alpha>"
>   shows "ordertype A r \<le> \<alpha>"
> proof -
>   have "\<And>x y. \<lbrakk>x\<in>A; y\<in>A; (x,y) \<in> r\<rbrakk> \<Longrightarrow> (\<pi> x, \<pi> y) \<in> VWF"
>     by (meson Ord_in_Ord VWF_iff_Ord_less \<pi> \<open>Ord \<alpha>\<close> sub image_subset_iff)
>   with assms show ?thesis
>     by (metis ordertype_inc_eq ordertype_le_Ord wf_VWF)
> qed
> 
> lemma le_ordertype_obtains_subset:
>   assumes \<alpha>: "\<beta> \<le> \<alpha>" "ordertype H VWF = \<alpha>" and "small H" "Ord \<beta>"
>   obtains G where "G \<subseteq> H" "ordertype G VWF = \<beta>" 
> proof (intro exI conjI that)
>   let ?f = "ordermap H VWF"
>   show \<ddagger>: "inv_into H ?f ` elts \<beta> \<subseteq> H"
>     unfolding image_subset_iff
>     by (metis \<alpha> inv_into_into ordermap_surj subsetD vsubsetD)
>   have "\<exists>f. bij_betw f (inv_into H ?f ` elts \<beta>) (elts \<beta>) \<and> (\<forall>x\<in>inv_into H ?f ` elts \<beta>. \<forall>y\<in>inv_into H ?f ` elts \<beta>. (f x < f y) = ((x, y) \<in> VWF))"
>   proof (intro exI conjI ballI iffI)
>     show "bij_betw ?f (inv_into H ?f ` elts \<beta>) (elts \<beta>)"
>       using ordermap_bij [OF wf_VWF total_on_VWF \<open>small H\<close>] \<alpha> 
>       by (metis bij_betw_inv_into_RIGHT bij_betw_subset less_eq_V_def \<ddagger>)
>   next
>     fix x y
>     assume x: "x \<in> inv_into H ?f ` elts \<beta>"
>         and y: "y \<in> inv_into H ?f ` elts \<beta>"
>     show "?f x < ?f y" if "(x,y) \<in> VWF"
>       using that \<ddagger> \<open>small H\<close> in_mono ordermap_mono_less x y by fastforce
>     show "(x,y) \<in> VWF" if "?f x < ?f y"
>       using that \<ddagger> \<open>small H\<close> in_mono ordermap_mono_less [OF _ wf_VWF trans_VWF] x y
>       by (metis UNIV_I less_imp_not_less total_VWF total_on_def)
>   qed
>   then show "ordertype (inv_into H ?f ` elts \<beta>) VWF = \<beta>"
>     by (subst ordertype_eq_iff) (use assms in auto)
> qed
> 
> lemma ordertype_infinite_\<omega>:
>   assumes "A \<subseteq> elts \<omega>" "infinite A"
>   shows "ordertype A VWF = \<omega>"
> proof (rule antisym)
>   show "ordertype A VWF \<le> \<omega>"
>     by (simp add: assms ordertype_le_Ord)
>   show "\<omega> \<le> ordertype A VWF"
>     using assms down ordertype_infinite_ge_\<omega> by auto
> qed
> 
> 
> proposition ordertype_eq_ordertype:
>   assumes r: "wf r" "total_on A r" "trans r" and "small A"
>   assumes s: "wf s" "total_on B s" "trans s" and "small B"
>   shows "ordertype A r = ordertype B s \<longleftrightarrow>
>          (\<exists>f. bij_betw f A B \<and> (\<forall>x \<in> A. \<forall>y \<in> A. (f x, f y) \<in> s \<longleftrightarrow> (x,y) \<in> r))"
>     (is "?lhs = ?rhs")
> proof
>   assume L: ?lhs
>   define \<gamma> where "\<gamma> = ordertype A r"
>   have A: "bij_betw (ordermap A r) A (ordermap A r ` A)"
>     by (meson ordermap_bij assms(4) bij_betw_def r)
>   have B: "bij_betw (ordermap B s) B (ordermap B s ` B)"
>     by (meson ordermap_bij assms(8) bij_betw_def s)
> 
>   define f where "f \<equiv> inv_into B (ordermap B s) o ordermap A r"
>   show ?rhs
>   proof (intro exI conjI)
>     have bijA: "bij_betw (ordermap A r) A (elts \<gamma>)"
>       unfolding \<gamma>_def using ordermap_bij \<open>small A\<close> r by blast
>     moreover have bijB: "bij_betw (ordermap B s) B (elts \<gamma>)"
>       by (simp add: L \<gamma>_def ordermap_bij \<open>small B\<close> s)
>     ultimately show bij: "bij_betw f A B"
>       unfolding f_def using bij_betw_comp_iff bij_betw_inv_into by blast
>     have invB: "\<And>\<alpha>. \<alpha> \<in> elts \<gamma> \<Longrightarrow> ordermap B s (inv_into B (ordermap B s) \<alpha>) = \<alpha>"
>       by (meson bijB bij_betw_inv_into_right)
>     have ordermap_A_\<gamma>: "\<And>a. a \<in> A \<Longrightarrow> ordermap A r a \<in> elts \<gamma>"
>       using bijA bij_betwE by auto
>     have f_in_B: "\<And>a. a \<in> A \<Longrightarrow> f a \<in> B"
>       using bij bij_betwE by fastforce
>     show "\<forall>x\<in>A. \<forall>y\<in>A. (f x, f y) \<in> s \<longleftrightarrow> (x, y) \<in> r"
>     proof (intro iffI ballI)
>       fix x y
>       assume "x \<in> A" "y \<in> A" and ins: "(f x, f y) \<in> s"
>       then have "ordermap A r x < ordermap A r y"
>         unfolding o_def 
>         by (metis (mono_tags, lifting) f_def \<open>small B\<close> comp_apply f_in_B invB ordermap_A_\<gamma> ordermap_mono_less s(1) s(3))
>       then show "(x, y) \<in> r"
>         by (metis \<open>x \<in> A\<close> \<open>y \<in> A\<close> \<open>small A\<close> order.asym ordermap_mono_less r total_on_def)
>     next
>       fix x y
>       assume "x \<in> A" "y \<in> A" and "(x, y) \<in> r"
>       then have "ordermap A r x < ordermap A r y"
>         by (simp add: \<open>small A\<close> ordermap_mono_less r)
>       then have "(f y, f x) \<notin> s"
>         by (metis (mono_tags, lifting) \<open>x \<in> A\<close> \<open>y \<in> A\<close> \<open>small B\<close> comp_apply f_def f_in_B invB order.asym ordermap_A_\<gamma> ordermap_mono_less s(1) s(3))
>       moreover have "f y \<noteq> f x"
>         by (metis \<open>(x, y) \<in> r\<close> \<open>x \<in> A\<close> \<open>y \<in> A\<close> bij bij_betw_inv_into_left r(1) wf_not_sym)
>       ultimately show "(f x, f y) \<in> s"
>         by (meson \<open>x \<in> A\<close> \<open>y \<in> A\<close> f_in_B s(2) total_on_def)
>     qed
>   qed
> next
>   assume ?rhs
>   then show ?lhs
>     using assms ordertype_eqI  by blast
> qed
> 
> 
> lemma ordermap_insert:
>   assumes "Ord \<alpha>" and y: "Ord y" "y \<le> \<alpha>" and U: "U \<subseteq> elts \<alpha>"
>   shows "ordermap (insert \<alpha> U) VWF y = ordermap U VWF y"
>   using y
> proof (induction rule: Ord_induct)
>   case (step y)
>   then have 1: "{u \<in> U. (u, y) \<in> VWF} = elts y \<inter> U"
>     apply (simp add: set_eq_iff)
>     by (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less assms subsetD)
>   have 2: "{u \<in> insert \<alpha> U. (u, y) \<in> VWF} = elts y \<inter> U"
>     apply (simp add: set_eq_iff)
>     by (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less assms leD step.hyps step.prems subsetD)
>   show ?case
>     using step
>     apply (simp only: ordermap [OF wf_VWF, of _ y] 1 2)
>     by (meson Int_lower1 Ord_is_Transset Sup.SUP_cong Transset_def assms(1) in_mono vsubsetD)
> qed
> 
> lemma ordertype_insert:
>   assumes "Ord \<alpha>" and U: "U \<subseteq> elts \<alpha>"
>   shows "ordertype (insert \<alpha> U) VWF = succ (ordertype U VWF)"
> proof -
>   have \<dagger>: "{y \<in> insert \<alpha> U. (y, \<alpha>) \<in> VWF} = U" "{y \<in> U. (y, \<alpha>) \<in> VWF} = U"
>     using Ord_in_Ord OrdmemD assms by auto
>   have eq: "\<And>x. x \<in> U \<Longrightarrow> ordermap (insert \<alpha> U) VWF x = ordermap U VWF x"
>     by (meson Ord_in_Ord Ord_is_Transset Transset_def U assms(1) in_mono ordermap_insert)
>   have "ordertype (insert \<alpha> U) VWF =
>         ZFC_in_HOL.set (insert (ordermap U VWF \<alpha>) (ordermap U VWF ` U))"
>     by (simp add: ordertype_def ordermap_insert assms eq)
>   also have "\<dots> = succ (ZFC_in_HOL.set (ordermap U VWF ` U))"
>     using "\<dagger>" U by (simp add: ordermap [OF wf_VWF, of _ \<alpha>] down succ_def vinsert_def)
>   also have "\<dots> = succ (ordertype U VWF)"
>     by (simp add: ordertype_def)
>   finally show ?thesis .
> qed
> 
> lemma finite_ordertype_le_card:
>   assumes "finite A" "wf r" "trans r" 
>   shows "ordertype A r \<le> ord_of_nat (card A)"
> proof -
>   have "Ord (ordertype A r)"
>     by (simp add: wf_Ord_ordertype assms)
>   moreover have "ordermap A r ` A = elts (ordertype A r)"
>     by (simp add: ordertype_def finite_imp_small \<open>finite A\<close>)
>   moreover have "card (ordermap A r ` A) \<le> card A"
>     using \<open>finite A\<close> card_image_le by blast
>   ultimately show ?thesis
>     by (metis Ord_linear_le Ord_ord_of_nat \<open>finite A\<close> card_ord_of_nat card_seteq finite_imageI less_eq_V_def)
> qed
> 
> lemma ordertype_VWF_\<omega>:
>   assumes "finite A"
>   shows "ordertype A VWF \<in> elts \<omega>"
> proof -
>   have "finite (ordermap A VWF ` A)"
>     using assms by blast
>   then have "ordertype A VWF < \<omega>"
>     by (meson Ord_\<omega> OrdmemD trans_VWF wf_VWF assms finite_ordertype_le_card le_less_trans ord_of_nat_\<omega>)
>   then show ?thesis
>     by (simp add: Ord_mem_iff_lt)
> qed
> 
> lemma ordertype_VWF_finite_nat:
>   assumes "finite A"
>   shows "ordertype A VWF = ord_of_nat (card A)"
>   by (metis finite_imp_small ordermap_bij total_on_VWF wf_VWF \<omega>_def assms bij_betw_same_card card_ord_of_nat elts_of_set f_inv_into_f inf ordertype_VWF_\<omega>)
> 
> lemma finite_ordertype_eq_card:
>   assumes "small A" "wf r" "trans r" "total_on A r"
>   shows "ordertype A r = ord_of_nat m \<longleftrightarrow> finite A \<and> card A = m"
>   using ordermap_bij [OF \<open>wf r\<close>]
> proof -
>   have *: "bij_betw (ordermap A r) A (elts (ordertype A r))"
>     by (simp add: assms ordermap_bij)
>   moreover have "card (ordermap A r ` A) = card A"
>     by (meson bij_betw_def * card_image)
>   ultimately show ?thesis
>     using assms bij_betw_finite bij_betw_imp_surj_on finite_Ord_omega ordertype_VWF_finite_nat wf_Ord_ordertype by fastforce
> qed
> 
> 
> lemma ex_bij_betw_strict_mono_card:
>   assumes "finite M" "M \<subseteq> ON"
>   obtains h where "bij_betw h {..<card M} M" and "strict_mono_on h {..<card M}"
> proof -
>   have bij: "bij_betw (ordermap M VWF) M (elts (card M))"
>     using Finite_V \<open>finite M\<close> ordermap_bij ordertype_VWF_finite_nat by fastforce
>   let ?h = "(inv_into M (ordermap M VWF)) \<circ> ord_of_nat"
>   show thesis
>   proof
>     show bijh: "bij_betw ?h {..<card M} M"
>     proof (rule bij_betw_trans)
>       show "bij_betw ord_of_nat {..<card M} (elts (card M))"
>         by (simp add: bij_betw_def elts_ord_of_nat inj_on_def)
>       show "bij_betw (inv_into M (ordermap M VWF)) (elts (card M)) M"
>         using Finite_V assms bij_betw_inv_into ordermap_bij ordertype_VWF_finite_nat by fastforce
>     qed
>     show "strict_mono_on ?h {..<card M}"
>     proof -
>       have "?h m < ?h n"
>         if "m < n" "n < card M" for m n
>       proof (rule ccontr)
>         obtain mn: "m \<in> elts (ordertype M VWF)" "n \<in> elts (ordertype M VWF)"
>           using \<open>m < n\<close> \<open>n < card M\<close> \<open>finite M\<close> ordertype_VWF_finite_nat by auto
>         have ord: "Ord (?h m)" "Ord (?h n)"
>           using bijh assms(2) bij_betwE that by fastforce+
>         moreover
>         assume "\<not> ?h m < ?h n"
>         ultimately consider "?h m = ?h n" | "?h m > ?h n"
>           using Ord_linear_lt by blast
>         then show False
>         proof cases
>           case 1
>           then have "m = n"
>             by (metis inv_ordermap_mono_eq mn comp_apply ord_of_nat_inject)
>           with \<open>m < n\<close> show False by blast 
>         next
>           case 2
>           then have "ord_of_nat n \<le> ord_of_nat m"
>             by (metis Finite_V mn assms comp_def inv_ordermap_VWF_mono_le less_imp_le)
>           then show ?thesis
>             using leD \<open>m < n\<close> by blast
>         qed
>       qed
>       with assms show ?thesis
>         by (auto simp: strict_mono_on_def)
>     qed
>   qed
> qed
> 
834c1604
<     using Ord_ordertype ordertype_eqpoll by force
---
>     using Ord_ordertype ordertype_eqpoll by blast
844a1615,1619
> lemma inj_into_vcard:
>   obtains f where "f \<in> elts A \<rightarrow> elts (vcard A)" "inj_on f (elts A)"
>   using cardinal_eqpoll [of A] inj_on_the_inv_into the_inv_into_onto
>   by (fastforce simp: Pi_iff bij_betw_def eqpoll_def)
> 
899a1675,1682
> lemma Card_\<omega> [iff]: "Card \<omega>"
> proof -
>   have "\<And>\<alpha> f. \<lbrakk>\<alpha> \<in> elts \<omega>; bij_betw f (elts \<alpha>) (elts \<omega>)\<rbrakk> \<Longrightarrow> False"
>   using bij_betw_finite finite_Ord_omega infinite_\<omega> by blast
>   then show ?thesis
>     by (meson CardI Ord_\<omega> Ord_mem_iff_lt eqpoll_def)
> qed
> 
926a1710,1712
> lemma cardinal_le_lepoll: "vcard A \<le> \<alpha> \<Longrightarrow> elts A \<lesssim> elts \<alpha>"
>   by (meson cardinal_eqpoll eqpoll_sym lepoll_trans1 less_eq_V_def subset_imp_lepoll)
> 
930a1717,1745
> 
> lemma Card_Union [simp,intro]:
>   assumes A: "\<And>x. x \<in> A \<Longrightarrow> Card(x)" shows "Card(\<Squnion>A)"
> proof (rule CardI)
>   show "Ord(\<Squnion>A)" using A
>     by (simp add: Card_is_Ord Ord_Sup)
> next
>   fix j
>   assume j: "j < \<Squnion>A" "Ord j"
>   hence "\<exists>c\<in>A. j < c \<and> Card(c)" using A
>     by (meson Card_is_Ord Ord_linear2 ZFC_in_HOL.Sup_least leD)
>   then obtain c where c: "c\<in>A" "j < c" "Card(c)"
>     by blast
>   hence jls: "elts j \<prec> elts c"
>     using j(2) lt_Card_imp_lesspoll by blast
>   { assume eqp: "elts j \<approx> elts (\<Squnion>A)"
>     have  "elts c \<lesssim> elts (\<Squnion>A)" using c
>       using Sup_V_def ZFC_in_HOL.Sup_upper j(1) less_eq_V_def subset_imp_lepoll by fastforce
>     also have "... \<approx> elts j"  by (rule eqpoll_sym [OF eqp])
>     also have "... \<prec> elts c"  by (rule jls)
>     finally have "elts c \<prec> elts c" .
>     hence False
>       by auto
>   } thus "\<not> elts j \<approx> elts (\<Squnion>A)" by blast
> qed
> 
> lemma Card_UN: "(\<And>x. x \<in> A \<Longrightarrow> Card(K x)) ==> Card(Sup (K ` A))"
>   by blast
> 
1115,1116c1930
<     unfolding one_V_def cmult_def
<     using Card_def assms cardinal_cong by auto
---
>     by (metis Card_def assms cardinal_cong cmult_def elts_1 set_of_elts)
1234c2048
< lemma "vcard A < vcard (VPow A)"
---
> lemma less_vcard_VPow: "vcard A < vcard (VPow A)"
1253,1260d2066
< lemma csucc_works:
<   assumes "Card \<kappa>" shows "Card (csucc \<kappa>) \<and> \<kappa> < csucc \<kappa>"
<   unfolding csucc_def
<   proof (rule Ord_LeastI2)
<   show "Card (vcard (VPow \<kappa>)) \<and> \<kappa> < (vcard (VPow \<kappa>))"
<     using Card_def assms greater_Card by auto
< qed auto
< 
1263,1264c2069,2079
<   shows Card_csucc [simp]: "Card (csucc \<kappa>)" and less_csucc: "\<kappa> < csucc \<kappa>"
<   using csucc_works [OF assms] by auto
---
>   shows Card_csucc [simp]: "Card (csucc \<kappa>)" and less_csucc [simp]: "\<kappa> < csucc \<kappa>"
> proof -
>   have "Card (csucc \<kappa>) \<and> \<kappa> < csucc \<kappa>"
>     unfolding csucc_def
>   proof (rule Ord_LeastI2)
>     show "Card (vcard (VPow \<kappa>)) \<and> \<kappa> < (vcard (VPow \<kappa>))"
>       using Card_def assms greater_Card by auto
>   qed auto
>   then show "Card (csucc \<kappa>)" "\<kappa> < csucc \<kappa>"
>     by auto
> qed
1290c2105
<   assumes FA: "finite(A)" and a: "a \<notin> A"
---
>   assumes FA: "finite A" and a: "a \<notin> A"
1296,1298c2111,2116
<     show "Ord (vcard (set (insert a A))) \<and> Card (vcard (set (insert a A))) \<and> vcard (set A) < vcard (set (insert a A))"
<       apply (auto simp: Card_def)
<       by (metis FA Finite finite_insert_lepoll FA a elts_of_set eqpoll_imp_lepoll eqpoll_sym lesspoll_def lesspoll_imp_Card_less small_insert subset_imp_lepoll subset_insertI)
---
>     have "small A"
>       by (simp add: FA Finite_V)
>     then have "\<not> elts (set A) \<approx> elts (set (insert a A))"
>       using FA a eqpoll_imp_lepoll eqpoll_sym finite_insert_lepoll by fastforce
>     then show "Ord (vcard (set (insert a A))) \<and> Card (vcard (set (insert a A))) \<and> vcard (set A) < vcard (set (insert a A))"
>       by (simp add: Card_def lesspoll_imp_Card_less lesspoll_def subset_imp_lepoll subset_insertI)
1303c2121
<         by (metis FA Finite cardinal_eqpoll elts_of_set)
---
>         by (metis FA finite_imp_small cardinal_eqpoll elts_of_set)
1431a2250,2368
> 
> 
> subsection \<open>The Aleph-seqence\<close>
> 
> text \<open>This is the well-known transfinite enumeration of the cardinal numbers.\<close>
> 
> definition
>   Aleph :: "V \<Rightarrow> V"   (\<open>\<aleph>_\<close> [90] 90) 
>   where "Aleph \<equiv> transrec3 \<omega> (\<lambda>x r. csucc(r)) (\<lambda>i r . \<Squnion> (r ` elts i))"
> 
> lemma Card_Aleph [simp, intro]:
>      "Ord \<alpha> \<Longrightarrow> Card(Aleph \<alpha>)"
> by (induction \<alpha> rule: Ord_induct3) (auto simp: Aleph_def)
> 
> lemma Aleph_0 [simp]: "\<aleph>0 = \<omega>"
>   by (simp add: Aleph_def)
> 
> lemma Aleph_succ [simp]: "\<aleph>(succ x) = csucc (\<aleph> x)"
>   by (simp add: Aleph_def)
> 
> lemma Aleph_Limit: "Limit \<gamma> \<Longrightarrow> \<aleph> \<gamma> = \<Squnion> (Aleph ` elts \<gamma>)"
>   by (simp add: Aleph_def)
> 
> lemma mem_Aleph_succ: "Ord \<alpha> \<Longrightarrow> \<aleph>(\<alpha>) \<in> elts (\<aleph>(succ \<alpha>))"
>   by (simp add: Card_is_Ord Ord_mem_iff_lt)
> 
> lemma Aleph_increasing:
>   assumes ab: "\<alpha> < \<beta>" "Ord \<alpha>" "Ord \<beta>" shows "Aleph(\<alpha>) < Aleph(\<beta>)"
> proof -
>   { fix x
>     have "\<lbrakk>Ord x; x \<in> elts \<beta>\<rbrakk> \<Longrightarrow> Aleph(x) \<in> elts (Aleph \<beta>)"
>       using \<open>Ord \<beta>\<close>
>     proof (induct \<beta> arbitrary: x rule: Ord_induct3)
>       case 0 thus ?case by simp
>     next
>       case (succ \<beta>)
>       then consider "x = \<beta>" |"x \<in> elts \<beta>"
>         using OrdmemD by auto
>       then show ?case
>       proof cases
>         case 1
>         then show ?thesis
>           by (simp add: Card_is_Ord Ord_mem_iff_lt succ.hyps(1))
>       next
>         case 2
>         with succ show ?thesis
>           by (metis Aleph_succ Card_Aleph le_csucc vsubsetD)
>       qed
>     next
>       case (Limit \<gamma>)
>       hence sc: "succ x \<in> elts \<gamma>"
>         by (simp add: Limit_def Ord_mem_iff_lt)
>       hence "\<aleph> x \<in> elts (\<Squnion> (Aleph ` elts \<gamma>))" 
>         using Limit
>         by blast
>       thus ?case using Limit
>         by (simp add: Aleph_Limit)
>     qed
>   } thus ?thesis using ab
>     by (simp add: Card_is_Ord Ord_mem_iff_lt)
> qed
> 
> lemma countable_iff_le_Aleph0: "countable (elts A) \<longleftrightarrow> vcard A \<le> \<aleph>0"
> proof
>   show "vcard A \<le> \<aleph>0"
>     if "countable (elts A)"
>   proof (cases "finite (elts A)")
>     case True
>     then show ?thesis
>       using vcard_finite_set by fastforce
>   next
>     case False
>     then have "elts \<omega> \<approx> elts A"
>       using countableE_infinite [OF that]     
>       by (simp add: eqpoll_def \<omega>_def) (meson bij_betw_def bij_betw_inv bij_betw_trans inj_ord_of_nat)
>     then show ?thesis
>       using Card_\<omega> Card_def cardinal_cong vcard_def by auto
>   qed
>   show "countable (elts A)"
>     if "vcard A \<le> \<aleph>0"
>   proof -
>     have "elts A \<lesssim> elts \<omega>"
>       using cardinal_le_lepoll [OF that] by simp
>     then show ?thesis
>       by (simp add: countable_iff_lepoll \<omega>_def inj_ord_of_nat)
>   qed
> qed
> 
> subsection \<open>The ordinal @{term "\<omega>1"}\<close>
> 
> abbreviation "\<omega>1 \<equiv> Aleph 1"
> 
> lemma Ord_\<omega>1 [simp]: "Ord \<omega>1"
>   by (simp add: Card_is_Ord)
> 
> lemma omega_\<omega>1 [iff]: "\<omega> \<in> elts \<omega>1"
>   using mem_Aleph_succ one_V_def by fastforce
> 
> lemma ord_of_nat_\<omega>1 [iff]: "ord_of_nat n \<in> elts \<omega>1"
>   using Ord_\<omega>1 Ord_trans by blast
> 
> lemma countable_iff_less_\<omega>1:
>   assumes "Ord \<alpha>"
>   shows "countable (elts \<alpha>) \<longleftrightarrow> \<alpha> < \<omega>1"
>   by (simp add: assms countable_iff_le_Aleph0 lt_csucc_iff one_V_def)
> 
> lemma less_\<omega>1_imp_countable:
>   assumes "\<alpha> \<in> elts \<omega>1"
>   shows "countable (elts \<alpha>)"
>   using Ord_\<omega>1 Ord_in_Ord OrdmemD assms countable_iff_less_\<omega>1 by blast
> 
> lemma \<omega>1_gt0 [simp]: "\<omega>1 > 0"
>   using Ord_\<omega>1 Ord_trans OrdmemD by blast
> 
> lemma \<omega>1_gt1 [simp]: "\<omega>1 > 1"
>   using Ord_\<omega>1 OrdmemD \<omega>_gt1 less_trans by blast
> 
> lemma Limit_\<omega>1 [simp]: "Limit \<omega>1"
>   by (simp add: InfCard_def InfCard_is_Limit le_csucc one_V_def)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/ZFC_in_HOL/ZFC_in_HOL.thy ../../AFPs/afp-2020/thys/ZFC_in_HOL/ZFC_in_HOL.thy
30,34c30,34
< definition   "small X \<equiv> (X \<in> range elts)"
< text\<open>Remark: the alternative is to make this an abbreviation.
< However, then reasoning about @{term small} would invariably
< reduce to reasoning about certain (unknown) sets containing
< the elements in question. Instead we regard smallness as a primitive concept.\<close>
---
> lemma mem_not_refl [simp]: "i \<notin> elts i"
>   using wf_not_refl [OF foundation] by force
> 
> lemma mem_not_sym: "\<not> (x \<in> elts y \<and> y \<in> elts x)"
>   using wf_not_sym [OF foundation] by force
35a36,45
> text \<open>A set is small if it can be injected into the extension of a V-set.\<close>
> definition small :: "'a set \<Rightarrow> bool" 
>   where "small X \<equiv> \<exists>V_of :: 'a \<Rightarrow> V. inj_on V_of X \<and> V_of ` X \<in> range elts"
> 
> lemma small_empty [iff]: "small {}"
>   by (simp add: small_def down_raw)
> 
> lemma small_iff_range: "small X \<longleftrightarrow> X \<in> range elts"
>   apply (simp add: small_def)
>   by (metis inj_on_id2 replacement_raw the_inv_into_onto)
41c51
<   by (simp add: ext set_def f_inv_into_f small_def)
---
>   by (force simp add: ext set_def f_inv_into_f small_def)
44c54
<   by (metis set_def bot.extremum down_raw f_inv_into_f small_def)
---
>   by (simp add: ZFC_in_HOL.set_def down_raw f_inv_into_f small_iff_range)
47c57
<   by (simp add: down_raw small_def)
---
>   by (simp add: down_raw small_iff_range)
50c60
<   by (simp add: Union_raw small_def)
---
>   by (simp add: Union_raw small_iff_range)
53c63
<   unfolding small_def using Pow_raw set_def down by force
---
>   unfolding small_iff_range using Pow_raw set_def down by force
55,56c65,96
< lemma replacement [intro,simp]: "small X \<Longrightarrow> small (f ` X)"
<   by (simp add: replacement_raw small_def)
---
> declare replacement_raw [intro,simp]
> 
> lemma replacement [intro,simp]:
>   assumes "small X"
>   shows "small (f ` X)" 
> proof -
>   let ?A = "inv_into X f ` (f ` X)"
>   have AX: "?A \<subseteq> X"
>     by (simp add: image_subsetI inv_into_into)
>   have inj: "inj_on f ?A"
>     by (simp add: f_inv_into_f inj_on_def)
>   have injo: "inj_on (inv_into X f) (f ` X)"
>     using inj_on_inv_into by blast
>   have "\<exists>V_of. inj_on V_of (f ` X) \<and> V_of ` f ` X \<in> range elts"
>     if "inj_on V_of X" and "V_of ` X = elts x"
>     for V_of :: "'a \<Rightarrow> V" and x
>   proof (intro exI conjI)
>     show "inj_on (V_of \<circ> inv_into X f) (f ` X)"
>       by (meson \<open>inv_into X f ` f ` X \<subseteq> X\<close> comp_inj_on inj_on_subset injo that)
>     have "(\<lambda>x. V_of (inv_into X f (f x))) ` X = elts (set (V_of ` ?A))"
>       by (metis AX down elts_of_set image_image image_mono that(2))
>     then show "(V_of \<circ> inv_into X f) ` f ` X \<in> range elts"
>       by (metis image_comp image_image rangeI)
>   qed
>   then show ?thesis
>     using assms by (auto simp: small_def)
> qed
> 
> lemma small_image_iff [simp]: "inj_on f A \<Longrightarrow> small (f ` A) \<longleftrightarrow> small A"
>   by (metis replacement the_inv_into_onto)
> 
> text \<open>A little bootstrapping is needed to characterise @{term small} for sets of arbitrary type.\<close>
59c99
<   by (simp add: inf_raw small_def)
---
>   by (simp add: inf_raw small_iff_range)
61c101
< lemma inf' [simp]: "small (g ` N)" for N :: "nat set"
---
> lemma small_image_nat_V [simp]: "small (g ` N)" for g :: "nat \<Rightarrow> V"
64c104,125
< lemma UN [intro]:
---
> lemma Finite_V:
>   fixes X :: "V set"
>   assumes "finite X" shows "small X"
>   using ex_bij_betw_nat_finite [OF assms] unfolding bij_betw_def by (metis small_image_nat_V)
> 
> lemma small_insert_V:
>   fixes X :: "V set"
>   assumes "small X"
>   shows "small (insert a X)"
> proof (cases "finite X")
>   case True
>   then show ?thesis
>     by (simp add: Finite_V)
> next
>   case False
>   show ?thesis
>     using infinite_imp_bij_betw2 [OF False]
>     by (metis replacement Un_insert_right assms bij_betw_imp_surj_on sup_bot.right_neutral)
> qed
> 
> lemma small_UN_V [simp,intro]:
>   fixes B :: "'a \<Rightarrow> V set"
68c129
<   have "(\<Union> (elts ` (\<lambda>x. set (B x)) ` X)) = (\<Union> (B ` X))"
---
>   have "(\<Union> (elts ` (\<lambda>x. ZFC_in_HOL.set (B x)) ` X)) = (\<Union> (B ` X))"
71c132
<     using Union [OF replacement [OF X, of "\<lambda>x. set (B x)"]] by simp
---
>     using Union [OF replacement [OF X, of "\<lambda>x. ZFC_in_HOL.set (B x)"]] by simp
72a134,135
>  
> definition vinsert where "vinsert x y \<equiv> set (insert x (elts y))"
74,76c137,138
< lemma countable:
<   assumes "countable X" shows "small X"
<   by (metis down elts_of_set subset_range_from_nat_into inf assms)
---
> lemma elts_vinsert [simp]: "elts (vinsert x y) = insert x (elts y)"
>   using down small_insert_V vinsert_def by auto
78c140,145
< lemma Finite:
---
> definition succ where "succ x \<equiv> vinsert x x"
> 
> lemma elts_succ [simp]: "elts (succ x) = insert x (elts x)"
>   by (simp add: succ_def)
> 
> lemma finite_imp_small:
80,83c147,151
< proof (cases "X = {}")
<   case True
<   then show ?thesis
<     by (simp add: down)
---
>   using assms
> proof induction
>   case empty
>   then show ?case
>     by simp
85,93c153,167
<   case False
<   then have "card X > 0"
<     using assms card_gt_0_iff by blast
<   moreover obtain h where "bij_betw h {0..<card X} X"
<     using assms ex_bij_betw_nat_finite by blast
<   ultimately have "range (\<lambda>k. if k < card X then h k else h 0) = X"
<     by (auto simp: image_def bij_betw_def set_eq_iff atLeast0LessThan)
<   then show ?thesis
<     using inf by metis
---
>   case (insert a X)
>   then obtain V_of u where u: "inj_on V_of X" "V_of ` X = elts u"
>     by (meson small_def image_iff)
>   show ?case
>     unfolding small_def
>   proof (intro exI conjI)
>     show "inj_on (V_of(a:=u)) (insert a X)"
>       using u
>       apply (clarsimp simp add: inj_on_def)
>       by (metis image_eqI mem_not_refl)
>     have "(V_of(a:=u)) ` insert a X = elts (vinsert u u)"
>       using insert.hyps(2) u(2) by auto
>     then show "(V_of(a:=u)) ` insert a X \<in> range elts"
>       by (blast intro:  elim: )
>   qed
96,98d169
< lemma small_empty [iff]: "small {}"
<   by (blast intro: Finite)
< 
105c176
<     by (simp add: Finite)
---
>     by (simp add: finite_imp_small)
112a184,188
> lemma smaller_than_small:
>   assumes "small A" "B \<subseteq> A" shows "small B"
>   using assms
>   by (metis down elts_of_set image_mono small_def small_iff_range subset_inj_on) 
> 
114c190
<   by (metis down elts_of_set small_insert subset_insertI)
---
>   by (meson small_insert smaller_than_small subset_insertI)
124a201,203
> lemma small_set [simp]: "small (list.set xs)"
>   by (simp add: ZFC_in_HOL.finite_imp_small)
> 
128c207
< lemma small_Un: "small (elts x \<union> elts y)"
---
> lemma small_Un_elts: "small (elts x \<union> elts y)"
134c213
< lemma big_UNIV [simp]: "\<not> small UNIV"
---
> lemma big_UNIV [simp]: "\<not> small (UNIV::V set)" (is  "\<not> small ?U")
136,137c215,216
<     assume "small UNIV"
<     then have "small A" for A
---
>     assume "small ?U"
>     then have "small A" for A :: "V set"
163c242
< lemma set_empty: "set {} = 0"
---
> lemma set_empty [simp]: "set {} = 0"
168c247
< definition one_V where "1 \<equiv> set {0}"
---
> definition one_V where "1 \<equiv> succ 0"
178a258,260
> lemma elts_eq_empty_iff [simp]: "elts x = {} \<longleftrightarrow> x=0"
>   by (auto simp: ZFC_in_HOL.ext)
> 
211,216c293,296
<   show "x \<le> x \<squnion> y" for x y :: V
<     by (simp add: less_eq_V_def small_Un sup_V_def)
<   show "y \<le> x \<squnion> y" for x y :: V
<     by (simp add: less_eq_V_def small_Un sup_V_def)
<   show "sup y z \<le> x" if "y \<le> x" "(z::V) \<le> x" for x y z :: V
<     using elts_of_set less_eq_V_def small_Un sup_V_def that by auto
---
>   show "x \<le> x \<squnion> y" "y \<le> x \<squnion> y" for x y :: V
>     by (simp_all add: less_eq_V_def small_Un_elts sup_V_def)
>   show "sup y z \<le> x" if "y \<le> x" "z \<le> x" for x y z :: V
>     using less_eq_V_def sup_V_def that by auto
222c302
<       by (simp add: Un_Int_distrib inf_V_def small_Un sup_V_def)
---
>       by (simp add: Un_Int_distrib inf_V_def small_Un_elts sup_V_def)
243a324,332
> lemma set_image_le_iff: "small A \<Longrightarrow> set (f ` A) \<le> B \<longleftrightarrow> (\<forall>x\<in>A. f x \<in> elts B)"
>   by auto
> 
> lemma eq0_iff: "x = 0 \<longleftrightarrow> (\<forall>y. y \<notin> elts x)"
>   by auto
> 
> lemma less_eq_V_0_iff [simp]: "x \<le> 0 \<longleftrightarrow> x = 0" for x::V
>   by auto
> 
248,251d336
< lemma smaller_than_small:
<     assumes "small B" "A \<le> B" shows "small A"
<   using assms subset_iff_less_eq_V by blast
< 
274a360,368
> lemma min_0L [simp]: "min 0 n = 0" for n :: V
>   by (simp add: min_absorb1)
> 
> lemma min_0R [simp]: "min n 0 = 0" for n :: V
>   by (simp add: min_absorb2)
> 
> lemma neq0_conv: "\<And>n::V. n \<noteq> 0 \<longleftrightarrow> 0 < n"
>   by (simp add: less_V_def)
> 
291,292c385,386
< lemma small_sup_iff [simp]: "small (X \<union> Y) \<longleftrightarrow> small X \<and> small Y"
<   by (metis down small_Un small_iff sup_ge1 sup_ge2)
---
> lemma small_sup_iff [simp]: "small (X \<union> Y) \<longleftrightarrow> small X \<and> small Y" for X::"V set"
>   by (metis down elts_of_set small_Un_elts sup_ge1 sup_ge2)
295c389
<   by (auto simp: sup_V_def small_Un)
---
>   by (simp add: sup_V_def)
319,320c413,414
< lemma bdd_above_iff_small [simp]: "bdd_above X = small X"
<   proof
---
> lemma bdd_above_iff_small [simp]: "bdd_above X = small X" for X::"V set"
> proof
353,354c447,448
<     apply (simp add: bdd_below_V_def Inf_V_def split: if_split_asm)
<     by (metis INF_greatest INT_lower down elts_of_set equals0I less_eq_V_def that)
---
>     apply (clarsimp simp add: bdd_below_V_def Inf_V_def less_eq_V_def split: if_split_asm)
>     by (meson INT_subset_iff down eq_refl equals0I)
362c456
< lemma Sup_upper: "\<lbrakk>x \<in> A; small A\<rbrakk> \<Longrightarrow> x \<le> \<Squnion>A"
---
> lemma Sup_upper: "\<lbrakk>x \<in> A; small A\<rbrakk> \<Longrightarrow> x \<le> \<Squnion>A" for A::"V set"
382c476
< lemma Sup_Un_distrib: "\<lbrakk>small A; small B\<rbrakk> \<Longrightarrow> \<Squnion>(A \<union> B) = \<Squnion>A \<squnion> \<Squnion>B"
---
> lemma Sup_Un_distrib: "\<lbrakk>small A; small B\<rbrakk> \<Longrightarrow> \<Squnion>(A \<union> B) = \<Squnion>A \<squnion> \<Squnion>B" for A::"V set"
394,395c488,490
<   "\<lbrakk>small (g ` B); A \<subseteq> B; \<And>x. x \<in> A \<Longrightarrow> f x \<le> g x\<rbrakk> \<Longrightarrow> \<Squnion> (f ` A) \<le> \<Squnion> (g ` B)"
<   by (rule Sup_least) fastforce
---
>   fixes f :: "'a \<Rightarrow> V set" and g :: "'a \<Rightarrow> V set"
>   shows "\<lbrakk>A \<subseteq> B; \<And>x. x \<in> A \<Longrightarrow> f x \<le> g x\<rbrakk> \<Longrightarrow> \<Squnion> (f ` A) \<le> \<Squnion> (g ` B)"
>   by (simp add: SUP_subset_mono)
398,400c493
<   apply auto
<    apply (metis Sup_V_def UN_E elts_0 elts_Sup empty_iff)
<   by (metis Sup_V_def elts_0 empty_iff)
---
>   using Sup_V_def by auto
402a496
>   fixes B :: "V \<Rightarrow> V set" and f :: "V \<Rightarrow> V"
407c501,502
<     using bdd_UN subset_iff_less_eq_V by fastforce
---
>     using bdd_UN subset_iff_less_eq_V
>     by (meson SUP_upper smaller_than_small)
418c513
< lemma Sup_subset_mono: "small B \<Longrightarrow> A \<subseteq> B \<Longrightarrow> Sup A \<le> Sup B"
---
> lemma Sup_subset_mono: "small B \<Longrightarrow> A \<subseteq> B \<Longrightarrow> Sup A \<le> Sup B" for A::"V set"
421c516
< lemma Sup_le_iff: "small S \<Longrightarrow> Sup S \<le> a \<longleftrightarrow> (\<forall>x\<in>S. x \<le> a)"
---
> lemma Sup_le_iff: "small A \<Longrightarrow> Sup A \<le> a \<longleftrightarrow> (\<forall>x\<in>A. x \<le> a)" for A::"V set"
424c519
< lemma SUP_le_iff: "small (f ` A) \<Longrightarrow> \<Squnion>(f ` A) \<le> u \<longleftrightarrow> (\<forall>x\<in>A. f x \<le> u)"
---
> lemma SUP_le_iff: "small (f ` A) \<Longrightarrow> \<Squnion>(f ` A) \<le> u \<longleftrightarrow> (\<forall>x\<in>A. f x \<le> u)" for f :: "V \<Rightarrow> V"
427c522,523
< subsection\<open>Successor function\<close>
---
> lemma Sup_eq_0_iff [simp]: "\<Squnion>A = 0 \<longleftrightarrow> A \<subseteq> {0} \<or> \<not> small A" for A :: "V set"
>   using Sup_upper by fastforce
429c525,547
< definition vinsert where "vinsert x y \<equiv> set (insert x (elts y))"
---
> lemma Sup_Union_commute:
>   fixes f :: "V \<Rightarrow> V set"
>   assumes "small A" "\<And>x. x\<in>A \<Longrightarrow> small (f x)"
>   shows "\<Squnion> (\<Union>x\<in>A. f x) = (SUP x\<in>A. \<Squnion> (f x))"
>   using assms 
>   by (force simp: subset_iff_less_eq_V intro!: antisym)
> 
> lemma Sup_eq_Sup:
>   fixes B :: "V set"
>   assumes "B \<subseteq> A" "small A" and *: "\<And>x. x \<in> A \<Longrightarrow> \<exists>y \<in> B. x \<le> y"
>   shows "Sup A = Sup B"
> proof -
>   have "small B"
>     using assms subset_iff_less_eq_V by auto
>   moreover have "\<exists>y\<in>B. u \<in> elts y"
>     if "x \<in> A" "u \<in> elts x" for u x
>     using that "*" by blast
>   moreover have "\<exists>x\<in>A. v \<in> elts x"
>     if "y \<in> B" "v \<in> elts y" for v y
>     using that \<open>B \<subseteq> A\<close> by blast
>   ultimately show ?thesis
>     using assms by auto
> qed
431,432c549
< lemma elts_vinsert [simp]: "elts (vinsert x y) = insert x (elts y)"
<   by (simp add: vinsert_def)
---
> subsection\<open>Successor function\<close>
434c551,553
< definition succ where "succ x \<equiv> vinsert x x"
---
> lemma vinsert_not_empty [simp]: "vinsert a A \<noteq> 0"
>   and empty_not_vinsert [simp]: "0 \<noteq> vinsert a A"
>   by (auto simp: vinsert_def)
436,440c555,556
< lemma elts_succ [simp]: "elts (succ x) = insert x (elts x)"
<   by (simp add: succ_def)
< 
< lemma succ_not_0 [simp]: "succ n \<noteq> 0"
<   by (metis elts_0 elts_succ empty_not_insert)
---
> lemma succ_not_0 [simp]: "succ n \<noteq> 0" and zero_not_succ [simp]: "0 \<noteq> succ n"
>   by (auto simp: succ_def)
444c560,561
< instance by intro_classes (metis elts_0 elts_succ empty_iff insert_iff one_V_def set_of_elts)
---
> instance 
>   by intro_classes (metis elts_0 elts_succ empty_iff insert_iff one_V_def set_of_elts)
447,451c564,568
< lemma mem_not_refl [simp]: "i \<notin> elts i"
<   using wf_not_refl [OF foundation] by force
< 
< lemma mem_not_sym: "\<not> (x \<in> elts y \<and> y \<in> elts x)"
<   using wf_not_sym [OF foundation] by force
---
> instantiation V :: zero_less_one
> begin
> instance 
>   by intro_classes (simp add: less_V_def)
> end
484a602,603
> subsubsection \<open>Transitive sets\<close>
> 
520a640,641
> subsubsection \<open>Zero, successor, sups\<close>
> 
546c667
<     using that small_Un sup_V_def Transset_sup by auto
---
>     using Ord_def Transset_sup assms by auto
582a704,717
> lemma ON_imp_Ord:
>   assumes "H \<subseteq> ON" "x \<in> H"
>   shows "Ord x"
>   using assms by blast
> 
> lemma elts_subset_ON: "Ord \<alpha> \<Longrightarrow> elts \<alpha> \<subseteq> ON"
>   using Ord_in_Ord by blast
> 
> lemma Transset_pred [simp]: "Transset x \<Longrightarrow> \<Squnion>(elts (succ x)) = x"
>   by (fastforce simp: Transset_def)
> 
> lemma Ord_pred [simp]: "Ord \<beta> \<Longrightarrow> \<Squnion> (insert \<beta> (elts \<beta>)) = \<beta>"
>   using Ord_def Transset_pred by auto
> 
631a767,775
> lemma Ord_Collect_lt: "Ord \<alpha> \<Longrightarrow> {\<xi>. Ord \<xi> \<and> \<xi> < \<alpha>} = elts \<alpha>"
>   by (auto simp flip: Ord_mem_iff_lt elim: Ord_in_Ord OrdmemD)
> 
> lemma Ord_not_less: "\<lbrakk>Ord x; Ord y\<rbrakk> \<Longrightarrow> \<not> x < y \<longleftrightarrow> y \<le> x"
>   by (metis (no_types) Ord_linear2 leD)
> 
> lemma Ord_not_le: "\<lbrakk>Ord x; Ord y\<rbrakk> \<Longrightarrow> \<not> x \<le> y \<longleftrightarrow> y < x"
>   by (metis (no_types) Ord_linear2 leD)
> 
634a779,791
> lemma succ_le_iff: "Ord i \<Longrightarrow> Ord j \<Longrightarrow> succ i \<le> j \<longleftrightarrow> i < j"
>   using Ord_mem_iff_lt dual_order.strict_implies_order less_eq_V_def by fastforce
> 
> lemma succ_in_Sup_Ord:
>   assumes eq: "succ \<beta> = \<Squnion>A" and "small A" "A \<subseteq> ON" "Ord \<beta>"
>   shows "succ \<beta> \<in> A"
> proof -
>   have "\<not> \<Squnion>A \<le> \<beta>"
>     using eq \<open>Ord \<beta>\<close> succ_le_iff by fastforce
>   then show ?thesis
>     using assms by (metis Ord_linear2 Sup_least Sup_upper eq_iff mem_Collect_eq subsetD succ_le_iff)
> qed
> 
637a795,814
> lemma Ord_finite_Sup: "\<lbrakk>finite A; A \<subseteq> ON; A \<noteq> {}\<rbrakk> \<Longrightarrow> \<Squnion>A \<in> A"
> proof (induction A rule: finite_induct)
>   case (insert x A)
>   then have *: "small A" "A \<subseteq> ON" "Ord x"
>     by (auto simp add: ZFC_in_HOL.finite_imp_small insert.hyps)
>   show ?case
>   proof (cases "A = {}")
>     case False
>     then have "\<Squnion>A \<in> A"
>       using insert by blast
>     then have "\<Squnion>A \<le> x" if "x \<squnion> \<Squnion>A \<notin> A"
>       using * by (metis ON_imp_Ord Ord_linear_le sup.absorb2 that)
>     then show ?thesis
>       by (fastforce simp: \<open>small A\<close> Sup_V_insert)
>   qed auto
> qed auto
> 
> 
> subsubsection \<open>The natural numbers\<close>
> 
647a825,827
> lemma elts_ord_of_nat: "elts (ord_of_nat k) = ord_of_nat ` {..<k}"
>   by auto
> 
655c835
<   by (metis Ord_ord_of_nat elts_of_set image_comp inf'  ord_of_nat_eq_initial Ord_equality)
---
>   by (metis Ord_equality Ord_ord_of_nat elts_of_set image_comp small_image_nat_V ord_of_nat_eq_initial)
658a839,841
> lemma elts_\<omega>: "elts \<omega> = {\<alpha>. \<exists>n. \<alpha> = ord_of_nat n}"
>   by (auto simp: \<omega>_def image_iff)
> 
669c852
<   by (metis (no_types) Ord_\<omega> \<omega>_def elts_0 elts_of_set empty_iff inf' mem_0_Ord rangeI)
---
>   by (metis \<omega>_def elts_of_set inf ord_of_nat.simps(1) rangeI)
672c855
<   by (metis \<omega>_def elts_of_set image_iff inf' ord_of_nat.simps(2) rangeI)
---
>   by (metis \<omega>_def elts_of_set image_iff small_image_nat_V ord_of_nat.simps(2) rangeI)
678c861
<   by (metis Ord_\<omega> Ord_def Transset_def \<omega>_def elts_of_set inf' rangeI)
---
>   by (metis Sup_\<omega> ZFC_in_HOL.Sup_upper \<omega>_def elts_of_set inf rangeI)
694a878,900
> corollary countable:
>   assumes "countable X" shows "small X"
> proof -
>   have "X \<subseteq> range (from_nat_into X)"
>     by (simp add: assms subset_range_from_nat_into)
>   then show ?thesis
>     by (meson inf_raw inj_ord_of_nat replacement small_def smaller_than_small)
> qed
> 
> corollary infinite_\<omega>: "infinite (elts \<omega>)"
>   using range_inj_infinite [of ord_of_nat]
>   by (simp add: \<omega>_def inj_ord_of_nat)
> 
> corollary ord_of_nat_mono_iff [iff]: "ord_of_nat i \<le> ord_of_nat j \<longleftrightarrow> i \<le> j"
>   by (metis Ord_def Ord_ord_of_nat Transset_def eq_iff mem_ord_of_nat_iff not_less ord_of_nat_inject)
> 
> corollary ord_of_nat_strict_mono_iff [iff]: "ord_of_nat i < ord_of_nat j \<longleftrightarrow> i < j"
>   by (simp add: less_le_not_le)
> 
> lemma small_image_nat [simp]:
>   fixes N :: "nat set" shows "small (g ` N)"
>   by (simp add: countable)
> 
706a913,927
> lemma card_ord_of_nat [simp]: "card (elts (ord_of_nat m)) = m"
>   by (induction m) (auto simp: \<omega>_def finite_Ord_omega)
> 
> lemma ord_of_nat_\<omega> [iff]:"ord_of_nat n \<in> elts \<omega>"
>   by (simp add: \<omega>_def)
> 
> lemma succ_\<omega>_iff [iff]: "succ n \<in> elts \<omega> \<longleftrightarrow> n \<in> elts \<omega>"
>   by (metis Ord_\<omega> OrdmemD elts_vinsert insert_iff less_V_def succ_def succ_in_omega vsubsetD)
> 
> lemma \<omega>_gt0: "\<omega> > 0"
>   by (simp add: OrdmemD)
> 
> lemma \<omega>_gt1: "\<omega> > 1"
>   by (simp add: OrdmemD one_V_def)
> 
717a939,943
> lemma Limit_is_Ord: "Limit \<xi> \<Longrightarrow> Ord \<xi>"
>   by (simp add: Limit_def)
> 
> lemma succ_in_Limit_iff: "Limit \<xi> \<Longrightarrow> succ \<alpha> \<in> elts \<xi> \<longleftrightarrow> \<alpha> \<in> elts \<xi>"
>   by (metis Limit_def OrdmemD elts_succ insertI1 less_V_def vsubsetD)
719c945
< lemma Limit_eq_Sup_self: "Limit i \<Longrightarrow> i = Sup (elts i)"
---
> lemma Limit_eq_Sup_self [simp]: "Limit i \<Longrightarrow> Sup (elts i) = i"
721,722c947,960
<   apply (metis Limit_def Ord_equality Sup_V_def SUP_le_iff Sup_upper small_elts)
<   by (simp add: Limit_def Ord_def Transset_def Sup_least)
---
>   apply (simp add: Limit_def Ord_def Transset_def Sup_least)
>   by (metis Limit_def Ord_equality Sup_V_def SUP_le_iff Sup_upper small_elts)
> 
> lemma zero_less_Limit: "Limit \<beta> \<Longrightarrow> 0 < \<beta>"
>   by (simp add: Limit_def OrdmemD)
> 
> lemma non_Limit_ord_of_nat [iff]: "\<not> Limit (ord_of_nat m)"
>   by (metis Limit_def mem_ord_of_nat_iff not_succ_Limit ord_of_eq_0_iff ord_of_minus_1)
> 
> lemma Limit_omega [iff]: "Limit \<omega>"
>   by (simp add: Limit_def)
> 
> lemma omega_nonzero [simp]: "\<omega> \<noteq> 0"
>   using Limit_omega by fastforce
745,752c983,991
<   assumes k: "Ord k"
<       and P: "P 0" "\<And>k. \<lbrakk>Ord k; P k\<rbrakk> \<Longrightarrow> P (succ k)"
<              "\<And>k. \<lbrakk>Limit k; \<And>j. j \<in> elts k \<Longrightarrow> P j\<rbrakk> \<Longrightarrow> P k"
<   shows "P k"
< using k
< proof (induction k rule: Ord_induct)
<   case (step k) thus ?case
<     by (metis P Ord_cases Ord_linear succ_ne_self succ_notin_self)
---
>   assumes \<alpha>: "Ord \<alpha>"
>     and P: "P 0" "\<And>\<alpha>. \<lbrakk>Ord \<alpha>; P \<alpha>\<rbrakk> \<Longrightarrow> P (succ \<alpha>)"
>            "\<And>\<alpha>. \<lbrakk>Limit \<alpha>; \<And>\<xi>. \<xi> \<in> elts \<alpha> \<Longrightarrow> P \<xi>\<rbrakk> \<Longrightarrow> P (SUP \<xi> \<in> elts \<alpha>. \<xi>)"
>   shows "P \<alpha>"
>   using \<alpha>
> proof (induction \<alpha> rule: Ord_induct)
>   case (step \<alpha>)
>   then show ?case
>     by (metis Limit_eq_Sup_self Ord_cases P elts_succ image_ident insertI1)
755,757d993
< lemma small_UN [simp,intro]: "\<lbrakk>small A; \<And>x. x \<in> A \<Longrightarrow> small (B x)\<rbrakk> \<Longrightarrow> small (\<Union>x\<in>A. B x)"
<   by auto
< 
759a996
> 
847a1085,1116
> qed
> 
> lemma Ord_mono_imp_increasing:
>   assumes fun_hD: "h \<in> D \<rightarrow> D"
>     and mono_h: "strict_mono_on h D" 
>     and "D \<subseteq> ON" and \<nu>: "\<nu> \<in> D"
>   shows "\<nu> \<le> h \<nu>"
> proof (rule ccontr)
>   assume non: "\<not> \<nu> \<le> h \<nu>"
>   define \<mu> where "\<mu> \<equiv> LEAST \<mu>. Ord \<mu> \<and> \<not> \<mu> \<le> h \<mu> \<and> \<mu> \<in> D"
>   have "Ord \<nu>"
>     using \<nu> \<open>D \<subseteq> ON\<close> by blast
>   then have \<mu>: "\<not> \<mu> \<le> h \<mu> \<and> \<mu> \<in> D"
>     unfolding \<mu>_def by (rule Ord_LeastI) (simp add: \<nu> non)
>   have "Ord (h \<nu>)"
>     using assms by auto
>   then have "Ord (h (h \<nu>))"
>     by (meson ON_imp_Ord \<nu> assms funcset_mem)
>   have "Ord \<mu>"
>     using \<mu> \<open>D \<subseteq> ON\<close> by blast
>   then have "h \<mu> < \<mu>"
>     by (metis ON_imp_Ord Ord_linear2 PiE \<mu> \<open>D \<subseteq> ON\<close> fun_hD)
>   then have "\<not> h \<mu> \<le> h (h \<mu>)"
>     using \<mu> fun_hD mono_h by (force simp: strict_mono_on_def)
>   moreover have *: "h \<mu> \<in> D"
>     using \<mu> fun_hD by auto
>   moreover have "Ord (h \<mu>)"
>     using \<open>D \<subseteq> ON\<close> * by blast
>   ultimately have "\<mu> \<le> h \<mu>"
>     by (simp add: \<mu>_def Ord_Least_le)
>   then show False
>     using \<mu> by blast
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/ZFC_in_HOL/ZFC_Library.thy ../../AFPs/afp-2020/thys/ZFC_in_HOL/ZFC_Library.thy
6,126c6
< text\<open>These are a mixture of results that mostly deserve to be installed in the main Isabelle/HOL libraries.\<close>
< 
< (*REPLACE*)
< notation Sup ("\<Squnion>")
< context conditionally_complete_lattice
< begin
< lemma cSUP_subset_mono: "A \<noteq> {} \<Longrightarrow> bdd_above (g ` B) \<Longrightarrow> A \<subseteq> B \<Longrightarrow> (\<And>x. x \<in> A \<Longrightarrow> f x \<le> g x) \<Longrightarrow> \<Squnion>(f ` A) \<le> \<Squnion>(g ` B)"
<   by (rule cSUP_mono) auto
< end
< 
< lemma lepoll_refl [iff]: "A \<lesssim> A"
<   by (simp add: subset_imp_lepoll)
< 
< lemma empty_lepoll [iff]: "{} \<lesssim> A"
<   by (simp add: lepoll_iff)
< 
< lemma lepoll_Pow_self: "A \<lesssim> Pow A"
<   unfolding lepoll_def inj_def
<   proof (intro exI conjI)
<     show "inj_on (\<lambda>x. {x}) A"
<       by (auto simp: inj_on_def)
< qed auto
< 
< lemma lesspoll_Pow_self: "A \<prec> Pow A"
<   unfolding lesspoll_def
<   by (meson lepoll_Pow_self Cantors_paradox bij_betw_def eqpoll_def)
< 
< lemma eqpoll_refl [iff]: "A \<approx> A"
<   by (simp add: lepoll_antisym subset_imp_lepoll)
< 
< lemma inj_on_image_eqpoll_self: "inj_on f A \<Longrightarrow> f ` A \<approx> A"
<   by (meson bij_betw_def eqpoll_def eqpoll_sym)
< 
< lemma inj_on_image_lepoll_1 [simp]:
<   assumes "inj_on f A" shows "f ` A \<lesssim> B \<longleftrightarrow> A \<lesssim> B"
<   by (meson assms image_lepoll lepoll_def lepoll_trans order_refl)
< 
< lemma inj_on_image_lepoll_2 [simp]:
<   assumes "inj_on f B" shows "A \<lesssim> f ` B \<longleftrightarrow> A \<lesssim> B"
<   by (meson assms eq_iff image_lepoll lepoll_def lepoll_trans)
< 
< lemma inj_on_image_lesspoll_1 [simp]:
<   assumes "inj_on f A" shows "f ` A \<prec> B \<longleftrightarrow> A \<prec> B"
<   by (meson assms image_lepoll le_less lepoll_def lesspoll_trans1)
< 
< lemma inj_on_image_lesspoll_2 [simp]:
<   assumes "inj_on f B" shows "A \<prec> f ` B \<longleftrightarrow> A \<prec> B"
<   by (meson assms eqpoll_sym inj_on_image_eqpoll_self lesspoll_eq_trans)
< 
< lemma inj_on_image_eqpoll_1 [simp]:
<   assumes "inj_on f A" shows "f ` A \<approx> B \<longleftrightarrow> A \<approx> B"
<   by (metis assms eqpoll_trans inj_on_image_eqpoll_self eqpoll_sym)
< 
< lemma inj_on_image_eqpoll_2 [simp]:
<   assumes "inj_on f B" shows "A \<approx> f ` B \<longleftrightarrow> A \<approx> B"
<   by (metis assms inj_on_image_eqpoll_1 eqpoll_sym)
< 
< lemma times_square_lepoll: "A \<lesssim> A \<times> A"
<   unfolding lepoll_def inj_def
< proof (intro exI conjI)
<   show "inj_on (\<lambda>x. (x,x)) A"
<     by (auto simp: inj_on_def)
< qed auto
< 
< lemma times_commute_eqpoll: "A \<times> B \<approx> B \<times> A"
<   unfolding eqpoll_def
<   by (force intro: bij_betw_byWitness [where f = "\<lambda>(x,y). (y,x)" and f' = "\<lambda>(x,y). (y,x)"])
< 
< lemma times_assoc_eqpoll: "(A \<times> B) \<times> C \<approx> A \<times> (B \<times> C)"
<   unfolding eqpoll_def
<   by (force intro: bij_betw_byWitness [where f = "\<lambda>((x,y),z). (x,(y,z))" and f' = "\<lambda>(x,(y,z)). ((x,y),z)"])
< 
< lemma times_singleton_eqpoll: "{a} \<times> A \<approx> A"
< proof -
<   have "{a} \<times> A = (\<lambda>x. (a,x)) ` A"
<     by auto
<   also have "\<dots>  \<approx> A"
<     proof (rule inj_on_image_eqpoll_self)
<       show "inj_on (Pair a) A"
<         by (auto simp: inj_on_def)
<     qed
<     finally show ?thesis .
< qed
< 
< 
< lemma Union_eqpoll_Times:
<   assumes B: "\<And>x. x \<in> A \<Longrightarrow> F x \<approx> B" and disj: "pairwise (\<lambda>x y. disjnt (F x) (F y)) A"
<   shows "(\<Union>x\<in>A. F x) \<approx> A \<times> B"
< proof (rule lepoll_antisym)
<   obtain b where b: "\<And>x. x \<in> A \<Longrightarrow> bij_betw (b x) (F x) B"
<     using B unfolding eqpoll_def by metis
<   show "\<Union>(F ` A) \<lesssim> A \<times> B"
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     define \<chi> where "\<chi> \<equiv> \<lambda>z. THE x. x \<in> A \<and> z \<in> F x"
<     have \<chi>: "\<chi> z = x" if "x \<in> A" "z \<in> F x" for x z
<       unfolding \<chi>_def
<       apply (rule the_equality)
<       apply (simp add: that)
<       by (metis disj disjnt_iff pairwiseD that)
<     let ?f = "\<lambda>z. (\<chi> z, b (\<chi> z) z)"
<     show "inj_on ?f (\<Union>(F ` A))"
<       unfolding inj_on_def
<       by clarify (metis \<chi> b bij_betw_inv_into_left)
<     show "?f ` \<Union>(F ` A) \<subseteq> A \<times> B"
<       using \<chi> b bij_betwE by blast
<   qed
<   show "A \<times> B \<lesssim> \<Union>(F ` A)"
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     let ?f = "\<lambda>(x,y). inv_into (F x) (b x) y"
<     have *: "inv_into (F x) (b x) y \<in> F x" if "x \<in> A" "y \<in> B" for x y
<       by (metis b bij_betw_imp_surj_on inv_into_into that)
<     then show "inj_on ?f (A \<times> B)"
<       unfolding inj_on_def
<       by clarsimp (metis (mono_tags, lifting) b bij_betw_inv_into_right disj disjnt_iff pairwiseD)
<     show "?f ` (A \<times> B) \<subseteq> \<Union> (F ` A)"
<       by clarsimp (metis b bij_betw_imp_surj_on inv_into_into)
<   qed
< qed
< 
---
> text\<open>Equipollence and Lists.\<close>
135,332d14
< lemma finite_lepoll_infinite:
<   assumes "infinite A" "finite B" shows "B \<lesssim> A"
< proof -
<   have "B \<lesssim> (UNIV::nat set)"
<     unfolding lepoll_def
<     using finite_imp_inj_to_nat_seg [OF \<open>finite B\<close>] by blast
<   then show ?thesis
<     using \<open>infinite A\<close> infinite_le_lepoll lepoll_trans by auto
< qed
< 
< lemma finite_lesspoll_infinite:
<   assumes "infinite A" "finite B" shows "B \<prec> A"
<   by (meson assms eqpoll_finite_iff finite_lepoll_infinite lesspoll_def)
< 
< 
< lemma infinite_insert_lepoll:
<   assumes "infinite A" shows "insert a A \<lesssim> A"
< proof -
<   obtain f :: "nat \<Rightarrow> 'a" where "inj f" and f: "range f \<subseteq> A"
<     using assms infinite_countable_subset by blast
<   let ?g = "(\<lambda>z. if z=a then f 0 else if z \<in> range f then f (Suc (inv f z)) else z)"
<   show ?thesis
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     show "inj_on ?g (insert a A)"
<       using inj_on_eq_iff [OF \<open>inj f\<close>]
<       by (auto simp: inj_on_def)
<     show "?g ` insert a A \<subseteq> A"
<       using f by auto
<   qed
< qed
< 
< lemma infinite_insert_eqpoll: "infinite A \<Longrightarrow> insert a A \<approx> A"
<   by (simp add: lepoll_antisym infinite_insert_lepoll subset_imp_lepoll subset_insertI)
< 
< 
< lemma Un_lepoll_mono:
<   assumes "A \<lesssim> C" "B \<lesssim> D" "disjnt C D" shows "A \<union> B \<lesssim> C \<union> D"
< proof -
<   obtain f g where inj: "inj_on f A" "inj_on g B" and fg: "f ` A \<subseteq> C" "g ` B \<subseteq> D"
<     by (meson assms lepoll_def)
<   have "inj_on (\<lambda>x. if x \<in> A then f x else g x) (A \<union> B)"
<     using inj \<open>disjnt C D\<close> fg unfolding disjnt_iff
<     by (fastforce intro: inj_onI dest: inj_on_contraD split: if_split_asm)
<   with fg show ?thesis
<     unfolding lepoll_def
<     by (rule_tac x="\<lambda>x. if x \<in> A then f x else g x" in exI) auto
< qed
< 
< lemma Un_eqpoll_cong: "\<lbrakk>A \<approx> C; B \<approx> D; disjnt A B; disjnt C D\<rbrakk> \<Longrightarrow> A \<union> B \<approx> C \<union> D"
<   by (meson Un_lepoll_mono eqpoll_imp_lepoll eqpoll_sym lepoll_antisym)
< 
< lemma sum_lepoll_mono:
<   assumes "A \<lesssim> C" "B \<lesssim> D" shows "A <+> B \<lesssim> C <+> D"
< proof -
<   obtain f g where "inj_on f A" "f ` A \<subseteq> C" "inj_on g B" "g ` B \<subseteq> D"
<     by (meson assms lepoll_def)
<   then show ?thesis
<     unfolding lepoll_def
<     by (rule_tac x="case_sum (Inl \<circ> f) (Inr \<circ> g)" in exI) (force simp: inj_on_def)
< qed
< 
< lemma sum_eqpoll_cong: "\<lbrakk>A \<approx> C; B \<approx> D\<rbrakk> \<Longrightarrow> A <+> B \<approx> C <+> D"
<   by (meson eqpoll_imp_lepoll eqpoll_sym lepoll_antisym sum_lepoll_mono)
< 
< lemma Sigma_lepoll_mono:
<   assumes "A \<subseteq> C" "\<And>x. x \<in> A \<Longrightarrow> B x \<lesssim> D x" shows "Sigma A B \<lesssim> Sigma C D"
< proof -
<   have "\<And>x. x \<in> A \<Longrightarrow> \<exists>f. inj_on f (B x) \<and> f ` (B x) \<subseteq> D x"
<     by (meson assms lepoll_def)
<   then obtain f where  "\<And>x. x \<in> A \<Longrightarrow> inj_on (f x) (B x) \<and> f x ` B x \<subseteq> D x"
<     by metis
<   with \<open>A \<subseteq> C\<close> show ?thesis
<     unfolding lepoll_def inj_on_def
<     by (rule_tac x="\<lambda>(x,y). (x, f x y)" in exI) force
< qed
< 
< lemma times_lepoll_mono:
<   assumes "A \<lesssim> C" "B \<lesssim> D" shows "A \<times> B \<lesssim> C \<times> D"
< proof -
<   obtain f g where "inj_on f A" "f ` A \<subseteq> C" "inj_on g B" "g ` B \<subseteq> D"
<     by (meson assms lepoll_def)
<   then show ?thesis
<     unfolding lepoll_def
<     by (rule_tac x="\<lambda>(x,y). (f x, g y)" in exI) (auto simp: inj_on_def)
< qed
< 
< lemma times_eqpoll_cong: "\<lbrakk>A \<approx> C; B \<approx> D\<rbrakk> \<Longrightarrow> A \<times> B \<approx> C \<times> D"
<   by (metis eqpoll_imp_lepoll eqpoll_sym lepoll_antisym times_lepoll_mono)
< 
< lemma
<   assumes "B \<noteq> {}" shows lepoll_times1: "A \<lesssim> A \<times> B" and lepoll_times2:  "A \<lesssim> B \<times> A"
<   using assms lepoll_iff by fastforce+
< 
< 
< lemma times_0_eqpoll: "{} \<times> A \<approx> {}"
<   by (simp add: eqpoll_iff_bijections)
< 
< lemma sum_times_distrib_eqpoll: "(A <+> B) \<times> C \<approx> (A \<times> C) <+> (B \<times> C)"
<   unfolding eqpoll_def
< proof
<   show "bij_betw (\<lambda>(x,z). case_sum(\<lambda>y. Inl(y,z)) (\<lambda>y. Inr(y,z)) x) ((A <+> B) \<times> C) (A \<times> C <+> B \<times> C)"
<     by (rule bij_betw_byWitness [where f' = "case_sum (\<lambda>(x,z). (Inl x, z)) (\<lambda>(y,z). (Inr y, z))"]) auto
< qed
< 
< lemma prod_insert_eqpoll:
<   assumes "a \<notin> A" shows "insert a A \<times> B \<approx> B <+> A \<times> B"
<   unfolding eqpoll_def
<   proof
<   show "bij_betw (\<lambda>(x,y). if x=a then Inl y else Inr (x,y)) (insert a A \<times> B) (B <+> A \<times> B)"
<     by (rule bij_betw_byWitness [where f' = "case_sum (\<lambda>y. (a,y)) id"]) (auto simp: assms)
< qed
< 
< lemma insert_lepoll_insertD:
<   assumes "insert u A \<lesssim> insert v B" "u \<notin> A" "v \<notin> B" shows "A \<lesssim> B"
< proof -
<   obtain f where inj: "inj_on f (insert u A)" and fim: "f ` (insert u A) \<subseteq> insert v B"
<     by (meson assms lepoll_def)
<   show ?thesis
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     let ?g = "\<lambda>x\<in>A. if f x = v then f u else f x"
<     show "inj_on ?g A"
<       using inj \<open>u \<notin> A\<close> by (auto simp: inj_on_def)
<     show "?g ` A \<subseteq> B"
<       using fim \<open>u \<notin> A\<close> image_subset_iff inj inj_on_image_mem_iff by fastforce
<   qed
< qed
< 
< lemma insert_eqpoll_insertD: "\<lbrakk>insert u A \<approx> insert v B; u \<notin> A; v \<notin> B\<rbrakk> \<Longrightarrow> A \<approx> B"
<   by (meson insert_lepoll_insertD eqpoll_imp_lepoll eqpoll_sym lepoll_antisym)
< 
< lemma insert_lepoll_cong:
<   assumes "A \<lesssim> B" "b \<notin> B" shows "insert a A \<lesssim> insert b B"
< proof -
<   obtain f where f: "inj_on f A" "f ` A \<subseteq> B"
<     by (meson assms lepoll_def)
<   let ?f = "\<lambda>u \<in> insert a A. if u=a then b else f u"
<   show ?thesis
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     show "inj_on ?f (insert a A)"
<       using f \<open>b \<notin> B\<close> by (auto simp: inj_on_def)
<     show "?f ` insert a A \<subseteq> insert b B"
<       using f \<open>b \<notin> B\<close> by auto
<   qed
< qed
< 
< lemma insert_eqpoll_cong:
<      "\<lbrakk>A \<approx> B; a \<notin> A; b \<notin> B\<rbrakk> \<Longrightarrow> insert a A \<approx> insert b B"
<   apply (rule lepoll_antisym)
<   apply (simp add: eqpoll_imp_lepoll insert_lepoll_cong)+
<   by (meson eqpoll_imp_lepoll eqpoll_sym insert_lepoll_cong)
< 
< lemma insert_eqpoll_insert_iff:
<      "\<lbrakk>a \<notin> A; b \<notin> B\<rbrakk> \<Longrightarrow> insert a A \<approx> insert b B  \<longleftrightarrow>  A \<approx> B"
<   by (meson insert_eqpoll_insertD insert_eqpoll_cong)
< 
< lemma insert_lepoll_insert_iff:
<      " \<lbrakk>a \<notin> A; b \<notin> B\<rbrakk> \<Longrightarrow> (insert a A \<lesssim> insert b B) \<longleftrightarrow> (A \<lesssim> B)"
<   by (meson insert_lepoll_insertD insert_lepoll_cong)
< 
< lemma less_imp_insert_lepoll:
<   assumes "A \<prec> B" shows "insert a A \<lesssim> B"
< proof -
<   obtain f where "inj_on f A" "f ` A \<subset> B"
<     using assms by (metis bij_betw_def eqpoll_def lepoll_def lesspoll_def psubset_eq)
<   then obtain b where b: "b \<in> B" "b \<notin> f ` A"
<     by auto
<   show ?thesis
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     show "inj_on (f(a:=b)) (insert a A)"
<       using b \<open>inj_on f A\<close> by (auto simp: inj_on_def)
<     show "(f(a:=b)) ` insert a A \<subseteq> B"
<       using \<open>f ` A \<subset> B\<close>  by (auto simp: b)
<   qed
< qed
< 
< lemma finite_insert_lepoll: "finite A \<Longrightarrow> (insert a A \<lesssim> A) \<longleftrightarrow> (a \<in> A)"
< proof (induction A rule: finite_induct)
<   case (insert x A)
<   then show ?case
<     apply (auto simp: insert_absorb)
<     by (metis insert_commute insert_iff insert_lepoll_insertD)
< qed auto
< 
< 
< lemma lists_lepoll_mono:
<   assumes "A \<lesssim> B" shows "lists A \<lesssim> lists B"
< proof -
<   obtain f where "inj_on f A" "f ` A \<subseteq> B"
<     by (meson assms lepoll_def)
<   then show ?thesis
<     unfolding lepoll_def
<     by (rule_tac x="map f" in exI) (simp add: inj_on_map_lists map_lists_mono)
< qed
< 
345d26
< 
377,379d57
< lemma lepoll_lists: "A \<lesssim> lists A"
<   unfolding lepoll_def inj_on_def by(rule_tac x="\<lambda>x. [x]" in exI) auto
< 
394,428d71
< qed
< 
< 
< lemma UN_lepoll_UN:
<   assumes A: "\<And>x. x \<in> A \<Longrightarrow> B x \<lesssim> C x"
<     and disj: "pairwise (\<lambda>x y. disjnt (C x) (C y)) A"
<   shows "\<Union> (B`A) \<lesssim> \<Union> (C`A)"
< proof -
<   obtain f where f: "\<And>x. x \<in> A \<Longrightarrow> inj_on (f x) (B x) \<and> f x ` (B x) \<subseteq> (C x)"
<     using A unfolding lepoll_def by metis
<   show ?thesis
<     unfolding lepoll_def
<   proof (intro exI conjI)
<     define \<chi> where "\<chi> \<equiv> \<lambda>z. @x. x \<in> A \<and> z \<in> B x"
<     have \<chi>: "\<chi> z \<in> A \<and> z \<in> B (\<chi> z)" if "x \<in> A" "z \<in> B x" for x z
<       unfolding \<chi>_def by (metis (mono_tags, lifting) someI_ex that)
<     let ?f = "\<lambda>z. (f (\<chi> z) z)"
<     show "inj_on ?f (\<Union>(B ` A))"
<       using disj f unfolding inj_on_def disjnt_iff pairwise_def image_subset_iff
<       by (metis UN_iff \<chi>)
<     show "?f ` \<Union> (B ` A) \<subseteq> \<Union> (C ` A)"
<       using \<chi> f unfolding image_subset_iff by blast
<   qed
< qed
< 
< lemma UN_eqpoll_UN:
<   assumes A: "\<And>x. x \<in> A \<Longrightarrow> B x \<approx> C x"
<     and B: "pairwise (\<lambda>x y. disjnt (B x) (B y)) A"
<     and C: "pairwise (\<lambda>x y. disjnt (C x) (C y)) A"
<   shows "(\<Union>x\<in>A. B x) \<approx> (\<Union>x\<in>A. C x)"
< proof (rule lepoll_antisym)
<   show "\<Union> (B ` A) \<lesssim> \<Union> (C ` A)"
<     by (meson A C UN_lepoll_UN eqpoll_imp_lepoll)
<   show "\<Union> (C ` A) \<lesssim> \<Union> (B ` A)"
<     by (simp add: A B UN_lepoll_UN eqpoll_imp_lepoll eqpoll_sym)
diff -r -x ROOT -x root.tex -x root.bib ../../AFPs/afp-2019/thys/ZFC_in_HOL/ZFC_Typeclasses.thy ../../AFPs/afp-2020/thys/ZFC_in_HOL/ZFC_Typeclasses.thy
4c4
<   imports ZFC_Cardinals
---
>   imports ZFC_Cardinals Complex_Main
71c71
<   have "inj (case_option 0 (\<lambda>x. set{V_of x}))" if "inj V_of"
---
>   have "inj (case_option 0 (\<lambda>x. ZFC_in_HOL.set{V_of x}))" if "inj V_of"
130c130
<   assumes small: "\<exists>V_of :: 'a \<Rightarrow> V. \<exists>A. inj V_of \<and> range V_of \<le> (elts A)"
---
>   assumes small: "small (UNIV::'a set)"
133,134c133,139
<  subclass embeddable
<    by intro_classes (use small in metis)
---
> subclass embeddable
>   by intro_classes (meson local.small small_def)
> 
> lemma TC_small [iff]:
>   fixes A :: "'a set"
>   shows "small A"
>   using small smaller_than_small by blast
147,148c152
<     apply intro_classes
<     by (metis VPow_iff * fun.set_map image_subset_iff local.ex_inj ord_of_nat_le_omega)
---
>     by intro_classes (metis small_image_nat local.ex_inj the_inv_into_onto)
153d156
< 
155c158
<   by (metis down inj_on_image_eqpoll_self lepoll_def lepoll_trans order_refl small small_eqcong small_iff)
---
>   by (meson lepoll_iff replacement small smaller_than_small)
179,180c182,187
<   then show "OFCLASS('a \<times> 'b, small_class)"
<     by intro_classes (meson small)
---
>   with small [where 'a='a] small [where 'a='b]
>   show "OFCLASS('a \<times> 'b, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis down_raw dual_order.refl)
190,191c197,202
<   then show "OFCLASS('a + 'b, small_class)"
<     by intro_classes (meson small)
---
>   with small [where 'a='a] small [where 'a='b]
>   show "OFCLASS('a + 'b, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis down_raw dual_order.refl)
196,197c207,208
<   have "inj (\<lambda>x. case x of None \<Rightarrow> 0 | Some x \<Rightarrow> set {V_of x})"
<        "range (\<lambda>x. case x of None \<Rightarrow> 0 | Some x \<Rightarrow> set {V_of x}) \<le> insert 0 (elts (VPow A))"
---
>   have "inj (\<lambda>x. case x of None \<Rightarrow> 0 | Some x \<Rightarrow> ZFC_in_HOL.set {V_of x})"
>        "range (\<lambda>x. case x of None \<Rightarrow> 0 | Some x \<Rightarrow> ZFC_in_HOL.set {V_of x}) \<le> insert 0 (elts (VPow A))"
201,202c212,217
<   then show "OFCLASS('a option, small_class)"
<     by intro_classes (metis elts_vinsert small)
---
>   with small [where 'a='a]
>   show "OFCLASS('a option, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis down_raw elts_vinsert subset_insertI)
232,233c247,252
<   then show "OFCLASS('a list, small_class)"
<     by intro_classes (metis inj_V_of_list order_refl small small_iff)
---
>   with small [where 'a='a]
>   show "OFCLASS('a list, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis inj_V_of_list order_refl small_def small_iff_range)
250,251c269
<     apply intro_classes
<     using embeddable_class.ex_inj small by auto
---
>     by intro_classes (metis embeddable_class.ex_inj small order_refl replacement small_iff)
270,271c288,293
<   then show "OFCLASS('a \<Rightarrow> 'b, small_class)"
<     by intro_classes (meson small)
---
>   with small [where 'a='a] small [where 'a='b]
>   show "OFCLASS('a \<Rightarrow> 'b, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis down_raw dual_order.refl)
272a295,327
> 
> instance set :: (small) small 
> proof -
>   have 1: "inj (\<lambda>x. ZFC_in_HOL.set (V_of ` x))"
>     if "inj V_of" for V_of :: "'a \<Rightarrow> V" 
>     by (simp add: inj_on_def inj_image_eq_iff [OF that])
>   have 2: "range (\<lambda>x. ZFC_in_HOL.set (V_of ` x)) \<le> elts (VPow A)"
>     if "range V_of \<le> elts A" for V_of :: "'a \<Rightarrow> V" and A
>     using that by (auto simp: inj_on_def image_subset_iff)
>   from small [where 'a='a]
>   show "OFCLASS('a set, small_class)"
>     apply intro_classes
>     unfolding small_def
>     apply clarify
>     by (metis 1 2 down_raw subsetI)
> qed
> 
> instance real :: small 
> proof -
>   have "small (range (Rep_real))"
>     by simp
>   then show "OFCLASS(real, small_class)"
>     by intro_classes (metis Rep_real_inverse image_inv_f_f inj_on_def replacement)
> qed
> 
> instance complex :: small 
> proof -
>   have "\<And>c. c \<in> range (\<lambda>(x,y). Complex x y)"
>     by (metis case_prod_conv complex.exhaust_sel rangeI)
>   then show "OFCLASS(complex, small_class)"
>     by intro_classes (meson TC_small replacement smaller_than_small subset_eq)
> qed
> 
